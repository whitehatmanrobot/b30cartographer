eturn Value:

    TRUE - The checksum stored in the image matches the checksum of the data.

    FALSE - The checksum in the image is not correct.

--*/

{

    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    ULONG HeaderSum;
    ULONG CheckSum;

    RTL_PAGED_CODE();

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    HeaderSum = 0;
    PartialSum = ChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

    NtHeaders = RtlImageNtHeader(BaseAddress);
    if (NtHeaders != NULL) {
        HeaderSum = NtHeaders->OptionalHeader.CheckSum;

#ifndef NTOS_KERNEL_RUNTIME
        //
        // On Nt 3.1 and 3.5, we allowed printer drivers with 0 checksums into
        // csrss unintentionally. This means that we must allow this forever.
        // I don't want to allow this for kernel mode drivers, so I will only
        // allow 0 checksums of the high order bit is clear ?
        //


        if ( HeaderSum == 0 ) {
            return TRUE;
        }
#endif // NTOS_KERNEL_RUNTIME

        AdjustSum = (PUSHORT)(&NtHeaders->OptionalHeader.CheckSum);
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    } else {
        PartialSum = 0;
        HeaderSum = FileLength;
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    CheckSum = (ULONG)PartialSum + FileLength;
    return (CheckSum == HeaderSum);
}



ULONG32
RtlComputeCrc32(
    ULONG32 PartialCrc,
    PUCHAR Buffer,
    ULONG Length
    )

/*++

Routine Description:

    Compute the CRC32 as specified in in IS0 3309. See RFC-1662 and RFC-1952
    for implementation details and references.

    Pre- and post-conditioning (one's complement) is done by this function, so
    it should not be done by the caller. That is, do:

        Crc = RtlComputeCrc32 ( 0, buffer, length );

    instead of

        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length );

    or
        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length) ^ 0xffffffff;


Arguments:

    PartialCrc - A partially calculated CRC32.

    Buffer - The buffer you want to CRC.

    Length - The length of the buffer in bytes.

Return Value:

    The updated CRC32 value.

Environment:

    Kernel mode at IRQL of APC_LEVEL or below, User mode, or within
    the boot-loader.

--*/



{
    ULONG32 Crc;
    ULONG i;


    RTL_PAGED_CODE ();

    //
    // Compute the CRC32 checksum.
    //

    Crc = PartialCrc ^ 0xffffffffL;

    for (i = 0; i < Length; i++) {
        Crc = RtlCrc32Table [(Crc ^ Buffer [ i ]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\compress.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    compress.c

Abstract:

    This module implements the NT Rtl compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:

--*/

#include "ntrtlp.h"


//
//  The following arrays hold procedures that we call to do the various
//  compression functions.  Each new compression function will need to
//  be added to this array.  For one that are currently not supported
//  we will fill in a not supported routine.
//

NTSTATUS
RtlCompressWorkSpaceSizeNS (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
RtlCompressBufferNS (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDecompressBufferNS (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
RtlDecompressFragmentNS (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDescribeChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
RtlReserveChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGELKCONST")
#endif

//
//  Routines to query the amount of memory needed for each workspace
//

const PRTL_COMPRESS_WORKSPACE_SIZE RtlWorkSpaceProcs[8] = {
    NULL,                          // 0
    NULL,                          // 1
    RtlCompressWorkSpaceSizeLZNT1, // 2
    RtlCompressWorkSpaceSizeNS,    // 3
    RtlCompressWorkSpaceSizeNS,    // 4
    RtlCompressWorkSpaceSizeNS,    // 5
    RtlCompressWorkSpaceSizeNS,    // 6
    RtlCompressWorkSpaceSizeNS     // 7
};

//
//  Routines to compress a buffer
//

const PRTL_COMPRESS_BUFFER RtlCompressBufferProcs[8] = {
    NULL,                   // 0
    NULL,                   // 1
    RtlCompressBufferLZNT1, // 2
    RtlCompressBufferNS,    // 3
    RtlCompressBufferNS,    // 4
    RtlCompressBufferNS,    // 5
    RtlCompressBufferNS,    // 6
    RtlCompressBufferNS     // 7
};

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif

//
//  Routines to decompress a buffer
//

const PRTL_DECOMPRESS_BUFFER RtlDecompressBufferProcs[8] = {
    NULL,                     // 0
    NULL,                     // 1
    RtlDecompressBufferLZNT1, // 2
    RtlDecompressBufferNS,    // 3
    RtlDecompressBufferNS,    // 4
    RtlDecompressBufferNS,    // 5
    RtlDecompressBufferNS,    // 6
    RtlDecompressBufferNS     // 7
};

//
//  Routines to decompress a fragment
//

const PRTL_DECOMPRESS_FRAGMENT RtlDecompressFragmentProcs[8] = {
    NULL,                       // 0
    NULL,                       // 1
    RtlDecompressFragmentLZNT1, // 2
    RtlDecompressFragmentNS,    // 3
    RtlDecompressFragmentNS,    // 4
    RtlDecompressFragmentNS,    // 5
    RtlDecompressFragmentNS,    // 6
    RtlDecompressFragmentNS     // 7
};

//
//  Routines to describe the current chunk
//

const PRTL_DESCRIBE_CHUNK RtlDescribeChunkProcs[8] = {
    NULL,                  // 0
    NULL,                  // 1
    RtlDescribeChunkLZNT1, // 2
    RtlDescribeChunkNS,    // 3
    RtlDescribeChunkNS,    // 4
    RtlDescribeChunkNS,    // 5
    RtlDescribeChunkNS,    // 6
    RtlDescribeChunkNS     // 7
};

//
//  Routines to reserve for a chunk
//

const PRTL_RESERVE_CHUNK RtlReserveChunkProcs[8] = {
    NULL,                 // 0
    NULL,                 // 1
    RtlReserveChunkLZNT1, // 2
    RtlReserveChunkNS,    // 3
    RtlReserveChunkNS,    // 4
    RtlReserveChunkNS,    // 5
    RtlReserveChunkNS,    // 6
    RtlReserveChunkNS     // 7
};

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

//
// N.B. The two functions below are placed in the PAGELK section
//      because they need to be locked down in memory during Hibernation,
//      since they are used to enable compression of the Hiberfile.
//

#pragma alloc_text(PAGELK, RtlGetCompressionWorkSpaceSize)
#pragma alloc_text(PAGELK, RtlCompressBuffer)

#pragma alloc_text(PAGE, RtlDecompressChunks)
#pragma alloc_text(PAGE, RtlCompressChunks)
#pragma alloc_text(PAGE, RtlDecompressBuffer)
#pragma alloc_text(PAGE, RtlDecompressFragment)
#pragma alloc_text(PAGE, RtlDescribeChunk)
#pragma alloc_text(PAGE, RtlReserveChunk)
#pragma alloc_text(PAGE, RtlCompressWorkSpaceSizeNS)
#pragma alloc_text(PAGE, RtlCompressBufferNS)
#pragma alloc_text(PAGE, RtlDecompressBufferNS)
#pragma alloc_text(PAGE, RtlDecompressFragmentNS)
#pragma alloc_text(PAGE, RtlDescribeChunkNS)
#pragma alloc_text(PAGE, RtlReserveChunkNS)
#endif


NTSTATUS
RtlGetCompressionWorkSpaceSize (
    IN USHORT CompressionFormatAndEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )


/*++

Routine Description:

    This routine returns to the caller the size in bytes of the
    different work space buffers need to perform the compression

Arguments:

    CompressionFormatAndEngine - Supplies the format and engine
        specification for the compressed data.

    CompressBufferWorkSpaceSize - Receives the size in bytes needed
        to compress a buffer.

    CompressBufferWorkSpaceSize - Receives the size in bytes needed
        to decompress a fragment.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format and engine specification
    //

    USHORT Format = CompressionFormatAndEngine & 0x00ff;
    USHORT Engine = CompressionFormatAndEngine & 0xff00;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the routine to return the workspace sizes.
    //

    return RtlWorkSpaceProcs[ Format ]( Engine,
                                        CompressBufferWorkSpaceSize,
                                        CompressFragmentWorkSpaceSize );
}


NTSTATUS
RtlCompressBuffer (
    IN USHORT CompressionFormatAndEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

Arguments:

    CompressionFormatAndEngine - Supplies the format and engine
        specification for the compressed data.

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Supplies the chunk size to use when
        compressing the input buffer.  The only valid values are
        512, 1024, 2048, and 4096.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format and engine specification
    //

    USHORT Format = CompressionFormatAndEngine & 0x00ff;
    USHORT Engine = CompressionFormatAndEngine & 0xff00;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlCompressBufferProcs[ Format ]( Engine,
                                             UncompressedBuffer,
                                             UncompressedBufferSize,
                                             CompressedBuffer,
                                             CompressedBufferSize,
                                             UncompressedChunkSize,
                                             FinalCompressedSize,
                                             WorkSpace );
}


NTSTATUS
RtlDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and produces
    its uncompressed equivalent provided the uncompressed data fits
    within the specified destination buffer.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed data.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlDecompressBufferProcs[ Format ]( UncompressedBuffer,
                                               UncompressedBufferSize,
                                               CompressedBuffer,
                                               CompressedBufferSize,
                                               FinalUncompressedSize );
}


NTSTATUS
RtlDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and extract an
    uncompressed fragment.

    Output bytes are copied to the fragment buffer until either the
    fragment buffer is full or the end of the uncompressed buffer is
    reached.

    An output variable indicates the number of bytes used to store the
    uncompressed fragment.

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    UncompressedFragment - Supplies a pointer to where the uncompressed
        fragment is to be stored.

    UncompressedFragmentSize - Supplies the size, in bytes, of the
        uncompressed fragment buffer.

    CompressedBuffer - Supplies a pointer to the compressed data buffer.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FragmentOffset - Supplies the offset (zero based) where the uncompressed
        fragment is being extract from.  The offset is the position within
        the original uncompressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the Uncompressed fragment buffer to store the data.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlDecompressFragmentProcs[ Format ]( UncompressedFragment,
                                                 UncompressedFragmentSize,
                                                 CompressedBuffer,
                                                 CompressedBufferSize,
                                                 FragmentOffset,
                                                 FinalUncompressedSize,
                                                 WorkSpace );
}


NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and returns
    a description of the current chunk in that buffer, updating
    the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Receives the size of the current chunk pointed
        to by CompressedBuffer.  Returns 0 if STATUS_NO_MORE_ENTRIES.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

    STATUS_NO_MORE_ENTRIES - There is no chunk at the current pointer.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlDescribeChunkProcs[ Format ]( CompressedBuffer,
                                            EndOfCompressedBufferPlus1,
                                            ChunkBuffer,
                                            ChunkSize );
}


NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and reserves
    space for a chunk of the specified size - filling in any pattern
    as is necessary for a chunk of that size.  On return it has
    updated the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressionFormat - Supplies the format of the compressed data.

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Supplies the compressed size of the chunk to be received.
                Two special values are 0, and whatever the maximum
                uncompressed chunk size is for the routine.  0 means
                the chunk should be filled with a pattern that equates
                to all 0's.  The maximum chunk size implies that the
                compression routine should prepare to receive all of the
                data in uncompressed form.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    //
    //  Declare two variables to hold the format specification
    //

    USHORT Format = CompressionFormat & 0x00ff;

    //
    //  make sure the format is sort of supported
    //

    if ((Format == COMPRESSION_FORMAT_NONE) || (Format == COMPRESSION_FORMAT_DEFAULT)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Format & 0x00f0) {

        return STATUS_UNSUPPORTED_COMPRESSION;
    }

    //
    //  Call the compression routine for the individual format
    //

    return RtlReserveChunkProcs[ Format ]( CompressedBuffer,
                                           EndOfCompressedBufferPlus1,
                                           ChunkBuffer,
                                           ChunkSize );
}


NTSTATUS
RtlDecompressChunks (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN PUCHAR CompressedTail,
    IN ULONG CompressedTailSize,
    IN PCOMPRESSED_DATA_INFO CompressedDataInfo
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer which is a stream
    of chunks and decompresses it into the specified destination buffer.
    The compressed data may be in two pieces, such that the "tail" of
    the buffer is top aligned in the buffer at CompressedTail, and the
    rest of the data is top aligned in the CompressedBuffer.  The
    CompressedBuffer can overlap and be top-aligned in the UncompressedBuffer,
    to allow something close to in-place decompression.  The CompressedTail
    must be large enough to completely contain the final chunk and it
    chunk header.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data, part 1.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    CompressedTail - Supplies a pointer to the compressed data, part 2,
        which must be the bytes immediately following the CompressedBuffer.

    CompressedTailSize - Supplies the size of the CompressedTail.

    CompressedDataInfo - Supplies a complete description of the
        compressed data with all the chunk sizes and compression
        parameters.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_INVALID_PARAMETER - The specified format is illegal

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_UNSUPPORTED_COMPRESSION - the specified compression format and/or engine
        is not support.

--*/

{
    NTSTATUS Status;
    PULONG CurrentCompressedChunkSize;
    ULONG SizeToDecompress, FinalUncompressedSize;
    ULONG ChunksToGo = CompressedDataInfo->NumberOfChunks;
    ULONG UncompressedChunkSize = 1 << CompressedDataInfo->ChunkShift;

    CurrentCompressedChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

    //
    //  Loop to decompress chunks.
    //

    do {

        //
        //  Calculate uncompressed size of next chunk to decompress.
        //

        SizeToDecompress = UncompressedBufferSize;
        if (SizeToDecompress >= UncompressedChunkSize) {
            SizeToDecompress = UncompressedChunkSize;
        }

        //
        //  If the next chunk is all zeros, then zero it.
        //

        if ((ChunksToGo == 0) || (*CurrentCompressedChunkSize == 0)) {

            RtlZeroMemory( UncompressedBuffer, SizeToDecompress );

            //
            //  Test for out of chunks here and set to 1, so we can
            //  unconditionally decrement below.  Also back up the 
            //  CompressedChunkSize pointer because we dereference
            //  it as well.
            //

            if (ChunksToGo == 0) {
                ChunksToGo = 1;
                CurrentCompressedChunkSize -= 1;
            }

        //
        //  If the next chunk is not compressed, just copy it.
        //

        } else if (*CurrentCompressedChunkSize == UncompressedChunkSize) {

            //
            //  Does this chunk extend beyond the end of the current
            //  buffer?  If so, that probably means we can move the
            //  first part of the chunk, and then switch to the Compressed
            //  tail to get the rest.
            //

            if (SizeToDecompress >= CompressedBufferSize) {

                //
                //  If we have already switched to the tail, then this must
                //  be badly formatted compressed data.
                //

                if ((CompressedTailSize == 0) && (SizeToDecompress > CompressedBufferSize)) {
                    return STATUS_BAD_COMPRESSION_BUFFER;
                }

                //
                //  Copy the first part, and then the second part from the tail.
                //  Then switch to make the tail the current buffer.
                //

                RtlCopyMemory( UncompressedBuffer, CompressedBuffer, CompressedBufferSize );
                RtlCopyMemory( UncompressedBuffer + CompressedBufferSize,
                               CompressedTail,
                               SizeToDecompress - CompressedBufferSize );

                //
                //  If we exhausted the first buffer, move into the tail, knowing
                //  that we adjust these pointers by *CurrentCompressedChunkSize
                //  below.
                //

                CompressedBuffer = CompressedTail - CompressedBufferSize;
                CompressedBufferSize = CompressedTailSize + CompressedBufferSize;
                CompressedTailSize = 0;

            //
            //  Otherwise we can just copy the whole chunk.
            //

            } else {
                RtlCopyMemory( UncompressedBuffer, CompressedBuffer, SizeToDecompress );
            }

        //
        //  Otherwise it is a normal chunk to decompress.
        //

        } else {

            //
            //  Does this chunk extend beyond the end of the current
            //  buffer?  If so, that probably means we can move the
            //  first part of the chunk, and then switch to the Compressed
            //  tail to get the rest.  Since the tail must be at least
            //  ChunkSize, the last chunk cannot be the one that is
            //  overlapping into the tail.  Therefore, it is safe for
            //  us to copy the chunk to decompress into the last chunk
            //  of the uncompressed buffer, and decompress it from there.
            //

            if (*CurrentCompressedChunkSize > CompressedBufferSize) {

                //
                //  If we have already switched to the tail, then this must
                //  be badly formatted compressed data.
                //

                if (CompressedTailSize == 0) {
                    return STATUS_BAD_COMPRESSION_BUFFER;
                }

                //
                //  Move the beginning of the chunk to the beginning of the last
                //  chunk in the uncompressed buffer.  This move could overlap.
                //

                RtlMoveMemory( UncompressedBuffer + UncompressedBufferSize - UncompressedChunkSize,
                               CompressedBuffer,
                               CompressedBufferSize );

                //
                //  Move the rest of the chunk from the tail.
                //

                RtlCopyMemory( UncompressedBuffer + UncompressedBufferSize - UncompressedChunkSize + CompressedBufferSize,
                               CompressedTail,
                               *CurrentCompressedChunkSize - CompressedBufferSize );

                //
                //  We temporarily set CompressedBuffer to describe where we
                //  copied the chunk to make the call in common code, then we
                //  switch it into the tail below.
                //

                CompressedBuffer = UncompressedBuffer + UncompressedBufferSize - UncompressedChunkSize;
            }

            //
            //  Attempt the decompress.
            //

            Status =
            RtlDecompressBuffer( CompressedDataInfo->CompressionFormatAndEngine,
                                 UncompressedBuffer,
                                 SizeToDecompress,
                                 CompressedBuffer,
                                 *CurrentCompressedChunkSize,
                                 &FinalUncompressedSize );

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            //  If we did not get a full chunk, zero the rest.
            //

            if (SizeToDecompress > FinalUncompressedSize) {
                RtlZeroMemory( UncompressedBuffer + FinalUncompressedSize,
                               SizeToDecompress - FinalUncompressedSize );
            }

            //
            //  If we exhausted the first buffer, move into the tail, knowing
            //  that we adjust these pointers by *CurrentCompressedChunkSize
            //  below.
            //

            if (*CurrentCompressedChunkSize >= CompressedBufferSize) {
                CompressedBuffer = CompressedTail - CompressedBufferSize;
                CompressedBufferSize = CompressedTailSize + CompressedBufferSize;
                CompressedTailSize = 0;
            }
        }

        //
        //  Update for next possible pass through the loop.
        //

        UncompressedBuffer += SizeToDecompress;
        UncompressedBufferSize -= SizeToDecompress;
        CompressedBuffer += *CurrentCompressedChunkSize;
        CompressedBufferSize -= *CurrentCompressedChunkSize;
        CurrentCompressedChunkSize += 1;
        ChunksToGo -= 1;

    } while (UncompressedBufferSize != 0);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlCompressChunks(
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT PCOMPRESSED_DATA_INFO CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    The desired compression parameters must be supplied via the
    CompressedDataInfo structure, and this structure then returns all
    of the compressed chunk sizes.

    Note that since any given chunk (or all chunks) can simply be
    transmitted uncompressed, all error possibilities are actually
    stopped in this routine, except for STATUS_BUFFER_TOO_SMALL.
    This code will be returned when the data is not compressing
    sufficiently to warrant sending the data compressed.  The caller
    must field this error, and send the data uncompressed.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    CompressedDataInfo - Supplies the compression parameters, such as
        CompressionFormat, CompressionUnitSize, ChunkSize and ClusterSize,
        returns all of the compressed chunk sizes.

    CompressedDataInfoLength - Size of the supplied CompressedDataInfo
        in bytes.

    WorkSpace - A workspace area of the correct size as returned from
        RtlGetCompressionWorkSpaceSize.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_TOO_SMALL - the data is not compressing sufficiently to
        warrant sending the data compressed.

--*/

{
    NTSTATUS Status;
    PULONG CurrentCompressedChunkSize;
    ULONG SizeToCompress, FinalCompressedSize;
    ULONG UncompressedChunkSize = 1 << CompressedDataInfo->ChunkShift;

    //
    //  Make sure CompressedDataInfo is long enough.
    //

    ASSERT(CompressedDataInfoLength >=
           (sizeof(COMPRESSED_DATA_INFO) +
            ((UncompressedBufferSize - 1) >> (CompressedDataInfo->ChunkShift - 2))));

    //
    //  For the worst case, the compressed buffer actually has to be
    //  the same size as the uncompressed buffer, minus 1/16th.  We then
    //  will actually use that size.  If the data is not compressing very
    //  well, it is cheaper for us to actually send the data to the
    //  server uncompressed, than poorly compressed, because if the
    //  data is poorly compressed, the server will end up doing an
    //  extra copy before trying to compress the data again anyway.
    //

    ASSERT(CompressedBufferSize >= (UncompressedBufferSize - (UncompressedBufferSize / 16)));
    CompressedBufferSize = (UncompressedBufferSize - (UncompressedBufferSize / 16));

    //
    //  Initialize NumberOfChunks returned and the pointer to the first chunk size.
    //

    CompressedDataInfo->NumberOfChunks = 0;
    CurrentCompressedChunkSize = &CompressedDataInfo->CompressedChunkSizes[0];

    //
    //  Loop to decompress chunks.
    //

    do {

        //
        //  Calculate uncompressed size of next chunk to decompress.
        //

        SizeToCompress = UncompressedBufferSize;
        if (SizeToCompress >= UncompressedChunkSize) {
            SizeToCompress = UncompressedChunkSize;
        }

        //
        //  Now compress the next chunk.
        //

        Status = RtlCompressBuffer( CompressedDataInfo->CompressionFormatAndEngine,
                                    UncompressedBuffer,
                                    SizeToCompress,
                                    CompressedBuffer,
                                    CompressedBufferSize,
                                    UncompressedChunkSize,
                                    &FinalCompressedSize,
                                    WorkSpace );

        //
        //  If the Buffer was all zeros, then we will not send anything.
        //

        if (Status == STATUS_BUFFER_ALL_ZEROS) {

            FinalCompressedSize = 0;

        //
        //  Otherwise, if there was any kind of error (we only expect the
        //  case where the data did not compress), then just copy the
        //  data and return UncompressedChunkSize for this one.
        //

        } else if (!NT_SUCCESS(Status)) {

            //
            //  The most likely error is STATUS_BUFFER_TOO_SMALL.
            //  But in any case, our only recourse would be to send
            //  the data uncompressed.  To be completely safe, we
            //  see if there is enough space for an uncompressed chunk
            //  in the CompressedBuffer, and if not we return
            //  buffer too small (which is probably what we had anyway!).
            //

            if (CompressedBufferSize < UncompressedChunkSize) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            //  Copy the uncompressed chunk.
            //

            RtlCopyMemory( CompressedBuffer, UncompressedBuffer, SizeToCompress );
            if (UncompressedChunkSize > SizeToCompress) {
                RtlZeroMemory( (PCHAR)CompressedBuffer + SizeToCompress,
                               UncompressedChunkSize - SizeToCompress );
            }

            FinalCompressedSize = UncompressedChunkSize;
        }

        ASSERT(FinalCompressedSize <= CompressedBufferSize);

        //
        //  At this point, we have handled any error status.
        //

        Status = STATUS_SUCCESS;

        //
        //  Store the final chunk size.
        //

        *CurrentCompressedChunkSize = FinalCompressedSize;
        CurrentCompressedChunkSize += 1;
        CompressedDataInfo->NumberOfChunks += 1;

        //
        //  Prepare for the next trip through the loop.
        //

        UncompressedBuffer += SizeToCompress;
        UncompressedBufferSize -= SizeToCompress;
        CompressedBuffer += FinalCompressedSize;
        CompressedBufferSize -= FinalCompressedSize;

    } while (UncompressedBufferSize != 0);

    return Status;
}


NTSTATUS
RtlCompressWorkSpaceSizeNS (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSTATUS
RtlCompressBufferNS (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSTATUS
RtlDecompressBufferNS (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSTATUS
RtlDecompressFragmentNS (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    )
{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlDescribeChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

{
    return STATUS_UNSUPPORTED_COMPRESSION;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlReserveChunkNS (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

{
    return STATUS_UNSUPPORTED_COMPRESSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\eballoc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eballoc.c

Abstract:

    Process/Thread Environment Block allocation functions

Author:

    Steve Wood (stevewo) 10-May-1990

Revision History:

--*/

#include "ntrtlp.h"
#include <nturtl.h>

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlAcquirePebLock)
#pragma alloc_text(PAGE,RtlReleasePebLock)
#endif

typedef VOID (*PEB_LOCK_ROUTINE)(PVOID FastLock);

VOID
RtlAcquirePebLock( VOID )
{
    PEB_LOCK_ROUTINE LockRoutine;
    PPEB Peb;
    LARGE_INTEGER Timeout;

    RTL_PAGED_CODE();

    Peb = NtCurrentPeb();

    LockRoutine = (PEB_LOCK_ROUTINE)Peb->FastPebLockRoutine;
    ASSERT(LockRoutine);

    for (;;) {
        try {
            (LockRoutine)(Peb->FastPebLock);
	    break;
        } except ( GetExceptionCode() == STATUS_INSUFFICIENT_RESOURCES 
                   ? EXCEPTION_EXECUTE_HANDLER
                   : EXCEPTION_CONTINUE_SEARCH ) {
            //
            // Unfortunately, a number of things assume that
            // RtlAcquirePebLock can't fail.  So we need to loop and
            // try again.
            //
            Timeout.QuadPart = UInt32x32To64( 10 /* Milliseconds to sleep */,
                                              10000 /* Milliseconds to 100 Nanoseconds) */);
            Timeout.QuadPart *= -1; /* Make it a relative time */
            NtDelayExecution(FALSE, &Timeout);
            continue;
        }
    }
}

VOID
RtlReleasePebLock( VOID )
{
    PEB_LOCK_ROUTINE LockRoutine;
    PPEB Peb;

    RTL_PAGED_CODE();

    Peb = NtCurrentPeb();

    LockRoutine = (PEB_LOCK_ROUTINE)Peb->FastPebUnlockRoutine;
    ASSERT(LockRoutine);
    (LockRoutine)(Peb->FastPebLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\environ.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    environ.c

Abstract:

    Environment Variable support

Author:

    Steven R. Wood (stevewo) 30-Jan-1991

Revision History:

--*/

#include "ntrtlp.h"
#include "zwapi.h"
#include "nturtl.h"
#include "string.h"
#include "ntrtlpath.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(INIT,RtlCreateEnvironment          )
#pragma alloc_text(INIT,RtlDestroyEnvironment         )
#pragma alloc_text(INIT,RtlSetCurrentEnvironment      )
#pragma alloc_text(INIT,RtlQueryEnvironmentVariable_U )
#pragma alloc_text(INIT,RtlSetEnvironmentVariable     )
#endif

BOOLEAN RtlpEnvironCacheValid;

NTSTATUS
RtlCreateEnvironment(
    IN BOOLEAN CloneCurrentEnvironment OPTIONAL,
    OUT PVOID *Environment
    )
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    PVOID pNew, pOld;

    //
    // If not cloning a copy of the current process's environment variable
    // block, just allocate a block of committed memory and return its
    // address.
    //

    pNew = NULL;
    if (!CloneCurrentEnvironment) {
createEmptyEnvironment:
        MemoryInformation.RegionSize = 1;
        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          &pNew,
                                          0,
                                          &MemoryInformation.RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (NT_SUCCESS( Status )) {
            *Environment = pNew;
        }

        return( Status );
    }

    //
    // Acquire the Peb Lock for the duration while we munge the environment
    // variable storage block.
    //

    RtlAcquirePebLock();

    //
    // Capture the pointer to the current process's environment variable
    // block and initialize the new pointer to null for our finally clause.
    //

    pOld = NtCurrentPeb()->ProcessParameters->Environment;
    if (pOld == NULL) {
        RtlReleasePebLock();
        goto createEmptyEnvironment;
    }

    try {
        try {
            //
            // Query the current size of the current process's environment
            // variable block.  Return status if failure.
            //

            Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                           pOld,
                                           MemoryBasicInformation,
                                           &MemoryInformation,
                                           sizeof( MemoryInformation ),
                                           NULL
                                         );
            if (!NT_SUCCESS( Status )) {
                leave;
            }

            //
            // Allocate memory to contain a copy of the current process's
            // environment variable block.  Return status if failure.
            //

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              &pNew,
                                              0,
                                              &MemoryInformation.RegionSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if (!NT_SUCCESS( Status )) {
                leave;
            }

            //
            // Copy the current process's environment to the allocated memory
            // and return a pointer to the copy.
            //

            RtlCopyMemory( pNew, pOld, MemoryInformation.RegionSize );
            *Environment = pNew;
        } except (EXCEPTION_EXECUTE_HANDLER) {
              Status = STATUS_ACCESS_VIOLATION;
        }
    } finally {
        if (Status == STATUS_ACCESS_VIOLATION) {
            if (pNew != NULL) {
                ZwFreeVirtualMemory( NtCurrentProcess(),
                                     &pNew,
                                     &MemoryInformation.RegionSize,
                                     MEM_RELEASE
                                   );
            }
        }

        RtlReleasePebLock();
    }

    return( Status );
}


NTSTATUS
RtlDestroyEnvironment(
    IN PVOID Environment
    )
{
    NTSTATUS Status;
    SIZE_T RegionSize;

    //
    // Free the specified environment variable block.
    //

    RtlpEnvironCacheValid = FALSE;

    RegionSize = 0;
    Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                  &Environment,
                                  &RegionSize,
                                  MEM_RELEASE
                                );
    //
    // Return status.
    //

    return( Status );
}


NTSTATUS
RtlSetCurrentEnvironment(
    IN PVOID Environment,
    OUT PVOID *PreviousEnvironment OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID pOld;

    //
    // Acquire the Peb Lock for the duration while we munge the environment
    // variable storage block.
    //

    RtlpEnvironCacheValid = FALSE;

    RtlAcquirePebLock();

    Status = STATUS_SUCCESS;
    try {
        //
        // Capture current process's environment variable block pointer to
        // return to caller or destroy.
        //

        pOld = NtCurrentPeb()->ProcessParameters->Environment;

        //
        // Change current process's environment variable block pointer to
        // point to the passed block.
        //


        NtCurrentPeb()->ProcessParameters->Environment = Environment;

        //
        // If caller requested it, return the pointer to the previous
        // process environment variable block and set the local variable
        // to NULL so we dont destroy it below.
        //

        if (ARGUMENT_PRESENT( PreviousEnvironment )) {
            *PreviousEnvironment = pOld;
            pOld = NULL;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
          Status = STATUS_ACCESS_VIOLATION;
          pOld = NULL;
    }

    //
    // Release the Peb Lock
    //

    RtlReleasePebLock();


    //
    // If old environment not returned to caller, destroy it.
    //

    if (pOld != NULL) {
        RtlDestroyEnvironment( pOld );
        }

    //
    // Return status
    //

    return( Status );
}

UNICODE_STRING RtlpEnvironCacheName;
UNICODE_STRING RtlpEnvironCacheValue;

NTSTATUS
RtlQueryEnvironmentVariable_U(
    IN PVOID Environment OPTIONAL,
    IN PUNICODE_STRING Name,
    IN OUT PUNICODE_STRING Value
    )
{
    NTSTATUS Status;
    UNICODE_STRING CurrentName;
    UNICODE_STRING CurrentValue;
    PWSTR p;
    PPEB Peb;
    BOOLEAN PebLockLocked = FALSE;

    Status = STATUS_VARIABLE_NOT_FOUND;
    Peb = NtCurrentPeb();

    try {
        if (ARGUMENT_PRESENT( Environment )) {
            p = Environment;
            if (*p == UNICODE_NULL) {
                leave;
            }
        }
        else {
            //
            // Acquire the Peb Lock for the duration while we munge the
            // environment variable storage block.
            //

            RtlAcquirePebLock();
            PebLockLocked = TRUE;

            //
            // Capture the pointer to the current process's environment variable
            // block.
            //

            p = Peb->ProcessParameters->Environment;

        }

        if ( RtlpEnvironCacheValid && p == Peb->ProcessParameters->Environment ) {
            if (RtlEqualUnicodeString( Name, &RtlpEnvironCacheName, TRUE )) {

                //
                // Names are equal.  Always return the length of the
                // value string, excluding the terminating null.  If
                // there is room in the caller's buffer, return a copy
                // of the value string and success status.  Otherwise
                // return an error status.  In the latter case, the caller
                // can examine the length field of their value string
                // so they can determine much memory is needed.
                //

                Value->Length = RtlpEnvironCacheValue.Length;
                if (Value->MaximumLength >= RtlpEnvironCacheValue.Length) {
                    RtlCopyMemory( Value->Buffer,
                                   RtlpEnvironCacheValue.Buffer,
                                   RtlpEnvironCacheValue.Length
                                 );
                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > RtlpEnvironCacheValue.Length) {
                        Value->Buffer[ RtlpEnvironCacheValue.Length/sizeof(WCHAR) ] = L'\0';
                    }

                    Status = STATUS_SUCCESS;
                }
                else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
                leave;
            }
        }

        //
        // The environment variable block consists of zero or more null
        // terminated UNICODE strings.  Each string is of the form:
        //
        //      name=value
        //
        // where the null termination is after the value.
        //

        if (p != NULL) while (*p) {
            //
            // Determine the size of the name and value portions of
            // the current string of the environment variable block.
            //

            CurrentName.Buffer = p;
            CurrentName.Length = 0;
            CurrentName.MaximumLength = 0;
            while (*p) {
                //
                // If we see an equal sign, then compute the size of
                // the name portion and scan for the end of the value.
                //

                if (*p == L'=' && p != CurrentName.Buffer) {
                    CurrentName.Length = (USHORT)(p - CurrentName.Buffer)*sizeof(WCHAR);
                    CurrentName.MaximumLength = (USHORT)(CurrentName.Length+sizeof(WCHAR));
                    CurrentValue.Buffer = ++p;

                    while(*p) {
                        p++;
                    }
                    CurrentValue.Length = (USHORT)(p - CurrentValue.Buffer)*sizeof(WCHAR);
                    CurrentValue.MaximumLength = (USHORT)(CurrentValue.Length+sizeof(WCHAR));

                    //
                    // At this point we have the length of both the name
                    // and value portions, so exit the loop so we can
                    // do the compare.
                    //
                    break;
                }
                else {
                    p++;
                }
            }

            //
            // Skip over the terminating null character for this name=value
            // pair in preparation for the next iteration of the loop.
            //

            p++;

            //
            // Compare the current name with the one requested, ignore
            // case.
            //

            if (RtlEqualUnicodeString( Name, &CurrentName, TRUE )) {
                //
                // Names are equal.  Always return the length of the
                // value string, excluding the terminating null.  If
                // there is room in the caller's buffer, return a copy
                // of the value string and success status.  Otherwise
                // return an error status.  In the latter case, the caller
                // can examine the length field of their value string
                // so they can determine much memory is needed.
                //

                Value->Length = CurrentValue.Length;
                if (Value->MaximumLength >= CurrentValue.Length) {
                    RtlCopyMemory( Value->Buffer,
                                   CurrentValue.Buffer,
                                   CurrentValue.Length
                                 );
                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > CurrentValue.Length) {
                        Value->Buffer[ CurrentValue.Length/sizeof(WCHAR) ] = L'\0';
                        }

                    if ( !Environment || Environment == Peb->ProcessParameters->Environment) {
                        RtlpEnvironCacheValid = TRUE;
                        RtlpEnvironCacheName = CurrentName;
                        RtlpEnvironCacheValue = CurrentValue;
                    }

                    Status = STATUS_SUCCESS;
                }
                else {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
                break;
            }
        }

        // If it's not in the real env block, let's see if it's a pseudo environment variable
        if (Status == STATUS_VARIABLE_NOT_FOUND) {
            static const UNICODE_STRING CurrentWorkingDirectoryPseudoVariable = RTL_CONSTANT_STRING(L"__CD__");
            static const UNICODE_STRING ApplicationDirectoryPseudoVariable = RTL_CONSTANT_STRING(L"__APPDIR__");

            if (RtlEqualUnicodeString(Name, &CurrentWorkingDirectoryPseudoVariable, TRUE)) {
                // Get the PEB lock if we don't already have it.
                if (!PebLockLocked) {
                    RtlAcquirePebLock();
                    PebLockLocked = TRUE;
                }

                // get cdw here...
                CurrentValue = NtCurrentPeb()->ProcessParameters->CurrentDirectory.DosPath;
                Status = STATUS_SUCCESS;
            } else if (RtlEqualUnicodeString(Name, &ApplicationDirectoryPseudoVariable, TRUE)) {
                USHORT PrefixLength = 0;

                if (!PebLockLocked) {
                    RtlAcquirePebLock();
                    PebLockLocked = TRUE;
                }

                // get appdir here 
                CurrentValue = NtCurrentPeb()->ProcessParameters->ImagePathName;

                Status = RtlFindCharInUnicodeString(
                                RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                                &CurrentValue,
                                &RtlDosPathSeperatorsString,
                                &PrefixLength);
                if (NT_SUCCESS(Status)) {
                    CurrentValue.Length = PrefixLength + sizeof(WCHAR);
                } else if (Status == STATUS_NOT_FOUND) {
                    // Use the whole thing; just translate the status to successs.
                    Status = STATUS_SUCCESS;
                }
            }

            if (NT_SUCCESS(Status)) {
                Value->Length = CurrentValue.Length;
                if (Value->MaximumLength >= CurrentValue.Length) {
                    RtlCopyMemory(Value->Buffer, CurrentValue.Buffer, CurrentValue.Length);

                    //
                    // Null terminate returned string if there is room.
                    //

                    if (Value->MaximumLength > CurrentValue.Length)
                        Value->Buffer[ CurrentValue.Length/sizeof(WCHAR) ] = L'\0';
                }
            }
        }



    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_ACCESS_VIOLATION;
    }


    //
    // Release the Peb lock.
    //

    if (PebLockLocked)
        RtlReleasePebLock();

    //
    // Return status.
    //

    return Status;
}


NTSTATUS
RtlSetEnvironmentVariable(
    IN OUT PVOID *Environment OPTIONAL,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING Value OPTIONAL
    )
{
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    UNICODE_STRING CurrentName;
    UNICODE_STRING CurrentValue;
    PVOID pOld, pNew;
    ULONG n, Size;
    SIZE_T NewSize;
    LONG CompareResult;
    PWSTR p, pStart, pEnd;
    PWSTR InsertionPoint;

    //
    // Validate passed in name and reject if zero length or anything but the first
    // character is an equal sign.
    //
    n = Name->Length / sizeof( WCHAR );
    if (n == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    try {
        p = Name->Buffer;
        while (--n) {
            if (*++p == L'=') {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    RtlpEnvironCacheValid = FALSE;
    Status = STATUS_VARIABLE_NOT_FOUND;
    if (ARGUMENT_PRESENT( Environment )) {
        pOld = *Environment;
    }
    else {
        //
        // Acquire the Peb Lock for the duration while we munge the
        // environment variable storage block.
        //

        RtlAcquirePebLock();

        //
        // Capture the pointer to the current process's environment variable
        // block.
        //

        pOld = NtCurrentPeb()->ProcessParameters->Environment;
    }


    pNew = NULL;
    InsertionPoint = NULL;

    try {
        try {

            //
            // The environment variable block consists of zero or more null
            // terminated UNICODE strings.  Each string is of the form:
            //
            //      name=value
            //
            // where the null termination is after the value.
            //

            p = pOld;
            pEnd = NULL;
            if (p != NULL) while (*p) {
                //
                // Determine the size of the name and value portions of
                // the current string of the environment variable block.
                //

                CurrentName.Buffer = p;
                CurrentName.Length = 0;
                CurrentName.MaximumLength = 0;
                while (*p) {
                    //
                    // If we see an equal sign, then compute the size of
                    // the name portion and scan for the end of the value.
                    //

                    if (*p == L'=' && p != CurrentName.Buffer) {
                        CurrentName.Length = (USHORT)(p - CurrentName.Buffer) * sizeof(WCHAR);
                        CurrentName.MaximumLength = (USHORT)(CurrentName.Length+sizeof(WCHAR));
                        CurrentValue.Buffer = ++p;

                        while(*p) {
                            p++;
                        }
                        CurrentValue.Length = (USHORT)(p - CurrentValue.Buffer) * sizeof(WCHAR);
                        CurrentValue.MaximumLength = (USHORT)(CurrentValue.Length+sizeof(WCHAR));

                        //
                        // At this point we have the length of both the name
                        // and value portions, so exit the loop so we can
                        // do the compare.
                        //
                        break;
                    }
                    else {
                        p++;
                    }
                }

                //
                // Skip over the terminating null character for this name=value
                // pair in preparation for the next iteration of the loop.
                //

                p++;

                //
                // Compare the current name with the one requested, ignore
                // case.
                //

                if (!(CompareResult = RtlCompareUnicodeString( Name, &CurrentName, TRUE ))) {
                    //
                    // Names are equal.  Now find the end of the current
                    // environment variable block.
                    //

                    pEnd = p;
                    while (*pEnd) {
                        while (*pEnd++) {
                        }
                    }
                    pEnd++;

                    if (!ARGUMENT_PRESENT( Value )) {
                        //
                        // If the caller did not specify a new value, then delete
                        // the entire name=value pair by copying up the remainder
                        // of the environment variable block.
                        //

                        RtlMoveMemory( CurrentName.Buffer,
                                       p,
                                       (ULONG) ((pEnd - p)*sizeof(WCHAR))
                                     );
                        Status = STATUS_SUCCESS;
                    }
                    else
                    if (Value->Length <= CurrentValue.Length) {
                        //
                        // New value is smaller, so copy new value, then null
                        // terminate it, and then move up the remainder of the
                        // variable block so it is immediately after the new
                        // null terminated value.
                        //

                        pStart = CurrentValue.Buffer;
                        RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                        pStart += Value->Length/sizeof(WCHAR);
                        *pStart++ = L'\0';

                        RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                        Status = STATUS_SUCCESS;
                    }
                    else {
                        //
                        // New value is larger, so query the current size of the
                        // environment variable block.  Return status if failure.
                        //

                        Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                                       pOld,
                                                       MemoryBasicInformation,
                                                       &MemoryInformation,
                                                       sizeof( MemoryInformation ),
                                                       NULL
                                                     );
                        if (!NT_SUCCESS( Status )) {
                            leave;
                        }

                        //
                        // See if there is room for new, larger value.  If not
                        // allocate a new copy of the environment variable
                        // block.
                        //

                        NewSize = (pEnd - (PWSTR)pOld)*sizeof(WCHAR) +
                                    Value->Length - CurrentValue.Length;
                        if (NewSize >= MemoryInformation.RegionSize) {
                            //
                            // Allocate memory to contain a copy of the current
                            // process's environment variable block.  Return
                            // status if failure.
                            //

                            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                              &pNew,
                                                              0,
                                                              &NewSize,
                                                              MEM_COMMIT,
                                                              PAGE_READWRITE
                                                            );
                            if (!NT_SUCCESS( Status )) {
                                leave;
                            }

                            //
                            // Copy the current process's environment to the allocated memory
                            // inserting the new value as we do the copy.
                            //

                            Size = (ULONG) (CurrentValue.Buffer - (PWSTR)pOld);
                            RtlMoveMemory( pNew, pOld, Size*sizeof(WCHAR) );
                            pStart = (PWSTR)pNew + Size;
                            RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                            pStart += Value->Length/sizeof(WCHAR);
                            *pStart++ = L'\0';
                            RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)));
    			            if (ARGUMENT_PRESENT( Environment ))
    			                *Environment = pNew;
                            else {
    			                NtCurrentPeb()->ProcessParameters->Environment = pNew;
                                NtCurrentPeb()->EnvironmentUpdateCount += 1;
                            }

    			            ZwFreeVirtualMemory( NtCurrentProcess(),
                                         &pOld,
                                         &MemoryInformation.RegionSize,
                                         MEM_RELEASE
                                       );
                            pNew = pOld;
                        }
                        else {
                            pStart = CurrentValue.Buffer + Value->Length/sizeof(WCHAR) + 1;
                            RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)));
                            *--pStart = L'\0';

                            RtlMoveMemory( pStart - Value->Length/sizeof(WCHAR),
                                           Value->Buffer,
                                           Value->Length
                                         );
                        }
                    }

                    break;
                }
                else
                if (CompareResult < 0) {
                    //
                    // Requested name is less than the current name.  Save this
                    // spot in case the variable is not in a sorted position.
                    // The insertion point for the new variable is before the
                    // variable just examined.
                    //

                    if (InsertionPoint == NULL) {
                        InsertionPoint = CurrentName.Buffer;
                    }
                }
            }

            //
            // If we found an insertion point, reset the string
            // pointer back to it.
            //

            if (InsertionPoint != NULL) {
                p = InsertionPoint;
            }

            //
            // If variable name not found and a new value parameter was specified
            // then insert the new variable name and its value at the appropriate
            // place in the environment variable block (i.e. where p points to).
            //

            if (pEnd == NULL && ARGUMENT_PRESENT( Value )) {
                if (p != NULL) {
                    //
                    // Name not found.  Now find the end of the current
                    // environment variable block.
                    //

                    pEnd = p;
                    while (*pEnd) {
                        while (*pEnd++) {
                        }
                    }
                    pEnd++;

                    //
                    // New value is present, so query the current size of the
                    // environment variable block.  Return status if failure.
                    //

                    Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                                   pOld,
                                                   MemoryBasicInformation,
                                                   &MemoryInformation,
                                                   sizeof( MemoryInformation ),
                                                   NULL
                                                 );
                    if (!NT_SUCCESS( Status )) {
                        leave;
                    }

                    //
                    // See if there is room for new, larger value.  If not
                    // allocate a new copy of the environment variable
                    // block.
                    //

                    NewSize = (pEnd - (PWSTR)pOld) * sizeof(WCHAR) +
                              Name->Length +
                              sizeof(WCHAR) +
                              Value->Length +
                              sizeof(WCHAR);
                }
                else {
                    NewSize = Name->Length +
                              sizeof(WCHAR) +
                              Value->Length +
                              sizeof(WCHAR);
                    MemoryInformation.RegionSize = 0;
                }

                if (NewSize >= MemoryInformation.RegionSize) {
                    //
                    // Allocate memory to contain a copy of the current
                    // process's environment variable block.  Return
                    // status if failure.
                    //

                    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                      &pNew,
                                                      0,
                                                      &NewSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE
                                                    );
                    if (!NT_SUCCESS( Status )) {
                        leave;
                    }

                    //
                    // Copy the current process's environment to the allocated memory
                    // inserting the new value as we do the copy.
                    //

                    if (p != NULL) {
                        Size = (ULONG)(p - (PWSTR)pOld);
                        RtlMoveMemory( pNew, pOld, Size*sizeof(WCHAR) );
                    }
                    else {
                        Size = 0;
                    }
                    pStart = (PWSTR)pNew + Size;
                    RtlMoveMemory( pStart, Name->Buffer, Name->Length );
                    pStart += Name->Length/sizeof(WCHAR);
                    *pStart++ = L'=';
                    RtlMoveMemory( pStart, Value->Buffer, Value->Length );
                    pStart += Value->Length/sizeof(WCHAR);
                    *pStart++ = L'\0';
                    if (p != NULL) {
                        RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                    }

    		        if (ARGUMENT_PRESENT( Environment )) {
    		            *Environment = pNew;
                    }
                    else {
    		            NtCurrentPeb()->ProcessParameters->Environment = pNew;
                        NtCurrentPeb()->EnvironmentUpdateCount += 1;
                    }
                    ZwFreeVirtualMemory( NtCurrentProcess(),
                                         &pOld,
                                         &MemoryInformation.RegionSize,
                                         MEM_RELEASE
                                       );
                }
                else {
                    pStart = p + Name->Length/sizeof(WCHAR) + 1 + Value->Length/sizeof(WCHAR) + 1;
                    RtlMoveMemory( pStart, p,(ULONG)((pEnd - p)*sizeof(WCHAR)) );
                    RtlMoveMemory( p, Name->Buffer, Name->Length );
                    p += Name->Length/sizeof(WCHAR);
                    *p++ = L'=';
                    RtlMoveMemory( p, Value->Buffer, Value->Length );
                    p += Value->Length/sizeof(WCHAR);
                    *p++ = L'\0';
                    }
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
              //
              // If abnormally terminating, assume access violation.
              //

              Status = STATUS_ACCESS_VIOLATION;
        }
    } finally {
        //
        // Release the Peb lock.
        //

        if (!ARGUMENT_PRESENT( Environment )) {
            RtlReleasePebLock();
        }
    }

    //
    // Return status.
    //

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\error.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/

#include <ntrtlp.h>
#include "winerror.h"
#include "error.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE, RtlGetLastNtStatus)
#pragma alloc_text(PAGE, RtlGetLastWin32Error)
#pragma alloc_text(PAGE, RtlNtStatusToDosError)
#pragma alloc_text(PAGE, RtlRestoreLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32Error)
#pragma alloc_text(PAGE, RtlSetLastWin32ErrorAndNtStatusFromNtStatus)
#endif

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

ULONG
RtlNtStatusToDosError (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS|2 equivalent.
    Remembers the Status code value in the TEB.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS|2 error code.

--*/

{
    PTEB Teb;

    Teb = NtCurrentTeb();

    if (Teb) {
        try {
            Teb->LastStatusValue = Status;
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return RtlNtStatusToDosErrorNoTeb( Status );
}

ULONG
RtlNtStatusToDosErrorNoTeb (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS 2 equivalent
    and returns the translated value.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS 2 error code.

--*/

{

    ULONG Offset;
    ULONG Entry;
    ULONG Index;

    //
    // Convert any HRESULTs to their original form of a NTSTATUS or a
    // WIN32 error
    //


    if (Status & 0x20000000) {

        //
        // The customer bit is set so lets just pass the
        // error code on thru
        //

        return Status;

    }
    else if ((Status & 0xffff0000) == 0x80070000) {

        //
        // The status code  was a win32 error already.
        //

        return(Status & 0x0000ffff);
    }
    else if ((Status & 0xf0000000) == 0xd0000000) {

        //
        // The status code is a HRESULT from NTSTATUS
        //

        Status &= 0xcfffffff;
    }

    //
    // Scan the run length table and compute the entry in the translation
    // table that maps the specified status code to a DOS error code.
    //

    Entry = 0;
    Index = 0;
    do {
        if ((ULONG)Status >= RtlpRunTable[Entry + 1].BaseCode) {
            Index += (RtlpRunTable[Entry].RunLength * RtlpRunTable[Entry].CodeSize);

        } else {
            Offset = (ULONG)Status - RtlpRunTable[Entry].BaseCode;
            if (Offset >= RtlpRunTable[Entry].RunLength) {
                break;

            } else {
                Index += (Offset * (ULONG)RtlpRunTable[Entry].CodeSize);
                if (RtlpRunTable[Entry].CodeSize == 1) {
                    return (ULONG)RtlpStatusTable[Index];

                } else {
                    return (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                                (ULONG)RtlpStatusTable[Index]);
                }
            }
        }

        Entry += 1;
    } while (Entry < (sizeof(RtlpRunTable) / sizeof(RUN_ENTRY)));

    //
    // The translation to a DOS error code failed.
    //
    // The redirector maps unknown OS/2 error codes by ORing 0xC001 into
    // the high 16 bits.  Detect this and return the low 16 bits if true.
    //

    if (((ULONG)Status >> 16) == 0xC001) {
        return ((ULONG)Status & 0xFFFF);
    }

#ifndef NTOS_KERNEL_RUNTIME
    DbgPrint("RTL: RtlNtStatusToDosError(0x%lx): No Valid Win32 Error Mapping\n",Status);
    DbgPrint("RTL: Edit ntos\\rtl\\generr.c to correct the problem\n");
    DbgPrint("RTL: ERROR_MR_MID_NOT_FOUND is being returned\n");

#if DBG
    DbgBreakPoint();
#endif // DBG

#endif // NTOS_KERNEL_RUNTIME

    return ERROR_MR_MID_NOT_FOUND;
}

NTSTATUS
NTAPI
RtlGetLastNtStatus(
	VOID
	)
{
	return NtCurrentTeb()->LastStatusValue;
}

LONG
NTAPI
RtlGetLastWin32Error(
	VOID
	)
{
	return NtCurrentTeb()->LastErrorValue;
}

VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
	NTSTATUS Status
	)
{
	//
	// RtlNtStatusToDosError stores into NtCurrentTeb()->LastStatusValue.
	//
	RtlSetLastWin32Error(RtlNtStatusToDosError(Status));
}

VOID
NTAPI
RtlSetLastWin32Error(
	LONG Win32Error
	)
{
//
// Arguably this should clear or reset the last nt status, but it does not
// touch it.
//
	NtCurrentTeb()->LastErrorValue = Win32Error;
}

VOID
NTAPI
RtlRestoreLastWin32Error(
	LONG Win32Error
	)
{
#if DBG
	if ((LONG)NtCurrentTeb()->LastErrorValue != Win32Error)
#endif
		NtCurrentTeb()->LastErrorValue = Win32Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\cnvint.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cnvint.c

Abstract:

    Text to integer and integer to text converion routines.

Author:

    Steve Wood (stevewo) 23-Aug-1990

Revision History:

--*/

#include <ntrtlp.h>

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlIntegerToChar)
#pragma alloc_text(PAGE,RtlCharToInteger)
#pragma alloc_text(PAGE,RtlUnicodeStringToInteger)
#pragma alloc_text(PAGE,RtlIntegerToUnicode)
#pragma alloc_text(PAGE,RtlIntegerToUnicodeString)
#pragma alloc_text(PAGE,RtlLargeIntegerToChar)
#pragma alloc_text(PAGE,RtlLargeIntegerToUnicode)
#pragma alloc_text(PAGE,RtlInt64ToUnicodeString)
#endif

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif
const CHAR RtlpIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const WCHAR RtlpIntegerWChars[] = { L'0', L'1', L'2', L'3', L'4', L'5',
                              L'6', L'7', L'8', L'9', L'A', L'B',
                              L'C', L'D', L'E', L'F' };

NTSTATUS
RtlIntegerToChar (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = '\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlCopyMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlCharToInteger (
    IN PCSZ String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    CHAR c, Sign;
    ULONG Result, Digit, Shift;

    RTL_PAGED_CODE();

    while ((Sign = *String++) <= ' ') {
        if (!*String) {
            String--;
            break;
            }
        }

    c = Sign;
    if (c == '-' || c == '+') {
        c = *String++;
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)(Base) )) {
        Base = 10;
        Shift = 0;
        if (c == '0') {
            c = *String++;
            if (c == 'x') {
                Base = 16;
                Shift = 4;
                }
            else
            if (c == 'o') {
                Base = 8;
                Shift = 3;
                }
            else
            if (c == 'b') {
                Base = 2;
                Shift = 1;
                }
            else {
                String--;
                }

            c = *String++;
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c) {
        if (c >= '0' && c <= '9') {
            Digit = c - '0';
            }
        else
        if (c >= 'A' && c <= 'F') {
            Digit = c - 'A' + 10;
            }
        else
        if (c >= 'a' && c <= 'f') {
            Digit = c - 'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *String++;
        }

    if (Sign == '-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlUnicodeStringToInteger (
    IN PCUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    RTL_PAGED_CODE();

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );
    while (nChars-- && (Sign = *s++) <= ' ') {
        if (!nChars) {
            Sign = UNICODE_NULL;
            break;
            }
        }

    c = Sign;
    if (c == L'-' || c == L'+') {
        if (nChars) {
            nChars--;
            c = *s++;
            }
        else {
            c = UNICODE_NULL;
            }
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)Base )) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            if (nChars) {
                nChars--;
                c = *s++;
                if (c == L'x') {
                    Base = 16;
                    Shift = 4;
                    }
                else
                if (c == L'o') {
                    Base = 8;
                    Shift = 3;
                    }
                else
                if (c == L'b') {
                    Base = 2;
                    Shift = 1;
                    }
                else {
                    nChars++;
                    s--;
                    }
                }

            if (nChars) {
                nChars--;
                c = *s++;
                }
            else {
                c = UNICODE_NULL;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        if (!nChars) {
            break;
            }
        nChars--;
        c = *s++;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = L'\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlCopyMemory( String, s, Length * sizeof( WCHAR ));

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    UCHAR ResultBuffer[ 16 ];
    ANSI_STRING AnsiString;

    RTL_PAGED_CODE();

    Status = RtlIntegerToChar( Value, Base, sizeof( ResultBuffer ), ResultBuffer );
    if (NT_SUCCESS( Status )) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof( ResultBuffer );
        AnsiString.Length = (USHORT)strlen( ResultBuffer );
        Status = RtlAnsiStringToUnicodeString( String, &AnsiString, FALSE );
        }

    return( Status );
}


NTSTATUS
RtlLargeIntegerToChar (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 99 ];
    *s = '\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> (4 - HighShift);
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = (ULONG)(&Result[ 99 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlCopyMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}

NTSTATUS
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    RTL_PAGED_CODE();

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 99 ];
    *s = L'\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> (4 - HighShift);
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerWChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerWChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = (ULONG)(&Result[ 99 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlCopyMemory( String, s, Length * sizeof( WCHAR ));

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}

NTSTATUS
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )

{

    NTSTATUS Status;
    UCHAR ResultBuffer[32];
    ANSI_STRING AnsiString;
    LARGE_INTEGER Temp;

    RTL_PAGED_CODE();

    Temp.QuadPart = Value;
    Status = RtlLargeIntegerToChar(&Temp,
                                   Base,
                                   sizeof(ResultBuffer),
                                   ResultBuffer);

    if (NT_SUCCESS(Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof(ResultBuffer);
        AnsiString.Length = (USHORT)strlen(ResultBuffer);
        Status = RtlAnsiStringToUnicodeString(String, &AnsiString, FALSE);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\debug.c ===
//      TITLE("Debug Support Functions")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug.c
//
// Abstract:
//
//    This module implements functions to support debugging NT.  They call
//    architecture specific routines to do the actual work.
//
// Author:
//
//    Steven R. Wood (stevewo) 8-Nov-1994
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "ntrtlp.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>

#if !defined(BLDR_KERNEL_RUNTIME) || (defined(BLDR_KERNEL_RUNTIME) && defined(ENABLE_LOADER_DEBUG))

ULONG
DbgPrint(
    IN PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefix("", -1, 0, Format, arglist);
}

ULONG
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level.
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    va_list arglist;

    va_start(arglist, Format);
    return vDbgPrintExWithPrefix("", ComponentId, Level, Format, arglist);
}

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//
//    Level      - Supplies the output filter level or mask.
//
//    Arguments   - Supplies a pointer to a variable argument list.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    return vDbgPrintExWithPrefix("", ComponentId, Level, Format, arglist);
}

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Prefix - Supplies a pointer to text that is to prefix the formatted
//        output.
//
//    ComponentId - Supplies the Id of the calling component.
//
//    Level      - Supplies the output filter level or mask.
//
//    Arguments   - Supplies a pointer to a variable argument list.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{

    UCHAR Buffer[512];
    int cb;
    STRING Output;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If the debug output will be suppressed, then return success
    // immediately.
    //

#if !defined(BLDR_KERNEL_RUNTIME)

    if ((ComponentId != -1) &&
        (NtQueryDebugFilterState(ComponentId, Level) == FALSE)) {
        return STATUS_SUCCESS;
    }

#endif

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)

    if (NtCurrentTeb()->InDbgPrint) {
        return STATUS_SUCCESS;
    }
    NtCurrentTeb()->InDbgPrint = TRUE;
#endif

    //
    // Format the output into a buffer and then print it.
    //

#if !defined(BLDR_KERNEL_RUNTIME)
    try {
        cb = strlen(Prefix);
        strcpy(Buffer, Prefix);
        cb = _vsnprintf(Buffer + cb , sizeof(Buffer) - cb, Format, arglist) + cb;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
#else
    cb = strlen(Prefix);
    strcpy(Buffer, Prefix);
    cb = _vsnprintf(Buffer + cb, sizeof(Buffer) - cb, Format, arglist) + cb;
#endif

    if (!NT_SUCCESS(Status)) {
#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
        NtCurrentTeb()->InDbgPrint = FALSE;
#endif
        return Status;
    }

    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }
    Output.Buffer = Buffer;
    Output.Length = (USHORT) cb;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
#if !i386
    //
    // For non-Intel architectures, can't raise exceptions until the PebLock
    // is initialized, since the Function Table lookup code uses the PebLock
    // to serialize access to the loaded module database.  What a crock
    //
    if (NtCurrentPeb()->FastPebLockRoutine != NULL)
#endif  //!i386
    if (NtCurrentPeb()->BeingDebugged) {
        EXCEPTION_RECORD ExceptionRecord;

        //
        // Construct an exception record.
        //

        ExceptionRecord.ExceptionCode = DBG_PRINTEXCEPTION_C;
        ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
        ExceptionRecord.NumberParameters = 2;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionInformation[ 0 ] = Output.Length + 1;
        ExceptionRecord.ExceptionInformation[ 1 ] = (ULONG_PTR)(Output.Buffer);

        try {
            RtlRaiseException( &ExceptionRecord );
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
        NtCurrentTeb()->InDbgPrint = FALSE;
#endif
        return STATUS_SUCCESS;
        }
#endif
    Status = DebugPrint(&Output, ComponentId, Level);
    if (Status == STATUS_BREAKPOINT) {
        DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
        Status = STATUS_SUCCESS;
    }
#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
    NtCurrentTeb()->InDbgPrint = FALSE;
#endif
    return Status;
}

ULONG
DbgPrintReturnControlC(
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    This routine is exactly the same as DbgPrint except that control-C
//    is NOT handled here.   Instead, status indicating control-C is
//    returned to the caller to do with as they will.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    STRING Output;
#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
    CONST PPEB Peb = NtCurrentPeb();
#endif

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }
    Output.Buffer = Buffer;
    Output.Length = (USHORT) cb;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

#if !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
#if !i386
    //
    // For non-Intel architectures, can't raise exceptions until the PebLock
    // is initialized, since the Function Table lookup code uses the PebLock
    // to serialize access to the loaded module database.  What a crock
    //
    if (Peb->FastPebLockRoutine != NULL)

    //
    // For IA64 and probably AMD64, can't raise exceptions until ntdll is in
    // Peb->Ldr, so that RtlPcToFileHeader can find ntdll in Peb->Ldr. The
    // dbgprints / exceptions are necessarily from ntdll at this point.
    // The first two things in Peb->Ldr are the .exe and ntdll.dll, so
    // check that there are two things in the list.
    //
    if ((Peb->Ldr != NULL) &&
       (Peb->Ldr->InLoadOrderModuleList.Flink != &Peb->Ldr->InLoadOrderModuleList) &&
       (Peb->Ldr->InLoadOrderModuleList.Blink != Peb->Ldr->InLoadOrderModuleList.Flink))
#endif  //!i386
    if (Peb->BeingDebugged) {
        EXCEPTION_RECORD ExceptionRecord;

        //
        // Construct an exception record.
        //

        ExceptionRecord.ExceptionCode = DBG_PRINTEXCEPTION_C;
        ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
        ExceptionRecord.NumberParameters = 2;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionInformation[ 0 ] = Output.Length + 1;
        ExceptionRecord.ExceptionInformation[ 1 ] = (ULONG_PTR)(Output.Buffer);
        try {
            RtlRaiseException( &ExceptionRecord );
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
        return STATUS_SUCCESS;
        }
#endif
    return DebugPrint(&Output, 0, 0);
}

ULONG
DbgPrompt(
    IN PCHAR Prompt,
    OUT PCHAR Response,
    IN ULONG MaximumResponseLength
    )

//++
//
// Routine Description:
//
//    This function displays the prompt string on the debugging console and
//    then reads a line of text from the debugging console.  The line read
//    is returned in the memory pointed to by the second parameter.  The
//    third parameter specifies the maximum number of characters that can
//    be stored in the response area.
//
// Arguments:
//
//    Prompt - specifies the text to display as the prompt.
//
//    Response - specifies where to store the response read from the
//       debugging console.
//
//    Prompt - specifies the maximum number of characters that can be
//       stored in the Response buffer.
//
// Return Value:
//
//    Number of characters stored in the Response buffer.  Includes the
//    terminating newline character, but not the null character after
//    that.
//
//--

{

    STRING Input;
    STRING Output;

    //
    // Output the prompt string and read input.
    //

    Input.MaximumLength = (USHORT)MaximumResponseLength;
    Input.Buffer = Response;
    Output.Length = (USHORT)strlen( Prompt );
    Output.Buffer = Prompt;
    return DebugPrompt( &Output, &Input );
}

#if defined(NTOS_KERNEL_RUNTIME) || defined(BLDR_KERNEL_RUNTIME)


VOID
DbgLoadImageSymbols(
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly loaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{

    PIMAGE_NT_HEADERS NtHeaders;
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    NtHeaders = RtlImageNtHeader( ImageBase );
    if (NtHeaders != NULL) {
        SymbolInfo.CheckSum = (ULONG)NtHeaders->OptionalHeader.CheckSum;
        SymbolInfo.SizeOfImage = (ULONG)NtHeaders->OptionalHeader.SizeOfImage;

    } else {

#if defined(BLDR_KERNEL_RUNTIME)

        //
        // There is only one image loaded in the loader environment that
        // does not have an NT image header. The image is the OS loader
        // and it is loaded by the firmware which strips the file header
        // and the optional ROM header. All the debugger requires is a
        // good guest at the size of the image.
        //

        SymbolInfo.SizeOfImage = 0x100000;

#else

        SymbolInfo.SizeOfImage = 0;

#endif

        SymbolInfo.CheckSum    = 0;
    }

    DebugService2(FileName, &SymbolInfo, BREAKPOINT_LOAD_SYMBOLS);

    return;
}


VOID
DbgUnLoadImageSymbols (
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly unloaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    SymbolInfo.CheckSum    = 0;
    SymbolInfo.SizeOfImage = 0;

    DebugService2(FileName, &SymbolInfo, BREAKPOINT_UNLOAD_SYMBOLS);

    return;
}


VOID
DbgCommandString(
    IN PCH Name,
    IN PCH Command
    )

//++
//
// Routine Description:
//
//    Tells the debugger to execute a command string
//
// Arguments:
//
//    Name - Identifies the originator of the command.
//
//    Command - Command string.
//
// Return Value:
//
//--

{
    STRING NameStr, CommandStr;

    NameStr.Buffer = Name;
    NameStr.Length = (USHORT)strlen(Name);
    CommandStr.Buffer = Command;
    CommandStr.Length = (USHORT)strlen(Command);
    DebugService2(&NameStr, &CommandStr, BREAKPOINT_COMMAND_STRING);
}

#endif // defined(NTOS_KERNEL_RUNTIME)

#if !defined(BLDR_KERNEL_RUNTIME)
NTSTATUS
DbgQueryDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level
    )

//++
//
// Routine Description:
//
//    This function queries the debug print enable for a specified component
//    level.  If Level is > 31, it's assumed to be a mask otherwise, it indicates
//    a specific debug level to test for (ERROR/WARNING/TRACE/INFO, etc).
//
// Arguments:
//
//     ComponentId - Supplies the component id.
//
//     Level - Supplies the debug filter level number or mask.
//
// Return Value:
//
//     STATUS_INVALID_PARAMETER_1 is returned if the component id is not
//         valid.
//
//     TRUE is returned if output is enabled for the specified component
//         and level or is enabled for the system.
//
//     FALSE is returned if output is not enabled for the specified component
//         and level and is not enabled for the system.
//
//--

{

    return NtQueryDebugFilterState(ComponentId, Level);
}

NTSTATUS
DbgSetDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    )

//++
//
// Routine Description:
//
//    This function sets the state of the debug print enable for a specified
//    component and level. The debug print enable state for the system is set
//    by specifying the distinguished value -1 for the component id.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//
//    Level - Supplies the output filter level or mask.
//
//    State - Supplies a boolean value that determines the new state.
//
// Return Value:
//
//    STATUS_ACCESS_DENIED is returned if the required privilege is not held.
//
//    STATUS_INVALID_PARAMETER_1 is returned if the component id is not
//        valid.
//
//    STATUS_SUCCESS  is returned if the debug print enable state is set for
//        the specified component.
//
//--

{
    return NtSetDebugFilterState(ComponentId, Level, State);
}

#endif
#endif // !defined(BLDR_KERNEL_RUNTIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\gen8dot3.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Gen8dot3.c

Abstract:

    This module implements a routine to generate 8.3 names from long names.

Author:

    Gary Kimura     [GaryKi]    26-Mar-1992

Environment:

    Pure Utility Routines

Revision History:

--*/

#include "ntrtlp.h"
#include <stdio.h>

extern PUSHORT  NlsUnicodeToMbOemData;
extern PUSHORT  NlsOemToUnicodeData;
extern PCH      NlsUnicodeToOemData;
extern PUSHORT  NlsMbOemCodePageTables;
extern BOOLEAN  NlsMbOemCodePageTag;
extern const PUSHORT  NlsOemLeadByteInfo;
extern USHORT   OemDefaultChar;

//
//  A condensed table of legal fat character values
//

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif
const
ULONG RtlFatIllegalTable[] = { 0xffffffff,
                               0xfc009c04,
                               0x38000000,
                               0x10000000 };

WCHAR
GetNextWchar (
    IN PUNICODE_STRING Name,
    IN PULONG CurrentIndex,
    IN BOOLEAN SkipDots,
    IN BOOLEAN AllowExtendedCharacters
    );

USHORT
RtlComputeLfnChecksum (
    PUNICODE_STRING Name
    );

//
//  BOOLEAN
//  IsDbcsCharacter (
//      IN WCHAR Wc
//  );
//

#define IsDbcsCharacter(WC) (             \
    ((WC) > 127) &&                       \
    (HIBYTE(NlsUnicodeToMbOemData[(WC)])) \
)

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlGenerate8dot3Name)
#pragma alloc_text(PAGE,GetNextWchar)
#pragma alloc_text(PAGE,RtlComputeLfnChecksum)
#pragma alloc_text(PAGE,RtlIsNameLegalDOS8Dot3)
#pragma alloc_text(PAGE,RtlIsValidOemCharacter)
#endif


VOID
RtlGenerate8dot3Name (
    IN PUNICODE_STRING Name,
    IN BOOLEAN AllowExtendedCharacters,
    IN OUT PGENERATE_NAME_CONTEXT Context,
    OUT PUNICODE_STRING Name8dot3
    )

/*++

Routine Description:

    This routine is used to generate an 8.3 name from a long name.  It can
    be called repeatedly to generate different 8.3 name variations for the
    same long name.  This is necessary if the gernerated 8.3 name conflicts
    with an existing 8.3 name.

Arguments:

    Name - Supplies the original long name that is being translated from.

    AllowExtendedCharacters - If TRUE, then extended characters, including
        DBCS characters, are allowed in the basis of the short name if they
        map to an upcased Oem character.

    Context - Supplies a context for the translation.  This is a private structure
        needed by this routine to help enumerate the different long name
        possibilities.  The caller is responsible with providing a "zeroed out"
        context structure on the first call for each given input name.

    Name8dot3 - Receives the new 8.3 name.  Pool for the buffer must be allocated
        by the caller and should be 12 characters wide (i.e., 24 bytes).

Return Value:

    None.

--*/

{
    BOOLEAN DbcsAware;
    BOOLEAN IndexAll9s = TRUE;
    ULONG OemLength;
    ULONG IndexLength;
    WCHAR IndexBuffer[8];
    ULONG i;

#ifdef NTOS_KERNEL_RUNTIME
    extern BOOLEAN FsRtlSafeExtensions;
#else
    BOOLEAN FsRtlSafeExtensions = TRUE;
#endif

    DbcsAware = AllowExtendedCharacters && NlsMbOemCodePageTag;

    //
    //  Check if this is the first time we are being called, and if so then
    //  initialize the context fields.
    //

    if (Context->NameLength == 0) {

        ULONG LastDotIndex;

        ULONG CurrentIndex;
        BOOLEAN SkipDots;
        WCHAR wc;

        //
        //  Skip down the name remembering the index of the last dot we
        //  will skip over the first dot provided the name starts with
        //  a dot.
        //

        LastDotIndex = MAXULONG;

        CurrentIndex = 0;
        SkipDots = ((Name->Length > 0) && (Name->Buffer[0] == L'.'));

        while ((wc = GetNextWchar( Name,
                                   &CurrentIndex,
                                   SkipDots,
                                   AllowExtendedCharacters )) != 0) {

            SkipDots = FALSE;
            if (wc == L'.') { LastDotIndex = CurrentIndex; }
        }

        //
        //  If the LastDotIndex is the last character in the name,
        //  then there really isn't an extension, so reset LastDotIndex.
        //

        if (LastDotIndex == Name->Length/sizeof(WCHAR)) {

            LastDotIndex = MAXULONG;
        }

        //
        //  Build up the name part. This can be at most 6 characters
        //  (because of the ~# appeneded on the end) and we skip over
        //  dots, except the last dot, which terminates the loop.
        //
        //  We exit the loop if:
        //
        //  - The input Name has been exhausted
        //  - We have consumed the input name up to the last dot
        //  - We have filled 6 characters of short name basis
        //

        CurrentIndex = 0;
        OemLength = 0;
        Context->NameLength = 0;

        while ((wc = GetNextWchar( Name, &CurrentIndex, TRUE, AllowExtendedCharacters)) &&
               (CurrentIndex < LastDotIndex) &&
               (Context->NameLength < 6)) {

            //
            //  If we are on a multi-byte code page we have to be careful
            //  here because the short name (when converted to Oem) must
            //  be 8.3 compliant.  Note that if AllowExtendedCharacters
            //  is FALSE, then GetNextWchar will never return a DBCS
            //  character, so we don't care what kind of code page we
            //  are on.
            //

            if (DbcsAware) {

                OemLength += IsDbcsCharacter(wc) ? 2 : 1;

                if (OemLength > 6) { break; }
            }

            //
            //  Copy the UNICODE character into the name buffer
            //

            Context->NameBuffer[Context->NameLength++] = wc;
        }

        //
        //  Now if the name part of the basis is 2 or less bytes (when
        //  represented in Oem) then append a four character checksum
        //  to make the short name space less sparse.
        //

        if ((DbcsAware ? OemLength : Context->NameLength) <= 2) {

            USHORT Checksum;
            WCHAR Nibble;

            Checksum =
            Context->Checksum = RtlComputeLfnChecksum( Name );

            for (i = 0; i < 4; i++, Checksum >>= 4) {

                Nibble = Checksum & 0xf;
                Nibble += Nibble <= 9 ? '0' : 'A' - 10;

                Context->NameBuffer[ Context->NameLength + i ] = Nibble;
            }

            Context->NameLength += 4;
            Context->ChecksumInserted = TRUE;
        }

        //
        //  Now process the last extension (if there is one).
        //  If the last dot index is not MAXULONG then we
        //  have located the last dot in the name
        //

        if (LastDotIndex != MAXULONG) {

            //
            //  Put in the "."
            //

            Context->ExtensionBuffer[0] = L'.';

            //
            //  Process the extension similar to how we processed the name
            //
            //  We exit the loop if:
            //
            //  - The input Name has been exhausted
            //  - We have filled . + 3 characters of extension
            //

            OemLength = 1;
            Context->ExtensionLength = 1;

            while ((wc = GetNextWchar( Name, &LastDotIndex, TRUE, AllowExtendedCharacters)) &&
                   (Context->ExtensionLength < 4)) {

                if (DbcsAware) {

                    OemLength += IsDbcsCharacter(wc) ? 2 : 1;

                    if (OemLength > 4) { break; }
                }

                Context->ExtensionBuffer[Context->ExtensionLength++] = wc;
            }

            //
            //  If we had to truncate the extension (i.e. input name was not
            //  exhausted), change the last char of the truncated extension
            //  to a ~ is user has selected safe extensions.
            //

            if (wc && FsRtlSafeExtensions) {

                Context->ExtensionBuffer[Context->ExtensionLength - 1] = L'~';
            }

        } else {

            Context->ExtensionLength = 0;
        }
    }

    //
    //  In all cases we add one to the index value and this is the value
    //  of the index we are going to generate this time around
    //

    Context->LastIndexValue += 1;

    //
    //  Now if the new index value is greater than 4 then we've had too
    //  many collisions and we should alter our basis if possible
    //

    if ((Context->LastIndexValue > 4) && !Context->ChecksumInserted) {

        USHORT Checksum;
        WCHAR Nibble;

        //
        // 'XX' is represented A DBCS character.
        //
        // LongName       -> ShortName  | DbcsBias  Oem  Unicode
        // -----------------------------+------------------------
        // XXXXThisisapen -> XX1234     |    1       6      5
        // XXThisisapen   -> XX1234     |    1       6      5
        // aXXThisisapen  -> a1234      |    1       5      5
        // aaThisisapen   -> aa1234     |    0       6      6
        //

        ULONG DbcsBias;

        if (DbcsAware) {

              DbcsBias = ((IsDbcsCharacter(Context->NameBuffer[0]) ? 1 : 0) |
                          (IsDbcsCharacter(Context->NameBuffer[1]) ? 1 : 0));

        } else {

              DbcsBias = 0;
        }

        Checksum =
        Context->Checksum = RtlComputeLfnChecksum( Name );

        for (i = (2-DbcsBias); i < (6-DbcsBias); i++, Checksum >>= 4) {

            Nibble = Checksum & 0xf;
            Nibble += Nibble <= 9 ? '0' : 'A' - 10;

            Context->NameBuffer[ i ] = Nibble;
        }

        Context->NameLength = (UCHAR)(6-DbcsBias);
        Context->LastIndexValue = 1;
        Context->ChecksumInserted = TRUE;
    }

    //
    //  Now build the index buffer from high index to low index because we
    //  use a mod & div operation to build the string from the index value.
    //
    //  We also want to remember is we are about to rollover in base 10.
    //

    for (IndexLength = 1, i = Context->LastIndexValue;
         (IndexLength <= 7) && (i > 0);
         IndexLength += 1, i /= 10) {

        if ((IndexBuffer[ 8 - IndexLength] = (WCHAR)(L'0' + (i % 10))) != L'9') {

            IndexAll9s = FALSE;
        }
    }

    //
    //  And tack on the preceding dash
    //

    IndexBuffer[ 8 - IndexLength ] = L'~';

    //
    //  At this point everything is set up to copy to the output buffer.  First
    //  copy over the name and then only copy the index and extension if they exist
    //

    if (Context->NameLength != 0) {

        RtlCopyMemory( &Name8dot3->Buffer[0],
                       &Context->NameBuffer[0],
                       Context->NameLength * 2 );

        Name8dot3->Length = (USHORT)(Context->NameLength * 2);

    } else {

        Name8dot3->Length = 0;
    }

    //
    //  Now do the index.
    //

    RtlCopyMemory( &Name8dot3->Buffer[ Name8dot3->Length/2 ],
                   &IndexBuffer[ 8 - IndexLength ],
                   IndexLength * 2 );

    Name8dot3->Length += (USHORT) (IndexLength * 2);

    //
    //  Now conditionally do the extension
    //

    if (Context->ExtensionLength != 0) {

        RtlCopyMemory( &Name8dot3->Buffer[ Name8dot3->Length/2 ],
                       &Context->ExtensionBuffer[0],
                       Context->ExtensionLength * 2 );

        Name8dot3->Length += (USHORT) (Context->ExtensionLength * 2);
    }

    //
    //  If current index value is all 9s, then the next value will cause the
    //  index string to grow from it's current size.  In this case recompute
    //  Context->NameLength so that is will be correct for next time.
    //

    if (IndexAll9s) {

        if (DbcsAware) {

            for (i = 0, OemLength = 0; i < Context->NameLength; i++) {

                OemLength += IsDbcsCharacter(Context->NameBuffer[i]) ? 2 : 1;

                if (OemLength > 8 - (IndexLength + 1)) {
                    break;
                }
            }

            Context->NameLength = (UCHAR)i;

        } else {

            Context->NameLength -= 1;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


BOOLEAN
RtlIsValidOemCharacter (
    IN PWCHAR Char
)

/*++

Routine Description:

    This routine determines if the best-fitted and upcased version of the
    input unicode char is a valid Oem character.

Arguments:

    Char - Supplies the Unicode char and receives the best-fitted and
        upcased version if it was indeed valid.

Return Value:

    TRUE if the character was valid.

--*/

{
    WCHAR UniTmp;
    WCHAR OemChar;

    //
    //  First try to make a round trip from Unicode->Oem->Unicode.
    //

    if (!NlsMbOemCodePageTag) {

        UniTmp = (WCHAR)NLS_UPCASE(NlsOemToUnicodeData[(UCHAR)NlsUnicodeToOemData[*Char]]);
        OemChar = NlsUnicodeToOemData[UniTmp];

    } else {

        //
        // Convert to OEM and back to Unicode before upper casing
        // to ensure the visual best fits are converted and
        // upper cased properly.
        //

        OemChar = NlsUnicodeToMbOemData[ *Char ];

        if (NlsOemLeadByteInfo[HIBYTE(OemChar)]) {

            USHORT Entry;

            //
            // Lead byte - translate the trail byte using the table
            // that corresponds to this lead byte.
            //

            Entry = NlsOemLeadByteInfo[HIBYTE(OemChar)];
            UniTmp = (WCHAR)NlsMbOemCodePageTables[ Entry + LOBYTE(OemChar) ];

        } else {

            //
            // Single byte character.
            //

            UniTmp = NlsOemToUnicodeData[LOBYTE(OemChar)];
        }

        //
        //  Now upcase this UNICODE character, and convert it to Oem.
        //

        UniTmp = (WCHAR)NLS_UPCASE(UniTmp);
        OemChar = NlsUnicodeToMbOemData[UniTmp];
    }

    //
    //  Now if the final OemChar is the default one, then there was no
    //  mapping for this UNICODE character.
    //

    if (OemChar == OemDefaultChar) {

        return FALSE;

    } else {

        *Char = UniTmp;
        return TRUE;
    }
}


//
//  Local support routine
//

WCHAR
GetNextWchar (
    IN PUNICODE_STRING Name,
    IN PULONG CurrentIndex,
    IN BOOLEAN SkipDots,
    IN BOOLEAN AllowExtendedCharacters
    )

/*++

Routine Description:

    This routine scans the input name starting at the current index and
    returns the next valid character for the long name to 8.3 generation
    algorithm.  It also updates the current index to point to the
    next character to examine.

    The user can specify if dots are skipped over or passed back.  The
    filtering done by the procedure is:

    1. Skip characters less then blanks, and larger than 127 if
       AllowExtendedCharacters is FALSE
    2. Optionally skip over dots
    3. translate the special 7 characters : + , ; = [ ] into underscores

Arguments:

    Name - Supplies the name being examined

    CurrentIndex - Supplies the index to start our examination and also
        receives the index of one beyond the character we return.

    SkipDots - Indicates whether this routine will also skip over periods

    AllowExtendedCharacters - Tell whether charaacters >= 127 are valid.

Return Value:

    WCHAR - returns the next wchar in the name string

--*/

{
    WCHAR wc;

    //
    //  Until we find out otherwise the character we are going to return
    //  is 0
    //

    wc = 0;

    //
    //  Now loop through updating the current index until we either have a character to
    //  return or until we exhaust the name buffer
    //

    while (*CurrentIndex < (ULONG)(Name->Length/2)) {

        //
        //  Get the next character in the buffer
        //

        wc = Name->Buffer[*CurrentIndex];
        *CurrentIndex += 1;

        //
        //  If the character is to be skipped over then reset wc to 0
        //

        if ((wc <= L' ') ||
            ((wc >= 127) && (!AllowExtendedCharacters || !RtlIsValidOemCharacter(&wc))) ||
            ((wc == L'.') && SkipDots)) {

            wc = 0;

        } else {

            //
            //  We have a character to return, but first translate the character is necessary
            //

            if ((wc < 0x80) && (RtlFatIllegalTable[wc/32] & (1 << (wc%32)))) {

                wc = L'_';
            }

            //
            //  Do an a-z upcase.
            //

            if ((wc >= L'a') && (wc <= L'z')) {

                wc -= L'a' - L'A';
            }

            //
            //  And break out of the loop to return to our caller
            //

            break;
        }
    }

    //DebugTrace( 0, Dbg, "GetNextWchar -> %08x\n", wc);

    return wc;
}


//
//  Internal support routine
//

USHORT
RtlComputeLfnChecksum (
    PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine computes the Chicago long file name checksum.

Arguments:

    Name - Supplies the name to compute the checksum on.  Note that one
        character names don't have interesting checksums.

Return Value:

    The checksum.

--*/

{
    ULONG i;
    USHORT Checksum;

    RTL_PAGED_CODE();

    if (Name->Length == sizeof(WCHAR)) {

        return Name->Buffer[0];
    }

    Checksum = ((Name->Buffer[0] << 8) + Name->Buffer[1]) & 0xffff;

    //
    //  This checksum is kinda strange because we want to still have
    //  a good range even if all the characters are < 0x00ff.
    //

    for (i=2; i < Name->Length / sizeof(WCHAR); i+=2) {

        Checksum = (Checksum & 1 ? 0x8000 : 0) +
                   (Checksum >> 1) +
                   (Name->Buffer[i] << 8);

        //
        //  Be carefull to not walk off the end of the string.
        //

        if (i+1 < Name->Length / sizeof(WCHAR)) {

            Checksum += Name->Buffer[i+1] & 0xffff;
        }
    }

    return Checksum;
}


BOOLEAN
RtlIsNameLegalDOS8Dot3 (
    IN PUNICODE_STRING Name,
    IN OUT POEM_STRING OemName OPTIONAL,
    OUT PBOOLEAN NameContainsSpaces OPTIONAL
    )
/*++

Routine Description:

    This routine takes an input string and gives a definitive answer
    on whether this name can successfully be used to create a file
    on the FAT file system.

    This routine can therefore also be used to determine if a name is
    appropriate to be passed back to a Win31 or DOS app, i.e. whether
    the downlevel APP will understand the name.

    Note: an important part of this test is the mapping from UNICODE
    to Oem, which is why it is important that the input parameter be
    received in UNICODE.

Arguments:

    Name - The UNICODE name to test for conformance to 8.3 symantics.

    OemName - If specified, will receive the Oem name corresponding
        to the passed in Name.  Storage must be provided by the caller.
        The name is undefined if the routine returns FALSE.

    NameContainsSpaces - If the function returns TRUE, then this
        parameter will indicate if the names contains spaces.  If
        the function returns FALSE, this parameter is undefined. In
        many instances, the alternate name is more appropriate to
        use if spaces are present in the principle name, even if
        it is 8.3 compliant.

Return Value:

    BOOLEAN - TRUE if the passed in UNICODE name forms a valid 8.3
        FAT name when upcased to the current Oem code page.

--*/

{
    ULONG Index;
    BOOLEAN ExtensionPresent = FALSE;
    BOOLEAN SpacesPresent = FALSE;
    OEM_STRING LocalOemName;
    UCHAR Char;
    UCHAR OemBuffer[12];

    //
    //  If the name is more than 12 chars, bail.
    //

    if (Name->Length > 12*sizeof(WCHAR)) {
        return FALSE;
    }

    //
    //  Now upcase this name to Oem.  If anything goes wrong,
    //  return FALSE.
    //

    if (!ARGUMENT_PRESENT(OemName)) {

        OemName = &LocalOemName;

        OemName->Buffer = &OemBuffer[0];
        OemName->Length = 0;
        OemName->MaximumLength = 12;
    }

    if (!NT_SUCCESS(RtlUpcaseUnicodeStringToCountedOemString(OemName, Name, FALSE))) {
        return FALSE;
    }

    //
    //  Special case . and ..
    //

    if (((OemName->Length == 1) && (OemName->Buffer[0] == '.')) ||
        ((OemName->Length == 2) && (OemName->Buffer[0] == '.') && (OemName->Buffer[1] == '.'))) {

        if (ARGUMENT_PRESENT(NameContainsSpaces)) {
            *NameContainsSpaces = FALSE;
        }
        return TRUE;
    }

    //
    //  Now we are going to walk through the string looking for
    //  illegal characters and/or incorrect syntax.
    //

    for ( Index = 0; Index < OemName->Length; Index += 1 ) {

        Char = OemName->Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if (NlsMbOemCodePageTag && NlsOemLeadByteInfo[Char]) {

            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //

            if ((!ExtensionPresent && (Index >= 7)) ||
                (Index == (ULONG)(OemName->Length - 1))) {
                return FALSE;
            }

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal.
        //

        if ((Char < 0x80) &&
            (RtlFatIllegalTable[Char/32] & (1 << (Char%32)))) {
            return FALSE;
        }

        //
        //  Remember if there was a space.
        //

        if (Char == ' ') {
            SpacesPresent = TRUE;
        }

        if (Char == '.') {

            //
            //  We stepped onto a period.  We require the following things:
            //
            //      - There can only be one
            //      - It can't be the first character
            //      - The previous character can't be a space.
            //      - There can't be more than 3 bytes following
            //

            if (ExtensionPresent ||
                (Index == 0) ||
                (OemName->Buffer[Index - 1] == ' ') ||
                (OemName->Length - (Index + 1) > 3)) {

                return FALSE;
            }

            ExtensionPresent = TRUE;
        }

        //
        //  The base part of the name can't be more than 8 characters long.
        //

        if ((Index >= 8) && !ExtensionPresent) { return FALSE; }
    }

    //
    //  The name cannot end in a space or a period.
    //

    if ((Char == ' ') || (Char == '.')) { return FALSE; }

    if (ARGUMENT_PRESENT(NameContainsSpaces)) {
        *NameContainsSpaces = SpacesPresent;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\excptdbg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    excptdbg.c

Abstract:

    This module implements an exception dispatcher logging facility.

Author:

    Kent Forschmiedt (kentf) 05-Oct-1995

Revision History:

    Jonathan Schwartz (jschwart)  16-Jun-2000
        Added RtlUnhandledExceptionFilter

    Jay Krell (a-JayK) November 2000
        Added RtlUnhandledExceptionFilter2, takes __FUNCTION__ parameter

--*/

#include "ntrtlp.h"

PLAST_EXCEPTION_LOG RtlpExceptionLog;
ULONG RtlpExceptionLogCount;
ULONG RtlpExceptionLogSize;


VOID
RtlInitializeExceptionLog(
    IN ULONG Entries
    )
/*++

Routine Description:

    This routine allocates space for the exception dispatcher logging
    facility, and records the address and size of the log area in globals
    where they can be found by the debugger.

    If memory is not available, the table pointer will remain NULL
    and the logging functions will do nothing.

Arguments:

    Entries - Supplies the number of entries to allocate for

Return Value:

    None

--*/
{
#if defined(NTOS_KERNEL_RUNTIME)
    RtlpExceptionLog = (PLAST_EXCEPTION_LOG)ExAllocatePoolWithTag( NonPagedPool, sizeof(LAST_EXCEPTION_LOG) * Entries, 'gbdE' );
#else
    //RtlpExceptionLog = (PLAST_EXCEPTION_LOG)RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(LAST_EXCEPTION_LOG) * Entries );
#endif
    if (RtlpExceptionLog) {
        RtlpExceptionLogSize = Entries;
    }
}


ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    )
/*++

Routine Description:

    Records the dispatching of exceptions to frame-based handlers.
    The debugger may inspect the table later and interpret the data
    to discover the address of the filters and handlers.

Arguments:

    ExceptionRecord - Supplies an exception record

    ContextRecord - Supplies the context at the exception

    ControlPc - Supplies the PC where control left the frame being
        dispatched to.

    HandlerData - Supplies a pointer to the host-dependent exception
        data.  On the RISC machines this is a RUNTIME_FUNCTION record;
        on x86 it is the registration record from the stack frame.

    Size - Supplies the size of HandlerData

Returns:

    The index to the log entry used, so that if the handler returns
    a disposition it may be recorded.

--*/
{
#if !defined(NTOS_KERNEL_RUNTIME)

    return 0;

#else

    ULONG LogIndex;

    if (!RtlpExceptionLog) {
        return 0;
    }

    ASSERT(Size <= MAX_EXCEPTION_LOG_DATA_SIZE * sizeof(ULONG));

    do {
        LogIndex = RtlpExceptionLogCount;
    } while (LogIndex != (ULONG)InterlockedCompareExchange(
                                    (PLONG)&RtlpExceptionLogCount,
                                    ((LogIndex + 1) % MAX_EXCEPTION_LOG),
                                    LogIndex));

    //
    // the debugger will have to interpret the exception handler
    // data, because it cannot be done safely here.
    //

    RtlCopyMemory(RtlpExceptionLog[LogIndex].HandlerData,
                  HandlerData,
                  Size);
    RtlpExceptionLog[LogIndex].ExceptionRecord = *ExceptionRecord;
    RtlpExceptionLog[LogIndex].ContextRecord = *ContextRecord;
    RtlpExceptionLog[LogIndex].Disposition = -1;

    return LogIndex;
#endif  // !NTOS_KERNEL_RUNTIME
}


VOID
RtlpLogLastExceptionDisposition(
    ULONG LogIndex,
    EXCEPTION_DISPOSITION Disposition
    )
/*++

Routine Description:

    Records the disposition from an exception handler.

Arguments:

    LogIndex - Supplies the entry number of the exception log record.

    Disposition - Supplies the disposition code

Return Value:

    None

--*/

{
    // If MAX_EXCEPTION_LOG or more exceptions were dispatched while
    // this one was being handled, this disposition will get written
    // on the wrong record.  Oh well.
    if (RtlpExceptionLog) {
        RtlpExceptionLog[LogIndex].Disposition = Disposition;
    }
}

LONG
NTAPI
RtlUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    return RtlUnhandledExceptionFilter2(ExceptionInfo, "");
}

LONG
NTAPI
RtlUnhandledExceptionFilter2(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo,
    IN CONST CHAR*                 Function
    )
/*++

Routine Description:

    Default exception handler that prints info and does a DbgBreak if
    a debugger is attached to the machine.

Arguments:

    ExceptionInfo - Structure containing the exception and context records

    Function - the function containing the __except, such as returned by __FUNCTION__

Returns:

    EXCEPTION_CONTINUE_EXECUTION or EXCEPTION_CONTINUE_SEARCH

--*/

{
    LPCWSTR  lpProcessName = NtCurrentPeb()->ProcessParameters->CommandLine.Buffer;
    BOOLEAN  DebuggerPresent = NtCurrentPeb()->BeingDebugged;

    if (!DebuggerPresent)
    {
        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo = { 0 };

        NtQuerySystemInformation(
            SystemKernelDebuggerInformation,
            &KdInfo,
            sizeof(KdInfo),
            NULL);
        DebuggerPresent = KdInfo.KernelDebuggerEnabled;
    }

    if (DebuggerPresent)
    {
        switch ( ExceptionInfo->ExceptionRecord->ExceptionCode )
        {
            case STATUS_POSSIBLE_DEADLOCK:
            {
                PRTL_CRITICAL_SECTION CritSec;
                PRTL_CRITICAL_SECTION_DEBUG CritSecDebug;

                CritSec = (PRTL_CRITICAL_SECTION)
                              ExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ];

                if ( CritSec )
                {
                    try
                    {
                        CritSecDebug = CritSec->DebugInfo ;

                        if ( CritSecDebug->Type == RTL_RESOURCE_TYPE )
                        {
                            PRTL_RESOURCE Resource = (PRTL_RESOURCE) CritSec;

                            DbgPrint("\n\n *** Resource timeout (%p) in %ws:%s\n\n",
                                        Resource, lpProcessName, Function );

                            if ( Resource->NumberOfActive < 0 )
                            {
                                DbgPrint("The resource is owned exclusively by thread %x\n",
                                         Resource->ExclusiveOwnerThread);
                            }
                            else if ( Resource->NumberOfActive > 0 )
                            {
                                DbgPrint("The resource is owned shared by %d threads\n",
                                         Resource->NumberOfActive);
                            }
                            else
                            {
                                DbgPrint("The resource is unowned.  This usually implies a "
                                         "slow-moving machine due to memory pressure\n\n");
                            }
                        }
                        else
                        {
                            DbgPrint("\n\n *** Critical Section Timeout (%p) in %ws:%s\n\n",
                                     CritSec, lpProcessName, Function );

                            if (CritSec->OwningThread != 0)
                            {
                                DbgPrint("The critical section is owned by thread %x.\n",
                                         CritSec->OwningThread );
                                DbgPrint("Go determine why that thread has not released "
                                         "the critical section.\n\n" );
                            }
                            else
                            {
                                DbgPrint("The critical section is unowned.  This "
                                         "usually implies a slow-moving machine "
                                         "due to memory pressure\n\n");
                            }
                        }
                    }
                    except( EXCEPTION_EXECUTE_HANDLER )
                    {
                        NOTHING ;
                    }
                }

                break;
            }

            case STATUS_IN_PAGE_ERROR:

                DbgPrint("\n\n *** Inpage error in %ws:%s\n\n", lpProcessName, Function );
                DbgPrint("The instruction at %p referenced memory at %p.\n",
                    ExceptionInfo->ExceptionRecord->ExceptionAddress,
                    ExceptionInfo->ExceptionRecord->ExceptionInformation[1]);
                DbgPrint("This failed because of error %x.\n\n",
                    ExceptionInfo->ExceptionRecord->ExceptionInformation[2]);


                switch (ExceptionInfo->ExceptionRecord->ExceptionInformation[2])
                {
                    case STATUS_INSUFFICIENT_RESOURCES:

                        DbgPrint("This means the machine is out of memory.  Use !vm "
                                 "to see where all the memory is being used.\n\n");

                        break;

                    case STATUS_DEVICE_DATA_ERROR:
                    case STATUS_DISK_OPERATION_FAILED:

                        DbgPrint("This means the data could not be read, typically because "
                                 "of a bad block on the disk.  Check your hardware.\n\n");


                        break;

                    case STATUS_IO_DEVICE_ERROR:

                        DbgPrint("This means that the I/O device reported an I/O error.  "
                                 "Check your hardware.");

                        break;
                }

                break;

            case STATUS_ACCESS_VIOLATION:

                DbgPrint("\n\n *** An Access Violation occurred in %ws:%s\n\n", lpProcessName, Function );
                DbgPrint("The instruction at %p tried to %s ",
                    ExceptionInfo->ExceptionRecord->ExceptionAddress,
                    ExceptionInfo->ExceptionRecord->ExceptionInformation[0] ?
                        "write to" : "read from" );

                if ( ExceptionInfo->ExceptionRecord->ExceptionInformation[1] )
                {
                    DbgPrint("an invalid address, %p\n\n",
                        ExceptionInfo->ExceptionRecord->ExceptionInformation[1] );
                }
                else
                {
                    DbgPrint("a NULL pointer\n\n" );
                }

                break;

            default:

                DbgPrint("\n\n *** Unhandled exception 0x%08lx, hit in %ws:%s\n\n", ExceptionInfo->ExceptionRecord->ExceptionCode, lpProcessName, Function);
        }

        DbgPrint(" *** enter .exr %p for the exception record\n",
                 ExceptionInfo->ExceptionRecord);

        DbgPrint(" ***  enter .cxr %p for the context\n",
                 ExceptionInfo->ContextRecord);

        //
        // .cxr <foo> now changes the debugger state so kb
        // will do the trick (vs. !kb previously)
        //

        DbgPrint(" *** then kb to get the faulting stack\n\n");

        DbgBreakPoint();
    }

    if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_POSSIBLE_DEADLOCK)
    {
        if (DebuggerPresent)
        {
            DbgPrint(" *** Restarting wait on critsec or resource at %p (in %ws:%s)\n\n",
                     ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                     lpProcessName,
                     Function);
        }

        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\generr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    generr.c

Abstract:

    This module contains code to generate the NT status code to DOS
    error code table that is used by the runtime to translate status
    codes.

Author:

    David N. Cutler (davec) 2-Dec-1992

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <wtypes.h>
#include <status.h>
#include "stdio.h"
#include "stdarg.h"
#include "stdlib.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

//
// The following error code table contains paired entries in a singly
// dimensioned array. The first member of a paired entry is an NT status
// code and the second member is the DOS error code that it translates to.
//
// To add a value to this table simply insert the NT status/DOS error code
// pair anywhere is the table. If multiple NT status codes map to a single
// DOS error code, then insert a paired entry for each of the code pairs.
//
#ifdef i386
#pragma warning (4:4018)        // lower to -W4
#endif
LONG CodePairs[] = {

    //
    // First some marker entries so that generr.exe can locate this table
    // in generr.obj.  The following line must appear first in the table.
    //

    'Begi','n ge','nerr',' tbl',

    //
    // Exception codes defined in WINNT.H can map to themselves.
    //

    STATUS_BREAKPOINT, STATUS_BREAKPOINT,
    STATUS_SINGLE_STEP, STATUS_SINGLE_STEP,
    STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION,
    STATUS_NONCONTINUABLE_EXCEPTION, STATUS_NONCONTINUABLE_EXCEPTION,
    STATUS_INVALID_DISPOSITION, STATUS_INVALID_DISPOSITION,
    STATUS_PARITY_ERROR, STATUS_PARITY_ERROR,
    STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED,
    STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND,
    STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO,
    STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT,
    STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION,
    STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW,
    STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK,
    STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW,
    STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO,
    STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION,

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,
    STATUS_DATATYPE_MISALIGNMENT_ERROR, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_NO_LDT, ERROR_INVALID_THREAD_ID,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,
    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,
    STATUS_INVALID_IMPORT_OF_NON_DLL, ERROR_INVALID_IMPORT_OF_NON_DLL,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    RPC_NT_SS_IN_NULL_CONTEXT, ERROR_INVALID_HANDLE,
    RPC_NT_INVALID_BINDING, ERROR_INVALID_HANDLE,
    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,
    STATUS_VOLUME_NOT_UPGRADED, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_FILE_RENAMED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,
    STATUS_MUTUAL_AUTHENTICATION_FAILED, ERROR_MUTUAL_AUTH_FAILED,
    STATUS_TIME_DIFFERENCE_AT_DC, ERROR_TIME_SKEW,
    STATUS_PKINIT_FAILURE, ERROR_PKINIT_FAILURE,
    STATUS_SMARTCARD_SUBSYSTEM_FAILURE, ERROR_SMARTCARD_SUBSYSTEM_FAILURE,
    STATUS_DOWNGRADE_DETECTED, ERROR_DOWNGRADE_DETECTED,
    STATUS_SMARTCARD_CERT_REVOKED, SEC_E_SMARTCARD_CERT_REVOKED,
    STATUS_ISSUING_CA_UNTRUSTED, SEC_E_ISSUING_CA_UNTRUSTED,
    STATUS_REVOCATION_OFFLINE_C, SEC_E_REVOCATION_OFFLINE_C,
    STATUS_PKINIT_CLIENT_FAILURE, SEC_E_PKINIT_CLIENT_FAILURE,
    STATUS_SMARTCARD_CERT_EXPIRED,SEC_E_SMARTCARD_CERT_EXPIRED,
    STATUS_NO_KERB_KEY, SEC_E_NO_KERB_KEY,
    STATUS_CURRENT_DOMAIN_NOT_ALLOWED, ERROR_CURRENT_DOMAIN_NOT_ALLOWED,

    STATUS_SMARTCARD_WRONG_PIN, SCARD_W_WRONG_CHV,
    STATUS_SMARTCARD_CARD_BLOCKED, SCARD_W_CHV_BLOCKED,
    STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED, SCARD_W_CARD_NOT_AUTHENTICATED,
    STATUS_SMARTCARD_NO_CARD, SCARD_E_NO_SMARTCARD,
    STATUS_SMARTCARD_NO_KEY_CONTAINER, NTE_NO_KEY,
    STATUS_SMARTCARD_NO_CERTIFICATE, SCARD_E_NO_SUCH_CERTIFICATE,
    STATUS_SMARTCARD_NO_KEYSET, NTE_BAD_KEYSET,
    STATUS_SMARTCARD_IO_ERROR, SCARD_E_COMM_DATA_LOST,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,
    STATUS_FT_MISSING_MEMBER, ERROR_IO_DEVICE,
    STATUS_FT_ORPHANING, ERROR_IO_DEVICE,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_UNAVAILABLE, ERROR_CONNECTION_UNAVAIL,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_OVERRUN, ERROR_IO_DEVICE,
    STATUS_DATA_LATE_ERROR, ERROR_IO_DEVICE,
    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_CANNOT_MAKE, ERROR_CANNOT_MAKE,

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NOT_MZ, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_LE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_16, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_32, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_64, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_NOT_CONNECTED, ERROR_DEVICE_NOT_CONNECTED,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_NOT_FOUND, ERROR_NOT_FOUND,
    STATUS_NO_MATCH, ERROR_NO_MATCH,
    STATUS_PROPSET_NOT_FOUND, ERROR_SET_NOT_FOUND,


    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_ONLY_IF_CONNECTED, ERROR_ONLY_IF_CONNECTED,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_NOT_A_REPARSE_POINT, ERROR_NOT_A_REPARSE_POINT,
    STATUS_IO_REPARSE_TAG_INVALID, ERROR_REPARSE_TAG_INVALID,
    STATUS_IO_REPARSE_TAG_MISMATCH, ERROR_REPARSE_TAG_MISMATCH,
    STATUS_IO_REPARSE_TAG_NOT_HANDLED, ERROR_CANT_ACCESS_FILE,
    STATUS_REPARSE_POINT_NOT_RESOLVED, ERROR_CANT_RESOLVE_FILENAME,
    STATUS_DIRECTORY_IS_A_REPARSE_POINT, ERROR_BAD_PATHNAME,
    STATUS_REPARSE_ATTRIBUTE_CONFLICT, ERROR_REPARSE_ATTRIBUTE_CONFLICT,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_REPARSE_DATA,

    STATUS_FILE_IS_OFFLINE, ERROR_FILE_OFFLINE,
    STATUS_REMOTE_STORAGE_NOT_ACTIVE, ERROR_REMOTE_STORAGE_NOT_ACTIVE,
    STATUS_REMOTE_STORAGE_MEDIA_ERROR, ERROR_REMOTE_STORAGE_MEDIA_ERROR,
    STATUS_NO_TRACKING_SERVICE, ERROR_NO_TRACKING_SERVICE,

    STATUS_JOURNAL_DELETE_IN_PROGRESS, ERROR_JOURNAL_DELETE_IN_PROGRESS,
    STATUS_JOURNAL_NOT_ACTIVE, ERROR_JOURNAL_NOT_ACTIVE,
    STATUS_JOURNAL_ENTRY_DELETED, ERROR_JOURNAL_ENTRY_DELETED,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_BAD_MASTER_BOOT_RECORD, ERROR_INVALID_PARAMETER,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_OPLOCK_NOT_GRANTED, ERROR_OPLOCK_NOT_GRANTED,
    STATUS_INVALID_OPLOCK_PROTOCOL, ERROR_INVALID_OPLOCK_PROTOCOL,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_RXACT_INVALID_STATE, ERROR_RXACT_INVALID_STATE,

    STATUS_RXACT_COMMIT_FAILURE, ERROR_RXACT_COMMIT_FAILURE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_IO_DEVICE_ERROR, ERROR_IO_DEVICE,
    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,
    STATUS_DRIVER_INTERNAL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_SOURCE_ELEMENT_EMPTY,       ERROR_SOURCE_ELEMENT_EMPTY,
    STATUS_DESTINATION_ELEMENT_FULL,   ERROR_DESTINATION_ELEMENT_FULL,
    STATUS_ILLEGAL_ELEMENT_ADDRESS,    ERROR_ILLEGAL_ELEMENT_ADDRESS,
    STATUS_MAGAZINE_NOT_PRESENT,       ERROR_MAGAZINE_NOT_PRESENT,
    STATUS_REINITIALIZATION_NEEDED,    ERROR_DEVICE_REINITIALIZATION_NEEDED,
    STATUS_DEVICE_REQUIRES_CLEANING,   ERROR_DEVICE_REQUIRES_CLEANING,
    STATUS_DEVICE_DOOR_OPEN,           ERROR_DEVICE_DOOR_OPEN,
    STATUS_TRANSPORT_FULL,             ERROR_TRANSPORT_FULL,
    STATUS_CLEANER_CARTRIDGE_INSTALLED, ERROR_CLEANER_CARTRIDGE_INSTALLED,
    STATUS_REG_NAT_CONSUMPTION,        ERROR_REG_NAT_CONSUMPTION,

    STATUS_ENCRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_DECRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_NO_RECOVERY_POLICY,         ERROR_ACCESS_DENIED,
    STATUS_NO_EFS,                     ERROR_ACCESS_DENIED,
    STATUS_WRONG_EFS,                  ERROR_ACCESS_DENIED,
    STATUS_NO_USER_KEYS,               ERROR_ACCESS_DENIED,
    STATUS_FILE_NOT_ENCRYPTED,         ERROR_FILE_NOT_ENCRYPTED,
    STATUS_NOT_EXPORT_FORMAT,          ERROR_NOT_EXPORT_FORMAT,
    STATUS_FILE_ENCRYPTED,             ERROR_FILE_ENCRYPTED,
    STATUS_EFS_ALG_BLOB_TOO_BIG,       ERROR_EFS_ALG_BLOB_TOO_BIG,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_FLOPPY_ID_MARK_NOT_FOUND, ERROR_FLOPPY_ID_MARK_NOT_FOUND,

    STATUS_FLOPPY_WRONG_CYLINDER, ERROR_FLOPPY_WRONG_CYLINDER,

    STATUS_FLOPPY_UNKNOWN_ERROR, ERROR_FLOPPY_UNKNOWN_ERROR,

    STATUS_FLOPPY_BAD_REGISTERS, ERROR_FLOPPY_BAD_REGISTERS,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    STATUS_WMI_GUID_NOT_FOUND, ERROR_WMI_GUID_NOT_FOUND,
    STATUS_WMI_INSTANCE_NOT_FOUND, ERROR_WMI_INSTANCE_NOT_FOUND,
    STATUS_WMI_ITEMID_NOT_FOUND, ERROR_WMI_ITEMID_NOT_FOUND,
    STATUS_WMI_TRY_AGAIN, ERROR_WMI_TRY_AGAIN,
    STATUS_WMI_READ_ONLY, ERROR_WMI_READ_ONLY,
    STATUS_WMI_SET_FAILURE, ERROR_WMI_SET_FAILURE,
    STATUS_WMI_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_WMI_GUID_DISCONNECTED, ERROR_WMI_GUID_DISCONNECTED,
    STATUS_WMI_ALREADY_DISABLED, ERROR_WMI_ALREADY_DISABLED,
    STATUS_WMI_ALREADY_ENABLED, ERROR_WMI_ALREADY_ENABLED,

    STATUS_COPY_PROTECTION_FAILURE    , STG_E_STATUS_COPY_PROTECTION_FAILURE,
    STATUS_CSS_AUTHENTICATION_FAILURE , STG_E_CSS_AUTHENTICATION_FAILURE,
    STATUS_CSS_KEY_NOT_PRESENT        , STG_E_CSS_KEY_NOT_PRESENT,
    STATUS_CSS_KEY_NOT_ESTABLISHED    , STG_E_CSS_KEY_NOT_ESTABLISHED,
    STATUS_CSS_SCRAMBLED_SECTOR       , STG_E_CSS_SCRAMBLED_SECTOR,
    STATUS_CSS_REGION_MISMATCH        , STG_E_CSS_REGION_MISMATCH,
    STATUS_CSS_RESETS_EXHAUSTED       , STG_E_RESETS_EXHAUSTED,

    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,

    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,

    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,

    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,

    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,

    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,

    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,

    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,

    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,

    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,

    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,

    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,

    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,

    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,

    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,

    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,

    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,

    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,

    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,

    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,

    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,

    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,

    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,

    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,

    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,

    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,

    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,

    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,

    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,

    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,

    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,

    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,

    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,

    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,

    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,

    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,

    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,

    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,

    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,

    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,

    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,

    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,

    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,

    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,

    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,

    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,

    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,

    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,

    EPT_NT_INVALID_ENTRY, EPT_S_INVALID_ENTRY,

    EPT_NT_CANT_PERFORM_OP, EPT_S_CANT_PERFORM_OP,

    EPT_NT_NOT_REGISTERED, EPT_S_NOT_REGISTERED,

    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,

    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,

    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,

    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,

    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,

    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,

    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,

    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,

    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,

    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,

    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,

    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,

    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,

    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,

    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,

    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,

    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,

    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,

    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,

    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,

    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,

    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,

    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,

    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,

    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,

    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,

    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,

    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,

    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,

    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    RPC_NT_CALL_IN_PROGRESS, RPC_S_CALL_IN_PROGRESS,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,

    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,

    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,

    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,

    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,

    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,

    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,

    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,

    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,

    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,

    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,

    RPC_NT_INVALID_PIPE_OBJECT,    RPC_X_INVALID_PIPE_OBJECT,
    RPC_NT_INVALID_PIPE_OPERATION, RPC_X_INVALID_PIPE_OPERATION,
    RPC_NT_WRONG_PIPE_VERSION,     RPC_X_WRONG_PIPE_VERSION,

    EPT_NT_CANT_CREATE,            EPT_S_CANT_CREATE,

    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_HOST_DOWN, ERROR_HOST_DOWN,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,
    STATUS_OBJECTID_NOT_FOUND, ERROR_FILE_NOT_FOUND,
    STATUS_MFT_TOO_FRAGMENTED, ERROR_DISK_TOO_FRAGMENTED,
    SEC_E_INSUFFICIENT_MEMORY, ERROR_NO_SYSTEM_RESOURCES,
    SEC_E_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    SEC_E_UNSUPPORTED_FUNCTION, ERROR_INVALID_FUNCTION,
    SEC_E_TARGET_UNKNOWN, ERROR_BAD_NETPATH,
    SEC_E_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,
    SEC_E_SECPKG_NOT_FOUND, ERROR_NO_SUCH_PACKAGE,
    SEC_E_NOT_OWNER, ERROR_NOT_OWNER,
    SEC_E_CANNOT_INSTALL, ERROR_NO_SUCH_PACKAGE,
    SEC_E_INVALID_TOKEN, ERROR_INVALID_PARAMETER,
    SEC_E_CANNOT_PACK, ERROR_INVALID_PARAMETER,
    SEC_E_QOP_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    SEC_E_NO_IMPERSONATION, ERROR_CANNOT_IMPERSONATE,
    SEC_E_MULTIPLE_ACCOUNTS, ERROR_CANNOT_IMPERSONATE,
    SEC_E_LOGON_DENIED, ERROR_LOGON_FAILURE,
    SEC_E_UNKNOWN_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_INCOMPLETE_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_NO_CREDENTIALS, ERROR_NO_SUCH_LOGON_SESSION,
    SEC_E_MESSAGE_ALTERED, ERROR_ACCESS_DENIED,
    SEC_E_OUT_OF_SEQUENCE, ERROR_ACCESS_DENIED,
    SEC_E_NO_AUTHENTICATING_AUTHORITY, ERROR_NO_LOGON_SERVERS,
    SEC_E_BAD_PKGID, ERROR_NO_SUCH_PACKAGE,
    SEC_E_WRONG_PRINCIPAL, ERROR_WRONG_TARGET_NAME,
    SEC_E_INCOMPLETE_MESSAGE, ERROR_INVALID_USER_BUFFER,
    SEC_E_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,
    SEC_E_UNTRUSTED_ROOT, ERROR_TRUST_FAILURE,
    SEC_E_ILLEGAL_MESSAGE, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_UNKNOWN, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_EXPIRED, ERROR_PASSWORD_EXPIRED,
    SEC_E_ENCRYPT_FAILURE, ERROR_ENCRYPTION_FAILED,
    SEC_E_DECRYPT_FAILURE, ERROR_DECRYPTION_FAILED,
    SEC_E_ALGORITHM_MISMATCH, ERROR_INVALID_FUNCTION,
    SEC_E_CONTEXT_EXPIRED, ERROR_CONTEXT_EXPIRED,

    STATUS_BAD_BINDINGS, SEC_E_BAD_BINDINGS,

    TRUST_E_CERT_SIGNATURE, ERROR_MUTUAL_AUTH_FAILED,
    CRYPT_E_REVOKED, ERROR_MUTUAL_AUTH_FAILED,
    CRYPT_E_NO_REVOCATION_CHECK, ERROR_MUTUAL_AUTH_FAILED,
    CRYPT_E_REVOCATION_OFFLINE, ERROR_MUTUAL_AUTH_FAILED,

    STATUS_SHUTDOWN_IN_PROGRESS, ERROR_SHUTDOWN_IN_PROGRESS,
    STATUS_SERVER_SHUTDOWN_IN_PROGRESS, ERROR_SERVER_SHUTDOWN_IN_PROGRESS,
    STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY,ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY,

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE,ERROR_DS_NO_ATTRIBUTE_OR_VALUE,

    STATUS_DS_INVALID_ATTRIBUTE_SYNTAX,ERROR_DS_INVALID_ATTRIBUTE_SYNTAX,

    STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED,ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED,

    STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS,ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS,

    STATUS_DS_BUSY,ERROR_DS_BUSY,

    STATUS_DS_UNAVAILABLE,ERROR_DS_UNAVAILABLE,

    STATUS_DS_NO_RIDS_ALLOCATED,ERROR_DS_NO_RIDS_ALLOCATED,

    STATUS_DS_NO_MORE_RIDS,ERROR_DS_NO_MORE_RIDS,

    STATUS_DS_INCORRECT_ROLE_OWNER,ERROR_DS_INCORRECT_ROLE_OWNER,

    STATUS_DS_RIDMGR_INIT_ERROR,ERROR_DS_RIDMGR_INIT_ERROR,

    STATUS_DS_OBJ_CLASS_VIOLATION,ERROR_DS_OBJ_CLASS_VIOLATION,

    STATUS_DS_CANT_ON_NON_LEAF,ERROR_DS_CANT_ON_NON_LEAF,

    STATUS_DS_CANT_ON_RDN,ERROR_DS_CANT_ON_RDN,

    STATUS_DS_CROSS_DOM_MOVE_FAILED,ERROR_DS_CROSS_DOM_MOVE_ERROR,

    STATUS_DS_GC_NOT_AVAILABLE,ERROR_DS_GC_NOT_AVAILABLE,

    STATUS_DS_CANT_MOD_OBJ_CLASS, ERROR_DS_CANT_MOD_OBJ_CLASS,

    STATUS_DS_ADMIN_LIMIT_EXCEEDED, ERROR_DS_ADMIN_LIMIT_EXCEEDED,

    STATUS_DIRECTORY_SERVICE_REQUIRED, ERROR_DS_DS_REQUIRED,

    STATUS_DS_SAM_INIT_FAILURE, ERROR_DS_SAM_INIT_FAILURE,

    STATUS_DS_CANT_START, ERROR_DS_CANT_START,

    STATUS_DS_INIT_FAILURE, ERROR_DS_INIT_FAILURE,

    STATUS_SAM_INIT_FAILURE, ERROR_SAM_INIT_FAILURE,

    STATUS_DS_SENSITIVE_GROUP_VIOLATION, ERROR_DS_SENSITIVE_GROUP_VIOLATION,

    STATUS_DS_CANT_MOD_PRIMARYGROUPID, ERROR_DS_CANT_MOD_PRIMARYGROUPID,

    STATUS_DS_INVALID_GROUP_TYPE, ERROR_DS_INVALID_GROUP_TYPE,

    STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN, ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN,

    STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN, ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN,

    STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER, ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER,

    STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER, ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER,

    STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER, ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER,

    STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER, ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER,

    STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER, ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER,

    STATUS_DS_HAVE_PRIMARY_MEMBERS, ERROR_DS_HAVE_PRIMARY_MEMBERS,

    STATUS_DS_GC_REQUIRED, ERROR_DS_GC_REQUIRED,

    STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY, ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY,

    STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS, ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS,

    STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED, ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED,

    STATUS_SAM_NEED_BOOTKEY_PASSWORD, ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD,

    STATUS_SAM_NEED_BOOTKEY_FLOPPY, ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY,

    STATUS_DS_INIT_FAILURE_CONSOLE, ERROR_DS_INIT_FAILURE_CONSOLE,

    STATUS_DS_SAM_INIT_FAILURE_CONSOLE, ERROR_DS_SAM_INIT_FAILURE_CONSOLE,

    STATUS_UNFINISHED_CONTEXT_DELETED, SEC_E_UNFINISHED_CONTEXT_DELETED,

    STATUS_NO_TGT_REPLY, SEC_E_NO_TGT_REPLY,

    STATUS_NO_IP_ADDRESSES, SEC_E_NO_IP_ADDRESSES,

    STATUS_WRONG_CREDENTIAL_HANDLE, SEC_E_WRONG_CREDENTIAL_HANDLE,

    STATUS_CRYPTO_SYSTEM_INVALID, SEC_E_CRYPTO_SYSTEM_INVALID,

    STATUS_MAX_REFERRALS_EXCEEDED, SEC_E_MAX_REFERRALS_EXCEEDED,

    STATUS_MUST_BE_KDC, SEC_E_MUST_BE_KDC,

    STATUS_STRONG_CRYPTO_NOT_SUPPORTED, SEC_E_STRONG_CRYPTO_NOT_SUPPORTED,

    STATUS_TOO_MANY_PRINCIPALS, SEC_E_TOO_MANY_PRINCIPALS,

    STATUS_NO_PA_DATA, SEC_E_NO_PA_DATA,

    STATUS_PKINIT_NAME_MISMATCH, SEC_E_PKINIT_NAME_MISMATCH,

    STATUS_SMARTCARD_LOGON_REQUIRED, SEC_E_SMARTCARD_LOGON_REQUIRED,

    STATUS_KDC_INVALID_REQUEST, SEC_E_KDC_INVALID_REQUEST,

    STATUS_KDC_UNABLE_TO_REFER, SEC_E_KDC_UNABLE_TO_REFER,

    STATUS_KDC_UNKNOWN_ETYPE, SEC_E_KDC_UNKNOWN_ETYPE,

    STATUS_UNSUPPORTED_PREAUTH, SEC_E_UNSUPPORTED_PREAUTH,

    STATUS_SHARED_POLICY,ERROR_SHARED_POLICY,

    STATUS_POLICY_OBJECT_NOT_FOUND,ERROR_POLICY_OBJECT_NOT_FOUND,

    STATUS_POLICY_ONLY_IN_DS,ERROR_POLICY_ONLY_IN_DS,

    STATUS_DEVICE_REMOVED,ERROR_DEVICE_REMOVED,

    STATUS_RETRY,ERROR_RETRY,

    STATUS_NOT_SUPPORTED_ON_SBS, ERROR_NOT_SUPPORTED_ON_SBS,

    STATUS_DRIVER_BLOCKED_CRITICAL, ERROR_DRIVER_BLOCKED,
    STATUS_DRIVER_BLOCKED, ERROR_DRIVER_BLOCKED,

    STATUS_PRENT4_MACHINE_ACCOUNT, ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4,

    STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER, ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER,

    STATUS_DS_SHUTTING_DOWN, ERROR_DS_SHUTTING_DOWN,

    STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT, ERROR_ACCESS_DISABLED_BY_POLICY,
    STATUS_ACCESS_DISABLED_BY_POLICY_PATH, ERROR_ACCESS_DISABLED_BY_POLICY,
    STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER, ERROR_ACCESS_DISABLED_BY_POLICY,
    STATUS_ACCESS_DISABLED_BY_POLICY_OTHER, ERROR_ACCESS_DISABLED_BY_POLICY,

    STATUS_FAIL_CHECK, ERROR_INVALID_PARAMETER,

    // Terminal Server Entries

    STATUS_CTX_CLOSE_PENDING,               ERROR_CTX_CLOSE_PENDING,
    STATUS_CTX_NO_OUTBUF,                   ERROR_CTX_NO_OUTBUF,
    STATUS_CTX_MODEM_INF_NOT_FOUND,         ERROR_CTX_MODEM_INF_NOT_FOUND,
    STATUS_CTX_INVALID_MODEMNAME,           ERROR_CTX_INVALID_MODEMNAME,
    STATUS_CTX_RESPONSE_ERROR,              ERROR_CTX_MODEM_RESPONSE_ERROR,
    STATUS_CTX_MODEM_RESPONSE_TIMEOUT,      ERROR_CTX_MODEM_RESPONSE_TIMEOUT,
    STATUS_CTX_MODEM_RESPONSE_NO_CARRIER,   ERROR_CTX_MODEM_RESPONSE_NO_CARRIER,
    STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE,  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE,
    STATUS_CTX_MODEM_RESPONSE_BUSY,         ERROR_CTX_MODEM_RESPONSE_BUSY,
    STATUS_CTX_MODEM_RESPONSE_VOICE,        ERROR_CTX_MODEM_RESPONSE_VOICE,
    STATUS_CTX_TD_ERROR,                    ERROR_CTX_TD_ERROR,
    STATUS_LPC_REPLY_LOST,                  ERROR_CONNECTION_ABORTED,
    STATUS_CTX_WINSTATION_NAME_INVALID,     ERROR_CTX_WINSTATION_NAME_INVALID,
    STATUS_CTX_WINSTATION_NOT_FOUND,        ERROR_CTX_WINSTATION_NOT_FOUND,
    STATUS_CTX_WINSTATION_NAME_COLLISION,   ERROR_CTX_WINSTATION_ALREADY_EXISTS,
    STATUS_CTX_WINSTATION_BUSY,             ERROR_CTX_WINSTATION_BUSY,
    STATUS_CTX_GRAPHICS_INVALID,            ERROR_CTX_GRAPHICS_INVALID,
    STATUS_CTX_BAD_VIDEO_MODE,              ERROR_CTX_BAD_VIDEO_MODE,
    STATUS_CTX_NOT_CONSOLE,                 ERROR_CTX_NOT_CONSOLE,
    STATUS_CTX_CLIENT_QUERY_TIMEOUT,        ERROR_CTX_CLIENT_QUERY_TIMEOUT,
    STATUS_CTX_CONSOLE_DISCONNECT,          ERROR_CTX_CONSOLE_DISCONNECT,
    STATUS_CTX_CONSOLE_CONNECT,             ERROR_CTX_CONSOLE_CONNECT,
    STATUS_CTX_SHADOW_DENIED,               ERROR_CTX_SHADOW_DENIED,
    STATUS_CTX_SHADOW_INVALID,              ERROR_CTX_SHADOW_INVALID,
    STATUS_CTX_SHADOW_DISABLED,             ERROR_CTX_SHADOW_DISABLED,
    STATUS_CTX_WINSTATION_ACCESS_DENIED,    ERROR_CTX_WINSTATION_ACCESS_DENIED,
    STATUS_CTX_INVALID_PD,                  ERROR_CTX_INVALID_PD,
    STATUS_CTX_PD_NOT_FOUND,                ERROR_CTX_PD_NOT_FOUND,
    STATUS_CTX_INVALID_WD,                  ERROR_CTX_INVALID_WD,
    STATUS_CTX_WD_NOT_FOUND,                ERROR_CTX_WD_NOT_FOUND,
    STATUS_CTX_CLIENT_LICENSE_IN_USE,       ERROR_CTX_CLIENT_LICENSE_IN_USE,
    STATUS_CTX_CLIENT_LICENSE_NOT_SET,      ERROR_CTX_CLIENT_LICENSE_NOT_SET,
    STATUS_CTX_LICENSE_NOT_AVAILABLE,       ERROR_CTX_LICENSE_NOT_AVAILABLE,
    STATUS_CTX_LICENSE_CLIENT_INVALID,      ERROR_CTX_LICENSE_CLIENT_INVALID,
    STATUS_CTX_LICENSE_EXPIRED,             ERROR_CTX_LICENSE_EXPIRED,
    STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE, ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE,
    STATUS_CTX_SHADOW_NOT_RUNNING,          ERROR_CTX_SHADOW_NOT_RUNNING,
    STATUS_LICENSE_VIOLATION,               ERROR_CTX_LICENSE_NOT_AVAILABLE,


    // Smb Server Entries

    STATUS_ENDPOINT_CLOSED,                 ERROR_DEV_NOT_EXIST,
    STATUS_DISCONNECTED,                    ERROR_DEV_NOT_EXIST,
    STATUS_NONEXISTENT_NET_NAME,            ERROR_DEV_NOT_EXIST,
    STATUS_NETWORK_SESSION_EXPIRED,         ERROR_NO_USER_SESSION_KEY,

    STATUS_FILES_OPEN,                      ERROR_OPEN_FILES,

    STATUS_SXS_SECTION_NOT_FOUND,           ERROR_SXS_SECTION_NOT_FOUND,
    STATUS_SXS_CANT_GEN_ACTCTX,             ERROR_SXS_CANT_GEN_ACTCTX,
    STATUS_SXS_INVALID_ACTCTXDATA_FORMAT,   ERROR_SXS_INVALID_ACTCTXDATA_FORMAT,
    STATUS_SXS_ASSEMBLY_NOT_FOUND,          ERROR_SXS_ASSEMBLY_NOT_FOUND,
    STATUS_SXS_MANIFEST_FORMAT_ERROR,       ERROR_SXS_MANIFEST_FORMAT_ERROR,
    STATUS_SXS_MANIFEST_PARSE_ERROR,        ERROR_SXS_MANIFEST_PARSE_ERROR,
    STATUS_SXS_ACTIVATION_CONTEXT_DISABLED, ERROR_SXS_ACTIVATION_CONTEXT_DISABLED,
    STATUS_SXS_KEY_NOT_FOUND,               ERROR_SXS_KEY_NOT_FOUND,
    STATUS_SXS_WRONG_SECTION_TYPE,          ERROR_SXS_WRONG_SECTION_TYPE,
    STATUS_SXS_THREAD_QUERIES_DISABLED,     ERROR_SXS_THREAD_QUERIES_DISABLED,
    STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET, ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET,

    STATUS_REDIRECTOR_STARTED,              ERROR_SERVICE_ALREADY_RUNNING,
    STATUS_AUDITING_DISABLED,               ERROR_AUDITING_DISABLED,

    // Cluster Entries
    STATUS_CLUSTER_NODE_ALREADY_UP,         ERROR_CLUSTER_NODE_ALREADY_UP,
    STATUS_CLUSTER_NODE_ALREADY_DOWN,       ERROR_CLUSTER_NODE_ALREADY_DOWN,
    STATUS_CLUSTER_NETWORK_ALREADY_ONLINE,  ERROR_CLUSTER_NETWORK_ALREADY_ONLINE,
    STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE, ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE,
    STATUS_CLUSTER_NODE_ALREADY_MEMBER,     ERROR_CLUSTER_NODE_ALREADY_MEMBER,

    STATUS_CLUSTER_INVALID_NODE,            ERROR_CLUSTER_INVALID_NODE,
    STATUS_CLUSTER_NODE_EXISTS,             ERROR_CLUSTER_NODE_EXISTS,
    STATUS_CLUSTER_JOIN_IN_PROGRESS,        ERROR_CLUSTER_JOIN_IN_PROGRESS,
    STATUS_CLUSTER_NODE_NOT_FOUND,          ERROR_CLUSTER_NODE_NOT_FOUND,
    STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND,    ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND,
    STATUS_CLUSTER_NETWORK_EXISTS,          ERROR_CLUSTER_NETWORK_EXISTS,
    STATUS_CLUSTER_NETWORK_NOT_FOUND,       ERROR_CLUSTER_NETWORK_NOT_FOUND,
    STATUS_CLUSTER_NETINTERFACE_EXISTS,     ERROR_CLUSTER_NETINTERFACE_EXISTS,
    STATUS_CLUSTER_NETINTERFACE_NOT_FOUND,  ERROR_CLUSTER_NETINTERFACE_NOT_FOUND,
    STATUS_CLUSTER_INVALID_REQUEST,         ERROR_CLUSTER_INVALID_REQUEST,
    STATUS_CLUSTER_INVALID_NETWORK_PROVIDER,ERROR_CLUSTER_INVALID_NETWORK_PROVIDER,
    STATUS_CLUSTER_NODE_DOWN,               ERROR_CLUSTER_NODE_DOWN,
    STATUS_CLUSTER_NODE_UNREACHABLE,        ERROR_CLUSTER_NODE_UNREACHABLE,
    STATUS_CLUSTER_NODE_NOT_MEMBER,         ERROR_CLUSTER_NODE_NOT_MEMBER,
    STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS,    ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS,
    STATUS_CLUSTER_INVALID_NETWORK,         ERROR_CLUSTER_INVALID_NETWORK,
    STATUS_CLUSTER_NODE_UP,                 ERROR_CLUSTER_NODE_UP,
    STATUS_CLUSTER_NODE_PAUSED,             ERROR_CLUSTER_NODE_PAUSED,
    STATUS_CLUSTER_NODE_NOT_PAUSED,         ERROR_CLUSTER_NODE_NOT_PAUSED,
    STATUS_CLUSTER_NO_SECURITY_CONTEXT,     ERROR_CLUSTER_NO_SECURITY_CONTEXT,
    STATUS_CLUSTER_NETWORK_NOT_INTERNAL,    ERROR_CLUSTER_NETWORK_NOT_INTERNAL,

    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\gentable.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Gentable.c

Abstract:

    This module implements the generic table package.

Author:

    Gary Kimura     [GaryKi]    23-May-1989

Environment:

    Pure Utility Routines

Revision History:

    Anthony V. Ercolano [tonye] 23-May-1990

    Implement package.

    Anthony V. Ercolano [tonye] 1-Jun-1990

    Added ability to get elements out in the order
    inserted.  *NOTE* *NOTE* This depends on the implicit
    ordering of record fields:

        SPLAY_LINKS,
        LIST_ENTRY,
        USER_DATA

--*/

#include <nt.h>

#include <ntrtl.h>

#pragma pack(8)

//
// This structure is the header for a generic table entry.
// Align this structure on a 8 byte boundary so the user
// data is correctly aligned.
//

typedef struct _TABLE_ENTRY_HEADER {

    RTL_SPLAY_LINKS SplayLinks;
    LIST_ENTRY ListEntry;
    LONGLONG UserData;

} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

#pragma pack()


static
TABLE_SEARCH_RESULT
FindNodeOrParent(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    OUT PRTL_SPLAY_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is used by all of the routines of the generic
    table package to locate the a node in the tree.  It will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Table - The generic table to search for the key.

    Buffer - Pointer to a buffer holding the key.  The table
             package doesn't examine the key itself.  It leaves
             this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is TableEmptyTree.

Return Value:

    TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent
                                          is *not* altered.

                          TableFoundNode: A node with the key is in the tree.
                                          NodeOrParent points to that node.

                          TableInsertAsLeft: Node with key was not found.
                                             NodeOrParent points to what would be
                                             parent.  The node would be the left
                                             child.

                          TableInsertAsRight: Node with key was not found.
                                              NodeOrParent points to what would be
                                              parent.  The node would be the right
                                              child.

--*/



{

    if (RtlIsGenericTableEmpty(Table)) {

        return TableEmptyTree;

    } else {

        //
        // Used as the iteration variable while stepping through
        // the generic table.
        //
        PRTL_SPLAY_LINKS NodeToExamine = Table->TableRoot;

        //
        // Just a temporary.  Hopefully a good compiler will get
        // rid of it.
        //
        PRTL_SPLAY_LINKS Child;

        //
        // Holds the value of the comparasion.
        //
        RTL_GENERIC_COMPARE_RESULTS Result;

        while (TRUE) {

            //
            // Compare the buffer with the key in the tree element.
            //

            Result = Table->CompareRoutine(
                         Table,
                         Buffer,
                         &((PTABLE_ENTRY_HEADER) NodeToExamine)->UserData
                         );

            if (Result == GenericLessThan) {

                if (Child = RtlLeftChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsLeft;

                }

            } else if (Result == GenericGreaterThan) {

                if (Child = RtlRightChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return TableInsertAsRight;

                }


            } else {

                //
                // Node is in the tree (or it better be because of the
                // assert).  Set the output parameter to point to
                // the node and tell the caller that we found the node.
                //

                ASSERT(Result == GenericEqual);
                *NodeOrParent = NodeToExamine;
                return TableFoundNode;

            }

        }

    }

}

VOID
RtlInitializeGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    )

/*++

Routine Description:

    The procedure InitializeGenericTable takes as input an uninitialized
    generic table variable and pointers to the three user supplied routines.
    This must be called for every individual generic table variable before
    it can be used.

Arguments:

    Table - Pointer to the generic table to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - User routine to call to allocate memory for a new
                      node in the generic table.

    FreeRoutine - User routine to call to deallocate memory for
                        a node in the generic table.

    TableContext - Supplies user supplied context for the table.

Return Value:

    None.

--*/

{

    //
    // Initialize each field of the Table parameter.
    //

    Table->TableRoot = NULL;
    InitializeListHead(&Table->InsertOrderList);
    Table->NumberGenericTableElements = 0;
    Table->OrderedPointer = &Table->InsertOrderList;
    Table->WhichOrderedElement = 0;
    Table->CompareRoutine = CompareRoutine;
    Table->AllocateRoutine = AllocateRoutine;
    Table->FreeRoutine = FreeRoutine;
    Table->TableContext = TableContext;

}


PVOID
RtlInsertElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    )

/*++

Routine Description:

    The function InsertElementGenericTable will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element (which is
    the first available space after the splay links).  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the SPLAY_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(SPLAY_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{

    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    //
    //  Call the full routine to do the real work.
    //

    return RtlInsertElementGenericTableFull(
                Table,
                Buffer,
                BufferSize,
                NewElement,
                NodeOrParent,
                Lookup
                );
}


PVOID
RtlInsertElementGenericTableFull (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    TABLE_SEARCH_RESULT SearchResult
    )

/*++

Routine Description:

    The function InsertElementGenericTableFull will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element.  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.
    This routine is passed the NodeOrParent and SearchResult from a
    previous RtlLookupElementGenericTableFull.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the SPLAY_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(SPLAY_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

   NodeOrParent - Result of prior RtlLookupElementGenericTableFull.

   SearchResult - Result of prior RtlLookupElementGenericTableFull.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{
    //
    // Node will point to the splay links of what
    // will be returned to the user.
    //

    PRTL_SPLAY_LINKS NodeToReturn;

    if (SearchResult != TableFoundNode) {

        //
        // We just check that the table isn't getting
        // too big.
        //

        ASSERT(Table->NumberGenericTableElements != (MAXULONG-1));

        //
        // The node wasn't in the (possibly empty) tree.
        // Call the user allocation routine to get space
        // for the new node.
        //

        NodeToReturn = Table->AllocateRoutine(
                           Table,
                           BufferSize+FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData )
                           );

        //
        // If the return is NULL, return NULL from here to indicate that
        // the entry could not be added.
        //

        if (NodeToReturn == NULL) {

            if (ARGUMENT_PRESENT(NewElement)) {

                *NewElement = FALSE;
            }

            return(NULL);
        }

        RtlInitializeSplayLinks(NodeToReturn);

        //
        // Insert the new node at the end of the ordered linked list.
        //

        InsertTailList(
            &Table->InsertOrderList,
            &((PTABLE_ENTRY_HEADER) NodeToReturn)->ListEntry
            );

        Table->NumberGenericTableElements++;

        //
        // Insert the new node in the tree.
        //

        if (SearchResult == TableEmptyTree) {

            Table->TableRoot = NodeToReturn;

        } else {

            if (SearchResult == TableInsertAsLeft) {

                RtlInsertAsLeftChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            } else {

                RtlInsertAsRightChild(
                    NodeOrParent,
                    NodeToReturn
                    );
            }
        }

        //
        // Copy the users buffer into the user data area of the table.
        //

        RtlCopyMemory(
            &((PTABLE_ENTRY_HEADER) NodeToReturn)->UserData,
            Buffer,
            BufferSize
            );

    } else {

        NodeToReturn = NodeOrParent;
    }

    //
    // Always splay the (possibly) new node.
    //

    Table->TableRoot = RtlSplay(NodeToReturn);

    if (ARGUMENT_PRESENT(NewElement)) {

        *NewElement = ((SearchResult == TableFoundNode)?(FALSE):(TRUE));
    }

    //
    // Insert the element on the ordered list;
    //

    return &((PTABLE_ENTRY_HEADER) NodeToReturn)->UserData;
}


BOOLEAN
RtlDeleteElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function DeleteElementGenericTable will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            memory accessed by the key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the key then true, otherwise false.

--*/

{

    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    if ((Lookup == TableEmptyTree) || (Lookup != TableFoundNode)) {

        return FALSE;

    } else {

        //
        // Delete the node from the splay tree.
        //

        Table->TableRoot = RtlDelete(NodeOrParent);

        //
        // Delete the element from the linked list.
        //

        RemoveEntryList(&((PTABLE_ENTRY_HEADER) NodeOrParent)->ListEntry);
        Table->NumberGenericTableElements--;
        Table->WhichOrderedElement = 0;
        Table->OrderedPointer = &Table->InsertOrderList;

        //
        // The node has been deleted from the splay table.
        // Now give the node to the user deletion routine.
        // NOTE: We are giving the deletion routine a pointer
        // to the splay links rather then the user data.  It
        // is assumed that the deallocation is rather bad.
        //

        Table->FreeRoutine(Table,NodeOrParent);
        return TRUE;

    }

}


PVOID
RtlLookupElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function LookupElementGenericTable will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element, otherwise if
    the element is not located the return value is NULL.  The user supplied
    input buffer is only used as a key in locating the element in the table.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{
    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    TABLE_SEARCH_RESULT Lookup;

    return RtlLookupElementGenericTableFull(
                Table,
                Buffer,
                &NodeOrParent,
                &Lookup
                );
}


PVOID
NTAPI
RtlLookupElementGenericTableFull (
    PRTL_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT TABLE_SEARCH_RESULT *SearchResult
    )

/*++

Routine Description:

    The function LookupElementGenericTableFull will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element.  If the element is not
    located then a pointer to the parent for the insert location is returned.  The
    user must look at the SearchResult value to determine which is being returned.
    The user can use the SearchResult and parent for a subsequent FullInsertElement
    call to optimize the insert.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

    NodeOrParent - Address to store the desired Node or parent of the desired node.

    SearchResult - Describes the relationship of the NodeOrParent with the desired Node.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    //  Lookup the element and save the result.
    //

    *SearchResult = FindNodeOrParent(
                        Table,
                        Buffer,
                        (PRTL_SPLAY_LINKS *)NodeOrParent
                        );

    if ((*SearchResult == TableEmptyTree) || (*SearchResult != TableFoundNode)) {

        return NULL;

    } else {

        //
        // Splay the tree with this node.
        //

        Table->TableRoot = RtlSplay(*NodeOrParent);

        //
        // Return a pointer to the user data.
        //

        return &((PTABLE_ENTRY_HEADER)*NodeOrParent)->UserData;
    }
}


PVOID
RtlEnumerateGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    The function EnumerateGenericTable will return to the caller one-by-one
    the elements of of a table.  The return value is a pointer to the user
    defined structure associated with the element.  The input parameter
    Restart indicates if the enumeration should start from the beginning
    or should return the next element.  If the are no more new elements to
    return the return value is NULL.  As an example of its use, to enumerate
    all of the elements in a table the user would write:

        for (ptr = EnumerateGenericTable(Table,TRUE);
             ptr != NULL;
             ptr = EnumerateGenericTable(Table, FALSE)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    Restart - Flag that if true we should start with the least
              element in the tree otherwise, return we return
              a pointer to the user data for the root and make
              the real successor to the root the new root.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    if (RtlIsGenericTableEmpty(Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (Restart) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->TableRoot;
                RtlLeftChild(NodeToReturn);
                NodeToReturn = RtlLeftChild(NodeToReturn)
                ) {
                ;
            }

            Table->TableRoot = RtlSplay(NodeToReturn);

        } else {

            //
            // The assumption here is that the root of the
            // tree is the last node that we returned.  We
            // find the real successor to the root and return
            // it as next element of the enumeration.  The
            // node that is to be returned is splayed (thereby
            // making it the root of the tree).  Note that we
            // need to take care when there are no more elements.
            //

            NodeToReturn = RtlRealSuccessor(Table->TableRoot);

            if (NodeToReturn) {

                Table->TableRoot = RtlSplay(NodeToReturn);

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));

    }

}


BOOLEAN
RtlIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    )

/*++

Routine Description:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{

    //
    // Table is empty if the root pointer is null.
    //

    return ((Table->TableRoot)?(FALSE):(TRUE));

}

PVOID
RtlGetElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN ULONG I
    )

/*++

Routine Description:


    The function GetElementGenericTable will return the i'th element
    inserted in the generic table.  I = 0 implies the first element,
    I = (RtlNumberGenericTableElements(Table)-1) will return the last element
    inserted into the generic table.  The type of I is ULONG.  Values
    of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
    an arbitrary element is deleted from the generic table it will cause
    all elements inserted after the deleted element to "move up".

Arguments:

    Table - Pointer to the generic table from which to get the ith element.

    I - Which element to get.


Return Value:

    PVOID - Pointer to the user data.

--*/

{

    //
    // Current location in the table.
    //
    ULONG CurrentLocation = Table->WhichOrderedElement;

    //
    // Hold the number of elements in the table.
    //
    ULONG NumberInTable = Table->NumberGenericTableElements;

    //
    // Holds the value of I+1.
    //
    // Note that we don't care if this value overflows.
    // If we end up accessing it we know that it didn't.
    //
    ULONG NormalizedI = I + 1;

    //
    // Will hold distances to travel to the desired node;
    //
    ULONG ForwardDistance,BackwardDistance;

    //
    // Will point to the current element in the linked list.
    //
    PLIST_ENTRY CurrentNode = Table->OrderedPointer;


    //
    // If it's out of bounds get out quick.
    //

    if ((I == MAXULONG) || (NormalizedI > NumberInTable)) return NULL;

    //
    // If we're already at the node then return it.
    //

    if (NormalizedI == CurrentLocation) {

        return &((PTABLE_ENTRY_HEADER) CONTAINING_RECORD(CurrentNode, TABLE_ENTRY_HEADER, ListEntry))->UserData;
    }

    //
    // Calculate the forward and backward distance to the node.
    //

    if (CurrentLocation > NormalizedI) {

        //
        // When CurrentLocation is greater than where we want to go,
        // if moving forward gets us there quicker than moving backward
        // then it follows that moving forward from the listhead is
        // going to take fewer steps. (This is because, moving forward
        // in this case must move *through* the listhead.)
        //
        // The work here is to figure out if moving backward would be quicker.
        //
        // Moving backward would be quicker only if the location we wish  to
        // go to is more than half way between the listhead and where we
        // currently are.
        //

        if (NormalizedI > (CurrentLocation/2)) {

            //
            // Where we want to go is more than half way from the listhead
            // We can traval backwards from our current location.
            //

            for (
                BackwardDistance = CurrentLocation - NormalizedI;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = CurrentNode->Blink;

            }
        } else {

            //
            // Where we want to go is less than halfway between the start
            // and where we currently are.  Start from the listhead.
            //

            for (
                CurrentNode = &Table->InsertOrderList;
                NormalizedI;
                NormalizedI--
                ) {

                CurrentNode = CurrentNode->Flink;

            }

        }

    } else {


        //
        // When CurrentLocation is less than where we want to go,
        // if moving backwards gets us there quicker than moving forwards
        // then it follows that moving backwards from the listhead is
        // going to take fewer steps. (This is because, moving backwards
        // in this case must move *through* the listhead.)
        //

        ForwardDistance = NormalizedI - CurrentLocation;

        //
        // Do the backwards calculation as if we are starting from the
        // listhead.
        //

        BackwardDistance = (NumberInTable - NormalizedI) + 1;

        if (ForwardDistance <= BackwardDistance) {

            for (
                ;
                ForwardDistance;
                ForwardDistance--
                ) {

                CurrentNode = CurrentNode->Flink;

            }


        } else {

            for (
                CurrentNode = &Table->InsertOrderList;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = CurrentNode->Blink;

            }

        }

    }

    //
    // We're where we want to be.  Save our current location and return
    // a pointer to the data to the user.
    //

    Table->OrderedPointer = CurrentNode;
    Table->WhichOrderedElement = I+1;

    return &((PTABLE_ENTRY_HEADER) CONTAINING_RECORD(CurrentNode, TABLE_ENTRY_HEADER, ListEntry))->UserData;

}


ULONG
RtlNumberGenericTableElements(
    IN PRTL_GENERIC_TABLE Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements returns a ULONG value
    which is the number of generic table elements currently inserted
    in the generic table.

Arguments:

    Table - Pointer to the generic table from which to find out the number
    of elements.


Return Value:

    ULONG - The number of elements in the generic table.

--*/
{

    return Table->NumberGenericTableElements;

}


PVOID
RtlEnumerateGenericTableWithoutSplaying (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        PVOID RestartKey = NULL;

        for (ptr = RtlEnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = RtlEnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    if (RtlIsGenericTableEmpty(Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == NULL) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->TableRoot;
                RtlLeftChild(NodeToReturn);
                NodeToReturn = RtlLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // RtlRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = RtlRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heapdll.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapdll.c

Abstract:

    This module implements the user mode only portions of the heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1994

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"
#include "NtdllTrc.h"
#include "wmiumkm.h"

#ifdef NTHEAP_ENABLED
#include "heapp.h"
#endif // NTHEAP_ENABLED


//
//  This structure is used by RtlUsageHeap to keep track of heap usage
//  between calls.  This package typecasts an extra reserved buffer passed
//  in by the user to hold this information
//

typedef struct _RTL_HEAP_USAGE_INTERNAL {
    PVOID Base;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    PRTL_HEAP_USAGE_ENTRY FreeList;
    PRTL_HEAP_USAGE_ENTRY LargeEntriesSentinal;
    ULONG Reserved;
} RTL_HEAP_USAGE_INTERNAL, *PRTL_HEAP_USAGE_INTERNAL;


//
//  Note that the following variables are specific to each process
//
//
//  This is a lock used to protect access the this processes heap list
//

HEAP_LOCK RtlpProcessHeapsListLock;

//
//  This is a specific list of heaps initialized and used by the process
//

#define RTLP_STATIC_HEAP_LIST_SIZE 16

PHEAP RtlpProcessHeapsListBuffer[ RTLP_STATIC_HEAP_LIST_SIZE ];

//
//  This variable stores a pointer to the heap used to storage global heap
//  tags
//

PHEAP RtlpGlobalTagHeap = NULL;

//
//  This varible is used by the process as work space to build up names for
//  pseudo tags
//

static WCHAR RtlpPseudoTagNameBuffer[ 24 ];

ULONG RtlpLFHInitialized = 0;


BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    );

PVOID
RtlDebugReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    );

BOOLEAN
RtlDebugGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    );

BOOLEAN
RtlDebugSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    );

BOOLEAN
RtlDebugSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlDebugCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    );

PWSTR
RtlDebugQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    );

NTSTATUS
RtlDebugUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

PHEAP_TAG_ENTRY
RtlpAllocateTags (
    PHEAP Heap,
    ULONG NumberOfTags
    );

PRTL_HEAP_USAGE_ENTRY
RtlpFreeHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY p
    );

NTSTATUS
RtlpAllocateHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY *pp
    );

//
//  Declared in ntrtl.h
//

NTSTATUS
RtlInitializeHeapManager(
    VOID
    )

/*++

Routine Description:

    This routine is used to initialize the heap manager for the current process

Arguments:

    None.

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();

#if DBG

    //
    //  Sanity check the sizes of the header entry structures
    //

    if (sizeof( HEAP_ENTRY ) != sizeof( HEAP_ENTRY_EXTRA )) {

        HeapDebugPrint(( "Heap header and extra header sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

    if (sizeof( HEAP_ENTRY ) != CHECK_HEAP_TAIL_SIZE) {

        HeapDebugPrint(( "Heap header and tail fill sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

    if (sizeof( HEAP_FREE_ENTRY ) != (2 * sizeof( HEAP_ENTRY ))) {

        HeapDebugPrint(( "Heap header and free header sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

#endif // DBG

    //
    //  Initialize the heap specific structures in the current peb
    //

    Peb->NumberOfHeaps = 0;
    Peb->MaximumNumberOfHeaps = RTLP_STATIC_HEAP_LIST_SIZE;
    Peb->ProcessHeaps = RtlpProcessHeapsListBuffer;

#ifdef NTHEAP_ENABLED
    {
        (VOID) RtlInitializeNtHeapManager();
    }
#endif // NTHEAP_ENABLED

    //
    //  Initialize the lock and return to our caller
    //
    
    return RtlInitializeLockRoutine( &RtlpProcessHeapsListLock.Lock );
}


//
//  Declared in ntrtl.h
//

VOID
RtlProtectHeap (
    IN PVOID HeapHandle,
    IN BOOLEAN MakeReadOnly
    )

/*++

Routine Description:

    This routine will change the protection on all the pages in a heap
    to be either readonly or readwrite

Arguments:

    HeapHandle - Supplies a pointer to the heap being altered

    MakeReadOnly - Specifies if the heap is to be made readonly or
        readwrite

Return Value:

    None.

--*/

{
    PHEAP Heap;
    UCHAR SegmentIndex;
    PHEAP_SEGMENT Segment;
    MEMORY_BASIC_INFORMATION VaInfo;
    NTSTATUS Status;
    PVOID Address;
    PVOID ProtectAddress;
    SIZE_T Size;
    ULONG OldProtect;
    ULONG NewProtect;

    Heap = (PHEAP)HeapHandle;

    //
    //  For every valid segment in the heap we will zoom through all its
    //  regions and for those that are committed we'll change it protection
    //

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if ( Segment ) {

            //
            //  Starting from the first address for the segment and going to
            //  the last address in the segment we'll step through by regions
            //

            Address = Segment->BaseAddress;

            while ((ULONG_PTR)Address < (ULONG_PTR)(Segment->LastValidEntry)) {

                //
                //  Query the current region to get its state and size
                //

                Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                               Address,
                                               MemoryBasicInformation,
                                               &VaInfo,
                                               sizeof(VaInfo),
                                               NULL );

                if (!NT_SUCCESS( Status )) {

                    HeapDebugPrint(( "VirtualQuery Failed 0x%08x %x\n", Address, Status ));

                    return;
                }

                //
                //  If we found a commited block then set its protection
                //

                if (VaInfo.State == MEM_COMMIT) {

                    Size = VaInfo.RegionSize;

                    ProtectAddress = Address;

                    if (MakeReadOnly) {

                        NewProtect = PAGE_READONLY;

                    } else {

                        NewProtect = PAGE_READWRITE;
                    }

                    Status = ZwProtectVirtualMemory( NtCurrentProcess(),
                                                     &ProtectAddress,
                                                     &Size,
                                                     NewProtect,
                                                     &OldProtect );

                    if (!NT_SUCCESS( Status )) {

                        HeapDebugPrint(( "VirtualProtect Failed 0x%08x %x\n", Address, Status ));

                        return;
                    }
                }

                //
                //  Now calculate the address of the next region in the segment
                //

                Address = (PVOID)((PCHAR)Address + VaInfo.RegionSize);
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlLockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used by lock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heap being locked

Return Value:

    BOOLEAN - TRUE if the heap is now locked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is returned even if the heap is
        not lockable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapLock( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlLockHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.  And disable the lookaside list by incrementing
    //  its lock count.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        RtlAcquireLockRoutine( Heap->LockVariable );

        RtlpLockFrontHeap(Heap);
    }

    
    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(NTDLL_EVENT_COMMON) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PNTDLL_EVENT_COMMON pHeapEvent = (PNTDLL_EVENT_COMMON)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_LOCK;

            pHeapEvent->Handle	            = (PVOID)HeapHandle;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 

    #endif // NTOS_KERNEL_RUNTIME

    return TRUE;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlUnlockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to unlock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heep being unlocked

Return Value:

    BOOLEAN - TRUE if the heap is now unlocked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is also returned if the heap was
        never locked to begin with because it is not seralizable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUnlock( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlUnlockHeap" )) {

        return FALSE;
    }

    //
    //  Unlock the heap.  And enable the lookaside logic by decrementing
    //  its lock count
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        RtlpUnlockFrontHeap(Heap);

        RtlReleaseLockRoutine( Heap->LockVariable );
    }

    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(NTDLL_EVENT_COMMON) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PNTDLL_EVENT_COMMON pHeapEvent = (PNTDLL_EVENT_COMMON)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_UNLOCK;

            pHeapEvent->Handle	            = (PVOID)HeapHandle;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 


    #endif // NTOS_KERNEL_RUNTIME


    return TRUE;
}


//
//  Declared in nturtl.h
//

PVOID
RtlReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine will resize a user specified heap block.  The new size
    can either be smaller or larger than the current block size.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of heap flags to augment those already
        enforced by the heap

    BaseAddress - Supplies the current address of a block allocated
        from heap.  We will try and resize this block at its current
        address, but it could possibly move if this heap structure
        allows for relocation

    Size - Supplies the size, in bytes, for the newly resized heap
        block

Return Value:

    PVOID - A pointer to the resized block.  If the block had to move
        then this address will not be equal to the input base address

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock, NewBusyBlock;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    PVOID NewBaseAddress;
    PHEAP_FREE_ENTRY SplitBlock, SplitBlock2;
    SIZE_T OldSize;
    SIZE_T AllocationIndex;
    SIZE_T OldAllocationIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    PVOID DeCommitAddress;
    SIZE_T DeCommitSize;
    EXCEPTION_RECORD ExceptionRecord;
    PVOID TraceBaseAddress = NULL;

    //
    //  If there isn't an address to relocate the heap at then our work is done
    //

    if (BaseAddress == NULL) {

        SET_LAST_STATUS( STATUS_SUCCESS );

        return NULL;
    }

#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlReAllocateNtHeap( HeapHandle, Flags, BaseAddress, Size );
        }
    }
#endif // NTHEAP_ENABLED
    
    if (RtlpGetLowFragHeap(Heap)) {

        BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

        if (BusyBlock->SegmentIndex == HEAP_LFH_INDEX) {

            //
            //  Refuse realloc in place only for LFH blocks
            //

            if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {

                return NULL;
            }

            OldSize = RtlSizeHeap(Heap, 0, BaseAddress);

            Flags &= ~HEAP_TAG_MASK;

            NewBaseAddress = RtlAllocateHeap(Heap, Flags, (Size ? Size : 1));

            if (NewBaseAddress) {
                
                //
                //  Copy over the user's data area to the new block
                //

                RtlMoveMemory( NewBaseAddress, BaseAddress, Size < OldSize ? Size : OldSize );
                
                //
                //  Check if we grew the block and we should zero
                //  the remaining part.
                //

                if (Size > OldSize && (Flags & HEAP_ZERO_MEMORY)) {

                    RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
                                   Size - OldSize );
                }

                RtlFreeHeap(Heap, Flags, BaseAddress);
            }

            #ifndef NTOS_KERNEL_RUNTIME
            if( IsHeapLogging( HeapHandle ) && NewBaseAddress != NULL ) {

                PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                USHORT ReqSize = sizeof(PHEAP_EVENT_REALLOC) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                if(pEventHeader && pThreadLocalData) {

                    PHEAP_EVENT_REALLOC pHeapEvent = (PHEAP_EVENT_REALLOC)((SIZE_T)pEventHeader
                                                 +(SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                    pEventHeader->Packet.Size = (USHORT) ReqSize;
                    pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_REALLOC;

                    pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                    pHeapEvent->NewAddress	= (PVOID)NewBaseAddress;
                    pHeapEvent->OldAddress	= (PVOID)BaseAddress;
                    pHeapEvent->OldSize		= OldSize;
                    pHeapEvent->NewSize		= Size;
                    pHeapEvent->Source		= MEMORY_FROM_LOWFRAG;

                    ReleaseBufferLocation(pThreadLocalData);
                }
            }
            #endif //NTOS_KERNEL_RUNTIME							

            return NewBaseAddress;
        }
    } 


    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should simply call the debug version of heap to do the work
    //

    if (DEBUG_HEAP( Flags)) {

        return RtlDebugReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );
    }

    //
    //  Make sure we didn't get a negative heap size
    //

    if (Size > MAXINT_PTR) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra byte to protect ourselves from errors.
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) ||
        (Heap->PseudoTagEntries != NULL) ||
        ((((PHEAP_ENTRY)BaseAddress)-1)->Flags & HEAP_ENTRY_EXTRA_PRESENT)) {

        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }
    
    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;

            //
            //  Because it is now zero the following statement will set the no
            //  serialize bit
            //

            Flags ^= HEAP_NO_SERIALIZE;
        }

        try {

            //
            //  Compute the heap block address for user specified block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Check if the block is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

                //
                //  Bail if not a busy block.
                //

                leave;

            //
            //  We need the current (i.e., old) size and allocation of the
            //  block.  Check if the block is a big allocation.  The size
            //  field of a big block is really the unused by count
            //

            } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                OldSize = RtlpGetSizeOfBigBlock( BusyBlock );

                OldAllocationIndex = (OldSize + BusyBlock->Size) >> HEAP_GRANULARITY_SHIFT;

                //
                //  We'll need to adjust the new allocation size to account
                //  for the big block header and then round it up to a page
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );
                AllocationSize = ROUND_UP_TO_POWER2( AllocationSize, PAGE_SIZE );

            //
            //  Otherwise the block is in use and is a small allocation
            //

            } else {

                OldAllocationIndex = BusyBlock->Size;

                OldSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                          RtlpGetUnusedBytes(Heap, BusyBlock);
            }

            //
            //  Compute the new allocation index
            //

            AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

            //
            //  At this point we have the old size and index, and the new size
            //  and index
            //
            //  See if new size less than or equal to the current size.
            //

            if (AllocationIndex <= OldAllocationIndex) {

                //
                //  If the new allocation index is only one less then the current
                //  index then make the sizes equal
                //

                if (AllocationIndex + 1 == OldAllocationIndex) {

                    AllocationIndex += 1;
                    AllocationSize += sizeof( HEAP_ENTRY );
                }

                //
                //  Calculate new residual (unused) amount
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    //
                    //  In a big block the size is really the unused byte count
                    //

                    BusyBlock->Size = (USHORT)(AllocationSize - Size);

                } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  The extra stuff struct goes after the data.  So compute
                    //  the old and new extra stuff location and copy the data
                    //

                    OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                    NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

                    *NewExtraStuff = *OldExtraStuff;

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        NewExtraStuff->TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                NewExtraStuff->TagIndex,
                                                OldAllocationIndex,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

                    RtlpSetUnusedBytes(Heap, BusyBlock, (AllocationSize - Size));

                } else {

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        BusyBlock->SmallTagIndex = (UCHAR)
                            RtlpUpdateTagEntry( Heap,
                                                BusyBlock->SmallTagIndex,
                                                BusyBlock->Size,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

                    RtlpSetUnusedBytes(Heap, BusyBlock, (AllocationSize - Size));
                }

                //
                //  Check if the block is getting bigger, then fill in the extra
                //  space.
                //
                //  This happens even if the allocation index is less than or
                //  equal to the old allocation index, because the old allocation 
                //  index contains unused bytes as well. 
                //

                if (Size > OldSize) {

                    //
                    //  See if we should zero the extra space
                    //

                    if (Flags & HEAP_ZERO_MEMORY) {

                        RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
                                       Size - OldSize );

                    //
                    //  Otherwise see if we should fill the extra space
                    //

                    } else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                        SIZE_T PartialBytes, ExtraSize;

                        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

                        if (PartialBytes) {

                            PartialBytes = 4 - PartialBytes;
                        }

                        if (Size > (OldSize + PartialBytes)) {

                            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

                            if (ExtraSize != 0) {

                                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                                    ExtraSize,
                                                    ALLOC_HEAP_FILL );
                            }
                        }
                    }
                }

                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );
                }

                //
                //  If amount of change is greater than the size of a free block,
                //  then need to free the extra space.  Otherwise, nothing else to
                //  do.
                //

                if (AllocationIndex != OldAllocationIndex) {

                    FreeFlags = BusyBlock->Flags & ~HEAP_ENTRY_BUSY;

                    if (FreeFlags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                        if (IS_HEAP_TAGGING_ENABLED()) {

                            VirtualAllocBlock->ExtraStuff.TagIndex =
                                RtlpUpdateTagEntry( Heap,
                                                    VirtualAllocBlock->ExtraStuff.TagIndex,
                                                    OldAllocationIndex,
                                                    AllocationIndex,
                                                    VirtualReAllocationAction );
                        }

                        DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;

                        DeCommitSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                                       AllocationSize;

                        Status = RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                                            (PVOID *)&DeCommitAddress,
                                                            &DeCommitSize,
                                                            MEM_DECOMMIT );

                        if (!NT_SUCCESS( Status )) {

                            HeapDebugPrint(( "Unable to release memory at %p for %p bytes - Status == %x\n",
                                             DeCommitAddress, DeCommitSize, Status ));

                            HeapDebugBreak( NULL );

                        } else {

                            VirtualAllocBlock->CommitSize -= DeCommitSize;
                        }

                    } else {

                        //
                        //  Otherwise, shrink size of this block to new size, and make extra
                        //  space at end free.
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        SplitBlock->Flags = FreeFlags;

                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

                        FreeSize = BusyBlock->Size - AllocationIndex;

                        BusyBlock->Size = (USHORT)AllocationIndex;

                        BusyBlock->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

                        //
                        //  If the following block is uncommitted then we only need to
                        //  add this new entry to its free list
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

                            SplitBlock->Size = (USHORT)FreeSize;

                            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise get the next block and check if it is busy.  If it
                            //  is in use then add this new entry to its free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock->Size = (USHORT)FreeSize;

                                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise the next block is not in use so we
                                //  should be able to merge with it.  Remove the
                                //  second free block and if the combined size is
                                //  still okay then merge the two blocks and add
                                //  the single block back in.  Otherwise call a
                                //  routine that will actually break it apart
                                //  before insertion.
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                Heap->TotalFreeSize -= SplitBlock2->Size;

                                FreeSize += SplitBlock2->Size;

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                    } else {

                                        PHEAP_SEGMENT Segment;

                                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                                    }

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }
                    }
                }

            } else {

                //
                //  At this point the new size is greater than the current size
                //
                //  If the block is a big allocation or we're not able to grow
                //  the block in place then we have a lot of work to do
                //

                if ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) ||
                    !RtlpGrowBlockInPlace( Heap, Flags, BusyBlock, Size, AllocationIndex )) {

                    //
                    //  We're growing the block.  Allocate a new block with the bigger
                    //  size, copy the contents of the old block to the new block and then
                    //  free the old block.  Return the address of the new block.
                    //

                    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {

#if DBG
                        // HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));
#endif

                        BaseAddress = NULL;

                    } else {

                        //
                        //  Clear the tag bits from the flags
                        //

                        Flags &= ~HEAP_TAG_MASK;

                        //
                        //  If there is an extra struct present then get the tag
                        //  index from the extra stuff and augment the flags with
                        //  the tag index.
                        //

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            Flags &= ~HEAP_SETTABLE_USER_FLAGS;

                            Flags |= HEAP_SETTABLE_USER_VALUE |
                                     ((BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4);

                            OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                            try {

                                if ((OldExtraStuff->TagIndex != 0) &&
                                    !(OldExtraStuff->TagIndex & HEAP_PSEUDO_TAG_FLAG)) {

                                    Flags |= OldExtraStuff->TagIndex << HEAP_TAG_SHIFT;
                                }

                            } except (EXCEPTION_EXECUTE_HANDLER) {

                                BusyBlock->Flags &= ~HEAP_ENTRY_EXTRA_PRESENT;
                            }

                        } else if (BusyBlock->SmallTagIndex != 0) {

                            //
                            //  There is not an extra stuff struct, but block
                            //  does have a small tag index so now add this small
                            //  tag to the flags
                            //

                            Flags |= BusyBlock->SmallTagIndex << HEAP_TAG_SHIFT;
                        }

                        //
                        //  Allocate from the heap space for the reallocation
                        //

                        NewBaseAddress = RtlAllocateHeap( HeapHandle,
                                                          Flags & ~HEAP_ZERO_MEMORY,
                                                          Size );

                        if (NewBaseAddress != NULL) {

                            //
                            //  We were able to get the allocation so now back up
                            //  to the heap block and if the block has an extra
                            //  stuff struct then copy over the extra stuff
                            //

                            NewBusyBlock = (PHEAP_ENTRY)NewBaseAddress - 1;

                            if (NewBusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                NewExtraStuff = RtlpGetExtraStuffPointer( NewBusyBlock );

                                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                                    NewExtraStuff->Settable = OldExtraStuff->Settable;

                                } else {

                                    RtlZeroMemory( NewExtraStuff, sizeof( *NewExtraStuff ));
                                }
                            }

                            //
                            //  Copy over the user's data area to the new block
                            //

                            RtlCopyMemory( NewBaseAddress, BaseAddress, Size < OldSize ? Size : OldSize );

                            //
                            //  Check if we grew the block and we should zero
                            //  the remaining part.
                            //

                            if (Size > OldSize && (Flags & HEAP_ZERO_MEMORY)) {

                                RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
                                               Size - OldSize );
                            }

                            //
                            //  Release the old block
                            //

                            RtlFreeHeap( HeapHandle,
                                         Flags,
                                         BaseAddress );
                        }

                        TraceBaseAddress = BaseAddress;
                        BaseAddress = NewBaseAddress;
                    }
                }
            }

            if ((BaseAddress == NULL) && (Flags & HEAP_GENERATE_EXCEPTIONS)) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
            BaseAddress = NULL;

        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) && BaseAddress ) {

        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        USHORT ReqSize = sizeof(HEAP_EVENT_REALLOC) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PHEAP_EVENT_REALLOC pHeapEvent=(PHEAP_EVENT_REALLOC)( (SIZE_T)pEventHeader
                        + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_REALLOC;

            pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
            pHeapEvent->NewAddress	= (PVOID)BaseAddress;

            if(TraceBaseAddress){
                pHeapEvent->OldAddress	= (PVOID)TraceBaseAddress;
            } else {
                pHeapEvent->OldAddress	= (PVOID)BaseAddress;
            }

            pHeapEvent->OldSize		= OldSize;
            pHeapEvent->NewSize		= Size;
            pHeapEvent->Source		= MEMORY_FROM_MAINPATH;

            ReleaseBufferLocation(pThreadLocalData);
        }
    }
    #endif //NTOS_KERNEL_RUNTIME

    //
    //  And return to our caller
    //

    return BaseAddress;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine returns to the user the set of user flags
    and user values for the specified heap entry.  The user value
    is set via a set call and the user flags is part of the
    user settable flags used when communicating with the heap package
    and can also be set via a set call

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags to agument those already in the heap

    BaseAddress - Supplies a pointer to the users heap entry being
        queried

    UserValue - Optionally supplies a pointer to recieve the heap entry
        value

    UserFlasg - Optionally supplies a pointer to recieve the heap flags

Return Value:

    BOOLEAN - TRUE if the query is successful and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    //
    //  Build up a set of real flags to use in this operation
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugGetUserInfoHeap( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
    }

    Result = FALSE;

    try {

        try {

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }

            //
            //  Backup the pointer to the heap entry
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  If the entry is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            } else {

                //
                //  The heap entry is in use so now check if there is
                //  any extra information present
                //

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  Get a pointer to the extra information and if the
                    //  user asked for user values then that field from the
                    //  extra stuff
                    //

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    if (ARGUMENT_PRESENT( UserValue )) {

                        *UserValue = (PVOID)ExtraStuff->Settable;
                    }
                }

                //
                //  If the user asked for user flags then return the flags
                //  from the heap entry that are user setable
                //

                if (ARGUMENT_PRESENT( UserFlags )) {

                    *UserFlags = (BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4;
                }

                //
                //  Now that the assignments are done we can say that
                //  we were successful
                //

                Result = TRUE;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    )

/*++

Routine Description:

    This routine is used to set the user settable value for a heap entry

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags needed to augment those already enforced
        by the heap

    BaseAddress - Supplies a pointer to the heap entry allocation being
        modified

    UserValue - Supplies the value to store in the extra stuff space of
        the heap entry

Return Value:

    BOOLEAN - TRUE if the setting worked, and FALSE otherwise.  It could be
        FALSE if the base address is invalid, or if there is not room for
        the extra stuff

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    //
    //  Augment the set of flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check to see if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSetUserValueHeap( HeapHandle, Flags, BaseAddress, UserValue );
    }

    Result = FALSE;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Get a pointer to the owning heap entry
        //

        BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

        //
        //  If the entry is not in use then its is an error
        //

        if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

            SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

        //
        //  Otherwise we only can set the value if the entry has space
        //  for the extra stuff
        //

        } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

            ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

            ExtraStuff->Settable = (ULONG_PTR)UserValue;

            Result = TRUE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )

/*++

Routine Description:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags needed to augment those already enforced
        by the heap

    BaseAddress - Supplies a pointer to the heap entry allocation being
        modified

    UserFlagsReset - Supplies a mask of flags that the user wants cleared

    UserFlagsSet- Supplies a mask of flags that the user wants set

Return Value:

    BOOLEAN - TRUE if the operation is a success and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result = FALSE;

    //
    //  Augment the set of flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check to see if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSetUserFlagsHeap( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Get a pointer to the owning heap entry
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  If the entry is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            } else {

                //
                //  Otherwise modify the flags in the block
                //
                //  This is terrible error prone if the user passes in
                //  flags that aren't 0x20 0x40 or 0x80 only.
                //

                BusyBlock->Flags &= ~(UserFlagsReset >> 4);
                BusyBlock->Flags |= (UserFlagsSet >> 4);

                Result = TRUE;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


//
//  Declared in nturtl.h
//

ULONG
RtlCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    )

/*++

Routine Description:

    This routine create a tag heap for either the specified heap or
    for the global tag heap.

Arguments:

    HeapHandle - Optionally supplies a pointer to the heap that we
        want modified.  If null then the global tag heap is used

    Flags - Supplies a list of flags to augment the flags already
        enforced by the heap

    TagPrefix - Optionally supplies a null terminated wchar string
        of a prefix to add to each tag

    TagNames - Supplies a list of tag names separated by null and terminated
        by a double null.  If the first name in the list start with
        a "!" then it is interpreted as the heap name.  The syntax
        for the tag name is

            [!<heapname> nul ] {<tagname> nul}* nul

Return Value:

    ULONG - returns the index of the last tag create shifted to the high
        order word.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    ULONG TagIndex;
    ULONG NumberOfTags, MaxTagNameLength, TagPrefixLength;
    PWSTR s, s1, HeapName;
    PHEAP_TAG_ENTRY TagEntry;
    ULONG Result;

    //
    //  Check if tagging is disable and so this call is a noop
    //

    if (!IS_HEAP_TAGGING_ENABLED()) {

        return 0;
    }

    //
    //  If the processes global tag heap has not been created yet then
    //  allocate a global tag heap
    //

    if (RtlpGlobalTagHeap == NULL) {

        RtlpGlobalTagHeap = RtlAllocateHeap( RtlProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( HEAP ));

        if (RtlpGlobalTagHeap == NULL) {

            return 0;
        }
    }

    try {

        //
        //  If the user passed in a heap then we'll use the lock from that
        //  heap to synchronize our work.  Otherwise we're unsynchronized
        //

        if (Heap != NULL) {

            //
            //  Tagging is not part of the guard page heap package
            //

            IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle, 0 );

            //
            //  Check if we should be calling the debug version of the heap package
            //

            if (DEBUG_HEAP( Flags )) {

                Result = RtlDebugCreateTagHeap( HeapHandle, Flags, TagPrefix, TagNames );
                leave;
            }

            //
            //  Augment the flags and lock the specified heap
            //

            Flags |= Heap->ForceFlags;

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }
        }

        //
        //  We start off with zero tags
        //

        TagIndex = 0;
        NumberOfTags = 0;

        //
        //  With tag names that start with "!" we assume what follows
        //  is a heap name.
        //

        if (*TagNames == L'!') {

            HeapName = TagNames + 1;

            //
            //  Move up to the following tag name after the heap name
            //  separated by a null
            //

            while (*TagNames++) { NOTHING; }

        } else {

            HeapName = NULL;
        }

        //
        //  Gobble up each tag name keeping count of how many we find
        //

        s = TagNames;

        while (*s) {

            while (*s++) { NOTHING; }

            NumberOfTags += 1;
        }

        //
        //  Now we will only continue on if we were supplied tag names
        //

        if (NumberOfTags > 0) {

            //
            //  Allocate heap entries for the number of tags we need and
            //  only proceed if this allocation succeeded.   The following
            //  call also makes room for the heap name as tag index 0.  Note
            //  that is heap is null then we assume we're using the global
            //  tag heap
            //

            TagEntry = RtlpAllocateTags( Heap, NumberOfTags );

            if (TagEntry != NULL) {

                MaxTagNameLength = (sizeof( TagEntry->TagName ) / sizeof( WCHAR )) - 1;

                TagIndex = TagEntry->TagIndex;

                //
                //  If the first tag index is zero then we'll make this tag entry
                //  the heap name.
                //

                if (TagIndex == 0) {

                    if (HeapName != NULL ) {

                        //
                        //  Copy over the heap name and pad it out with nulls up
                        //  to the end of the name buffer
                        //

                        wcsncpy( TagEntry->TagName, HeapName, MaxTagNameLength );
                    }

                    //
                    //  Whether we add a heap name or not we'll move on to the
                    //  next tag entry and index
                    //

                    TagEntry += 1;

                    TagIndex = TagEntry->TagIndex;

                //
                //  This isn't the first index for a specified heap, but see if
                //  it is the first index for the global heap.  If so then put
                //  name of the global tags into the 0 index
                //

                } else if (TagIndex == HEAP_GLOBAL_TAG) {

                    wcsncpy( TagEntry->TagName, L"GlobalTags", MaxTagNameLength );

                    TagEntry += 1;

                    TagIndex = TagEntry->TagIndex;
                }

                //
                //  Now we've taken case of the 0 index we'll go on to the rest of
                //  the tags.  If there is tag prefix and it is not zero length
                //  then we'll use this tag prefix provided that is leaves us at
                //  least 4 characters for the tag name itself.  Otherwise we'll
                //  ignore the tag prefix (by setting the variable to null).
                //

                if ((ARGUMENT_PRESENT( TagPrefix )) &&
                    (TagPrefixLength = wcslen( TagPrefix ))) {

                    if (TagPrefixLength >= MaxTagNameLength-4) {

                        TagPrefix = NULL;

                    } else {

                        MaxTagNameLength -= TagPrefixLength;
                    }

                } else {

                    TagPrefix = NULL;
                }

                //
                //  For every tag name (note that this varable has already been
                //  advanced beyond the heap name) we'll put it in a tag entry
                //  by copying in the prefix and then appending on the tag itself
                //
                //   s points to the current users supplied tag name
                //  s1 points to the tag name buffer in the current tag entry
                //

                s = TagNames;

                while (*s) {

                    s1 = TagEntry->TagName;

                    //
                    //  Copy in the optional tag prefix and update s1
                    //

                    if (ARGUMENT_PRESENT( TagPrefix )) {

                        wcscpy( s1, TagPrefix );

                        s1 += TagPrefixLength;
                    }

                    //
                    //  Copy over the remaining tag name padding it with nulls
                    //  up to the end of the name buffer
                    //

                    wcsncpy( s1, s, MaxTagNameLength );

                    //
                    //  Skip to the next tag name
                    //

                    while (*s++) { NOTHING; }

                    //
                    //  Skip to the next tag entry
                    //

                    TagEntry += 1;
                }
            }
        }

        Result = TagIndex << HEAP_TAG_SHIFT;

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller.  The answer we return is the last tag index
    //  stored in the high word of a ulong result
    //

    return Result;
}


//
//  Declared in nturtl.h
//

PWSTR
RtlQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    )

/*++

Routine Description:

    This routine returns the name and optional statistics for a given
    tag index.

Arguments:

        Note that some of the code looks like it can handle the
        global tag heap but other places look rather wrong

    HeapHandle - Specifies the heap being queried.  If null then the
        global tag heap is used.

    Flags - Supplies a set flags to augment those enforced by the
        heap

    TagIndex - Specifies the tag index that we want to query

    ResetCounter - Specifies if this routine should reset the counter
        for the tag after the query

    TagInfo - Optionally supplies storage where the output tag information
        should be stored

Return Value:

    PWSTR - Returns a pointer to the tag name or NULL if the index
        doesn't exist

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PHEAP_TAG_ENTRY TagEntry;
    PWSTR Result;

    //
    //  Tagging is not part of the guard page heap package
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle, NULL );

    //
    //  Check if tagging is disabled
    //

    if (!IS_HEAP_TAGGING_ENABLED()) {

        return NULL;
    }

    try {

        //
        //  Check if the caller has given us a heap to query
        //

        Result = NULL;

        if (Heap == NULL) {

            leave;
        }

        //
        //  Check if we should be using the debug version of the
        //  heap package
        //

        if (DEBUG_HEAP( Flags )) {

            Result = RtlDebugQueryTagHeap( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
            leave;
        }

        //
        //  Lock the heap
        //

        Flags |= Heap->ForceFlags;

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Check that the specified tag index is valid and that the
        //  this heap does actually have some tag entries
        //

        if ((TagIndex < Heap->NextAvailableTagIndex) &&
            (Heap->TagEntries != NULL)) {

            //
            //  Stride over to the specific tag entry and if the caller gave us
            //  an output buffer then fill in the details
            //

            TagEntry = Heap->TagEntries + TagIndex;

            if (ARGUMENT_PRESENT( TagInfo )) {

                TagInfo->NumberOfAllocations = TagEntry->Allocs;
                TagInfo->NumberOfFrees = TagEntry->Frees;
                TagInfo->BytesAllocated = TagEntry->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Check if we should reset the counters
            //

            if (ResetCounters) {

                TagEntry->Allocs = 0;
                TagEntry->Frees = 0;
                TagEntry->Size = 0;
            }

            //
            //  Point to the tag name
            //

            Result = &TagEntry->TagName[ 0 ];

        //
        //  If the tag index has the psuedo tag bit set then recalulate the
        //  tag index and if this heap has pseudo tags than that is what
        //  we'll return
        //

        } else if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            //
            //  Clear the bit
            //

            TagIndex ^= HEAP_PSEUDO_TAG_FLAG;

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                //
                //  Stride over to the specific pseudo tag entry and if the
                //  caller gave us an output buffer then fill in the details
                //

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                if (ARGUMENT_PRESENT( TagInfo )) {

                    TagInfo->NumberOfAllocations = TagEntry->Allocs;
                    TagInfo->NumberOfFrees = TagEntry->Frees;
                    TagInfo->BytesAllocated = TagEntry->Size << HEAP_GRANULARITY_SHIFT;
                }

                //
                //  Check if we should reset the counters
                //

                if (ResetCounters) {

                    TagEntry->Allocs = 0;
                    TagEntry->Frees = 0;
                    TagEntry->Size = 0;
                }

                //
                //  Pseudo tags do not have names
                //

                Result = L"";
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the tag name to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlExtendHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine grows the specified heap by adding a new segment to its
    storage.  The memory for the segment is supplied by the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    Base - Supplies the starting address for the new segment being added
        to the input heap

    Size - Supplies the size, in bytes, of the new segment. Note that this
        routine will actually use more memory than specified by this
        variable.  It will use whatever is committed and reserved provided
        the amount is greater than or equal to "Size"

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    BOOLEAN LockAcquired = FALSE;
    UCHAR SegmentIndex, EmptySegmentIndex;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    ULONG SegmentFlags;
    PVOID CommittedBase;
    PVOID UnCommittedBase;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    //
    //  Check if the guard page version of heap can do the work
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapExtend( HeapHandle, Flags, Base, Size ));

    //
    //  See what Mm thinks about the base address we were passed in.
    //  The address must not be free.
    //

    Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                   Base,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof( MemoryInformation ),
                                   NULL );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    if (MemoryInformation.State == MEM_FREE) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If what we were passed in as a base address is not on a page boundary then
    //  adjust the information supplied by MM to the page boundary right after
    //  the input base address
    //

    if (MemoryInformation.BaseAddress != Base) {

        MemoryInformation.BaseAddress = (PCHAR)MemoryInformation.BaseAddress + PAGE_SIZE;
        MemoryInformation.RegionSize -= PAGE_SIZE;
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Scan the heap's segment list for a free segment.  And make sure the address
        //  of all the segment does not contain the input base address
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;

        EmptySegmentIndex = HEAP_MAXIMUM_SEGMENTS;

        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment) {

                if (((ULONG_PTR)Base >= (ULONG_PTR)Segment) &&
                    ((ULONG_PTR)Base < (ULONG_PTR)(Segment->LastValidEntry))) {

                    Status = STATUS_INVALID_PARAMETER;

                    break;
                }

            } else if ((Segment == NULL) &&
                       (EmptySegmentIndex == HEAP_MAXIMUM_SEGMENTS)) {

                EmptySegmentIndex = SegmentIndex;

                Status = STATUS_SUCCESS;
            }
        }

        //
        //  At this point if status is success then the empty segment index
        //  is available for us to use and base address doesn't overlap an
        //  existing segment.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Indicate that this segment is user supplied
            //

            SegmentFlags = HEAP_SEGMENT_USER_ALLOCATED;

            CommittedBase = MemoryInformation.BaseAddress;

            //
            //  If the start of the memory supplied by the use is already
            //  committed then check the state of the following
            //  uncommitted piece of memory to see if it is reserved
            //

            if (MemoryInformation.State == MEM_COMMIT) {

                CommitSize = MemoryInformation.RegionSize;

                UnCommittedBase = (PCHAR)CommittedBase + CommitSize;

                Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                               UnCommittedBase,
                                               MemoryBasicInformation,
                                               &MemoryInformation,
                                               sizeof( MemoryInformation ),
                                               NULL );

                ReserveSize = CommitSize;

                if ((NT_SUCCESS( Status )) &&
                    (MemoryInformation.State == MEM_RESERVE)) {

                    ReserveSize += MemoryInformation.RegionSize;
                }

            } else {

                //
                //  Otherwise the user hasn't committed anything in the
                //  the address they gave us and we know it is not free
                //  so it must be reserved.
                //

                UnCommittedBase = CommittedBase;

                ReserveSize = MemoryInformation.RegionSize;
            }

            //
            //  Now if the reserved size is smaller than a page size or
            //  the user specified size is greater than the reserved size
            //  then the buffer we're given is too small to be a segment
            //  of heap
            //

            if ((ReserveSize < PAGE_SIZE) ||
                (Size > ReserveSize)) {

                Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                //
                //  Otherwise the size is okay, now check if we need
                //  to do the commit of the base.  If so we'll commit
                //  one page

                if (UnCommittedBase == CommittedBase) {

                    CommitSize = PAGE_SIZE;

                    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                      (PVOID *)&Segment,
                                                      0,
                                                      &CommitSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE );
                }
            }

            //
            //  At this point the if status is good then memory is all set up
            //  with at least one page of committed memory to start with.  So
            //  initialize the heap segment and we're done.
            //

            if (NT_SUCCESS( Status )) {

                if (RtlpInitializeHeapSegment( Heap,
                                               Segment,
                                               EmptySegmentIndex,
                                               0,
                                               Segment,
                                               (PCHAR)Segment + CommitSize,
                                               (PCHAR)Segment + ReserveSize )) {

                    Status = STATUS_NO_MEMORY;
                }
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

SIZE_T
NTAPI
RtlCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine compacts the specified heap by coalescing all the free block.
    It also determines the size of the largest available free block and
    returns its, in bytes, back to the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

Return Value:

    SIZE_T - Returns the size, in bytes, of the largest free block
        available in the heap

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_FREE_ENTRY FreeBlock;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    SIZE_T LargestFreeSize;
    BOOLEAN LockAcquired = FALSE;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is a debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCompactHeap( HeapHandle, Flags );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        LargestFreeSize = 0;

        try {

            //
            //  Coalesce the heap into its largest free blocks possible
            //  and get the largest free block in the heap
            //

            FreeBlock = RtlpCoalesceHeap( (PHEAP)HeapHandle );

            //
            //  If there is a free block then compute its byte size
            //

            if (FreeBlock != NULL) {

                LargestFreeSize = FreeBlock->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Scan every segment in the heap looking at its largest uncommitted
            //  range.  Remember the largest range if its bigger than anything
            //  we've found so far
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment && Segment->LargestUnCommittedRange > LargestFreeSize) {

                    LargestFreeSize = Segment->LargestUnCommittedRange;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the largest free size to our caller
    //

    return LargestFreeSize;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateHeap (
    PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine verifies the structure of a heap and/or heap block

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    BaseAddress - Optionally supplies a pointer to the heap block
        that should be individually validated

Return Value:

    BOOLEAN - TRUE if the heap/block is okay and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    try {

        try {

            //
            //  Check for the guard page version of heap
            //

            if ( IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle )) {

                Result = RtlpDebugPageHeapValidate( HeapHandle, Flags, BaseAddress );
                 
            } else {

                //
                //  If there is an active lookaside list then drain and remove it.
                //  By setting the lookaside field in the heap to null we guarantee
                //  that the call the free heap will not try and use the lookaside
                //  list logic.
                //
                //  We'll actually capture the lookaside pointer from the heap and
                //  only use the captured pointer.  This will take care of the
                //  condition where another walk or lock heap can cause us to check
                //  for a non null pointer and then have it become null when we read
                //  it again.  If it is non null to start with then even if the
                //  user walks or locks the heap via another thread the pointer to
                //  still valid here so we can still try and do a lookaside list pop.
                //

                PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);

                if (Lookaside != NULL) {

                    ULONG i;
                    PVOID Block;

                    Heap->FrontEndHeap = NULL;
                    Heap->FrontEndHeapType = 0;

                    for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                        while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                            RtlFreeHeap( HeapHandle, 0, Block );
                        }
                    }
                }

                Result = FALSE;

                //
                //  Validate that HeapAddress points to a HEAP structure.
                //

                if (RtlpCheckHeapSignature( Heap, "RtlValidateHeap" )) {

                    Flags |= Heap->ForceFlags;

                    //
                    //  Lock the heap
                    //

                    if (!(Flags & HEAP_NO_SERIALIZE)) {

                        RtlAcquireLockRoutine( Heap->LockVariable );

                        LockAcquired = TRUE;
                    }

                    //
                    //  If the user did not supply a base address then verify
                    //  the complete heap otherwise just do a single heap
                    //  entry
                    //

                    if (BaseAddress == NULL) {

                        Result = RtlpValidateHeap( Heap, TRUE );

                    } else {

                        Result = RtlpValidateHeapEntry( Heap, (PHEAP_ENTRY)BaseAddress - 1, "RtlValidateHeap" );
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(NTDLL_EVENT_COMMON) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PNTDLL_EVENT_COMMON pHeapEvent = (PNTDLL_EVENT_COMMON)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));


            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_VALIDATE;

            pHeapEvent->Handle	            = (PVOID)HeapHandle;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 

    #endif // NTOS_KERNEL_RUNTIME

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateProcessHeaps (
    VOID
    )

/*++

Routine Description:

    This routine cycles through all and validates each heap in the current
    process.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if all the heap verify okay and FALSE for any other
        reason.

--*/

{
    NTSTATUS Status;
    ULONG i, NumberOfHeaps;
    PVOID HeapsArray[ 512 ];
    PVOID *Heaps;
    SIZE_T Size;
    BOOLEAN Result;

    Result = TRUE;

    Heaps = &HeapsArray[ 0 ];

    //
    //  By default we can handle 512 heaps per process any more than
    //  that and we'll need to allocate storage to do the processing
    //
    //  So now determine how many heaps are in the current process
    //

    NumberOfHeaps = RtlGetProcessHeaps( 512, Heaps );

    //
    //  RtlGetProcessHeaps returns the number of heaps from peb.
    //  Can be larger than 512, as we passed for buffer
    //

    if (NumberOfHeaps > 512) {

        //
        //  The number of heaps is greater than 512 so
        //  allocate extra memory to store the array of
        //  heap pointers
        //

        Heaps = NULL;
        Size = NumberOfHeaps * sizeof( PVOID );

        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&Heaps,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }

        //
        //  And retry getting the heaps
        //  Note that the number of heaps returned can be differnt now, 
        //  because other create/destroy heap calls. We'll use the returned value.
        //

        NumberOfHeaps = RtlGetProcessHeaps( NumberOfHeaps, Heaps );
    }

    //
    //  Now for each heap in our heap array we'll validate
    //  that heap
    //

    for (i=0; i<NumberOfHeaps; i++) {

        if (!RtlValidateHeap( Heaps[i], 0, NULL )) {

            Result = FALSE;
        }
    }

    //
    //  Check if we need to return the memory that we use for
    //  an enlarged heap array
    //

    if (Heaps != &HeapsArray[ 0 ]) {

        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                   (PVOID *)&Heaps,
                                   &Size,
                                   MEM_RELEASE );
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

ULONG
RtlGetProcessHeaps (
    ULONG NumberOfHeapsToReturn,
    PVOID *ProcessHeaps
    )

/*++

Routine Description:

    This routine determines how many individual heaps there are in the
    current process and fills an array with pointers to each heap.

Arguments:

    NumberOfHeapsToReturn - Indicates how many heaps the caller
        is willing to accept in the second parameter

    ProcessHeaps - Supplies a pointer to an array of heap pointer
        to be filled in by this routine.  The maximum size of this
        array is specified by the first parameter

Return Value:

    ULONG - Returns the smaller of the actual number of heaps in the
        the process or the size of the output buffer

--*/

{
    PPEB Peb = NtCurrentPeb();
    ULONG NumberOfHeapsToCopy;
    ULONG TotalHeaps;

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  Return no more than the number of heaps currently in use
        //

        TotalHeaps = Peb->NumberOfHeaps;

        if (TotalHeaps > NumberOfHeapsToReturn) {

            NumberOfHeapsToCopy = NumberOfHeapsToReturn;

        } else {

            NumberOfHeapsToCopy = TotalHeaps;

        }

        //
        //  Return the heap pointers to the caller
        //

        RtlCopyMemory( ProcessHeaps,
                       Peb->ProcessHeaps,
                       NumberOfHeapsToCopy * sizeof( *ProcessHeaps ));

        //
        //  Points to the PAGE_HEAP data 
        //

        ProcessHeaps += NumberOfHeapsToCopy;
        NumberOfHeapsToReturn -= NumberOfHeapsToCopy;

    } finally {

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

#ifdef DEBUG_PAGE_HEAP

    //
    //  If we have debugging page heaps, go return what we can from them
    //

    if ( RtlpDebugPageHeap ) {

        TotalHeaps +=
            RtlpDebugPageHeapGetProcessHeaps( NumberOfHeapsToReturn, ProcessHeaps );

    }

#endif

    return TotalHeaps;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlEnumProcessHeaps (
    PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    PVOID Parameter
    )

/*++

Routine Description:

    This routine cycles through all the heaps in a process and
    invokes the specified call back routine for that heap

Arguments:

    EnumRoutine - Supplies the callback to invoke for each heap
        in the process

    Parameter - Provides an additional parameter to pass to the
        callback routine

Return Value:

    NTSTATUS - returns success or the first error status returned
        by the callback routine

--*/

{
    PPEB Peb = NtCurrentPeb();
    NTSTATUS Status;
    ULONG i;

    Status = STATUS_SUCCESS;

    //
    //  Lock the heap
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  For each heap in the process invoke the callback routine
        //  and if the callback returns anything other than success
        //  then break out and return immediately to our caller
        //

        for (i=0; i<Peb->NumberOfHeaps; i++) {

            Status = (*EnumRoutine)( (PHEAP)(Peb->ProcessHeaps[ i ]), Parameter );

            if (!NT_SUCCESS( Status )) {

                break;
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )

/*++

Routine Description:

    This is a rather bizzare routine.  It models heap usage in that it returns
    to the caller the various heap sizes, but it also return three lists.  One
    is a list of entries for each active allocation in the heap.  The next two
    are used for tracking difference between usage calls.  There is a list of
    what was added and a list of what was removed.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags needed to augment those enforced
        by the heap.

        HEAP_USAGE_ALLOCATED_BLOCKS - Denotes that the calls wants the list
            of allocated entries.

        HEAP_USAGE_FREE_BUFFER - Denotes the last call to this procedure and
            that any temporary storage can now be freed

    Usage - Receives the current usage statistics for the heap.  This variable
        is also used to store state information between calls to this routine.

Return Value:

    NTSTATUS - An appropriate status value.  STATUS_SUCCESS if the heap has
        not changed at all between calls and STATUS_MORE_ENTRIES if thep changed
        between two calls.

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PRTL_HEAP_USAGE_INTERNAL Buffer;
    PHEAP_SEGMENT Segment;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PLIST_ENTRY Head, Next;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    SIZE_T BytesFree;
    UCHAR SegmentIndex;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN VirtualAllocBlockSeen;
    PRTL_HEAP_USAGE_ENTRY pOldEntries, pNewEntries, pNewEntry;
    PRTL_HEAP_USAGE_ENTRY *ppEntries, *ppAddedEntries, *ppRemovedEntries, *pp;
    PVOID DataAddress;
    SIZE_T DataSize;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should be using the debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugUsageHeap( HeapHandle, Flags, Usage );
    }

    //
    //  Make sure that the size of the input buffer is correct
    //

    if (Usage->Length != sizeof( RTL_HEAP_USAGE )) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    //  Zero out the output fields
    //

    Usage->BytesAllocated = 0;
    Usage->BytesCommitted = 0;
    Usage->BytesReserved = 0;
    Usage->BytesReservedMaximum = 0;

    //
    //  Use the reserved area of the output buffer as an internal
    //  heap usage storage space between calls
    //

    Buffer = (PRTL_HEAP_USAGE_INTERNAL)&Usage->Reserved[ 0 ];

    //
    //  Check if there is not a base buffer and we should allocate
    //  one then do so now
    //

    if ((Buffer->Base == NULL) &&
        (Flags & HEAP_USAGE_ALLOCATED_BLOCKS)) {

        Buffer->ReservedSize = 4 * 1024 * 1024;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Buffer->Base,
                                          0,
                                          &Buffer->ReservedSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        Buffer->CommittedSize = 0;
        Buffer->FreeList = NULL;
        Buffer->LargeEntriesSentinal = NULL;

    //
    //  Otherwise check if there already is a base buffer
    //  and we should free it now
    //

    } else if ((Buffer->Base != NULL) &&
               (Flags & HEAP_USAGE_FREE_BUFFER)) {

        Buffer->ReservedSize = 0;

        Status = RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                      &Buffer->Base,
                                      &Buffer->ReservedSize,
                                      MEM_RELEASE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        RtlZeroMemory( Buffer, sizeof( *Buffer ) );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Scan through the heap segments and for every in-use segment
        //  we add it to the amount of committed and reserved bytes
        //  If the segment is not in use and the heap is growable then
        //  we just add it to the reserved maximum
        //

        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment) {

                Usage->BytesCommitted += (Segment->NumberOfPages -
                                          Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

                Usage->BytesReserved += Segment->NumberOfPages * PAGE_SIZE;

            } else if (Heap->Flags & HEAP_GROWABLE) {

                Usage->BytesReservedMaximum += Heap->SegmentReserve;
            }
        }

        Usage->BytesReservedMaximum += Usage->BytesReserved;
        Usage->BytesAllocated = Usage->BytesCommitted - (Heap->TotalFreeSize << HEAP_GRANULARITY_SHIFT);

        //
        //  Scan through the big allocations and add those amounts to the
        //  usage statistics
        //

        Head = &Heap->VirtualAllocdBlocks;
        Next = Head->Flink;

        while (Head != Next) {

            VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

            Usage->BytesAllocated += VirtualAllocBlock->CommitSize;
            Usage->BytesCommitted += VirtualAllocBlock->CommitSize;

            Next = Next->Flink;
        }

        Status = STATUS_SUCCESS;

        //
        //  Now check if we have a base buffer and we are suppose to account
        //  for allocated blocks
        //

        if ((Buffer->Base != NULL) &&
            (Flags & HEAP_USAGE_ALLOCATED_BLOCKS)) {

            //
            //  Setup a pointer to the old entries, added entries, and removed
            //  entries in the usage struct.  Also drain the added entries
            //  and removed entries list
            //

            pOldEntries = Usage->Entries;

            ppEntries = &Usage->Entries;

            *ppEntries = NULL;

            ppAddedEntries = &Usage->AddedEntries;

            while (*ppAddedEntries = RtlpFreeHeapUsageEntry( Buffer, *ppAddedEntries )) { NOTHING; }

            ppRemovedEntries = &Usage->RemovedEntries;

            while (*ppRemovedEntries = RtlpFreeHeapUsageEntry( Buffer, *ppRemovedEntries )) { NOTHING; }

            //
            //  The way the code works is that ppEntries, ppAddedEntries, and
            //  ppRemovedEntries point to the tail of their respective lists.  If
            //  the list is empty then they point to the head.
            //

            //
            //  Process every segment in the heap
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                //
                //  Only deal with segments that are in use
                //

                if (Segment) {

                    //
                    //  The current block is really the first block in current
                    //  segment.  We need to special case the computation to
                    //  account for the first heap segment.
                    //

                    if (Segment->BaseAddress == Heap) {

                        CurrentBlock = &Heap->Entry;

                    } else {

                        CurrentBlock = &Segment->Entry;
                    }

                    //
                    //  Now for every busy block in the segment we'll check if
                    //  we need to allocate a heap usage entry and put it in the
                    //  the entries list
                    //

                    while (CurrentBlock < Segment->LastValidEntry) {

                        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                            //
                            //  Compute the users data address and size
                            //

                            DataAddress = (CurrentBlock+1);
                            DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                       RtlpGetUnusedBytes(Heap, CurrentBlock);

    keepLookingAtOldEntries:

                            //
                            //  The first time through this routine will have
                            //  both of these variables null so we'll start off
                            //  by looking at new entries.
                            //

                            if (pOldEntries == Buffer->LargeEntriesSentinal) {

                                goto keepLookingAtNewEntries;
                            }

                            //
                            //  Check if this entry hasn't changed.
                            //
                            //  If the old entry is equal to this data block
                            //  then move the old entry back to the entries
                            //  list and go on to the next block.
                            //

                            if ((pOldEntries->Address == DataAddress) &&
                                (pOldEntries->Size == DataSize)) {

                                //
                                //  Same block, keep in entries list
                                //

                                *ppEntries = pOldEntries;
                                pOldEntries = pOldEntries->Next;
                                ppEntries = &(*ppEntries)->Next;

                                *ppEntries = NULL;

                            //
                            //  Check if an entry was removed
                            //
                            //  If this entry is beyond the old entry then move
                            //  the old entry to the removed entry list and keep
                            //  looking at the old entry list without advancing
                            //  the current data block
                            //

                            } else if (pOldEntries->Address <= DataAddress) {

                                *ppRemovedEntries = pOldEntries;
                                pOldEntries = pOldEntries->Next;
                                ppRemovedEntries = &(*ppRemovedEntries)->Next;

                                *ppRemovedEntries = NULL;

                                goto keepLookingAtOldEntries;

                            //
                            //  Otherwise the we want to process the current data block
                            //

                            } else {

    keepLookingAtNewEntries:

                                //
                                //  Allocate a new heap usage entry
                                //

                                pNewEntry = NULL;

                                Status = RtlpAllocateHeapUsageEntry( Buffer, &pNewEntry );

                                if (!NT_SUCCESS( Status )) {

                                    break;
                                }

                                //
                                //  And fill in the new entry
                                //

                                pNewEntry->Address = DataAddress;
                                pNewEntry->Size = DataSize;

                                //
                                //  If there is an extra stuff struct then fill it in
                                //  with the stack backtrace, and appropriate tag index
                                //

                                if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

    #if i386

                                    pNewEntry->AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

    #endif // i386

                                    if (!IS_HEAP_TAGGING_ENABLED()) {

                                        pNewEntry->TagIndex = 0;

                                    } else {

                                        pNewEntry->TagIndex = ExtraStuff->TagIndex;
                                    }

                                } else {

                                    //
                                    //  Otherwise there is no extra stuff so there is
                                    //  no backtrace and the tag is from the small index
                                    //

    #if i386

                                    pNewEntry->AllocatorBackTraceIndex = 0;

    #endif // i386

                                    if (!IS_HEAP_TAGGING_ENABLED()) {

                                        pNewEntry->TagIndex = 0;

                                    } else {

                                        pNewEntry->TagIndex = CurrentBlock->SmallTagIndex;
                                    }
                                }

                                //
                                //  Allocate another new heap usage entry as part of the added
                                //  entry list
                                //

                                Status = RtlpAllocateHeapUsageEntry( Buffer, ppAddedEntries );

                                if (!NT_SUCCESS( Status )) {

                                    break;
                                }

                                //
                                //  Copy over the contents of the new entry to the added entry
                                //

                                **ppAddedEntries = *pNewEntry;

                                //
                                //  Advance the added entry pointer to the next slot
                                //

                                ppAddedEntries = &((*ppAddedEntries)->Next);

                                *ppAddedEntries = NULL;

                                pNewEntry->Next = NULL;

                                //
                                //  Add the new entry to the entries list
                                //

                                *ppEntries = pNewEntry;
                                ppEntries = &pNewEntry->Next;
                            }
                        }

                        //
                        //  Now advance to the next block in the segment
                        //
                        //  If the next block doesn't exist then zoom through the
                        //  uncommitted ranges in the segment until we find a
                        //  match and can recompute the next real block
                        //

                        if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                            CurrentBlock += CurrentBlock->Size;

                            if (CurrentBlock < Segment->LastValidEntry) {

                                UnCommittedRange = Segment->UnCommittedRanges;

                                while ((UnCommittedRange != NULL) &&
                                       (UnCommittedRange->Address != (ULONG_PTR)CurrentBlock)) {

                                    UnCommittedRange = UnCommittedRange->Next;
                                }

                                if (UnCommittedRange == NULL) {

                                    CurrentBlock = Segment->LastValidEntry;

                                } else {

                                    CurrentBlock = (PHEAP_ENTRY)(UnCommittedRange->Address +
                                                                 UnCommittedRange->Size);
                                }
                            }

                        } else {

                            //
                            //  Otherwise the next block exists and so point
                            //  directly at it
                            //

                            CurrentBlock += CurrentBlock->Size;
                        }
                    }
                }
            }

            //
            //  At this point we've scanned through every segment in the heap
            //
            //  The first time through we now have two lists one of entries and
            //  another of added entries.  In each case Usage->Entries, and
            //  Usage->AddedEntries points to the start of the list and ppEntries,
            //  and ppAddedEntries points to the tail of the list.  The first
            //  time through we has seem to have a one-to-one correspondence
            //  between Entries and AddedEntries, but the AddedEntries records
            //  do not contain anything useful
            //

            if (NT_SUCCESS( Status )) {

                //
                //  Now we'll examine each big allocation, and for each big allocation
                //  we'll make a heap usage entry
                //

                Head = &Heap->VirtualAllocdBlocks;
                Next = Head->Flink;
                VirtualAllocBlockSeen = FALSE;

                while (Head != Next) {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    //
                    //  Allocate a new heap usage entry
                    //

                    pNewEntry = NULL;

                    Status = RtlpAllocateHeapUsageEntry( Buffer, &pNewEntry );

                    if (!NT_SUCCESS( Status )) {

                        break;
                    }

                    VirtualAllocBlockSeen = TRUE;

                    //
                    //  Fill in the new heap usage entry
                    //

                    pNewEntry->Address = (VirtualAllocBlock + 1);
                    pNewEntry->Size = VirtualAllocBlock->CommitSize - VirtualAllocBlock->BusyBlock.Size;

    #if i386

                    pNewEntry->AllocatorBackTraceIndex = VirtualAllocBlock->ExtraStuff.AllocatorBackTraceIndex;

    #endif // i386

                    if (!IS_HEAP_TAGGING_ENABLED()) {

                        pNewEntry->TagIndex = 0;

                    } else {

                        pNewEntry->TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;
                    }

                    //
                    //  Search the heap usage entries list until we find the address
                    //  that right after the new entry address and then insert
                    //  this new entry.  This will keep the entries list sorted in
                    //  assending addresses
                    //
                    //
                    //  The first time through this function ppEntries will point
                    //  to the tail and so *pp should actually start off as null,
                    //  which means that the big allocation simply get tacked on
                    //  the end of the entries list.  We do not augment the
                    //  AddedEntries list for these big allocations.
                    //

                    pp = ppEntries;

                    while (*pp) {

                        if ((*pp)->Address >= pNewEntry->Address) {

                            break;
                        }

                        pp = &(*pp)->Next;
                    }

                    pNewEntry->Next = *pp;
                    *pp = pNewEntry;

                    //
                    //  Get the next big allocation block
                    //

                    Next = Next->Flink;
                }

                //
                //  At this point we've scanned through the heap segments and the
                //  big allocations.
                //
                //  The first time through this procedure we have built two lists
                //  the Entries and the AddedEntries
                //

                if (NT_SUCCESS( Status )) {

                    pOldEntries = Buffer->LargeEntriesSentinal;
                    Buffer->LargeEntriesSentinal = *ppEntries;

                    //
                    //  Now we'll process the previous large entries sentinal list
                    //
                    //  This path is not taken the first time through this procedure
                    //

                    while (pOldEntries != NULL) {

                        //
                        //  If we have new entries and the entry is equal to the
                        //  entry in the previous large sentinal list then
                        //  we move one down on the new list and remove the previous
                        //  sentinal entry
                        //

                        if ((*ppEntries != NULL) &&
                            (pOldEntries->Address == (*ppEntries)->Address) &&
                            (pOldEntries->Size == (*ppEntries)->Size)) {

                            ppEntries = &(*ppEntries)->Next;

                            pOldEntries = RtlpFreeHeapUsageEntry( Buffer, pOldEntries );

                        //
                        //  If we do now have any new entries or the previous
                        //  sentinal entry is comes before this new entry then
                        //  we'll add the sentinal entry to the remove list
                        //

                        } else if ((*ppEntries == NULL) ||
                                   (pOldEntries->Address < (*ppEntries)->Address)) {

                            *ppRemovedEntries = pOldEntries;

                            pOldEntries = pOldEntries->Next;

                            ppRemovedEntries = &(*ppRemovedEntries)->Next;

                            *ppRemovedEntries = NULL;

                        //
                        //  Otherwise the old sentinal entry is put on the added
                        //  entries list
                        //

                        } else {

                            *ppAddedEntries = pOldEntries;

                            pOldEntries = pOldEntries->Next;

                            **ppAddedEntries = **ppEntries;

                            ppAddedEntries = &(*ppAddedEntries)->Next;

                            *ppAddedEntries = NULL;
                        }
                    }

                    //
                    //  This path is not taken the first time through this procedure
                    //

                    while (pNewEntry = *ppEntries) {

                        Status = RtlpAllocateHeapUsageEntry( Buffer, ppAddedEntries );

                        if (!NT_SUCCESS( Status )) {

                            break;
                        }

                        **ppAddedEntries = *pNewEntry;

                        ppAddedEntries = &(*ppAddedEntries)->Next;

                        *ppAddedEntries = NULL;

                        ppEntries = &pNewEntry->Next;
                    }

                    //
                    //  Tell the user that something has changed between the
                    //  previous call and this one
                    //

                    if ((Usage->AddedEntries != NULL) || (Usage->RemovedEntries != NULL)) {

                        Status = STATUS_MORE_ENTRIES;
                    }
                }
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

    This routine is used to enumerate all the entries within a heap.  For each
    call it returns a new information in entry.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Entry - Supplies storage for the entry information.  If the DataAddress field
        is null then the enumeration starts over from the beginning otherwise it
        resumes from where it left off

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    PLIST_ENTRY Next, Head;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

    //
    //  Check if we should be using the guard page verion of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapWalk( HeapHandle, Entry ));

    //
    //  If this is the debug version of heap then validate the heap
    //  before we go on
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugWalkHeap( HeapHandle, Entry )) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = STATUS_SUCCESS;

    //
    //  If there is an active lookaside list then drain and remove it.
    //  By setting the lookaside field in the heap to null we guarantee
    //  that the call the free heap will not try and use the lookaside
    //  list logic.
    //
    //  We'll actually capture the lookaside pointer from the heap and
    //  only use the captured pointer.  This will take care of the
    //  condition where another walk or lock heap can cause us to check
    //  for a non null pointer and then have it become null when we read
    //  it again.  If it is non null to start with then even if the
    //  user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);

        if (Lookaside != NULL) {

            ULONG i;
            PVOID Block;

            Heap->FrontEndHeap = NULL;
            Heap->FrontEndHeapType = 0;

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                    RtlFreeHeap( HeapHandle, 0, Block );
                }
            }
        }
    }

    //
    //  Check if this is the first time we've been called to walk the heap
    //

    if (Entry->DataAddress == NULL) {

        //
        //  Start with the first segement in the heap
        //

        SegmentIndex = 0;

nextSegment:

        CurrentBlock = NULL;

        //
        //  Now find the next in use segment for the heap
        //

        Segment = NULL;

        while ((SegmentIndex < HEAP_MAXIMUM_SEGMENTS) &&
               ((Segment = Heap->Segments[ SegmentIndex ]) == NULL)) {

            SegmentIndex += 1;
        }

        //
        //  If there are no more valid segments then we'll try the big
        //  allocation
        //

        if (Segment == NULL) {

            Head = &Heap->VirtualAllocdBlocks;
            Next = Head->Flink;

            if (Next == Head) {

                Status = STATUS_NO_MORE_ENTRIES;

            } else {

                VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                CurrentBlock = &VirtualAllocBlock->BusyBlock;
            }

        //
        //  Otherwise we'll grab information about the segment.  Note that
        //  the current block is still null so when we fall out of this
        //  block we'll return directly to our caller with this segment
        //  information
        //

        } else {

            Entry->DataAddress = Segment;

            Entry->DataSize = 0;

            Entry->OverheadBytes = sizeof( *Segment );

            Entry->Flags = RTL_HEAP_SEGMENT;

            Entry->SegmentIndex = SegmentIndex;

            Entry->Segment.CommittedSize = (Segment->NumberOfPages -
                                            Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

            Entry->Segment.UnCommittedSize = Segment->NumberOfUnCommittedPages * PAGE_SIZE;

            Entry->Segment.FirstEntry = (Segment->FirstEntry->Flags & HEAP_ENTRY_BUSY) ?
                ((PHEAP_ENTRY)Segment->FirstEntry + 1) :
                (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Segment->FirstEntry + 1);

            Entry->Segment.LastEntry = Segment->LastValidEntry;
        }

    //
    //  This is not the first time through.  Check if last time we gave back
    //  an heap segement or an uncommitted range
    //

    } else if (Entry->Flags & (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {

        //
        //  Check that the segment index is still valid
        //

        if ((SegmentIndex = Entry->SegmentIndex) >= HEAP_MAXIMUM_SEGMENTS) {

            Status = STATUS_INVALID_ADDRESS;

            CurrentBlock = NULL;

        } else {

            //
            //  Check that the segment is still in use
            //

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  The segment is still in use if what we returned last time
            //  as the segment header then this time we'll return the
            //  segments first entry
            //

            } else if (Entry->Flags & RTL_HEAP_SEGMENT) {

                CurrentBlock = (PHEAP_ENTRY)Segment->FirstEntry;

            //
            //  Otherwise what we returned last time as an uncommitted
            //  range so now we need to get the next block
            //

            } else {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)Entry->DataAddress + Entry->DataSize);

                //
                //  Check if we are beyond this segment and need to get the
                //  next one
                //

                if (CurrentBlock >= Segment->LastValidEntry) {

                    SegmentIndex += 1;

                    goto nextSegment;
                }
            }
        }

    //
    //  Otherwise this is not the first time through and last time we gave back a
    //  valid heap entry
    //

    } else {

        //
        //  Check if the last entry we gave back was in use
        //

        if (Entry->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = ((PHEAP_ENTRY)Entry->DataAddress - 1);

            //
            //  If the last entry was for a big allocation then
            //  get the next big block if there is one otherwise
            //  say there are no more entries
            //
            
            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Head = &Heap->VirtualAllocdBlocks;

                VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Next = VirtualAllocBlock->Entry.Flink;

                if (Next == Head) {

                    Status = STATUS_NO_MORE_ENTRIES;

                } else {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    CurrentBlock = &VirtualAllocBlock->BusyBlock;
                }

            //
            //  Our previous result is a busy normal block
            //

            } else {

                if ( CurrentBlock->SegmentIndex == HEAP_LFH_INDEX ) {

                    //
                    //  Get the block size from the sub-segment. N.B the block size there
                    //  is in heap units as well.
                    //

                    PHEAP_ENTRY NextBlock = CurrentBlock + ((PHEAP_SUBSEGMENT)CurrentBlock->SubSegment)->BlockSize;

                    if (NextBlock->SegmentIndex == HEAP_LFH_INDEX) {

                        CurrentBlock = NextBlock;

                        goto SETCRTBLOCK;
                    }

                    //
                    //  We finished the metablock. We need to jump back to the metablock header
                    //

                    CurrentBlock = ((PHEAP_ENTRY)((PHEAP_SUBSEGMENT)CurrentBlock->SubSegment)->UserBlocks) - 1;
                }

                //
                //  Get the segment and make sure it is still valid and in use
                //

                Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

                if (Segment == NULL) {

                    Status = STATUS_INVALID_ADDRESS;

                    CurrentBlock = NULL;

                //
                //  The segment is still in use, check if what we returned
                //  previously was a last entry
                //

                } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

findUncommittedRange:

                    //
                    //  We are at a last entry so now if the segment is done
                    //  then go get another segment
                    //

                    CurrentBlock += CurrentBlock->Size;

                    if (CurrentBlock >= Segment->LastValidEntry) {

                        SegmentIndex += 1;

                        goto nextSegment;
                    }

                    //
                    //  Otherwise we will find the uncommitted range entry that
                    //  immediately follows this last entry
                    //

                    pp = &Segment->UnCommittedRanges;

                    while ((UnCommittedRange = *pp) && UnCommittedRange->Address != (ULONG_PTR)CurrentBlock ) {

                        pp = &UnCommittedRange->Next;
                    }

                    if (UnCommittedRange == NULL) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else {

                        //
                        //  Now fill in the entry to denote that uncommitted
                        //  range information
                        //

                        Entry->DataAddress = (PVOID)UnCommittedRange->Address;

                        Entry->DataSize = UnCommittedRange->Size;

                        Entry->OverheadBytes = 0;

                        Entry->SegmentIndex = SegmentIndex;

                        Entry->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                    }

                    //
                    //  Null out the current block because we've just filled in
                    //  the entry
                    //

                    CurrentBlock = NULL;

                } else {

                    //
                    //  Otherwise the entry has a following entry so now
                    //  advance to the next entry
                    //

                    CurrentBlock += CurrentBlock->Size;
                }
            }

        //
        //  Otherwise the previous entry we returned is not in use
        //

        } else {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Entry->DataAddress - 1);

            if ( CurrentBlock->SegmentIndex == HEAP_LFH_INDEX ) {

                //
                //
                //  We finished the metablock. We need to jump back to the metablock header
                //  we get the block size from the sub-segment. N.B the block size there
                //  is in heap units as well.
                //

                PHEAP_ENTRY NextBlock = CurrentBlock + ((PHEAP_SUBSEGMENT)CurrentBlock->SubSegment)->BlockSize;

                if (NextBlock->SegmentIndex == HEAP_LFH_INDEX) {

                    CurrentBlock = NextBlock;

                    goto SETCRTBLOCK;
                }

                CurrentBlock = ((PHEAP_ENTRY)((PHEAP_SUBSEGMENT)CurrentBlock->SubSegment)->UserBlocks) - 1;
            }

            //
            //  Get the segment and make sure it it still valid and in use
            //

            Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  If the block is the last entry then go find the next uncommitted
            //  range or segment
            //

            } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                goto findUncommittedRange;

            //
            //  Otherwise we'll just move on to the next entry
            //

            } else {

                CurrentBlock += CurrentBlock->Size;
            }
        }
    }

SETCRTBLOCK:
    //
    //  At this point if current block is not null then we've found another
    //  entry to return.  We could also have found a segment or uncommitted
    //  range but those are handled separately above and keep current block
    //  null
    //

    if (CurrentBlock != NULL) {

        if (RtlpGetLowFragHeap(Heap)
                &&
            (CurrentBlock->Size > ((sizeof(HEAP_USERDATA_HEADER) + sizeof(HEAP_ENTRY)) >> HEAP_GRANULARITY_SHIFT))
                &&
            (((PHEAP_USERDATA_HEADER)(CurrentBlock + 1))->Signature == HEAP_LFH_USER_SIGNATURE)) {
            
            CurrentBlock = (PHEAP_ENTRY)((ULONG_PTR)CurrentBlock + sizeof(HEAP_USERDATA_HEADER) + sizeof(HEAP_ENTRY));
        }

        //
        //  Check if the block is in use
        //

        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Fill in the entry field for this block
            //

            Entry->DataAddress = (CurrentBlock+1);

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Entry->DataSize = RtlpGetSizeOfBigBlock( CurrentBlock );

                Entry->OverheadBytes = (UCHAR)( sizeof( *VirtualAllocBlock ) + CurrentBlock->Size);

                Entry->SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

                Entry->Flags = RTL_HEAP_BUSY |  HEAP_ENTRY_VIRTUAL_ALLOC;

            } else {

                Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                  RtlpGetUnusedBytes(Heap, CurrentBlock);

                //
                //  OverheadBytes can't hold bore than 256 values. We copy then 
                //  the UnusedBytes value, even if the block actually has more than this
                //

                Entry->OverheadBytes = CurrentBlock->UnusedBytes; 

                Entry->SegmentIndex = CurrentBlock->SegmentIndex;

                Entry->Flags = RTL_HEAP_BUSY;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

                Entry->Block.Settable = ExtraStuff->Settable;
#if i386

                Entry->Block.AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

#endif // i386

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = ExtraStuff->TagIndex;
                }

                Entry->Flags |= RTL_HEAP_SETTABLE_VALUE;

            } else {

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = CurrentBlock->SmallTagIndex;
                }
            }

            Entry->Flags |= CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS;

        //
        //  Otherwise the block is not in use
        //

        } else {

            Entry->DataAddress = ((PHEAP_FREE_ENTRY)CurrentBlock+1);

            Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                              sizeof( HEAP_FREE_ENTRY );

            Entry->OverheadBytes = sizeof( HEAP_FREE_ENTRY );

            Entry->SegmentIndex = CurrentBlock->SegmentIndex;

            Entry->Flags = 0;
        }
    }

    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(NTDLL_EVENT_COMMON) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PNTDLL_EVENT_COMMON pHeapEvent = (PNTDLL_EVENT_COMMON)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_WALK;
            pHeapEvent->Handle	      = (PVOID)HeapHandle;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 

    #endif // NTOS_KERNEL_RUNTIME


    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    )

/*++

Routine Description:

    This routine verifies that it is being called with a properly identified
    heap.

Arguments:

    Heap - Supplies a pointer to the heap being checked

    Caller - Supplies a string that can be used to identify the caller

Return Value:

    BOOLEAN - TRUE if the heap signature is present, and FALSE otherwise

--*/

{
    //
    //  If the heap signature matches then that is the only
    //  checking we do
    //

    if (Heap->Signature == HEAP_SIGNATURE) {

        return TRUE;

    } else {

        //
        //  We have a bad heap signature.  Print out some information, break
        //  into the debugger, and then return false
        //

        HeapDebugPrint(( "Invalid heap signature for heap at %x", Heap ));

        if (Caller != NULL) {

            DbgPrint( ", passed to %s", Caller );
        }

        DbgPrint( "\n" );

        HeapDebugBreak( &Heap->Signature );

        return FALSE;
    }
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine scans through heap and coalesces its free blocks

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the largest free block
        in the heap

--*/

{
    SIZE_T OldFreeSize;
    SIZE_T FreeSize;
    ULONG n;
    PHEAP_FREE_ENTRY FreeBlock, LargestFreeBlock;
    PLIST_ENTRY FreeListHead, Next;

    RTL_PAGED_CODE();

    LargestFreeBlock = NULL;

    //
    //  For every free list in the heap, going from smallest to
    //  largest and skipping the zero index one we will
    //  scan the free list coalesceing the free blocks
    //

    FreeListHead = &Heap->FreeLists[ 1 ];

    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        //
        //  Scan the individual free list
        //

        Next = FreeListHead->Blink;

        while (FreeListHead != Next) {

            //
            //  Get a pointer to the current free list entry, and remember its
            //  next and size
            //

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            Next = Next->Flink;
            OldFreeSize = FreeSize = FreeBlock->Size;

            //
            //  Coalesce the block
            //

            FreeBlock = RtlpCoalesceFreeBlocks( Heap,
                                                FreeBlock,
                                                &FreeSize,
                                                TRUE );

            //
            //  If the new free size is not equal to the old free size
            //  then we actually did some changes otherwise the coalesce
            //  calll was essentialy a noop
            //

            if (FreeSize != OldFreeSize) {

                //
                //  Check if we should decommit this block because it is too
                //  large and it is either at the beginning or end of a
                //  committed run.  Otherwise just insert the new sized
                //  block into its corresponding free list.  We'll hit this
                //  block again when we visit larger free lists.
                //

                if (FreeBlock->Size >= (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT)

                        &&

                    (FreeBlock->PreviousSize == 0 ||
                     (FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY))) {

                    RtlpDeCommitFreeBlock( Heap, FreeBlock, FreeSize );

                } else {

                    RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );
                }

                Next = FreeListHead->Blink;

            } else {

                //
                //  Remember the largest free block we've found so far
                //

                if ((LargestFreeBlock == NULL) ||
                    (LargestFreeBlock->Size < FreeBlock->Size)) {

                    LargestFreeBlock = FreeBlock;
                }
            }
        }

        //
        //  Go to the next free list.  When we hit the largest dedicated
        //  size free list we'll fall back to the [0] index list
        //

        if (n == 1) {

            FreeListHead = &Heap->FreeLists[ 0 ];

        } else {

            FreeListHead++;
        }
    }

    //
    //  And return to our caller
    //

    return LargestFreeBlock;
}


//
//  Declared in heappriv.h
//

VOID
RtlpAddHeapToProcessList (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine adds the specified heap to the heap list for the
    current process

Arguments:

    Heap - Supplies a pointer to the heap being added

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();
    PHEAP *NewList;

    //
    //  Lock the processes heap list
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  If the processes heap list is already full then we'll
        //  double the size of the heap list for the process
        //

        if (Peb->NumberOfHeaps == Peb->MaximumNumberOfHeaps) {

            //
            //  Double the size
            //

            Peb->MaximumNumberOfHeaps *= 2;

            //
            //  Allocate space for the new list
            //

            NewList = RtlAllocateHeap( RtlProcessHeap(),
                                       0,
                                       Peb->MaximumNumberOfHeaps * sizeof( *NewList ));

            if (NewList == NULL) {

                //
                //  We can't allocate space for the new list. Restore then
                //  the previous value for MaximumNumberOfHeaps
                //

                Peb->MaximumNumberOfHeaps = Peb->NumberOfHeaps;

                leave;
            }

            //
            //  Copy over the old buffer to the new buffer
            //

            RtlCopyMemory( NewList,
                           Peb->ProcessHeaps,
                           Peb->NumberOfHeaps * sizeof( *NewList ));

            //
            //  Check if we should free the previous heap list buffer
            //

            if (Peb->ProcessHeaps != RtlpProcessHeapsListBuffer) {

                RtlFreeHeap( RtlProcessHeap(), 0, Peb->ProcessHeaps );
            }

            //
            //  Set the new list
            //

            Peb->ProcessHeaps = NewList;
        }

        //
        //  Add the input heap to the next free heap list slot, and note that
        //  the processes heap list index is really one beyond the actualy
        //  index used to get the processes heap
        //

        Peb->ProcessHeaps[ Peb->NumberOfHeaps++ ] = Heap;
        Heap->ProcessHeapsListIndex = (USHORT)Peb->NumberOfHeaps;

    } finally {

        //
        //  Unlock the processes heap list
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Delcared in heappriv.h
//

VOID
RtlpRemoveHeapFromProcessList (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine removes the specified heap to the heap list for the
    current process

Arguments:

    Heap - Supplies a pointer to the heap being removed

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();
    PHEAP *p, *p1;
    ULONG n;

    //
    //  Lock the current processes heap list lock
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  We only want to the the work if the current process actually has some
        //  heaps, the index stored in the heap is within the range for active
        //  heaps.  Note that the heaps stored index is bias by one.
        //

        if ((Peb->NumberOfHeaps != 0) &&
            (Heap->ProcessHeapsListIndex != 0) &&
            (Heap->ProcessHeapsListIndex <= Peb->NumberOfHeaps)) {

            //
            //  Establish a pointer into the array of process heaps at the
            //  current heap location and one beyond
            //

            p = (PHEAP *)&Peb->ProcessHeaps[ Heap->ProcessHeapsListIndex - 1 ];

            p1 = p + 1;

            //
            //  Calculate the number of heaps that exist beyond the current
            //  heap in the array including the current heap location
            //

            n = Peb->NumberOfHeaps - (Heap->ProcessHeapsListIndex - 1);

            //
            //  For every heap beyond the current one that we are removing
            //  we'll move that heap down to the previous index.
            //

            while (--n) {

                //
                //  Copy the heap process array entry of the next entry to
                //  the current entry, and move p1 to the next next entry
                //

                *p = *p1++;

                //
                //  This is simply a debugging call
                //

                RtlpUpdateHeapListIndex( (*p)->ProcessHeapsListIndex,
                                         (USHORT)((*p)->ProcessHeapsListIndex - 1));

                //
                //  Assign the moved heap its new heap index
                //

#if 0
                if (RtlpDebugPageHeap) {

                    PVOID ProtectAddress;
                    ULONG OldProtect;
                    ULONG NewProtect;
                    NTSTATUS Status;
                    SIZE_T Size;

                    ProtectAddress = *p;
                    Size = PAGE_SIZE;
                    NewProtect = PAGE_READWRITE;

                    Status = ZwProtectVirtualMemory( NtCurrentProcess(),
                                                     &ProtectAddress,
                                                     &Size,
                                                     NewProtect,
                                                     &OldProtect );

                    if (! NT_SUCCESS(Status)) {
                        DbgPrint ("Page heap: Failing to change protection in heap destroy (%x) \n",
                                  Status);
                    }

                    (*p)->ProcessHeapsListIndex -= 1;
                    
                    ProtectAddress = *p;
                    Size = PAGE_SIZE;
                    NewProtect = OldProtect;

                    Status = ZwProtectVirtualMemory( NtCurrentProcess(),
                                                     &ProtectAddress,
                                                     &Size,
                                                     NewProtect,
                                                     &OldProtect );

                }
                else {

                    (*p)->ProcessHeapsListIndex -= 1;
                }
#else
                (*p)->ProcessHeapsListIndex -= 1;
#endif

                //
                //  Move on to the next heap entry
                //

                p += 1;
            }

            //
            //  Zero out the last process heap pointer, update the count, and
            //  make the heap we just removed realize it has been removed by
            //  zeroing out its process heap list index
            //

            Peb->ProcessHeaps[ --Peb->NumberOfHeaps ] = NULL;
            Heap->ProcessHeapsListIndex = 0;
        }

    } finally {

        //
        //  Unlock the current processes heap list lock
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    return;
}


//
//  Local Support routine
//

BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    )

/*++

Routine Description:

    This routine will try and grow a heap allocation block at its current
    location

Arguments:

    Heap - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags to augment those already enforced by
        the heap

    BusyBlock - Supplies a pointer to the block being resized

    Size - Supplies the size, in bytes, needed by the resized block

    AllocationIndex - Supplies the allocation index for the resized block
        Note that the size variable has not been rounded up to the next
        granular block size, but that allocation index has.

Return Value:

    BOOLEAN - TRUE if the block has been resized and FALSE otherwise

--*/

{
    SIZE_T FreeSize;
    SIZE_T OldSize;
    UCHAR EntryFlags, FreeFlags;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;

    //
    //  Check if the allocation index is too large for even the nondedicated
    //  free list (i.e., too large for list [0])
    //

    if (AllocationIndex > Heap->VirtualMemoryThreshold) {

        return FALSE;
    }

    //
    //  Get the flags for the current block and a pointer to the next
    //  block following the current block
    //

    EntryFlags = BusyBlock->Flags;

    FreeBlock = (PHEAP_FREE_ENTRY)(BusyBlock + BusyBlock->Size);

    //
    //  If the current block is the last entry before an uncommitted range
    //  we'll try and extend the uncommitted range to fit our new allocation
    //

    if (EntryFlags & HEAP_ENTRY_LAST_ENTRY) {

        //
        //  Calculate how must more we need beyond the current block
        //  size
        //

        FreeSize = (AllocationIndex - BusyBlock->Size) << HEAP_GRANULARITY_SHIFT;
        FreeSize = ROUND_UP_TO_POWER2( FreeSize, PAGE_SIZE );

        //
        //  Try and commit memory at the desired location
        //

        FreeBlock = RtlpFindAndCommitPages( Heap,
                                            Heap->Segments[ BusyBlock->SegmentIndex ],
                                            &FreeSize,
                                            (PHEAP_ENTRY)FreeBlock );

        //
        //  Check if the commit succeeded
        //

        if (FreeBlock == NULL) {

            return FALSE;
        }

        //
        //  New coalesce this newly committed space with whatever is free
        //  around it
        //

        FreeSize = FreeSize >> HEAP_GRANULARITY_SHIFT;

        FreeBlock = RtlpCoalesceFreeBlocks( Heap, FreeBlock, &FreeSize, FALSE );

        FreeFlags = FreeBlock->Flags;

        //
        //  If the newly allocated space plus the current block size is still
        //  not big enough for our resize effort then put this newly
        //  allocated block into the appropriate free list and tell our caller
        //  that a resize wasn't possible
        //

        if ((FreeSize + BusyBlock->Size) < AllocationIndex) {

            RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

            Heap->TotalFreeSize += FreeSize;

            if (DEBUG_HEAP(Flags)) {

                RtlpValidateHeapHeaders( Heap, TRUE );
            }

            return FALSE;
        }

        //
        //  We were able to generate enough space for the resize effort, so
        //  now free size will be the index for the current block plus the
        //  new free space
        //

        FreeSize += BusyBlock->Size;

    } else {

        //
        //  The following block is present so grab its flags and see if
        //  it is free or busy.  If busy then we cannot grow the current
        //  block
        //

        FreeFlags = FreeBlock->Flags;

        if (FreeFlags & HEAP_ENTRY_BUSY) {

            return FALSE;
        }

        //
        //  Compute the index if we combine current block with its following
        //  free block and check if it is big enough
        //

        FreeSize = BusyBlock->Size + FreeBlock->Size;

        if (FreeSize < AllocationIndex) {

            return FALSE;
        }

        //
        //  The two blocks together are big enough so now remove the free
        //  block from its free list, and update the heap's total free size
        //

        RtlpRemoveFreeBlock( Heap, FreeBlock );

        Heap->TotalFreeSize -= FreeBlock->Size;
    }

    //
    //  At this point we have a busy block followed by a free block that
    //  together have enough space for the resize.  The free block has been
    //  removed from its list and free size is the index of the two combined
    //  blocks.
    //
    //  Calculate the number of bytes in use in the old block
    //

    OldSize = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) - RtlpGetUnusedBytes(Heap, BusyBlock);

    //
    //  Calculate the index for whatever excess we'll have when we combine
    //  the two blocks
    //

    FreeSize -= AllocationIndex;

    //
    //  If the excess is not too much then put it back in our allocation
    //  (i.e., we don't want small free pieces left over)
    //

    if (FreeSize <= 2) {

        AllocationIndex += FreeSize;

        FreeSize = 0;
    }

    //
    //  If the busy block has an extra stuff struct present then copy over the
    //  extra stuff
    //

    if (EntryFlags & HEAP_ENTRY_EXTRA_PRESENT) {

        OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);
        NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

        *NewExtraStuff = *OldExtraStuff;

        //
        //  If heap tagging is enabled then update the heap tag from the extra
        //  stuff struct
        //

        if (IS_HEAP_TAGGING_ENABLED()) {

            NewExtraStuff->TagIndex =
                RtlpUpdateTagEntry( Heap,
                                    NewExtraStuff->TagIndex,
                                    BusyBlock->Size,
                                    AllocationIndex,
                                    ReAllocationAction );
        }

    //
    //  Otherwise extra stuff is not in use so see if heap tagging is enabled
    //  and if so then update small tag index
    //

    } else if (IS_HEAP_TAGGING_ENABLED()) {

        BusyBlock->SmallTagIndex = (UCHAR)
            RtlpUpdateTagEntry( Heap,
                                BusyBlock->SmallTagIndex,
                                BusyBlock->Size,
                                AllocationIndex,
                                ReAllocationAction );
    }

    //
    //  Check if we will have any free space to give back.
    //

    if (FreeSize == 0) {

        //
        //  No following free space so update the flags, size and byte counts
        //  for the resized block.  If the free block was a last entry
        //  then the busy block must also now be a last entry.
        //

        BusyBlock->Flags |= FreeFlags & HEAP_ENTRY_LAST_ENTRY;

        BusyBlock->Size = (USHORT)AllocationIndex;

        RtlpSetUnusedBytes(Heap, BusyBlock, ((AllocationIndex << HEAP_GRANULARITY_SHIFT) - Size));

        //
        //  Update the previous size field of the following block if it exists
        //

        if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

            (BusyBlock + BusyBlock->Size)->PreviousSize = BusyBlock->Size;

        } else {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[BusyBlock->SegmentIndex];
            Segment->LastEntryInSegment = BusyBlock;
        }

    //
    //  Otherwise there is some free space to return to the heap
    //

    } else {

        //
        //  Update the size and byte counts for the resized block.
        //

        BusyBlock->Size = (USHORT)AllocationIndex;

        RtlpSetUnusedBytes(Heap, BusyBlock, ((AllocationIndex << HEAP_GRANULARITY_SHIFT) - Size));

        //
        //  Determine where the new free block starts and fill in its fields
        //

        SplitBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)BusyBlock + AllocationIndex);

        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

        //
        //  If this new free block will be the last entry then update its
        //  flags and size and put it into the appropriate free list
        //

        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[SplitBlock->SegmentIndex];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

            SplitBlock->Flags = FreeFlags;
            SplitBlock->Size = (USHORT)FreeSize;

            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

            Heap->TotalFreeSize += FreeSize;

        //
        //  The free block is followed by another valid block
        //

        } else {

            //
            //  Point to the block following our new free block
            //

            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

            //
            //  If the block following the new free block is busy then
            //  update the flags and size for the new free block, update
            //  the following blocks previous size, and put the free block
            //  into the appropriate free list
            //

            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                SplitBlock->Flags = FreeFlags & (~HEAP_ENTRY_LAST_ENTRY);
                SplitBlock->Size = (USHORT)FreeSize;

                ((PHEAP_ENTRY)SplitBlock + FreeSize)->PreviousSize = (USHORT)FreeSize;

                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                Heap->TotalFreeSize += FreeSize;

            //
            //  Otherwise the following block is also free so we can combine
            //  these two blocks
            //

            } else {

                //
                //  Remember the new free flags from the following block
                //

                FreeFlags = SplitBlock2->Flags;

                //
                //  Remove the following block from its free list
                //

                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                Heap->TotalFreeSize -= SplitBlock2->Size;

                //
                //  Calculate the size of the new combined free block
                //

                FreeSize += SplitBlock2->Size;

                //
                //  Give the new the its new flags
                //

                SplitBlock->Flags = FreeFlags;

                //
                //  If the combited block is not too large for the dedicated
                //  free lists then that where we'll put it
                //

                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                    SplitBlock->Size = (USHORT)FreeSize;

                    //
                    //  If present update the previous size for the following block
                    //

                    if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

                        ((PHEAP_ENTRY)SplitBlock + FreeSize)->PreviousSize = (USHORT)FreeSize;

                    } else {

                        PHEAP_SEGMENT Segment;

                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                    }

                    //
                    //  Insert the new combined free block into the free list
                    //

                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                    Heap->TotalFreeSize += FreeSize;

                } else {

                    //
                    //  Otherwise the new free block is too large to go into
                    //  a dedicated free list so put it in the general free list
                    //  which might involve breaking it apart.
                    //

                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                }
            }
        }
    }

    //
    //  At this point the block has been resized and any extra space has been
    //  returned to the free list
    //
    //  Check if we should zero out the new space
    //

    if (Flags & HEAP_ZERO_MEMORY) {

        //
        //  Because of the unused bytes, the OldSize can be lower than Size
        //  We'll fill the remaining chunck with 0.
        //

        if (Size > OldSize) {

            RtlZeroMemory( (PCHAR)(BusyBlock + 1) + OldSize,
                           Size - OldSize );
        }

    //
    //  Check if we should be filling in heap after it as
    //  been freed, and if so then fill in the newly allocated
    //  space beyond the old bytes.
    //

    } else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

        SIZE_T PartialBytes, ExtraSize;

        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

        if (PartialBytes) {

            PartialBytes = 4 - PartialBytes;
        }

        if (Size > (OldSize + PartialBytes)) {

            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

            if (ExtraSize != 0) {

                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                    ExtraSize,
                                    ALLOC_HEAP_FILL );
            }
        }
    }

    //
    //  If we are going tailing checking then fill in the space right beyond
    //  the new allocation
    //

    if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

        RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                       CHECK_HEAP_TAIL_SIZE,
                       CHECK_HEAP_TAIL_FILL );
    }

    //
    //  Give the resized block any user settable flags send in by the
    //  caller
    //

    BusyBlock->Flags &= ~HEAP_ENTRY_SETTABLE_FLAGS;
    BusyBlock->Flags |= ((Flags & HEAP_SETTABLE_USER_FLAGS) >> 4);

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Local support routine
//

PHEAP_TAG_ENTRY
RtlpAllocateTags (
    PHEAP Heap,
    ULONG NumberOfTags
    )

/*++

Routine Description:

    This routine is used to allocate space for additional tags within
    a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified.  If not specified
        then the processes global tag heap is used

    NumberOfTags - Supplies the number of tags that we want stored in the
        heap.  This is the number to grow the tag list by.

Return Value:

    PHEAP_TAG_ENTRY - Returns a pointer to the next available tag entry in the
        heap

--*/

{
    NTSTATUS Status;
    ULONG TagIndex;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    PHEAP_TAG_ENTRY TagEntry;
    USHORT CreatorBackTraceIndex;
    USHORT MaximumTagIndex;
    USHORT TagIndexFlag;

    //
    //  Check if the process has a global tag heap.  If not then there is
    //  nothing for us to do
    //

    if (RtlpGlobalTagHeap == NULL) {

        return NULL;
    }

    //
    //  If the user didn't give us a heap then use the processes global
    //  tag heap
    //

    if (Heap == NULL) {

        RtlpGlobalTagHeap->Signature = HEAP_SIGNATURE;

        RtlpGlobalTagHeap->Flags = HEAP_NO_SERIALIZE;

        TagIndexFlag = HEAP_GLOBAL_TAG;

        Heap = RtlpGlobalTagHeap;

    } else {

        TagIndexFlag = 0;
    }

    //
    //  Grab the stack backtrace if possible and if we should
    //

    CreatorBackTraceIndex = 0;

    if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

        CreatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
    }

    //
    //  If the heap does not already have tag entries then we'll
    //  reserve space for them
    //

    if (Heap->TagEntries == NULL) {

        MaximumTagIndex = HEAP_MAXIMUM_TAG & ~HEAP_GLOBAL_TAG;

        ReserveSize = MaximumTagIndex * sizeof( HEAP_TAG_ENTRY );

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Heap->TagEntries,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        Heap->MaximumTagIndex = MaximumTagIndex;

        Heap->NextAvailableTagIndex = 0;

        //
        // Add one for zero tag, as that is always reserved for heap name
        //

        NumberOfTags += 1;
    }

    //
    //  At this point we have a space reserved for tag entries.  If the number
    //  of tags that we need to grow is too large then tell the user we can't
    //  do it.
    //

    if (NumberOfTags > (ULONG)(Heap->MaximumTagIndex - Heap->NextAvailableTagIndex)) {

        return NULL;
    }

    //
    //  Get a pointer to the next available tag entry, and for
    //  every tag entry that we want to grow by we'll commit
    //  the page containing the tag entry.  We only need to do
    //  this for every page just once.  We'll determine this
    //  by seeing when the tag entry crosses a page boundary
    //

    TagEntry = Heap->TagEntries + Heap->NextAvailableTagIndex;

    for (TagIndex = Heap->NextAvailableTagIndex;
         TagIndex < Heap->NextAvailableTagIndex + NumberOfTags;
         TagIndex++ ) {

        if (((((ULONG_PTR)TagEntry + sizeof(*TagEntry)) & (PAGE_SIZE-1)) <=
            sizeof(*TagEntry))) {

            CommitSize = PAGE_SIZE;

            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &TagEntry,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }
        }

        //
        //  Bias the tag index if this is the global tag heap
        //

        TagEntry->TagIndex = (USHORT)TagIndex | TagIndexFlag;

        //
        //  Set the stack back trace
        //

        TagEntry->CreatorBackTraceIndex = CreatorBackTraceIndex;

        //
        //  Move on to the next tag entry
        //

        TagEntry += 1;
    }

    //
    //  At this point we've build the new tag list so now pop off the next
    //  available tag entry
    //

    TagEntry = Heap->TagEntries + Heap->NextAvailableTagIndex;

    Heap->NextAvailableTagIndex += (USHORT)NumberOfTags;

    //
    //  And return to our caller
    //

    return TagEntry;
}


//
//  Declared in heappriv.h
//

PWSTR
RtlpGetTagName (
    PHEAP Heap,
    USHORT TagIndex
    )

/*++

Routine Description:

    This routine returns the name of the tag denoted by the heap, tagindex
    tuple.

    This routine is only called by heapdbg when doing a debug print to
    generate a tag name for printing

Arguments:

    Heap - Supplies the tag being queried

    TagIndex - Supplies the index for the tag being queried

Return Value:

    PWSTR - returns the name of the indicated tag

--*/

{
    //
    //  If the processes global tag heap has not been initialized then
    //  not tag has a name
    //

    if (RtlpGlobalTagHeap == NULL) {

        return NULL;
    }

    //
    //  We only deal with non zero tag indices
    //

    if (TagIndex != 0) {

        //
        //  If the tag index is for a pseudo tag then we clear the
        //  the psuedo bit and generate a pseudo tag name
        //

        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

            //
            //  Check that the tag index is valid and that the heap
            //  has some psuedo tag entries
            //

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                //
                //  A pseudo tag index of zero denote objects
                //

                if (TagIndex == 0) {

                    swprintf( RtlpPseudoTagNameBuffer, L"Objects>%4u",
                              HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT );

                //
                //  A psuedo tag index less than the free list maximum
                //  denotes the dedicated free list
                //

                } else if (TagIndex < HEAP_MAXIMUM_FREELISTS) {

                    swprintf( RtlpPseudoTagNameBuffer, L"Objects=%4u", TagIndex << HEAP_GRANULARITY_SHIFT );

                //
                //  Otherwise the pseudo tag is for the big allocations
                //

                } else {

                    swprintf( RtlpPseudoTagNameBuffer, L"VirtualAlloc" );
                }

                return RtlpPseudoTagNameBuffer;
            }

        //
        //  Otherwise if the tag index is for a global tag then we pull
        //  the name off of the global heap.  Provided the index is valid
        //  and the heap does have some tag entries
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            if ((TagIndex < RtlpGlobalTagHeap->NextAvailableTagIndex) &&
                (RtlpGlobalTagHeap->TagEntries != NULL)) {

                return RtlpGlobalTagHeap->TagEntries[ TagIndex ].TagName;
            }

        //
        //  Otherwise we'll pull the name off of the input heap
        //  provided the index is valid and the heap does have some
        //  tag entries
        //

        } else if ((TagIndex < Heap->NextAvailableTagIndex) &&
                   (Heap->TagEntries != NULL)) {

            return Heap->TagEntries[ TagIndex ].TagName;
        }
    }

    return NULL;
}


//
//  Declared in heappriv.h
//

USHORT
RtlpUpdateTagEntry (
    PHEAP Heap,
    USHORT TagIndex,
    SIZE_T OldSize,              // Only valid for ReAllocation and Free actions
    SIZE_T NewSize,              // Only valid for ReAllocation and Allocation actions
    HEAP_TAG_ACTION Action
    )

/*++

Routine Description:

    This routine is used to modify a tag entry

Arguments:

    Heap - Supplies a pointer to the heap being modified

    TagIndex - Supplies the tag being modified

    OldSize - Supplies the old allocation index of the block associated with the tag

    NewSize - Supplies the new allocation index of the block associated with the tag

    Action - Supplies the type of action being performed on the heap tag

Return Value:

    USHORT - Returns a tag index for the newly updated tag

--*/

{
    PHEAP_TAG_ENTRY TagEntry;

    //
    //  If the processes tag heap does not exist then we'll return a zero index
    //  right away
    //

    if (RtlpGlobalTagHeap == NULL) {

        return 0;
    }

    //
    //  If the action is greater than or equal to free action then it is
    //  either FreeAction, VirtualFreeAction, ReAllocationAction, or
    //  VirtualReAllocationAction.  Which means we already should have a tag
    //  that is simply being modified
    //

    if (Action >= FreeAction) {

        //
        //  If the tag index is zero then there is nothing for us to do
        //

        if (TagIndex == 0) {

            return 0;
        }

        //
        //  If this is a pseudo tag then make sure the rest of the tag index
        //  after we remove the psuedo bit is valid and that the heap is
        //  actually maintaining pseudo tags
        //

        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                TagIndex |= HEAP_PSEUDO_TAG_FLAG;

            } else {

                return 0;
            }

        //
        //  Otherwise if this is a global tag then make sure the tag index
        //  after we remove the global bit is valid and that the global tag
        //  heap has some tag entries
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            if ((TagIndex < RtlpGlobalTagHeap->NextAvailableTagIndex) &&
                (RtlpGlobalTagHeap->TagEntries != NULL)) {

                TagEntry = &RtlpGlobalTagHeap->TagEntries[ TagIndex ];

                TagIndex |= HEAP_GLOBAL_TAG;

            } else {

                return 0;
            }

        //
        //  Otherwise we have a regular tag index that we need to make sure
        //  is a valid value and that the heap has some tag entries
        //

        } else if ((TagIndex < Heap->NextAvailableTagIndex) &&
                   (Heap->TagEntries != NULL)) {

            TagEntry = &Heap->TagEntries[ TagIndex ];

        } else {

            return 0;
        }

        //
        //  At this point we have a tag entry and tag index.  Increment the
        //  number of frees we've done on the tag, and decrement the size by
        //  the number of bytes we've just freed
        //

        TagEntry->Frees += 1;

        TagEntry->Size -= OldSize;

        //
        //  Now if the action is either ReAllocationAction or
        //  VirtualReAllocationAction.  Then we get to add back in the
        //  new size and the allocation count
        //

        if (Action >= ReAllocationAction) {

            //
            //  If the this is a pseudo tag then we tag entry goes off the
            //  pseudo tag list
            //

            if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                TagIndex = (USHORT)(NewSize < HEAP_MAXIMUM_FREELISTS ?
                                        NewSize :
                                        (Action == VirtualReAllocationAction ? HEAP_MAXIMUM_FREELISTS : 0));

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                TagIndex |= HEAP_PSEUDO_TAG_FLAG;
            }

            TagEntry->Allocs += 1;

            TagEntry->Size += NewSize;
        }

    //
    //  The action is either AllocationAction or VirtualAllocationAction
    //

    } else {

        //
        //  Check if the supplied tag index is a regular tag and that it is
        //  valid for the tags in this heap
        //

        if ((TagIndex != 0) &&
            (TagIndex < Heap->NextAvailableTagIndex) &&
            (Heap->TagEntries != NULL)) {

            TagEntry = &Heap->TagEntries[ TagIndex ];

        //
        //  Otherwise if this is a global tag then make sure that it is a
        //  valid global index
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            Heap = RtlpGlobalTagHeap;

            if ((TagIndex < Heap->NextAvailableTagIndex) &&
                (Heap->TagEntries != NULL)) {

                TagEntry = &Heap->TagEntries[ TagIndex ];

                TagIndex |= HEAP_GLOBAL_TAG;

            } else {

                return 0;
            }

        //
        //  Otherwise if this is a pseudo tag then build a valid tag index
        //  based on the new size of the allocation
        //

        } else if (Heap->PseudoTagEntries != NULL) {

            TagIndex = (USHORT)(NewSize < HEAP_MAXIMUM_FREELISTS ?
                                    NewSize :
                                    (Action == VirtualAllocationAction ? HEAP_MAXIMUM_FREELISTS : 0));

            TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

            TagIndex |= HEAP_PSEUDO_TAG_FLAG;

        //
        //  Otherwise the user didn't call us with a valid tag
        //

        } else {

            return 0;
        }

        //
        //  At this point we have a valid tag entry and tag index, so
        //  update the tag entry state to reflect this new allocation
        //

        TagEntry->Allocs += 1;

        TagEntry->Size += NewSize;
    }

    //
    //  And return to our caller with the new tag index
    //

    return TagIndex;
}


//
//  Declared in heappriv.h
//

VOID
RtlpResetTags (
    PHEAP Heap
    )

/*++

Routine Description:

    This routine is used to reset all the tag entries in a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    None.

--*/

{
    PHEAP_TAG_ENTRY TagEntry;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    ULONG i;

    //
    //  We only have work to do if the heap has any allocated tag entries
    //

    TagEntry = Heap->TagEntries;

    if (TagEntry != NULL) {

        //
        //  For every tag entry in the heap we will zero out its counters
        //

        for (i=0; i<Heap->NextAvailableTagIndex; i++) {

            TagEntry->Allocs = 0;
            TagEntry->Frees = 0;
            TagEntry->Size = 0;

            //
            //  Advance to the next tag entry
            //

            TagEntry += 1;
        }
    }

    //
    //  We will only reset the pseudo tags if they exist
    //

    PseudoTagEntry = Heap->PseudoTagEntries;

    if (PseudoTagEntry != NULL) {

        //
        //  For every pseudo tag entry in the heap we will zero out its
        //  counters
        //

        for (i=0; i<HEAP_NUMBER_OF_PSEUDO_TAG; i++) {

            PseudoTagEntry->Allocs = 0;
            PseudoTagEntry->Frees = 0;
            PseudoTagEntry->Size = 0;

            //
            //  Advance to the next pseudo tag entry
            //

            PseudoTagEntry += 1;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

VOID
RtlpDestroyTags (
    PHEAP Heap
    )

/*++

Routine Description:

    This routine is used to completely remove all the normal tag entries
    in use by a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    SIZE_T RegionSize;

    //
    //  We will only do the action if the heap has some tag entries
    //

    if (Heap->TagEntries != NULL) {

        //
        //  Release all the memory used by the tag entries
        //

        RegionSize = 0;

        Status = RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                      &Heap->TagEntries,
                                      &RegionSize,
                                      MEM_RELEASE );

        if (NT_SUCCESS( Status )) {

            Heap->TagEntries = NULL;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

NTSTATUS
RtlpAllocateHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY *pp
    )

/*++

Routine Description:

    This routine is used to allocate an new heap usage entry
    from the internal heap usage buffer

Arguments:

    Buffer - Supplies a pointer to the internal heap usage
        buffer from which to allocate an entry

    pp - Receives a pointer to the newly allocated heap
        usage entry.  If pp is already pointing to an existing
        heap usage entry then on return we'll have this old
        entry point to the new entry, but still return the new
        entry.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PRTL_HEAP_USAGE_ENTRY p;
    PVOID CommitAddress;
    SIZE_T PageSize;

    //
    //  Check if the free list is empty and then we have to allocate more
    //  memory for the free list
    //

    if (Buffer->FreeList == NULL) {

        //
        //  We cannot grow the buffer any larger than the reserved size
        //

        if (Buffer->CommittedSize >= Buffer->ReservedSize) {

            return STATUS_NO_MEMORY;
        }

        //
        //  Try and add one page of committed memory to the buffer
        //  starting right after the currently committed space
        //

        PageSize = PAGE_SIZE;

        CommitAddress = (PCHAR)Buffer->Base + Buffer->CommittedSize;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &CommitAddress,
                                          0,
                                          &PageSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  Update the committed buffer size
        //

        Buffer->CommittedSize += PageSize;

        //
        //  Add the newly allocated space to the free list and
        //  build up the free list
        //

        Buffer->FreeList = CommitAddress;

        p = Buffer->FreeList;

        while (PageSize != 0) {

            p->Next = (p+1);
            p += 1;
            PageSize -= sizeof( *p );
        }

        //
        //  Null terminate the next pointer in the last free entry
        //

        p -= 1;
        p->Next = NULL;
    }

    //
    //  At this point the free list contains at least one entry
    //  so simply pop the entry.
    //

    p = Buffer->FreeList;

    Buffer->FreeList = p->Next;

    p->Next = NULL;

    //
    //  Now if the caller supplied an existing heap entry then
    //  we'll make the old heap entry point to this new entry
    //

    if (*pp) {

        (*pp)->Next = p;
    }

    //
    //  And then return the new entry to our caller
    //

    *pp = p;

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

PRTL_HEAP_USAGE_ENTRY
RtlpFreeHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY p
    )

/*++

Routine Description:

    This routine moves a heap usage entry from its current
    list onto the free list and returns a pointer to the
    next heap usage entry in the list.  It is like doing a pop
    of the list denoted by "p"

Arguments:

    Buffer - Supplies a pointer to the internal heap usage buffer
        being modified

    p - Supplies a pointer to the entry being moved.  Okay if
        it's null

Return Value:

    PRTL_HEAP_USAGE_ENTRY - Returns a pointer to the next heap usage
        entry

--*/

{
    PRTL_HEAP_USAGE_ENTRY pTmp;

    //
    //  Check if we have a non null heap entry and if so then add
    //  the entry to the front of the free list and return the next
    //  entry in the list
    //

    if (p != NULL) {

        pTmp = p->Next;

        p->Next = Buffer->FreeList;

        Buffer->FreeList = p;

    } else {

        pTmp = NULL;
    }

    return pTmp;
}


//
//  Declared in heap.h
//

BOOLEAN
RtlpHeapIsLocked (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to determine if a heap is locked

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

Return Value:

    BOOLEAN - TRUE if the heap is locked and FALSE otherwise

--*/

{
    PHEAP Heap;

    //
    //  Check if this is guard page version of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapIsLocked( HeapHandle ));

    Heap = (PHEAP)HeapHandle;

    //
    //  The heap is locked if there is a lock variable, and it has an
    //  owning thread or the lockcount is not -1
    //

    return (( Heap->LockVariable != NULL ) &&
            ( Heap->LockVariable->Lock.CriticalSection.OwningThread ||
              Heap->LockVariable->Lock.CriticalSection.LockCount != -1 ));
}

//
//  Low fragmentation heap activation routines
//

//
//  The flags that are not compatible with the low fragmentation heap
//

#define HEAP_LFH_RESTRICTION_FLAGS (HEAP_DEBUG_FLAGS           | \
                                    HEAP_NO_SERIALIZE          | \
                                    HEAP_SETTABLE_USER_FLAGS   | \
                                    HEAP_NEED_EXTRA_FLAGS      | \
                                    HEAP_CREATE_ALIGN_16       | \
                                    HEAP_FREE_CHECKING_ENABLED | \
                                    HEAP_TAIL_CHECKING_ENABLED)

NTSTATUS
RtlpActivateLowFragmentationHeap(
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine activates the low fragmentation heap for a given NT heap
    Note that the activation is not compatible with some heap flags, so the caller should 
    test the status

Arguments:

    HeapHandle - Supplies a pointer to the heap being activated with LFH

Return Value:

    An appropriate status

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID LowFragmentationHeap;
    PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);
    
    if ( RtlpLFHInitialized == 0 ) {

        //
        //  Acquire the process lock and check again if the
        //  LFH manager was initialized
        //

        RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

        if ( RtlpLFHInitialized == 0 ) {

            RtlpInitializeLowFragHeapManager();

            RtlpLFHInitialized = 1;
        }

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    try {
        
        if ( (Heap->Flags & HEAP_LFH_RESTRICTION_FLAGS)
                 ||
             !(Heap->Flags & HEAP_GROWABLE) ) {

            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        if (IS_HEAP_TAGGING_ENABLED()) {

            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        //
        //  Lock the front heap. We need to do this under the heap lock
        //  to prevent concurent access to these fields
        //
        
        RtlAcquireLockRoutine( Heap->LockVariable );

        LockAcquired = TRUE;

        //
        //  if we already have a low fragmentation heap created
        //  we're done
        //

        if (RtlpGetLowFragHeap(Heap)) {

            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        if (!RtlpIsFrontHeapUnlocked(Heap)) {

            //
            //  Someone locked the front end heap probable to create another LFH
            //  We need to fail the call.
            //
            
            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        RtlpLockFrontHeap(Heap);

        //
        //  capture the lookaside
        //

        Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);

        Heap->FrontEndHeap = NULL;
        Heap->FrontEndHeapType = 0;
        
        RtlReleaseLockRoutine( Heap->LockVariable );
        LockAcquired = FALSE;

        //
        //  If there is an active lookaside list then drain and remove it.
        //  By setting the lookaside field in the heap to null we guarantee
        //  that the call the free heap will not try and use the lookaside
        //  list logic.
        //
        //  We'll actually capture the lookaside pointer from the heap and
        //  only use the captured pointer.  This will take care of the
        //  condition where another walk or lock heap can cause us to check
        //  for a non null pointer and then have it become null when we read
        //  it again.  If it is non null to start with then even if the
        //  user walks or locks the heap via another thread the pointer to
        //  still valid here so we can still try and do a lookaside list pop.
        //

        if (Lookaside != NULL) {

            ULONG i;
            PVOID Block;


            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                    RtlFreeHeap( HeapHandle, 0, Block );
                }
            }
        }

        LowFragmentationHeap = RtlpCreateLowFragHeap(Heap);

        RtlAcquireLockRoutine( Heap->LockVariable );
        LockAcquired = TRUE;

        if (LowFragmentationHeap) {

            Heap->FrontEndHeap = LowFragmentationHeap;
            Heap->FrontEndHeapType = HEAP_FRONT_LOWFRAGHEAP;

            //
            //  Adjusts the block decommit threshold to 16K, to reduce 
            //  the fragmentation induced by often sub-segment frees
            //

            Heap->DeCommitFreeBlockThreshold = HEAP_LARGEST_LFH_BLOCK >> HEAP_GRANULARITY_SHIFT;
            
        } else {

            //
            //  we cannot create the LFH. so we need to restore the lookaside
            //  if it previously existed and set the right return status
            //

            if (Lookaside != NULL) {
                
                Heap->FrontEndHeap = Lookaside;
                Heap->FrontEndHeapType = HEAP_FRONT_LOOKASIDE;
            }
            
            Status = STATUS_NO_MEMORY;
        }
        
        RtlpUnlockFrontHeap(Heap);

        LockAcquired = FALSE;
        RtlReleaseLockRoutine( Heap->LockVariable );

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}

NTSTATUS
RtlSetHeapInformation (
    IN PVOID HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    IN PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL
    )

/*++

Routine Description:

    This is a general purpose routine that sets a custom information to a given heap.
    
Arguments:

    HeapHandle - Supplies a pointer to the heap that will receive the settings
    
    HeapInformationClass - The information class being set. It could be one of these values:
    
            HeapCompatibilityInformation - Will change the default front end heap to the 
                    low fragmentation heap
                    
    HeapInformation - The Information buffer
    
    HeapInformationLength - the length of the HeapInformation buffer
                        

Return Value:

    An appropriate status

--*/

{
    switch (HeapInformationClass) {
    case HeapCompatibilityInformation:

        if (HeapInformationLength < sizeof(ULONG)) {

            return STATUS_BUFFER_TOO_SMALL;

        } else {

            if ( (*(PULONG)HeapInformation) == HEAP_FRONT_LOWFRAGHEAP ) {

                return RtlpActivateLowFragmentationHeap( HeapHandle );

            } else {

                return STATUS_UNSUCCESSFUL;
            }
        }

        break;

    }
    return STATUS_SUCCESS;
}

NTSTATUS
RtlQueryHeapInformation (
    IN PVOID HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    OUT PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL,
    OUT PSIZE_T ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This is a general purpose routine that queries a custom information from a given heap.
    
Arguments:

    HeapHandle - Supplies a pointer to the heap to be queried
    
    HeapInformationClass - The information class required. It could be one of these values:
    
            HeapCompatibilityInformation - It will retrieve 
                0 : for pre NT4 SP3 compatibility mode
                1 : lookasides are enabled (NT4 SP3 or greater or W2k)
                2 : Low fragmentation heap enabled
                                
    HeapInformation - The buffer where the information will be filled in
    
    HeapInformationLength - the length of the HeapInformation buffer
    
    ReturnLength - The actual size of the buffer needed.

Return Value:

    An appropriate status

--*/

{
    switch (HeapInformationClass) {
    case HeapCompatibilityInformation:

        if (HeapInformationLength < sizeof(ULONG)) {

            if (ReturnLength) {

                *ReturnLength = sizeof(ULONG);

            }
            
            return STATUS_BUFFER_TOO_SMALL;

        } else {

            *(PULONG)HeapInformation = (ULONG)(((PHEAP)HeapHandle)->FrontEndHeapType);

            if (ReturnLength) {

                *ReturnLength = sizeof(ULONG);
            }
        }

        break;

    default:
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\handle.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module contains a simple handle allocator for use by the Local and
    Global memory allocators.

Author:

    Steve Wood (stevewo) 25-Jul-1991

Revision History:

--*/

#include "ntrtlp.h"

void
RtlInitializeHandleTable(
    IN ULONG MaximumNumberOfHandles,
    IN ULONG SizeOfHandleTableEntry,
    OUT PRTL_HANDLE_TABLE HandleTable
    )
{
    RtlZeroMemory( HandleTable, sizeof( *HandleTable ) );
    HandleTable->MaximumNumberOfHandles = MaximumNumberOfHandles;
    HandleTable->SizeOfHandleTableEntry = SizeOfHandleTableEntry;

    return;
}

NTSTATUS
RtlDestroyHandleTable(
    IN OUT PRTL_HANDLE_TABLE HandleTable
    )
{
    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T ReserveSize;

    BaseAddress = HandleTable->CommittedHandles;
    ReserveSize = (PUCHAR)(HandleTable->MaxReservedHandles) -
                  (PUCHAR)(HandleTable->CommittedHandles);

    Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                  &BaseAddress,
                                  &ReserveSize,
                                  MEM_RELEASE
                                );
    return Status;
}

PRTL_HANDLE_TABLE_ENTRY
RtlAllocateHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    OUT PULONG HandleIndex OPTIONAL
    )
{
    NTSTATUS Status;
    PVOID BaseAddress;
    ULONG n;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    PRTL_HANDLE_TABLE_ENTRY p, *pp;

    if (HandleTable->FreeHandles == NULL) {
        try {
            if (HandleTable->UnCommittedHandles == NULL) {
                ReserveSize = HandleTable->MaximumNumberOfHandles *
                              HandleTable->SizeOfHandleTableEntry;
                BaseAddress = NULL;
                Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                                  &BaseAddress,
                                                  0,
                                                  &ReserveSize,
                                                  MEM_RESERVE,
                                                  PAGE_READWRITE
                                                );

                if (NT_SUCCESS( Status )) {
                    HandleTable->CommittedHandles = (PRTL_HANDLE_TABLE_ENTRY)BaseAddress;
                    HandleTable->UnCommittedHandles = (PRTL_HANDLE_TABLE_ENTRY)BaseAddress;
                    HandleTable->MaxReservedHandles = (PRTL_HANDLE_TABLE_ENTRY)
                        ((PCHAR)BaseAddress + ReserveSize);
                    }
                }
            else {
                Status = STATUS_SUCCESS;
                }


            if (NT_SUCCESS( Status )) {
                p = HandleTable->UnCommittedHandles;
                if (p >= HandleTable->MaxReservedHandles) {
                    Status = STATUS_NO_MEMORY;
                    }
                else {
                    CommitSize = PAGE_SIZE;
                    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                                      (PVOID *)&p,
                                                      0,
                                                      &CommitSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE
                                                    );
                    if (NT_SUCCESS( Status )) {
                        HandleTable->UnCommittedHandles = (PRTL_HANDLE_TABLE_ENTRY)
                                ((PCH)p + CommitSize);
                        }
                    }
                }

            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
            }

        if (!NT_SUCCESS( Status )) {
            return NULL;
            }

        pp = &HandleTable->FreeHandles;
        while (p < HandleTable->UnCommittedHandles) {
            *pp = p;
            pp = &p->NextFree;
            p = (PRTL_HANDLE_TABLE_ENTRY)((PUCHAR)p + HandleTable->SizeOfHandleTableEntry);
            }
        }

    //
    // Remove handle table entry from head of free list.
    //

    p = HandleTable->FreeHandles;
    HandleTable->FreeHandles = p->NextFree;

    //
    // Clear free list link field, which also leaves the handle allocated bit
    // clear.  This allows the caller to mark it is allocated after they are
    // done filling in their portion.
    //

    p->NextFree = NULL;


    //
    // If requested, return the index of this handle table entry
    //
    if (ARGUMENT_PRESENT( HandleIndex )) {
        *HandleIndex = (ULONG) (((PCHAR)p - (PCHAR)HandleTable->CommittedHandles) / 
                                HandleTable->SizeOfHandleTableEntry);
        }

    //
    // Return a pointer to the handle table entry.
    //

    return p;
}


BOOLEAN
RtlFreeHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN PRTL_HANDLE_TABLE_ENTRY Handle
    )
{
#if DBG
    if (!RtlIsValidHandle( HandleTable, Handle )) {
        DbgPrint( "RTL: RtlFreeHandle( %lx ) - invalid handle\n", Handle );
        if (NtCurrentPeb()->BeingDebugged) {
            DbgBreakPoint();
            }
        return FALSE;
        }
#endif

    RtlZeroMemory( Handle, HandleTable->SizeOfHandleTableEntry );
    Handle->NextFree = HandleTable->FreeHandles;
    HandleTable->FreeHandles = Handle;
    return TRUE;
}



BOOLEAN
RtlIsValidHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN PRTL_HANDLE_TABLE_ENTRY Handle
    )
{
    if (Handle == NULL ||
        Handle < HandleTable->CommittedHandles ||
        Handle >= HandleTable->UnCommittedHandles ||
        (ULONG_PTR)Handle & (HandleTable->SizeOfHandleTableEntry - 1) ||
        !(Handle->Flags & RTL_HANDLE_ALLOCATED)
       ) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}


BOOLEAN
RtlIsValidIndexHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN ULONG HandleIndex,
    OUT PRTL_HANDLE_TABLE_ENTRY *Handle
    )
{
    PRTL_HANDLE_TABLE_ENTRY p;

    p = (PRTL_HANDLE_TABLE_ENTRY)
        ((PCHAR)HandleTable->CommittedHandles + (HandleIndex * HandleTable->SizeOfHandleTableEntry));

    if (RtlIsValidHandle( HandleTable, p )) {
        *Handle = p;
        return TRUE;
        }
    else {
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This module implements a heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1989 (Adapted from URTL\alloc.c)

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"
#include "NtdllTrc.h"
#include "wmiumkm.h"


#ifdef NTHEAP_ENABLED
#include "heapp.h"
#endif // NTHEAP_ENABLED

#ifndef NTOS_KERNEL_RUNTIME
ULONG RtlpDisableHeapLookaside = 0;
LONG RtlpSequenceNumberTest = 1024;
LONG RtlpLargeListDepthLimit = 128;

#define HEAP_ACTIVATE_CACHE_THRESHOLD 256

#define HEAP_COMPAT_DISABLE_LOOKASIDES 1
#define HEAP_COMPAT_DISABLE_LARGECACHE 2

#endif

#define HEAP_REUSAGE_FACTOR 4

#if defined(_WIN64)

//
// Win64 heaps require an initial commit size of at least 8192.  Note that
// this is NOT necessarily the size of a page.
//

#define MINIMUM_HEAP_COMMIT 8192

#else

#define MINIMUM_HEAP_COMMIT 4096

#endif

C_ASSERT((MINIMUM_HEAP_COMMIT % PAGE_SIZE) == 0);

//
//  If any of these flags are set, the fast allocator punts
//  to the slow do-everything allocator.
//

#define HEAP_SLOW_FLAGS (HEAP_DEBUG_FLAGS           | \
                         HEAP_SETTABLE_USER_FLAGS   | \
                         HEAP_NEED_EXTRA_FLAGS      | \
                         HEAP_CREATE_ALIGN_16       | \
                         HEAP_FREE_CHECKING_ENABLED | \
                         HEAP_TAIL_CHECKING_ENABLED)

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif
const UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ] = {
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
#ifdef _WIN64
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
#endif
    CHECK_HEAP_TAIL_FILL
};


//
//  These are procedure prototypes exported by heapdbg.c
//

#ifndef NTOS_KERNEL_RUNTIME

PVOID
RtlDebugCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    );

BOOLEAN
RtlDebugDestroyHeap (
    IN PVOID HeapHandle
    );

PVOID
RtlDebugAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,            
    IN SIZE_T Size
    );

BOOLEAN
RtlDebugFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

ULONG
RtlDebugSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSTATUS
RtlDebugZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

SIZE_T
GetUCBytes (
    IN PHEAP Heap, 
    IN OUT SIZE_T *ReservedSpace, 
    IN OUT PULONG NoOfUCRs
    );

#endif // NTOS_KERNEL_RUNTIME


//
//  Local procedure prototypes
//

PHEAP_UNCOMMMTTED_RANGE
RtlpCreateUnCommittedRange (
    IN PHEAP_SEGMENT Segment
    );

VOID
RtlpDestroyUnCommittedRange (
    IN PHEAP_SEGMENT Segment,
    IN PHEAP_UNCOMMMTTED_RANGE UnCommittedRange
    );

VOID
RtlpInsertUnCommittedPages (
    IN PHEAP_SEGMENT Segment,
    IN ULONG_PTR Address,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDestroyHeapSegment (
    IN PHEAP_SEGMENT Segment
    );

PHEAP_FREE_ENTRY
RtlpExtendHeap (
    IN PHEAP Heap,
    IN SIZE_T AllocationSize
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

#pragma alloc_text(PAGE, RtlCreateHeap)
#pragma alloc_text(PAGE, RtlDestroyHeap)
#pragma alloc_text(PAGE, RtlAllocateHeap)
#pragma alloc_text(PAGE, RtlAllocateHeapSlowly)
#pragma alloc_text(PAGE, RtlFreeHeapSlowly)
#pragma alloc_text(PAGE, RtlFreeHeap)
#pragma alloc_text(PAGE, RtlSizeHeap)
#pragma alloc_text(PAGE, RtlZeroHeap)

#pragma alloc_text(PAGE, RtlpGetExtraStuffPointer)
#pragma alloc_text(PAGE, RtlpCreateUnCommittedRange)
#pragma alloc_text(PAGE, RtlpDestroyUnCommittedRange)
#pragma alloc_text(PAGE, RtlpInsertUnCommittedPages)
#pragma alloc_text(PAGE, RtlpDestroyHeapSegment)
#pragma alloc_text(PAGE, RtlpExtendHeap)

#pragma alloc_text(PAGE, RtlpFindAndCommitPages)
#pragma alloc_text(PAGE, RtlpInitializeHeapSegment)
#pragma alloc_text(PAGE, RtlpCoalesceFreeBlocks)
#pragma alloc_text(PAGE, RtlpDeCommitFreeBlock)
#pragma alloc_text(PAGE, RtlpInsertFreeBlock)
#pragma alloc_text(PAGE, RtlpGetSizeOfBigBlock)
#pragma alloc_text(PAGE, RtlpCheckBusyBlockTail)

#endif // ALLOC_PRAGMA


PVOID
RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a heap.

Arguments:

    Flags - Specifies optional attributes of the heap.

        Valid Flags Values:

        HEAP_NO_SERIALIZE - if set, then allocations and deallocations on
                         this heap are NOT synchronized by these routines.

        HEAP_GROWABLE - if set, then the heap is a "sparse" heap where
                        memory is committed only as necessary instead of
                        being preallocated.

    HeapBase - if not NULL, this specifies the base address for memory
        to use as the heap.  If NULL, memory is allocated by these routines.

    ReserveSize - if not zero, this specifies the amount of virtual address
        space to reserve for the heap.

    CommitSize - if not zero, this specifies the amount of virtual address
        space to commit for the heap.  Must be less than ReserveSize.  If
        zero, then defaults to one page.

    Lock - if not NULL, this parameter points to the resource lock to
        use.  Only valid if HEAP_NO_SERIALIZE is NOT set.

    Parameters - optional heap parameters.

Return Value:

    PVOID - a pointer to be used in accessing the created heap.

--*/

{
    ULONG_PTR HighestUserAddress;
    NTSTATUS Status;
    PHEAP Heap = NULL;
    PHEAP_SEGMENT Segment = NULL;
    PLIST_ENTRY FreeListHead;
    ULONG SizeOfHeapHeader;
    ULONG SegmentFlags;
    PVOID CommittedBase;
    PVOID UnCommittedBase;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    SYSTEM_BASIC_INFORMATION SystemInformation;
    ULONG n;
    ULONG InitialCountOfUnusedUnCommittedRanges;
    SIZE_T MaximumHeapBlockSize;
    PVOID NextHeapHeaderAddress;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    RTL_HEAP_PARAMETERS TempParameters;
    ULONG NtGlobalFlag = RtlGetNtGlobalFlags();

#ifndef NTOS_KERNEL_RUNTIME

    PPEB Peb;

#else // NTOS_KERNEL_RUNTIME

    extern SIZE_T MmHeapSegmentReserve;
    extern SIZE_T MmHeapSegmentCommit;
    extern SIZE_T MmHeapDeCommitTotalFreeThreshold;
    extern SIZE_T MmHeapDeCommitFreeBlockThreshold;

#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Flags & NTHEAP_ENABLED_FLAG) {

            Heap = RtlCreateNtHeap( Flags, NULL );

            if (Heap != NULL) {

                return Heap;
            }

            Flags &= ~NTHEAP_ENABLED_FLAG;
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if we should be using the page heap code.  If not then turn
    //  off any of the page heap flags before going on
    //

#ifdef DEBUG_PAGE_HEAP

    if ( RtlpDebugPageHeap && ( HeapBase == NULL ) && ( Lock == NULL )) {

        PVOID PageHeap;

        PageHeap = RtlpDebugPageHeapCreate(

            Flags,
            HeapBase,
            ReserveSize,
            CommitSize,
            Lock,
            Parameters );

        if (PageHeap != NULL) {
            return PageHeap;
        }

        //
        // A `-1' value signals a recursive call from page heap
        // manager. We set this to null and continue creating
        // a normal heap. This small hack is required so that we
        // minimize the dependencies between the normal and the page
        // heap manager.
        //

        if ((SIZE_T)Parameters == (SIZE_T)-1) {

            Parameters = NULL;
        }
    }

    Flags &= ~( HEAP_PROTECTION_ENABLED |
        HEAP_BREAK_WHEN_OUT_OF_VM |
        HEAP_NO_ALIGNMENT );

#endif // DEBUG_PAGE_HEAP

    //
    //  If the caller does not want to skip heap validiation checks then we
    //  need to validate the rest of the flags but simply masking out only
    //  those flags that want on a create heap call
    //

    if (!(Flags & HEAP_SKIP_VALIDATION_CHECKS)) {

        if (Flags & ~HEAP_CREATE_VALID_MASK) {

            HeapDebugPrint(( "Invalid flags (%08x) specified to RtlCreateHeap\n", Flags ));
            HeapDebugBreak( NULL );

            Flags &= HEAP_CREATE_VALID_MASK;
        }
    }

    //
    //  The maximum heap block size is really 0x7f000 which is 0x80000 minus a
    //  page.  Maximum block size is 0xfe00 and granularity shift is 3.
    //

    MaximumHeapBlockSize = HEAP_MAXIMUM_BLOCK_SIZE << HEAP_GRANULARITY_SHIFT;

    //
    //  Assume we're going to be successful until we're shown otherwise
    //

    Status = STATUS_SUCCESS;

    //
    //  This part of the routine builds up local variable containing all the
    //  parameters used to initialize the heap.  First thing we do is zero
    //  it out.
    //

    RtlZeroMemory( &TempParameters, sizeof( TempParameters ) );

    //
    //  If our caller supplied the optional heap parameters then we'll
    //  make sure the size is good and copy over them over to our
    //  local copy
    //

    if (ARGUMENT_PRESENT( Parameters )) {

        try {

            if (Parameters->Length == sizeof( *Parameters )) {

                RtlCopyMemory( &TempParameters, Parameters, sizeof( *Parameters ) );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }
    }

    //
    //  Set the parameter block to the local copy
    //

    Parameters = &TempParameters;

    //
    //  If nt global flags tells us to always do tail or free checking
    //  or to disable coalescing then force those bits set in the user
    //  specified flags
    //

    if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {

        Flags |= HEAP_TAIL_CHECKING_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {

        Flags |= HEAP_FREE_CHECKING_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {

        Flags |= HEAP_DISABLE_COALESCE_ON_FREE;
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we also check if we should
    //  validate parameters, validate all, or do stack backtraces
    //

    Peb = NtCurrentPeb();

    if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {

        Flags |= HEAP_VALIDATE_PARAMETERS_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {

        Flags |= HEAP_VALIDATE_ALL_ENABLED;
    }

    if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {

        Flags |= HEAP_CAPTURE_STACK_BACKTRACES;
    }

    //
    //  Also in the non kernel case the PEB will have some state
    //  variables that we need to set if the user hasn't specified
    //  otherwise
    //

    if (Parameters->SegmentReserve == 0) {

        Parameters->SegmentReserve = Peb->HeapSegmentReserve;
    }

    if (Parameters->SegmentCommit == 0) {

        Parameters->SegmentCommit = Peb->HeapSegmentCommit;
    }

    if (Parameters->DeCommitFreeBlockThreshold == 0) {

        Parameters->DeCommitFreeBlockThreshold = Peb->HeapDeCommitFreeBlockThreshold;
    }

    if (Parameters->DeCommitTotalFreeThreshold == 0) {

        Parameters->DeCommitTotalFreeThreshold = Peb->HeapDeCommitTotalFreeThreshold;
    }
#else // NTOS_KERNEL_RUNTIME

    //
    //  In the kernel case Mm has some global variables that we set
    //  into the paramters if the user hasn't specified otherwise
    //

    if (Parameters->SegmentReserve == 0) {

        Parameters->SegmentReserve = MmHeapSegmentReserve;
    }

    if (Parameters->SegmentCommit == 0) {

        Parameters->SegmentCommit = MmHeapSegmentCommit;
    }

    if (Parameters->DeCommitFreeBlockThreshold == 0) {

        Parameters->DeCommitFreeBlockThreshold = MmHeapDeCommitFreeBlockThreshold;
    }

    if (Parameters->DeCommitTotalFreeThreshold == 0) {

        Parameters->DeCommitTotalFreeThreshold = MmHeapDeCommitTotalFreeThreshold;
    }
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Get the highest user address
    //

    if (!NT_SUCCESS(ZwQuerySystemInformation(SystemBasicInformation,
                                             &SystemInformation,
                                             sizeof(SystemInformation),
                                             NULL))) {
        return NULL;
    }
    HighestUserAddress = SystemInformation.MaximumUserModeAddress;

    //
    //  If the user hasn't said what the largest allocation size is then
    //  we should compute it as the difference between the highest and lowest
    //  address less one page
    //

    if (Parameters->MaximumAllocationSize == 0) {

        Parameters->MaximumAllocationSize = (HighestUserAddress -
                                             (ULONG_PTR)MM_LOWEST_USER_ADDRESS -
                                             PAGE_SIZE );
    }

    //
    //  Set the virtual memory threshold to be non zero and not more than the
    //  maximum heap block size of 0x7f000.  If the user specified one that is
    //  too large we automatically and silently drop it down.
    //

    if ((Parameters->VirtualMemoryThreshold == 0) ||
        (Parameters->VirtualMemoryThreshold > MaximumHeapBlockSize)) {

        Parameters->VirtualMemoryThreshold = MaximumHeapBlockSize;
    }

    //
    //  The default commit size is MINIMUM_HEAP_COMMIT and the default
    //  reserve size is 64 pages.
    //

    if (!ARGUMENT_PRESENT( CommitSize )) {

        CommitSize = MINIMUM_HEAP_COMMIT;

        if (!ARGUMENT_PRESENT( ReserveSize )) {

            ReserveSize = 64 * CommitSize;

        } else {

            ReserveSize = ROUND_UP_TO_POWER2( ReserveSize,
                                              MINIMUM_HEAP_COMMIT );
        }

    } else {

        //
        //  The heap actually uses space that is reserved and commited
        //  to store internal data structures (the LOCK,
        //  the HEAP_PSEUDO_TAG, etc.). These structures can be larger than
        //  4K especially on a 64-bit build. So, make sure the commit
        //  is at least 8K in length.
        //

        CommitSize = ROUND_UP_TO_POWER2(CommitSize, MINIMUM_HEAP_COMMIT);

        if (!ARGUMENT_PRESENT( ReserveSize )) {

            ReserveSize = ROUND_UP_TO_POWER2( CommitSize, 16 * PAGE_SIZE );

        } else {

            ReserveSize = ROUND_UP_TO_POWER2( ReserveSize,
                                              MINIMUM_HEAP_COMMIT );

            //
            //  If the CommitSize is larger than the ReservedSize, adjust 
            //  it to the ReserveSize. Reserved size is already rounded up to
            //  MINIMUM_HEAP_COMMIT.
            //

            if ( CommitSize > ReserveSize ) {

                CommitSize = ReserveSize;
            }
        }
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if we are creating a debug heap
    //  the test checks that skip validation checks is false.
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCreateHeap( Flags,
                                   HeapBase,
                                   ReserveSize,
                                   CommitSize,
                                   Lock,
                                   Parameters );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Compute the size of the heap which will be the
    //  heap struct itself and if we are to serialize with
    //  out own lock then add room for the lock.  If the
    //  user did not supply the lock then set the lock
    //  variable to -1.
    //

    SizeOfHeapHeader = sizeof( HEAP );

    if (!(Flags & HEAP_NO_SERIALIZE)) {

        if (ARGUMENT_PRESENT( Lock )) {

            Flags |= HEAP_LOCK_USER_ALLOCATED;

        } else {

            SizeOfHeapHeader += sizeof( HEAP_LOCK );
            Lock = (PHEAP_LOCK)-1;
        }

    } else if (ARGUMENT_PRESENT( Lock )) {

        //
        //  In this error case the call said not to serialize but also fed us
        //  a lock
        //

        return NULL;
    }

    //
    //  See if caller allocate the space for the heap.
    //

    if (ARGUMENT_PRESENT( HeapBase )) {

        //
        //  The call specified a heap base now check if there is
        //  a caller supplied commit routine
        //

        if (Parameters->CommitRoutine != NULL) {

            //
            //  The caller specified a commit routine so the caller
            //  also needs to have given us certain parameters and make
            //  sure the heap is not growable.  Otherwise it is an error
            //

            if ((Parameters->InitialCommit == 0) ||
                (Parameters->InitialReserve == 0) ||
                (Parameters->InitialCommit > Parameters->InitialReserve) ||
                (Flags & HEAP_GROWABLE)) {

                return NULL;
            }

            //
            //  Set the commited base and the uncommited base to the
            //  proper pointers within the heap.
            //

            CommittedBase = HeapBase;
            UnCommittedBase = (PCHAR)CommittedBase + Parameters->InitialCommit;
            ReserveSize = Parameters->InitialReserve;

            //
            //  Zero out a page of the heap where our first part goes
            //

            RtlZeroMemory( CommittedBase, Parameters->InitialCommit );

        } else {

            //
            //  The user gave us space but not commit routine
            //  So query the base to get its size
            //

            Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                           HeapBase,
                                           MemoryBasicInformation,
                                           &MemoryInformation,
                                           sizeof( MemoryInformation ),
                                           NULL );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  Make sure the user gave us a base address for this block
            //  and that the memory is not free
            //

            if (MemoryInformation.BaseAddress != HeapBase) {

                return NULL;
            }

            if (MemoryInformation.State == MEM_FREE) {

                return NULL;
            }

            //
            //  Set our commit base to the start of the range
            //

            CommittedBase = MemoryInformation.BaseAddress;

            //
            //  If the memory is committed then
            //  we can zero out a page worth
            //

            if (MemoryInformation.State == MEM_COMMIT) {

                RtlZeroMemory( CommittedBase, PAGE_SIZE );

                //
                //  Set the commit size and uncommitted base according
                //  to the start of the vm
                //

                CommitSize = MemoryInformation.RegionSize;
                UnCommittedBase = (PCHAR)CommittedBase + CommitSize;

                //
                //  Find out the uncommited base is reserved and if so
                //  the update the reserve size accordingly.
                //

                Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                               UnCommittedBase,
                                               MemoryBasicInformation,
                                               &MemoryInformation,
                                               sizeof( MemoryInformation ),
                                               NULL );

                ReserveSize = CommitSize;

                if ((NT_SUCCESS( Status )) &&
                    (MemoryInformation.State == MEM_RESERVE)) {

                    ReserveSize += MemoryInformation.RegionSize;
                }

            } else {

                //
                //  The memory the user gave us is not committed so dummy
                //  up these small numbers
                //

                CommitSize = MINIMUM_HEAP_COMMIT;
                UnCommittedBase = CommittedBase;
            }
        }

        //
        //  This user gave us a base and we've just taken care of the committed
        //  bookkeeping.  So mark this segment as user supplied and set the
        //  heap
        //

        SegmentFlags = HEAP_SEGMENT_USER_ALLOCATED;
        Heap = (PHEAP)HeapBase;

    } else {

        //
        //  The user did not specify a heap base so we have to allocate the
        //  vm here.  First make sure the user did not give us a commit routine
        //

        if (Parameters->CommitRoutine != NULL) {

            return NULL;
        }

        //
        //  Reserve the amount of virtual address space requested.
        //

        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&Heap,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        //
        //  Indicate that this segment is not user supplied
        //

        SegmentFlags = 0;

        //
        //  Set the default commit size to one page
        //

        if (!ARGUMENT_PRESENT( CommitSize )) {

            CommitSize = MINIMUM_HEAP_COMMIT;
        }

        //
        //  Set the committed and uncommitted base to be the same the following
        //  code will actually commit the page for us
        //

        CommittedBase = Heap;
        UnCommittedBase = Heap;
    }

    //
    //  At this point we have a heap pointer, committed base, uncommitted base,
    //  segment flags, commit size, and reserve size.  If the committed and
    //  uncommited base are the same then we need to commit the amount
    //  specified by the commit size
    //

    if (CommittedBase == UnCommittedBase) {

        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&CommittedBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        //
        //  In the non successful case we need to back out any vm reservation
        //  we did earlier
        //

        if (!NT_SUCCESS( Status )) {

            if (!ARGUMENT_PRESENT(HeapBase)) {

                //
                //  Return the reserved virtual address space.
                //

                RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                           (PVOID *)&Heap,
                                           &ReserveSize,
                                           MEM_RELEASE );

            }

            return NULL;
        }

        //
        //  The new uncommitted base is not adjusted above what we just
        //  committed
        //

        UnCommittedBase = (PVOID)((PCHAR)UnCommittedBase + CommitSize);
    }

    //
    //  At this point we have memory for the start of the heap committed and
    //  ready to be initialized.  So now we need initialize the heap
    //

    //
    //  Calculate the end of the heap header and make room for 8 uncommitted
    //  range structures.  Once we have the room for them then chain them
    //  together and null terminate the chain
    //

    NextHeapHeaderAddress = Heap + 1;

    UnCommittedRange = (PHEAP_UNCOMMMTTED_RANGE)ROUND_UP_TO_POWER2( NextHeapHeaderAddress,
                                                                    sizeof( QUAD ) );

    InitialCountOfUnusedUnCommittedRanges = 8;

    SizeOfHeapHeader += InitialCountOfUnusedUnCommittedRanges * sizeof( *UnCommittedRange );

    //
    //  What a hack Pp is really a pointer to the next field of the
    //  uncommitted range structure.  So we set next by setting through Pp
    //

    pp = &Heap->UnusedUnCommittedRanges;

    while (InitialCountOfUnusedUnCommittedRanges--) {

        *pp = UnCommittedRange;
        pp = &UnCommittedRange->Next;
        UnCommittedRange += 1;
    }

    NextHeapHeaderAddress = UnCommittedRange;

    *pp = NULL;

    //
    //  Check if tagging is enabled in global flags.  This check is always true
    //  in a debug build.
    //
    //  If tagging is enabled then make room for 129 pseudo tag heap entry.
    //  Which is one more than the number of free lists.  Also point the heap
    //  header to this array of pseudo tags entries.
    //

    if (IS_HEAP_TAGGING_ENABLED()) {

        Heap->PseudoTagEntries = (PHEAP_PSEUDO_TAG_ENTRY)ROUND_UP_TO_POWER2( NextHeapHeaderAddress,
                                                                             sizeof( QUAD ) );

        SizeOfHeapHeader += HEAP_NUMBER_OF_PSEUDO_TAG * sizeof( HEAP_PSEUDO_TAG_ENTRY );

        //
        //  Update the next address with the number of pseudotags
        //  (The math is right here because  Heap->PseudoTagEntries is of
        //  type PHEAP_PSEUDO_TAG_ENTRY)
        //

        NextHeapHeaderAddress = Heap->PseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
    }

    //
    //  Round the size of the heap header to the next 8 byte boundary
    //

    SizeOfHeapHeader = (ULONG) ROUND_UP_TO_POWER2( SizeOfHeapHeader,
                                                   HEAP_GRANULARITY );

    //
    //  If the sizeof the heap header is larger than the native
    //  page size, you have a problem. Further, if the CommitSize passed
    //  in was smaller than the SizeOfHeapHeader, you may not even make it
    //  this far before death...
    //
    //  HeapDbgPrint() doesn't work for IA64 yet.
    //
    //  HeapDbgPrint(("Size of the heap header is %u bytes, commit was %u bytes\n", SizeOfHeapHeader, (ULONG) CommitSize));
    //

    //
    //  Fill in the heap header fields
    //

    Heap->Entry.Size = (USHORT)(SizeOfHeapHeader >> HEAP_GRANULARITY_SHIFT);
    Heap->Entry.Flags = HEAP_ENTRY_BUSY;

    Heap->Signature = HEAP_SIGNATURE;
    Heap->Flags = Flags;
    Heap->ForceFlags = (Flags & (HEAP_NO_SERIALIZE |
                                 HEAP_GENERATE_EXCEPTIONS |
                                 HEAP_ZERO_MEMORY |
                                 HEAP_REALLOC_IN_PLACE_ONLY |
                                 HEAP_VALIDATE_PARAMETERS_ENABLED |
                                 HEAP_VALIDATE_ALL_ENABLED |
                                 HEAP_TAIL_CHECKING_ENABLED |
                                 HEAP_CREATE_ALIGN_16 |
                                 HEAP_FREE_CHECKING_ENABLED));

//    Heap->FreeListsInUseTerminate = 0xFFFF;
    Heap->u2.DecommitCount = 0;
    Heap->HeaderValidateLength = (USHORT)((PCHAR)NextHeapHeaderAddress - (PCHAR)Heap);
    Heap->HeaderValidateCopy = NULL;

    //
    //  Initialize the free list to be all empty
    //

    FreeListHead = &Heap->FreeLists[ 0 ];
    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        InitializeListHead( FreeListHead );
        FreeListHead++;
    }

    //
    //  Make it so that there a no big block allocations
    //

    InitializeListHead( &Heap->VirtualAllocdBlocks );

    //
    //  Initialize the critical section that controls access to
    //  the free list.  If the lock variable is -1 then the caller
    //  did not supply a lock so we need to make room for one
    //  and initialize it.
    //

    if (Lock == (PHEAP_LOCK)-1) {

        Lock = (PHEAP_LOCK)NextHeapHeaderAddress;

        Status = RtlInitializeLockRoutine( Lock );

        if (!NT_SUCCESS( Status )) {

            if (!ARGUMENT_PRESENT(HeapBase)) {
                
                RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                           (PVOID *)&Heap,
                                           &ReserveSize,
                                           MEM_RELEASE );
            }
            
            return NULL;
        }

        NextHeapHeaderAddress = (PHEAP_LOCK)Lock + 1;
    }

    Heap->LockVariable = Lock;
    Heap->LastSegmentIndex = 0;

    //
    //  Initialize the first segment for the heap
    //

    if (!RtlpInitializeHeapSegment( Heap,
                                    (PHEAP_SEGMENT)((PCHAR)Heap + SizeOfHeapHeader),
                                    0,
                                    SegmentFlags,
                                    CommittedBase,
                                    UnCommittedBase,
                                    (PCHAR)CommittedBase + ReserveSize )) {

        if (!ARGUMENT_PRESENT(HeapBase)) {
            
            RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                       (PVOID *)&Heap,
                                       &ReserveSize,
                                       MEM_RELEASE );
        }
        
        return NULL;
    }

    //
    //  Fill in additional heap entry fields
    //

    Heap->ProcessHeapsListIndex = 0;
    Heap->SegmentReserve = Parameters->SegmentReserve;
    Heap->SegmentCommit = Parameters->SegmentCommit;
    Heap->DeCommitFreeBlockThreshold = Parameters->DeCommitFreeBlockThreshold >> HEAP_GRANULARITY_SHIFT;
    Heap->DeCommitTotalFreeThreshold = Parameters->DeCommitTotalFreeThreshold >> HEAP_GRANULARITY_SHIFT;
    Heap->MaximumAllocationSize = Parameters->MaximumAllocationSize;

    Heap->VirtualMemoryThreshold = (ULONG) (ROUND_UP_TO_POWER2( Parameters->VirtualMemoryThreshold,
                                                       HEAP_GRANULARITY ) >> HEAP_GRANULARITY_SHIFT);

    Heap->CommitRoutine = Parameters->CommitRoutine;

    //
    //  We either align the heap at 16 or 8 byte boundaries.  The AlignRound
    //  and AlignMask are used to bring allocation sizes up to the next
    //  boundary.  The align round includes the heap header and the optional
    //  check tail size
    //

    if (Flags & HEAP_CREATE_ALIGN_16) {

        Heap->AlignRound = 15 + sizeof( HEAP_ENTRY );
        Heap->AlignMask = ~((ULONG_PTR)15);

    } else {

        Heap->AlignRound = HEAP_GRANULARITY - 1 + sizeof( HEAP_ENTRY );
        Heap->AlignMask = ~((ULONG_PTR)HEAP_GRANULARITY - 1);
    }

    if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

        Heap->AlignRound += CHECK_HEAP_TAIL_SIZE;
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we need to add this heap to the processes heap
    //  list
    //

    RtlpAddHeapToProcessList( Heap );

    //
    //  Initialize the heap lookaside lists.  This is only for the user mode
    //  heap and the heap contains a pointer to the lookaside list array.
    //  The array is sized the same as the dedicated free list.  First we
    //  allocate space for the lookaside list and then we initialize each
    //  lookaside list.
    //
    //  But the caller asked for no serialize or asked for non growable
    //  heap then we won't enable the lookaside lists.
    //

    Heap->FrontEndHeap = NULL;
    Heap->FrontHeapLockCount = 0;
    Heap->FrontEndHeapType = 0;

    if ((!(Flags & HEAP_NO_SERIALIZE)) &&
        ( (Flags & HEAP_GROWABLE)) &&
        (!(RtlpDisableHeapLookaside & HEAP_COMPAT_DISABLE_LOOKASIDES))) {

        //
        //  We do not allow creation of the cache heap if the tags are enabled.
        //  We use the tag field to sign our private blocks
        //

        if (RtlpIsLowFragHeapEnabled() &&
            !IS_HEAP_TAGGING_ENABLED()) {

            RtlpActivateLowFragmentationHeap(Heap);

        } else {

            ULONG i;

            Heap->FrontEndHeap = RtlAllocateHeap( Heap,
                                               HEAP_ZERO_MEMORY,
                                               sizeof(HEAP_LOOKASIDE) * HEAP_MAXIMUM_FREELISTS );

            if (Heap->FrontEndHeap != NULL) {

                Heap->FrontEndHeapType = HEAP_FRONT_LOOKASIDE;

                for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                    //  
                    //  N.B. we should call here the function: 
                    //
                    //  RtlpInitializeHeapLookaside( &(((PHEAP_LOOKASIDE)(Heap->Lookaside))[i]), 32 );
                    //
                    //  But for performance reasons, because the most fields are 0,
                    //  we've set the flag HEAP_ZERO_MEMORY in allocation above and we'll
                    //  initialize the only two NON-NULL fields: Depth and MaximumDepth
                    //  IceCap data showed that RtlHeapCreate spends ~30% of the time within
                    //  these calls.
                    //
                    //  N.B. This works based on assumption that 
                    //  RtlInitializeSListHead zeroed the SLIST_HEADER structure
                    //

                    PHEAP_LOOKASIDE HeapLookaside = &(((PHEAP_LOOKASIDE)(Heap->FrontEndHeap))[i]);

                    HeapLookaside->Depth = MINIMUM_LOOKASIDE_DEPTH;
                    HeapLookaside->MaximumDepth = 256; //Depth;
                }
            }
        }
    }

    if( IsHeapLogging( Heap )) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;

        USHORT ReqSize = sizeof(HEAP_EVENT_CREATE) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PHEAP_EVENT_CREATE pHeapEvent = (PHEAP_EVENT_CREATE)((SIZE_T)pEventHeader
                                            +(SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_CREATE;

            pHeapEvent->HeapHandle	= (PVOID)Heap;
            pHeapEvent->Flags       = Flags;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 

#endif // NTOS_KERNEL_RUNTIME

    //
    //  And return the fully initialized heap to our caller
    //

    return (PVOID)Heap;
}


PVOID
RtlDestroyHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is the opposite of Rtl Create Heap.  It tears down an
    existing heap structure.

Arguments:

    HeapHandle - Supplies a pointer to the heap being destroyed

Return Value:

    PVOID - Returns null if the heap was destroyed completely and a
        pointer back to the heap if for some reason the heap could
        not be destroyed.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    PHEAP_UCR_SEGMENT UCRSegments;
    PLIST_ENTRY Head, Next;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    UCHAR SegmentIndex;
    PVOID LowFragmentationHeap;

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    RTL_PAGED_CODE();

    if (HeapHandle == NULL) {

        HeapDebugPrint(( "Ignoring RtlDestroyHeap( NULL )\n" ));

        return NULL;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlDestroyNtHeap( HeapHandle );
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if this is the debug version of heap using page allocation
    //  with guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapDestroy( HeapHandle ));

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if this is the debug version of heap
    //  and of so then call the debug version to do the teardown
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugDestroyHeap( HeapHandle )) {

            return HeapHandle;
        }
    }

    //
    //  We are not allowed to destroy the process heap
    //

    if (HeapHandle == NtCurrentPeb()->ProcessHeap) {

        return HeapHandle;
    }

    if (LowFragmentationHeap = RtlpGetLowFragHeap(Heap)) {

        RtlpDestroyLowFragHeap(LowFragmentationHeap);
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  For every big allocation we remove it from the list and free the
    //  vm
    //

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        BaseAddress = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        Next = Next->Flink;
        RegionSize = 0;

        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                   (PVOID *)&BaseAddress,
                                   &RegionSize,
                                   MEM_RELEASE );
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we need to destroy any heap tags we have setup
    //  and remove this heap from the process heap list
    //

    RtlpDestroyTags( Heap );
    RtlpRemoveHeapFromProcessList( Heap );

#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the heap is serialized, delete the critical section created
    //  by RtlCreateHeap.
    //
    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        if (!(Heap->Flags & HEAP_LOCK_USER_ALLOCATED)) {

            (VOID)RtlDeleteLockRoutine( Heap->LockVariable );
        }

        Heap->LockVariable = NULL;
    }

    //
    //  For every uncommitted segment we free its vm
    //

    UCRSegments = Heap->UCRSegments;
    Heap->UCRSegments = NULL;

    while (UCRSegments) {

        BaseAddress = UCRSegments;
        UCRSegments = UCRSegments->Next;
        RegionSize = 0;

        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                   &BaseAddress,
                                   &RegionSize,
                                   MEM_RELEASE );
    }

#ifndef NTOS_KERNEL_RUNTIME
    
    //
    //  Free the large block index, if we have one
    //

    if (Heap->LargeBlocksIndex) {
        
        PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

        //
        //  Save the commited size for the index.
        //

        RegionSize = HeapIndex->VirtualMemorySize;
        Heap->LargeBlocksIndex = NULL;

        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                   &HeapIndex,
                                   &RegionSize,
                                   MEM_RELEASE );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  For every segment in the heap we call a worker routine to
    //  destroy the segment
    //

    SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

    while (SegmentIndex--) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            RtlpDestroyHeapSegment( Segment );
        }
    }

    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(NTDLL_EVENT_COMMON) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize );

        if(pEventHeader && pThreadLocalData) {

            PNTDLL_EVENT_COMMON pHeapEvent = (PNTDLL_EVENT_COMMON)( (SIZE_T)pEventHeader
                                            + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId= PERFINFO_LOG_TYPE_HEAP_DESTROY;

            pHeapEvent->Handle = (PVOID)HeapHandle;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 

    #endif // NTOS_KERNEL_RUNTIME


    //
    //  And we return to our caller
    //

    return NULL;
}


PVOID
RtlAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine allocates a memory of the specified size from the specified
    heap.

Arguments:

    HeapHandle - Supplies a pointer to an initialized heap structure

    Flags - Specifies the set of flags to use to control the allocation

    Size - Specifies the size, in bytes, of the allocation

Return Value:

    PVOID - returns a pointer to the newly allocated block

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PULONG FreeListsInUse;
    ULONG FreeListsInUseUlong;
    SIZE_T AllocationSize;
    SIZE_T FreeSize, AllocationIndex;
    PLIST_ENTRY FreeListHead, Next;
    PHEAP_ENTRY BusyBlock;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    ULONG InUseIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    EXCEPTION_RECORD ExceptionRecord;
    PVOID ReturnValue = NULL;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T BlockSize = 0;
    PVOID FrontEndHeap = NULL;
    
    HEAP_PERF_DECLARE_TIMER();

    RTL_PAGED_CODE();


#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlAllocateNtHeap( HeapHandle,
                                      Flags,
                                      Size);
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME


    //
    //  Take the callers flags and add in the flags that we must forcibly set
    //  in the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check for special features that force us to call the slow, do-everything
    //  version.  We do everything slow for any of the following flags.
    //
    //    HEAP_SLOW_FLAGS defined as           0x6f030f60
    //
    //      HEAP_DEBUG_FLAGS, defined as       0x69020000 (heappriv.h)
    //
    //        HEAP_VALIDATE_PARAMETERS_ENABLED 0x40000000 (heap.h)
    //
    //        HEAP_VALIDATE_ALL_ENABLED        0x20000000 (heap.h)
    //
    //        HEAP_CAPTURE_STACK_BACKTRACES    0x08000000 (heap.h)
    //
    //        HEAP_CREATE_ENABLE_TRACING       0x00020000 (ntrtl.h winnt obsolete)
    //
    //        HEAP_FLAG_PAGE_ALLOCS            0x01000000 (heappage.h)
    //
    //      HEAP_SETTABLE_USER_FLAGS           0x00000E00 (ntrtl.h)
    //
    //      HEAP_NEED_EXTRA_FLAGS              0x0f000100 (heap.h)
    //
    //      HEAP_CREATE_ALIGN_16               0x00010000 (ntrtl.h winnt obsolete)
    //
    //      HEAP_FREE_CHECKING_ENABLED         0x00000040 (ntrtl.h winnt)
    //
    //      HEAP_TAIL_CHECKING_ENABLED         0x00000020 (ntrtl.h winnt )
    //
    //  We also do everything slow if the size is greater than max long
    //

    if ((Flags & HEAP_SLOW_FLAGS) || (Size >= 0x80000000)) {

        ReturnValue = RtlAllocateHeapSlowly( HeapHandle, Flags, Size );

        if ( (ReturnValue == NULL) && 
             (Flags & HEAP_GENERATE_EXCEPTIONS) ) {

            //
            //  Construct an exception record.
            //

            ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
            ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
            ExceptionRecord.NumberParameters = 1;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.ExceptionInformation[ 0 ] = Size;

            RtlRaiseException( &ExceptionRecord );
        }

        return ReturnValue;
    }

#ifndef NTOS_KERNEL_RUNTIME

    if ((FrontEndHeap = RtlpGetLowFragHeap(Heap))
            &&
        RtlpIsFrontHeapUnlocked(Heap)
            &&
        !(Flags & (HEAP_NO_CACHE_BLOCK | HEAP_NO_SERIALIZE))) {

        ReturnValue = RtlpLowFragHeapAlloc( FrontEndHeap, (Size ? Size : 1) );
        
        if (ReturnValue != NULL) {

            if (Flags & HEAP_ZERO_MEMORY) {

                RtlZeroMemory( ReturnValue, Size );
            }

            if( IsHeapLogging( HeapHandle ) ) {

                PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                USHORT ReqSize = sizeof(HEAP_EVENT_ALLOC) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

                if(pEventHeader && pThreadLocalData) {

                    PHEAP_EVENT_ALLOC pHeapEvent = (PHEAP_EVENT_ALLOC)((SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                    pEventHeader->Packet.Size = (USHORT) ReqSize;
                    pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_ALLOC;

                    pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                    pHeapEvent->Size		= Size;
                    pHeapEvent->Address		= (PVOID)ReturnValue;
                    pHeapEvent->Source		= MEMORY_FROM_LOWFRAG;

                    ReleaseBufferLocation(pThreadLocalData);
                }
            } 

            return ReturnValue;
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  At this point we know we are doing everything in this routine
    //  and not taking the slow route.
    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra 1 byte to protect ourselves from mistakes.
    //
    //      Allocation size will be either 16, 24, 32, ...
    //      Allocation index will be 2, 3, 4, ...
    //
    //  Note that allocation size 8 is skipped and are indices 0 and 1
    //

    AllocationSize = ((Size ? Size : 1) + HEAP_GRANULARITY - 1 + sizeof( HEAP_ENTRY ))
        & ~(HEAP_GRANULARITY -1);
    
#ifndef NTOS_KERNEL_RUNTIME

    //
    //  Adjust the size to page boundary to reduce the virtual address fragmentation
    //

    if (FrontEndHeap 
            &&
        (AllocationSize > HEAP_LARGEST_LFH_BLOCK)) {

        AllocationSize = ROUND_UP_TO_POWER2(AllocationSize, PAGE_SIZE);
    }

#endif //  NTOS_KERNEL_RUNTIME

    AllocationIndex = AllocationSize >>  HEAP_GRANULARITY_SHIFT;

    //
    //  If there is a lookaside list and the index is within limits then
    //  try and allocate from the lookaside list.  We'll actually capture
    //  the lookaside pointer from the heap and only use the captured pointer.
    //  This will take care of the condition where a walk or lock heap can
    //  cause us to check for a non null pointer and then have it become null
    //  when we read it again.  If it is non null to start with then even if
    //  the user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

#ifndef NTOS_KERNEL_RUNTIME

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);

        if ((Lookaside != NULL) &&
            RtlpIsFrontHeapUnlocked(Heap) &&
            (AllocationIndex < HEAP_MAXIMUM_FREELISTS)) {

            //
            //  If the number of operation elapsed operations is 128 times the
            //  lookaside depth then it is time to adjust the depth
            //

            if ((LONG)(Lookaside[AllocationIndex].TotalAllocates - Lookaside[AllocationIndex].LastTotalAllocates) >=
                      (Lookaside[AllocationIndex].Depth * 128)) {

                RtlpAdjustHeapLookasideDepth(&(Lookaside[AllocationIndex]));
            }

            ReturnValue = RtlpAllocateFromHeapLookaside(&(Lookaside[AllocationIndex]));
            
            if (ReturnValue != NULL) {

                PHEAP_ENTRY BusyBlock;

                BusyBlock = ((PHEAP_ENTRY)ReturnValue) - 1;
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

                if (Flags & HEAP_ZERO_MEMORY) {

                    RtlZeroMemory( ReturnValue, Size );
                }
                #ifndef NTOS_KERNEL_RUNTIME

                if( IsHeapLogging( HeapHandle ) && (TraceLevel & LOG_LOOKASIDE)) {

                    PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                    PPERFINFO_TRACE_HEADER pEventHeader = NULL;

                    USHORT ReqSize = sizeof(HEAP_EVENT_ALLOC) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                    AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                    if(pEventHeader && pThreadLocalData) {

                        PHEAP_EVENT_ALLOC pHeapEvent = (PHEAP_EVENT_ALLOC)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                        pEventHeader->Packet.Size = (USHORT) ReqSize;
                        pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_ALLOC;

                        pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                        pHeapEvent->Size		= Size;
                        pHeapEvent->Address		= (PVOID)ReturnValue;
                        pHeapEvent->Source		= MEMORY_FROM_LOOKASIDE;

                        ReleaseBufferLocation(pThreadLocalData);
                    }
                } 

                #endif //NTOS_KERNEL_RUNTIME

                return ReturnValue;
            }
        }
    }


#endif // NTOS_KERNEL_RUNTIME

    try {

        HEAP_PERF_START_TIMER(Heap);
        
        //
        //  Check if we need to serialize our access to the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            //
            //  Lock the free list.
            //

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  If the allocation index is less than the maximum free list size
        //  then we can use the index to check the free list otherwise we have
        //  to either pull the entry off of the [0] index list or allocate
        //  memory directly for this request.
        //

        if (AllocationIndex < HEAP_MAXIMUM_FREELISTS) {

            //
            //  With a size that matches a free list size grab the head
            //  of the list and check if there is an available entry
            //

            FreeListHead = &Heap->FreeLists[ AllocationIndex ];

            if ( !IsListEmpty( FreeListHead ))  {

                //
                //  We're in luck the list has an entry so now get the free
                //  entry,  copy its flags, remove it from the free list
                //

                FreeBlock = CONTAINING_RECORD( FreeListHead->Blink,
                                               HEAP_FREE_ENTRY,
                                               FreeList );

                FreeFlags = FreeBlock->Flags;

                RtlpFastRemoveDedicatedFreeBlock( Heap, FreeBlock );

                //
                //  Adjust the total number of bytes free in the heap
                //

                Heap->TotalFreeSize -= AllocationIndex;

                //
                //  Mark the block as busy and set the number of bytes
                //  unused and tag index.  Also if it is the last entry
                //  then keep that flag.
                //

                BusyBlock = (PHEAP_ENTRY)FreeBlock;
                BusyBlock->Flags = HEAP_ENTRY_BUSY | (FreeFlags & HEAP_ENTRY_LAST_ENTRY);

                RtlpSetUnusedBytes(Heap, BusyBlock, AllocationSize - Size);

                BusyBlock->SmallTagIndex = 0;

            } else {

                //
                //  The free list that matches our request is empty
                //
                //  Scan the free list in use vector to find the smallest
                //  available free block large enough for our allocations.
                //

                //
                //  Compute the index of the ULONG where the scan should begin
                //

                InUseIndex = (ULONG) (AllocationIndex >> 5);
                FreeListsInUse = &Heap->u.FreeListsInUseUlong[InUseIndex];

                //
                //  Mask off the bits in the first ULONG that represent allocations
                //  smaller than we need.
                //

                FreeListsInUseUlong = *FreeListsInUse++ & ~((1 << ((ULONG) AllocationIndex & 0x1f)) - 1);

                //
                //  Begin unrolled loop to scan bit vector.
                //

                switch (InUseIndex) {

                case 0:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[0];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 1:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[32];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 2:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[64];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 3:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[96];
                        break;
                    }

                    //
                    //  deliberate fallthrough to non dedicated list
                    //

                default:

                    //
                    //  No suitable entry on the free list was found.
                    //

                    goto LookInNonDedicatedList;
                }

                //
                //  A free list has been found with a large enough allocation.
                //  FreeListHead contains the base of the vector it was found in.
                //  FreeListsInUseUlong contains the vector.
                //

                FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                //
                //  Grab the free block and remove it from the free list
                //

                FreeBlock = CONTAINING_RECORD( FreeListHead->Blink,
                                               HEAP_FREE_ENTRY,
                                               FreeList );

                RtlpFastRemoveDedicatedFreeBlock( Heap, FreeBlock );

    SplitFreeBlock:

                //
                //  Save the blocks flags and decrement the amount of
                //  free space left in the heap
                //

                FreeFlags = FreeBlock->Flags;
                Heap->TotalFreeSize -= FreeBlock->Size;

                //
                //  Mark the block busy
                //

                BusyBlock = (PHEAP_ENTRY)FreeBlock;
                BusyBlock->Flags = HEAP_ENTRY_BUSY;

                //
                //  Compute the size (i.e., index) of the amount from this block
                //  that we don't need and can return to the free list
                //

                FreeSize = BusyBlock->Size - AllocationIndex;

                //
                //  Finish setting up the rest of the new busy block
                //

                BusyBlock->Size = (USHORT)AllocationIndex;
                RtlpSetUnusedBytes(Heap, BusyBlock, (AllocationSize - Size));
                BusyBlock->SmallTagIndex = 0;

                //
                //  Now if the size that we are going to free up is not zero
                //  then lets get to work and to the split.
                //

                if (FreeSize != 0) {

                    //
                    //  But first we won't ever bother doing a split that only
                    //  gives us 8 bytes back.  So if free size is one then just
                    //  bump up the size of the new busy block
                    //

                    if (FreeSize == 1) {

                        BusyBlock->Size += 1;
                        RtlpSetUnusedBytes(Heap, BusyBlock, AllocationSize + sizeof( HEAP_ENTRY ) - Size );

                    } else {

                        //
                        //  Get a pointer to where the new free block will be.
                        //  When we split a block the first part goes to the new
                        //  busy block and the second part goes back to the free
                        //  list
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        //
                        //  Reset the flags that we copied from the original free list
                        //  header, and set it other size fields.
                        //

                        SplitBlock->Flags = FreeFlags;
                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;
                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;
                        SplitBlock->Size = (USHORT)FreeSize;

                        //
                        //  If nothing else follows this entry then we will insert
                        //  this into the corresponding free list (and update
                        //  Segment->LastEntryInSegment)
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize);
                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise we need to check the following block
                            //  and if it is busy then update its previous size
                            //  before inserting our new free block into the
                            //  free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock2->PreviousSize = (USHORT)FreeSize;

                                RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );
                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  The following block is free so we'll merge
                                //  these to blocks. by first merging the flags
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                //
                                //  Removing the second block from its free list
                                //

                                RtlpFastRemoveFreeBlock( Heap, SplitBlock2 );

                                //
                                //  Updating the free total number of free bytes
                                //  in the heap and updating the size of the new
                                //  free block
                                //

                                Heap->TotalFreeSize -= SplitBlock2->Size;
                                FreeSize += SplitBlock2->Size;

                                //
                                //  If the new free block is still less than the
                                //  maximum heap block size then we'll simply
                                //  insert it back in the free list
                                //

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    //
                                    //  Again check if the new following block
                                    //  exists and if so then update is previous
                                    //  size
                                    //

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;
                                    }

                                    //
                                    //  Insert the new free block into the free
                                    //  list and update the free heap size
                                    //

                                    RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );
                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    //
                                    //  The new free block is pretty large so we
                                    //  need to call a private routine to do the
                                    //  insert
                                    //

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }

                        //
                        //  Now that free flags made it back into a free block
                        //  we can zero out what we saved.
                        //

                        FreeFlags = 0;

                        //
                        //  If splitblock now last, update LastEntryInSegment
                        //

                        if (SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                        }
                    }
                }

                //
                //  If there are no following entries then mark the new block as
                //  such
                //

                if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                    BusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;
                }
            }

            //
            //  Return the address of the user portion of the allocated block.
            //  This is the byte following the header.
            //

            ReturnValue = BusyBlock + 1;
            BlockSize = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

            //
            //  Release the lock before the zero memory call
            //

            if (LockAcquired) {

                RtlReleaseLockRoutine( Heap->LockVariable );

                LockAcquired = FALSE;
            }
            
            //
            //  If the flags indicate that we should zero memory then do it now
            //

            if (Flags & HEAP_ZERO_MEMORY) {

                RtlZeroMemory( ReturnValue, Size );
            }

            //
            //  And return the allocated block to our caller
            //

            leave;

        //
        //  Otherwise the allocation request is bigger than the last dedicated
        //  free list size.  Now check if the size is within our threshold.
        //  Meaning that it could be in the [0] free list
        //

        } else if (AllocationIndex <= Heap->VirtualMemoryThreshold) {

    LookInNonDedicatedList:

            //
            //  The following code cycles through the [0] free list until
            //  it finds a block that satisfies the request.  The list
            //  is sorted so the search is can be terminated early on success
            //

            FreeListHead = &Heap->FreeLists[0];
        
            if (Heap->LargeBlocksIndex) {

                //
                //  We can use the index to find the block very quick
                //

                Next = RtlpFindEntry( Heap, (ULONG)AllocationIndex );

                if ( FreeListHead != Next ) {

                    FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                    if ( FreeBlock->Size >= AllocationIndex ) {

                        //
                        //  We've found something that we can use so now remove
                        //  it from the free list and go to where we treat splitting
                        //  a free block.  Note that the block we found here might
                        //  actually be the exact size we need and that is why
                        //  in the split free block case we have to consider having
                        //  nothing free after the split
                        //
#ifndef NTOS_KERNEL_RUNTIME

                        if ((((PHEAP_INDEX)Heap->LargeBlocksIndex)->LargeBlocksCacheSequence)
                                &&
                            (AllocationIndex > Heap->DeCommitFreeBlockThreshold) 
                                &&
                            (FreeBlock->Size > (AllocationIndex * HEAP_REUSAGE_FACTOR))) {

                            RtlpFlushLargestCacheBlock(Heap);

                        } else {
                            
                            RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                            goto SplitFreeBlock;
                        }
#else // NTOS_KERNEL_RUNTIME
                        
                        RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                        goto SplitFreeBlock;
#endif // NTOS_KERNEL_RUNTIME
                    }
                }

            } else {
                
                //
                //  Check if the largest block in the list is smaller than the request
                //

                Next = FreeListHead->Blink;

                if (FreeListHead != Next) {

                    FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                    if (FreeBlock->Size >= AllocationIndex) {

                        //
                        //  Here we are sure there is at least a block here larger than
                        //  the requested size. Start searching from the first block
                        //

                        Next = FreeListHead->Flink;

                        while (FreeListHead != Next) {

                            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                            if (FreeBlock->Size >= AllocationIndex) {

                                //
                                //  We've found something that we can use so now remove
                                //  it from the free list and go to where we treat splitting
                                //  a free block.  Note that the block we found here might
                                //  actually be the exact size we need and that is why
                                //  in the split free block case we have to consider having
                                //  nothing free after the split
                                //

                                RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                                goto SplitFreeBlock;
                            }

                            Next = Next->Flink;
                        }
                    }
                }
            }
            
            //
            //  The [0] list is either empty or everything is too small
            //  so now extend the heap which should get us something less
            //  than or equal to the virtual memory threshold
            //

            FreeBlock = RtlpExtendHeap( Heap, AllocationSize );

            //
            //  And provided we got something we'll treat it just like the previous
            //  split free block cases
            //

            if (FreeBlock != NULL) {

                RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                goto SplitFreeBlock;
            }

            //
            //  We weren't able to extend the heap so we must be out of memory
            //

            Status = STATUS_NO_MEMORY;

        //
        //  At this point the allocation is way too big for any of the free lists
        //  and we can only satisfy this request if the heap is growable
        //

        } else if (Heap->Flags & HEAP_GROWABLE) {

            PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

            VirtualAllocBlock = NULL;

            //
            //  Compute how much memory we will need for this allocation which
            //  will include the allocation size plus a header, and then go
            //  get the committed memory
            //

            AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              (PVOID *)&VirtualAllocBlock,
                                              0,
                                              &AllocationSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (NT_SUCCESS(Status)) {

                //
                //  Just committed, already zero.  Fill in the new block
                //  and insert it in the list of big allocation
                //

                VirtualAllocBlock->BusyBlock.Size = (USHORT)(AllocationSize - Size);
                VirtualAllocBlock->BusyBlock.Flags = HEAP_ENTRY_VIRTUAL_ALLOC | HEAP_ENTRY_EXTRA_PRESENT | HEAP_ENTRY_BUSY;
                VirtualAllocBlock->CommitSize = AllocationSize;
                VirtualAllocBlock->ReserveSize = AllocationSize;

                InsertTailList( &Heap->VirtualAllocdBlocks, (PLIST_ENTRY)VirtualAllocBlock );

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                ReturnValue = (PHEAP_ENTRY)(VirtualAllocBlock + 1);
                BlockSize = AllocationSize;

                leave;
            }

        } else {

            Status = STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  This is the error return.
        //

        if (Flags & HEAP_GENERATE_EXCEPTIONS) {

            //
            //  Construct an exception record.
            //

            ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
            ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
            ExceptionRecord.NumberParameters = 1;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

            RtlRaiseException( &ExceptionRecord );
        }

        SET_LAST_STATUS(Status);

        ReturnValue = NULL;

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }
    
    RtlpRegisterOperation(Heap, BlockSize, HEAP_OP_ALLOC);
    HEAP_PERF_STOP_TIMER(Heap, HEAP_OP_ALLOC);

    #ifndef NTOS_KERNEL_RUNTIME
    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(HEAP_EVENT_ALLOC) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PHEAP_EVENT_ALLOC pHeapEvent = (PHEAP_EVENT_ALLOC)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_ALLOC;

            pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
            pHeapEvent->Size		= Size;
            pHeapEvent->Address		= (PVOID)ReturnValue;
            pHeapEvent->Source		= MEMORY_FROM_MAINPATH;

            ReleaseBufferLocation(pThreadLocalData);
        }
    } 
    #endif //NTOS_KERNEL_RUNTIME


    return ReturnValue;
}


PVOID
RtlAllocateHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine does the equivalent of Rtl Allocate Heap but it does it will
    additional heap consistency checking logic and tagging.

Arguments:

    HeapHandle - Supplies a pointer to an initialized heap structure

    Flags - Specifies the set of flags to use to control the allocation

    Size - Specifies the size, in bytes, of the allocation

Return Value:

    PVOID - returns a pointer to the newly allocated block

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    PULONG FreeListsInUse;
    ULONG FreeListsInUseUlong;
    SIZE_T AllocationSize;
    SIZE_T FreeSize, AllocationIndex;
    UCHAR EntryFlags, FreeFlags;
    PLIST_ENTRY FreeListHead, Next;
    PHEAP_ENTRY BusyBlock;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    NTSTATUS Status;
    EXCEPTION_RECORD ExceptionRecord;
    SIZE_T ZeroSize = 0;
    SIZE_T BlockSize = 0;
    
    HEAP_PERF_DECLARE_TIMER();

    RTL_PAGED_CODE();
    
    //
    //  Note that Flags has already been OR'd with Heap->ForceFlags.
    //

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if we should be using the debug version
    //  of heap allocation
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugAllocateHeap( HeapHandle, Flags, Size );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the size is greater than maxlong then say we can't allocate that
    //  much and return the error to our caller
    //

    if (Size > MAXINT_PTR) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round up the requested size to the allocation granularity.  Note
    //  that if the request is for zero bytes we will still allocate memory,
    //
    //      Allocation size will be either 16, 24, 32, ...
    //      Allocation index will be 2, 3, 4, ...
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    //
    //  Generate the flags needed for this heap entry.  Mark it busy and add
    //  any user settable bits.  Also if the input flag indicates any entry
    //  extra fields and we have a tag to use then make room for the extra
    //  fields in the heap entry
    //

    EntryFlags = (UCHAR)(HEAP_ENTRY_BUSY | ((Flags & HEAP_SETTABLE_USER_FLAGS) >> 4));

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) || (Heap->PseudoTagEntries != NULL)) {

        EntryFlags |= HEAP_ENTRY_EXTRA_PRESENT;
        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

    try {

        HEAP_PERF_START_TIMER(Heap);
        
        //
        //  Lock the free list.
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Do all the actual heap work under the protection of a try-except clause
        //  to protect us from corruption
        //

        try {

            //
            //  If the allocation index is less than the maximum free list size
            //  then we can use the index to check the free list otherwise we have
            //  to either pull the entry off of the [0] index list or allocate
            //  memory directly for this request.
            //

            if (AllocationIndex < HEAP_MAXIMUM_FREELISTS) {

                //
                //  With a size that matches a free list size grab the head
                //  of the list and check if there is an available entry
                //

                FreeListHead = &Heap->FreeLists[ AllocationIndex ];

                if ( !IsListEmpty( FreeListHead ))  {

                    //
                    //  We're in luck the list has an entry so now get the free
                    //  entry,  copy its flags, remove it from the free list
                    //

                    FreeBlock = CONTAINING_RECORD( FreeListHead->Flink,
                                                   HEAP_FREE_ENTRY,
                                                   FreeList );

                    FreeFlags = FreeBlock->Flags;

                    RtlpRemoveFreeBlock( Heap, FreeBlock );

                    //
                    //  Adjust the total number of bytes free in the heap
                    //

                    Heap->TotalFreeSize -= AllocationIndex;

                    //
                    //  Mark the block as busy and set the number of bytes
                    //  unused and tag index.  Also if it is the last entry
                    //  then keep that flag.
                    //

                    BusyBlock = (PHEAP_ENTRY)FreeBlock;
                    BusyBlock->Flags = EntryFlags | (FreeFlags & HEAP_ENTRY_LAST_ENTRY);
                    RtlpSetUnusedBytes(Heap, BusyBlock, (AllocationSize - Size));

                } else {

                    //
                    //  The free list that matches our request is empty.  We know
                    //  that there are 128 free lists managed by a 4 ULONG bitmap.
                    //  The next big if-else-if statement will decide which ULONG
                    //  we tackle
                    //
                    //  Check if the requested allocation index within the first
                    //  quarter of the free lists.
                    //

                    if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 1) / 4) {

                        //
                        //  Grab a pointer to the corresponding bitmap ULONG, and
                        //  then get the bit we're actually interested in to be the
                        //  first bit of the ULONG.
                        //

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 0 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        //
                        //  If the remaining bitmap has any bits set then we know
                        //  there is a non empty list that is larger than our
                        //  requested index so find that bit and compute the list
                        //  head of the next non empty list
                        //

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            //
                            //  The rest of the first ULONG is all zeros so we need
                            //  to move to the second ULONG
                            //

                            FreeListsInUseUlong = *FreeListsInUse++;

                            //
                            //  Check if the second ULONG has any bits set and if
                            //  so then compute the list head of the next non empty
                            //  list
                            //

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                //
                                //  Do the same test for the third ULONG
                                //

                                FreeListsInUseUlong = *FreeListsInUse++;

                                if (FreeListsInUseUlong) {

                                    FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 2) / 4) -
                                        (AllocationIndex & 0x1F) +
                                        RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                } else {

                                    //
                                    //  Repeat the test for the forth ULONG, and if
                                    //  that one is also empty then we need to grab
                                    //  the allocation off of the [0] index list
                                    //

                                    FreeListsInUseUlong = *FreeListsInUse++;

                                    if (FreeListsInUseUlong) {

                                        FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 3) / 4) -
                                            (AllocationIndex & 0x1F)  +
                                            RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                    } else {

                                        goto LookInNonDedicatedList;
                                    }
                                }
                            }
                        }

                    //
                    //  Otherwise check if the requested allocation index lies
                    //  within the second quarter of the free lists.  We repeat the
                    //  test just like we did above on the second, third, and forth
                    //  bitmap ulongs.
                    //

                    } else if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 2) / 4) {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 1 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            FreeListsInUseUlong = *FreeListsInUse++;

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                FreeListsInUseUlong = *FreeListsInUse++;

                                if (FreeListsInUseUlong) {

                                    FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 2) / 4) -
                                        (AllocationIndex & 0x1F)  +
                                        RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                } else {

                                    goto LookInNonDedicatedList;
                                }
                            }
                        }

                    //
                    //  Otherwise check if the requested allocation index lies
                    //  within the third quarter of the free lists. We repeat the
                    //  test just like we did above on the third and forth bitmap
                    //  ulongs
                    //

                    } else if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 3) / 4) {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 2 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            FreeListsInUseUlong = *FreeListsInUse++;

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                goto LookInNonDedicatedList;
                            }
                        }

                    //
                    //  Lastly the requested allocation index must lie within the
                    //  last quarter of the free lists.  We repeat the test just
                    //  like we did above on the forth ulong
                    //

                    } else {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 3 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            goto LookInNonDedicatedList;
                        }
                    }

                    //
                    //  At this point the free list head points to a non empty free
                    //  list that is of greater size than we need.
                    //

                    FreeBlock = CONTAINING_RECORD( FreeListHead->Flink,
                                                   HEAP_FREE_ENTRY,
                                                   FreeList );

    SplitFreeBlock:

                    //
                    //  Remember the flags that go with this block and remove it
                    //  from its list
                    //

                    FreeFlags = FreeBlock->Flags;

                    RtlpRemoveFreeBlock( Heap, FreeBlock );

                    //
                    //  Adjust the amount free in the heap
                    //

                    Heap->TotalFreeSize -= FreeBlock->Size;

                    //
                    //  Mark the block busy
                    //

                    BusyBlock = (PHEAP_ENTRY)FreeBlock;
                    BusyBlock->Flags = EntryFlags;

                    //
                    //  Compute the size (i.e., index) of the amount from this
                    //  block that we don't need and can return to the free list
                    //

                    FreeSize = BusyBlock->Size - AllocationIndex;

                    //
                    //  Finish setting up the rest of the new busy block
                    //

                    BusyBlock->Size = (USHORT)AllocationIndex;
                    RtlpSetUnusedBytes(Heap, BusyBlock, ((AllocationSize - Size)));

                    //
                    //  Now if the size that we are going to free up is not zero
                    //  then lets get to work and to the split.
                    //

                    if (FreeSize != 0) {

                        //
                        //  But first we won't ever bother doing a split that only
                        //  gives us 8 bytes back.  So if free size is one then
                        //  just bump up the size of the new busy block
                        //

                        if (FreeSize == 1) {

                            BusyBlock->Size += 1;
                            RtlpSetUnusedBytes(Heap, BusyBlock, AllocationSize + sizeof( HEAP_ENTRY ) - Size);

                        } else {

                            //
                            //  Get a pointer to where the new free block will be.
                            //  When we split a block the first part goes to the
                            //  new busy block and the second part goes back to the
                            //  free list
                            //

                            SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                            //
                            //  Reset the flags that we copied from the original
                            //  free list header, and set it other size fields.
                            //

                            SplitBlock->Flags = FreeFlags;
                            SplitBlock->PreviousSize = (USHORT)AllocationIndex;
                            SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;
                            SplitBlock->Size = (USHORT)FreeSize;

                            //
                            //  If nothing else follows this entry then we will
                            //  insert this into the corresponding free list
                            //

                            if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise we need to check the following block
                                //  and if it is busy then update its previous size
                                //  before inserting our new free block into the
                                //  free list
                                //

                                SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                                if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                    SplitBlock2->PreviousSize = (USHORT)FreeSize;

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    //
                                    //  The following block is free so we'll merge
                                    //  these to blocks. by first merging the flags
                                    //

                                    SplitBlock->Flags = SplitBlock2->Flags;

                                    //
                                    //  Removing the second block from its free
                                    //  list
                                    //

                                    RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                    //
                                    //  Updating the free total number of free
                                    //  bytes in the heap and updating the size of
                                    //  the new free block
                                    //

                                    Heap->TotalFreeSize -= SplitBlock2->Size;
                                    FreeSize += SplitBlock2->Size;

                                    //
                                    //  If the new free block is still less than
                                    //  the maximum heap block size then we'll
                                    //  simply insert it back in the free list
                                    //

                                    if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                        SplitBlock->Size = (USHORT)FreeSize;

                                        //
                                        //  Again check if the new following block
                                        //  exists and if so then update is
                                        //  previous size
                                        //

                                        if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                            ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;
                                        }

                                        //
                                        //  Insert the new free block into the free
                                        //  list and update the free heap size
                                        //

                                        RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                        Heap->TotalFreeSize += FreeSize;

                                    } else {

                                        //
                                        //  The new free block is pretty large so
                                        //  we need to call a private routine to do
                                        //  the insert
                                        //

                                        RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                    }
                                }
                            }

                            //
                            //  Now that free flags made it back into a free block
                            //  we can zero out what we saved.
                            //

                            FreeFlags = 0;

                            //
                            //  If splitblock now last, update LastEntryInSegment
                            //

                            if (SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                                PHEAP_SEGMENT Segment;

                                Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                            }

                        }
                    }

                    //
                    //  If there are no following entries then mark the new block
                    //  as such
                    //

                    if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                        BusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;
                    }
                }

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                ReturnValue = BusyBlock + 1;
                BlockSize = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

                //
                //  If the flags indicate that we should zero memory then
                //  remember how much to zero.  We'll do the zeroing later
                //

                if (Flags & HEAP_ZERO_MEMORY) {

                    ZeroSize = Size;

                //
                //  Otherwise if the flags indicate that we should fill heap then
                //  it it now.
                //

                } else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                    RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1), Size & ~0x3, ALLOC_HEAP_FILL );
                }

                //
                //  If the flags indicate that we should do tail checking then copy
                //  the fill pattern right after the heap block.
                //

                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)ReturnValue + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );

                    BusyBlock->Flags |= HEAP_ENTRY_FILL_PATTERN;
                }

                BusyBlock->SmallTagIndex = 0;

                //
                //  If the flags indicate that there is an extra block persent then
                //  we'll fill it in
                //

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    RtlZeroMemory( ExtraStuff, sizeof( *ExtraStuff ));

    #ifndef NTOS_KERNEL_RUNTIME

                //
                //  In the non kernel case the tagging goes in either the extra
                //  stuff of the busy block small tag index
                //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        ExtraStuff->TagIndex = RtlpUpdateTagEntry( Heap,
                                                                   (USHORT)((Flags & HEAP_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                                   0,
                                                                   BusyBlock->Size,
                                                                   AllocationAction );
                    }

                } else if (IS_HEAP_TAGGING_ENABLED()) {

                    BusyBlock->SmallTagIndex = (UCHAR)RtlpUpdateTagEntry( Heap,
                                                                          (USHORT)((Flags & HEAP_SMALL_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                                          0,
                                                                          BusyBlock->Size,
                                                                          AllocationAction );

    #endif // NTOS_KERNEL_RUNTIME

                }

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                leave;

            //
            //  Otherwise the allocation request is bigger than the last dedicated
            //  free list size.  Now check if the size is within our threshold.
            //  Meaning that it could be in the [0] free list
            //

            } else if (AllocationIndex <= Heap->VirtualMemoryThreshold) {

    LookInNonDedicatedList:

                //
                //  The following code cycles through the [0] free list until
                //  it finds a block that satisfies the request.  The list
                //  is sorted so the search is can be terminated early on success
                //

                FreeListHead = &Heap->FreeLists[ 0 ];

                if (Heap->LargeBlocksIndex) {

                    Next = RtlpFindEntry(Heap, (ULONG)AllocationIndex);

                    if (FreeListHead != Next) {

                        FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                        if (FreeBlock->Size >= AllocationIndex) {

                            //
                            //  We've found something that we can use so now remove
                            //  it from the free list and go to where we treat splitting
                            //  a free block.  Note that the block we found here might
                            //  actually be the exact size we need and that is why
                            //  in the split free block case we have to consider having
                            //  nothing free after the split
                            //

#ifndef NTOS_KERNEL_RUNTIME

                            if  ((((PHEAP_INDEX)Heap->LargeBlocksIndex)->LargeBlocksCacheSequence)
                                    &&
                                (AllocationIndex > Heap->DeCommitFreeBlockThreshold) 
                                    &&
                                (FreeBlock->Size > (AllocationIndex * HEAP_REUSAGE_FACTOR))) {

                                RtlpFlushLargestCacheBlock(Heap);

                            } else {
                                
                                goto SplitFreeBlock;
                            }
#else // NTOS_KERNEL_RUNTIME
                            
                            goto SplitFreeBlock;
#endif // NTOS_KERNEL_RUNTIME
                        }
                    }

                } else {
                    
                    Next = FreeListHead->Flink;

                    while (FreeListHead != Next) {

                        FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                        if (FreeBlock->Size >= AllocationIndex) {

                            //
                            //  We've found something that we can use so now go to
                            //  where we treat splitting a free block.  Note that
                            //  the block we found here might actually be the exact
                            //  size we need and that is why in the split free block
                            //  case we have to consider having nothing free after the
                            //  split
                            //

                            goto SplitFreeBlock;

                        } else {

                            Next = Next->Flink;
                        }
                    }
                }

                //
                //  The [0] list is either empty or everything is too small
                //  so now extend the heap which should get us something less
                //  than or equal to the virtual memory threshold
                //

                FreeBlock = RtlpExtendHeap( Heap, AllocationSize );

                //
                //  And provided we got something we'll treat it just like the
                //  previous split free block cases
                //

                if (FreeBlock != NULL) {

                    goto SplitFreeBlock;
                }

                //
                //  We weren't able to extend the heap so we must be out of memory
                //

                Status = STATUS_NO_MEMORY;

            //
            //  At this point the allocation is way too big for any of the free
            //  lists and we can only satisfy this request if the heap is growable
            //

            } else if (Heap->Flags & HEAP_GROWABLE) {

                PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                VirtualAllocBlock = NULL;

                //
                //  Compute how much memory we will need for this allocation which
                //  will include the allocation size plus a header, and then go
                //  get the committed memory
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                  (PVOID *)&VirtualAllocBlock,
                                                  0,
                                                  &AllocationSize,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE );

                if (NT_SUCCESS( Status )) {

                    //
                    //  Just committed, already zero.  Fill in the new block
                    //  and insert it in the list of big allocation
                    //

                    VirtualAllocBlock->BusyBlock.Size = (USHORT)(AllocationSize - Size);
                    VirtualAllocBlock->BusyBlock.Flags = EntryFlags | HEAP_ENTRY_VIRTUAL_ALLOC | HEAP_ENTRY_EXTRA_PRESENT;
                    VirtualAllocBlock->CommitSize = AllocationSize;
                    VirtualAllocBlock->ReserveSize = AllocationSize;

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we need to add heap tagging
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        VirtualAllocBlock->ExtraStuff.TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                (USHORT)((Flags & HEAP_SMALL_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                0,
                                                VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT,
                                                VirtualAllocationAction );
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    InsertTailList( &Heap->VirtualAllocdBlocks, (PLIST_ENTRY)VirtualAllocBlock );

                    //
                    //  Return the address of the user portion of the allocated
                    //  block.  This is the byte following the header.
                    //

                    ReturnValue = (PHEAP_ENTRY)(VirtualAllocBlock + 1);
                    BlockSize = AllocationSize;

                    leave;
                }

            //
            //  Otherwise we have an error condition
            //

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }

            SET_LAST_STATUS( Status );

            if (Flags & HEAP_GENERATE_EXCEPTIONS) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

        //
        //  Check if there is anything to zero out
        //

        if ( ZeroSize ) {

            RtlZeroMemory( ReturnValue, ZeroSize );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //
    
    RtlpRegisterOperation(Heap, BlockSize, HEAP_OP_ALLOC);
    HEAP_PERF_STOP_TIMER(Heap, HEAP_OP_ALLOC);

    if(ReturnValue) {

        #ifndef NTOS_KERNEL_RUNTIME

        if( IsHeapLogging( HeapHandle ) ) {

            PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
            PPERFINFO_TRACE_HEADER pEventHeader = NULL;
            USHORT ReqSize = sizeof(HEAP_EVENT_ALLOC) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

            AcquireBufferLocation(&pEventHeader, &pThreadLocalData, &ReqSize);

            if(pEventHeader && pThreadLocalData) {

                PHEAP_EVENT_ALLOC pHeapEvent = (PHEAP_EVENT_ALLOC)( (SIZE_T)pEventHeader
                                            + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                pEventHeader->Packet.Size = (USHORT) ReqSize;
                pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_ALLOC;

                pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                pHeapEvent->Size		= Size;
                pHeapEvent->Address		= (PVOID)ReturnValue;
                pHeapEvent->Source		= MEMORY_FROM_SLOWPATH;

                ReleaseBufferLocation(pThreadLocalData);
            }
        } 

        #endif // NTOS_KERNEL_RUNTIME
    }

    return ReturnValue;
}


BOOLEAN
RtlFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns a previously allocated block back to its heap

Arguments:

    HeapHandle - Supplies a pointer to the owning heap structure

    Flags - Specifies the set of flags to use in the deallocation

    BaseAddress - Supplies a pointer to the block being freed

Return Value:

    BOOLEAN - TRUE if the block was properly freed and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN ReturnValue = TRUE;
    SIZE_T BlockSize;
    PVOID FrontHeap = NULL;

    HEAP_PERF_DECLARE_TIMER();

    RTL_PAGED_CODE();
    
    //
    //  First check if the address we're given is null and if so then
    //  there is really nothing to do so just return success
    //

    if (BaseAddress == NULL) {

        return TRUE;
    }

#ifndef NTOS_KERNEL_RUNTIME

    if (FrontHeap = RtlpGetLowFragHeap(Heap)) {

        //
        //  We can do everything in this routine. So now backup to get
        //  a pointer to the start of the block
        //

        BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;
        
        if (BusyBlock->SegmentIndex >= HEAP_LFH_IN_CONVERSION) {

            if (RtlpLowFragHeapFree( FrontHeap, BaseAddress)) {

                #ifndef NTOS_KERNEL_RUNTIME
                if( IsHeapLogging( HeapHandle ) ) {

                    PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                    PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                    USHORT ReqSize = sizeof(HEAP_EVENT_FREE) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                    AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                    if(pEventHeader && pThreadLocalData) {

                        PHEAP_EVENT_FREE pHeapEvent = (PHEAP_EVENT_FREE)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                        pEventHeader->Packet.Size = (USHORT) ReqSize;
                        pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_FREE;

                        pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                        pHeapEvent->Address		= (PVOID)BaseAddress;
                        pHeapEvent->Source		= MEMORY_FROM_LOWFRAG;

                        ReleaseBufferLocation(pThreadLocalData);
                    }
                }
                #endif //NTOS_KERNEL_RUNTIME

                return TRUE;
            }
        }
    } 
    

#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlFreeNtHeap( HeapHandle,
                                  Flags,
                                  BaseAddress);
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME


    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Now check if we should go the slow route
    //

    if (Flags & HEAP_SLOW_FLAGS) {

        return RtlFreeHeapSlowly(HeapHandle, Flags, BaseAddress);
    }

    //
    //  We can do everything in this routine. So now backup to get
    //  a pointer to the start of the block
    //

    BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

    //
    //  Protect ourselves from mistakes by refusing to free blocks
    //  that do not have the busy bit set.
    //
    //  Also refuse to free blocks that are not eight-byte aligned.
    //  The specific mistake in this case is Office95, which likes
    //  to free a random pointer when you start Word95 from a desktop
    //  shortcut.
    //
    //  As further insurance against mistakes, check the segment index
    //  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This
    //  should fix all the dorks who have ASCII or Unicode where the
    //  heap header is supposed to be.
    //

    try {
        if ((((ULONG_PTR)BaseAddress & 0x7) != 0) ||
            (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) ||
            (BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS)) {

            //
            //  Not a busy block, or it's not aligned or the segment is
            //  to big, meaning it's corrupt
            //

            SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            return FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        SET_LAST_STATUS( STATUS_INVALID_PARAMETER );
        return FALSE;
    }

    BlockSize = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

    //
    //  If there is a lookaside list and the block is not a big allocation
    //  and the index is for a dedicated list then free the block to the
    //  lookaside list.  We'll actually capture
    //  the lookaside pointer from the heap and only use the captured pointer.
    //  This will take care of the condition where a walk or lock heap can
    //  cause us to check for a non null pointer and then have it become null
    //  when we read it again.  If it is non null to start with then even if
    //  the user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list push
    //

#ifndef NTOS_KERNEL_RUNTIME

    if ( !(BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) ) {

        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);

        if ((Lookaside != NULL) &&
            RtlpIsFrontHeapUnlocked(Heap) &&
            (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)) &&
            ((FreeSize = BusyBlock->Size) < HEAP_MAXIMUM_FREELISTS)) {

            if (RtlpFreeToHeapLookaside( &Lookaside[FreeSize], BaseAddress)) {

            if( IsHeapLogging( HeapHandle ) && (TraceLevel & LOG_LOOKASIDE)) {

                PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                USHORT ReqSize = sizeof(HEAP_EVENT_FREE) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                if(pEventHeader && pThreadLocalData) {

                    PHEAP_EVENT_FREE pHeapEvent = (PHEAP_EVENT_FREE)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                    pEventHeader->Packet.Size = (USHORT) ReqSize;
                    pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_FREE;

                    pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                    pHeapEvent->Address		= (PVOID)BaseAddress;
                    pHeapEvent->Source		= MEMORY_FROM_LOOKASIDE;

                    ReleaseBufferLocation(pThreadLocalData);
                }
            }

                return TRUE;
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    try {
        
        HEAP_PERF_START_TIMER(Heap);
        
        //
        //  Check if we need to lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Check if this is not a virtual block allocation meaning
        //  that we it is part of the heap free list structure and not
        //  one huge allocation that we got from vm
        //

        if (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)) {

            //
            //  This block is not a big allocation so we need to
            //  to get its size, and coalesce the blocks note that
            //  the user mode heap does this conditionally on a heap
            //  flag.  The coalesce function returns the newly formed
            //  free block and the new size.
            //

            FreeSize = BusyBlock->Size;

    #ifdef NTOS_KERNEL_RUNTIME

            BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap,
                                                             (PHEAP_FREE_ENTRY)BusyBlock,
                                                             &FreeSize,
                                                             FALSE );

    #else // NTOS_KERNEL_RUNTIME

            if (!(Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE)) {

                BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap,
                                                                 (PHEAP_FREE_ENTRY)BusyBlock,
                                                                 &FreeSize,
                                                                 FALSE );
            }

    #endif // NTOS_KERNEL_RUNTIME

            //
            //  Check for a small allocation that can go on a freelist
            //  first, these should never trigger a decommit.
            //

            HEAPASSERT(HEAP_MAXIMUM_FREELISTS < Heap->DeCommitFreeBlockThreshold);

            //
            //  If the allocation fits on a free list then insert it on
            //  the appropriate free list.  If the block is not the last
            //  entry then make sure that the next block knows our correct
            //  size, and update the heap free space counter.
            //

            if (FreeSize < HEAP_MAXIMUM_FREELISTS) {

                RtlpFastInsertDedicatedFreeBlockDirect( Heap,
                                                        (PHEAP_FREE_ENTRY)BusyBlock,
                                                        (USHORT)FreeSize );

                if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                    HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                }

                Heap->TotalFreeSize += FreeSize;

            //
            //  Otherwise the block is to big for one of the dedicated free list so
            //  see if the free size is under the decommit threshold by itself
            //  or the total free in the heap is under the decomit threshold then
            //  we'll put this into a free list
            //

            } else if ((FreeSize < Heap->DeCommitFreeBlockThreshold) ||
                       ((Heap->TotalFreeSize + FreeSize) < Heap->DeCommitTotalFreeThreshold)) {

    #ifndef NTOS_KERNEL_RUNTIME

                //
                //  If the block is larger than 1 page, and has uncommited ranges around
                //  force the decommit to reduce the VA fragmentation
                //

                if (((Heap->TotalFreeSize + FreeSize) > Heap->DeCommitTotalFreeThreshold)
                        &&
                    !(RtlpDisableHeapLookaside & HEAP_COMPAT_DISABLE_LARGECACHE)
                        &&
                    (FreeSize >= (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT))
                        &&
                    ((BusyBlock->PreviousSize == 0) || (BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY))) {

                //
                //  Check if the block can go into the [0] index free list, and if
                //  so then do the insert and make sure the following block is
                //  needed knows our correct size, and update the heaps free space
                //  counter
                //

                    RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );

                } else 

    #endif  //NTOS_KERNEL_RUNTIME
    
                //
                //  Check if the block can go into the [0] index free list, and if
                //  so then do the insert and make sure the following block is
                //  needed knows our correct size, and update the heaps free space
                //  counter
                //

                if (FreeSize <= (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

                    RtlpFastInsertNonDedicatedFreeBlockDirect( Heap,
                                                               (PHEAP_FREE_ENTRY)BusyBlock,
                                                               (USHORT)FreeSize );

                    if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                        HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                    }

                    Heap->TotalFreeSize += FreeSize;

                } else {

                    //
                    //  The block is too big to go on a free list in its
                    //  entirety but we don't want to decommit anything so
                    //  simply call a worker routine to hack up the block
                    //  into pieces that will fit on the free lists.
                    //

                    RtlpInsertFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                }

            //
            //  Otherwise the block is to big for any lists and we should decommit
            //  the block
            //

            } else {

                RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
            }

        } else {

            //
            //  This is a big virtual block allocation.  To free it we only have to
            //  remove it from the heaps list of virtual allocated blocks, unlock
            //  the heap, and return the block to vm
            //

            PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

            VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

            RemoveEntryList( &VirtualAllocBlock->Entry );

            //
            //  Release lock here as there is no reason to hold it across
            //  the system call.
            //

            if (LockAcquired) {

                RtlReleaseLockRoutine( Heap->LockVariable );
                LockAcquired = FALSE;
            }

            FreeSize = 0;

            Status = RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                                (PVOID *)&VirtualAllocBlock,
                                                &FreeSize,
                                                MEM_RELEASE );

            //
            //  Check if we had trouble freeing the block back to vm
            //  and return an error if necessary
            //

            if (!NT_SUCCESS( Status )) {

                SET_LAST_STATUS( Status );

                ReturnValue = FALSE;
            }
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  The block was freed successfully so return success to our
    //  caller
    //
    
    RtlpRegisterOperation(Heap, BlockSize, HEAP_OP_FREE);
    HEAP_PERF_STOP_TIMER(Heap, HEAP_OP_FREE);

    #ifndef NTOS_KERNEL_RUNTIME

    if( IsHeapLogging( HeapHandle ) ) {

        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
        USHORT ReqSize = sizeof(HEAP_EVENT_FREE) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

        AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

        if(pEventHeader && pThreadLocalData) {

            PHEAP_EVENT_FREE pHeapEvent = (PHEAP_EVENT_FREE)( (SIZE_T)pEventHeader
                                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

            pEventHeader->Packet.Size = (USHORT) ReqSize;
            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_FREE;

            pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
            pHeapEvent->Address		= (PVOID)BaseAddress;
            pHeapEvent->Source		= MEMORY_FROM_MAINPATH;

            ReleaseBufferLocation(pThreadLocalData);
        }
    }
    #endif //NTOS_KERNEL_RUNTIME


    return ReturnValue;
}


BOOLEAN
RtlFreeHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns a previously allocated block back to its heap.
    It is the slower version of Rtl Free Heap and does more checking and
    tagging control.

Arguments:

    HeapHandle - Supplies a pointer to the owning heap structure

    Flags - Specifies the set of flags to use in the deallocation

    BaseAddress - Supplies a pointer to the block being freed

Return Value:

    BOOLEAN - TRUE if the block was properly freed and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN Result;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T BlockSize;

#ifndef NTOS_KERNEL_RUNTIME

    USHORT TagIndex;

#endif // NTOS_KERNEL_RUNTIME
    
    HEAP_PERF_DECLARE_TIMER();

    RTL_PAGED_CODE();

    //
    //  Note that Flags has already been OR'd with Heap->ForceFlags.
    //

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case see if we should be calling the debug version to
    //  free the heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugFreeHeap( HeapHandle, Flags, BaseAddress );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Until we figure out otherwise we'll assume that this call will fail
    //

    Result = FALSE;

    try {

        HEAP_PERF_START_TIMER(Heap);
        
        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }
        
        try {

            //
            //  Backup to get a pointer to the start of the block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;
            BlockSize = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

            //
            //  Protect ourselves from mistakes by refusing to free blocks
            //  that do not have the busy bit set.
            //
            //  Also refuse to free blocks that are not eight-byte aligned.
            //  The specific mistake in this case is Office95, which likes
            //  to free a random pointer when you start Word95 from a desktop
            //  shortcut.
            //
            //  As further insurance against mistakes, check the segment index
            //  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This
            //  should fix all the dorks who have ASCII or Unicode where the
            //  heap header is supposed to be.
            //
            //  Note that this test is just opposite from the test used in
            //  Rtl Free Heap
            //

            if ((BusyBlock->Flags & HEAP_ENTRY_BUSY) &&
                (((ULONG_PTR)BaseAddress & 0x7) == 0) &&
                (BusyBlock->SegmentIndex < HEAP_MAXIMUM_SEGMENTS)) {

                //
                //  Check if this is a virtual block allocation
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                    //
                    //  This is a big virtual block allocation.  To free it
                    //  we only have to remove it from the heaps list of
                    //  virtual allocated blocks, unlock the heap, and return
                    //  the block to vm
                    //

                    VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                    RemoveEntryList( &VirtualAllocBlock->Entry );

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we need to free the tag
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        RtlpUpdateTagEntry( Heap,
                                            VirtualAllocBlock->ExtraStuff.TagIndex,
                                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT,
                                            0,
                                            VirtualFreeAction );
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    FreeSize = 0;

                    Status = RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                                        (PVOID *)&VirtualAllocBlock,
                                                        &FreeSize,
                                                        MEM_RELEASE );

                    //
                    //  Check if everything worked okay, if we had trouble freeing
                    //  the block back to vm return an error if necessary,
                    //

                    if (NT_SUCCESS( Status )) {

                        #ifndef NTOS_KERNEL_RUNTIME

                        if( IsHeapLogging( HeapHandle ) ) {

                            PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                            PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                            USHORT ReqSize = sizeof(HEAP_EVENT_FREE) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                            AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                            if(pEventHeader && pThreadLocalData) {

                                PHEAP_EVENT_FREE pHeapEvent = (PHEAP_EVENT_FREE)( (SIZE_T)pEventHeader
                                                              +(SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                                pEventHeader->Packet.Size = (USHORT) ReqSize;
                                pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_FREE;

                                pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                                pHeapEvent->Address		= (PVOID)BaseAddress;
                                pHeapEvent->Source		= MEMORY_FROM_SLOWPATH;

                                ReleaseBufferLocation(pThreadLocalData);
                            }
                        }
                        #endif //NTOS_KERNEL_RUNTIME

                        Result = TRUE;

                    } else {

                        SET_LAST_STATUS( Status );
                    }

                } else {

                    //
                    //  This block is not a big allocation so we need to
                    //  to get its size, and coalesce the blocks note that
                    //  the user mode heap does this conditionally on a heap
                    //  flag.  The coalesce function returns the newly formed
                    //  free block and the new size.
                    //

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  First in the non kernel case remove any tagging we might
                    //  have been using.  Note that the will either be in
                    //  the heap header, or in the extra block if present
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            ExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                            TagIndex = RtlpUpdateTagEntry( Heap,
                                                           ExtraStuff->TagIndex,
                                                           BusyBlock->Size,
                                                           0,
                                                           FreeAction );

                        } else {

                            TagIndex = RtlpUpdateTagEntry( Heap,
                                                           BusyBlock->SmallTagIndex,
                                                           BusyBlock->Size,
                                                           0,
                                                           FreeAction );
                        }

                    } else {

                        TagIndex = 0;
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    //
                    //  This is the size of the block we are freeing
                    //

                    FreeSize = BusyBlock->Size;

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we should coalesce on free
                    //

                    if (!(Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE)) {

    #endif // NTOS_KERNEL_RUNTIME

                        //
                        //  In kernel case and in the tested user mode case we
                        //  now coalesce free blocks
                        //

                        BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap, (PHEAP_FREE_ENTRY)BusyBlock, &FreeSize, FALSE );

    #ifndef NTOS_KERNEL_RUNTIME

                    }

    #endif // NTOS_KERNEL_RUNTIME

                    //
                    //  If the block should not be decommit then try and put it
                    //  on a free list
                    //

                    if ((FreeSize < Heap->DeCommitFreeBlockThreshold) ||
                        ((Heap->TotalFreeSize + FreeSize) < Heap->DeCommitTotalFreeThreshold)) {

                        //
                        //  Check if the block can fit on one of the dedicated free
                        //  lists
                        //

                        if (FreeSize <= (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

                            //
                            //  It can fit on a dedicated free list so insert it on
                            //

                            RtlpInsertFreeBlockDirect( Heap, (PHEAP_FREE_ENTRY)BusyBlock, (USHORT)FreeSize );

                            //
                            //  If there is a following entry then make sure the
                            //  sizes agree
                            //

                            if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                            }

                            //
                            //  Update the heap with the amount of free space
                            //  available
                            //

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  The block goes on the non dedicated free list
                            //

                            RtlpInsertFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                        }

    #ifndef NTOS_KERNEL_RUNTIME

                        //
                        //  In the non kernel case see if the there was tag and if
                        //  so then update the entry to show that it's been freed
                        //

                        if (TagIndex != 0) {

                            PHEAP_FREE_ENTRY_EXTRA FreeExtra;

                            BusyBlock->Flags |= HEAP_ENTRY_EXTRA_PRESENT;

                            FreeExtra = (PHEAP_FREE_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size) - 1;

                            FreeExtra->TagIndex = TagIndex;
                            FreeExtra->FreeBackTraceIndex = 0;

                            if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                                FreeExtra->FreeBackTraceIndex = (USHORT)RtlLogStackBackTrace();
                            }
                        }

    #endif // NTOS_KERNEL_RUNTIME

                    } else {

                        //
                        //  Otherwise the block is big enough to decommit so have a
                        //  worker routine to do the decommit
                        //

                        RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                    }

                    #ifndef NTOS_KERNEL_RUNTIME

                    if( IsHeapLogging( HeapHandle ) ) {

                        PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                        PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                        USHORT ReqSize = sizeof(HEAP_EVENT_FREE) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                        AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                        if(pEventHeader && pThreadLocalData) {

                            PHEAP_EVENT_FREE pHeapEvent = (PHEAP_EVENT_FREE)( (SIZE_T)pEventHeader
                                                          +(SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                            pEventHeader->Packet.Size = (USHORT) ReqSize;
                            pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_FREE;

                            pHeapEvent->HeapHandle	= (PVOID)HeapHandle;
                            pHeapEvent->Address		= (PVOID)BaseAddress;
                            pHeapEvent->Source		= MEMORY_FROM_SLOWPATH;

                            ReleaseBufferLocation(pThreadLocalData);
                        }
                    }

                    #endif //NTOS_KERNEL_RUNTIME

                    //
                    //  And say the free worked fine
                    //

                    Result = TRUE;
                }

            } else {

                //
                //  Not a busy block, or it's not aligned or the segment is
                //  to big, meaning it's corrupt
                //

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    RtlpRegisterOperation(Heap, BlockSize, HEAP_OP_FREE);
    HEAP_PERF_STOP_TIMER(Heap, HEAP_OP_FREE);

    return Result;
}


SIZE_T
RtlSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of the indicated block
    of heap storage.  The size only includes the number of bytes the
    original caller used to allocate the block and not any unused
    bytes at the end of the block.

Arguments:

    HeapHandle - Supplies a pointer to the heap that owns the block
        being queried

    Flags - Supplies a set of flags used to allocate the block

    BaseAddress - Supplies the address of the block being queried

Return Value:

    SIZE_T - returns the size, in bytes, of the queried block, or -1
        if the block is not in use.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    SIZE_T BusySize;

    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is the nonkernel debug version of heap
    //

#ifndef NTOS_KERNEL_RUNTIME

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSizeHeap( HeapHandle, Flags, BaseAddress );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  No lock is required since nothing is modified and nothing
    //  outside the busy block is read.  Backup to get a pointer
    //  to the heap entry
    //

    BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

    //
    //  If the block is not in use then the answer is -1 and
    //  we'll set the error status for the user mode thread
    //

    if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

        BusySize = -1;

        SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

    //
    //  Otherwise if the block is from our large allocation then
    //  we'll get the result from that routine
    //

    } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        BusySize = RtlpGetSizeOfBigBlock( BusyBlock );

    //
    //  Otherwise the block must be one that we can handle so
    //  calculate its block size and then subtract what's not being
    //  used by the caller.
    //
    //  Note: This includes the heap entry header in its calculation.  
    //

    } else {

        BusySize = (((SIZE_T)RtlpGetAllocationUnits(Heap, BusyBlock)) << HEAP_GRANULARITY_SHIFT) -
                    RtlpGetUnusedBytes(Heap, BusyBlock);
    }

    //
    //  And return to our caller
    //

    return BusySize;
}


NTSTATUS
RtlZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine zero's (or fills) in all the free blocks in a heap.
    It does not touch big allocations.

Arguments:

    HeapHandle - Supplies a pointer to the heap being zeroed

    Flags - Supplies a set of heap flags to compliment those already
        set in the heap

Return Value:

    NTSTATUS - An appropriate status code

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    BOOLEAN LockAcquired = FALSE;
    PHEAP_SEGMENT Segment;
    ULONG SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_FREE_ENTRY FreeBlock;
    SIZE_T Size;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    RTL_PAGED_CODE();

    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is the nonkernel debug version of heap
    //

#ifndef NTOS_KERNEL_RUNTIME

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugZeroHeap( HeapHandle, Flags );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Unless something happens otherwise we'll assume that we'll
    //  be successful
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Zero fill all the free blocks in all the segements
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (!Segment) {

                    continue;
                }

                UnCommittedRange = Segment->UnCommittedRanges;
                CurrentBlock = Segment->FirstEntry;

                //
                //  With the current segment we'll zoom through the
                //  blocks until we reach the end
                //

                while (CurrentBlock < Segment->LastValidEntry) {

                    Size = CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

                    //
                    //  If the block is not in use then we'll either zero
                    //  it or fill it.
                    //

                    if (!(CurrentBlock->Flags & HEAP_ENTRY_BUSY)) {

                        FreeBlock = (PHEAP_FREE_ENTRY)CurrentBlock;

                        if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                            (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                            RtlFillMemoryUlong( FreeBlock + 1,
                                                Size - sizeof( *FreeBlock ),
                                                FREE_HEAP_FILL );

                        } else {

                            RtlFillMemoryUlong( FreeBlock + 1,
                                                Size - sizeof( *FreeBlock ),
                                                0 );
                        }
                    }

                    //
                    //  If the following entry is uncommited then we need to
                    //  skip over it.  This code strongly implies that the
                    //  uncommitted range list is in perfect sync with the
                    //  blocks in the segement
                    //

                    if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                        CurrentBlock += CurrentBlock->Size;

                        //
                        //  Check if the we've reached the end of the segment
                        //  and should just break out of the while loop
                        //
                        //  "break;" would probably be more clear here
                        //

                        if (UnCommittedRange == NULL) {

                            CurrentBlock = Segment->LastValidEntry;

                        //
                        //  Otherwise skip over the uncommitted range
                        //

                        } else {

                            CurrentBlock = (PHEAP_ENTRY)
                                ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                            UnCommittedRange = UnCommittedRange->Next;
                        }

                    //
                    //  Otherwise the next block exists so advance to it
                    //

                    } else {

                        CurrentBlock += CurrentBlock->Size;
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


//
//  Local Support Routine
//

PHEAP_UNCOMMMTTED_RANGE
RtlpCreateUnCommittedRange (
    IN PHEAP_SEGMENT Segment
    )

/*++

Routine Description:

    This routine add a new uncommitted range structure to the specified heap
    segment.  This routine works by essentially doing a pop of the stack of
    unused uncommitted range structures located off the heap structure.  If
    the stack is empty then we'll create some more before doing the pop.

Arguments:

    Segment - Supplies the heap segment being modified

Return Value:

    PHEAP_UNCOMMITTED_RANGE - returns a pointer to the newly created
        uncommitted range structure

--*/

{
    NTSTATUS Status;
    PVOID FirstEntry, LastEntry;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    SIZE_T ReserveSize, CommitSize;
    PHEAP_UCR_SEGMENT UCRSegment;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the unused uncommitted range structures for
    //  the specified heap
    //

    pp = &Segment->Heap->UnusedUnCommittedRanges;

    //
    //  If the list is null then we need to allocate some more to
    //  put on the list
    //

    if (*pp == NULL) {

        //
        //  Get the next uncommitted range segment from the heap
        //

        UCRSegment = Segment->Heap->UCRSegments;

        //
        //  If there are no more uncommitted range segments or
        //  the segments commited and reserved sizes are equal (meaning
        //  it's all used up) then we need to allocate another uncommitted
        //  range segment
        //

        if ((UCRSegment == NULL) ||
            (UCRSegment->CommittedSize == UCRSegment->ReservedSize)) {

            //
            //  We'll reserve 16 pages of memory and commit at this
            //  time one page of it.
            //

            ReserveSize = PAGE_SIZE * 16;
            UCRSegment = NULL;

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              &UCRSegment,
                                              0,
                                              &ReserveSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            CommitSize = PAGE_SIZE;

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              &UCRSegment,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                           &UCRSegment,
                                           &ReserveSize,
                                           MEM_RELEASE );

                return NULL;
            }

            //
            //  Add this new segment to the front of the UCR segments
            //

            UCRSegment->Next = Segment->Heap->UCRSegments;
            Segment->Heap->UCRSegments = UCRSegment;

            //
            //  Set the segments commit and reserve size
            //

            UCRSegment->ReservedSize = ReserveSize;
            UCRSegment->CommittedSize = CommitSize;

            //
            //  Point to the first free spot in the segment
            //

            FirstEntry = (PCHAR)(UCRSegment + 1);

        } else {

            //
            //  We have an existing UCR segment with available space
            //  So now try and commit another PAGE_SIZE bytes.  When we are done
            //  FirstEntry will point to the newly committed space
            //

            CommitSize = PAGE_SIZE;
            FirstEntry = (PCHAR)UCRSegment + UCRSegment->CommittedSize;

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              &FirstEntry,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  And update the amount committed in the segment
            //

            UCRSegment->CommittedSize += CommitSize;
        }

        //
        //  At this point UCR segment exists and First Entry points to the
        //  start of the available committed space.  We'll make Last Entry
        //  point to the end of the committed space
        //

        LastEntry = (PCHAR)UCRSegment + UCRSegment->CommittedSize;

        //
        //  Now the task is to push all of this new space unto the
        //  unused uncommitted range list off the heap, then we can
        //  do a regular pop
        //

        UnCommittedRange = (PHEAP_UNCOMMMTTED_RANGE)FirstEntry;

        pp = &Segment->Heap->UnusedUnCommittedRanges;

        while ((PCHAR)UnCommittedRange < (PCHAR)LastEntry) {

            *pp = UnCommittedRange;
            pp = &UnCommittedRange->Next;
            UnCommittedRange += 1;
        }

        //
        //  Null terminate the list
        //

        *pp = NULL;

        //
        //  And have Pp point the new top of the list
        //

        pp = &Segment->Heap->UnusedUnCommittedRanges;
    }

    //
    //  At this point the Pp points to a non empty list of unused uncommitted
    //  range structures.  So we pop the list and return the top to our caller
    //

    UnCommittedRange = *pp;
    *pp = UnCommittedRange->Next;

    return UnCommittedRange;
}


//
//  Local Support Routine
//

VOID
RtlpDestroyUnCommittedRange (
    IN PHEAP_SEGMENT Segment,
    IN PHEAP_UNCOMMMTTED_RANGE UnCommittedRange
    )

/*++

Routine Description:

    This routine returns an uncommitted range structure back to the unused
    uncommitted range list

Arguments:

    Segment - Supplies any segment in the heap being modified.  Most likely but
        not necessarily the segment containing the uncommitted range structure

    UnCommittedRange - Supplies a pointer to the uncommitted range structure
        being decommissioned.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    //
    //  This routine simply does a "push" of the uncommitted range structure
    //  onto the heap's stack of unused uncommitted ranges
    //

    UnCommittedRange->Next = Segment->Heap->UnusedUnCommittedRanges;
    Segment->Heap->UnusedUnCommittedRanges = UnCommittedRange;

    //
    //  For safety sake we'll also zero out the fields in the decommissioned
    //  structure
    //

    UnCommittedRange->Address = 0;
    UnCommittedRange->Size = 0;

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
RtlpInsertUnCommittedPages (
    IN PHEAP_SEGMENT Segment,
    IN ULONG_PTR Address,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine adds the specified range to the list of uncommitted pages
    in the segment.  When done the information will hang off the segments
    uncommitted ranges list.

Arguments:

    Segment - Supplies a segment whose uncommitted range is being modified

    Address - Supplies the base (start) address for the uncommitted range

    Size - Supplies the size, in bytes, of the uncommitted range

Return Value:

    None.

--*/

{
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the front of the segments uncommitted range list
    //  The list is sorted by ascending address
    //

    pp = &Segment->UnCommittedRanges;

    //
    //  While we haven't reached the end of the list we'll zoom through
    //  trying to find a fit
    //

    while (UnCommittedRange = *pp) {

        //
        //  If address we want is less than what we're pointing at then
        //  we've found where this new entry goes
        //

        if (UnCommittedRange->Address > Address) {

            //
            //  If the new block matches right up to the existing block
            //  then we can simply backup the existing block and add
            //  to its size
            //

            if ((Address + Size) == UnCommittedRange->Address) {

                UnCommittedRange->Address = Address;
                UnCommittedRange->Size += Size;

                //
                //  Check if we need to update our notion of what the
                //  largest uncommitted range is
                //

                if (UnCommittedRange->Size > Segment->LargestUnCommittedRange) {

                    Segment->LargestUnCommittedRange = UnCommittedRange->Size;
                }

                //
                //  And return to our caller
                //

                return;
            }

            //
            //  Pp is the address of the block right before us, and *Pp is the
            //  address of the block right after us.  So now fall out to where
            //  the insertion takes place.
            //

            break;

        //
        //  Otherwise if this existing block stops right where the new block
        //  starts then we get to modify this entry.
        //

        } else if ((UnCommittedRange->Address + UnCommittedRange->Size) == Address) {

            //
            //  Remember the starting address and compute the new larger size
            //

            Address = UnCommittedRange->Address;
            Size += UnCommittedRange->Size;

            //
            //  Remove this entry from the list and then return it to the
            //  unused uncommitted list
            //

            *pp = UnCommittedRange->Next;

            RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

            //
            //  Modify the segment counters and largest size state.  The next
            //  time through the loop should hit the first case above where
            //  we'll either merge with a list following us or add a new
            //  entry
            //

            Segment->NumberOfUnCommittedRanges -= 1;

            if (Size > Segment->LargestUnCommittedRange) {

                Segment->LargestUnCommittedRange = Size;
            }

        //
        //  Otherwise we'll continue search down the list
        //

        } else {

            pp = &UnCommittedRange->Next;
        }
    }

    //
    //  If we reach this point that means we've either fallen off the end of the
    //  list, or the list is empty, or we've located the spot where a new uncommitted
    //  range structure belongs.  So allocate a new uncommitted range structure,
    //  and make sure we got one.
    //
    //  Pp is the address of the block right before us and *Pp is the address of the
    //  block right after us
    //

    UnCommittedRange = RtlpCreateUnCommittedRange( Segment );

    if (UnCommittedRange == NULL) {

        HeapDebugPrint(( "Abandoning uncommitted range (%x for %x)\n", Address, Size ));
        // HeapDebugBreak( NULL );

        return;
    }

    //
    //  Fill in the new uncommitted range structure
    //

    UnCommittedRange->Address = Address;
    UnCommittedRange->Size = Size;

    //
    //  Insert it in the list for the segment
    //

    UnCommittedRange->Next = *pp;
    *pp = UnCommittedRange;

    //
    //  Update the segment counters and notion of the largest uncommitted range
    //

    Segment->NumberOfUnCommittedRanges += 1;

    if (Size >= Segment->LargestUnCommittedRange) {

        Segment->LargestUnCommittedRange = Size;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpFindAndCommitPages (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN OUT PSIZE_T Size,
    IN PVOID AddressWanted OPTIONAL
    )

/*++

Routine Description:

    This function searches the supplied segment for an uncommitted range that
    satisfies the specified size.  It commits the range and returns a heap entry
    for the range.

Arguments:

    Heap - Supplies the heap being manipulated

    Segment - Supplies the segment being searched

    Size - Supplies the size of what we need to look for, on return it contains
        the size of what we're just found and committed.

    AddressWanted - Optionally gives an address where we would like the pages
        based.  If supplied the entry must start at this address

Return Value:

    PHEAP_FREE_ENTRY - Returns a pointer to the newly committed range that
        satisfies the given size requirement, or NULL if we could not find
        something large enough and/or based at the address wanted.

--*/

{
    NTSTATUS Status;
    PHEAP_ENTRY FirstEntry, LastEntry, PreviousLastEntry;
    PHEAP_UNCOMMMTTED_RANGE PreviousUnCommittedRange, UnCommittedRange, *pp;
    ULONG_PTR Address;
    SIZE_T Length;

    RTL_PAGED_CODE();

    //
    //  What the outer loop does is cycle through the uncommited ranges
    //  stored in in the specified segment
    //

    PreviousUnCommittedRange = NULL;
    pp = &Segment->UnCommittedRanges;

    while (UnCommittedRange = *pp) {

        //
        //  Check for the best of worlds, where the size of this current
        //  uncommitted range satisfies our size request and either the user
        //  didn't specify an address or the address match
        //

        if ((UnCommittedRange->Size >= *Size) &&
            (!ARGUMENT_PRESENT( AddressWanted ) || (UnCommittedRange->Address == (ULONG_PTR)AddressWanted ))) {

            //
            //  Calculate an address
            //

            Address = UnCommittedRange->Address;

            //
            //  Commit the memory.  If the heap doesn't have a commit
            //  routine then use the default mm supplied routine.
            //

            if (Heap->CommitRoutine != NULL) {

                Status = (Heap->CommitRoutine)( Heap,
                                                (PVOID *)&Address,
                                                Size );

            } else {

    #ifndef NTOS_KERNEL_RUNTIME

                //
                //  If we have a small uncommited range left, Adjust the size to 
                //  take that block too
                //

                if (!(RtlpDisableHeapLookaside & HEAP_COMPAT_DISABLE_LARGECACHE)
                        &&
                    ( (UnCommittedRange->Size - (*Size)) <= (((SIZE_T)Heap->DeCommitFreeBlockThreshold) << HEAP_GRANULARITY_SHIFT) )
                        &&
                    (UnCommittedRange->Size < (((SIZE_T)Heap->VirtualMemoryThreshold) << HEAP_GRANULARITY_SHIFT)) ) {

                    *Size = UnCommittedRange->Size;
                }
    #endif //  NTOS_KERNEL_RUNTIME
    
#ifdef _WIN64
                //
                // This is for Wow64 processes. This is needed to return PAGE_SIZE aligned
                // aligned sizes.
                //

                *Size = ROUND_UP_TO_POWER2 (*Size, PAGE_SIZE);
#endif

                Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                  (PVOID *)&Address,
                                                  0,
                                                  Size,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE );

            }

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  At this point we have some committed memory, with Address and Size
            //  giving us the necessary details
            //
            //  Update the number of uncommitted pages in the segment and if necessary
            //  mark down the largest uncommitted range
            //

            Segment->NumberOfUnCommittedPages -= (ULONG) (*Size / PAGE_SIZE);

            if (Segment->LargestUnCommittedRange == UnCommittedRange->Size) {

                Segment->LargestUnCommittedRange = 0;
            }

            //
            //  First entry is the start of the newly committed range
            //

            FirstEntry = (PHEAP_ENTRY)Address;

            //
            //  We want last entry to point to the last real entry before
            //  this newly committed spot.  To do this we start by
            //  setting last entry to either the first entry for the
            //  segment or (if we can do better), to right after the last
            //  uncommitted range we examined.  Either way it points to
            //  some committed range
            //

            if ((Segment->LastEntryInSegment->Flags & HEAP_ENTRY_LAST_ENTRY) &&
                (ULONG_PTR)(Segment->LastEntryInSegment + Segment->LastEntryInSegment->Size) == UnCommittedRange->Address) {

                LastEntry = Segment->LastEntryInSegment;

            } else {

                if (PreviousUnCommittedRange == NULL) {

                    LastEntry = Segment->FirstEntry;

                } else {

                    LastEntry = (PHEAP_ENTRY)(PreviousUnCommittedRange->Address +
                                              PreviousUnCommittedRange->Size);
                }

                //
                //  Now we zoom through the entries until we find the one
                //  marked last
                //

                while (!(LastEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                    PreviousLastEntry = LastEntry;
                    LastEntry += LastEntry->Size;

                    if (((PCHAR)LastEntry >= (PCHAR)Segment->LastValidEntry) || (LastEntry->Size == 0)) {

                        //
                        //  Check for the situation where the last entry in the
                        //  segment isn't marked as a last entry but does put
                        //  us right where the have a new committed range
                        //

                        if (LastEntry == (PHEAP_ENTRY)Address) {

                            LastEntry = PreviousLastEntry;

                            break;
                        }

                        HeapDebugPrint(( "Heap missing last entry in committed range near %x\n", PreviousLastEntry ));
                        HeapDebugBreak( PreviousLastEntry );

                        return NULL;
                    }
                }
            }

            //
            //  Turn off the last bit on this entry because what's following
            //  is no longer uncommitted
            //

            LastEntry->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

            //
            //  Shrink the uncommited range by the size we've committed
            //

            UnCommittedRange->Address += *Size;
            UnCommittedRange->Size -= *Size;

            //
            //  Now if the size is zero then we've committed everything that there
            //  was in the range.  Otherwise make sure the first entry of what
            //  we've just committed knows that an uncommitted range follows.
            //

            if (UnCommittedRange->Size == 0) {

                //
                //  This uncommitted range is about to vanish.  Base on if the
                //  range is the last one in the segment then we know how to
                //  mark the committed range as being last or not.
                //

                if (UnCommittedRange->Address == (ULONG_PTR)Segment->LastValidEntry) {

                    FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

                    Segment->LastEntryInSegment = FirstEntry;

                } else {

                    FirstEntry->Flags = 0;

                    Segment->LastEntryInSegment = Segment->FirstEntry;
                }

                //
                //  Remove this zero sized range from the uncommitted range
                //  list, and update the segment counters
                //

                *pp = UnCommittedRange->Next;

                RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

                Segment->NumberOfUnCommittedRanges -= 1;

            } else {

                //
                //  Otherwise the range is not empty so we know what we committed
                //  is immediately followed by an uncommitted range
                //

                FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

                Segment->LastEntryInSegment = FirstEntry;
            }

            //
            //  Update the fields in the first entry, and optional
            //  following entry.
            //

            FirstEntry->SegmentIndex = LastEntry->SegmentIndex;
            FirstEntry->Size = (USHORT)(*Size >> HEAP_GRANULARITY_SHIFT);
            FirstEntry->PreviousSize = LastEntry->Size;

            if (!(FirstEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                (FirstEntry + FirstEntry->Size)->PreviousSize = FirstEntry->Size;
            }

            //
            //  Now if we adjusted the largest uncommitted range to zero then
            //  we need to go back and find the largest uncommitted range
            //  To do that we simply zoom down the uncommitted range list
            //  remembering the largest one
            //

            if (Segment->LargestUnCommittedRange == 0) {

                UnCommittedRange = Segment->UnCommittedRanges;

                while (UnCommittedRange != NULL) {

                    if (UnCommittedRange->Size >= Segment->LargestUnCommittedRange) {

                        Segment->LargestUnCommittedRange = UnCommittedRange->Size;
                    }

                    UnCommittedRange = UnCommittedRange->Next;
                }
            }

            #ifndef NTOS_KERNEL_RUNTIME

            if(IsHeapLogging( Heap ) ) {

                PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                USHORT ReqSize = sizeof(HEAP_EVENT_EXPANSION) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                if(pEventHeader && pThreadLocalData) {


                    SIZE_T UCBytes = 0;
                    PHEAP_EVENT_EXPANSION pHeapEvent = (PHEAP_EVENT_EXPANSION)( (SIZE_T)pEventHeader
                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                    pEventHeader->Packet.Size = (USHORT) ReqSize;
                    pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_EXTEND;

                    pHeapEvent->HeapHandle		= (PVOID)Heap;
                    pHeapEvent->CommittedSize	= *Size;
                    pHeapEvent->Address			= (PVOID)FirstEntry;
                    pHeapEvent->FreeSpace		= Heap->TotalFreeSize;
                    pHeapEvent->ReservedSpace	= 0;
                    pHeapEvent->CommittedSpace  = 0;
                    pHeapEvent->NoOfUCRs		= 0;

                    UCBytes = GetUCBytes(Heap, &pHeapEvent->ReservedSpace, &pHeapEvent->NoOfUCRs);

                    pHeapEvent->ReservedSpace *= PAGE_SIZE; 
                    pHeapEvent->CommittedSpace =  pHeapEvent->ReservedSpace - UCBytes;

                    ReleaseBufferLocation(pThreadLocalData);

                } 
            }
            #endif //NTOS_KERNEL_RUNTIME

            //
            //  And return the heap entry to our caller
            //

            return (PHEAP_FREE_ENTRY)FirstEntry;

        } else {

            //
            //  Otherwise the current uncommited range is too small or
            //  doesn't have the right address so go to the next uncommitted
            //  range entry
            //

            PreviousUnCommittedRange = UnCommittedRange;
            pp = &UnCommittedRange->Next;
        }
    }

    //
    //  At this point we did not find an uncommitted range entry that satisfied
    //  our requirements either because of size and/or address.  So return null
    //  to tell the user we didn't find anything.
    //

    return NULL;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpInitializeHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UnCommittedAddress,
    IN PVOID CommitLimitAddress
    )

/*++

Routine Description:

    This routines initializes the internal structures for a heap segment.
    The caller supplies the heap and the memory for the segment being
    initialized

Arguments:

    Heap - Supplies the address of the heap owning this segment

    Segment - Supplies a pointer to the segment being initialized

    SegmentIndex - Supplies the segement index within the heap that this
        new segment is being assigned

    Flags - Supplies flags controlling the initialization of the segment
        Valid flags are:

            HEAP_SEGMENT_USER_ALLOCATED

    BaseAddress - Supplies the base address for the segment

    UnCommittedAddress - Supplies the address where the uncommited range starts

    CommitLimitAddress - Supplies the top address available to the segment

Return Value:

    BOOLEAN - TRUE if the initialization is successful and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP_ENTRY FirstEntry;
    USHORT PreviousSize, Size;
    ULONG NumberOfPages;
    ULONG NumberOfCommittedPages;
    ULONG NumberOfUnCommittedPages;
    SIZE_T CommitSize;
    ULONG NtGlobalFlag = RtlGetNtGlobalFlags();

    RTL_PAGED_CODE();

    //
    //  Compute the total number of pages possible in this segment
    //

    NumberOfPages = (ULONG) (((PCHAR)CommitLimitAddress - (PCHAR)BaseAddress) / PAGE_SIZE);

    //
    //  First entry points to the first possible segment entry after
    //  the segment header
    //

    FirstEntry = (PHEAP_ENTRY)ROUND_UP_TO_POWER2( Segment + 1,
                                                  HEAP_GRANULARITY );

    //
    //  Now if the heap is equal to the base address for the segment which
    //  it the case for the segment zero then the previous size is the
    //  heap header.  Otherwise there isn't a previous entry
    //

    if ((PVOID)Heap == BaseAddress) {

        PreviousSize = Heap->Entry.Size;

    } else {

        PreviousSize = 0;
    }

    //
    //  Compute the index size of the segment header
    //

    Size = (USHORT)(((PCHAR)FirstEntry - (PCHAR)Segment) >> HEAP_GRANULARITY_SHIFT);

    //
    //  If the first available heap entry is not committed and
    //  it is beyond the heap limit then we cannot initialize
    //

    if ((PCHAR)(FirstEntry + 1) >= (PCHAR)UnCommittedAddress) {

        if ((PCHAR)(FirstEntry + 1) >= (PCHAR)CommitLimitAddress) {

            return FALSE;
        }

        //
        //  Enough of the segment has not been committed so we
        //  will commit enough now to handle the first entry
        //

        CommitSize = (PCHAR)(FirstEntry + 1) - (PCHAR)UnCommittedAddress;

#ifdef _WIN64
        //
        // This is for Wow64 processes. This is needed to return PAGE_SIZE aligned
        // aligned sizes.
        //

        CommitSize = ROUND_UP_TO_POWER2 (CommitSize, PAGE_SIZE);
#endif


        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&UnCommittedAddress,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }

        //
        //  Because we had to commit some memory we need to adjust
        //  the uncommited address
        //

        UnCommittedAddress = (PVOID)((PCHAR)UnCommittedAddress + CommitSize);
    }

    //
    //  At this point we know there is enough memory committed to handle the
    //  segment header and one heap entry
    //
    //  Now compute the number of uncommited pages and the number of committed
    //  pages
    //

    NumberOfUnCommittedPages = (ULONG)(((PCHAR)CommitLimitAddress - (PCHAR)UnCommittedAddress) / PAGE_SIZE);
    NumberOfCommittedPages = NumberOfPages - NumberOfUnCommittedPages;

    //
    //  Initialize the heap segment heap entry.  We
    //  calculated earlier if there was a previous entry
    //

    Segment->Entry.PreviousSize = PreviousSize;
    Segment->Entry.Size = Size;
    Segment->Entry.Flags = HEAP_ENTRY_BUSY;
    Segment->Entry.SegmentIndex = SegmentIndex;

#if !NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case see if we need to capture the callers stack
    //  backtrace
    //

    if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {

        Segment->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
    }

#endif // !NTOS_KERNEL_RUNTIME

    //
    //  Now initializes the heap segment
    //

    Segment->Signature = HEAP_SEGMENT_SIGNATURE;
    Segment->Flags = Flags;
    Segment->Heap = Heap;
    Segment->BaseAddress = BaseAddress;
    Segment->FirstEntry = FirstEntry;
    Segment->LastValidEntry = (PHEAP_ENTRY)((PCHAR)BaseAddress + (NumberOfPages * PAGE_SIZE));
    Segment->NumberOfPages = NumberOfPages;
    Segment->NumberOfUnCommittedPages = NumberOfUnCommittedPages;

    //
    //  If there are uncommitted pages then we need to insert them
    //  into the uncommitted ranges list
    //

    if (NumberOfUnCommittedPages) {

        RtlpInsertUnCommittedPages( Segment,
                                    (ULONG_PTR)UnCommittedAddress,
                                    NumberOfUnCommittedPages * PAGE_SIZE );

        //
        //  Test if we successfully created the uncommitted range within the segment
        //

        if (Segment->NumberOfUnCommittedRanges == 0) {
            
            HeapDebugPrint(( "Failed to initialize a new segment (%x)\n", Segment ));

            //
            //  We don't need to decommitt the extra memory commited before because
            //  the caller for this function will do this for the entire reserved size
            //

            return FALSE;
        }
    }

    //
    //  Have the containing heap point to this segment via the specified index
    //

    Heap->Segments[ SegmentIndex ] = Segment;
    
    if (Heap->LastSegmentIndex < SegmentIndex) {
        
        Heap->LastSegmentIndex = SegmentIndex;
    }

    //
    //  Initialize the first free heap entry after the heap segment header and
    //  put it in the free list.  This first entry will be for whatever is left
    //  of the committed range
    //

    PreviousSize = Segment->Entry.Size;
    FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

    Segment->LastEntryInSegment = FirstEntry;

    FirstEntry->PreviousSize = PreviousSize;
    FirstEntry->SegmentIndex = SegmentIndex;

    RtlpInsertFreeBlock( Heap,
                         (PHEAP_FREE_ENTRY)FirstEntry,
                         (PHEAP_ENTRY)UnCommittedAddress - FirstEntry);

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Local Support Routine
//

NTSTATUS
RtlpDestroyHeapSegment (
    IN PHEAP_SEGMENT Segment
    )

/*++

Routine Description:

    This routine removes an existing heap segment.  After the call it
    is as if the segment never existed

Arguments:

    Segment - Supplies a pointer to the heap segment being destroyed

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PVOID BaseAddress;
    SIZE_T BytesToFree;

    RTL_PAGED_CODE();

    //
    //  We actually only have work to do if the segment is not
    //  user allocated.  If the segment is user allocated then
    //  we'll assume knows how to get rid of the memory
    //

    if (!(Segment->Flags & HEAP_SEGMENT_USER_ALLOCATED)) {

        BaseAddress = Segment->BaseAddress;
        BytesToFree = 0;

        //
        //  Free all the virtual memory for the segment and return
        //  to our caller.
        //

        return RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&BaseAddress,
                                          &BytesToFree,
                                          MEM_RELEASE );

    } else {

        //
        //  User allocated segments are a noop
        //

        return STATUS_SUCCESS;
    }
}



//
//  Local Support Routine
//

PHEAP_FREE_ENTRY
RtlpExtendHeap (
    IN PHEAP Heap,
    IN SIZE_T AllocationSize
    )

/*++

Routine Description:

    This routine is used to extend the amount of committed memory in a heap

Arguments:

    Heap - Supplies the heap being modified

    AllocationSize - Supplies the size, in bytes, that we need to extend the
        heap

Return Value:

    PHEAP_FREE_ENTRY - Returns a pointer to the newly created heap entry
        of the specified size, or NULL if we weren't able to extend the heap

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PHEAP_FREE_ENTRY FreeBlock;
    UCHAR SegmentIndex, EmptySegmentIndex;
    ULONG NumberOfPages;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    SIZE_T FreeSize;

    RTL_PAGED_CODE();

#ifndef NTOS_KERNEL_RUNTIME
    
    if (Heap->LargeBlocksIndex) {

        PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

        if (HeapIndex->LargeBlocksCacheMaxDepth < RtlpLargeListDepthLimit) {

            HeapIndex->LargeBlocksCacheMaxDepth += 1;
        }
    
        HeapIndex->CacheStats.Committs += 1;    
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Compute the number of pages need to hold this extension
    //  And then compute the real free, still in bytes, based on
    //  the page count
    //

    NumberOfPages = (ULONG) ((AllocationSize + PAGE_SIZE - 1) / PAGE_SIZE);
    FreeSize = NumberOfPages * PAGE_SIZE;

    //
    //  For every segment we're either going to look for an existing
    //  heap segment that we can get some pages out of or we will
    //  identify a free heap segment index where we'll try and create a new
    //  segment
    //

    EmptySegmentIndex = (UCHAR)(Heap->LastSegmentIndex + 1);
    for (SegmentIndex=0; SegmentIndex <= Heap->LastSegmentIndex; SegmentIndex++) {

#ifndef NTOS_KERNEL_RUNTIME
        if ((RtlpGetLowFragHeap(Heap) != NULL) 
                &&
            (AllocationSize > HEAP_LARGEST_LFH_BLOCK)) {

            //
            //  Search backward for large blocks. This will group the
            //  large allocations into upper segments, and small allocations 
            //  into lower index segments. It helps the fragmentation
            //

            Segment = Heap->Segments[ Heap->LastSegmentIndex - SegmentIndex ];
        
        } else {

            Segment = Heap->Segments[ SegmentIndex ];
        }
#else  //  NTOS_KERNEL_RUNTIME

        Segment = Heap->Segments[ SegmentIndex ];

#endif //  NTOS_KERNEL_RUNTIME
        //
        //  If the segment exists and number of uncommitted pages will
        //  satisfy our request and the largest uncommitted range will
        //  also satisfy our request then we'll try and segment
        //
        //  Note that this second test seems unnecessary given that
        //  the largest uncommitted range is also being tested
        //

        if ((Segment) &&
            (NumberOfPages <= Segment->NumberOfUnCommittedPages) &&
            (FreeSize <= Segment->LargestUnCommittedRange)) {

            //
            //  Looks like a good segment so try and commit the
            //  amount we need
            //

            FreeBlock = RtlpFindAndCommitPages( Heap,
                                                Segment,
                                                &FreeSize,
                                                NULL );

            //
            //  If we were successful the we will coalesce it with adjacent
            //  free blocks and put it in the free list then return the
            //  the free block
            //

            if (FreeBlock != NULL) {

                //
                //  RtlpCoalesceFreeBlocks needs the free size in heap units.
                //  We'll shift with the granularity before calling the coalesce.
                //

                FreeSize = FreeSize >> HEAP_GRANULARITY_SHIFT;

                FreeBlock = RtlpCoalesceFreeBlocks( Heap, FreeBlock, &FreeSize, FALSE );

                RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

                return FreeBlock;
            }
        }
    }

    //
    //  At this point we weren't able to get the memory from an existing
    //  heap segment so now check if we found an unused segment index
    //  and if we're allowed to grow the heap.
    //

    if ((EmptySegmentIndex != HEAP_MAXIMUM_SEGMENTS) &&
        (Heap->Flags & HEAP_GROWABLE)) {

        Segment = NULL;

        //
        //  Calculate a reserve size for the new segment, we might
        //  need to fudge it up if the allocation size we're going for
        //  right now is already beyond the default reserve size
        //

        if ((AllocationSize + PAGE_SIZE) > Heap->SegmentReserve) {

            ReserveSize = AllocationSize + PAGE_SIZE;

        } else {

            ReserveSize = Heap->SegmentReserve;
        }

#if defined(_WIN64)

        //
        //  Limit the size of the segments to 2 GBytes
        //

        #define HEAP_MAX_SEGMENT_SIZE 0x80000000

        if (ReserveSize >= HEAP_MAX_SEGMENT_SIZE) {

            ReserveSize = HEAP_MAX_SEGMENT_SIZE;
        }

#endif
        
        //
        //  Try and reserve some vm
        //

        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&Segment,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        //
        //  If we get back status no memory then we should trim back the
        //  request to something reasonable and try again.  We'll half
        //  the amount until we it either succeeds or until we reach
        //  the allocation size.  In the latter case we are really
        //  out of memory.
        //

        while ((!NT_SUCCESS( Status )) && (ReserveSize != (AllocationSize + PAGE_SIZE))) {

            ReserveSize = ReserveSize / 2;

            if( ReserveSize < (AllocationSize + PAGE_SIZE) ) {

                ReserveSize = (AllocationSize + PAGE_SIZE);
            }

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              (PVOID *)&Segment,
                                              0,
                                              &ReserveSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE );
        }

        if (NT_SUCCESS( Status )) {

            //
            //  Adjust the heap state information
            //

            Heap->SegmentReserve += ReserveSize;

            //
            //  Compute the commit size to be either the default, or if
            //  that's not big enough then make it big enough to handle
            //  this current request
            //

            if ((AllocationSize + PAGE_SIZE) > Heap->SegmentCommit) {

                CommitSize = AllocationSize + PAGE_SIZE;

            } else {

                CommitSize = Heap->SegmentCommit;
            }

#ifdef _WIN64
            //
            // This is for Wow64 processes. This is needed to return PAGE_SIZE aligned
            // aligned sizes.
            //

            CommitSize = ROUND_UP_TO_POWER2 (CommitSize, PAGE_SIZE);
#endif

            //
            //  Try and commit the memory
            //

            Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                              (PVOID *)&Segment,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            //
            //  If the commit is successful but we were not able to
            //  initialize the heap segment then still make the status
            //  and error value
            //

            if (NT_SUCCESS( Status ) &&
                !RtlpInitializeHeapSegment( Heap,
                                            Segment,
                                            EmptySegmentIndex,
                                            0,
                                            Segment,
                                            (PCHAR)Segment + CommitSize,
                                            (PCHAR)Segment + ReserveSize)) {

                Status = STATUS_NO_MEMORY;
            }

            //
            //  If we've been successful so far then we're done and we
            //  can return the first entry in the segment to our caller
            //

            if (NT_SUCCESS(Status)) {

                #ifndef NTOS_KERNEL_RUNTIME
                if(IsHeapLogging( Heap ) ) {

                    PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                    PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                    USHORT ReqSize = sizeof(HEAP_EVENT_EXPANSION) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                    AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                    if(pEventHeader && pThreadLocalData) {

                        SIZE_T UCBytes = 0;
                        PHEAP_EVENT_EXPANSION pHeapEvent = (PHEAP_EVENT_EXPANSION)( (SIZE_T)pEventHeader
                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                        pEventHeader->Packet.Size = (USHORT) ReqSize;
                        pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_EXTEND;

                        pHeapEvent->HeapHandle		= (PVOID)Heap;
                        pHeapEvent->CommittedSize	= CommitSize;
                        pHeapEvent->Address			= (PVOID)Segment->FirstEntry;
                        pHeapEvent->FreeSpace		= Heap->TotalFreeSize;
                        pHeapEvent->ReservedSpace	= 0;
                        pHeapEvent->CommittedSpace  = 0;
                        pHeapEvent->NoOfUCRs		= 0;

                        UCBytes = GetUCBytes(Heap, &pHeapEvent->ReservedSpace, &pHeapEvent->NoOfUCRs);

                        pHeapEvent->ReservedSpace *= PAGE_SIZE; 
                        pHeapEvent->CommittedSpace =  pHeapEvent->ReservedSpace - UCBytes;

                        ReleaseBufferLocation(pThreadLocalData);

                    } 
                }
                #endif //NTOS_KERNEL_RUNTIME


                return (PHEAP_FREE_ENTRY)Segment->FirstEntry;
            }

            //
            //  Otherwise either the commit or heap segment initialization failed
            //  so we'll release the memory which will also decommit it if necessary
            //

            RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                       (PVOID *)&Segment,
                                       &ReserveSize,
                                       MEM_RELEASE );
        }
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we disabled coalescing on free then what we'll
    //  do as a last resort is coalesce the heap and see if a block comes out
    //  that we can use
    //

    if (Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE) {

        FreeBlock = RtlpCoalesceHeap( Heap );

        if ((FreeBlock != NULL) && (FreeBlock->Size >= AllocationSize)) {

            return FreeBlock;
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Either the heap cannot grow or we out of resources of some type
    //  so we're going to return null
    //

    return NULL;
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceFreeBlocks (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN OUT PSIZE_T FreeSize,
    IN BOOLEAN RemoveFromFreeList
    )

/*++

Routine Description:

    This routine coalesces the free block together.

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

    FreeBlock - Supplies a pointer to the free block that we want coalesced

    FreeSize - Supplies the size, in heap units, of the free block.  On return it
        contains the size, in bytes, of the of the newly coalesced free block

    RemoveFromFreeList - Indicates if the input free block is already on a
        free list and needs to be removed to before coalescing

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the newly coalesced free block

--*/

{
    PHEAP_FREE_ENTRY FreeBlock1, NextFreeBlock;

    RTL_PAGED_CODE();

    //
    //  Point to the preceding block
    //

    FreeBlock1 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock - FreeBlock->PreviousSize);

    //
    //  Check if there is a preceding block, and if it is free, and the two sizes
    //  put together will still fit on a free lists.
    //

    if ((FreeBlock1 != FreeBlock) &&
        !(FreeBlock1->Flags & HEAP_ENTRY_BUSY) &&
        ((*FreeSize + FreeBlock1->Size) <= HEAP_MAXIMUM_BLOCK_SIZE)) {

        //
        //  We are going to merge ourselves with the preceding block
        //

        HEAPASSERT(FreeBlock->PreviousSize == FreeBlock1->Size);

        //
        //  Check if we need to remove the input block from the free list
        //

        if (RemoveFromFreeList) {

            RtlpRemoveFreeBlock( Heap, FreeBlock );

            Heap->TotalFreeSize -= FreeBlock->Size;

            //
            //  We're removed so we don't have to do it again
            //

            RemoveFromFreeList = FALSE;
        }

        //
        //  Remove the preceding block from its free list
        //

        RtlpRemoveFreeBlock( Heap, FreeBlock1 );

        //
        //  Copy over the last entry flag if necessary from what we're freeing
        //  to the preceding block
        //

        FreeBlock1->Flags = FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY;

        if( FreeBlock1->Flags & HEAP_ENTRY_LAST_ENTRY ) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[FreeBlock1->SegmentIndex];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock1;
        }

        //
        //  Point to the preceding block, and adjust the sizes for the
        //  new free block.  It is the total of both blocks.
        //

        FreeBlock = FreeBlock1;

        *FreeSize += FreeBlock1->Size;

        Heap->TotalFreeSize -= FreeBlock1->Size;

        FreeBlock->Size = (USHORT)*FreeSize;

        //
        //  Check if we need to update the previous size of the next
        //  entry
        //

        if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

            ((PHEAP_ENTRY)FreeBlock + *FreeSize)->PreviousSize = (USHORT)*FreeSize;
        }
    }

    //
    //  Check if there is a following block.
    //

    if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

        //
        //  There is a following block so now get a pointer to it
        //  and check if it is free and if putting the two blocks together
        //  still fits on a free list
        //

        NextFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + *FreeSize);

        if (!(NextFreeBlock->Flags & HEAP_ENTRY_BUSY) &&
            ((*FreeSize + NextFreeBlock->Size) <= HEAP_MAXIMUM_BLOCK_SIZE)) {

            //
            //  We are going to merge ourselves with the following block
            //

            HEAPASSERT(*FreeSize == NextFreeBlock->PreviousSize);

            //
            //  Check if we need to remove the input block from the free list
            //

            if (RemoveFromFreeList) {

                RtlpRemoveFreeBlock( Heap, FreeBlock );

                Heap->TotalFreeSize -= FreeBlock->Size;
            }

            //
            //  Copy up the last entry flag if necessary from the following
            //  block to our input block
            //

            FreeBlock->Flags = NextFreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY;

            if( FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY ) {

                PHEAP_SEGMENT Segment;

                Segment = Heap->Segments[FreeBlock->SegmentIndex];
                Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock;
            }

            //
            //  Remove the following block from its free list
            //

            RtlpRemoveFreeBlock( Heap, NextFreeBlock );

            //
            //  Adjust the size for the newly combined block
            //

            *FreeSize += NextFreeBlock->Size;

            Heap->TotalFreeSize -= NextFreeBlock->Size;

            FreeBlock->Size = (USHORT)*FreeSize;

            //
            //  Check if we need to update the previous size of the next block
            //

            if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                ((PHEAP_ENTRY)FreeBlock + *FreeSize)->PreviousSize = (USHORT)*FreeSize;
            }
        }
    }

    //
    //  And return the free block to our caller
    //

    return FreeBlock;
}


//
//  Declared in heappriv.h
//

VOID
RtlpDeCommitFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    )

/*++

Routine Description:

    This routine takes a free block and decommits it.  This is usually called
    because the block is beyond the decommit threshold

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

    FreeBlock - Supplies a pointer to the block being decommitted

    FreeSize - Supplies the size, in heap units, of the free block being decommitted

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG_PTR DeCommitAddress;
    SIZE_T DeCommitSize;
    USHORT LeadingFreeSize, TrailingFreeSize;
    PHEAP_SEGMENT Segment;
    PHEAP_FREE_ENTRY LeadingFreeBlock, TrailingFreeBlock;
    PHEAP_ENTRY LeadingBusyBlock, TrailingBusyBlock;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_FREE_ENTRY LeadingBlockToDecommit = NULL, TrailingBlockToDecommit = NULL;

    RTL_PAGED_CODE();

    //
    //  If the heap has a user specified decommit routine then we won't really
    //  decommit anything instead we'll call a worker routine to chop it up
    //  into pieces that will fit on the free lists
    //

    if (Heap->CommitRoutine != NULL) {

        RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );      

        return;
    }

    //
    //  Get a pointer to the owning segment
    //

    Segment = Heap->Segments[ FreeBlock->SegmentIndex ];

    //
    //  The leading busy block identifies the preceding in use block before
    //  what we are trying to decommit.  It is only used if what we are trying
    //  decommit is right on a page boundary and then it is the block right
    //  before us if it exists.
    //
    //  The leading free block is used to identify whatever space is needed
    //  to round up the callers specified address to a page address.  If the
    //  caller already gave us a page aligned address then the free block
    //  address is identical to what the caller supplied.
    //

    LeadingBusyBlock = NULL;
    LeadingFreeBlock = FreeBlock;

    //
    //  Make sure the block we are trying to decommit start on the next full
    //  page boundary.  The leading free size is the size of whatever it takes
    //  to round up the free block to the next page specified in units of
    //  heap entries.
    //

    DeCommitAddress = ROUND_UP_TO_POWER2( LeadingFreeBlock, PAGE_SIZE );
    LeadingFreeSize = (USHORT)((PHEAP_ENTRY)DeCommitAddress - (PHEAP_ENTRY)LeadingFreeBlock);

    //
    //  If we leading free size only has space for one heap entry then we'll
    //  bump it up to include the next page, because we don't want to leave
    //  anything that small laying around.  Otherwise if we have a preceding
    //  block and the leading free size is zero then identify the preceding
    //  block as the leading busy block
    //

    if (LeadingFreeSize == 1) {

        DeCommitAddress += PAGE_SIZE;
        LeadingFreeSize += PAGE_SIZE >> HEAP_GRANULARITY_SHIFT;

    } else if (LeadingFreeBlock->PreviousSize != 0) {

        if (DeCommitAddress == (ULONG_PTR)LeadingFreeBlock) {

            LeadingBusyBlock = (PHEAP_ENTRY)LeadingFreeBlock - LeadingFreeBlock->PreviousSize;
        }
    }

    //
    //  The trailing busy block identifies the block immediately after the one
    //  we are trying to decommit provided what we are decommitting ends right
    //  on a page boundary otherwise the trailing busy block stays null and
    //  the trailing free block value is used.
    //

    TrailingBusyBlock = NULL;
    TrailingFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + FreeSize);

    //
    //  Make sure the block we are trying to decommit ends on a page boundary.
    //
    //  And compute how many heap entries we had to backup to make it land on a
    //  page boundary.
    //

    DeCommitSize = ROUND_DOWN_TO_POWER2( (ULONG_PTR)TrailingFreeBlock, PAGE_SIZE );
    TrailingFreeSize = (USHORT)((PHEAP_ENTRY)TrailingFreeBlock - (PHEAP_ENTRY)DeCommitSize);

    //
    //  If the trailing free size is exactly one heap in size then we will
    //  nibble off a bit more from the decommit size because free block of
    //  exactly one heap entry in size are useless.  Otherwise if we actually
    //  ended on a page boundary and there is a block after us then indicate
    //  that we have a trailing busy block
    //

    if (TrailingFreeSize == (sizeof( HEAP_ENTRY ) >> HEAP_GRANULARITY_SHIFT)) {

        DeCommitSize -= PAGE_SIZE;
        TrailingFreeSize += PAGE_SIZE >> HEAP_GRANULARITY_SHIFT;

    } else if ((TrailingFreeSize == 0) && !(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

        TrailingBusyBlock = (PHEAP_ENTRY)TrailingFreeBlock;
    }

    //
    //  Now adjust the trailing free block to compensate for the trailing free size
    //  we just computed.
    //

    TrailingFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)TrailingFreeBlock - TrailingFreeSize);

    //
    //  Right now DeCommit size is really a pointer.  If it points at is beyond
    //  the decommit address then make the size really be just the byte count
    //  to decommit.  Otherwise the decommit size is zero.
    //

    if (DeCommitSize > DeCommitAddress) {

        DeCommitSize -= DeCommitAddress;

    } else {

        DeCommitSize = 0;
    }

    //
    //  Now check if we still have something to decommit
    //

    if (DeCommitSize != 0) {

#ifndef NTOS_KERNEL_RUNTIME

        //
        //  We do not try to push the large block to the 
        //  cache if it already has uncommited ranges arround
        //

        if ( (FreeBlock->PreviousSize != 0) 
                && 
             !(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY) ) {
            
            if (Heap->LargeBlocksIndex == NULL) {

                Heap->u2.DecommitCount += 1;

                if ( (Heap->u2.DecommitCount == HEAP_ACTIVATE_CACHE_THRESHOLD) &&
                     (Heap->Flags & HEAP_GROWABLE) &&
                     !(RtlpDisableHeapLookaside & HEAP_COMPAT_DISABLE_LARGECACHE) ) {

                    RtlpInitializeListIndex( Heap );
                }

            } else {

                PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

                //
                //  Check if the cache is locked for flushing
                //

                if ((HeapIndex->LargeBlocksCacheSequence != 0)
                        &&
                    ( (LeadingFreeBlock->PreviousSize != 0)
                            ||
                      (TrailingFreeSize != 0) ) ) {

                    if (HeapIndex->LargeBlocksCacheDepth < HeapIndex->LargeBlocksCacheMaxDepth) {

                        //
                        //  There is nothing left to decommit to take our leading free block
                        //  and put it on a free list
                        //

                        RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
                        RtlpCheckLargeCache(Heap);

                        return;

                        //
                        //  Check whether the block being deleted is the only one 
                        //  between two uncommitted ranges. If no, we'll decommit the largest block from the list
                        //

                    } else {

                        PLIST_ENTRY Head, Next;
                        PHEAP_FREE_ENTRY LargestFreeBlock;

                        //
                        //  we have too many blocks outside. We need to decommit one.
                        //  To reduce the virtual address fragmentation we nned to decommit the
                        //  largest block available
                        //

                        Head = &Heap->FreeLists[ 0 ];                         
                        Next = Head->Blink;

                        if (Head != Next) {

                            //
                            //  Lock the cache operations
                            //

                            LargestFreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                            //
                            //  Even if the we found a larger block in the list, because of a wrong
                            //  alignment it can produce less uncommitted space. We'll try to free the larges one instead
                            //  the current block only if the size is significant bigger (+ one page)
                            //

                            if (LargestFreeBlock->Size > (FreeSize + (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT))) {

                                //
                                //  If we have a larger block into the list
                                //  we'll insert this one into the list and we'll decommitt
                                //  the largest one
                                //

                                RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
                                RtlpFlushLargestCacheBlock(Heap);
                                RtlpCheckLargeCache(Heap);

                                return;
                            }
                        }
                    }
                }

                HeapIndex->CacheStats.Decommitts += 1;    
//            HeapDebugPrint(("Decommitting size %ld\n", DeCommitSize));
            }
        }
#endif //  NTOS_KERNEL_RUNTIME

        //
        //  Before freeing the memory to MM we have to be sure we can create 
        //  a PHEAP_UNCOMMMTTED_RANGE later. So we do it right now
        //

        UnCommittedRange = RtlpCreateUnCommittedRange(Segment);

        if (UnCommittedRange == NULL) {
            
            HeapDebugPrint(( "Failing creating uncommitted range (%x for %x)\n", DeCommitAddress, DeCommitSize ));

            //
            //  We weren't successful in the decommit so now simply
            //  add the leading free block to the free list
            //

            RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );

            return;
        }

        //
        //  Decommit the memory
        //
        
        Status = RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                                            (PVOID *)&DeCommitAddress,
                                            &DeCommitSize,
                                            MEM_DECOMMIT );

        //
        //  Push back the UnCommittedRange structure. Now the insert cannot fail
        //

        RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

        if (NT_SUCCESS( Status )) {

            //
            //  Insert information regarding the pages we just decommitted
            //  to the lsit of uncommited pages in the segment
            //

            RtlpInsertUnCommittedPages( Segment,
                                        DeCommitAddress,
                                        DeCommitSize );
            //
            //  Adjust the segments count of uncommitted pages
            //

            Segment->NumberOfUnCommittedPages += (ULONG)(DeCommitSize / PAGE_SIZE);

            //
            //  If we have a leading free block then mark its proper state
            //  update the heap, and put it on the free list
            //

            if (LeadingFreeSize != 0) {

                SIZE_T TempSize;

                LeadingFreeBlock->Flags = HEAP_ENTRY_LAST_ENTRY;
                TempSize = LeadingFreeBlock->Size = LeadingFreeSize;

                Segment->LastEntryInSegment = (PHEAP_ENTRY)LeadingFreeBlock;

                LeadingFreeBlock = RtlpCoalesceFreeBlocks( Heap, 
                                                           LeadingFreeBlock, 
                                                           &TempSize,
                                                           FALSE );

                if (LeadingFreeBlock->Size < Heap->DeCommitFreeBlockThreshold) {

                    Heap->TotalFreeSize += LeadingFreeBlock->Size;
                    RtlpInsertFreeBlockDirect( Heap, LeadingFreeBlock, LeadingFreeBlock->Size );

                } else {

                    LeadingBlockToDecommit = LeadingFreeBlock;
                }

            //
            //  Otherwise if we actually have a leading busy block then
            //  make sure the busy block knows we're uncommitted
            //

            } else if (LeadingBusyBlock != NULL) {

                LeadingBusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;

                Segment->LastEntryInSegment = LeadingBusyBlock;

            } else if ((Segment->LastEntryInSegment >= (PHEAP_ENTRY)DeCommitAddress)
                            &&
                       ((PCHAR)Segment->LastEntryInSegment < ((PCHAR)DeCommitAddress + DeCommitSize))) {

                     Segment->LastEntryInSegment = Segment->FirstEntry;
            }

            //
            //  If there is a trailing free block then sets its state,
            //  update the heap, and insert it on a free list
            //

            if (TrailingFreeSize != 0) {

                SIZE_T TempSize;
                
                TrailingFreeBlock->PreviousSize = 0;
                TrailingFreeBlock->SegmentIndex = Segment->Entry.SegmentIndex;
                TrailingFreeBlock->Flags = 0;
                TempSize = TrailingFreeBlock->Size = TrailingFreeSize;

                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)TrailingFreeBlock + TrailingFreeSize))->PreviousSize = (USHORT)TrailingFreeSize;

                TrailingFreeBlock = RtlpCoalesceFreeBlocks( Heap, 
                                                            TrailingFreeBlock, 
                                                            &TempSize,
                                                            FALSE );
                
                if (TrailingFreeBlock->Size < Heap->DeCommitFreeBlockThreshold) {

                    RtlpInsertFreeBlockDirect( Heap, TrailingFreeBlock, TrailingFreeBlock->Size );
                    Heap->TotalFreeSize += TrailingFreeBlock->Size;

                } else {

                    TrailingBlockToDecommit = TrailingFreeBlock;
                }

            //
            //  Otherwise if we actually have a succeeding block then
            //  make it know we are uncommitted
            //

            } else if (TrailingBusyBlock != NULL) {

                TrailingBusyBlock->PreviousSize = 0;
            }

            #ifndef NTOS_KERNEL_RUNTIME

            if( IsHeapLogging( Heap ) ) {

                PPERFINFO_TRACE_HEADER pEventHeader = NULL;
                PTHREAD_LOCAL_DATA pThreadLocalData = NULL;
                USHORT ReqSize = sizeof(HEAP_EVENT_CONTRACTION) + FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);

                AcquireBufferLocation(&pEventHeader, &pThreadLocalData,&ReqSize);

                if(pEventHeader && pThreadLocalData) {

                    SIZE_T UCBytes = 0;
                    PHEAP_EVENT_CONTRACTION pHeapEvent = (PHEAP_EVENT_CONTRACTION)( (SIZE_T)pEventHeader
                                + (SIZE_T)FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data ));

                    pEventHeader->Packet.Size = (USHORT) ReqSize;
                    pEventHeader->Packet.HookId = PERFINFO_LOG_TYPE_HEAP_CONTRACT;

                    pHeapEvent->HeapHandle			= (PVOID)Heap;
                    pHeapEvent->DeCommitAddress		= (PVOID)DeCommitAddress;
                    pHeapEvent->DeCommitSize		= DeCommitSize;
                    pHeapEvent->FreeSpace			= Heap->TotalFreeSize;
                    pHeapEvent->ReservedSpace		= 0;
                    pHeapEvent->CommittedSpace		= 0;
                    pHeapEvent->NoOfUCRs			= 0;

                    UCBytes = GetUCBytes(Heap, &pHeapEvent->ReservedSpace, &pHeapEvent->NoOfUCRs);

                    pHeapEvent->ReservedSpace *= PAGE_SIZE; 
                    pHeapEvent->CommittedSpace =  pHeapEvent->ReservedSpace - UCBytes;

                    ReleaseBufferLocation(pThreadLocalData);

                }
            }
            #endif // NTOS_KERNEL_RUNTIME


        } else {

            //
            //  We weren't successful in the decommit so now simply
            //  add the leading free block to the free list
            //

            RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
        }

    } else {

        //
        //  There is nothing left to decommit to take our leading free block
        //  and put it on a free list
        //

        RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
    }

#ifndef NTOS_KERNEL_RUNTIME

    if ( (LeadingBlockToDecommit != NULL)
            || 
         (TrailingBlockToDecommit != NULL)){

        PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;
        LONG PreviousSequence = 0;

        if (HeapIndex) {
            
            PreviousSequence = HeapIndex->LargeBlocksCacheSequence;

            //
            //  Lock the cache for the next two decommits
            //

            HeapIndex->LargeBlocksCacheSequence = 0;
        }

#endif // NTOS_KERNEL_RUNTIME

        if (LeadingBlockToDecommit) {

            RtlpDeCommitFreeBlock( Heap,
                                   LeadingBlockToDecommit,
                                   LeadingBlockToDecommit->Size
                                 );
        }

        if (TrailingBlockToDecommit) {

            RtlpDeCommitFreeBlock( Heap,
                                    TrailingBlockToDecommit,
                                    TrailingBlockToDecommit->Size
                                 );
        }

#ifndef NTOS_KERNEL_RUNTIME

        if (HeapIndex) {

            //
            //  Unlock the large block cache
            //

            HeapIndex->LargeBlocksCacheSequence = PreviousSequence;
        }
    }
    

    //
    //  At this point the free block to decommit is inserted 
    //  into the free lists. So it's safe now to check the large
    //  block list and flush what is not longer necessary.
    //
    
    RtlpCheckLargeCache(Heap);

#endif // NTOS_KERNEL_RUNTIME

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

VOID
RtlpInsertFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    )

/*++

Routine Description:

    This routines take a piece of committed memory and adds to the
    the appropriate free lists for the heap.  If necessary this
    routine will divide up the free block to sizes that fit
    on the free list


Arguments:

    Heap - Supplies a pointer to the owning heap

    FreeBlock - Supplies a pointer to the block being freed

    FreeSize - Supplies the size, in bytes, of the block being freed

Return Value:

    None.

--*/

{
    USHORT PreviousSize, Size;
    UCHAR Flags;
    UCHAR SegmentIndex;
    PHEAP_SEGMENT Segment;

    RTL_PAGED_CODE();

    //
    //  Get the size of the previous block, the index of the segment
    //  containing this block, and the flags specific to the block
    //

    PreviousSize = FreeBlock->PreviousSize;

    SegmentIndex = FreeBlock->SegmentIndex;
    Segment = Heap->Segments[ SegmentIndex ];

    Flags = FreeBlock->Flags;

    //
    //  Adjust the total amount free in the heap
    //

    Heap->TotalFreeSize += FreeSize;

    //
    //  Now, while there is still something left to add to the free list
    //  we'll process the information
    //

    while (FreeSize != 0) {

        //
        //  If the size is too big for our free lists then we'll
        //  chop it down.
        //

        if (FreeSize > (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

            Size = HEAP_MAXIMUM_BLOCK_SIZE;

            //
            //  This little adjustment is so that we don't have a remainder
            //  that is too small to be useful on the next iteration
            //  through the loop
            //

            if (FreeSize == ((ULONG)HEAP_MAXIMUM_BLOCK_SIZE + 1)) {

                Size -= 16;
            }

            //
            //  Guarantee that Last entry does not get set in this
            //  block.
            //

            FreeBlock->Flags = 0;

        } else {

            Size = (USHORT)FreeSize;

            //
            //  This could propagate the last entry flag
            //

            FreeBlock->Flags = Flags;
        }

        //
        //  Update the block sizes and then insert this
        //  block into a free list
        //

        FreeBlock->PreviousSize = PreviousSize;
        FreeBlock->SegmentIndex = SegmentIndex;
        FreeBlock->Size = Size;

        RtlpInsertFreeBlockDirect( Heap, FreeBlock, Size );

        //
        //  Note the size of what we just freed, and then update
        //  our state information for the next time through the
        //  loop
        //

        PreviousSize = Size;

        FreeSize -= Size;

        //
        //  Update the last entry in segment, if necessary
        //

        if (FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[ FreeBlock->SegmentIndex ];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock;
        }
        
        FreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + Size);

        //
        //  Check if we're done with the free block based on the
        //  segment information, otherwise go back up and check size
        //  Note that is means that we can get called with a very
        //  large size and still work.
        //

        if ((PHEAP_ENTRY)FreeBlock >= Segment->LastValidEntry) {

            return;
        }
    }

    //
    //  If the block we're freeing did not think it was the last entry
    //  then tell the next block our real size.
    //

    if (!(Flags & HEAP_ENTRY_LAST_ENTRY)) {

        FreeBlock->PreviousSize = PreviousSize;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

PHEAP_ENTRY_EXTRA
RtlpGetExtraStuffPointer (
    PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine calculates where the extra stuff record will be given
    the busy block and returns a pointer to it.  The caller must have
    already checked that the entry extra field is present

Arguments:

    BusyBlock - Supplies the busy block whose extra stuff we are seeking

Return Value:

    PHEAP_ENTRY_EXTRA - returns a pointer to the extra stuff record.

--*/

{
    ULONG AllocationIndex;

    RTL_PAGED_CODE();

    //
    //  On big blocks the extra stuff is automatically part of the
    //  block
    //

    if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

        return &VirtualAllocBlock->ExtraStuff;

    } else {

        //
        //  On non big blocks the extra stuff follows immediately after
        //  the allocation itself.
        //
        //  We do some funny math here because the busy block
        //  stride is 8 bytes we know we can stride it by its
        //  index minus one to get to the end of the allocation
        //

        AllocationIndex = BusyBlock->Size;

        return (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);
    }
}


//
//  Declared in heappriv.h
//

SIZE_T
RtlpGetSizeOfBigBlock (
    IN PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of the big allocation block

Arguments:

    BusyBlock - Supplies a pointer to the block being queried

Return Value:

    SIZE_T - Returns the size, in bytes, that was allocated to the big
        block

--*/

{
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the block header itself
    //

    VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

    //
    //  The size allocated to the block is actually the difference between the
    //  commit size stored in the virtual alloc block and the size stored in
    //  in the block.
    //

    return VirtualAllocBlock->CommitSize - BusyBlock->Size;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckBusyBlockTail (
    IN PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine checks to see if the bytes beyond the user specified
    allocation have been modified.  It does this by checking for a tail
    fill pattern

Arguments:

    BusyBlock - Supplies the heap block being queried

Return Value:

    BOOLEAN - TRUE if the tail is still okay and FALSE otherwise

--*/

{
    PCHAR Tail;
    SIZE_T Size, cbEqual;

    RTL_PAGED_CODE();

    //
    //  Compute the user allocated size of the input heap block
    //

    if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        Size = RtlpGetSizeOfBigBlock( BusyBlock );

    } else {

        Size = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) - BusyBlock->UnusedBytes;
    }

    //
    //  Compute a pointer to the tail of the input block.  This would
    //  be the space right after the user allocated portion
    //

    Tail = (PCHAR)(BusyBlock + 1) + Size;

    //
    //  Check if the tail fill pattern is still there
    //

    cbEqual = RtlCompareMemory( Tail,
                                CheckHeapFillPattern,
                                CHECK_HEAP_TAIL_SIZE );

    //
    //  If the number we get back isn't equal to the tail size then
    //  someone modified the block beyond its user specified allocation
    //  size
    //

    if (cbEqual != CHECK_HEAP_TAIL_SIZE) {

        //
        //  Do some debug printing
        //

        HeapDebugPrint(( "Heap block at %p modified at %p past requested size of %lx\n",
                         BusyBlock,
                         Tail + cbEqual,
                         Size ));

        HeapDebugBreak( BusyBlock );

        //
        //  And tell our caller there was an error
        //

        return FALSE;

    } else {

        //
        //  And return to our caller that the tail is fine
        //

        return TRUE;
    }
}

//
//  Nondedicated free list optimization
//  The index is active only in the USER MODE HEAP
//

#ifndef NTOS_KERNEL_RUNTIME
    
//
//  RtlpSizeToAllocIndex is used to convert from a size (in heap allocation units)
//  to an index into the array
//

#define RtlpSizeToAllocIndex(HI,S)     \
    (( (ULONG)((S) - HEAP_MAXIMUM_FREELISTS) >= (HI)->ArraySize) ? ((HI)->ArraySize - 1) :   \
        ((S) - HEAP_MAXIMUM_FREELISTS))


VOID 
RtlpInitializeListIndex(
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine initialize the index for large blocks. It can be called any time
    during the execution. The function assumes the heap lock is acquired.

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

Return Value:

    None

--*/

{
    PHEAP_INDEX HeapIndex = NULL;
    ULONG i;
    SIZE_T CommitSize;
    NTSTATUS Status;
    ULONG_PTR ArraySize;
    UINT64 _HeapPerfStartTimer;                         
    
    //
    //  Check if we already have an index 
    //

    if ( Heap->LargeBlocksIndex == NULL) {

        //
        //  Determine the number of entries into the index.
        //  For a heap with high usage, the most of blocks into the 
        //  non-dedicated list should be smaller than block 
        //  decommit threshold + one page
        //
        
        ArraySize = Heap->DeCommitFreeBlockThreshold + (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT) - HEAP_MAXIMUM_FREELISTS;

        //
        //  The statement bellow is just a sanity round up of the array size.
        //  Basically for current heap constants this is not necessary:
        //      DeCommitFreeBlockThreshold == 512
        //      PAGE_SIZE >> HEAP_GRANULARITY_SHIFT == 512
        //          So the ArraySize == 1024 is 32 aligned
        //

        ArraySize = ROUND_UP_TO_POWER2( ArraySize, 32 );

        //
        //  Determine the amount of memory we need from OS
        //

        CommitSize = sizeof(HEAP_INDEX) +  
                     ArraySize * sizeof(PHEAP_FREE_ENTRY) + 
                     ArraySize / 8;


        CommitSize = ROUND_UP_TO_POWER2( CommitSize, PAGE_SIZE );
        
        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&HeapIndex,
                                          0,
                                          &CommitSize,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE 
                                        );
        
        if ( NT_SUCCESS(Status) ) {

            //
            //  Here the allocation succeed. We need to
            //  initialize the index structures
            //

            PLIST_ENTRY Head, Next;
            
            //
            //  Initialize the array fields
            //

            HeapIndex->ArraySize = (ULONG)ArraySize;
            HeapIndex->VirtualMemorySize = (ULONG)CommitSize;
            
            //
            //  The FreeListHints will be immediately after the index structure
            //

            HeapIndex->FreeListHints = (PHEAP_FREE_ENTRY *)((PUCHAR)HeapIndex + sizeof(HEAP_INDEX));

            //
            //  The bitmap is placed after the array with hints to
            //  free blocks
            //

            HeapIndex->u.FreeListsInUseBytes = (PUCHAR)(HeapIndex->FreeListHints + ArraySize);
            
            HeapIndex->LargeBlocksCacheDepth = 0;
            if (RtlpDisableHeapLookaside & HEAP_COMPAT_DISABLE_LARGECACHE) {

                HeapIndex->LargeBlocksCacheSequence = 0;
            
            } else {

                HeapIndex->LargeBlocksCacheSequence = 1;
            }
            
            //
            //  Save the original non-dedicated list from the heap
            //

            Head = &Heap->FreeLists[ 0 ];                  
            Next = Head->Flink;                     
            
            //
            //  Walk the non-dedicated list and insert each block found
            //  there into the new structures
            //

            while (Head != Next) {
                
                PHEAP_FREE_ENTRY FreeEntry;                                               
                ULONG AllocIndex;

                //
                //  Get the free block from the old list
                //

                FreeEntry = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                //
                //  Save the next link. The insertion into the new 
                //  structure will destroy it
                //

                Next = Next->Flink;

                //
                //  Insert the block into the large blocks array
                //
                
                AllocIndex = RtlpSizeToAllocIndex( HeapIndex, FreeEntry->Size );

                if ( !HeapIndex->FreeListHints[ AllocIndex ] ) {

                    HeapIndex->FreeListHints[ AllocIndex ] = FreeEntry;
                    SET_INDEX_BIT( HeapIndex, AllocIndex );
                }

                if (AllocIndex == (HeapIndex->ArraySize - 1)) {

                    HeapIndex->LargeBlocksCacheDepth += 1;
                }
            }
            
            HeapIndex->LargeBlocksCacheMaxDepth = HeapIndex->LargeBlocksCacheDepth;
            HeapIndex->LargeBlocksCacheMinDepth = HeapIndex->LargeBlocksCacheDepth;
            
            HeapIndex->CacheStats.Committs = 0;
            HeapIndex->CacheStats.Decommitts = 0;
            HeapIndex->CacheStats.LargestDepth = HeapIndex->LargeBlocksCacheDepth;
            HeapIndex->CacheStats.LargestRequiredDepth = 0;
            
            NtQueryPerformanceCounter( (PLARGE_INTEGER)&_HeapPerfStartTimer , (PLARGE_INTEGER)&HeapIndex->PerfData.CountFrequence);

            //
            //  Initialize the LargeBlocksIndex with the new created structure
            //

            Heap->LargeBlocksIndex = HeapIndex;

            //
            //  validate the index if HEAP_VALIDATE_INDEX is defined
            //  (Debug - test only)
            //
            
            RtlpValidateNonDedicatedList( Heap );
        }
    }
}


PLIST_ENTRY
RtlpFindEntry (
    IN PHEAP Heap,
    IN ULONG Size
    )

/*++

Routine Description:
    
    The function search the first block into the non-dedicated list
    greater or equal with the given size.

Arguments:

    Heap - Supplies a pointer to the heap being manipulated
    
    Size - The size in heap units we're looking for

Return Value:

    Return the list entry for the block which match the search criteria.
    If the search fails simple returns the Non-dedicated list header.

--*/

{
    PHEAP_INDEX HeapIndex = NULL;
    ULONG LookupBitmapUlongIndex;
    ULONG LastValidIndex;
    ULONG CrtBitmapUlong;
    PULONG UlongArray;
    PHEAP_FREE_ENTRY FreeEntry = NULL;
    PLIST_ENTRY Head, Next;
    PHEAP_FREE_ENTRY LastBlock, FirstBlock;
    ULONG AllocIndex;

    Head = &Heap->FreeLists[0];
    Next = Head->Blink;

    //
    //  Check if the list is empty. Return the list head if it is.
    //

    if (Head == Next) {

        return Head;
    }
    
    //
    //  Compare if the largest block into the free list is smaller
    //  than the requested size. 
    //

    LastBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

    if (LastBlock->Size < Size) {

        //
        //  we don't have a block available for our request
        //

        return Head;
    }

    //
    //  If the block is smaller or equal with the first free block we'll
    //  return the first block into the list w/o searching the index
    //

    FirstBlock = CONTAINING_RECORD( Head->Flink, HEAP_FREE_ENTRY, FreeList );

    if (Size <= FirstBlock->Size) {

        //
        //  Return the first block then.
        //

        return Head->Flink;
    }

    //
    //  At this point we have a block that must be somewhere in
    //  the middle of the list. We'll use the index to locate it.
    //

    HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

    AllocIndex = RtlpSizeToAllocIndex(HeapIndex, Size);

    //
    //  We'll try first into the last sublist
    //

    if ( AllocIndex == (HeapIndex->ArraySize - 1) ) {

        FreeEntry = HeapIndex->FreeListHints[ AllocIndex ];

        Next = &FreeEntry->FreeList;

        while ( Head != Next ) {

            FreeEntry = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
            
            if (FreeEntry->Size >= Size) {

                return &FreeEntry->FreeList;
            }

            Next = Next->Flink;
        }
    }

    //
    //  Calculate the starting index into the bitmap array
    //

    LookupBitmapUlongIndex = AllocIndex >> 5;

    //
    //  Determine the last index into the ULONG bitmap where the
    //  lookup must stop
    //

    LastValidIndex = (HeapIndex->ArraySize >> 5) - 1;

    UlongArray = HeapIndex->u.FreeListsInUseUlong + LookupBitmapUlongIndex;

    CrtBitmapUlong = *UlongArray;
    
    //
    //  Mask off the bits in the first ULONG that represent allocations
    //  smaller than we need.
    //

    CrtBitmapUlong = CrtBitmapUlong & ~((1 << ((ULONG) Size & 0x1f)) - 1);

    // 
    //  Loop through the ULONG bitmap until we'll find something
    //  not empty
    //

    while ( !CrtBitmapUlong &&
            (LookupBitmapUlongIndex <= LastValidIndex) ) {
        
        CrtBitmapUlong = *(++UlongArray);
        LookupBitmapUlongIndex++;
    }

    //
    //  Sanity checking if we found something.
    //  The test for smaller block and larger block should 
    //  guarantee we found something in the loop above
    //

    if ( !CrtBitmapUlong ) {

        HeapDebugPrint(( "Index not found into the bitmap %08lx\n", Size ));
//        DbgBreakPoint();

        return Head;
    }

    //
    //  Determine the position within bitmap where the bit is set.
    //  This is the index into the hints array
    //

    LookupBitmapUlongIndex = (LookupBitmapUlongIndex << 5) + 
        RtlFindFirstSetRightMember( CrtBitmapUlong );

    //
    //  Return the list entry for the block we found
    //

    FreeEntry = HeapIndex->FreeListHints[ LookupBitmapUlongIndex ];

    return &FreeEntry->FreeList;
}


VOID 
RtlpFlushLargestCacheBlock (
    IN PHEAP Heap
    )
{

    PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

    if ((HeapIndex != NULL) &&
        (HeapIndex->LargeBlocksCacheSequence != 0) ) {

        PLIST_ENTRY Head, Next;
        PHEAP_FREE_ENTRY FreeBlock;

        Head = &Heap->FreeLists[ 0 ];                         
        Next = Head->Blink;

        if (Head != Next) {
            
            ULONG PrevSeq = HeapIndex->LargeBlocksCacheSequence;

            //
            //  Lock the cache operations
            //

            HeapIndex->LargeBlocksCacheSequence = 0;

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

            FreeBlock->Flags |= HEAP_ENTRY_BUSY;
            Heap->TotalFreeSize -= FreeBlock->Size;
            
            RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)FreeBlock, FreeBlock->Size );
            
            //
            //  Unlock the cache
            //

            HeapIndex->LargeBlocksCacheSequence = PrevSeq;

            RtlpValidateNonDedicatedList(Heap);                 
        }
    }
}



VOID 
RtlpFlushCacheContents (
    IN PHEAP Heap
    )
{

    PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

    if ((HeapIndex != NULL) &&
        (HeapIndex->LargeBlocksCacheSequence != 0) ) {
        
        LONG NewDepth = HeapIndex->LargeBlocksCacheMaxDepth - HeapIndex->LargeBlocksCacheMinDepth;

        if ( (HeapIndex->LargeBlocksCacheDepth > NewDepth) ) { 

            PLIST_ENTRY Head, Next;
            LIST_ENTRY ListToFree;
            PHEAP_FREE_ENTRY FreeBlock;
            LONG BlocksToFree = HeapIndex->LargeBlocksCacheDepth - NewDepth;
            LONG RemainingBlocks = HeapIndex->LargeBlocksCacheDepth;
            
            if (HeapIndex->LargeBlocksCacheMaxDepth > HeapIndex->CacheStats.LargestDepth) {

                HeapIndex->CacheStats.LargestDepth = HeapIndex->LargeBlocksCacheMaxDepth;
            }

            if (NewDepth > HeapIndex->CacheStats.LargestRequiredDepth) {
                HeapIndex->CacheStats.LargestRequiredDepth = NewDepth;
            }

            //
            //  Get the last hint for this specific size from the index
            //

            FreeBlock = HeapIndex->FreeListHints[ HeapIndex->ArraySize - 1 ];

            if (FreeBlock == NULL) {

                DbgPrint("No free blocks in the cache but the depth is not 0 %ld\n",
                         HeapIndex->LargeBlocksCacheDepth);
                
                return;
            }

            //
            //  Lock the cache operations
            //

            HeapIndex->LargeBlocksCacheSequence = 0;

            Head = &Heap->FreeLists[ 0 ];                  
            Next = &FreeBlock->FreeList;                     

            InitializeListHead(&ListToFree);
            
            while (Head != Next) {

                FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
                
                Next = Next->Flink;
                
                if ( (((SIZE_T)FreeBlock->Size) << HEAP_GRANULARITY_SHIFT) > Heap->DeCommitFreeBlockThreshold) {

                    if ((FreeBlock->Flags & HEAP_ENTRY_SETTABLE_FLAG3)
                          ||
                        (BlocksToFree >= RemainingBlocks) ) {
                        
                        RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );
                        InsertTailList(&ListToFree, &FreeBlock->FreeList);
                        FreeBlock->Flags |= HEAP_ENTRY_BUSY;
                        Heap->TotalFreeSize -= FreeBlock->Size;

                        BlocksToFree -= 1;

                    } else {

                        FreeBlock->Flags |= HEAP_ENTRY_SETTABLE_FLAG3;
                    }
                }
                
                RemainingBlocks -= 1;
            }

            Head = &ListToFree;                  
            Next = ListToFree.Flink;                     

            while (Head != Next) {

                FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                RemoveEntryList(&FreeBlock->FreeList);

                Next = ListToFree.Flink;                     
                RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)FreeBlock, FreeBlock->Size );
            }
        }
        
        HeapIndex->LargeBlocksCacheMaxDepth = HeapIndex->LargeBlocksCacheDepth;
        HeapIndex->LargeBlocksCacheMinDepth = HeapIndex->LargeBlocksCacheDepth;

        HeapIndex->LargeBlocksCacheSequence = 1;
        RtlpValidateNonDedicatedList(Heap);                 
    }
}



VOID 
RtlpUpdateIndexRemoveBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeEntry
    )

/*++

Routine Description:
    
    This function is called each time a free block is removed from
    non-dedicated list. This should update the heap index to reflect the change.
    NOTE : This function must be called before the freeentry is
    actually removed from the non-dedicated list

Arguments:

    Heap - Supplies a pointer to the heap being manipulated
    
    FreeEntry - The removed free block 
    
Return Value:

    None
    
--*/

{
    PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;
    ULONG Size = FreeEntry->Size;

    //
    //  It updates the index only for large sizes 
    //  (over 1024 bytes)
    //

    if (Size >= HEAP_MAXIMUM_FREELISTS) {

        //
        //  Update the length of the nondedicated list
        //  This is happening even if the index isn't created
        //

        Heap->NonDedicatedListLength -= 1;
        
        //
        //  If we have an index, we need to update the index structures
        //

        if (HeapIndex) {

            PHEAP_FREE_ENTRY PrevBlock;
            ULONG AllocIndex = RtlpSizeToAllocIndex( HeapIndex, Size );
            PLIST_ENTRY Flink = FreeEntry->FreeList.Flink;

            //
            //  Get the next block into the list. Set it to NULL
            //  if this is the last element here
            //

            PHEAP_FREE_ENTRY NextFreeBlock = (Flink == &Heap->FreeLists[ 0 ]) ? 
                NULL :
                CONTAINING_RECORD( Flink, HEAP_FREE_ENTRY, FreeList );

            //
            //  Get the last hint for this specific size from the index
            //

            PrevBlock = HeapIndex->FreeListHints[ AllocIndex ];
            
            if ( PrevBlock ==  FreeEntry) {

                //
                //  The free block being removed is actually the hint for that 
                //  specific size. We need then to update
                //

                if (AllocIndex < (HeapIndex->ArraySize - 1)) {

                    //
                    //  If the next block has the same size with the current one
                    //  we need to update only the hint pointer
                    //

                    if ( NextFreeBlock && 
                        (NextFreeBlock->Size == Size) ) {

                        HeapIndex->FreeListHints[ AllocIndex ] = NextFreeBlock;

                    } else {

                        //
                        //  There is no other block with this size, so we need 
                        //  set the hint to NULL and clear the appropriate bit
                        //

                        HeapIndex->FreeListHints[ AllocIndex ] = NULL;
                        CLEAR_INDEX_BIT( HeapIndex, AllocIndex );
                    }

                } else {

                    //
                    //  We are here because this is the last hint from the array
                    //  This list may contain free blocks with different sizes.
                    //

                    if (NextFreeBlock) {

                        //
                        //  We have an other block larger than this one
                        //  We move the hint to that pointer
                        //

                        HeapIndex->FreeListHints[ AllocIndex ] = NextFreeBlock;

                    } else {

                        //
                        //  This was the last block within the non-dedicated list
                        //  Clear the hint pointer and the appropriate bit.
                        //

                        HeapIndex->FreeListHints[ AllocIndex ] = NULL;
                        CLEAR_INDEX_BIT( HeapIndex, AllocIndex );
                    }
                }
            }
            
            if (AllocIndex == (HeapIndex->ArraySize - 1)) {

                HeapIndex->LargeBlocksCacheDepth -= 1;
                
                if (HeapIndex->LargeBlocksCacheDepth < 0) {

                    DbgPrint(("Invalid Cache depth\n"));
                }

                if (HeapIndex->LargeBlocksCacheSequence != 0) {

                    HeapIndex->LargeBlocksCacheSequence += 1;

                    if (HeapIndex->LargeBlocksCacheDepth < HeapIndex->LargeBlocksCacheMinDepth) {

                        HeapIndex->LargeBlocksCacheMinDepth = HeapIndex->LargeBlocksCacheDepth;
                    }
                }
            }
        }
    }
}


VOID 
RtlpUpdateIndexInsertBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeEntry
    )

/*++

Routine Description:
    
    This function is called each time a free block is inserted into
    non-dedicated list. This should update the heap index to reflect the change.
    NOTE : This function must be called AFTER the free entry is
    actually inserted into the non-dedicated list

Arguments:

    Heap - Supplies a pointer to the heap being manipulated
    
    FreeEntry - The new inserted free block free block 
    
Return Value:

    None
    
--*/

{
    PHEAP_INDEX HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

    //
    //  we only have something to do if the size is over the dedicated list 
    //  range
    //

    if ( FreeEntry->Size >= HEAP_MAXIMUM_FREELISTS ) {

        //
        //  Update the non-dedicated list length
        //
        
        Heap->NonDedicatedListLength += 1;

        if ( HeapIndex ) {

            //
            //  We have an index for this list. we need to to some
            //  extra-work to maintain it
            //

            PHEAP_FREE_ENTRY PrevBlock;

            ULONG AllocIndex = RtlpSizeToAllocIndex( HeapIndex, FreeEntry->Size );
            
            //
            //  Get the original hint stored into the index
            //

            PrevBlock = HeapIndex->FreeListHints[ AllocIndex ];

            //
            //  If the hint before was NULL, or we are adding a new 
            //  block smaller or equal with the previous one, we need
            //  to update the hint pointer
            //

            if ( (!PrevBlock) ||
                 (FreeEntry->Size <= PrevBlock->Size) ) {

                HeapIndex->FreeListHints[ AllocIndex ] = FreeEntry;
            }

            //
            //  If this is the first time we set a hint for that size
            //  we need to set the busy bit into the bitmap
            //

            if ( !PrevBlock ) {

                SET_INDEX_BIT( HeapIndex, AllocIndex );
            }

            if ( AllocIndex == (HeapIndex->ArraySize - 1) ) {
                
                HeapIndex->LargeBlocksCacheDepth += 1;
                
                if (HeapIndex->LargeBlocksCacheSequence != 0) {

                    HeapIndex->LargeBlocksCacheSequence += 1;

                    if (HeapIndex->LargeBlocksCacheDepth > HeapIndex->LargeBlocksCacheMaxDepth) {

                        HeapIndex->LargeBlocksCacheMaxDepth = HeapIndex->LargeBlocksCacheDepth;
                    }
                }
            }

        } else if ( Heap->NonDedicatedListLength >= HEAP_INDEX_THRESHOLD ) {

            //
            //  We don't have an index, but we have enough blocks into the 
            //  non-dedicated list. We need to create an index right now,
            //  to help us in search further
            //
            
            RtlpInitializeListIndex( Heap );
        }
    }
}

//
//  Additional debug - test code
//

#ifdef HEAP_VALIDATE_INDEX


BOOLEAN
RtlpGetBitState( 
    IN PHEAP_INDEX HeapIndex, 
    IN ULONG Bit
    )                                     

/*++

Routine Description:
    
    Utility routine which tests the given bit from the bitmap

Arguments:

    Heap - Supplies a pointer to the heapindex being manipulated
    
    Bit - The bit to be tested
    
Return Value:

    TRUE if the bit is 1 and 0 otherwise
    
--*/

{                                                                     
    ULONG _Index_;                                                    
    ULONG _Bit_;                                                      
                                                                      
    _Index_ = Bit >> 3;                                        
    _Bit_ = (1 << (Bit & 7));

    return (((HeapIndex)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_)) != 0;
}


BOOLEAN
RtlpValidateNonDedicatedList (
    IN PHEAP Heap
    )

/*++

Routine Description:
    
    Utility routine which validate the index and non-dedicated lists
    structures

Arguments:

    Heap - Supplies a pointer to the heapindex being manipulated
    
Return Value:

    TRUE validation succeeds
    
--*/

{
    PHEAP_INDEX HeapIndex = NULL;
    PLIST_ENTRY Head, Next;
    ULONG PreviousSize = 0;
    ULONG PreviousIndex = 0;
    LONG LargeBlocksCount = 0;
    
    HeapIndex = (PHEAP_INDEX)Heap->LargeBlocksIndex;

    //
    //  we only do validation if we have a heap index created
    //

    if (HeapIndex) {

        Head = &Heap->FreeLists[ 0 ];                  
        Next = Head->Flink;                     

        //
        //  Loop through the free blocks placed into the non-dedicated list
        //

        while (Head != Next) {

            PHEAP_FREE_ENTRY FreeEntry;                                               
            ULONG AllocIndex;

            //
            //  Get the free block from the old list
            //

            FreeEntry = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            //
            //  Test if the blocks are in the proper order (ascending)
            //

            if (PreviousSize > FreeEntry->Size) {

                HeapDebugPrint(( "Invalid Block order %08lx - %08lx, %08lx\n",
                          FreeEntry,
                          FreeEntry->Size,
                          PreviousSize ));
                DbgBreakPoint();
            }

            //
            //  Get the appropriate index for the current block
            //

            AllocIndex = RtlpSizeToAllocIndex( HeapIndex, FreeEntry->Size );

            if (AllocIndex == (HeapIndex->ArraySize - 1)) {

                LargeBlocksCount += 1;
            }

            if (PreviousSize != FreeEntry->Size) {

                ULONG i;
                
                //
                //  We are here only for the first block of a given size
                //

                //
                //  We need to have all hints NULL between two adjacent
                //  free blocks of different sizes
                //

                for (i = PreviousIndex + 1; i < AllocIndex; i++) {

                    //
                    //  Report an error if there is a hint, but that block doesn't
                    //  exists into the non-dedicated list
                    //

                    if (HeapIndex->FreeListHints[i]) {

                        DbgPrint( "Free block missing %lx, %08lx\n", 
                                  i, 
                                  HeapIndex->FreeListHints[i]
                                  );

                        DbgBreakPoint();
                    }

                    //
                    //  Reports an error if there is a bit set for a size
                    //  not inserted into the non-dedicated list
                    //

                    if ( RtlpGetBitState(HeapIndex, i) ) {

                        DbgPrint("Invalid bit state. Must be 0 %lx\n", i);
                        DbgBreakPoint();
                    }
                }

                //
                //  we are here for the first block of this size. So the hint
                //  should point to this block
                //

                if ( (AllocIndex < HeapIndex->ArraySize - 1) &&
                     (HeapIndex->FreeListHints[ AllocIndex ] != FreeEntry)) {

                    DbgPrint( "Invalid index %lx for block %08lx (%08lx)\n", 
                              AllocIndex, 
                              HeapIndex->FreeListHints[AllocIndex], 
                              FreeEntry);

                    DbgBreakPoint();
                }

                //
                //  We have a block into the non-dedicated list so we need to have
                //  the appropriate bit set
                //

                if ( !RtlpGetBitState( HeapIndex, AllocIndex ) ) {

                    DbgPrint("Invalid bit state. Must be 1 %lx\n", i);

                    DbgBreakPoint();
                }
            }

            //
            //  Save the next link. The insertion into the new 
            //  structure will destroy it
            //

            Next = Next->Flink;

            PreviousSize = FreeEntry->Size;
            PreviousIndex = AllocIndex;
        }

        if (LargeBlocksCount != HeapIndex->LargeBlocksCacheDepth) {
            
            DbgPrint("Invalid Cache depth %ld. Should be %ld\n", 
                     HeapIndex->LargeBlocksCacheDepth,
                     LargeBlocksCount);
        }
    }

    return TRUE;
}

#endif // HEAP_VALIDATE_INDEX

#endif  // NTOS_KERNEL_RUNTIME


#ifndef NTOS_KERNEL_RUNTIME

SIZE_T
GetUCBytes(
    IN PHEAP Heap,
    IN OUT SIZE_T *ReservedSpace, 
    IN OUT PULONG NoOfUCRs
    )
/*++

Routine Description:
    
    Utility routine which computes Uncommited Bytes in a Heap

Arguments:

    Heap - Supplies a pointer to the heap
    
    ReservedSpace - Pointer to Reserved space which is computed

    NoOfUCRs - Pointer to NoOfUCRs which is computed
    
Return Value:

    Total number of UCBytes.
    
--*/

{

    SIZE_T UCBytes = 0;
    PHEAP_SEGMENT pSegment;
    LONG SegmentIndex;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        pSegment = Heap->Segments[ SegmentIndex ];

        if (pSegment) {

            PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;


            (*ReservedSpace) += pSegment->NumberOfPages;
            (*NoOfUCRs) += pSegment->NumberOfUnCommittedRanges;

            for( UnCommittedRange = pSegment->UnCommittedRanges;
                UnCommittedRange;
                UnCommittedRange = UnCommittedRange->Next ) {

                UCBytes += UnCommittedRange->Size;
            }
        }
    }

    return UCBytes;
}

#endif  // NTOS_KERNEL_RUNTIME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heapdbg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    This module implements a debugging layer on top of heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1994

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

BOOLEAN RtlpValidateHeapHdrsEnable = FALSE; // Set to TRUE if headers are being corrupted
BOOLEAN RtlpValidateHeapTagsEnable;         // Set to TRUE if tag counts are off and you want to know why

HEAP_STOP_ON_VALUES RtlpHeapStopOn;


const struct {

    ULONG Offset;
    LPSTR Description;

} RtlpHeapHeaderFieldOffsets[] = {

    FIELD_OFFSET( HEAP, Entry ),                        "Entry",
    FIELD_OFFSET( HEAP, Signature ),                    "Signature",
    FIELD_OFFSET( HEAP, Flags ),                        "Flags",
    FIELD_OFFSET( HEAP, ForceFlags ),                   "ForceFlags",
    FIELD_OFFSET( HEAP, VirtualMemoryThreshold ),       "VirtualMemoryThreshold",
    FIELD_OFFSET( HEAP, SegmentReserve ),               "SegmentReserve",
    FIELD_OFFSET( HEAP, SegmentCommit ),                "SegmentCommit",
    FIELD_OFFSET( HEAP, DeCommitFreeBlockThreshold ),   "DeCommitFreeBlockThreshold",
    FIELD_OFFSET( HEAP, DeCommitTotalFreeThreshold ),   "DeCommitTotalFreeThreshold",
    FIELD_OFFSET( HEAP, TotalFreeSize ),                "TotalFreeSize",
    FIELD_OFFSET( HEAP, MaximumAllocationSize ),        "MaximumAllocationSize",
    FIELD_OFFSET( HEAP, ProcessHeapsListIndex ),        "ProcessHeapsListIndex",
    FIELD_OFFSET( HEAP, HeaderValidateLength ),         "HeaderValidateLength",
    FIELD_OFFSET( HEAP, HeaderValidateCopy ),           "HeaderValidateCopy",
    FIELD_OFFSET( HEAP, NextAvailableTagIndex ),        "NextAvailableTagIndex",
    FIELD_OFFSET( HEAP, MaximumTagIndex ),              "MaximumTagIndex",
    FIELD_OFFSET( HEAP, TagEntries ),                   "TagEntries",
    FIELD_OFFSET( HEAP, UCRSegments ),                  "UCRSegments",
    FIELD_OFFSET( HEAP, UnusedUnCommittedRanges ),      "UnusedUnCommittedRanges",
    FIELD_OFFSET( HEAP, AlignRound ),                   "AlignRound",
    FIELD_OFFSET( HEAP, AlignMask ),                    "AlignMask",
    FIELD_OFFSET( HEAP, VirtualAllocdBlocks ),          "VirtualAllocdBlocks",
    FIELD_OFFSET( HEAP, Segments ),                     "Segments",
    FIELD_OFFSET( HEAP, u ),                            "FreeListsInUse",
    FIELD_OFFSET( HEAP, u2 ),                           "FreeListsInUseTerminate",
    FIELD_OFFSET( HEAP, AllocatorBackTraceIndex ),      "AllocatorBackTraceIndex",
    FIELD_OFFSET( HEAP, NonDedicatedListLength ),       "NonDedicatedListLength",
    FIELD_OFFSET( HEAP, PseudoTagEntries ),             "PseudoTagEntries",
    FIELD_OFFSET( HEAP, FreeLists ),                    "FreeLists",
    FIELD_OFFSET( HEAP, LockVariable ),                 "LockVariable",
    FIELD_OFFSET( HEAP, FrontEndHeap ),                 "FrontEndHeap",
    FIELD_OFFSET( HEAP, FrontHeapLockCount ),           "FrontHeapLockCount",
    FIELD_OFFSET( HEAP, FrontEndHeapType ),             "FrontEndHeapType",
    FIELD_OFFSET( HEAP, LastSegmentIndex ),             "LastSegmentIndex",
    sizeof( HEAP ),                                     "Uncommitted Ranges",
    0xFFFF, NULL
};


VOID
RtlpUpdateHeapListIndex (
    USHORT OldIndex,
    USHORT NewIndex
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (RtlpHeapStopOn.AllocTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.AllocTag.HeapIndex = NewIndex;
    }

    if (RtlpHeapStopOn.ReAllocTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.ReAllocTag.HeapIndex = NewIndex;
    }

    if (RtlpHeapStopOn.FreeTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.FreeTag.HeapIndex = NewIndex;
    }

    return;
}


BOOLEAN
RtlpValidateHeapHeaders (
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG i;
    SIZE_T n;
    SIZE_T nEqual;
    NTSTATUS Status;

    if (!RtlpValidateHeapHdrsEnable) {

        return TRUE;
    }

    if (Heap->HeaderValidateCopy == NULL) {

        n = Heap->HeaderValidateLength;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Heap->HeaderValidateCopy,
                                          0,
                                          &n,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return TRUE;
        }

        Recompute = TRUE;
    }

    n = Heap->HeaderValidateLength;

    if (!Recompute) {

        nEqual = RtlCompareMemory( Heap,
                                   Heap->HeaderValidateCopy,
                                   n );

    } else {

        RtlCopyMemory( Heap->HeaderValidateCopy,
                       Heap,
                       n );

        nEqual = n;
    }

    if (n != nEqual) {

        HeapDebugPrint(( "Heap %x - headers modified (%x is %x instead of %x)\n",
                         Heap,
                         (PCHAR)Heap + nEqual,
                         *(PULONG)((PCHAR)Heap + nEqual),
                         *(PULONG)((PCHAR)Heap->HeaderValidateCopy + nEqual)));

        for (i=0; RtlpHeapHeaderFieldOffsets[ i ].Description != NULL; i++) {

            if ((nEqual >= RtlpHeapHeaderFieldOffsets[ i ].Offset) &&
                (nEqual < RtlpHeapHeaderFieldOffsets[ i+1 ].Offset)) {

                DbgPrint( "    This is located in the %s field of the heap header.\n",
                                 RtlpHeapHeaderFieldOffsets[ i ].Description );

                break;
            }
        }

        return FALSE;

    } else {

        return TRUE;
    }
}


PVOID
RtlDebugCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    if (ReserveSize <= sizeof( HEAP_ENTRY )) {

        HeapDebugPrint(( "Invalid ReserveSize parameter - %p\n", ReserveSize ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if (ReserveSize < CommitSize) {

        HeapDebugPrint(( "Invalid CommitSize parameter - %p\n", CommitSize ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if ((Flags & HEAP_NO_SERIALIZE) && ARGUMENT_PRESENT( Lock )) {

        HeapDebugPrint(( "May not specify Lock parameter with HEAP_NO_SERIALIZE\n" ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if (ARGUMENT_PRESENT( HeapBase )) {

        Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                       HeapBase,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof( MemoryInformation ),
                                       NULL );

        if (!NT_SUCCESS( Status )) {

            HeapDebugPrint(( "Specified HeapBase (%p) invalid,  Status = %lx\n",
                             HeapBase,
                             Status ));

            HeapDebugBreak( NULL );

            return NULL;
        }

        if (MemoryInformation.BaseAddress != HeapBase) {

            HeapDebugPrint(( "Specified HeapBase (%p) != to BaseAddress (%p)\n",
                             HeapBase,
                             MemoryInformation.BaseAddress ));

            HeapDebugBreak( NULL );

            return NULL;
        }

        if (MemoryInformation.State == MEM_FREE) {

            HeapDebugPrint(( "Specified HeapBase (%p) is free or not writable\n",
                             MemoryInformation.BaseAddress ));

            HeapDebugBreak( NULL );

            return NULL;
        }
    }

    Heap = RtlCreateHeap( Flags |
                            HEAP_SKIP_VALIDATION_CHECKS |
                            HEAP_TAIL_CHECKING_ENABLED  |
                            HEAP_FREE_CHECKING_ENABLED,
                          HeapBase,
                          ReserveSize,
                          CommitSize,
                          Lock,
                          Parameters );

    if (Heap != NULL) {

        if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

            Heap->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
        }

        RtlpValidateHeapHeaders( Heap, TRUE );
    }

    return Heap;
}


BOOLEAN
RtlpSerializeHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_LOCK Lock;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSerialize( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlpSerializeHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.
    //

    if (Heap->Flags & HEAP_NO_SERIALIZE) {

        Lock = RtlAllocateHeap( HeapHandle, HEAP_NO_SERIALIZE, sizeof( *Lock ) );

        if ( Lock == NULL ) {

            return FALSE;
        }
    
        Status = RtlInitializeLockRoutine( Lock );

        if (!NT_SUCCESS( Status )) {

            RtlFreeHeap( HeapHandle, HEAP_NO_SERIALIZE, Lock );

            return FALSE;
        }

        Heap->LockVariable = Lock;
        Heap->Flags &= ~HEAP_NO_SERIALIZE;
        Heap->ForceFlags &= ~HEAP_NO_SERIALIZE;

        RtlpValidateHeapHeaders( Heap, TRUE );
    }

    return TRUE;
}


BOOLEAN
RtlDebugDestroyHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    LIST_ENTRY ListEntry;
    SIZE_T n;

    if (HeapHandle == NtCurrentPeb()->ProcessHeap) {

        HeapDebugPrint(( "May not destroy the process heap at %x\n", HeapHandle ));

        return FALSE;
    }

    if (!RtlpCheckHeapSignature( Heap, "RtlDestroyHeap" )) {

        return FALSE;
    }

    if (!RtlpValidateHeap( Heap, FALSE )) {

        return FALSE;
    }

    //
    //  Now mark the heap as invalid by zeroing the signature field.
    //

    Heap->Signature = 0;

    if (Heap->HeaderValidateCopy != NULL) {

        n = 0;
        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                             &Heap->HeaderValidateCopy,
                             &n,
                             MEM_RELEASE );
    }

    return TRUE;
}


PVOID
RtlDebugAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    SIZE_T AllocationSize;
    USHORT TagIndex;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapAllocate( HeapHandle, Flags, Size ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlAllocateHeap" )) {

                ReturnValue = NULL;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SETTABLE_USER_VALUE | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Verify that the size did not wrap or exceed the limit for this heap.
            //

            AllocationSize = (((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask) +
                             sizeof( HEAP_ENTRY_EXTRA );

            if ((AllocationSize < Size) || (AllocationSize > Heap->MaximumAllocationSize)) {

                HeapDebugPrint(( "Invalid allocation size - %p (exceeded %x)\n",
                                 Size,
                                 Heap->MaximumAllocationSize ));

                ReturnValue = NULL;
                leave;
            }

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            ReturnValue = RtlAllocateHeapSlowly( HeapHandle, Flags, Size );

            RtlpValidateHeapHeaders( Heap, TRUE );

            if (ReturnValue != NULL) {

                BusyBlock = (PHEAP_ENTRY)ReturnValue - 1;

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                        ExtraStuff->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

                    } else {

                        ExtraStuff->AllocatorBackTraceIndex = 0;
                    }

                    TagIndex = ExtraStuff->TagIndex;

                } else {

                    TagIndex = BusyBlock->SmallTagIndex;
                }

                if (Heap->Flags & HEAP_VALIDATE_ALL_ENABLED) {

                    RtlpValidateHeap( Heap, FALSE );
                }
            }

            if (ReturnValue != NULL) {

                if ((ULONG_PTR)ReturnValue == RtlpHeapStopOn.AllocAddress) {

                    HeapDebugPrint(( "Just allocated block at %p for 0x%x bytes\n",
                                     RtlpHeapStopOn.AllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) &&
                           (TagIndex != 0) &&
                           (TagIndex == RtlpHeapStopOn.AllocTag.TagIndex) &&
                           (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.AllocTag.HeapIndex)) {

                    HeapDebugPrint(( "Just allocated block at %p for 0x%x bytes with tag %ws\n",
                                     ReturnValue,
                                     Size,
                                     RtlpGetTagName( Heap, TagIndex )));

                    HeapDebugBreak( NULL );
                }
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            ReturnValue = NULL;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


PVOID
RtlDebugReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    USHORT TagIndex;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapReAllocate( HeapHandle, Flags, BaseAddress, Size ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlReAllocateHeap" )) {

                ReturnValue = NULL;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SETTABLE_USER_VALUE | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Verify that the size did not wrap or exceed the limit for this heap.
            //

            AllocationSize = (((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask) +
                             sizeof( HEAP_ENTRY_EXTRA );

            if (AllocationSize < Size || AllocationSize > Heap->MaximumAllocationSize) {

                HeapDebugPrint(( "Invalid allocation size - %p (exceeded %x)\n",
                                 Size,
                                 Heap->MaximumAllocationSize ));

                HeapDebugBreak( NULL );

                ReturnValue = NULL;
                leave;
            }

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );
            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlReAllocateHeap" )) {

                if ((ULONG_PTR)BaseAddress == RtlpHeapStopOn.ReAllocAddress) {

                    HeapDebugPrint(( "About to reallocate block at %p to 0x%x bytes\n",
                                     RtlpHeapStopOn.ReAllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if (IS_HEAP_TAGGING_ENABLED() && RtlpHeapStopOn.ReAllocTag.HeapAndTagIndex != 0) {

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }

                    if ((TagIndex != 0) &&
                        (TagIndex == RtlpHeapStopOn.ReAllocTag.TagIndex) &&
                        (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.ReAllocTag.HeapIndex)) {

                        HeapDebugPrint(( "About to rellocate block at %p to 0x%x bytes with tag %ws\n",
                                         BaseAddress,
                                         Size,
                                         RtlpGetTagName( Heap, TagIndex )));

                        HeapDebugBreak( NULL );
                    }
                }

                ReturnValue = RtlReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );

                if (ReturnValue != NULL) {

                    BusyBlock = (PHEAP_ENTRY)ReturnValue - 1;

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                        if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                            ExtraStuff->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

                        } else {

                            ExtraStuff->AllocatorBackTraceIndex = 0;
                        }

                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }
                }

                RtlpValidateHeapHeaders( Heap, TRUE );
                RtlpValidateHeap( Heap, FALSE );
            }

            if (ReturnValue != NULL) {

                if ((ULONG_PTR)ReturnValue == RtlpHeapStopOn.ReAllocAddress) {

                    HeapDebugPrint(( "Just reallocated block at %p to 0x%x bytes\n",
                                     RtlpHeapStopOn.ReAllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) &&
                           (TagIndex == RtlpHeapStopOn.ReAllocTag.TagIndex) &&
                           (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.ReAllocTag.HeapIndex)) {

                    HeapDebugPrint(( "Just reallocated block at %p to 0x%x bytes with tag %ws\n",
                                     ReturnValue,
                                     Size,
                                     RtlpGetTagName( Heap, TagIndex )));

                    HeapDebugBreak( NULL );
                }
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            ReturnValue = NULL;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


BOOLEAN
RtlDebugFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T Size;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;
    USHORT TagIndex;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapFree( HeapHandle, Flags, BaseAddress ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlFreeHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;
            Size = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlFreeHeap" )) {

                if ((ULONG_PTR)BaseAddress == RtlpHeapStopOn.FreeAddress) {

                    HeapDebugPrint(( "About to free block at %p\n",
                                     RtlpHeapStopOn.FreeAddress ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) && (RtlpHeapStopOn.FreeTag.HeapAndTagIndex != 0)) {

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }

                    if ((TagIndex != 0) &&
                        (TagIndex == RtlpHeapStopOn.FreeTag.TagIndex) &&
                        (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.FreeTag.HeapIndex)) {

                        HeapDebugPrint(( "About to free block at %p with tag %ws\n",
                                         BaseAddress,
                                         RtlpGetTagName( Heap, TagIndex )));

                        HeapDebugBreak( NULL );
                    }
                }

                Result = RtlFreeHeapSlowly( HeapHandle, Flags, BaseAddress );

                RtlpValidateHeapHeaders( Heap, TRUE );
                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapGetUserInfo( HeapHandle, Flags, BaseAddress, UserValue, UserFlags ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlGetUserInfoHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlGetUserInfoHeap" )) {

                Result = RtlGetUserInfoHeap( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSetUserValue( HeapHandle, Flags, BaseAddress, UserValue ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSetUserValueHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSetUserValueHeap" )) {

                Result = RtlSetUserValueHeap( HeapHandle, Flags, BaseAddress, UserValue );

                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSetUserFlags( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet ));

    if ((UserFlagsReset & ~HEAP_SETTABLE_USER_FLAGS) ||
        (UserFlagsSet & ~HEAP_SETTABLE_USER_FLAGS)) {

        return FALSE;
    }

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSetUserFlagsHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSetUserFlagsHeap" )) {

                Result = RtlSetUserFlagsHeap( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );

                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


SIZE_T
RtlDebugSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T BusySize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSize( HeapHandle, Flags, BaseAddress ));

    BusySize = 0xFFFFFFFF;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSizeHeap" )) {

                BusySize = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                Flags |= HEAP_NO_SERIALIZE;

                LockAcquired = TRUE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSizeHeap" )) {

                BusySize = RtlSizeHeap( HeapHandle, Flags, BaseAddress );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return BusySize;
}


SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapCompact( HeapHandle, Flags ));

    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlCompactHeap" )) {

                LargestFreeSize = 0;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            LargestFreeSize = RtlCompactHeap( HeapHandle, Flags );

            RtlpValidateHeapHeaders( Heap, TRUE );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return LargestFreeSize;
}


NTSTATUS
RtlDebugZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapZero( HeapHandle, Flags ));

    Status = STATUS_SUCCESS;
    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlZeroHeap" )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            if (!RtlpValidateHeap( Heap, FALSE )) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = RtlZeroHeap( HeapHandle, Flags );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


NTSTATUS
RtlDebugCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    ULONG TagIndex;

    TagIndex = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (RtlpCheckHeapSignature( Heap, "RtlCreateTagHeap" )) {

                Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

                //
                //  Lock the heap
                //

                if (!(Flags & HEAP_NO_SERIALIZE)) {

                    RtlAcquireLockRoutine( Heap->LockVariable );

                    LockAcquired = TRUE;

                    Flags |= HEAP_NO_SERIALIZE;
                }

                if (RtlpValidateHeap( Heap, FALSE )) {

                    TagIndex = RtlCreateTagHeap( HeapHandle, Flags, TagPrefix, TagNames );
                }

                RtlpValidateHeapHeaders( Heap, TRUE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return TagIndex;
}


NTSYSAPI
PWSTR
NTAPI
RtlDebugQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PWSTR Result;

    Result = NULL;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (RtlpCheckHeapSignature( Heap, "RtlQueryTagHeap" )) {

                Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

                //
                //  Lock the heap
                //

                if (!(Flags & HEAP_NO_SERIALIZE)) {

                    RtlAcquireLockRoutine( Heap->LockVariable );

                    LockAcquired = TRUE;

                    Flags |= HEAP_NO_SERIALIZE;
                }

                if (RtlpValidateHeap( Heap, FALSE )) {

                    Result = RtlQueryTagHeap( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


NTSTATUS
RtlDebugUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUsage( HeapHandle, Flags, Usage ));

    Status = STATUS_SUCCESS;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlUsageHeap" )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            if (!RtlpValidateHeap( Heap, FALSE )) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = RtlUsageHeap( HeapHandle, Flags, Usage );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN Result;

    //
    //  Assumed the caller has serialized via RtlLockHeap or their own locking mechanism.
    //

    Result = FALSE;

    try {

        if (RtlpCheckHeapSignature( Heap, "RtlWalkHeap" )) {

            Result = RtlpValidateHeap( Heap, FALSE );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        SET_LAST_STATUS( GetExceptionCode() );
    }

    return Result;
}


BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    BOOLEAN Result;

    if ((BusyBlock != NULL) &&
        (BusyBlock->SegmentIndex == HEAP_LFH_INDEX)) {

        if ((RtlpGetLowFragHeap(Heap) == NULL)
                ||
            ((ULONG_PTR)BusyBlock & (HEAP_GRANULARITY-1))
                ||
            (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)
                ||
            !(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

            goto InvalidBlock;
        }

        return TRUE;
    }

    if ((BusyBlock == NULL)

            ||

        ((ULONG_PTR)BusyBlock & (HEAP_GRANULARITY-1))

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((ULONG_PTR)BusyBlock & (PAGE_SIZE-1)) != FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock ))

            ||

        (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS) ||
          !(Segment = Heap->Segments[ BusyBlock->SegmentIndex ]) ||
          (BusyBlock < Segment->FirstEntry) ||
          (BusyBlock >= Segment->LastValidEntry)))

            ||

        !(BusyBlock->Flags & HEAP_ENTRY_BUSY)

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_FILL_PATTERN) && !RtlpCheckBusyBlockTail( BusyBlock ))) {

InvalidBlock:

        HeapDebugPrint(( "Invalid Address specified to %s( %p, %p )\n",
                         Reason,
                         Heap,
                         BusyBlock + 1 ));

        HeapDebugBreak( BusyBlock );

        return FALSE;

    } else {

        if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

            Result = TRUE;

        } else {

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment) {

                    if ((BusyBlock >= Segment->FirstEntry) &&
                        (BusyBlock < Segment->LastValidEntry)) {

                        Result = TRUE;
                        break;
                    }
                }
            }
        }

        if (!Result) {

            goto InvalidBlock;
        }

        return TRUE;
    }
}


BOOLEAN
RtlpValidateHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN OUT PULONG CountOfFreeBlocks,
    IN OUT PSIZE_T TotalFreeSize,
    OUT PVOID *BadAddress,
    IN OUT PSIZE_T ComputedTagEntries,
    IN OUT PSIZE_T ComputedPseudoTagEntries
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_ENTRY CurrentBlock, PreviousBlock;
    SIZE_T Size;
    USHORT PreviousSize, TagIndex;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;

    RTL_PAGED_CODE();

    NumberOfUnCommittedPages = 0;
    NumberOfUnCommittedRanges = 0;

    UnCommittedRange = Segment->UnCommittedRanges;

    if (Segment->BaseAddress == Heap) {

        CurrentBlock = &Heap->Entry;

    } else {

        CurrentBlock = &Segment->Entry;
    }

    while (CurrentBlock < Segment->LastValidEntry) {

        *BadAddress = CurrentBlock;

        if ((UnCommittedRange != NULL) &&
            ((ULONG_PTR)CurrentBlock >= UnCommittedRange->Address)) {

            HeapDebugPrint(( "Heap entry %p is beyond uncommited range [%x .. %x)\n",
                             CurrentBlock,
                             UnCommittedRange->Address,
                             (PCHAR)UnCommittedRange->Address + UnCommittedRange->Size ));

            return FALSE;
        }

        PreviousSize = 0;

        while (CurrentBlock < Segment->LastValidEntry) {

            *BadAddress = CurrentBlock;

            if (PreviousSize != CurrentBlock->PreviousSize) {

                HeapDebugPrint(( "Heap entry %p has incorrect PreviousSize field (%04x instead of %04x)\n",
                                 CurrentBlock, CurrentBlock->PreviousSize, PreviousSize ));

                return FALSE;
            }

            PreviousSize = CurrentBlock->Size;
            Size = (ULONG_PTR)CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                if (ComputedTagEntries != NULL) {

                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = CurrentBlock->SmallTagIndex;
                    }

                    if (TagIndex != 0) {

                        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                            if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                                ComputedPseudoTagEntries[ TagIndex ] += CurrentBlock->Size;
                            }

                        } else if (TagIndex & HEAP_GLOBAL_TAG) {

                            //
                            //  Ignore these since they are global across more than
                            //  one heap.
                            //

                        } else if (TagIndex < Heap->NextAvailableTagIndex) {

                            ComputedTagEntries[ TagIndex ] += CurrentBlock->Size;
                        }
                    }
                }

                if (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN) {

                    if (!RtlpCheckBusyBlockTail( CurrentBlock )) {

                        return FALSE;
                    }
                }

            } else {

                *CountOfFreeBlocks += 1;
                *TotalFreeSize += CurrentBlock->Size;

                if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                    (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                    SIZE_T cb, cbEqual;

                    cb = Size - sizeof( HEAP_FREE_ENTRY );

                    if ((CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) &&
                        (cb > sizeof( HEAP_FREE_ENTRY_EXTRA ))) {

                        cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );
                    }

                    cbEqual = RtlCompareMemoryUlong( (PCHAR)((PHEAP_FREE_ENTRY)CurrentBlock + 1),
                                                     cb,
                                                     FREE_HEAP_FILL );

                    if (cbEqual != cb) {

                        HeapDebugPrint(( "Free Heap block %p modified at %p after it was freed\n",
                                         CurrentBlock,
                                         (PCHAR)(CurrentBlock + 1) + cbEqual ));

                        return FALSE;
                    }
                }
            }

            if (CurrentBlock->SegmentIndex != SegmentIndex) {

                HeapDebugPrint(( "Heap block at %p has incorrect segment index (%x)\n",
                                 CurrentBlock,
                                 SegmentIndex ));

                return FALSE;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);

                if (UnCommittedRange == NULL) {

                    if (CurrentBlock != Segment->LastValidEntry) {

                        HeapDebugPrint(( "Heap block at %p is not last block in segment (%x)\n",
                                         CurrentBlock,
                                         Segment->LastValidEntry ));

                        return FALSE;
                    }

                } else if ((ULONG_PTR)CurrentBlock != UnCommittedRange->Address) {

                    HeapDebugPrint(( "Heap block at %p does not match address of next uncommitted address (%x)\n",
                                     CurrentBlock,
                                     UnCommittedRange->Address ));

                    return FALSE;

                } else {

                    NumberOfUnCommittedPages += (ULONG) (UnCommittedRange->Size / PAGE_SIZE);
                    NumberOfUnCommittedRanges += 1;

                    CurrentBlock = (PHEAP_ENTRY)
                        ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                    UnCommittedRange = UnCommittedRange->Next;
                }

                break;
            }

            CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);
        }
    }

    *BadAddress = Segment;

    if (Segment->NumberOfUnCommittedPages != NumberOfUnCommittedPages) {

        HeapDebugPrint(( "Heap Segment at %p contains invalid NumberOfUnCommittedPages (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedPages,
                         NumberOfUnCommittedPages ));

        return FALSE;
    }

    if (Segment->NumberOfUnCommittedRanges != NumberOfUnCommittedRanges) {

        HeapDebugPrint(( "Heap Segment at %p contains invalid NumberOfUnCommittedRanges (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedRanges,
                         NumberOfUnCommittedRanges ));

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PLIST_ENTRY Head, Next;
    PHEAP_FREE_ENTRY FreeBlock;
    BOOLEAN EmptyFreeList;
    ULONG NumberOfFreeListEntries;
    ULONG CountOfFreeBlocks;
    SIZE_T TotalFreeSize;
    SIZE_T Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    PVOID BadAddress;
    PSIZE_T ComputedTagEntries = NULL;
    PSIZE_T ComputedPseudoTagEntries = NULL;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    USHORT TagIndex;

    RTL_PAGED_CODE();

    BadAddress = Heap;

    if (!RtlpValidateHeapHeaders( Heap, FALSE )) {

        goto errorExit;
    }

    if (!AlwaysValidate && !(Heap->Flags & HEAP_VALIDATE_ALL_ENABLED)) {

        goto exit;
    }

    NumberOfFreeListEntries = 0;
    Head = &Heap->FreeLists[ 0 ];

    for (Size = 0; Size < HEAP_MAXIMUM_FREELISTS; Size++) {

        if (Size != 0) {

            EmptyFreeList = (BOOLEAN)(IsListEmpty( Head ));
            BadAddress = &Heap->u.FreeListsInUseBytes[ Size / 8 ];

            if (Heap->u.FreeListsInUseBytes[ Size / 8 ] & (1 << (Size & 7)) ) {

                if (EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list empty but marked as non-empty\n",
                                     Size ));

                    goto errorExit;
                }

            } else {

                if (!EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list non-empty but marked as empty\n",
                                     Size ));

                    goto errorExit;
                }
            }
        }

        Next = Head->Flink;
        PreviousSize = 0;

        while (Head != Next) {

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
            Next = Next->Flink;

            BadAddress = FreeBlock;

            if (FreeBlock->Flags & HEAP_ENTRY_BUSY) {

                HeapDebugPrint(( "dedicated (%04x) free list element %p is marked busy\n",
                                 Size,
                                 FreeBlock ));

                goto errorExit;
            }

            if ((Size != 0) && (FreeBlock->Size != Size)) {

                HeapDebugPrint(( "Dedicated (%04x) free list element %p is wrong size (%04x)\n",
                                 Size,
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < HEAP_MAXIMUM_FREELISTS)) {

                HeapDebugPrint(( "Non-Dedicated free list element %p with too small size (%04x)\n",
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < PreviousSize)) {

                HeapDebugPrint(( "Non-Dedicated free list element %p is out of order\n",
                                 FreeBlock ));

                goto errorExit;

            } else {

                PreviousSize = FreeBlock->Size;
            }

            NumberOfFreeListEntries++;
        }

        Head++;
    }

    Size = (HEAP_NUMBER_OF_PSEUDO_TAG + Heap->NextAvailableTagIndex + 1) * sizeof( SIZE_T );

    if ((RtlpValidateHeapTagsEnable) && (Heap->PseudoTagEntries != NULL)) {

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &ComputedPseudoTagEntries,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (NT_SUCCESS( Status )) {

            ComputedTagEntries = ComputedPseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
        }
    }

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        if (ComputedTagEntries != NULL) {

            TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;

            if (TagIndex != 0) {

                if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                    TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                    if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                        ComputedPseudoTagEntries[ TagIndex ] +=
                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                    }

                } else if (TagIndex & HEAP_GLOBAL_TAG) {

                    //
                    //  Ignore these since they are global across more than
                    //  one heap.
                    //

                } else if (TagIndex < Heap->NextAvailableTagIndex) {

                    ComputedTagEntries[ TagIndex ] +=
                        VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                }
            }
        }

        if (VirtualAllocBlock->BusyBlock.Flags & HEAP_ENTRY_FILL_PATTERN) {

            if (!RtlpCheckBusyBlockTail( &VirtualAllocBlock->BusyBlock )) {

                return FALSE;
            }
        }

        Next = Next->Flink;
    }

    CountOfFreeBlocks = 0;
    TotalFreeSize = 0;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            if (!RtlpValidateHeapSegment( Heap,
                                          Segment,
                                          SegmentIndex,
                                          &CountOfFreeBlocks,
                                          &TotalFreeSize,
                                          &BadAddress,
                                          ComputedTagEntries,
                                          ComputedPseudoTagEntries )) {

                goto errorExit;
            }
        }
    }

    BadAddress = Heap;

    if (NumberOfFreeListEntries != CountOfFreeBlocks) {

        HeapDebugPrint(( "Number of free blocks in arena (%ld) does not match number in the free lists (%ld)\n",
                         CountOfFreeBlocks,
                         NumberOfFreeListEntries ));

        goto errorExit;
    }

    if (Heap->TotalFreeSize != TotalFreeSize) {

        HeapDebugPrint(( "Total size of free blocks in arena (%ld) does not match number total in heap header (%ld)\n",
                         TotalFreeSize,
                         Heap->TotalFreeSize ));

        goto errorExit;
    }

    if (ComputedPseudoTagEntries != NULL) {

        PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
        PHEAP_TAG_ENTRY TagEntries;
        USHORT TagIndex;

        PseudoTagEntries = Heap->PseudoTagEntries;

        if (PseudoTagEntries != NULL) {

            for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {

                PseudoTagEntries += 1;

                if (ComputedPseudoTagEntries[ TagIndex ] != PseudoTagEntries->Size) {

                    HeapDebugPrint(( "Pseudo Tag %04x size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     PseudoTagEntries->Size,
                                     ComputedPseudoTagEntries[ TagIndex ]
                                     &ComputedPseudoTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        TagEntries = Heap->TagEntries;

        if (TagEntries != NULL) {

            for (TagIndex=1; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {

                TagEntries += 1;

                if (ComputedTagEntries[ TagIndex ] != TagEntries->Size) {

                    HeapDebugPrint(( "Tag %04x (%ws) size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     TagEntries->TagName,
                                     TagEntries->Size,
                                     ComputedTagEntries[ TagIndex ],
                                     &ComputedTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        Size = 0;

        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                             &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

exit:

    return TRUE;

errorExit:

    HeapDebugBreak( BadAddress );

    if (ComputedPseudoTagEntries != NULL) {

        Size = 0;

        RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
                             &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

    return FALSE;

}


BOOLEAN RtlpHeapInvalidBreakPoint;
PVOID RtlpHeapInvalidBadAddress;

VOID
RtlpBreakPointHeap (
    IN PVOID BadAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (NtCurrentPeb()->BeingDebugged) {

        *(BOOLEAN volatile *)&RtlpHeapInvalidBreakPoint = TRUE;

        RtlpHeapInvalidBadAddress = BadAddress;

        DbgBreakPoint();

        *(BOOLEAN volatile *)&RtlpHeapInvalidBreakPoint = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heapleak.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heapleak.c

Abstract:

    Garbage collection leak detection

Author:

    Adrian Marinescu (adrmarin) 04-24-2000

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"


//
//  heap walking contexts.
//

#define CONTEXT_START_GLOBALS   11
#define CONTEXT_START_HEAP      1
#define CONTEXT_END_HEAP        2
#define CONTEXT_START_SEGMENT   3
#define CONTEXT_END_SEGMENT     4
#define CONTEXT_FREE_BLOCK      5
#define CONTEXT_BUSY_BLOCK      6
#define CONTEXT_LOOKASIDE_BLOCK 7
#define CONTEXT_VIRTUAL_BLOCK   8
#define CONTEXT_END_BLOCKS      9
#define CONTEXT_ERROR           10

typedef BOOLEAN (*HEAP_ITERATOR_CALLBACK)(
    IN ULONG Context,
    IN PHEAP HeapAddress,
    IN PHEAP_SEGMENT SegmentAddress,
    IN PHEAP_ENTRY EntryAddress,
    IN ULONG_PTR Data
    );

//
//  Garbage collector structures
//
    
typedef enum _USAGE_TYPE {

    UsageUnknown,
    UsageModule,
    UsageHeap,
    UsageOther

} USAGE_TYPE;

typedef struct _HEAP_BLOCK {

    LIST_ENTRY   Entry;
    ULONG_PTR BlockAddress;
    ULONG_PTR Size;
    LONG    Count;

} HEAP_BLOCK, *PHEAP_BLOCK;

typedef struct _BLOCK_DESCR {

    USAGE_TYPE Type;
    ULONG_PTR Heap;
    LONG Count;
    HEAP_BLOCK Blocks[1];

}BLOCK_DESCR, *PBLOCK_DESCR;

typedef struct _MEMORY_MAP {

    ULONG_PTR Granularity;
    ULONG_PTR Offset;
    ULONG_PTR MaxAddress;

    CHAR FlagsBitmap[256 / 8];

    union{
        
        struct _MEMORY_MAP * Details[ 256 ];
        PBLOCK_DESCR Usage[ 256 ];
    };

    struct _MEMORY_MAP * Parent;

} MEMORY_MAP, *PMEMORY_MAP;

//
//  Process leak detection flags
//

#define INSPECT_LEAKS 1
#define BREAK_ON_LEAKS 2

ULONG RtlpShutdownProcessFlags = 0;

//
//  Allocation routines. It creates a temporary heap for the temporary
//  leak detection structures
//

HANDLE RtlpLeakHeap;

#define RtlpLeakAllocateBlock(Size) RtlAllocateHeap(RtlpLeakHeap, 0, Size)


//
//  Local data declarations
//

MEMORY_MAP RtlpProcessMemoryMap;
LIST_ENTRY RtlpBusyList;
LIST_ENTRY RtlpLeakList;

ULONG RtlpLeaksCount = 0;


ULONG_PTR RtlpLDPreviousPage = 0;
ULONG_PTR RtlpLDCrtPage = 0;
LONG RtlpLDNumBlocks = 0;
PHEAP_BLOCK RtlpTempBlocks = NULL;
ULONG_PTR RtlpCrtHeapAddress = 0;
ULONG_PTR RtlpLeakHeapAddress = 0;
ULONG_PTR RtlpPreviousStartAddress = 0;

//
//  Debugging facility
//

ULONG_PTR RtlpBreakAtAddress = MAXULONG_PTR;


//
//  Walking heap routines. These are general purposes routines that 
//  receive a callback function to handle a specific operation
//


BOOLEAN 
RtlpReadHeapSegment(
    IN PHEAP Heap, 
    IN ULONG SegmentIndex,
    IN PHEAP_SEGMENT Segment, 
    IN HEAP_ITERATOR_CALLBACK HeapCallback
    )

/*++

Routine Description:

    This routine is called to walk a heap segment. For each block 
    from the segment is invoked the HeapCallback function.

Arguments:

    Heap - The heap being walked
    
    SegmentIndex - The index of this segment
    
    Segment - The segment to be walked
    
    HeapCallback - a HEAP_ITERATOR_CALLBACK function passed down from the heap walk

Return Value:

    TRUE if succeeds.


--*/

{
    PHEAP_ENTRY PrevEntry, Entry, NextEntry;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    ULONG_PTR UnCommittedRangeAddress = 0;
    SIZE_T UnCommittedRangeSize = 0;

    //
    //  Ask the callback if we're required to walk this segment. Return otherwise.
    //

    if (!(*HeapCallback)( CONTEXT_START_SEGMENT,
                          Heap,
                          Segment,
                          0,
                          0
                     )) {

        return FALSE;
    }

    //
    //  Prepare to read the uncommitted ranges. we need to jump
    //  to the next uncommitted range for each last block
    //

    UnCommittedRange = Segment->UnCommittedRanges;

    if (UnCommittedRange) {

        UnCommittedRangeAddress = (ULONG_PTR)UnCommittedRange->Address;
        UnCommittedRangeSize = UnCommittedRange->Size;
    }
    
    //
    //  Walk the segment, block by block
    //

    Entry = (PHEAP_ENTRY)Segment->BaseAddress;
    
    PrevEntry = 0;

    while (Entry < Segment->LastValidEntry) {

        ULONG EntryFlags = Entry->Flags;

        //
        //  Determine the next block entry. Size is in heap granularity and
        //  sizeof(HEAP_ENTRY) == HEAP_GRANULARITY.
        //

        NextEntry = Entry + Entry->Size;

        (*HeapCallback)( (Entry->Flags & HEAP_ENTRY_BUSY ? 
                            CONTEXT_BUSY_BLOCK : 
                            CONTEXT_FREE_BLOCK),
                         Heap,
                         Segment,
                         Entry,
                         Entry->Size
                         ); 

        PrevEntry = Entry;
        Entry = NextEntry;
        
        //
        //  Check whether this is the last entry
        //

        if (EntryFlags & HEAP_ENTRY_LAST_ENTRY) {

            if ((ULONG_PTR)Entry == UnCommittedRangeAddress) {

                //
                //  Here we need to skip the uncommited range and jump
                //  to the next valid block
                //

                PrevEntry = 0;
                Entry = (PHEAP_ENTRY)(UnCommittedRangeAddress + UnCommittedRangeSize);

                UnCommittedRange = UnCommittedRange->Next;
                
                if (UnCommittedRange) {

                    UnCommittedRangeAddress = UnCommittedRange->Address;
                    UnCommittedRangeSize = UnCommittedRange->Size;
                }

            } else {

                //
                //  We finished the search because we exausted the uncommitted
                //  ranges
                //

                break;
            }
        }
    }

    //
    //  Return to our caller.
    //

    return TRUE;
}



BOOLEAN
RtlpReadHeapData(
    IN PHEAP Heap, 
    IN HEAP_ITERATOR_CALLBACK HeapCallback
    )

/*++

Routine Description:

    This routine is called to walk a heap. This means:
        - walking all segments
        - walking the virtual blocks
        - walking the lookaside

Arguments:

    Heap - The heap being walked
    
    HeapCallback - a HEAP_ITERATOR_CALLBACK function passed down from the heap walk

Return Value:

    TRUE if succeeds.

--*/

{
    ULONG SegmentCount;
    PLIST_ENTRY Head, Next;
    PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(Heap);

    //
    //  Flush the lookaside first
    //

    if (Lookaside != NULL) {

        ULONG i;
        PVOID Block;

        Heap->FrontEndHeap = NULL;
        Heap->FrontEndHeapType = 0;

        for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

            while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                RtlFreeHeap( Heap, 0, Block );
            }
        }
    }

    //
    //  Check whether we're required to walk this heap
    //

    if (!(*HeapCallback)( CONTEXT_START_HEAP,
                          Heap,
                          0,
                          0,
                          0
                     )) {

        return FALSE;
    }
    
    //
    //  Start walking through the segments
    //

    for (SegmentCount = 0; SegmentCount < HEAP_MAXIMUM_SEGMENTS; SegmentCount++) {
        
        PHEAP_SEGMENT Segment = Heap->Segments[SegmentCount];

        if (Segment) {
            
            //
            //  Call the appropriate routine to walk a valid segment
            //

            RtlpReadHeapSegment( Heap,
                             SegmentCount,
                             Segment, 
                             HeapCallback
                            );
        }
    }

    //
    //  Start walking the virtual block list
    //

    Head = &Heap->VirtualAllocdBlocks;

    Next = Head->Flink;
    
    while (Next != Head) {

        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

        VirtualAllocBlock = CONTAINING_RECORD(Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry);

        (*HeapCallback)( CONTEXT_VIRTUAL_BLOCK,
                         Heap,
                         0,
                         NULL,
                         (ULONG_PTR)VirtualAllocBlock
                         );

        Next = Next->Flink;
    }

    if (!(*HeapCallback)( CONTEXT_END_BLOCKS,
                          Heap,
                          0,
                          0,
                          0
                     )) {

        return FALSE;
    }

    return TRUE;
}


VOID 
RtlpReadProcessHeaps(
    IN HEAP_ITERATOR_CALLBACK HeapCallback
    )

/*++

Routine Description:

    This routine is called to walk the existing heaps in the current process
    
Arguments:

    HeapCallback - a HEAP_ITERATOR_CALLBACK function passed down from the heap walk

Return Value:

    TRUE if succeeds.

--*/

{
    ULONG i;
    PPEB ProcessPeb = NtCurrentPeb();

    if (!(*HeapCallback)( CONTEXT_START_GLOBALS,
                          0,
                          0,
                          0,
                          (ULONG_PTR)ProcessPeb
                     )) {

        return;
    }
    
    //
    //  Walk the heaps from the process PEB
    //

    for (i = 0; i < ProcessPeb->NumberOfHeaps; i++) {

        RtlpReadHeapData ( (PHEAP)(ProcessPeb->ProcessHeaps[ i ]), 
                       HeapCallback
                     );
    }
}


VOID
RtlpInitializeMap (
    IN PMEMORY_MAP MemMap, 
    IN PMEMORY_MAP Parent
    )

/*++

Routine Description:

    This routine initialize a memory map structure
    
Arguments:

    MemMap - Map being initializated
    Parent - The upper level map

Return Value:

    None

--*/

{
    //
    //  Clear the memory map data
    //

    RtlZeroMemory(MemMap, sizeof(*MemMap));

    //
    //  Save the upper level map
    //

    MemMap->Parent = Parent;

    //
    //  Determine the granularity from the parent's granularity
    //

    if (Parent) {

        MemMap->Granularity = Parent->Granularity / 256;
    }
}


VOID
RtlpSetBlockInfo (
    IN PMEMORY_MAP MemMap, 
    IN ULONG_PTR Base, 
    IN ULONG_PTR Size, 
    IN PBLOCK_DESCR BlockDescr
    )

/*++

Routine Description:
    
    The routine will set a given block descriptor for a range
    in the memory map. 
    
Arguments:

    MemMap - The memory map
    
    Base - base address for the range to be set.
    
    Size - size in bytes of the zone
    
    BlockDescr - The pointer to the BLOCK_DESCR structure to be set

Return Value:

    None

--*/

{
    ULONG_PTR Start, End;
    ULONG_PTR i;
    
    //
    //  Check wheter we got a valid range
    //

    if (((Base + Size - 1) < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return;
    }

    //
    //  Determine the starting index to be set
    //

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    //
    //  Determine the ending index to be set
    //
    
    End = (Base - MemMap->Offset + Size - 1) / MemMap->Granularity;

    if (End > 255) {

        End = 255;
    }

    for (i = Start; i <= End; i++) {

        //
        //  Check whether this is the lowes memory map level
        //
        
        if (MemMap->Granularity == PAGE_SIZE) {

            //
            //  This is the last level in the memory map, so we can apply
            //  the block descriptor here
            //

            if (BlockDescr) {

                //
                //  Check if we already have a block descriptor here
                //

                if (MemMap->Usage[i] != NULL) {
                    if (MemMap->Usage[i] != BlockDescr) {

                        DbgPrint("Error\n");
                    }
                }

                //
                //  Assign the given descriptor
                //

                MemMap->Usage[i] = BlockDescr;

            } else {

                //
                //  We didn't recedive a block descriptor. We set
                //  then the given flag
                //

                MemMap->FlagsBitmap[i / 8] |= 1 << (i % 8);
            }

        } else {

            //
            //  This isn't the lowest map level. We recursively call 
            //  this function for the next detail range
            //

            if (!MemMap->Details[i]) {

                //
                //  Allocate a new map
                //

                MemMap->Details[i] = RtlpLeakAllocateBlock( sizeof(*MemMap) );

                if (!MemMap->Details[i]) {
                    
                    DbgPrint("Error allocate\n");
                }

                //
                //  Initialize the map and link it with the current one
                //

                RtlpInitializeMap(MemMap->Details[i], MemMap);
                MemMap->Details[i]->Offset = MemMap->Offset + MemMap->Granularity * i;
                MemMap->Details[i]->MaxAddress = MemMap->Offset + MemMap->Granularity * (i+1) - 1;
            }
            
            RtlpSetBlockInfo(MemMap->Details[i], Base, Size, BlockDescr);
        }
    }
}


PBLOCK_DESCR
RtlpGetBlockInfo (
    IN PMEMORY_MAP MemMap, 
    IN ULONG_PTR Base
    )

/*++

Routine Description:

    This function will return the appropriate Block descriptor
    for a given base address
    
Arguments:

    MemMap - The memory map
    
    Base - The base address for the descriptor we are looking for

Return Value:

    None

--*/

{
    ULONG_PTR Start;
    PBLOCK_DESCR BlockDescr = NULL;
    
    //
    //  Validate the range
    //

    if ((Base < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return NULL;
    }

    //
    //  Determine the appropriate index for lookup
    //

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }
    
    //
    //  If this is the lowest map level we'll return that entry
    //

    if (MemMap->Granularity == PAGE_SIZE) {

        return MemMap->Usage[ Start ];

    } else {

        //
        //  We need a lower detail level call
        //

        if (MemMap->Details[ Start ]) {

            return RtlpGetBlockInfo( MemMap->Details[Start], Base );
        }
    }

    //
    //  We didn't find something for this address, we'll return NULL then
    //

    return NULL;
}


BOOLEAN
RtlpGetMemoryFlag (
    IN PMEMORY_MAP MemMap, 
    IN ULONG_PTR Base
    )

/*++

Routine Description:

    This function returns the flag for a given base address
    
Arguments:

    MemMap - The memory map
    
    Base - The base address we want to know the flag

Return Value:

    None

--*/

{
    ULONG_PTR Start;
    PBLOCK_DESCR BlockDescr = NULL;
    
    //
    //  Validate the base address
    //

    if ((Base < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return FALSE;
    }

    //
    //  Determine the appropriate index for the given base address
    //

    if (Base > MemMap->Offset) {

        Start = (Base - MemMap->Offset) / MemMap->Granularity;

    } else {

        Start = 0;
    }

    if (MemMap->Granularity == PAGE_SIZE) {

        //
        //  Return the bit value if are in the case of
        //  the lowest detail level
        //

        return (MemMap->FlagsBitmap[Start / 8] & (1 << (Start % 8))) != 0;

    } else {

        //
        //  Lookup in the detailed map
        //

        if (MemMap->Details[Start]) {

            return RtlpGetMemoryFlag(MemMap->Details[Start], Base);
        }
    }

    return FALSE;
}


VOID 
RtlpInitializeLeakDetection ()

/*++

Routine Description:

    This function initialize the leak detection structures
    
Arguments:

Return Value:

    None

--*/

{
    ULONG_PTR AddressRange = PAGE_SIZE;
    ULONG_PTR PreviousAddressRange = PAGE_SIZE;

    //
    //  Initialize the global memory map
    //

    RtlpInitializeMap(&RtlpProcessMemoryMap, NULL);

    //
    //  Initialize the lists
    //

    InitializeListHead( &RtlpBusyList );
    InitializeListHead( &RtlpLeakList );
    
    //
    //  Determine the granularity for the highest memory map level
    //

    while (TRUE) {

        AddressRange = AddressRange * 256;

        if (AddressRange < PreviousAddressRange) {

            RtlpProcessMemoryMap.MaxAddress = MAXULONG_PTR;

            RtlpProcessMemoryMap.Granularity = PreviousAddressRange;

            break;
        }
        
        PreviousAddressRange = AddressRange;
    }

    RtlpTempBlocks = RtlpLeakAllocateBlock(PAGE_SIZE);
}


BOOLEAN
RtlpPushPageDescriptor(
    IN ULONG_PTR Page, 
    IN ULONG_PTR NumPages
    )

/*++

Routine Description:

    This routine binds the temporary block data into a block descriptor
    structure and push it to the memory map
    
Arguments:

    Page - The start page that wil contain this data
    
    NumPages - The number of pages to be set

Return Value:

    TRUE if succeeds.

--*/

{
    PBLOCK_DESCR PBlockDescr;
    PBLOCK_DESCR PreviousDescr;

    //
    //  Check whether we already have a block descriptor there
    //

    PreviousDescr = RtlpGetBlockInfo( &RtlpProcessMemoryMap, Page * PAGE_SIZE );

    if (PreviousDescr) {

        DbgPrint("Conflicting descriptors %08lx\n", PreviousDescr);

        return FALSE;
    }

    //
    //  We need to allocate a block descriptor structure and initializate it
    //  with the acquired data.
    //

    PBlockDescr = (PBLOCK_DESCR)RtlpLeakAllocateBlock(sizeof(BLOCK_DESCR) + (RtlpLDNumBlocks - 1) * sizeof(HEAP_BLOCK));

    if (!PBlockDescr) {

        DbgPrint("Unable to allocate page descriptor\n");

        return FALSE;
    }

    PBlockDescr->Type = UsageHeap;
    PBlockDescr->Count = RtlpLDNumBlocks;
    PBlockDescr->Heap = RtlpCrtHeapAddress;

    //
    //  Copy the temporary block buffer
    //

    RtlCopyMemory(PBlockDescr->Blocks, RtlpTempBlocks, RtlpLDNumBlocks * sizeof(HEAP_BLOCK));

    //
    //  If this page doesn't bnelong to the temporary heap, we insert all these blocks
    //  in the busy list
    //

    if (RtlpCrtHeapAddress != RtlpLeakHeapAddress) {

        LONG i;

        for (i = 0; i < RtlpLDNumBlocks; i++) {

            InitializeListHead( &PBlockDescr->Blocks[i].Entry );

            //
            //  We might have a blockin more different pages. but We'll 
            //  insert only ones in the list
            //

            if (PBlockDescr->Blocks[i].BlockAddress != RtlpPreviousStartAddress) {

                InsertTailList(&RtlpLeakList, &PBlockDescr->Blocks[i].Entry);

                PBlockDescr->Blocks[i].Count = 0;

                //
                //  Save the last block address
                //

                RtlpPreviousStartAddress = PBlockDescr->Blocks[i].BlockAddress;
            }
        }
    }

    //
    //  Set the memory map with this block descriptor
    //

    RtlpSetBlockInfo(&RtlpProcessMemoryMap, Page * PAGE_SIZE, NumPages * PAGE_SIZE, PBlockDescr);

    return TRUE;
}


BOOLEAN 
RtlpRegisterHeapBlocks (
    IN ULONG Context,
    IN PHEAP Heap OPTIONAL,
    IN PHEAP_SEGMENT Segment OPTIONAL,
    IN PHEAP_ENTRY Entry OPTIONAL,
    IN ULONG_PTR Data OPTIONAL
    )

/*++

Routine Description:

    This is the callback routine invoked while parsing the
    process heaps. Depending on the context it is invoked
    it performs different tasks.
        
Arguments:

    Context - The context this callback is being invoked
    
    Heap - The Heap structure
    
    Segment - The current Segment (if any)
    
    Entry - The current block entry (if any)
    
    Data - Additional data

Return Value:

    TRUE if succeeds.

--*/

{
    //
    //  Check whether we need to break at this address
    //

    if ((ULONG_PTR)Entry == RtlpBreakAtAddress) {

        DbgBreakPoint();
    }
    
    if (Context == CONTEXT_START_HEAP) {

        //
        //  The only thing we need to do in this case
        //  is to set the global current heap address
        //
        
        RtlpCrtHeapAddress = (ULONG_PTR)Heap;

        return TRUE;
    }
    
    //
    //  For a new segment, we mark the flag for the whole 
    //  reserved space for the segment the flag to TRUE
    //

    if (Context == CONTEXT_START_SEGMENT) {

        RtlpSetBlockInfo(&RtlpProcessMemoryMap, (ULONG_PTR)Segment->BaseAddress, Segment->NumberOfPages * PAGE_SIZE, NULL);
        
        return TRUE;
    }

    if (Context == CONTEXT_ERROR) {
        
        DbgPrint("HEAP %p (Seg %p) At %p Error: %s\n", 
               Heap,
               Segment,
               Entry,
               Data
               );

        return TRUE;
    } 

    if (Context == CONTEXT_END_BLOCKS) {
        
        if (RtlpLDPreviousPage) {

            RtlpPushPageDescriptor(RtlpLDPreviousPage, 1);
        }

        RtlpLDPreviousPage = 0;
        RtlpLDNumBlocks = 0;

    } else if (Context == CONTEXT_BUSY_BLOCK) {

        ULONG_PTR EndPage;

        //
        //  EnrtySize is assuming is the same as heap granularity
        //

        EndPage = (((ULONG_PTR)(Entry + Entry->Size)) - 1)/ PAGE_SIZE;

        //
        //  Check whether we received a valid block
        //

        if ((Context == CONTEXT_BUSY_BLOCK) &&
            !RtlpGetMemoryFlag(&RtlpProcessMemoryMap, (ULONG_PTR)Entry)) {

            DbgPrint("%p address isn't from the heap\n", Entry);
        }

        //
        //  Determine the starting page that contains the block
        //

        RtlpLDCrtPage = ((ULONG_PTR)Entry) / PAGE_SIZE;

        if (RtlpLDCrtPage != RtlpLDPreviousPage) {

            //
            //  We moved to an other page, so we need to save the previous
            //  information before going further
            //

            if (RtlpLDPreviousPage) {

                RtlpPushPageDescriptor(RtlpLDPreviousPage, 1);
            }
            
            //
            //  Reset the temporary data. We're starting a new page now
            //

            RtlpLDPreviousPage = RtlpLDCrtPage;
            RtlpLDNumBlocks = 0;
        }

         //
         //  Add this block to the current list
         //

         RtlpTempBlocks[RtlpLDNumBlocks].BlockAddress = (ULONG_PTR)Entry;
         RtlpTempBlocks[RtlpLDNumBlocks].Count = 0;
         RtlpTempBlocks[RtlpLDNumBlocks].Size = Entry->Size * sizeof(HEAP_ENTRY);

         RtlpLDNumBlocks++;
        
         if (EndPage != RtlpLDCrtPage) {

             //
             //  The block ends on a different page. We can then save the
             //  starting page and all others but the last one
             //

             RtlpPushPageDescriptor(RtlpLDCrtPage, 1);

             RtlpLDNumBlocks = 0;

             RtlpTempBlocks[RtlpLDNumBlocks].BlockAddress = (ULONG_PTR)Entry;
             RtlpTempBlocks[RtlpLDNumBlocks].Count = 0;
             RtlpTempBlocks[RtlpLDNumBlocks].Size = Entry->Size * sizeof(HEAP_ENTRY);

             RtlpLDNumBlocks += 1;
             
             if (EndPage - RtlpLDCrtPage > 1) {
                 
                 RtlpPushPageDescriptor(RtlpLDCrtPage + 1, EndPage - RtlpLDCrtPage - 1);
             }
             
             RtlpLDPreviousPage = EndPage;
        }

    } else if (Context == CONTEXT_VIRTUAL_BLOCK) {

        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock = (PHEAP_VIRTUAL_ALLOC_ENTRY)Data;
        ULONG_PTR EndPage;

        //
        //  EnrtySize is assuming is the same as heap granularity
        //

        EndPage = ((ULONG_PTR)Data + VirtualAllocBlock->CommitSize - 1)/ PAGE_SIZE;

        RtlpLDCrtPage = (Data) / PAGE_SIZE;

        if (RtlpLDCrtPage != RtlpLDPreviousPage) {

            //
            //  Save the previous data if we're moving to a new page
            //

            if (RtlpLDPreviousPage) {

                RtlpPushPageDescriptor(RtlpLDPreviousPage, 1);
            }
            
            RtlpLDPreviousPage = RtlpLDCrtPage;
            RtlpLDNumBlocks = 0;
        }

        //
        //  Initialize the block descriptor structure as we are
        //  starting a new page
        //

        RtlpLDNumBlocks = 0;

        RtlpTempBlocks[RtlpLDNumBlocks].BlockAddress = (ULONG_PTR)Entry;
        RtlpTempBlocks[RtlpLDNumBlocks].Count = 0;
        RtlpTempBlocks[RtlpLDNumBlocks].Size = VirtualAllocBlock->CommitSize;

        RtlpLDNumBlocks += 1;

        RtlpPushPageDescriptor(RtlpLDCrtPage, EndPage - RtlpLDCrtPage + 1);

        RtlpLDPreviousPage = 0;

    } else if ( Context == CONTEXT_LOOKASIDE_BLOCK ) {

        PBLOCK_DESCR PBlockDescr;
        LONG i;
                
        //
        //  Check whether we received a valid block
        //

        if (!RtlpGetMemoryFlag(&RtlpProcessMemoryMap, (ULONG_PTR)Entry)) {

            DbgPrint("%p address isn't from the heap\n", Entry);
        }
        
        PBlockDescr = RtlpGetBlockInfo( &RtlpProcessMemoryMap, (ULONG_PTR)Entry );

        if (!PBlockDescr) {

            DbgPrint("Error finding block from lookaside %p\n", Entry);

            return FALSE;
        }

        //
        //  Find the block in the block descriptor
        //

        for (i = 0; i < PBlockDescr->Count; i++) {

            if ((PBlockDescr->Blocks[i].BlockAddress <= (ULONG_PTR)Entry) &&
                (PBlockDescr->Blocks[i].BlockAddress + PBlockDescr->Blocks[i].Size > (ULONG_PTR)Entry)) {

                PBlockDescr->Blocks[i].Count = -10000;

                //
                //  Remove the block from the busy list
                //
                
                RemoveEntryList(&PBlockDescr->Blocks[i].Entry);

                return TRUE;
            }
        }

        //
        //  A block from lookaside should be busy for the heap structures.
        //  If we didn't find the block in the block list, something went 
        //  wrong. We make some noise here.
        //

        DbgPrint("Error, block %p from lookaside not found in allocated block list\n", Entry);
    }
    
    return TRUE;
}


PHEAP_BLOCK
RtlpGetHeapBlock (
    IN ULONG_PTR Address
    )

/*++

Routine Description:

    The function performs a lookup for the block descriptor
    for a given address. The address can point somewhere inside the 
    block.

        
Arguments:
    
    Address - The lookup address.

Return Value:

    Returns a pointer to the heap descriptor structure if found. 
    This is not NULL if the given address belongs to any busy heap block.

--*/

{
    PBLOCK_DESCR PBlockDescr;
    LONG i;

    //
    //  Find the block descriptor for the given address
    //

    PBlockDescr = RtlpGetBlockInfo( &RtlpProcessMemoryMap, Address );

    if ( (PBlockDescr != NULL) 
            &&
         (PBlockDescr->Heap != RtlpLeakHeapAddress)) {

        //
        //  Search through the blocks
        //

        for (i = 0; i < PBlockDescr->Count; i++) {

            if ((PBlockDescr->Blocks[i].BlockAddress <= Address) &&
                (PBlockDescr->Blocks[i].BlockAddress + PBlockDescr->Blocks[i].Size > Address)) {

                //
                //  Search again if the caller didn't pass a start address
                //

                if (PBlockDescr->Blocks[i].BlockAddress != Address) {

                    return RtlpGetHeapBlock(PBlockDescr->Blocks[i].BlockAddress);
                } 

                //
                //  we found a block here. 
                //

                return &(PBlockDescr->Blocks[i]);
            }
        }
    }

    return NULL;
}


VOID
RtlpDumpEntryHeader ( )

/*++

Routine Description:

    Writes the table header
        
Arguments:
    
Return Value:

--*/

{
    DbgPrint("Entry     User      Heap          Size  PrevSize  Flags\n");
    DbgPrint("------------------------------------------------------------\n");
}


VOID 
RtlpDumpEntryFlagDescription(
    IN ULONG Flags
    )

/*++

Routine Description:

    The function writes a description string for the given block flag
        
Arguments:

    Flags - Block flags
    
Return Value:

--*/

{
    if (Flags & HEAP_ENTRY_BUSY) DbgPrint("busy "); else DbgPrint("free ");
    if (Flags & HEAP_ENTRY_EXTRA_PRESENT) DbgPrint("extra ");
    if (Flags & HEAP_ENTRY_FILL_PATTERN) DbgPrint("fill ");
    if (Flags & HEAP_ENTRY_VIRTUAL_ALLOC) DbgPrint("virtual ");
    if (Flags & HEAP_ENTRY_LAST_ENTRY) DbgPrint("last ");
    if (Flags & HEAP_ENTRY_SETTABLE_FLAGS) DbgPrint("user_flag ");
}


VOID
RtlpDumpEntryInfo(
    IN ULONG_PTR HeapAddress,
    IN PHEAP_ENTRY Entry
    )

/*++

Routine Description:

    The function logs a heap block information
        
Arguments:

    HeapAddress - The heap that contains the entry to be displayied
    
    Entry - The block entry
    
Return Value:

    None.

--*/

{
    DbgPrint("%p  %p  %p  %8lx  %8lx  ",
            Entry,
            (Entry + 1),
            HeapAddress,
            Entry->Size << HEAP_GRANULARITY_SHIFT,
            Entry->PreviousSize << HEAP_GRANULARITY_SHIFT
            );

    RtlpDumpEntryFlagDescription(Entry->Flags);

    DbgPrint("\n");
}


BOOLEAN
RtlpScanHeapAllocBlocks ( )

/*++

Routine Description:

    The function does:
        - Scan all busy blocks and update the references to all other blocks
        - Build the list with leaked blocks
        - Reports the leaks

Arguments:

Return Value:

    Return TRUE if succeeds.

--*/

{

    PLIST_ENTRY Next;

    //
    //  walk the busy list
    //

    Next = RtlpBusyList.Flink;

    while (Next != &RtlpBusyList) {
        
        PHEAP_BLOCK Block = CONTAINING_RECORD(Next, HEAP_BLOCK, Entry);
        
        PULONG_PTR CrtAddress = (PULONG_PTR)(Block->BlockAddress + sizeof(HEAP_ENTRY));
        
        //
        //  Move to the next block in the list
        //

        Next = Next->Flink;

        //
        //  Iterate through block space and update
        //  the references for every block found here
        //

        while ((ULONG_PTR)CrtAddress < Block->BlockAddress + Block->Size) {

            PHEAP_BLOCK pBlock = RtlpGetHeapBlock( *CrtAddress );

            if (pBlock) {

                //
                //  We found a block. we increment then the reference count
                //
                
                if (pBlock->Count == 0) {
                    
                    RemoveEntryList(&pBlock->Entry);
                    InsertTailList(&RtlpBusyList, &pBlock->Entry);
                }
                
                pBlock->Count += 1;

                if (pBlock->BlockAddress == RtlpBreakAtAddress) {

                    DbgBreakPoint();
                }
            }

            //
            //  Go to the next possible pointer
            //

            CrtAddress++;
        }
    }

    //
    //  Now walk the leak list, and report leaks.
    //  Also any pointer found here will be dereferenced and added to
    //  the end of list.
    //
    
    Next = RtlpLeakList.Flink;

    while (Next != &RtlpLeakList) {
        
        PHEAP_BLOCK Block = CONTAINING_RECORD(Next, HEAP_BLOCK, Entry);
        PBLOCK_DESCR PBlockDescr = RtlpGetBlockInfo( &RtlpProcessMemoryMap, Block->BlockAddress );
        PULONG_PTR CrtAddress = (PULONG_PTR)(Block->BlockAddress + sizeof(HEAP_ENTRY));

        if (PBlockDescr) {

            //
            //  First time we need to display the header
            //

            if (RtlpLeaksCount == 0) {

                RtlpDumpEntryHeader();
            }

            //
            //  Display the information for this block
            //

            RtlpDumpEntryInfo( PBlockDescr->Heap, (PHEAP_ENTRY)Block->BlockAddress);

            RtlpLeaksCount += 1;
        }
        
        //
        //  Go to the next item from the leak list
        //

        Next = Next->Flink;
    }

    return TRUE;
}



BOOLEAN
RtlpScanProcessVirtualMemory()

/*++

Routine Description:

    This function scan the whole process virtual address space and lookup
    for possible references to busy blocks

Arguments:

Return Value:

    Return TRUE if succeeds.

--*/

{
    ULONG_PTR lpAddress = 0;
    MEMORY_BASIC_INFORMATION Buffer;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  Loop through virtual memory zones, we'll skip the heap space here
    //

    while ( NT_SUCCESS( Status ) ) {
        
        Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                       (PVOID)lpAddress,
                                       MemoryBasicInformation,
                                       &Buffer,
                                       sizeof(Buffer),
                                       NULL );

        if (NT_SUCCESS( Status )) {

            //
            //  If the page can be written, it might contain pointers to heap blocks
            //  We'll exclude at this point the heap address space. We scan the heaps
            //  later.
            //

            if ((Buffer.AllocationProtect & (PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
                    &&
                (Buffer.State & MEM_COMMIT) 
                    && 
                !RtlpGetMemoryFlag(&RtlpProcessMemoryMap, (ULONG_PTR)lpAddress)) {

                PULONG_PTR Pointers = (PULONG_PTR)lpAddress;
                ULONG_PTR i, Count;

                //
                //  compute the number of possible pointers
                //

                Count = Buffer.RegionSize / sizeof(ULONG_PTR);

                try {

                    //
                    //  Loop through pages and check any possible pointer reference
                    //
                    
                    for (i = 0; i < Count; i++) {

                        //
                        //  Check whether we have a pointer to a busy heap block
                        //

                        PHEAP_BLOCK pBlock = RtlpGetHeapBlock(*Pointers);

                        if (pBlock) {

                            if (pBlock->BlockAddress == RtlpBreakAtAddress) {

                                DbgBreakPoint();
                            }

                            if (pBlock->Count == 0) {
                                
                                RemoveEntryList(&pBlock->Entry);
                                InsertTailList(&RtlpBusyList, &pBlock->Entry);
                            }
                            
                            pBlock->Count += 1;
                        }

                        //
                        //  Move to the next pointer
                        //

                        Pointers++;
                    }
                
                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    //  Nothing more to do
                    //
                }
            }
            
            //
            //  Move to the next VM range to query
            //

            lpAddress += Buffer.RegionSize;
        }
    }
    
    //
    //  Now update the references provided by the busy blocks
    //

    RtlpScanHeapAllocBlocks( );

    return TRUE;
}



VOID
RtlDetectHeapLeaks ()

/*++

Routine Description:

    This routine detects and display the leaks found in the current process
    
    NOTE: The caller must make sure no other thread can change some heap data
    while a tread is executing this one. In general this function is supposed 
    to be called from LdrShutdownProcess.
    
    
Arguments:

Return Value:

--*/

{

    //
    //  Check if the global flag has the leak detection enabled
    //

    if (RtlpShutdownProcessFlags & (INSPECT_LEAKS | BREAK_ON_LEAKS)) {
        RtlpLeaksCount = 0;

        //
        //  Create a temporary heap that will be used for any alocation
        //  of these functions. 
        //

        RtlpLeakHeap = RtlCreateHeap(HEAP_NO_SERIALIZE | HEAP_GROWABLE, NULL, 0, 0, NULL, NULL);

        if (RtlpLeakHeap) {

            PPEB ProcessPeb = NtCurrentPeb();

            HeapDebugPrint( ("Inspecting leaks at process shutdown ...\n") );

            RtlpInitializeLeakDetection();

            //
            //  The last heap from the heap list is our temporary heap
            //

            RtlpLeakHeapAddress = (ULONG_PTR)ProcessPeb->ProcessHeaps[ ProcessPeb->NumberOfHeaps - 1 ];

            //
            //  Scan all process heaps, build the memory map and 
            //  the busy block list
            //

            RtlpReadProcessHeaps( RtlpRegisterHeapBlocks );
            
            //
            //  Scan the process virtual memory and the busy blocks
            //  At the end build the list with leaked blocks and report them
            //

            RtlpScanProcessVirtualMemory();

            //
            //  Destroy the temporary heap
            //

            RtlDestroyHeap(RtlpLeakHeap);

            RtlpLeakHeap = NULL;

            //
            //  Report the final statement about the process leaks
            //

            if (RtlpLeaksCount) {
                
                HeapDebugPrint(("%ld leaks detected.\n", RtlpLeaksCount));

                if (RtlpShutdownProcessFlags & BREAK_ON_LEAKS) {

                    DbgBreakPoint();
                }
            
            } else {

                HeapDebugPrint( ("No leaks detected.\n"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\guid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    guid.c

Abstract:

    This Module implements the guid manipulation functions.

Author:

    George Shaw (GShaw) 9-Oct-1996

Environment:

    Pure Runtime Library Routine

Revision History:

--*/

#include "nt.h"
#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
static
int
__cdecl
ScanHexFormat(
    IN const WCHAR* Buffer,
    IN ULONG MaximumLength,
    IN const WCHAR* Format,
    ...);

#pragma alloc_text(PAGE, RtlStringFromGUID)
#pragma alloc_text(PAGE, ScanHexFormat)
#pragma alloc_text(PAGE, RtlGUIDFromString)
#endif // ALLOC_PRAGMA && NTOS_KERNEL_RUNTIME

extern const WCHAR GuidFormat[];

#define GUID_STRING_SIZE 38


NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    IN REFGUID Guid,
    OUT PUNICODE_STRING GuidString
    )
/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    Guid -
        Contains the GUID to translate.

    GuidString -
        Returns a string that represents the textual format of the GUID.
        Caller must call RtlFreeUnicodeString to free the buffer when done with
        it.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if the user string was succesfully
    initialized.

--*/
{
    RTL_PAGED_CODE();
    GuidString->Length = GUID_STRING_SIZE * sizeof(WCHAR);
    GuidString->MaximumLength = GuidString->Length + sizeof(UNICODE_NULL);
    if (!(GuidString->Buffer = RtlAllocateStringRoutine(GuidString->MaximumLength))) {
        return STATUS_NO_MEMORY;
    }
    swprintf(GuidString->Buffer, GuidFormat, Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
    return STATUS_SUCCESS;
}


static
int
__cdecl
ScanHexFormat(
    IN const WCHAR* Buffer,
    IN ULONG MaximumLength,
    IN const WCHAR* Format,
    ...)
/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    Buffer -
        Contains the source buffer which is to be scanned.

    MaximumLength -
        Contains the maximum length in characters for which Buffer is searched.
        This implies that Buffer need not be UNICODE_NULL terminated.

    Format -
        Contains the format string which defines both the acceptable string format
        contained in Buffer, and the variable parameters which follow.

Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     FormatItems;

    va_start(ArgList, Format);
    for (FormatItems = 0;;) {
        switch (*Format) {
        case 0:
            return (MaximumLength && *Buffer) ? -1 : FormatItems;
        case '%':
            Format++;
            if (*Format != '%') {
                ULONG   Number;
                int     Width;
                int     Long;
                PVOID   Pointer;

                for (Long = 0, Width = 0;; Format++) {
                    if ((*Format >= '0') && (*Format <= '9')) {
                        Width = Width * 10 + *Format - '0';
                    } else if (*Format == 'l') {
                        Long++;
                    } else if ((*Format == 'X') || (*Format == 'x')) {
                        break;
                    }
                }
                Format++;
                for (Number = 0; Width--; Buffer++, MaximumLength--) {
                    if (!MaximumLength)
                        return -1;
                    Number *= 16;
                    if ((*Buffer >= '0') && (*Buffer <= '9')) {
                        Number += (*Buffer - '0');
                    } else if ((*Buffer >= 'a') && (*Buffer <= 'f')) {
                        Number += (*Buffer - 'a' + 10);
                    } else if ((*Buffer >= 'A') && (*Buffer <= 'F')) {
                        Number += (*Buffer - 'A' + 10);
                    } else {
                        return -1;
                    }
                }
                Pointer = va_arg(ArgList, PVOID);
                if (Long) {
                    *(PULONG)Pointer = Number;
                } else {
                    *(PUSHORT)Pointer = (USHORT)Number;
                }
                FormatItems++;
                break;
            }
            /* no break */
        default:
            if (!MaximumLength || (*Buffer != *Format)) {
                return -1;
            }
            Buffer++;
            MaximumLength--;
            Format++;
            break;
        }
    }
}


NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    )
/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/
{
    USHORT    Data4[8];
    int       Count;

    RTL_PAGED_CODE();
    if (ScanHexFormat(GuidString->Buffer, GuidString->Length / sizeof(WCHAR), GuidFormat, &Guid->Data1, &Guid->Data2, &Guid->Data3, &Data4[0], &Data4[1], &Data4[2], &Data4[3], &Data4[4], &Data4[5], &Data4[6], &Data4[7]) == -1) {
        return STATUS_INVALID_PARAMETER;
    }
    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Guid->Data4[Count] = (UCHAR)Data4[Count];
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heaplowf.c ===
/*

Copyright (c) 2000  Microsoft Corporation

File name:

    heaplowf.c
   
Author:
    
    adrmarin  Thu Nov 30 2000
    
    Low Fragmentation Heap implementation
    
    The file implements a bucket oriented heap. This approach provides in general 
    a significant bounded low fragmentation for large heap usages. 
    
    Generally, applications tend to use only a few sizes for allocations. LFH contains a 
    number of 128 buckets to allocate blocks up to 16K. The allocation granularity grows with 
    the block size, keeping though a reasonable internal fragmentation (~6% for the worst case). 
    The size and the granularity within each range is shown in the table below:

    Size    Range	Granularity	Buckets
    0	    256	    8	        32
    257	    512	    16	        16
    513	    1024	32	        16
    1025	2048	64	        16
    2049	4096	128	        16
    4097	8192	256	        16
    8193	16384	512	        16

  	Regardless how randomly the allocation pattern is, the LFH will handle only 
    128 different sizes, choosing the smallest block large enough to complete the request. 
  	Each bucket places individual allocations into bigger blocks (sub-segments), 
    which contain several other blocks with the same size. The allocations and free
    operations within sub-segments are lock free, the algorithm being similar with allocations
    from lookasides (interlocked S-Lists). This is the fastest path of the heap allocator, 
    and provides performance similar with lookasides; it also keeps all these blocks together, 
    avoiding fragmentation. Depending upon the heap usage, each bucket can have several sub-segments
    allocated to satisfy all requests, but only one of these is currently in use 
    for allocations (it is active). When the active sub-segments has no sub-blocks available, 
    another sub-segment will become active to satisfy the allocation requests. If the bucket does 
    not have any available sub-segments, it will allocate a new one from the NT heap. 
    Also, if a sub-segment does not contain any busy sub-block, the whole amount of memory 
    will be returned to the NT heap. Unlike the allocations, which are done from the 
    active sub-segments, the free operations can be done to every sub-segments, either active or passive. 
    
  	There are no constrains regarding the number of blocks within a sub-segment. 
    LFH is more concerned with the sub-segments sizes that are allocated from the NT heap. 
    Since the best-fit policy is good if we keep a relatively small number of sizes and blocks,
    the LFH will allocate sub-segments in size power of two. In practice, only about 9 different 
    sizes will be requested from the NT heap (from 1K to 512K). In this way, depending upon the size
    in the current bucket will result a number of blocks. When the sub-segment is destroyed, 
    that big chunk is returned to the NT heap, making it possible to be reused later for other buckets.
    
    Note that for some app scenarios, with low heap usage, random distributed, LFH is not the best choice.
    
    To achieve a good SMP scalability, all operations here are non-blocking. The only situation where 
    we aquire a critical section is when wi allocate an array of sub-segment descriptors. 
    This is a very rare case, even for an intensive MP usage. 
    
*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

//#define _HEAP_DEBUG

#define PrintMsg    DbgPrint
#define HeapAlloc   RtlAllocateHeap
#define HeapFree    RtlFreeHeap

//
//  The conversion code needs the Lock/Unlock APIs
//

#define HeapLock    RtlLockHeap
#define HeapUnlock  RtlUnlockHeap
#define HeapSize  RtlSizeHeap

#ifdef _HEAP_DEBUG

#define HeapValidate RtlValidateHeap

#endif //_HEAP_DEBUG


PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

#define RtlpSubSegmentPop RtlpInterlockedPopEntrySList

#define RtlpSubSegmentPush(SList,Block)  \
        RtlpInterlockedPushEntrySList((SList),(PSINGLE_LIST_ENTRY)(Block))

#define TEBDesiredAffinity (NtCurrentTeb()->HeapVirtualAffinity)

//
//  On x86 is not available the interlockCompareExchange64. We need to implement it localy.
//  Also the macros below will take care of the inconsistency between definition 
//  of this function on X86 and 64-bit platforms
//

#if !defined(_WIN64)

LONGLONG
FASTCALL
RtlInterlockedCompareExchange64 (     
   IN OUT PLONGLONG Destination,      
   IN PLONGLONG Exchange,             
   IN PLONGLONG Comperand             
   );                     

#define LOCKCOMP64(l,n,c) \
    (RtlInterlockedCompareExchange64((PLONGLONG)(l), (PLONGLONG)(&n), (PLONGLONG)(&c)) == (*((PLONGLONG)(&c))))

#else //#if defined(_WIN64)

//
//  64 bit specific definitions
//

#define LOCKCOMP64(l,n,c) \
    (_InterlockedCompareExchange64((PLONGLONG)(l), *((PLONGLONG)(&n)), *((PLONGLONG)(&c))) == (*((PLONGLONG)(&c))))

#endif // #if defined(_WIN64)

ULONG
FORCEINLINE
RtlpGetFirstBitSet64(
    LONGLONG Mask
    )
{
    if ((ULONG)Mask) {

        return RtlFindFirstSetRightMember((ULONG)Mask);
    }

    return 32 + RtlFindFirstSetRightMember((ULONG)(Mask >> 32));
}

#define HEAP_AFFINITY_LIMIT 64  // N.B.  This cannot be larger than 64 
                                // (the number of bits in LONGLONG data type)

typedef struct _AFFINITY_STATE{

    LONGLONG FreeEntries;
    LONGLONG UsedEntries;

    ULONG Limit;
    LONG CrtLimit;

    ULONG_PTR OwnerTID[ HEAP_AFFINITY_LIMIT ];

    //
    //  The counters below are not absolutely necessary for the affinity manager.
    //  But these help understanding the frequence of affinity changes. In general 
    //  accessing of these fields should be rare, even for many threads (like hundreds)
    //  Benchmarks didn't show any visible difference with all these removed
    //

    ULONG AffinitySwaps;
    ULONG AffinityResets;
    ULONG AffinityLoops;
    ULONG AffinityAllocs;

} AFFINITY_STATE, *PAFFINITY_STATE;

#define GetCrtThreadId() ((ULONG_PTR)NtCurrentTeb()->ClientId.UniqueThread)

AFFINITY_STATE RtlpAffinityState;

VOID
RtlpInitializeAffinityManager(
    UCHAR Size
    )

/*++

Routine Description:
    
    This routine initialize the affinity manager. This should be done
    only ones into that process, before any other affinity function is invoked
        
Arguments:

    Size - The number of virtual affinity entries
    
    
Return Value:
    
    None
    
--*/

{

    //
    //  The size of the affinity bitmap is limited to the number of bits from
    //  an LONGLONG data type. 
    //

    if (Size > HEAP_AFFINITY_LIMIT) {

        PrintMsg( "HEAP: Invalid size %ld for the affinity mask. Using %ld instead\n", 
                  Size, 
                  HEAP_AFFINITY_LIMIT );
        
        Size = HEAP_AFFINITY_LIMIT;
    }

    RtlpAffinityState.FreeEntries = 0;
    RtlpAffinityState.UsedEntries = 0;
    RtlpAffinityState.Limit = Size;

    RtlpAffinityState.CrtLimit = -1;
    RtlpAffinityState.AffinitySwaps = 0;
    RtlpAffinityState.AffinityResets = 0;
    RtlpAffinityState.AffinityAllocs = 0;
}


ULONG
FASTCALL
RtlpAllocateAffinityIndex(
    )

/*++

Routine Description:
    
    The function allocates a new index into the virtual affinity array
        
Arguments:
    
    
Return Value:
    
    Return the index, which the current thread can use further. 
    
--*/

{
    ULONGLONG CapturedMask;

    InterlockedIncrement(&RtlpAffinityState.AffinityAllocs);

RETRY:

    //
    //  Check first whether we have at least a free entry in the affinity mask
    //

    if (CapturedMask = RtlpAffinityState.FreeEntries) {

        ULONGLONG AvailableMask;

        AvailableMask = CapturedMask & RtlpAffinityState.UsedEntries;

        if (AvailableMask) {

            ULONG Index = RtlpGetFirstBitSet64(AvailableMask);
            LONGLONG NewMask = CapturedMask & ~((LONGLONG)1 << Index);
            
            if (!LOCKCOMP64(&RtlpAffinityState.FreeEntries, NewMask, CapturedMask)) {

                goto RETRY;
            }

            RtlpAffinityState.OwnerTID[ Index ] = GetCrtThreadId();

            return  Index;
        }

    } 
    
    //
    //  Nothing available. We need to allocate a new entry. We won't do this
    //  unless it's absolutely necessary
    //

    if (RtlpAffinityState.CrtLimit < (LONG)(RtlpAffinityState.Limit - 1)) {

        ULONG NewLimit = InterlockedIncrement(&RtlpAffinityState.CrtLimit);

        //
        //  We already postponed growing the size. We have to do now
        //

        if ( NewLimit < RtlpAffinityState.Limit) {

            LONGLONG CapturedUsed;
            LONGLONG NewMask;

            do {

                CapturedUsed = RtlpAffinityState.UsedEntries;
                NewMask = CapturedUsed | ((LONGLONG)1 << NewLimit);

            } while ( !LOCKCOMP64(&RtlpAffinityState.UsedEntries, NewMask, CapturedUsed) );

            RtlpAffinityState.FreeEntries = ~((LONGLONG)1 << NewLimit);

            RtlpAffinityState.OwnerTID[ NewLimit ] = GetCrtThreadId();

            return NewLimit;


        } else {

            InterlockedDecrement(&RtlpAffinityState.CrtLimit);
        }
    }
    
    if ((RtlpAffinityState.FreeEntries & RtlpAffinityState.UsedEntries) == 0) {

        RtlpAffinityState.FreeEntries = (LONGLONG)-1;

        InterlockedIncrement( &RtlpAffinityState.AffinityResets );
    }

    InterlockedIncrement( &RtlpAffinityState.AffinityLoops );

    goto RETRY;

    //
    //  return something to make the compiler happy
    //

    return 0;
}


ULONG
FORCEINLINE
RtlpGetThreadAffinity(
    )

/*++

Routine Description:
    
    The function returns the affinity which the current thread can use.
    This function is designed to be called pretty often. It has a quick path,
    which test whether the last affinity assigned did not expired. 
    If the number of threads is less than the number of processors, the threads will
    never get moved from an index to another.
        
Arguments:
    None  
    
Return Value:
    
    Return the index, which the current thread can use further. 
    
--*/

{
    LONG NewAffinity;
    LONG CapturedAffinity = TEBDesiredAffinity - 1;

    if (CapturedAffinity >= 0) {

        if (RtlpAffinityState.OwnerTID[CapturedAffinity] == GetCrtThreadId()) {
            
            if (RtlpAffinityState.FreeEntries & ((LONGLONG)1 << CapturedAffinity)) {

                LONGLONG NewMask = RtlpAffinityState.FreeEntries & ~(((LONGLONG)1 << CapturedAffinity));

                LOCKCOMP64(&RtlpAffinityState.FreeEntries, NewMask, RtlpAffinityState.FreeEntries);
            }

            return CapturedAffinity;
        }

    } else {

        //
        //  A new thread came up. Reset the affinity
        //

        RtlpAffinityState.FreeEntries = (LONGLONG) -1;
    }

    NewAffinity = RtlpAllocateAffinityIndex();

    if ((NewAffinity + 1) != TEBDesiredAffinity) {

        InterlockedIncrement( &RtlpAffinityState.AffinitySwaps );
    }

    TEBDesiredAffinity = NewAffinity + 1;

    return NewAffinity;
}

//
//  Low fragmentation heap tunning constants
//

#define LOCALPROC FORCEINLINE

//
//  The total number of buckets. The default is 128 which coveres 
//  blocks up to 16 K
//
//  N.B. HEAP_BUCKETS_COUNT must be > 32 and multiple of 16
//

#define HEAP_BUCKETS_COUNT      128  

//
//  Defining the limits for the number of blocks that can exist in sub-segment
//      Number of blocks >= 2^HEAP_MIN_BLOCK_CLASS
//          &&
//      Number of blocks <= 2^HEAP_MAX_BLOCK_CLASS
//          &&
//      sub-segment size <= HEAP_MAX_SUBSEGMENT_SIZE
//

#define HEAP_MIN_BLOCK_CLASS    4
#define HEAP_MAX_BLOCK_CLASS    10  
#define HEAP_MAX_SUBSEGMENT_SIZE (0x0000F000 << HEAP_GRANULARITY_SHIFT)  // must be smaller than HEAP_MAXIMUM_BLOCK_SIZE

//
//  If a size become very popular, LFH increases the number of blocks
//  that could be placed into the subsegments, with the formula below.
//

#define RtlpGetDesiredBlockNumber(Aff,T) \
    ((Aff) ? (((T) >> 4) / (RtlpHeapMaxAffinity)) : ((T) >> 4))


//
//  LFH uses only a few different sizes for subsegments. These have sizes 
//  of power of two between
//      2^HEAP_LOWEST_USER_SIZE_INDEX and 2^HEAP_HIGHEST_USER_SIZE_INDEX
//

#define HEAP_LOWEST_USER_SIZE_INDEX 7
#define HEAP_HIGHEST_USER_SIZE_INDEX 18

//
//  The sub-segments descriptors are allocated in zones, based on
//  processor affinity. These descriptors are in general small structures,
//  so ignoring the affinity impacts the performance on MP machines with
//  caches > sizeof( HEAP_SUBSEGMENT ).
//  Also it significantly reduces the number of calls to the NT heap
//

#define HEAP_DEFAULT_ZONE_SIZE  (1024 - sizeof(HEAP_ENTRY))  // allocate 1 K at ones

//
//  Each bucket holds a number of subsegments into a cache, in order
//  to find the emptiest one for reusage. FREE_CACHE_SIZE defines the 
//  number of sub-segments that will be searched
//

#define FREE_CACHE_SIZE  16

//
//  On low memory, the subsegments that are almost free can be converted to 
//  the regular NT heap. HEAP_CONVERT_LIMIT gives the maximum space that can be
//  converted at ones
//

#define HEAP_CONVERT_LIMIT      0x1000000  // Do not convert more than 16 MBytes at ones

//
//  Cache tunning constants.
//  LFH keeps the subsegments into a cache to be easy reused for different allocations
//  This significantly reduces the number of calls to the NT heap with huge impact
//  in scalability, performance and footprint for the most common cases.
//  The only problem is in a shrinking phase, when the app frees the most part
//  of the memory, and we want to reduce the commited space for the heap.
//  We handle this case with the following two constants:
//      - HEAP_CACHE_FREE_THRESHOLD
//      - HEAP_CACHE_SHIFT_THRESHOLD
//
//  The heap will free a block to the NT heap only if these conditions are TRUE:
//      - The number of blocks in cache for that size > HEAP_CACHE_FREE_THRESHOLD
//      - The number of blocks in cache for that size > 
//              (Total number of blocks of that size) >> HEAP_CACHE_SHIFT_THRESHOLD
//
//

#define HEAP_CACHE_FREE_THRESHOLD   8
#define HEAP_CACHE_SHIFT_THRESHOLD  2


//
//   Other definitions
//

#define NO_MORE_ENTRIES        0xFFFF

//
//  Locking constants
//

#define HEAP_USERDATA_LOCK  1
#define HEAP_PUBLIC_LOCK    2
#define HEAP_ACTIVE_LOCK    4
#define HEAP_CONVERT_LOCK   8

#define HEAP_FREE_BLOCK_SUCCESS     1
#define HEAP_FREE_BLOCK_CONVERTED   2
#define HEAP_FREE_SEGMENT_EMPTY     3

//
//  Low fragmentation heap data structures
//

typedef union _HEAP_BUCKET_COUNTERS{

    struct {
        
        volatile ULONG  TotalBlocks;
        volatile ULONG  SubSegmentCounts;
    };

    volatile LONGLONG Aggregate64;

} HEAP_BUCKET_COUNTERS, *PHEAP_BUCKET_COUNTERS;

//
//  The HEAP_BUCKET structure handles same size allocations 
//

typedef struct _HEAP_BUCKET {

    HEAP_BUCKET_COUNTERS Counters;

    USHORT BlockUnits;
    UCHAR SizeIndex;
    UCHAR UseAffinity;
    
    LONG Conversions;

} HEAP_BUCKET, *PHEAP_BUCKET;

//
//  LFH heap uses zones to allocate sub-segment descriptors. This will preallocate 
//  a large block and then for each individual sub-segment request will move the 
//  water mark pointer with a non-blocking operation
//

typedef struct _LFH_BLOCK_ZONE {

    LIST_ENTRY ListEntry;
    PVOID      FreePointer;
    PVOID      Limit;

} LFH_BLOCK_ZONE, *PLFH_BLOCK_ZONE;

typedef struct _HEAP_LOCAL_SEGMENT_INFO {

    PHEAP_SUBSEGMENT Hint;
    PHEAP_SUBSEGMENT ActiveSubsegment;

    PHEAP_SUBSEGMENT CachedItems[ FREE_CACHE_SIZE ];
    SLIST_HEADER SListHeader;

    SIZE_T BusyEntries;
    SIZE_T LastUsed;

} HEAP_LOCAL_SEGMENT_INFO, *PHEAP_LOCAL_SEGMENT_INFO;

typedef struct _HEAP_LOCAL_DATA {
    
    //
    //  We reserve the 128 bytes below to avoid sharing memory
    //  into the same cacheline on MP machines
    //

    UCHAR Reserved[128];

    volatile PLFH_BLOCK_ZONE CrtZone;
    struct _LFH_HEAP * LowFragHeap;

    HEAP_LOCAL_SEGMENT_INFO SegmentInfo[HEAP_BUCKETS_COUNT];
    SLIST_HEADER DeletedSubSegments;

    ULONG Affinity;
    ULONG Reserved1;

} HEAP_LOCAL_DATA, *PHEAP_LOCAL_DATA;

//
//  Fixed size large block cache data structures & definitions
//  This holds in S-Lists the blocks that can be free, but it
//  delay the free until no other thread is doing a heap operation
//  This helps reducing the contention on the heap lock,
//  improve the scalability with a relatively low memory footprint
//

#define HEAP_USER_ENTRIES (HEAP_HIGHEST_USER_SIZE_INDEX - HEAP_LOWEST_USER_SIZE_INDEX + 1)

typedef struct _USER_MEMORY_CACHE {

    SLIST_HEADER UserBlocks[ HEAP_USER_ENTRIES ];

    ULONG FreeBlocks;
    ULONG Sequence;

    ULONG MinDepth[ HEAP_USER_ENTRIES ];
    ULONG AvailableBlocks[ HEAP_USER_ENTRIES ];
    
} USER_MEMORY_CACHE, *PUSER_MEMORY_CACHE;

typedef struct _LFH_HEAP {
    
    RTL_CRITICAL_SECTION Lock;

    LIST_ENTRY SubSegmentZones;
    SIZE_T ZoneBlockSize;
    HANDLE Heap;
    LONG Conversions;
    LONG ConvertedSpace;

    ULONG SegmentChange;           //  
    ULONG SegmentCreate;           //  Various counters (optional)
    ULONG SegmentInsertInFree;     //   
    ULONG SegmentDelete;           //     

    USER_MEMORY_CACHE UserBlockCache;

    //
    //  Bucket data
    //

    HEAP_BUCKET Buckets[HEAP_BUCKETS_COUNT];

    //
    //  The LocalData array must be the last field in LFH structures
    //  The sizes of the array is choosen depending upon the
    //  number of processors.
    //

    HEAP_LOCAL_DATA LocalData[1];

} LFH_HEAP, *PLFH_HEAP;

//
//  Debugging macros. 
//

#ifdef _HEAP_DEBUG

LONG RtlpColissionCounter = 0;

#define LFHEAPASSERT(exp) \
    if (!(exp)) {       \
        PrintMsg( "\nERROR: %s\n\tSource File: %s, line %ld\n", #exp, __FILE__, __LINE__);\
        DbgBreakPoint();            \
    }

#define LFHEAPWARN(exp) \
    if (!(exp)) PrintMsg( "\nWARNING: %s\n\tSource File: %s, line %ld\n", #exp, __FILE__, __LINE__);

#define LFH_DECLARE_COUNTER  ULONG __Counter = 0;

#define LFH_UPDATE_COUNTER                      \
    if ((++__Counter) > 1) {                        \
        InterlockedIncrement(&RtlpColissionCounter);   \
    }

#else

#define LFHEAPASSERT(exp)
#define LFHEAPWARN(exp)

#define LFH_DECLARE_COUNTER
#define LFH_UPDATE_COUNTER

#endif


BOOLEAN
FORCEINLINE
RtlpLockSubSegment(
    PHEAP_SUBSEGMENT SubSegment,
    ULONG LockMask
    );

BOOLEAN
LOCALPROC
RtlpUnlockSubSegment(
    PHEAP_LOCAL_DATA LocalData,
    PHEAP_SUBSEGMENT SubSegment,
    ULONG LockMask
    );

BOOLEAN
FASTCALL
RtlpConvertSegmentToHeap (
    PLFH_HEAP LowFragHeap,
    PHEAP_SUBSEGMENT SubSegment
    );

ULONG
RtlpFlushLFHeapCache (
    PLFH_HEAP LowFragHeap
    );

//
//  Heap manager globals
//

SIZE_T RtlpBucketBlockSizes[HEAP_BUCKETS_COUNT];
ULONG  RtlpHeapMaxAffinity = 0;


//
//  User block management private functions
//

SIZE_T
FORCEINLINE
RtlpConvertSizeIndexToSize(
    UCHAR SizeIndex
    )

/*++

Routine Description:
    
    The function converts a size index into a memory block size.
    LFH requests only these particular sizes from the NT heap
    
Arguments:
    
   SizeIndex - The size category
    
Return Value:
    
    The size in bytes to be requested from the NT heap

--*/

{
    SIZE_T Size = 1 << SizeIndex;

    LFHEAPASSERT( SizeIndex >= HEAP_LOWEST_USER_SIZE_INDEX );
    LFHEAPASSERT( SizeIndex <= HEAP_HIGHEST_USER_SIZE_INDEX );

    if (Size > HEAP_MAX_SUBSEGMENT_SIZE) {

        Size = HEAP_MAX_SUBSEGMENT_SIZE;
    }

    return Size - sizeof(HEAP_ENTRY);
}

PVOID
FASTCALL
RtlpAllocateUserBlock(
    PLFH_HEAP LowFragHeap,
    UCHAR     SizeIndex
    )

/*++

Routine Description:
    
    The function allocates a large block for the sub-segment user data
    It tries first to allocate from the cache. So it makes an NT heap call
    only if the first one fails. The blocks allocated with this routine 
    can only have power of 2 sizes (from 256, 512, ....)
            
Arguments:
    
    LowFragHeap - The pointer to the LF heap
    
    SizeIndex - The category size to be allocated
    
Return Value:
    
    Returns a pointer to the new allocated block, or NULL if the operation fails

--*/

{
    PVOID ListEntry;
    PHEAP_USERDATA_HEADER UserBlock = NULL;

    LFHEAPASSERT(SizeIndex >= HEAP_LOWEST_USER_SIZE_INDEX);
    LFHEAPASSERT(SizeIndex <= HEAP_HIGHEST_USER_SIZE_INDEX);

    //
    //  Allocates first from the slist cache
    //
    __try {

        //
        //  Search first into the indicated index
        //
    
        if (ListEntry = RtlpSubSegmentPop(&LowFragHeap->UserBlockCache.UserBlocks[SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX])) {
            
            UserBlock = CONTAINING_RECORD(ListEntry, HEAP_USERDATA_HEADER, SFreeListEntry);

            leave;
        }

        //
        //  Look for a smaller size
        //
        
        if (SizeIndex > HEAP_LOWEST_USER_SIZE_INDEX) {

            if (ListEntry = RtlpSubSegmentPop(&LowFragHeap->UserBlockCache.UserBlocks[SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX - 1])) {
                
                UserBlock = CONTAINING_RECORD(ListEntry, HEAP_USERDATA_HEADER, SFreeListEntry);

                leave;
            }
        }
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        //  Nothing to do
        //
    }

    if (UserBlock == NULL) {
        //
        //  There is no available blocks into the cache. We need to 
        //  allocate the subsegment from the NT heap
        //

        InterlockedIncrement(&LowFragHeap->UserBlockCache.AvailableBlocks[ SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX ]);

        UserBlock = HeapAlloc(LowFragHeap->Heap, HEAP_NO_CACHE_BLOCK, RtlpConvertSizeIndexToSize(SizeIndex));

        if (UserBlock) {

            UserBlock->SizeIndex = SizeIndex;
        }
    }

    return UserBlock;
}

VOID
FASTCALL
RtlpFreeUserBlock(
    PLFH_HEAP LowFragHeap,
    PHEAP_USERDATA_HEADER UserBlock
    )

/*++

Routine Description:

    Free a block previously allocated with RtlpAllocateUserBlock.
            
Arguments:
    
    LowFragHeap - The pointer to the LF heap
    
    UserBlock - The block to be freed
    
Return Value:
    
    None.

--*/

{
    ULONG Depth;
    ULONG SizeIndex = (ULONG)UserBlock->SizeIndex;
    PSLIST_HEADER ListHeader = &LowFragHeap->UserBlockCache.UserBlocks[UserBlock->SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX];
    
    if (UserBlock->SizeIndex == 0) {

        //
        //  This block was converted before to NT heap block
        //

        HeapFree(LowFragHeap->Heap, 0, UserBlock);

        return;
    }

    LFHEAPASSERT(UserBlock->SizeIndex >= HEAP_LOWEST_USER_SIZE_INDEX);
    LFHEAPASSERT(UserBlock->SizeIndex <= HEAP_HIGHEST_USER_SIZE_INDEX);

    LFHEAPASSERT( RtlpConvertSizeIndexToSize((UCHAR)UserBlock->SizeIndex) == 
                  HeapSize(LowFragHeap->Heap, 0, UserBlock) );

    Depth = QueryDepthSList(&LowFragHeap->UserBlockCache.UserBlocks[SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX]);

    if ((Depth > HEAP_CACHE_FREE_THRESHOLD)
            &&
        (Depth > (LowFragHeap->UserBlockCache.AvailableBlocks[ SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX ] >> HEAP_CACHE_SHIFT_THRESHOLD))) {
        
        PVOID ListEntry;
        
        HeapFree(LowFragHeap->Heap, 0, UserBlock);

        ListEntry = NULL;
        
        __try {

            ListEntry = RtlpSubSegmentPop(&LowFragHeap->UserBlockCache.UserBlocks[SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX]);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        }
        
        if (ListEntry != NULL) {
            
            UserBlock = CONTAINING_RECORD(ListEntry, HEAP_USERDATA_HEADER, SFreeListEntry);
            HeapFree(LowFragHeap->Heap, 0, UserBlock);
            InterlockedDecrement(&LowFragHeap->UserBlockCache.AvailableBlocks[ SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX ]);
        }

        InterlockedDecrement(&LowFragHeap->UserBlockCache.AvailableBlocks[ SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX ]);

    } else {
    
        RtlpSubSegmentPush( ListHeader, 
                            &UserBlock->SFreeListEntry);
    }
}


VOID
FORCEINLINE
RtlpMarkLFHBlockBusy (
    PHEAP_ENTRY Block
    )

/*++

Routine Description:
    
    This function marks a LFH block as busy. Because the convert routine can 
    be invoked any time, the LFH cannot use the same flag as the regular heap
    (LFH access any fields unsynchronized, but the block flags are supposed to
    be accessed while holding the heap lock)
    
Arguments:
    
    Block - The block being marked as busy
    
Return Value:
    
    None

--*/

{
    Block->SmallTagIndex = 1;
}

VOID
FORCEINLINE
RtlpMarkLFHBlockFree (
    PHEAP_ENTRY Block
    )

/*++

Routine Description:
    
    This function marks a LFH block as free. Because the convert routine can 
    be invoked any time, the LFH cannot use the same flag as the regular heap
    (LFH access any fields unsynchronized, but the block flags are supposed to
    be accessed while holding the heap lock)
    
Arguments:
    
    Block - The block to be marked free
    
Return Value:
    
    None

--*/

{
    Block->SmallTagIndex = 0;
}

BOOLEAN
FORCEINLINE
RtlpIsLFHBlockBusy (
    PHEAP_ENTRY Block
    )

/*++

Routine Description:
    
    The function returns whether the block is busy or free
        
Arguments:
    
    Block - The heap block tested
    
Return Value:
    
    Return TRUE if the block is busy

--*/

{
    return (Block->SmallTagIndex == 1);
}


VOID
FORCEINLINE
RtlpUpdateLastEntry (
    PHEAP Heap,
    PHEAP_ENTRY Block
    )

/*++

Routine Description:
    
    The function updates the last entry in segment. This is mandatory each time 
    a new block become the last.

Arguments:

    Heap - The NT heap structure
    
    Block - The block being tested for LAST_ENTRY flag
    
Return Value:
    
    None

--*/

{
    if (Block->Flags & HEAP_ENTRY_LAST_ENTRY) {

        PHEAP_SEGMENT Segment;

        Segment = Heap->Segments[Block->SegmentIndex];
        Segment->LastEntryInSegment = Block;
    }
}

BOOLEAN
FORCEINLINE
RtlpIsSubSegmentEmpty(
    PHEAP_SUBSEGMENT SubSegment
    )

/*++

Routine Description:

    This function tests whether the subsegment does contain available sub-blocks


Arguments:
    
    SubSegment - The subsegment being tested


Return Value:

    TRUE if no blocks are available.

--*/

{
    return SubSegment->AggregateExchg.OffsetAndDepth == (NO_MORE_ENTRIES << 16);
}

VOID
FORCEINLINE
RtlpUpdateBucketCounters (
    PHEAP_BUCKET Bucket,
    LONG TotalBlocks
    )

/*++

Routine Description:
    
    The function updates the total number of blocks from a bucket and the 
    number of sub-segments with a single interlocked operation. This function should be
    called each time a new segment is allocated / deleted to/from this bucket


Arguments:

    Bucket - The heap bucket that needs to be updated
    
    TotalBlocks - The number of blocks added / subtracted from the bucket. A positive
                  value means the bucket increased with a new segment, and a positive value 
                  means a sub-segment with that many blocks was deleted.

Return Value:
    
    None

--*/

{
    HEAP_BUCKET_COUNTERS CapturedValue, NewValue;
    LFH_DECLARE_COUNTER;

    do {

        //
        //  Capture the current value for counters
        //

        CapturedValue.Aggregate64 = Bucket->Counters.Aggregate64;

        //
        //  Calculate the new value depending upon the captured state
        //
        
        NewValue.TotalBlocks = CapturedValue.TotalBlocks + TotalBlocks;

        if (TotalBlocks > 0) {

            NewValue.SubSegmentCounts = CapturedValue.SubSegmentCounts + 1;

        } else {
            
            NewValue.SubSegmentCounts = CapturedValue.SubSegmentCounts - 1;
        }

        LFH_UPDATE_COUNTER;

        //
        //  try to replace the original value with the current one. If the 
        //  lockcomp below fails, retry all the ops above
        //

    } while ( !LOCKCOMP64(&Bucket->Counters.Aggregate64, NewValue.Aggregate64, CapturedValue.Aggregate64) );

    //
    //  It's invalid to have negative numbers of blocks or sub-segments
    //

    LFHEAPASSERT(((LONG)NewValue.SubSegmentCounts) >= 0);
    LFHEAPASSERT(((LONG)NewValue.TotalBlocks) >= 0);
}

ULONG
FORCEINLINE
RtlpGetThreadAffinityIndex(
    PHEAP_BUCKET HeapBucket
    )

/*++

Routine Description:

    The affinity is managed independenlty on each bucket. This will spin up the number of sub-segments 
    that can be accessed simultanely only for most used buckets.
    The routinw will hash the thread ID givving the right affinity index depending 
    the affinity size for that bucket.


Arguments:

    Bucket - The heap bucket queried

Return Value:

    The affinity the current thread should use for allocation from this bucket

--*/

{
    if (HeapBucket->UseAffinity) {

        return 1 + RtlpGetThreadAffinity();
    } 
    
    return 0;
}

BOOLEAN
FORCEINLINE
RtlpIsSubSegmentLocked(
    PHEAP_SUBSEGMENT SubSegment,
    ULONG LockMask
    )

/*++

Routine Description:

    This function tests whether the subsegment has the given lock bits set 


Arguments:

    SubSegment - The sub-segment tested
    
    LockMask - contains the bits to be tested


Return Value:

    It returns false if any bit from the mask is not set

--*/

{
    return ((SubSegment->Lock & LockMask) == LockMask);
}

BOOLEAN
LOCALPROC
RtlpAddToSegmentInfo(
    PHEAP_LOCAL_DATA LocalData,
    IN PHEAP_LOCAL_SEGMENT_INFO SegmentInfo,
    IN PHEAP_SUBSEGMENT NewItem
    )
{

    ULONG Index;
    
    for (Index = 0; Index < FREE_CACHE_SIZE; Index++) {

        ULONG i = (Index + (ULONG)SegmentInfo->LastUsed) & (FREE_CACHE_SIZE - 1);

        PHEAP_SUBSEGMENT CrtSubSegment = SegmentInfo->CachedItems[i];

        if (CrtSubSegment  == NULL ) {
            
            if (InterlockedCompareExchangePointer( &SegmentInfo->CachedItems[i], NewItem, NULL) == NULL) {

                SegmentInfo->BusyEntries += 1;

                return TRUE;
            }

        } else {

            if (!RtlpIsSubSegmentLocked(CrtSubSegment, HEAP_USERDATA_LOCK)) {

                if (InterlockedCompareExchangePointer( &SegmentInfo->CachedItems[i], NewItem, CrtSubSegment) == CrtSubSegment) {

                    RtlpUnlockSubSegment(LocalData, CrtSubSegment, HEAP_PUBLIC_LOCK);
                    
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

PHEAP_SUBSEGMENT
LOCALPROC
RtlpRemoveFromSegmentInfo(
    PHEAP_LOCAL_DATA LocalData,
    IN PHEAP_LOCAL_SEGMENT_INFO SegmentInfo
    )
{

    ULONG i;
    PHEAP_SUBSEGMENT * Location = NULL;
    ULONG LargestDepth = 0;
    PHEAP_SUBSEGMENT CapturedSegment;

RETRY:
    
    for (i = 0; i < FREE_CACHE_SIZE; i++) {

        ULONG Depth;
        PHEAP_SUBSEGMENT CrtSubsegment = SegmentInfo->CachedItems[i];


        if ( CrtSubsegment
                &&
             (Depth = CrtSubsegment->AggregateExchg.Depth) > LargestDepth) {

            CapturedSegment = CrtSubsegment;
            LargestDepth = Depth;
            Location = &SegmentInfo->CachedItems[i];
        }
    }

    if (Location) {

        PHEAP_SUBSEGMENT NextEntry;
        
        while (NextEntry = (PHEAP_SUBSEGMENT)RtlpSubSegmentPop(&SegmentInfo->SListHeader)) {

            NextEntry = CONTAINING_RECORD(NextEntry, HEAP_SUBSEGMENT, SFreeListEntry);

        #ifdef _HEAP_DEBUG
            NextEntry->SFreeListEntry.Next = NULL;
        #endif        
        
            if (RtlpIsSubSegmentLocked(NextEntry, HEAP_USERDATA_LOCK)) {

                break;
            } 

            RtlpUnlockSubSegment(LocalData, NextEntry, HEAP_PUBLIC_LOCK);
        }

        if (InterlockedCompareExchangePointer( Location, NextEntry, CapturedSegment) == CapturedSegment) {

            if (NextEntry == NULL) {
            
                SegmentInfo->BusyEntries -= 1;
            
                SegmentInfo->LastUsed = Location - &SegmentInfo->CachedItems[0];

                LFHEAPASSERT(SegmentInfo->LastUsed < FREE_CACHE_SIZE);
            }

            return CapturedSegment;

        } else if (NextEntry){

            RtlpSubSegmentPush( &SegmentInfo->SListHeader,
                                &NextEntry->SFreeListEntry);
        }

        Location = NULL;
        LargestDepth = 0;

        goto RETRY;
    }

    return NULL;
}

PHEAP_SUBSEGMENT
LOCALPROC
RtlpRemoveFreeSubSegment(
    PHEAP_LOCAL_DATA LocalData,
    ULONG SizeIndex
    )

/*++

Routine Description:

    This function remove a sub-segments that has free sub-blocks from the free list.


Arguments:

    LowFragHeap - The Low Fragmentation Heap handle
    
    HeapBucket - The bucket where we need to reuse a free block


Return Value:

    A subsegment that contains free blocks

--*/

{
    PVOID Entry;
    LONG Depth;
    PHEAP_LOCAL_SEGMENT_INFO FreeSList;
    PHEAP_SUBSEGMENT SubSegment;

    SubSegment = RtlpRemoveFromSegmentInfo(LocalData, &LocalData->SegmentInfo[SizeIndex]);

    if (SubSegment) {

        if ( RtlpUnlockSubSegment(LocalData, SubSegment, HEAP_PUBLIC_LOCK)){

            return SubSegment;
        }
    }
    
    FreeSList =  &LocalData->SegmentInfo[SizeIndex];

    while (Entry = RtlpSubSegmentPop(&FreeSList->SListHeader) ) {

        SubSegment = CONTAINING_RECORD(Entry, HEAP_SUBSEGMENT, SFreeListEntry);

    #ifdef _HEAP_DEBUG
        SubSegment->SFreeListEntry.Next = NULL;
    #endif        

        LFHEAPASSERT( RtlpIsSubSegmentLocked(SubSegment, HEAP_PUBLIC_LOCK) );
        LFHEAPASSERT( SizeIndex == SubSegment->SizeIndex );
        
        //
        //  If we have a non-empty subsegments we'll return it
        //

        if ( RtlpUnlockSubSegment(LocalData, SubSegment, HEAP_PUBLIC_LOCK) 
                 && 
             (SubSegment->AggregateExchg.Depth != 0)) {
             
            return SubSegment;
        }
    }
    
    return NULL;
}

BOOLEAN
LOCALPROC
RtlpInsertFreeSubSegment(
    PHEAP_LOCAL_DATA LocalData,
    PHEAP_SUBSEGMENT SubSegment
    )

/*++

Routine Description:

    The function inserts a Subsegments that has certain number of free blocks into the list
    with free segments. The insertion is done according with the current thread affinity.

Arguments:

    SubSegment - The sub-segment being inserted into the bucket's free list


Return Value:

    TRUE if succeeds. False if someone else inserted the segment meanwhile, of freed it

--*/

{
    if ( RtlpLockSubSegment(SubSegment, HEAP_PUBLIC_LOCK) ) {

        PHEAP_LOCAL_SEGMENT_INFO FreeSList;
        
        if (RtlpAddToSegmentInfo(LocalData, &LocalData->SegmentInfo[SubSegment->SizeIndex], SubSegment)) {

            return TRUE;
        }
        
        FreeSList =  &LocalData->SegmentInfo[SubSegment->SizeIndex];

#ifdef _HEAP_DEBUG
        
        InterlockedIncrement(&LocalData->LowFragHeap->SegmentInsertInFree);
#endif        
        LFHEAPASSERT( RtlpIsSubSegmentLocked(SubSegment, HEAP_PUBLIC_LOCK) );
        LFHEAPASSERT( SubSegment->SFreeListEntry.Next == NULL );
        
        RtlpSubSegmentPush( &FreeSList->SListHeader,
                            &SubSegment->SFreeListEntry);

        return TRUE;
    }

    return FALSE;
}


BOOLEAN
LOCALPROC
RtlpTrySetActiveSubSegment (
    PHEAP_LOCAL_DATA LocalData,
    PHEAP_BUCKET HeapBucket,
    PHEAP_SUBSEGMENT SubSegment
    )

/*++

Routine Description:

    This function tries to elevate the active segment into an active state. An active state is 
    defined here the state where a segment is used for allocations. There is no guarantee a segment 
    can be set into an active state because of non-blocking algorithms. An other thread can free 
    it meanwhile or set it before. In these cases the function will fail.
    
    
Arguments:

    LowFragHeap - The LFH pointer
    
    HeapBucket  - The bucket containing the active sub-segment
    
    Affinity    - the required affinity for that segment
    
    SubSegment  - The subsegment being activated. If NULL, this function will remove only
                  the current active segment.


Return Value:

    TRUE if succeeds.

--*/

{
    PHEAP_SUBSEGMENT PreviousSubSegment;

    if (SubSegment) {

        //
        //  If we received a sub-segment we need to lock it exclusively in order
        //  to protect against other threads trying to do the same thing
        //  at the same time
        //

        if ( !RtlpLockSubSegment(SubSegment, HEAP_ACTIVE_LOCK | HEAP_PUBLIC_LOCK) ) {

            return FALSE;
        }

        //
        //  We have granted exclusive access to this sub-segment at this point.
        //  We need to test whether this subsegment wasn't freed meanwhile and reused
        //  for other allocations (for a different bucket)
        //
        
        if (SubSegment->Bucket != HeapBucket) {

            //
            //  Someone freed it before and reuse it. We need to back out
            //  whatever we've done before. We cannot insert it into this bucket,
            //  since it contains different block sizes
            //

            if (RtlpUnlockSubSegment(LocalData, SubSegment, HEAP_ACTIVE_LOCK | HEAP_PUBLIC_LOCK)) {
                
                if (SubSegment->AggregateExchg.Depth) {

                    RtlpInsertFreeSubSegment(LocalData, SubSegment);
                }
            }

            return FALSE;
        }

        LFHEAPASSERT( SubSegment->SFreeListEntry.Next == NULL );
        LFHEAPASSERT( HeapBucket == SubSegment->Bucket); 
        LFHEAPASSERT( RtlpIsSubSegmentLocked(SubSegment, HEAP_PUBLIC_LOCK));

#ifdef _HEAP_DEBUG
        SubSegment->SFreeListEntry.Next = (PSINGLE_LIST_ENTRY)(ULONG_PTR)0xEEEEEEEE;

#endif        

        LFHEAPASSERT( SubSegment->AffinityIndex == (UCHAR)LocalData->Affinity );
    }

    //
    //  Try to set this sub-segment as active an capture the previous active segment
    //

    do {

        PreviousSubSegment = *((PHEAP_SUBSEGMENT volatile *)&LocalData->SegmentInfo[HeapBucket->SizeIndex].ActiveSubsegment);

    } while ( InterlockedCompareExchangePointer( &LocalData->SegmentInfo[HeapBucket->SizeIndex].ActiveSubsegment,
                                                 SubSegment,
                                                 PreviousSubSegment) != PreviousSubSegment );

    if ( PreviousSubSegment ) {

        //
        //  We had a previous active segment. We need to unlock it, and if it has enough
        //  free space we'll mark it ready for reuse
        //

        LFHEAPASSERT( HeapBucket == PreviousSubSegment->Bucket );
        LFHEAPASSERT( RtlpIsSubSegmentLocked(PreviousSubSegment, HEAP_PUBLIC_LOCK) );
        LFHEAPASSERT( PreviousSubSegment->SFreeListEntry.Next == ((PSINGLE_LIST_ENTRY)(ULONG_PTR)0xEEEEEEEE) );

#ifdef _HEAP_DEBUG
        
        PreviousSubSegment->SFreeListEntry.Next = 0;
#endif        
        
        if (RtlpUnlockSubSegment(LocalData, PreviousSubSegment, HEAP_ACTIVE_LOCK | HEAP_PUBLIC_LOCK)) {

            //
            //  That was not the last lock reference for that sub-segment. 
            //

            if (PreviousSubSegment->AggregateExchg.Depth) {

                RtlpInsertFreeSubSegment(LocalData, PreviousSubSegment);
            }
        }
    }

#ifdef _HEAP_DEBUG
    LocalData->LowFragHeap->SegmentChange++;
#endif

    return TRUE;
}


VOID
FASTCALL
RtlpSubSegmentInitialize (
    IN PLFH_HEAP LowFragHeap,
    IN PHEAP_SUBSEGMENT SubSegment,
    IN PHEAP_USERDATA_HEADER UserBuffer,
    IN SIZE_T BlockSize,
    IN SIZE_T AllocatedSize,
    IN PVOID Bucket
    )

/*++

Routine Description:

    The routine initialize a sub-segment descriptor. 
    N.B. The Sub-Segment structure can be accessed simultanely by some other threads
    that captured it to allocate, but they were suspended before alloc completed. If meanwhile
    the sub-segment was deleted, the descriptor can be reused for a new subblock.

Arguments:

    SubSegment - The sub-segment structure being initialized
    
    UserBuffer - The block allocated for the user data
    
    BlockSize  - The size of each sub-block
    
    AllocatedSize - the size of the allocated buffer
    
    Bucket - The bucket that will own this heap sub-segment

Return Value:

    None

--*/

{
    ULONG i, NumItems;
    PVOID Buffer = UserBuffer + 1;
    PBLOCK_ENTRY BlockEntry;
    USHORT BlockUnits;
    USHORT CrtBlockOffset = 0;
    INTERLOCK_SEQ CapturedValue, NewValue;

    CapturedValue.Exchg = SubSegment->AggregateExchg.Exchg;

    //
    //  Add the block header overhead
    //
    
    BlockSize += sizeof(HEAP_ENTRY);
    
    BlockUnits = (USHORT)(BlockSize >> HEAP_GRANULARITY_SHIFT);

    //
    //  The debug version will check the state for the subsegment
    //  testing whether the state was modified
    //

    LFHEAPASSERT(((PHEAP_BUCKET)Bucket)->BlockUnits == BlockUnits);
    LFHEAPASSERT(SubSegment->Lock == 0);
    LFHEAPASSERT(CapturedValue.OffsetAndDepth == (NO_MORE_ENTRIES << 16));
    LFHEAPASSERT(SubSegment->UserBlocks == NULL);
    LFHEAPASSERT(SubSegment->SFreeListEntry.Next == 0);

    //
    //  Initialize the user segment. Note that we don't touch the
    //  sub-segment descriptor, as some other threads can still use it.
    //

    UserBuffer->SubSegment = SubSegment;
    UserBuffer->HeapHandle = LowFragHeap->Heap;
    
    NumItems = (ULONG)((AllocatedSize - sizeof(HEAP_USERDATA_HEADER)) / BlockSize);

    CrtBlockOffset = sizeof(HEAP_USERDATA_HEADER) >> HEAP_GRANULARITY_SHIFT;
    NewValue.FreeEntryOffset = CrtBlockOffset;

    for (i = 0; i < NumItems; i++) {

        BlockEntry = (PBLOCK_ENTRY) Buffer;
        
        //
        //  Initialize the block
        //

        BlockEntry->SubSegment = SubSegment;
        BlockEntry->SegmentIndex = HEAP_LFH_INDEX;

        //
        //  Points to the next free block
        //

        CrtBlockOffset += BlockUnits;
        Buffer = (PCHAR)Buffer + BlockSize;

        BlockEntry->LinkOffset = CrtBlockOffset;
        BlockEntry->Flags = HEAP_ENTRY_BUSY;
        BlockEntry->UnusedBytes = sizeof(HEAP_ENTRY);
        RtlpMarkLFHBlockFree( (PHEAP_ENTRY)BlockEntry );


#if defined(_WIN64)
        BlockEntry->SubSegment = SubSegment;
#endif

#ifdef _HEAP_DEBUG
        BlockEntry->Reserved2 = 0xFEFE;        
#endif
    }

    //
    //  Mark the last block from the list
    //

    BlockEntry->LinkOffset = NO_MORE_ENTRIES;
    
    SubSegment->BlockSize = BlockUnits;
    SubSegment->BlockCount = (USHORT)NumItems;
    SubSegment->Bucket = Bucket;
    SubSegment->SizeIndex = ((PHEAP_BUCKET)Bucket)->SizeIndex;

    //
    //  Determine the thresholds depending upon the total number of blocks
    //
    
    SubSegment->UserBlocks = UserBuffer;
    RtlpUpdateBucketCounters(Bucket, NumItems);
    
    NewValue.Depth = (USHORT)NumItems;
    NewValue.Sequence = CapturedValue.Sequence + 1;
    SubSegment->Lock = HEAP_USERDATA_LOCK;
    
    //
    //  At this point everything is set, so we can with an interlocked operation set the 
    //  entire slist to the segment. 
    //

    if (!LOCKCOMP64(&SubSegment->AggregateExchg.Exchg, NewValue, CapturedValue)) {

        //
        //  Someone changed the state for the heap structure, so the 
        //  initialization failed. We make noise in the debug version.
        //  (This should never happen)
        //

        LFHEAPASSERT( FALSE );
    }
}

VOID
LOCALPROC
RtlpFreeUserBuffer(
    PLFH_HEAP LowFragHeap,
    PHEAP_SUBSEGMENT SubSegment
    )

/*++

Routine Description:

    When all blocks within segment are free we can go ahead and free the whole user buffer
    The caller should receive a notification from the last free call that the sub-segment 
    does not have any allocated block

Arguments:

    LowFragHeap  - The LFH
    
    SubSegment - The sub-segment being released


Return Value:

    None.

--*/

{
    PHEAP_BUCKET HeapBucket;
    SIZE_T UserBlockSize;

    HeapBucket = (PHEAP_BUCKET)SubSegment->Bucket;
    
    LFHEAPASSERT( RtlpIsSubSegmentLocked(SubSegment, HEAP_USERDATA_LOCK) );

#ifdef _HEAP_DEBUG
    UserBlockSize = HeapSize(LowFragHeap->Heap, 0, (PVOID)SubSegment->UserBlocks);
    LFHEAPASSERT((LONG_PTR)UserBlockSize > 0);
#endif

    SubSegment->UserBlocks->Signature = 0;

    RtlpFreeUserBlock(LowFragHeap, (PHEAP_USERDATA_HEADER)SubSegment->UserBlocks);

    //
    //  Update the counters
    //

    RtlpUpdateBucketCounters (HeapBucket, -SubSegment->BlockCount);

    SubSegment->UserBlocks = NULL;

    LFHEAPASSERT( RtlpIsSubSegmentLocked(SubSegment, HEAP_USERDATA_LOCK) );

    //
    //  This is a slow path any way. It doesn't harm a rare global interlocked
    //  in order to estimate the frequency of slower calls
    //

    InterlockedIncrement(&LowFragHeap->SegmentDelete);
}

BOOLEAN
FORCEINLINE
RtlpLockSubSegment(
    PHEAP_SUBSEGMENT SubSegment,
    ULONG LockMask
    )

/*++

Routine Description:

    The function locks a given set of bits to that segment, with a single atomic operation.
    If any of the bits is already locked the function will fail. If the sub-segment is deleted
    it will fail too.


Arguments:

    SubSegment - The SubSegemnt being locked
    
    LockMask - An ULONG value specifying the bits needed locked

Return Value:

    TRUE if succeeds.

--*/

{
    ULONG CapturedLock;
    
    do {

        CapturedLock = *((ULONG volatile *)&SubSegment->Lock);

        if ((CapturedLock == 0)
                ||
            (CapturedLock & LockMask)) {

            return FALSE;
        }

    } while ( InterlockedCompareExchange((PLONG)&SubSegment->Lock, CapturedLock | LockMask, CapturedLock) != CapturedLock );

    return TRUE;
}

BOOLEAN
LOCALPROC
RtlpUnlockSubSegment(
    PHEAP_LOCAL_DATA LocalData,
    PHEAP_SUBSEGMENT SubSegment,
    ULONG LockMask
    )

/*++

Routine Description:

    The function unlocks the given sub-segment. If the last lock went away, the segment 
    descriptor will be deleted and inserted into the recycle queue to be reused 
    further for other allocations.


Arguments:

    LowFragHeap - The LFH
    
    SubSegment - The sub-segment being unlocked
    
    LockMask - the bits that will be released


Return Value:

    Returns false if unlocking the segment caused deletion. TRUE if there are still 
    other locks keeping this sub-segment descriptor alive.

--*/

{
    ULONG CapturedLock;

    do {

        CapturedLock = *((ULONG volatile *)&SubSegment->Lock);

        //
        //  Unlock can be called exclusively, ONLY the if lock operation succeded
        //  It's an invalid state to have the segment already unlocked
        //  We assert this in debug version
        //

        LFHEAPASSERT((CapturedLock & LockMask) == LockMask);

    } while ( InterlockedCompareExchange((PLONG)&SubSegment->Lock, CapturedLock & ~LockMask, CapturedLock) != CapturedLock );

    //
    //  If That was the last lock released, we go ahead and 
    //  free the sub-segment to the SLists
    //

    if (CapturedLock == LockMask) {

        SubSegment->Bucket = NULL;
        SubSegment->AggregateExchg.Sequence += 1;

        LFHEAPASSERT( RtlpIsSubSegmentEmpty(SubSegment) );
        LFHEAPASSERT(SubSegment->Lock == 0);
        LFHEAPASSERT(SubSegment->SFreeListEntry.Next == 0);
        
        RtlpSubSegmentPush(&LocalData->DeletedSubSegments, &SubSegment->SFreeListEntry);

        return FALSE;
    }

    return TRUE;
}

PVOID
LOCALPROC
RtlpSubSegmentAllocate (
    PHEAP_BUCKET HeapBucket,
    PHEAP_SUBSEGMENT SubSegment
    )

/*++

Routine Description:

    The function allocates a block from a sub-segment with a interlocked instruction.
    
    N.B. Since the access to this sub-segment is done unsynchronized, a tread can play 
    with reading some the the sub-segment fields while another thread deleted it. For this 
    reason the sub-segment descriptors are always allocated, so reading the interlocked 
    counter is consistent over with the states that produced deletion. Every delete or
    init will increment the sequence counter, so the alloc will simple fail if it ends up 
    using a different sub-segment.
    
    This function also handles the contention (interlocked operation failed) on this bucket.
    If we have too mani concurent access on this bucket, it will spin up the affinity
    limit on an MP machine.
    

Arguments:

    HeapBucket - The bucket from which we allocate a blocks
    
    SubSegment - The subsegment currently in use 

Return Value:

    The allocated block pointer, if succeeds.

--*/

{
    ULONGLONG CapturedValue, NewValue;
    PBLOCK_ENTRY BlockEntry;
    PHEAP_USERDATA_HEADER UserBlocks;
    SHORT Depth;
    LFH_DECLARE_COUNTER;

RETRY:

    CapturedValue = SubSegment->AggregateExchg.Exchg;
    
    //
    //  We need the memory barrier because we are accessing
    //  another shared data below :  UserBlocks
    //  This has to be fetched in the same order 
    //  We declared these volatile, and on IA64 (MP) we need the
    //  memory barrier as well
    //

    RtlMemoryBarrier();
    
    if ((Depth = (USHORT)CapturedValue)
            &&
        (UserBlocks = (PHEAP_USERDATA_HEADER)SubSegment->UserBlocks)
            &&
        (SubSegment->Bucket == HeapBucket)
            &&
        !RtlpIsSubSegmentLocked(SubSegment, HEAP_CONVERT_LOCK)) {

        BlockEntry = (PBLOCK_ENTRY)((PCHAR)UserBlocks + ((((ULONG)CapturedValue) >> 16) << HEAP_GRANULARITY_SHIFT));

        //
        //  Accessing BlockEntry->LinkOffset can produce an AV if another thread freed the buffer
        //  meanwhile and the memory was decommitted. The caller of this function should 
        //  have a try - except around this call. If the memory was used for other blocks
        //  the interlockedcompare should fail because the sequence number was incremented
        //

        LFHEAPASSERT(!(((CapturedValue >> 16) == SubSegment->AggregateExchg.Sequence)
                     &&
                  (BlockEntry->LinkOffset != NO_MORE_ENTRIES)
                     &&
                  (BlockEntry->LinkOffset > (SubSegment->BlockCount * SubSegment->BlockSize))
                     &&
                  ((CapturedValue >> 16) == SubSegment->AggregateExchg.Sequence)));

        LFHEAPASSERT(!(((CapturedValue >> 16) == SubSegment->AggregateExchg.Sequence)
                       &&
                   (BlockEntry->LinkOffset == NO_MORE_ENTRIES)
                       &&
                   (Depth != 0)
                       &&
                   ((CapturedValue >> 16) == SubSegment->AggregateExchg.Sequence)));

        LFHEAPASSERT(!(((CapturedValue >> 16) == SubSegment->AggregateExchg.Sequence)
                       &&
                   (SubSegment->Bucket != HeapBucket)
                       &&
                   ((CapturedValue >> 16) == SubSegment->AggregateExchg.Sequence)));

        NewValue = ((CapturedValue - 1) & (~(ULONGLONG)0xFFFF0000)) | ((ULONG)(BlockEntry->LinkOffset) << 16);

        if (LOCKCOMP64(&SubSegment->AggregateExchg.Exchg, NewValue, CapturedValue)) {

            //
            //  if the segment has been converted, the bucket will be invalid. 
            //
            //    LFHEAPASSERT(SubSegment->Bucket == HeapBucket);  
            //    LFHEAPASSERT(RtlpIsSubSegmentLocked(SubSegment, HEAP_USERDATA_LOCK));

            LFHEAPASSERT( !RtlpIsLFHBlockBusy( (PHEAP_ENTRY)BlockEntry ) );

            LFHEAPASSERT(((NewValue >> 24) != NO_MORE_ENTRIES) 
                            ||
                         ((USHORT)NewValue == 0));


        #ifdef _HEAP_DEBUG

            LFHEAPASSERT((BlockEntry->Reserved2 == 0xFFFC)
                           ||
                       (BlockEntry->Reserved2 == 0xFEFE));

            //
            //  In the debug version write something there
            //

            BlockEntry->LinkOffset = 0xFFFA;
            BlockEntry->Reserved2 = 0xFFFB;


        #endif

            RtlpMarkLFHBlockBusy( (PHEAP_ENTRY)BlockEntry );

            //
            //  If we had an interlocked compare failure, we must have another thread playing 
            //  with the same subsegment at the same time. If this happens to often
            //  we need to increase the affinity limit on this bucket.
            //

            return ((PHEAP_ENTRY)BlockEntry + 1);
        }

    } else {

        return NULL;
    }
    
    if (!HeapBucket->UseAffinity) {

        HeapBucket->UseAffinity = 1;
    }
    
    LFH_UPDATE_COUNTER;

    goto RETRY;

    return NULL;
}

ULONG
LOCALPROC
RtlpSubSegmentFree (
    PLFH_HEAP LowfHeap,
    PHEAP_SUBSEGMENT SubSegment,
    PBLOCK_ENTRY BlockEntry
    )

/*++

Routine Description:

    This function frees a block from a sub-segment. Because a sub-segment lives
    as long as there is at least an allocated block inside, we don't have the problem
    we have for alloc. 
    
    If the block being freed is happening to be the last one, we'll mark with an 
    interlocked instruction the whole sub-segment as being free. The caller needs then to 
    release the descriptor structure


Arguments:

    SubSegment - The subsegment that ownd the block
    
    BlockEntry - The block being free.                        

Return Value:

    TRUE if that was the last block, and it's safe now to recycle the descriptor. 
    FALSE otherwise.

--*/

{
    ULONGLONG CapturedValue, NewValue;
    ULONG ReturnStatus;
    ULONG_PTR UserBlocksRef = (ULONG_PTR)SubSegment->UserBlocks;
    LFH_DECLARE_COUNTER;

    LFHEAPASSERT( RtlpIsLFHBlockBusy((PHEAP_ENTRY)BlockEntry) );

    RtlpMarkLFHBlockFree((PHEAP_ENTRY)BlockEntry);

    do {
        
        LFH_UPDATE_COUNTER;
        
        //
        //  We need to capture the sequence at the first step
        //  Then we'll capture the other fields from the segment
        //  If interlock operation below succeeds, means that none
        //  of the sub-segment fields (UserBlocks, Bucket ....)
        //  we changed. So the new state was built upon a consistent state
        //

        CapturedValue = SubSegment->AggregateExchg.Exchg;
        
        RtlMemoryBarrier();

        NewValue = (CapturedValue + 0x100000001) & (~(ULONGLONG)0xFFFF0000);
        
        if (RtlpIsSubSegmentLocked(SubSegment, HEAP_CONVERT_LOCK) 
                ||
            !RtlpIsSubSegmentLocked(SubSegment, HEAP_USERDATA_LOCK)
                ||
            (BlockEntry->SegmentIndex != HEAP_LFH_INDEX)) {

            return HEAP_FREE_BLOCK_CONVERTED;
        }

        //
        //  Depth and FreeEntryOffset are fetched at at the same time. They need
        //  to be consistent
        //

        LFHEAPASSERT(!(((USHORT)CapturedValue > 1) && (((ULONG)(NewValue >> 16)) == NO_MORE_ENTRIES)));

        if ((((USHORT)NewValue) != SubSegment->BlockCount)) {
            
            ReturnStatus = HEAP_FREE_BLOCK_SUCCESS;
            BlockEntry->LinkOffset = (USHORT)(CapturedValue >> 16);
            NewValue |= ((((ULONG_PTR)BlockEntry - UserBlocksRef) >> HEAP_GRANULARITY_SHIFT) << 16);
        
        } else {

            //
            //  This was the last block. Instead pushing it into the list
            //  we'll take the all blocks from the sub-segment to allow releasing the 
            //  subsegment
            //
            
            ReturnStatus = HEAP_FREE_SEGMENT_EMPTY;
            NewValue = (NewValue & 0xFFFFFFFF00000000) | 0xFFFF0000;
        }

    } while ( !LOCKCOMP64(&SubSegment->AggregateExchg.Exchg, NewValue, CapturedValue) );

    if (!(USHORT)CapturedValue/*
            &&
        !RtlpIsSubSegmentLocked(SubSegment, HEAP_PUBLIC_LOCK)*/) {

        RtlpInsertFreeSubSegment(&LowfHeap->LocalData[SubSegment->AffinityIndex], SubSegment);
    }

    return ReturnStatus;
}


PHEAP_BUCKET
FORCEINLINE
RtlpGetBucket(
    PLFH_HEAP LowFragHeap, 
    SIZE_T Index
    )

/*++

Routine Description:
    
    The function simple returns the appropriate bucket for the given allocation index.
    The index should be < HEAP_BUCKETS_COUNT. This routine does not perform any range checking, it is supposed
    to be called with appropriate parameters

Arguments:

    LowFragHeap - The LFH
    
    Index - The allocation index


Return Value:

    The bucket that should be used for that allocation index.

--*/

{
    return &LowFragHeap->Buckets[Index];
}

HANDLE
FASTCALL
RtlpCreateLowFragHeap( 
    HANDLE Heap
    )

/*++

Routine Description:

    The function creates a Low fragmentation heap, using for the allocations the heap handle
    passed in.


Arguments:

    Heap - The NT heap handle


Return Value:

    Returns a handle to a Lof Fragmentation Heap.

--*/

{
    PLFH_HEAP LowFragHeap;
    ULONG i;
    PUCHAR Buffer;

    SIZE_T TotalSize;

    //
    //  Determine the size of the LFH structure based upon the current affinity limit.
    //

    TotalSize = sizeof(LFH_HEAP) + sizeof(HEAP_LOCAL_DATA) * RtlpHeapMaxAffinity;

    LowFragHeap = HeapAlloc(Heap, HEAP_NO_CACHE_BLOCK, TotalSize);

    if (LowFragHeap) {

        memset(LowFragHeap, 0, TotalSize);
        RtlInitializeCriticalSection( &LowFragHeap->Lock );
        
        //
        //  Initialize the heap zones. 
        //

        InitializeListHead(&LowFragHeap->SubSegmentZones);
        LowFragHeap->ZoneBlockSize = ROUND_UP_TO_POWER2(sizeof(HEAP_SUBSEGMENT), HEAP_GRANULARITY);

        LowFragHeap->Heap = Heap;

        //
        //  Initialize the heap buckets
        //

        for (i = 0; i < HEAP_BUCKETS_COUNT; i++) {

            LowFragHeap->Buckets[i].UseAffinity = 0;
            LowFragHeap->Buckets[i].SizeIndex = (UCHAR)i;
            LowFragHeap->Buckets[i].BlockUnits = (USHORT)(RtlpBucketBlockSizes[i] >> HEAP_GRANULARITY_SHIFT) + 1;
        }
        
        for (i = 0; i <= RtlpHeapMaxAffinity; i++) {

            LowFragHeap->LocalData[i].LowFragHeap = LowFragHeap;
            LowFragHeap->LocalData[i].Affinity = i;
        }
    }

    return LowFragHeap;
}

VOID
FASTCALL
RtlpDestroyLowFragHeap( 
    HANDLE LowFragHeapHandle
    )

/*++

Routine Description:
    
    The function should be called to destroy the LFH. 
    This function should be called only when the NT heap goes away. We cannot rolback 
    everything we've done with this heap. The NT heap is supposed to release all memory 
    this heap allocated.

Arguments:

    LowFragHeapHandle - The low fragmentation heap


Return Value:

    None.

--*/

{
    //
    //  This cannot be called unless the entire heap will go away
    //  It only delete the critical section, the all blocks allocated here will 
    //  be deleted by RltDestroyHeap when it destroys the segments.
    //

    RtlDeleteCriticalSection(&((PLFH_HEAP)LowFragHeapHandle)->Lock);
}

PVOID 
FASTCALL
RtlpLowFragHeapAllocateFromZone(
    PLFH_HEAP LowFragHeap,
    ULONG Affinity
    )

/*++

Routine Description:

    This function allocates a sub-segment descriptor structure from the heap zone


Arguments:

    LowFragHeap - the LFH


Return Value:

    The pointer to a new sub-segment descriptor structure.

--*/

{
    PLFH_BLOCK_ZONE CrtZone;

RETRY_ALLOC:

    CrtZone = LowFragHeap->LocalData[Affinity].CrtZone;
    
    if (CrtZone) {

        PVOID CapturedFreePointer = CrtZone->FreePointer;
        PVOID NextFreePointer = (PCHAR)CapturedFreePointer + LowFragHeap->ZoneBlockSize;

        //
        //  See if we have that sub-segment already preallocated
        //

        if (NextFreePointer < CrtZone->Limit) {

            if ( InterlockedCompareExchangePointer( &CrtZone->FreePointer, 
                                                    NextFreePointer, 
                                                    CapturedFreePointer) == CapturedFreePointer) {

                //
                //  The allocation succeeded, we can return that pointer
                //

                return CapturedFreePointer;
            }

            goto RETRY_ALLOC;
        }
    }
            
    //
    //  we need to grow the heap zone. We acquire a lock here to avoid more threads doing the 
    //  same thing
    //

    RtlEnterCriticalSection(&LowFragHeap->Lock);

    //
    //  Test whether meanwhile another thread already increased the zone
    //

    if (CrtZone == LowFragHeap->LocalData[Affinity].CrtZone) {

        CrtZone = HeapAlloc(LowFragHeap->Heap, HEAP_NO_CACHE_BLOCK, HEAP_DEFAULT_ZONE_SIZE);

        if (CrtZone == NULL) {

            RtlpFlushLFHeapCache(LowFragHeap);
            CrtZone = HeapAlloc(LowFragHeap->Heap, HEAP_NO_CACHE_BLOCK, HEAP_DEFAULT_ZONE_SIZE);

            RtlLeaveCriticalSection(&LowFragHeap->Lock);
            return NULL;
        }

        InsertTailList(&LowFragHeap->SubSegmentZones, &CrtZone->ListEntry);

        CrtZone->Limit = (PCHAR)CrtZone + HEAP_DEFAULT_ZONE_SIZE;
        CrtZone->FreePointer = CrtZone + 1;

        CrtZone->FreePointer = (PVOID)ROUND_UP_TO_POWER2((ULONG_PTR)CrtZone->FreePointer, HEAP_GRANULARITY);

        //
        //  Everything is set. We can go ahead and set this as the default zone
        //

        LowFragHeap->LocalData[Affinity].CrtZone = CrtZone;
    }
    
    RtlLeaveCriticalSection(&LowFragHeap->Lock);

    goto RETRY_ALLOC;
}


SIZE_T 
FORCEINLINE
RtlpSubSegmentGetIndex(
    SIZE_T BlockUnits
    )

/*++

Routine Description:

    This routine converts the block size (in block units >> HEAP_GRANULARITY_SHIFT) 
    into heap bucket index.

Arguments:

    BlockUnits - the block size  >> HEAP_GRANULARITY_SHIFT

Return Value:

    The index for the bucket that should handle these sizes.

--*/

{
    SIZE_T SizeClass;
    SIZE_T Bucket;
    
    if (BlockUnits <= 32) {

        return BlockUnits - 1;
    }

    SizeClass = 5;  //  Add 1 << 5 == 32

    while (BlockUnits >> SizeClass) {
        
        SizeClass += 1;
    }

    SizeClass -= 5;  

    BlockUnits = ROUND_UP_TO_POWER2(BlockUnits, (1 << SizeClass));

    Bucket = ((SizeClass << 4) + (BlockUnits >> SizeClass) - 1);
    return Bucket;
}


SIZE_T
FORCEINLINE
RtlpGetSubSegmentSizeIndex(
    PLFH_HEAP LowFragHeap,
    SIZE_T BlockSize, 
    ULONG NumBlocks,
    CHAR AffinityCorrection
    )

/*++

Routine Description:

    This function calculate the appropriate size for a sub-segment depending upon the
    block size and the minimal number of blocks that should be there.

Arguments:

    BlockSize - The size of the block, in bytes
    
    NumBlocks - the minimal number of the blocks.


Return Value:

    Returns the next power of 2 size that can satisfy the request

--*/

{
    SIZE_T MinSize;
    ULONG SizeShift = HEAP_LOWEST_USER_SIZE_INDEX;
    SIZE_T ReturnSize;

    LFHEAPASSERT(AffinityCorrection < HEAP_MIN_BLOCK_CLASS);

    if (BlockSize < 256) {

        AffinityCorrection -= 1;
    }

    if (RtlpAffinityState.CrtLimit > (LONG)(RtlpHeapMaxAffinity >> 1)) {

        AffinityCorrection += 1;
    }

    if (NumBlocks < ((ULONG)1 << (HEAP_MIN_BLOCK_CLASS - AffinityCorrection))) {

        NumBlocks = 1 << (HEAP_MIN_BLOCK_CLASS - AffinityCorrection);
    }
    
    if (LowFragHeap->Conversions) {

        NumBlocks = HEAP_MIN_BLOCK_CLASS;
    }
    
    if (NumBlocks > (1 << HEAP_MAX_BLOCK_CLASS)) {

        NumBlocks = 1 << HEAP_MAX_BLOCK_CLASS;
    }

    MinSize = ((BlockSize + sizeof(HEAP_ENTRY) ) * NumBlocks) + sizeof(HEAP_USERDATA_HEADER) + sizeof(HEAP_ENTRY);

    if (MinSize > HEAP_MAX_SUBSEGMENT_SIZE) {

        MinSize = HEAP_MAX_SUBSEGMENT_SIZE;
    }

    while (MinSize >> SizeShift) {

        SizeShift += 1;
    }

    if (SizeShift > HEAP_HIGHEST_USER_SIZE_INDEX) {

        SizeShift = HEAP_HIGHEST_USER_SIZE_INDEX;
    }
    
    return SizeShift;
}

PVOID
FASTCALL
RtlpLowFragHeapAlloc(
    HANDLE LowFragHeapHandle,
    SIZE_T BlockSize
    )

/*++

Routine Description:

    This function allocates a block from the LFH. 


Arguments:

    Heap - the NT heap handle
    
    LowFragHeapHandle - The LFH heap handle
    
    BlockSize - the requested size, in bytes

Return Value:

    A pointer to a new allocated block if succeeds. If the requested size is > 16K this 
    function will fail too.

--*/

{
    SIZE_T BlockUnits;
    SIZE_T Bucket;
    PLFH_HEAP LowFragHeap = (PLFH_HEAP)LowFragHeapHandle;
    PVOID Block;
    PHEAP_LOCAL_DATA LocalData;

    //
    //  Get the appropriate bucket depending upon the requested size
    //

    BlockUnits = (BlockSize + HEAP_GRANULARITY - 1) >> HEAP_GRANULARITY_SHIFT;
    Bucket = RtlpSubSegmentGetIndex( BlockUnits );

    if (Bucket < HEAP_BUCKETS_COUNT) {

        PHEAP_BUCKET HeapBucket = RtlpGetBucket(LowFragHeap, Bucket);
        SIZE_T SubSegmentSize;
        SIZE_T SubSegmentSizeIndex;
        PHEAP_SUBSEGMENT SubSegment, NewSubSegment;
        PHEAP_USERDATA_HEADER UserData;
        PHEAP_LOCAL_SEGMENT_INFO SegmentInfo;

        LocalData = &LowFragHeap->LocalData[ RtlpGetThreadAffinityIndex(HeapBucket) ];
        SegmentInfo = &LocalData->SegmentInfo[Bucket];

        //
        //  If we have some memory converted to the NT heap
        //  we need to allocate from NT heap first in order to reuse that memory
        //

        //
        //  Try first to allocate from the last segment used for free.
        //  This will provide a better performance because the data is likely to
        //  be still in the processor cache
        //

        if (SubSegment = SegmentInfo->Hint) {

            //
            //  Accessing the user data can generate an exception if another thread freed
            //  the subsegment meanwhile.
            //

            LFHEAPASSERT( LocalData->Affinity == SubSegment->AffinityIndex );

            __try {

                Block = RtlpSubSegmentAllocate(HeapBucket, SubSegment);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Block = NULL;
            }

            if (Block) {
                
                RtlpSetUnusedBytes(LowFragHeap->Heap, ((PHEAP_ENTRY)Block - 1), ( ((SIZE_T)HeapBucket->BlockUnits) << HEAP_GRANULARITY_SHIFT) - BlockSize);

                return Block;
            }

            SegmentInfo->Hint = NULL;
        }

RETRY_ALLOC:

        //
        //  Try to allocate from the current active sub-segment
        //

        if (SubSegment = SegmentInfo->ActiveSubsegment) {

            //
            //  Accessing the user data can generate an exception if another thread freed
            //  the subsegment meanwhile.
            //

            LFHEAPASSERT( LocalData->Affinity == SubSegment->AffinityIndex );

            __try {

                Block = RtlpSubSegmentAllocate(HeapBucket, SubSegment);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Block = NULL;
            }

            if (Block) {

                RtlpSetUnusedBytes(LowFragHeap->Heap, ((PHEAP_ENTRY)Block - 1), ( ((SIZE_T)HeapBucket->BlockUnits) << HEAP_GRANULARITY_SHIFT) - BlockSize);

                return Block;
            }
        }

        if (NewSubSegment = RtlpRemoveFreeSubSegment(LocalData, (LONG)Bucket)) {
            
            RtlpTrySetActiveSubSegment(LocalData, HeapBucket, NewSubSegment);

            goto RETRY_ALLOC;
        }
        
        if (LowFragHeap->ConvertedSpace) {

            InterlockedExchangeAdd((PLONG)&LowFragHeap->ConvertedSpace, -(LONG)(BlockSize >> 1));

            if ((LONG)LowFragHeap->ConvertedSpace < 0) {

                LowFragHeap->ConvertedSpace = 0;
            }
            
            return NULL;
        }

        //
        //  At this point we don't have any sub-segment we can use to allocate this 
        //  size. We need to create a new one.
        //

        SubSegmentSizeIndex = RtlpGetSubSegmentSizeIndex( LowFragHeap, 
                                                          RtlpBucketBlockSizes[Bucket], 
                                                          RtlpGetDesiredBlockNumber( HeapBucket->UseAffinity, 
                                                                                     HeapBucket->Counters.TotalBlocks),
                                                          HeapBucket->UseAffinity
                                                        );

        UserData = RtlpAllocateUserBlock( LowFragHeap, (UCHAR)SubSegmentSizeIndex );

        if (UserData == NULL) {

            //
            //  Low memory condition. Flush the caches and retry the allocation.
            //  On low memory, the heap will use smaller sizes for sub-segments.
            //

            RtlpFlushLFHeapCache(LowFragHeap);
            
            SubSegmentSizeIndex = RtlpGetSubSegmentSizeIndex( LowFragHeap, 
                                                              RtlpBucketBlockSizes[Bucket], 
                                                              RtlpGetDesiredBlockNumber(HeapBucket->UseAffinity, 
                                                                                        HeapBucket->Counters.TotalBlocks),
                                                              HeapBucket->UseAffinity
                                                            );

            UserData = RtlpAllocateUserBlock( LowFragHeap, (UCHAR)SubSegmentSizeIndex );
        }

        if (UserData) {

            PVOID Entry;

            SubSegmentSize = RtlpConvertSizeIndexToSize((UCHAR)UserData->SizeIndex);

            LFHEAPASSERT( SubSegmentSize == HeapSize(LowFragHeap->Heap, 0, UserData) );

            //
            //  This is a slow path any way, and it is exercised just in rare cases, 
            //  when a bigger sub-segment is allocated. It doesn't hurt if we have an 
            //  extra interlocked-increment.
            //
            
            InterlockedIncrement(&LowFragHeap->SegmentCreate);
            
            //
            //  Allocate a sub-segment descriptor structiure. If there isn't any in the
            //  recycle list we allocate one from the zones.
            //

            Entry = RtlpSubSegmentPop(&LocalData->DeletedSubSegments);

            if (Entry == NULL) {

                NewSubSegment = RtlpLowFragHeapAllocateFromZone(LowFragHeap, LocalData->Affinity);

#ifdef _HEAP_DEBUG

                //
                //  We need to do some more extra initializations for
                //  the debug version, to verify the state of the subsegment
                //  in the next RtlpSubSegmentInitialize call
                //

                NewSubSegment->Lock = 0;
                NewSubSegment->AggregateExchg.OffsetAndDepth = NO_MORE_ENTRIES << 16;
                NewSubSegment->UserBlocks = NULL;
#endif

            } else {
                
                NewSubSegment = CONTAINING_RECORD(Entry, HEAP_SUBSEGMENT, SFreeListEntry);
            }
            
            if (NewSubSegment) {
                
                UserData->Signature = HEAP_LFH_USER_SIGNATURE;
                NewSubSegment->AffinityIndex = (UCHAR)LocalData->Affinity;

#ifdef _HEAP_DEBUG

                //
                //  We need to do some more extra initializations for
                //  the debug version, to verify the state of the subsegment
                //  in the next RtlpSubSegmentInitialize call
                //

                NewSubSegment->SFreeListEntry.Next = 0;
#endif

                RtlpSubSegmentInitialize( LowFragHeap,
                                          NewSubSegment, 
                                          UserData, 
                                          RtlpBucketBlockSizes[Bucket], 
                                          SubSegmentSize, 
                                          HeapBucket
                                        );

                //
                //  When the segment initialization was completed some other threads
                //  can access this subsegment (because they captured the pointer before
                //  if the subsegment was recycled).
                //  This can change the state for this segment, even it can delete.
                //  This should be very rare cases, so we'll print a message in 
                //  debugger. However. If this happens too often it's an indication of
                //  a possible bug in LFH code, or a corruption.
                //

                LFHEAPWARN( NewSubSegment->Lock == HEAP_USERDATA_LOCK );
                LFHEAPWARN( NewSubSegment->UserBlocks );
                LFHEAPWARN( NewSubSegment->BlockSize == HeapBucket->BlockUnits );
                
                if (!RtlpTrySetActiveSubSegment(LocalData, HeapBucket, NewSubSegment)) {
                    
                    RtlpInsertFreeSubSegment(LocalData, NewSubSegment);
                }
                
                goto RETRY_ALLOC;

            } else {

                HeapFree(LowFragHeap->Heap, 0, UserData);
            }
        }
    }

    return NULL;
}

BOOLEAN
FASTCALL
RtlpLowFragHeapFree(
    HANDLE LowFragHeapHandle, 
    PVOID p
    )

/*++

Routine Description:

    The function free a block allocated with RtlpLowFragHeapAlloc.

Arguments:

    Heap - the NT heap handle
    
    LowFragHeapHandle - The LFH heap handle

    Flags - Free flags
    
    p - The pointer to the block to be freed
    
Return Value:

    TRUE if succeeds.

--*/

{
    PLFH_HEAP LowFragHeap = (PLFH_HEAP)LowFragHeapHandle;
    PBLOCK_ENTRY Block = (PBLOCK_ENTRY)((PHEAP_ENTRY)p - 1);
    PHEAP_SUBSEGMENT SubSegment;
    PHEAP_BUCKET HeapBucket;
    ULONG FreeStatus;
    
    SubSegment = Block->SubSegment;

    RtlMemoryBarrier();

RETRY_FREE:

    //
    //  Test whether the block belongs to the LFH
    //

    if (Block->SegmentIndex != HEAP_LFH_INDEX) {

        if ( Block->SegmentIndex == HEAP_LFH_IN_CONVERSION ) {

            //
            //  This should happen rarely, at high memory preasure.
            //  The subsegment was converted meanwhile from another thread
            //  We need to return FALSE and let the NT heap finish the free
            //
            //  Acquire the heap lock and release it. This way we make sure that
            //  the conversion completed. 
            //

            HeapLock(LowFragHeap->Heap);
            HeapUnlock(LowFragHeap->Heap);
        }

        return FALSE;
    }

    #ifdef _HEAP_DEBUG
        Block->Reserved2 = 0xFFFC;
    #endif  // _HEAP_DEBUG

    //
    //  Free the block to the appropriate sub-segment
    //

    FreeStatus = RtlpSubSegmentFree(LowFragHeap, SubSegment, Block);

    switch (FreeStatus) {
    
    case HEAP_FREE_SEGMENT_EMPTY:
        {

            PHEAP_LOCAL_DATA LocalData = &LowFragHeap->LocalData[SubSegment->AffinityIndex];

            //
            //  The free call above returned TRUE, meanning that the sub-segment can be deleted
            //  Remove it from the active state (to prevent other threads using it)
            //

            RtlpTrySetActiveSubSegment(LocalData, SubSegment->Bucket, NULL);

            //
            //  Free thye user buffer
            //

            RtlpFreeUserBuffer(LowFragHeap, SubSegment);

            //
            //  Unlock the sub-segment structure. This will actually recycle the descriptor
            //  if that was the last lock.
            //

            RtlpUnlockSubSegment(LocalData, SubSegment, HEAP_USERDATA_LOCK);
        }

        break;

    case HEAP_FREE_BLOCK_SUCCESS:

            {
                PHEAP_LOCAL_DATA LocalData = &LowFragHeap->LocalData[SubSegment->AffinityIndex];

                LocalData->SegmentInfo[SubSegment->SizeIndex].Hint = SubSegment;
            }

        break;

    case HEAP_FREE_BLOCK_CONVERTED:

        //
        //  In some rare cases the segment is locked for conversion, but the conversion 
        //  process is abandoned for some reasons. In that case we need to retry
        //  freeing to the LFH
        //
        
        //
        //  Acquire the heap lock and release it. This way we make sure that
        //  the conversion completed. 
        //

        HeapLock(LowFragHeap->Heap);
        HeapUnlock(LowFragHeap->Heap);

        goto RETRY_FREE;
    }

    return TRUE;
}

BOOLEAN
FASTCALL
RtlpConvertSegmentToHeap (
    PLFH_HEAP LowFragHeap,
    PHEAP_SUBSEGMENT SubSegment
    )

/*++

Routine Description:

    The function converts a sub-segment to regular heap blocks
    
    This function should be invocked with the PUBLIC lock held for 
    this subsegment    

Arguments:

    LowFragHeap - The Low Fragmentation Heap pointer
    
    SubSegment - The subsegment to be converted
    

Return Value:

    Returns TRUE if succeeds

--*/

{
    INTERLOCK_SEQ CapturedValue, NewValue;
    BOOLEAN SubSegmentEmpty;
    SHORT Depth;
    PHEAP_USERDATA_HEADER UserBlocks;
    PHEAP_ENTRY UserBlockHeapEntry;
    UCHAR SegmentIndex;
    SIZE_T FreeSize = 0;
    PVOID EndingFreeBlock = NULL;
    SIZE_T SegmentUnitsUsed;

    LFHEAPASSERT(RtlpIsSubSegmentLocked(SubSegment, HEAP_PUBLIC_LOCK));

    //
    //  Since this function directly access the NT heap data
    //  we need first to lock the heap
    //

    if ( !HeapLock(LowFragHeap->Heap) ) {

        return FALSE;
    }

    //
    //  Mark the segment as being converted. This will block other
    //  threads to allocate/free from this segment further. These threads will 
    //  make the NT call, which can succeeds only after the conversions is done
    //  (because the heap lock is held)
    //

    if (!RtlpLockSubSegment(SubSegment, HEAP_CONVERT_LOCK)) {

        HeapUnlock(LowFragHeap->Heap);
        return FALSE;
    }
    
    SegmentUnitsUsed = SubSegment->BlockCount * SubSegment->BlockSize + 
        ((sizeof( HEAP_ENTRY ) + sizeof(HEAP_USERDATA_HEADER)) >> HEAP_GRANULARITY_SHIFT);
    
    do {

        //
        //  We need to capture the sequence at the first step
        //  Then we'll capture the other fields from the segment
        //  If interlock operation below succeeds, means that none
        //  of the sub-segment fields (UserBlocks, Bucket ....)
        //  we changed. So the new state was built upon a consistent state
        //

        CapturedValue.Sequence = SubSegment->AggregateExchg.Sequence;
        CapturedValue.OffsetAndDepth = SubSegment->AggregateExchg.OffsetAndDepth;
        
        Depth = (SHORT)CapturedValue.OffsetAndDepth;
        UserBlocks = (PHEAP_USERDATA_HEADER)SubSegment->UserBlocks;

        //
        //  Test whether the sub-segment was not deleted meanwhile
        //

        if ((Depth == SubSegment->BlockCount) 
                ||
            (UserBlocks == NULL)
                ||
            RtlpIsSubSegmentEmpty(SubSegment)) {

            RtlpUnlockSubSegment(&LowFragHeap->LocalData[SubSegment->AffinityIndex], SubSegment, HEAP_CONVERT_LOCK);
            HeapUnlock(LowFragHeap->Heap);
            return FALSE;
        }

        //
        //  Do not convert sub-segments which have a trailing block of 
        //  one unit size.
        // 

        UserBlockHeapEntry = (PHEAP_ENTRY)UserBlocks - 1;

        if ( (UserBlockHeapEntry->Size - SegmentUnitsUsed) == 1) {

            RtlpUnlockSubSegment(&LowFragHeap->LocalData[SubSegment->AffinityIndex], SubSegment, HEAP_CONVERT_LOCK);
            HeapUnlock(LowFragHeap->Heap);

            return FALSE;
        }

        //
        //  We have some blocks in this segment. We try to take them
        //  at ones and free to the heap like regular blocks
        //

        NewValue.Sequence = CapturedValue.Sequence + 1;
        NewValue.OffsetAndDepth = NO_MORE_ENTRIES << 16;

    } while ( !LOCKCOMP64(&SubSegment->AggregateExchg.Exchg, NewValue, CapturedValue) );

    //
    //  We suceeded to take all blocks from the s-list. From now on
    //  the convert cannot fail
    //
    
    InterlockedDecrement(&LowFragHeap->UserBlockCache.AvailableBlocks[ UserBlocks->SizeIndex - HEAP_LOWEST_USER_SIZE_INDEX ]);
    
    UserBlocks->SizeIndex = 0;

    if (InterlockedIncrement(&(((PHEAP_BUCKET)SubSegment->Bucket))->Conversions) == 1) {
        
        InterlockedIncrement(&LowFragHeap->Conversions);
    }

    SegmentIndex = UserBlockHeapEntry->SegmentIndex;

    //
    //  Convert the heap block headers to NT heap style
    //

    {
        LONG i;
        LONG TotalSize;
        PVOID Buffer = UserBlocks + 1;
        PHEAP_ENTRY BlockEntry;
        PHEAP_ENTRY PreviousBlockEntry = (PHEAP_ENTRY)UserBlocks - 1;
        PHEAP_ENTRY NextBlock = NULL;
        
        TotalSize = PreviousBlockEntry->Size;

        InterlockedExchangeAdd(&LowFragHeap->ConvertedSpace, (TotalSize << HEAP_GRANULARITY_SHIFT));

        if (!(PreviousBlockEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

            NextBlock = PreviousBlockEntry + PreviousBlockEntry->Size;
        }

        PreviousBlockEntry->Size = (sizeof(HEAP_ENTRY) + sizeof(HEAP_USERDATA_HEADER)) >> HEAP_GRANULARITY_SHIFT;
        PreviousBlockEntry->UnusedBytes = sizeof(HEAP_ENTRY);

        TotalSize -= PreviousBlockEntry->Size;

        //
        //  Walk the heap sub-segment, and set the attributes for each block
        //  according with the NT heap rules
        //

        for (i = 0; i < SubSegment->BlockCount; i++) {

            HEAP_ENTRY TempEntry;

            BlockEntry = (PHEAP_ENTRY) Buffer;
            
            //
            //  Initialize the block
            //

            BlockEntry->SegmentIndex = HEAP_LFH_IN_CONVERSION;

            BlockEntry->Size = *((volatile USHORT *)&SubSegment->BlockSize);
            BlockEntry->PreviousSize = *((volatile USHORT *)&PreviousBlockEntry->Size);
            
            //
            //  Restore the index since we are done with initialization
            //

            BlockEntry->SegmentIndex = SegmentIndex;
            
            TotalSize -= SubSegment->BlockSize;

            //
            //  Points to the next free block
            //
            
            Buffer = (PCHAR)Buffer + ((SIZE_T)SubSegment->BlockSize << HEAP_GRANULARITY_SHIFT);

            PreviousBlockEntry = BlockEntry;

    #if defined(_WIN64)
            BlockEntry->SubSegment = NULL;
    #endif
        }

        LFHEAPASSERT(TotalSize >= 0);

        //
        //  The last block into the segment is a special case. In general it can be smaller than
        //  other blocks. If the size is less than 2 heap units 
        //  (a block header + a small minimal block) we attach it to the last block
        //  Otherwise, we create a separate block and initialize it properly
        //

        if (TotalSize >= 2) { // TotalSize in heap units

            BlockEntry = BlockEntry + BlockEntry->Size;
            
            //
            //  Initialize the block
            //
            
            BlockEntry->SegmentIndex = SegmentIndex;
            BlockEntry->PreviousSize = PreviousBlockEntry->Size;
            BlockEntry->Flags = HEAP_ENTRY_BUSY;

            BlockEntry->Size = (USHORT)TotalSize;

            EndingFreeBlock = BlockEntry + 1;
        }

        //
        //  If we have a next block, we need to correct the PreviousSize field
        //

        if (NextBlock) {

            NextBlock->PreviousSize = BlockEntry->Size;

        } else {
            
            //
            //  Transfer the LAST_ENTRY flag, if any,  to the last block
            //

            BlockEntry->Flags |= HEAP_ENTRY_LAST_ENTRY;
            UserBlockHeapEntry->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

            RtlpUpdateLastEntry((PHEAP)LowFragHeap->Heap, BlockEntry);
        }
    }

    HeapUnlock(LowFragHeap->Heap);

    //
    //  Now free all blocks from the captured s-list to the NT heap
    //  We use HEAP_NO_SERIALIZE flag because we're already holding the lock
    //

    if (Depth){

        ULONG CrtOffset = CapturedValue.FreeEntryOffset;

        while (CrtOffset != NO_MORE_ENTRIES) {

            PBLOCK_ENTRY BlockEntry;
            PHEAP_ENTRY PreviousBlockEntry;

            BlockEntry = (PBLOCK_ENTRY)((PCHAR)UserBlocks + (CrtOffset << HEAP_GRANULARITY_SHIFT));

            CrtOffset = BlockEntry->LinkOffset;

            FreeSize += BlockEntry->Size;

            HeapFree(LowFragHeap->Heap, 0, (PVOID)((PHEAP_ENTRY)BlockEntry + 1));
        }
    }

    //
    //  Free also the last block, if any.
    //

    if (EndingFreeBlock) {
        
        HeapFree(LowFragHeap->Heap, 0, EndingFreeBlock);
    }

    LFHEAPASSERT(HeapValidate(LowFragHeap->Heap, 0, 0));

    RtlpFreeUserBuffer(LowFragHeap, SubSegment);

    RtlpUnlockSubSegment(&LowFragHeap->LocalData[SubSegment->AffinityIndex], SubSegment, HEAP_CONVERT_LOCK | HEAP_PUBLIC_LOCK | HEAP_USERDATA_LOCK);
    
    return TRUE;
}


ULONG
RtlpConvertHeapBucket (
    PLFH_HEAP LowFragHeap,
    ULONG SizeIndex
    ) 

/*++

Routine Description:

    The function converts the segments from a given bucket index
    to regular heap blocks

    N.B. This is a operation can take a long time to complete. The heap is
    calling this if the allocation of a new segment fails. 

Arguments:

    LowFragHeap - The Low Fragmentation Heap pointer
    
    SizeIndex - Bucket index (in range 0 - 127)

Return Value:

    The number of segments converted

--*/

{
    PHEAP_BUCKET HeapBucket = RtlpGetBucket(LowFragHeap, SizeIndex);
    ULONG Affinity;
    ULONG TotalConverted = 0;
    SINGLE_LIST_ENTRY Non_ConvertedList; 
    PVOID Entry;

    Non_ConvertedList.Next = NULL;

    for (Affinity = 0; Affinity < RtlpHeapMaxAffinity; Affinity++) {

        PHEAP_LOCAL_SEGMENT_INFO FreeSList =  &LowFragHeap->LocalData[ Affinity ].SegmentInfo[ SizeIndex ];

        while (Entry = RtlpSubSegmentPop(&FreeSList->SListHeader) ) {

            PHEAP_SUBSEGMENT SubSegment;

            SubSegment = CONTAINING_RECORD(Entry, HEAP_SUBSEGMENT, SFreeListEntry);

        #ifdef _HEAP_DEBUG
            SubSegment->SFreeListEntry.Next = NULL;
        #endif        

            LFHEAPASSERT( RtlpIsSubSegmentLocked(SubSegment, HEAP_PUBLIC_LOCK) );
            LFHEAPASSERT( SizeIndex == SubSegment->SizeIndex );

            //
            //  While we still hold the subsegment public lock, we try to convert 
            //  it to regular NT blocks
            //

            if (RtlpConvertSegmentToHeap( LowFragHeap, SubSegment )) {

                TotalConverted += 1;

                if (LowFragHeap->ConvertedSpace > HEAP_CONVERT_LIMIT) {

                    while (TRUE) {

                        PHEAP_SUBSEGMENT xSubSegment;

                        Entry = PopEntryList(&Non_ConvertedList);

                        if (Entry == NULL) {

                            break;
                        }

                        xSubSegment = CONTAINING_RECORD(Entry, HEAP_SUBSEGMENT, SFreeListEntry);

                        RtlpSubSegmentPush(&FreeSList->SListHeader, &xSubSegment->SFreeListEntry);

                    }
                    
                    return TotalConverted;
                }

            } else {

                PushEntryList(&Non_ConvertedList, &SubSegment->SFreeListEntry);
            }
        }

        while (TRUE) {

            PHEAP_SUBSEGMENT SubSegment;

            Entry = PopEntryList(&Non_ConvertedList);

            if (Entry == NULL) {

                break;
            }

            SubSegment = CONTAINING_RECORD(Entry, HEAP_SUBSEGMENT, SFreeListEntry);

            RtlpSubSegmentPush(&FreeSList->SListHeader, &SubSegment->SFreeListEntry);

        }

        if (!HeapBucket->UseAffinity) {

            break;
        }
    }

    return TotalConverted;
}

ULONG
RtlpFlushLFHeapCache (
    PLFH_HEAP LowFragHeap
    ) 

/*++

Routine Description:

    The function converts the segments from the free lists
    to regular heap blocks

    N.B. This is a operation can take a long time to complete. The heap is
    calling this if the allocation of a new segment fails. 

Arguments:

    LowFragHeap - The Low Fragmentation Heap pointer
    

Return Value:

    The number of segments converted

--*/

{
    LONG SizeIndex;
    ULONG TotalSegments = 0;

    //
    //  Convert to regular heap blocks starting with the upper buckets (with large segments)
    //

    for (SizeIndex = HEAP_BUCKETS_COUNT - 1; SizeIndex >= 0; SizeIndex--) {

        TotalSegments += RtlpConvertHeapBucket(LowFragHeap, SizeIndex);
        
        if (LowFragHeap->ConvertedSpace > HEAP_CONVERT_LIMIT) {
            
            break;
        }
    }

#ifdef _HEAP_DEBUG

    HeapValidate(LowFragHeap->Heap, 0, 0);

#endif //  _HEAP_DEBUG

    return TotalSegments;
}

SIZE_T 
FASTCALL
RtlpLowFragHeapGetBlockSize(
    HANDLE HeapHandle, 
    ULONG Flags, 
    PVOID p
    )

/*++

Routine Description:

    The function returns the size of a LFH block


Arguments:

    HeapHandle - The handle of the heap (not used yet)
    
    Flags - Not used yet
    
    p - The pointer being queried


Return Value:

    The size of that block. 

--*/

{
    PBLOCK_ENTRY Block = (PBLOCK_ENTRY)((PHEAP_ENTRY)p - 1);
    
    PHEAP_SUBSEGMENT SubSegment = (PHEAP_SUBSEGMENT)Block->SubSegment;

    //
    //  Test whether the block belongs to LFH. We need to capture the 
    //  subsegment before to protect against segment conversions
    //

    if (Block->SegmentIndex == HEAP_LFH_INDEX) {

        return (((SIZE_T)SubSegment->BlockSize) << HEAP_GRANULARITY_SHIFT) - sizeof(HEAP_ENTRY);
    }

    return 0;
}

VOID
RtlpInitializeLowFragHeapManager()

/*++

Routine Description:

    This function initialize the global variables for the low fragmention heap manager.


Arguments:


Return Value:


--*/

{
    SIZE_T Granularity = HEAP_GRANULARITY;
    ULONG i;
    SIZE_T PreviousSize = 0;
    SYSTEM_BASIC_INFORMATION SystemInformation;
    
    //
    //  prevent the second initialization
    //

    if (RtlpHeapMaxAffinity) {

        return;
    }

#ifdef _HEAP_DEBUG
    PrintMsg("Debug version\n");
#endif
    
    //
    //  Query the number of processors
    //

    if (NT_SUCCESS(NtQuerySystemInformation (SystemBasicInformation, &SystemInformation, sizeof(SystemInformation), NULL))) {

        ULONG Shift = 0;

        RtlpHeapMaxAffinity = SystemInformation.NumberOfProcessors;

        if (RtlpHeapMaxAffinity > 1) {

            RtlpHeapMaxAffinity = (RtlpHeapMaxAffinity << 1);
        }

        if (RtlpHeapMaxAffinity > HEAP_AFFINITY_LIMIT) {

            RtlpHeapMaxAffinity = HEAP_AFFINITY_LIMIT;
        }
        
    } else {

        PrintMsg("NtQuerySystemInformation failed\n");

        RtlpHeapMaxAffinity = 1;
    }

#ifdef _HEAP_DEBUG

    if (RtlpHeapMaxAffinity > 1) {

        PrintMsg("Affinity enabled at %ld\n", RtlpHeapMaxAffinity);
    }

#endif

    RtlpInitializeAffinityManager( (UCHAR)RtlpHeapMaxAffinity );

    //
    //  Generate the Bucket size table
    //

    for (i = 0; i < 32; i++) {

        PreviousSize = RtlpBucketBlockSizes[i] = PreviousSize + Granularity;
    }
    
    for (i = 32; i < HEAP_BUCKETS_COUNT; i++) {

        if ((i % 16) == 0) {

            Granularity <<= 1;
        }

        PreviousSize = RtlpBucketBlockSizes[i] = PreviousSize + Granularity;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heappage.c ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.c

Abstract:

    Implementation of NT RtlHeap family of APIs for debugging
    applications with heap usage bugs.  Each allocation returned to
    the calling app is placed at the end of a virtual page such that
    the following virtual page is protected (ie, NO_ACCESS).
    So, when the errant app attempts to reference or modify memory
    beyond the allocated portion of a heap block, an access violation
    is immediately caused.  This facilitates debugging the app
    because the access violation occurs at the exact point in the
    app where the heap corruption or abuse would occur.  Note that
    significantly more memory (pagefile) is required to run an app
    using this heap implementation as opposed to the retail heap
    manager.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#include "ntrtlp.h"
#include "heappage.h"       // external interface (hooks) to debug heap manager
#include "heappagi.h"
#include "heappriv.h"

int __cdecl sprintf(char *, const char *, ...);

//
//  Remainder of entire file is wrapped with #ifdef DEBUG_PAGE_HEAP so that
//  it will compile away to nothing if DEBUG_PAGE_HEAP is not defined in
//  heappage.h
//

#ifdef DEBUG_PAGE_HEAP

//
// Page size
//

#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8

#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16

#elif defined(_AMD64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 16

#else
    #error  // platform not defined
#endif

//
// Few constants
//

#define DPH_HEAP_SIGNATURE       0xFFEEDDCC
#define FILL_BYTE                0xEE
#define HEAD_FILL_SIZE           0x10
#define RESERVE_SIZE             0x100000
#define VM_UNIT_SIZE             0x10000
#define POOL_SIZE                0x4000
#define INLINE                   __inline
#define MIN_FREE_LIST_LENGTH     8

//
// Few macros
//

#define ROUNDUP2( x, n ) ((( x ) + (( n ) - 1 )) & ~(( n ) - 1 ))

#if INTERNAL_DEBUG
#define DEBUG_CODE( a ) a
#else
#define DEBUG_CODE( a )
#endif

#define RETAIL_ASSERT( a ) ( (a) ? TRUE : \
    RtlpDebugPageHeapAssert( "Page heap: assert: (" #a ")\n" ))

#define DEBUG_ASSERT( a ) DEBUG_CODE( RETAIL_ASSERT( a ))

#define HEAP_HANDLE_FROM_ROOT( HeapRoot ) \
    ((PVOID)(((PCHAR)(HeapRoot)) - PAGE_SIZE ))

#define IF_GENERATE_EXCEPTION( Flags, Status ) {                \
    if (( Flags ) & HEAP_GENERATE_EXCEPTIONS )                  \
        RtlpDebugPageHeapException((ULONG)(Status));            \
    }

#define OUT_OF_VM_BREAK( Flags, szText ) {                      \
    if (( Flags ) & HEAP_BREAK_WHEN_OUT_OF_VM )                 \
        RtlpDebugPageHeapBreak(( szText ));                     \
    }

//
// List manipulation macros
//

#define ENQUEUE_HEAD( Node, Head, Tail ) {          \
            (Node)->pNextAlloc = (Head);            \
            if ((Head) == NULL )                    \
                (Tail) = (Node);                    \
            (Head) = (Node);                        \
            }

#define ENQUEUE_TAIL( Node, Head, Tail ) {          \
            if ((Tail) == NULL )                    \
                (Head) = (Node);                    \
            else                                    \
                (Tail)->pNextAlloc = (Node);        \
            (Tail) = (Node);                        \
            }

#define DEQUEUE_NODE( Node, Prev, Head, Tail ) {    \
            PVOID Next = (Node)->pNextAlloc;        \
            if ((Head) == (Node))                   \
                (Head) = Next;                      \
            if ((Tail) == (Node))                   \
                (Tail) = (Prev);                    \
            if ((Prev) != (NULL))                   \
                (Prev)->pNextAlloc = Next;          \
            }

//
// Bias/unbias pointer
//

#define BIAS_POINTER(p)      ((PVOID)((ULONG_PTR)(p) | (ULONG_PTR)0x01))
#define UNBIAS_POINTER(p)    ((PVOID)((ULONG_PTR)(p) & ~((ULONG_PTR)0x01)))
#define IS_BIASED_POINTER(p) ((PVOID)((ULONG_PTR)(p) & (ULONG_PTR)0x01))

//
// Scramble/unscramble
//
// We scramble heap pointers in the header blocks in order to make them
// look as kernel pointers and cause an AV if used. This is not totally
// accurate on IA64 but still likely to cause an AV.
//

#if defined(_WIN64)
#define SCRAMBLE_VALUE ((ULONG_PTR)0x8000000000000000)
#else
#define SCRAMBLE_VALUE ((ULONG_PTR)0x80000000)
#endif

#define SCRAMBLE_POINTER(P) ((PVOID)((ULONG_PTR)(P) ^ SCRAMBLE_VALUE))
#define UNSCRAMBLE_POINTER(P) ((PVOID)((ULONG_PTR)(P) ^ SCRAMBLE_VALUE))

//
// Protect/Unprotect heap structures macros
//
// The Protect/Unprotect functions are #if zeroed for now because there is
// an issue to be resolved when destroying a heap. At that moment we need
// to modify the global list of heaps and for this we need to touch the
// heap structure for another heap. In order to do this we need to unprotect
// and later protect it and for that we need to acquire the lock of that heap.
// But this is prone to causing deadlocks. Until we will find a smart scheme
// for doing this we will disable the whole /protect feature. Note also that
// the same problem exists in the heap create code path where we have to update
// the global list of heaps too.
//
// The best fix for this would be to move the fwrd/bwrd pointers for the heap
// list from the DPH_HEAP_ROOT structure into the special R/W page that stores
// the heap lock (needs to be always R/W).
//

#define PROTECT_HEAP_STRUCTURES( HeapRoot ) {                           \
            if ((HeapRoot)->HeapFlags & HEAP_PROTECTION_ENABLED ) {     \
                RtlpDebugPageHeapProtectStructures( (HeapRoot) );       \
            }                                                           \
        }                                                               \

#define UNPROTECT_HEAP_STRUCTURES( HeapRoot ) {                         \
            if ((HeapRoot)->HeapFlags & HEAP_PROTECTION_ENABLED ) {     \
                RtlpDebugPageHeapUnProtectStructures( (HeapRoot) );     \
            }                                                           \
        }                                                               \

//
// RtlpDebugPageHeap
//
// Global variable that marks that page heap is enabled. It is set
// in \nt\base\ntdll\ldrinit.c by reading the GlobalFlag registry
// value (system wide or per process one) and checking if the
// FLG_HEAP_PAGE_ALLOCS is set.
//

BOOLEAN RtlpDebugPageHeap;

//
// Internal version used to figure out what are people running
// in various VBLs.
//

PCHAR RtlpDphVersion = "01/30/2001";

//
// Page heaps list manipulation.
//
// We maintain a list of all page heaps in the process to support
// APIs like GetProcessHeaps. The list is also useful for debug
// extensions that need to iterate the heaps. The list is protected
// by RtlpDphHeapListCriticalSection lock.
//

BOOLEAN RtlpDphHeapListHasBeenInitialized;
RTL_CRITICAL_SECTION RtlpDphHeapListCriticalSection;
PDPH_HEAP_ROOT RtlpDphHeapListHead;
PDPH_HEAP_ROOT RtlpDphHeapListTail;
ULONG RtlpDphHeapListCount;

//
// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation.
//
// The initial value is so that by default we use page heap only with
// normal allocations. This way if system wide global flag for page
// heap is set the machine will still boot. After that we can enable
// page heap with "sudden death" for specific processes. The most useful
// flags for this case would be:
//
//    PAGE_HEAP_ENABLE_PAGE_HEAP       |
//    PAGE_HEAP_COLLECT_STACK_TRACES   ;
//
// If no flags specified the default is page heap light with
// stack trace collection.
//

ULONG RtlpDphGlobalFlags = PAGE_HEAP_COLLECT_STACK_TRACES;

//
// Page heap global flags.
//
// These values are read from registry in \nt\base\ntdll\ldrinit.c.
//

ULONG RtlpDphSizeRangeStart;
ULONG RtlpDphSizeRangeEnd;
ULONG RtlpDphDllRangeStart;
ULONG RtlpDphDllRangeEnd;
ULONG RtlpDphRandomProbability;
WCHAR RtlpDphTargetDlls [512];
UNICODE_STRING RtlpDphTargetDllsUnicode;

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

ULONG RtlpDphFaultProbability;
ULONG RtlpDphFaultTimeOut;

//
// This variable offers volatile fault injection.
// It can be set/reset from debugger to disable/enable
// fault injection.
//

ULONG RtlpDphDisableFaults;

//
// `RtlpDphDebugLevel' controls debug messages in the code.
//

#define DPH_DEBUG_INTERNAL_VALIDATION 0x0001
#define DPH_DEBUG_RESERVED_2          0x0002
#define DPH_DEBUG_RESERVED_4          0x0004
#define DPH_DEBUG_RESERVED_8          0x0008
#define DPH_DEBUG_DECOMMIT_RANGES     0x0010
#define DPH_DEBUG_SLOW_CHECKS         0x0080
#define DPH_DEBUG_SHOW_VM_LIMITS      0x0100

ULONG RtlpDphDebugLevel;

//
// Threshold for delaying a free operation in the normal heap.
// If we get over this limit we start actually freeing blocks.
//

SIZE_T RtlpDphDelayedFreeCacheSize = 256 * PAGE_SIZE;

//
// Process wide trace database and the maximum size it can
// grow to.
//

SIZE_T RtlpDphTraceDatabaseMaximumSize = 256 * PAGE_SIZE;
PRTL_TRACE_DATABASE RtlpDphTraceDatabase;

//
// Support for normal heap allocations
//
// In order to make better use of memory available page heap will
// allocate some of the block into a normal NT heap that it manages.
// We will call these blocks "normal blocks" as opposed to "page blocks".
//
// All normal blocks have the requested size increased by DPH_BLOCK_INFORMATION.
// The address returned is of course of the first byte after the block
// info structure. Upon free, blocks are checked for corruption and
// then released into the normal heap.
//
// All these normal heap functions are called with the page heap
// lock acquired.
//

PVOID
RtlpDphNormalHeapAllocate (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    SIZE_T Size
    );

BOOLEAN
RtlpDphNormalHeapFree (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    PVOID Block
    );

PVOID
RtlpDphNormalHeapReAllocate (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    PVOID OldBlock,
    SIZE_T Size
    );

SIZE_T
RtlpDphNormalHeapSize (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    PVOID Block
    );

BOOLEAN
RtlpDphNormalHeapSetUserFlags(
    IN PDPH_HEAP_ROOT Heap,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDphNormalHeapSetUserValue(
    IN PDPH_HEAP_ROOT Heap,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDphNormalHeapGetUserInfo(
    IN PDPH_HEAP_ROOT Heap,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDphNormalHeapValidate(
    IN PDPH_HEAP_ROOT Heap,
    IN ULONG Flags,
    IN PVOID Address
    );

//
// Support for DPH_BLOCK_INFORMATION management
//
// This header information prefixes both the normal and page heap
// blocks.
//

#define DPH_CONTEXT_GENERAL                     0
#define DPH_CONTEXT_FULL_PAGE_HEAP_FREE         1
#define DPH_CONTEXT_FULL_PAGE_HEAP_REALLOC      2
#define DPH_CONTEXT_FULL_PAGE_HEAP_DESTROY      3
#define DPH_CONTEXT_NORMAL_PAGE_HEAP_FREE       4
#define DPH_CONTEXT_NORMAL_PAGE_HEAP_REALLOC    5
#define DPH_CONTEXT_NORMAL_PAGE_HEAP_SETFLAGS   6
#define DPH_CONTEXT_NORMAL_PAGE_HEAP_SETVALUE   7
#define DPH_CONTEXT_NORMAL_PAGE_HEAP_GETINFO    8
#define DPH_CONTEXT_DELAYED_FREE                9
#define DPH_CONTEXT_DELAYED_DESTROY             10

VOID
RtlpDphReportCorruptedBlock (
    PVOID Heap,
    ULONG Context,
    PVOID Block,
    ULONG Reason
    );

BOOLEAN
RtlpDphIsNormalHeapBlock (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    PULONG Reason,
    BOOLEAN CheckPattern
    );

BOOLEAN
RtlpDphIsNormalFreeHeapBlock (
    PVOID Block,
    PULONG Reason,
    BOOLEAN CheckPattern
    );

BOOLEAN
RtlpDphIsPageHeapBlock (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    PULONG Reason,
    BOOLEAN CheckPattern
    );

BOOLEAN
RtlpDphWriteNormalHeapBlockInformation (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    SIZE_T RequestedSize,
    SIZE_T ActualSize
    );

BOOLEAN
RtlpDphWritePageHeapBlockInformation (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    SIZE_T RequestedSize,
    SIZE_T ActualSize
    );

BOOLEAN
RtlpDphGetBlockSizeFromCorruptedBlock (
    PVOID Block,
    PSIZE_T Size
    );

//
// Delayed free queue (of normal heap allocations) management
//

VOID
RtlpDphInitializeDelayedFreeQueue (
    );

VOID
RtlpDphAddToDelayedFreeQueue (
    PDPH_BLOCK_INFORMATION Info
    );

BOOLEAN
RtlpDphNeedToTrimDelayedFreeQueue (
    PSIZE_T TrimSize
    );

VOID
RtlpDphTrimDelayedFreeQueue (
    SIZE_T TrimSize,
    ULONG Flags
    );

VOID
RtlpDphFreeDelayedBlocksFromHeap (
    PVOID PageHeap,
    PVOID NormalHeap
    );

//
// Decision normal heap vs. page heap
//

BOOLEAN
RtlpDphShouldAllocateInPageHeap (
    PDPH_HEAP_ROOT Heap,
    SIZE_T Size
    );

BOOLEAN
RtlpDphVmLimitCanUsePageHeap (
    );

//
// Stack trace detection for trace database.
//

PRTL_TRACE_BLOCK
RtlpDphLogStackTrace (
    ULONG FramesToSkip
    );

//
//  Page heap general support functions
//

VOID
RtlpDebugPageHeapBreak(
    IN PCH Text
    );

BOOLEAN
RtlpDebugPageHeapAssert(
    IN PCH Text
    );

VOID
RtlpDebugPageHeapEnterCritSect(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN ULONG          Flags
    );

INLINE
VOID
RtlpDebugPageHeapLeaveCritSect(
    IN PDPH_HEAP_ROOT HeapRoot
    );

VOID
RtlpDebugPageHeapException(
    IN ULONG ExceptionCode
    );

PVOID
RtlpDebugPageHeapPointerFromHandle(
    IN PVOID HeapHandle
    );

PCCH
RtlpDebugPageHeapProtectionText(
    IN     ULONG Access,
    IN OUT PCHAR Buffer
    );

//
// Virtual memory manipulation functions
//

BOOLEAN
RtlpDebugPageHeapRobustProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess,
    IN BOOLEAN Recursion
    );

INLINE
BOOLEAN
RtlpDebugPageHeapProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess
    );

INLINE
PVOID
RtlpDebugPageHeapAllocateVM(
    IN SIZE_T nSize
    );

INLINE
BOOLEAN
RtlpDebugPageHeapReleaseVM(
    IN PVOID pVirtual
    );

INLINE
BOOLEAN
RtlpDebugPageHeapCommitVM(
    IN PVOID pVirtual,
    IN SIZE_T nSize
    );

INLINE
BOOLEAN
RtlpDebugPageHeapDecommitVM(
    IN PVOID pVirtual,
    IN SIZE_T nSize
    );

//
// Target dlls logic
//
// RtlpDphTargetDllsLoadCallBack is called in ntdll\ldrapi.c
// (LdrpLoadDll) whenever a new dll is loaded in the process
// space.
//

VOID
RtlpDphTargetDllsLogicInitialize (
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

//
// Internal heap validation
//

VOID
RtlpDphInternalValidatePageHeap (
    PDPH_HEAP_ROOT Heap,
    PUCHAR ExemptAddress,
    SIZE_T ExemptSize
    );

VOID
RtlpDphValidateInternalLists (
    PDPH_HEAP_ROOT Heap
    );

//
// Fault injection logic
//

BOOLEAN
RtlpDphShouldFaultInject (
    );


//
// Free delayed cache internal checking
//

VOID
RtlpDphCheckFreeDelayedCache (
    PVOID CheckBlock,
    SIZE_T CheckSize
    );


//
// Defined in \base\ntdll\resource.c
//

VOID
RtlpCheckForCriticalSectionsInMemoryRange(
    IN PVOID StartAddress,
    IN SIZE_T RegionSize,
    IN PVOID Information
    );


/////////////////////////////////////////////////////////////////////
///////////////////////////////// Page heap general support functions
/////////////////////////////////////////////////////////////////////

VOID
RtlpDebugPageHeapBreak(
    IN PCH Text
    )
{
    DbgPrint( Text );
    DbgBreakPoint();
}

BOOLEAN
RtlpDebugPageHeapAssert(
    IN PCH Text
    )
{
    RtlpDebugPageHeapBreak( Text );
    return FALSE;
}

VOID
RtlpDebugPageHeapEnterCritSect(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN ULONG          Flags
    )
{
    if (HeapRoot->FirstThread == NULL) {
        HeapRoot->FirstThread = NtCurrentTeb()->ClientId.UniqueThread;
    }

    if (Flags & HEAP_NO_SERIALIZE) {

        //
        // If current thread has a different ID than the first thread
        // that got into this heap then we break. Avoid this check if
        // this allocation comes from Global/Local Heap APIs because
        // they lock the heap in a separate call and then they call
        // NT heap APIs with no_serialize flag set.
        //
        // Note. We avoid this check if we do not have the specific flag
        // on. This is so because MPheap-like heaps can give false 
        // positives.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS)) {
            if (RtlpDebugPageHeapPointerFromHandle(RtlProcessHeap()) != HeapRoot) {
                if (HeapRoot->FirstThread != NtCurrentTeb()->ClientId.UniqueThread) {
                    
                    VERIFIER_STOP (APPLICATION_VERIFIER_UNSYNCHRONIZED_ACCESS,
                                   "multithreaded access in HEAP_NO_SERIALIZE heap",
                                   HeapRoot, "Heap handle",
                                   HeapRoot->FirstThread, "First thread that used the heap",
                                   NtCurrentTeb()->ClientId.UniqueThread, "Current thread using the heap",
                                   1, "/no_sync option used");
                }
            }
        }

        if (! RtlTryEnterCriticalSection( HeapRoot->HeapCritSect )) {

            if (HeapRoot->nRemoteLockAcquired == 0) {

                //
                //  Another thread owns the CritSect.  This is an application
                //  bug since multithreaded access to heap was attempted with
                //  the HEAP_NO_SERIALIZE flag specified.
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_UNSYNCHRONIZED_ACCESS,
                               "multithreaded access in HEAP_NO_SERIALIZE heap",
                               HeapRoot, "Heap handle",
                               HeapRoot->HeapCritSect->OwningThread, "Thread owning heap lock",
                               NtCurrentTeb()->ClientId.UniqueThread, "Current thread trying to acquire the heap lock",
                               0, "");

                //
                //  In the interest of allowing the errant app to continue,
                //  we'll force serialization and continue.
                //

                HeapRoot->HeapFlags &= ~HEAP_NO_SERIALIZE;

            }

            RtlEnterCriticalSection( HeapRoot->HeapCritSect );

        }
    }
    else {
        RtlEnterCriticalSection( HeapRoot->HeapCritSect );
    }
}

INLINE
VOID
RtlpDebugPageHeapLeaveCritSect(
    IN PDPH_HEAP_ROOT HeapRoot
    )
{
    RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
}

VOID
RtlpDebugPageHeapException(
    IN ULONG ExceptionCode
    )
{
    EXCEPTION_RECORD ER;

    ER.ExceptionCode    = ExceptionCode;
    ER.ExceptionFlags   = 0;
    ER.ExceptionRecord  = NULL;
    ER.ExceptionAddress = RtlpDebugPageHeapException;
    ER.NumberParameters = 0;
    RtlRaiseException( &ER );
}

PVOID
RtlpDebugPageHeapPointerFromHandle(
    IN PVOID HeapHandle
    )
{
    try {
        if (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS) {

            PDPH_HEAP_ROOT HeapRoot = (PVOID)(((PCHAR)(HeapHandle)) + PAGE_SIZE );

            if (HeapRoot->Signature == DPH_HEAP_SIGNATURE) {
                return HeapRoot;
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
    }

    VERIFIER_STOP (APPLICATION_VERIFIER_BAD_HEAP_HANDLE,
                   "heap handle with incorrect signature",
                   HeapHandle, "Heap handle", 
                   0, "", 0, "", 0, "");

    return NULL;
}

PCCH
RtlpDebugPageHeapProtectionText(
    IN     ULONG Access,
    IN OUT PCHAR Buffer
    )
{
    switch (Access) {
    case PAGE_NOACCESS:          return "PAGE_NOACCESS";
    case PAGE_READONLY:          return "PAGE_READONLY";
    case PAGE_READWRITE:         return "PAGE_READWRITE";
    case PAGE_WRITECOPY:         return "PAGE_WRITECOPY";
    case PAGE_EXECUTE:           return "PAGE_EXECUTE";
    case PAGE_EXECUTE_READ:      return "PAGE_EXECUTE_READ";
    case PAGE_EXECUTE_READWRITE: return "PAGE_EXECUTE_READWRITE";
    case PAGE_EXECUTE_WRITECOPY: return "PAGE_EXECUTE_WRITECOPY";
    case PAGE_GUARD:             return "PAGE_GUARD";
    case 0:                      return "UNKNOWN";
    default:                     sprintf( Buffer, "0x%08X", Access );
        return Buffer;
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////// Virtual memory manipulation functions
/////////////////////////////////////////////////////////////////////

BOOLEAN
RtlpDebugPageHeapRobustProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess,
    IN BOOLEAN Recursion
    )
{
    PVOID  CopyOfVirtualBase = VirtualBase;
    SIZE_T CopyOfVirtualSize = VirtualSize;
    ULONG  OldAccess;
    NTSTATUS Status;

    Status = ZwProtectVirtualMemory(
        NtCurrentProcess(),
        &CopyOfVirtualBase,
        &CopyOfVirtualSize,
        NewAccess,
        &OldAccess
        );

    if (NT_SUCCESS( Status ))
        return TRUE;

    if (! Recursion) {

        //
        //  We failed to change the protection on a range of memory.
        //  This can happen if if the range of memory spans more than
        //  one adjancent blocks allocated by separate calls to
        //  ZwAllocateVirtualMemory.  It also seems fails occasionally
        //  for reasons unknown to me, but always when attempting to
        //  change the protection on more than one page in a single call.
        //  So, fall back to changing pages individually in this range.
        //  This should be rare, so it should not be a performance problem.
        //

        PCHAR VirtualExtent = (PCHAR)ROUNDUP2((ULONG_PTR)((PCHAR)VirtualBase + VirtualSize ), PAGE_SIZE );
        PCHAR VirtualPage   = (PCHAR)((ULONG_PTR)VirtualBase & ~( PAGE_SIZE - 1 ));
        BOOLEAN SuccessAll  = TRUE;
        BOOLEAN SuccessOne;

        while (VirtualPage < VirtualExtent) {

            SuccessOne = RtlpDebugPageHeapRobustProtectVM(
                VirtualPage,
                PAGE_SIZE,
                NewAccess,
                TRUE
                );

            if (! SuccessOne) {
                SuccessAll = FALSE;
            }

            VirtualPage += PAGE_SIZE;

        }

        return SuccessAll;      // TRUE if all succeeded, FALSE if any failed
    }

    else {

        MEMORY_BASIC_INFORMATION mbi;
        CHAR OldProtectionText[ 12 ];     // big enough for "0x12345678"
        CHAR NewProtectionText[ 12 ];     // big enough for "0x12345678"

        mbi.Protect = 0;    // in case ZwQueryVirtualMemory fails

        ZwQueryVirtualMemory(
            NtCurrentProcess(),
            VirtualBase,
            MemoryBasicInformation,
            &mbi,
            sizeof( mbi ),
            NULL
            );

        DbgPrint(
            "Page heap: Failed changing VM at %08X size 0x%X\n"
            "          from %s to %s (Status %08X)\n",
            VirtualBase,
            VirtualSize,
            RtlpDebugPageHeapProtectionText( mbi.Protect, OldProtectionText ),
            RtlpDebugPageHeapProtectionText( NewAccess, NewProtectionText ),
            Status
            );
    }

    return FALSE;
}

INLINE
BOOLEAN
RtlpDebugPageHeapProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess
    )
{
    return RtlpDebugPageHeapRobustProtectVM( VirtualBase, VirtualSize, NewAccess, FALSE );
}

INLINE
PVOID
RtlpDebugPageHeapAllocateVM(
    IN SIZE_T nSize
    )
{
    NTSTATUS Status;
    PVOID pVirtual;

    pVirtual = NULL;

    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
        &pVirtual,
        0,
        &nSize,
        MEM_COMMIT,
        PAGE_NOACCESS );

    return NT_SUCCESS( Status ) ? pVirtual : NULL;
}

INLINE
BOOLEAN
RtlpDebugPageHeapReleaseVM(
    IN PVOID pVirtual
    )
{
    SIZE_T nSize = 0;

    return NT_SUCCESS( RtlpHeapFreeVirtualMemory( NtCurrentProcess(),
        &pVirtual,
        &nSize,
        MEM_RELEASE ));
}

INLINE
BOOLEAN
RtlpDebugPageHeapCommitVM(
    IN PVOID pVirtual,
    IN SIZE_T nSize
    )
{
    PCHAR pStart, pEnd, pCurrent;
    NTSTATUS Status;
    SIZE_T CommitSize;
    BOOLEAN Failed = FALSE;

    pStart = (PCHAR)((ULONG_PTR)pVirtual & ~(PAGE_SIZE - 1));
    pEnd = (PCHAR)(((ULONG_PTR)pVirtual + nSize) & ~(PAGE_SIZE - 1));

    for (pCurrent = pStart; pCurrent < pEnd; pCurrent += PAGE_SIZE) {

        CommitSize = PAGE_SIZE;

        Status = ZwAllocateVirtualMemory(
            NtCurrentProcess(),
            &pCurrent,
            0,
            &CommitSize,
            MEM_COMMIT,
            PAGE_NOACCESS);

        if (! NT_SUCCESS(Status)) {

            //
            // The call can fail in low memory conditions. In this case we
            // try to recover and will probably fail the original allocation.
            //

            if ((RtlpDphDebugLevel & DPH_DEBUG_DECOMMIT_RANGES)) {

                VERIFIER_STOP (APPLICATION_VERIFIER_INTERNAL_WARNING,
                               "page heap failed to commit memory",
                               pCurrent, "",
                               CommitSize, "",
                               Status, "",
                               0, "");
            }

            Failed = TRUE;
            break;
        }
    }


    if (Failed) {

        //
        // We need to roll back whatever succeeded.
        //

        for (pCurrent -= PAGE_SIZE; pCurrent >= pStart && pCurrent < pEnd; pCurrent -= PAGE_SIZE) {

            CommitSize = PAGE_SIZE;

            Status = RtlpHeapFreeVirtualMemory(
                NtCurrentProcess(),
                &pCurrent,
                &CommitSize,
                MEM_DECOMMIT);

            if (! NT_SUCCESS(Status)) {

                //
                // There is now valid reason known to me for a correct free operation
                // failure. So, in this case we make a little bit of fuss about it.
                //

                VERIFIER_STOP (APPLICATION_VERIFIER_INTERNAL_WARNING,
                               "page heap failed to decommit memory",
                               pCurrent, "",
                               CommitSize, "",
                               Status, "",
                               0, "");
            }
        }
    }

    if (Failed) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

INLINE
BOOLEAN
RtlpDebugPageHeapDecommitVM(
    IN PVOID pVirtual,
    IN SIZE_T nSize
    )
{
    PCHAR pStart, pEnd, pCurrent;
    NTSTATUS Status;
    SIZE_T DecommitSize;
    BOOLEAN Failed = FALSE;

    pStart = (PCHAR)((ULONG_PTR)pVirtual & ~(PAGE_SIZE - 1));
    pEnd = (PCHAR)(((ULONG_PTR)pVirtual + nSize) & ~(PAGE_SIZE - 1));

    for (pCurrent = pStart; pCurrent < pEnd; pCurrent += PAGE_SIZE) {

        DecommitSize = PAGE_SIZE;

        Status = RtlpHeapFreeVirtualMemory(
            NtCurrentProcess(),
            &pCurrent,
            &DecommitSize,
            MEM_DECOMMIT);

        if (! NT_SUCCESS(Status)) {

            //
            // There is now valid reason known to me for a correct free operation
            // failure. So, in this case we make a little bit of fuss about it.
            //

            VERIFIER_STOP (APPLICATION_VERIFIER_INTERNAL_WARNING,
                           "page heap failed to commit memory",
                           pCurrent, "",
                           DecommitSize, "",
                           Status, "",
                           0, "");

            Failed = TRUE;
        }
    }

    if (Failed) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Internal page heap functions
/////////////////////////////////////////////////////////////////////

PDPH_HEAP_BLOCK
RtlpDebugPageHeapTakeNodeFromUnusedList(
    IN PDPH_HEAP_ROOT pHeap
    )
{
    PDPH_HEAP_BLOCK pNode = pHeap->pUnusedNodeListHead;
    PDPH_HEAP_BLOCK pPrev = NULL;

    //
    //  UnusedNodeList is LIFO with most recent entry at head of list.
    //

    if (pNode) {

        DEQUEUE_NODE( pNode, pPrev, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

        pHeap->nUnusedNodes -= 1;

    }

    return pNode;
}

VOID
RtlpDebugPageHeapReturnNodeToUnusedList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode
    )
{
    //
    //  UnusedNodeList is LIFO with most recent entry at head of list.
    //

    ENQUEUE_HEAD( pNode, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

    pHeap->nUnusedNodes += 1;
}

PDPH_HEAP_BLOCK
RtlpDebugPageHeapFindBusyMem(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  PVOID                 pUserMem,
    OUT PDPH_HEAP_BLOCK *pPrevAlloc
    )
{
    PDPH_HEAP_BLOCK pNode = pHeap->pBusyAllocationListHead;
    PDPH_HEAP_BLOCK pPrev = NULL;

    while (pNode != NULL) {

        if (pNode->pUserAllocation == pUserMem) {

            if (pPrevAlloc)
                *pPrevAlloc = pPrev;

            return pNode;
        }

        pPrev = pNode;
        pNode = pNode->pNextAlloc;
    }

    return NULL;
}

VOID
RtlpDebugPageHeapRemoveFromAvailableList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode,
    IN PDPH_HEAP_BLOCK pPrev
    )
{
    DEQUEUE_NODE( pNode, pPrev, pHeap->pAvailableAllocationListHead, pHeap->pAvailableAllocationListTail );

    pHeap->nAvailableAllocations -= 1;
    pHeap->nAvailableAllocationBytesCommitted -= pNode->nVirtualBlockSize;
}

VOID
RtlpDebugPageHeapPlaceOnFreeList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pAlloc
    )
{
    //
    //  FreeAllocationList is stored FIFO to enhance finding
    //  reference-after-freed bugs by keeping previously freed
    //  allocations on the free list as long as possible.
    //

    pAlloc->pNextAlloc = NULL;

    ENQUEUE_TAIL( pAlloc, pHeap->pFreeAllocationListHead, pHeap->pFreeAllocationListTail );

    pHeap->nFreeAllocations += 1;
    pHeap->nFreeAllocationBytesCommitted += pAlloc->nVirtualBlockSize;
}

VOID
RtlpDebugPageHeapRemoveFromFreeList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode,
    IN PDPH_HEAP_BLOCK pPrev
    )
{
    DEQUEUE_NODE( pNode, pPrev, pHeap->pFreeAllocationListHead, pHeap->pFreeAllocationListTail );

    pHeap->nFreeAllocations -= 1;
    pHeap->nFreeAllocationBytesCommitted -= pNode->nVirtualBlockSize;

    pNode->StackTrace = NULL;
}

VOID
RtlpDebugPageHeapPlaceOnVirtualList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode
    )
{
    //
    //  VirtualStorageList is LIFO so that releasing VM blocks will
    //  occur in exact reverse order.
    //

    ENQUEUE_HEAD( pNode, pHeap->pVirtualStorageListHead, pHeap->pVirtualStorageListTail );

    pHeap->nVirtualStorageRanges += 1;
    pHeap->nVirtualStorageBytes += pNode->nVirtualBlockSize;
}

VOID
RtlpDebugPageHeapPlaceOnBusyList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode
    )
{
    //
    //  BusyAllocationList is LIFO to achieve better temporal locality
    //  of reference (older allocations are farther down the list).
    //

    ENQUEUE_HEAD( pNode, pHeap->pBusyAllocationListHead, pHeap->pBusyAllocationListTail );

    pHeap->nBusyAllocations += 1;
    pHeap->nBusyAllocationBytesCommitted  += pNode->nVirtualBlockSize;
    pHeap->nBusyAllocationBytesAccessible += pNode->nVirtualAccessSize;
}

VOID
RtlpDebugPageHeapRemoveFromBusyList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode,
    IN PDPH_HEAP_BLOCK pPrev
    )
{
    DEQUEUE_NODE( pNode, pPrev, pHeap->pBusyAllocationListHead, pHeap->pBusyAllocationListTail );

    pHeap->nBusyAllocations -= 1;
    pHeap->nBusyAllocationBytesCommitted  -= pNode->nVirtualBlockSize;
    pHeap->nBusyAllocationBytesAccessible -= pNode->nVirtualAccessSize;
}

PDPH_HEAP_BLOCK
RtlpDebugPageHeapSearchAvailableMemListForBestFit(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  SIZE_T                nSize,
    OUT PDPH_HEAP_BLOCK *pPrevAvailNode
    )
{
    PDPH_HEAP_BLOCK pAvail, pFound, pAvailPrev, pFoundPrev;
    SIZE_T nAvail, nFound;

    nFound     = 0x7FFFFFFF;
    pFound     = NULL;
    pFoundPrev = NULL;
    pAvailPrev = NULL;
    pAvail     = pHeap->pAvailableAllocationListHead;

    while (( pAvail != NULL ) && ( nFound > nSize )) {

        nAvail = pAvail->nVirtualBlockSize;

        if (( nAvail >= nSize ) && ( nAvail < nFound )) {
            nFound     = nAvail;
            pFound     = pAvail;
            pFoundPrev = pAvailPrev;
        }

        pAvailPrev = pAvail;
        pAvail     = pAvail->pNextAlloc;
    }

    *pPrevAvailNode = pFoundPrev;
    return pFound;
}

//
// Counters for # times coalesce operations got rejected
// to avoid cross-VAD issues.
//

LONG RtlpDphCoalesceStatistics [4];

#define ALIGN_TO_SIZE(P, Sz) (((ULONG_PTR)(P)) & ~((ULONG_PTR)(Sz) - 1))

BOOLEAN
RtlpDphSameVirtualRegion (
    IN PDPH_HEAP_BLOCK Left,
    IN PDPH_HEAP_BLOCK Right
    )
/*++

Routine description:

    This function tries to figure out if two nodes are part of the
    same VAD. The function is used during coalescing in order to avoid
    merging together blocks from different VADs. If we do not do this
    we will break applications that do GDI calls.

    SilviuC: this can be done differently if we keep the VAD address in 
    every node and make sure to propagate the value when nodes get split.
    Then this function will just be a comparison of the two values.
        
--*/
{
    PVOID LeftRegion;
    MEMORY_BASIC_INFORMATION MemoryInfo;
    NTSTATUS Status;
    SIZE_T ReturnLength;

    //
    // If blocks are in the same 64K chunk we are okay.
    //

    if (ALIGN_TO_SIZE(Left->pVirtualBlock, VM_UNIT_SIZE) 
        == ALIGN_TO_SIZE(Right->pVirtualBlock, VM_UNIT_SIZE)) {

        InterlockedIncrement (&(RtlpDphCoalesceStatistics[2]));
        return TRUE;
    }

    //
    // Call query() to find out what is the start address of the
    // VAD for each node.
    //

    Status = ZwQueryVirtualMemory (NtCurrentProcess(),
                                   Left->pVirtualBlock,
                                   MemoryBasicInformation,
                                   &MemoryInfo,
                                   sizeof MemoryInfo,
                                   &ReturnLength);
    
    if (! NT_SUCCESS(Status)) {
        InterlockedIncrement (&(RtlpDphCoalesceStatistics[3]));
        return FALSE;
    }

    LeftRegion = MemoryInfo.AllocationBase;

    Status = ZwQueryVirtualMemory (NtCurrentProcess(),
                                   Right->pVirtualBlock,
                                   MemoryBasicInformation,
                                   &MemoryInfo,
                                   sizeof MemoryInfo,
                                   &ReturnLength);
    
    if (! NT_SUCCESS(Status)) {
        InterlockedIncrement (&(RtlpDphCoalesceStatistics[3]));
        return FALSE;
    }

    if (LeftRegion == MemoryInfo.AllocationBase) {
        
        InterlockedIncrement (&(RtlpDphCoalesceStatistics[0]));
        return TRUE;
    }
    else {

        InterlockedIncrement (&(RtlpDphCoalesceStatistics[1]));
        return FALSE;
    }
}


VOID
RtlpDebugPageHeapCoalesceNodeIntoAvailable(
    IN PDPH_HEAP_ROOT pHeap,
    IN PDPH_HEAP_BLOCK pNode
    )
{
    PDPH_HEAP_BLOCK pPrev;
    PDPH_HEAP_BLOCK pNext;
    PUCHAR pVirtual;
    SIZE_T nVirtual;

    pPrev = NULL;
    pNext = pHeap->pAvailableAllocationListHead;

    pVirtual = pNode->pVirtualBlock;
    nVirtual = pNode->nVirtualBlockSize;

    pHeap->nAvailableAllocationBytesCommitted += nVirtual;
    pHeap->nAvailableAllocations += 1;

    //
    //  Walk list to insertion point.
    //

    while (( pNext ) && ( pNext->pVirtualBlock < pVirtual )) {
        pPrev = pNext;
        pNext = pNext->pNextAlloc;
    }

    if (pPrev) {

        if (((pPrev->pVirtualBlock + pPrev->nVirtualBlockSize) == pVirtual) && 
             RtlpDphSameVirtualRegion (pPrev, pNode)) {

            //
            //  pPrev and pNode are adjacent, so simply add size of
            //  pNode entry to pPrev entry.
            //

            pPrev->nVirtualBlockSize += nVirtual;

            RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNode );

            pHeap->nAvailableAllocations--;

            pNode    = pPrev;
            pVirtual = pPrev->pVirtualBlock;
            nVirtual = pPrev->nVirtualBlockSize;

        }

        else {

            //
            //  pPrev and pNode are not adjacent, so insert the pNode
            //  block into the list after pPrev.
            //

            pNode->pNextAlloc = pPrev->pNextAlloc;
            pPrev->pNextAlloc = pNode;

        }
    }

    else {

        //
        //  pNode should be inserted at head of list.
        //

        pNode->pNextAlloc = pHeap->pAvailableAllocationListHead;
        pHeap->pAvailableAllocationListHead = pNode;

    }


    if (pNext) {

        if (((pVirtual + nVirtual) == pNext->pVirtualBlock) &&
             RtlpDphSameVirtualRegion (pNode, pNext)) { 

            //
            //  pNode and pNext are adjacent, so simply add size of
            //  pNext entry to pNode entry and remove pNext entry
            //  from the list.
            //

            pNode->nVirtualBlockSize += pNext->nVirtualBlockSize;

            pNode->pNextAlloc = pNext->pNextAlloc;

            if (pHeap->pAvailableAllocationListTail == pNext) {
                pHeap->pAvailableAllocationListTail = pNode;
            }

            RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNext );

            pHeap->nAvailableAllocations--;

        }
    }

    else {

        //
        //  pNode is tail of list.
        //

        pHeap->pAvailableAllocationListTail = pNode;

    }
}


VOID
RtlpDebugPageHeapCoalesceFreeIntoAvailable(
    IN PDPH_HEAP_ROOT pHeap,
    IN ULONG          nLeaveOnFreeList
    )
{
    PDPH_HEAP_BLOCK pNode = pHeap->pFreeAllocationListHead;
    SIZE_T               nFree = pHeap->nFreeAllocations;
    PDPH_HEAP_BLOCK pNext;

    DEBUG_ASSERT( nFree >= nLeaveOnFreeList );

    while (( pNode ) && ( nFree-- > nLeaveOnFreeList )) {

        pNext = pNode->pNextAlloc;  // preserve next pointer across shuffling

        RtlpDebugPageHeapRemoveFromFreeList( pHeap, pNode, NULL );

        RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );

        pNode = pNext;

    }

    DEBUG_ASSERT(( nFree = (volatile SIZE_T)( pHeap->nFreeAllocations )) >= nLeaveOnFreeList );
    DEBUG_ASSERT(( pNode != NULL ) || ( nFree == 0 ));

}

// forward
BOOLEAN
RtlpDebugPageHeapGrowVirtual(
    IN PDPH_HEAP_ROOT pHeap,
    IN SIZE_T         nSize
    );

PDPH_HEAP_BLOCK
RtlpDebugPageHeapFindAvailableMem(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  SIZE_T                nSize,
    OUT PDPH_HEAP_BLOCK *pPrevAvailNode,
    IN  BOOLEAN               bGrowVirtual
    )
{
    PDPH_HEAP_BLOCK pAvail;
    ULONG                nLeaveOnFreeList;

    //
    // If we use uncommitted ranges it is really important to
    // call FindAvailableMemory only with page aligned sizes.
    //

    if ((pHeap->ExtraFlags & PAGE_HEAP_SMART_MEMORY_USAGE)) {
        DEBUG_ASSERT ((nSize & ~(PAGE_SIZE - 1)) == nSize);
    }

    //
    //  First search existing AvailableList for a "best-fit" block
    //  (the smallest block that will satisfy the request).
    //

    pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
        pHeap,
        nSize,
        pPrevAvailNode
        );

    while (( pAvail == NULL ) && ( pHeap->nFreeAllocations > MIN_FREE_LIST_LENGTH )) {

        //
        //  Failed to find sufficient memory on AvailableList.  Coalesce
        //  3/4 of the FreeList memory to the AvailableList and try again.
        //  Continue this until we have sufficient memory in AvailableList,
        //  or the FreeList length is reduced to MIN_FREE_LIST_LENGTH entries.
        //  We don't shrink the FreeList length below MIN_FREE_LIST_LENGTH
        //  entries to preserve the most recent MIN_FREE_LIST_LENGTH entries
        //  for reference-after-freed purposes.
        //

        nLeaveOnFreeList = pHeap->nFreeAllocations / 4;

        if (nLeaveOnFreeList < MIN_FREE_LIST_LENGTH)
            nLeaveOnFreeList = MIN_FREE_LIST_LENGTH;

        RtlpDebugPageHeapCoalesceFreeIntoAvailable( pHeap, nLeaveOnFreeList );

        pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
            pHeap,
            nSize,
            pPrevAvailNode
            );

    }


    if (( pAvail == NULL ) && ( bGrowVirtual )) {

        //
        //  After coalescing FreeList into AvailableList, still don't have
        //  enough memory (large enough block) to satisfy request, so we
        //  need to allocate more VM.
        //

        if (RtlpDebugPageHeapGrowVirtual( pHeap, nSize )) {

            pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                pHeap,
                nSize,
                pPrevAvailNode
                );

            if (pAvail == NULL) {

                //
                //  Failed to satisfy request with more VM.  If remainder
                //  of free list combined with available list is larger
                //  than the request, we might still be able to satisfy
                //  the request by merging all of the free list onto the
                //  available list.  Note we lose our MIN_FREE_LIST_LENGTH
                //  reference-after-freed insurance in this case, but it
                //  is a rare case, and we'd prefer to satisfy the allocation.
                //

                if (( pHeap->nFreeAllocationBytesCommitted +
                    pHeap->nAvailableAllocationBytesCommitted ) >= nSize) {

                    RtlpDebugPageHeapCoalesceFreeIntoAvailable( pHeap, 0 );

                    pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                        pHeap,
                        nSize,
                        pPrevAvailNode
                        );
                }
            }
        }
    }

    //
    // If we use uncommitted ranges we need to commit the memory
    // range now. Note that the memory will be committed but
    // the protection on it will be N/A.
    //

    if (pAvail && (pHeap->ExtraFlags & PAGE_HEAP_SMART_MEMORY_USAGE)) {

        BOOLEAN Success;

        //
        // (SilviuC): The memory here might be already committed if we use
        // it for the first time. Whenever we allocate virtual memory to grow
        // the heap we commit it. This is the reason the consumption does not
        // decrease as spectacular as we expected. We will need to fix it in
        // the future. It affects 0x43 flags.
        //

        Success = RtlpDebugPageHeapCommitVM (pAvail->pVirtualBlock, nSize);

        if (!Success) {

            //
            // We did not manage to commit memory for this block. This
            // can happen in low memory conditions. We will return null.
            // There is no need to do anything with the node we obtained.
            // It is already in the Available list where it should be anyway.

            return NULL;
        }
    }

    return pAvail;
}

VOID
RtlpDebugPageHeapPlaceOnPoolList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_BLOCK pNode
    )
{

    //
    //  NodePoolList is FIFO.
    //

    pNode->pNextAlloc = NULL;

    ENQUEUE_TAIL( pNode, pHeap->pNodePoolListHead, pHeap->pNodePoolListTail );

    pHeap->nNodePoolBytes += pNode->nVirtualBlockSize;
    pHeap->nNodePools     += 1;

}

VOID
RtlpDebugPageHeapAddNewPool(
    IN PDPH_HEAP_ROOT pHeap,
    IN PVOID          pVirtual,
    IN SIZE_T         nSize,
    IN BOOLEAN        bAddToPoolList
    )
{
    PDPH_HEAP_BLOCK pNode, pFirst;
    ULONG n, nCount;

    //
    //  Assume pVirtual points to committed block of nSize bytes.
    //

    pFirst = pVirtual;
    nCount = (ULONG)(nSize  / sizeof( DPH_HEAP_BLOCK ));

    for (n = nCount - 1, pNode = pFirst; n > 0; pNode++, n--)
        pNode->pNextAlloc = pNode + 1;

    pNode->pNextAlloc = NULL;

    //
    //  Now link this list into the tail of the UnusedNodeList
    //

    ENQUEUE_TAIL( pFirst, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

    pHeap->pUnusedNodeListTail = pNode;

    pHeap->nUnusedNodes += nCount;

    if (bAddToPoolList) {

        //
        //  Now add an entry on the PoolList by taking a node from the
        //  UnusedNodeList, which should be guaranteed to be non-empty
        //  since we just added new nodes to it.
        //

        pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );

        DEBUG_ASSERT( pNode != NULL );

        pNode->pVirtualBlock     = pVirtual;
        pNode->nVirtualBlockSize = nSize;

        RtlpDebugPageHeapPlaceOnPoolList( pHeap, pNode );

    }
}

PDPH_HEAP_BLOCK
RtlpDebugPageHeapAllocateNode(
    IN PDPH_HEAP_ROOT pHeap
    )
{
    PDPH_HEAP_BLOCK pNode, pPrev, pReturn;
    PUCHAR pVirtual;
    SIZE_T nVirtual;
    SIZE_T nRequest;

    DEBUG_ASSERT( ! pHeap->InsideAllocateNode );
    DEBUG_CODE( pHeap->InsideAllocateNode = TRUE );

    pReturn = NULL;

    if (pHeap->pUnusedNodeListHead == NULL) {

        //
        //  We're out of nodes -- allocate new node pool
        //  from AvailableList.  Set bGrowVirtual to FALSE
        //  since growing virtual will require new nodes, causing
        //  recursion.  Note that simply calling FindAvailableMem
        //  might return some nodes to the pUnusedNodeList, even if
        //  the call fails, so we'll check that the UnusedNodeList
        //  is still empty before we try to use or allocate more
        //  memory.
        //

        nRequest = POOL_SIZE;

        pNode = RtlpDebugPageHeapFindAvailableMem(
            pHeap,
            nRequest,
            &pPrev,
            FALSE
            );

        if (( pHeap->pUnusedNodeListHead == NULL ) && ( pNode == NULL )) {

            //
            //  Reduce request size to PAGE_SIZE and see if
            //  we can find at least a page on the available
            //  list.
            //

            nRequest = PAGE_SIZE;

            pNode = RtlpDebugPageHeapFindAvailableMem(
                pHeap,
                nRequest,
                &pPrev,
                FALSE
                );

        }

        if (pHeap->pUnusedNodeListHead == NULL) {

            if (pNode == NULL) {

                //
                //  Insufficient memory on Available list.  Try allocating a
                //  new virtual block.
                //

                nRequest = POOL_SIZE;
                nVirtual = RESERVE_SIZE;
                pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

                if (pVirtual == NULL) {

                    //
                    //  Unable to allocate full RESERVE_SIZE block,
                    //  so reduce request to single VM unit (64K)
                    //  and try again.
                    //

                    nVirtual = VM_UNIT_SIZE;
                    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

                    if (pVirtual == NULL) {

                        //
                        //  Can't allocate any VM.
                        //

                        goto EXIT;
                    }
                }
            }

            else {

                RtlpDebugPageHeapRemoveFromAvailableList( pHeap, pNode, pPrev );

                pVirtual = pNode->pVirtualBlock;
                nVirtual = pNode->nVirtualBlockSize;

            }

            //
            //  We now have allocated VM referenced by pVirtual,nVirtual.
            //  Make nRequest portion of VM accessible for new node pool.
            //

            if (! RtlpDebugPageHeapProtectVM( pVirtual, nRequest, PAGE_READWRITE )) {

                if (pNode == NULL) {
                    RtlpDebugPageHeapReleaseVM( pVirtual );
                }
                else {
                    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );
                }

                goto EXIT;
            }

            //
            //  Now we have accessible memory for new pool.  Add the
            //  new memory to the pool.  If the new memory came from
            //  AvailableList versus fresh VM, zero the memory first.
            //

            if (pNode != NULL) {
                RtlZeroMemory( pVirtual, nRequest );
            }

            RtlpDebugPageHeapAddNewPool( pHeap, pVirtual, nRequest, TRUE );

            //
            //  If any memory remaining, put it on available list.
            //

            if (pNode == NULL) {

                //
                //  Memory came from new VM -- add appropriate list entries
                //  for new VM and add remainder of VM to free list.
                //

                pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
                DEBUG_ASSERT( pNode != NULL );
                pNode->pVirtualBlock     = pVirtual;
                pNode->nVirtualBlockSize = nVirtual;
                RtlpDebugPageHeapPlaceOnVirtualList( pHeap, pNode );

                pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
                DEBUG_ASSERT( pNode != NULL );
                pNode->pVirtualBlock     = pVirtual + nRequest;
                pNode->nVirtualBlockSize = nVirtual - nRequest;

                RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );

            }

            else {

                if (pNode->nVirtualBlockSize > nRequest) {

                    pNode->pVirtualBlock     += nRequest;
                    pNode->nVirtualBlockSize -= nRequest;

                    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );
                }

                else {

                    //
                    //  Used up entire available block -- return node to
                    //  unused list.
                    //

                    RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNode );

                }
            }
        }
    }

    pReturn = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
    DEBUG_ASSERT( pReturn != NULL );

    EXIT:

    DEBUG_CODE( pHeap->InsideAllocateNode = FALSE );
    return pReturn;
}

BOOLEAN
RtlpDebugPageHeapGrowVirtual(
    IN PDPH_HEAP_ROOT pHeap,
    IN SIZE_T         nSize
    )
{
    PDPH_HEAP_BLOCK pVirtualNode;
    PDPH_HEAP_BLOCK pAvailNode;
    PVOID  pVirtual;
    SIZE_T nVirtual;

    pVirtualNode = RtlpDebugPageHeapAllocateNode( pHeap );

    if (pVirtualNode == NULL) {
        return FALSE;
    }

    pAvailNode = RtlpDebugPageHeapAllocateNode( pHeap );

    if (pAvailNode == NULL) {
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pVirtualNode );
        return FALSE;
    }

    nSize    = ROUNDUP2( nSize, VM_UNIT_SIZE );
    nVirtual = ( nSize > RESERVE_SIZE ) ? nSize : RESERVE_SIZE;
    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

    if (( pVirtual == NULL ) && ( nSize < RESERVE_SIZE )) {
        nVirtual = nSize;
        pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );
    }

    if (pVirtual == NULL) {
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pVirtualNode );
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pAvailNode );
        return FALSE;
    }

    pVirtualNode->pVirtualBlock     = pVirtual;
    pVirtualNode->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapPlaceOnVirtualList( pHeap, pVirtualNode );

    pAvailNode->pVirtualBlock     = pVirtual;
    pAvailNode->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pAvailNode );

    return TRUE;
}

VOID
RtlpDebugPageHeapProtectStructures(
    IN PDPH_HEAP_ROOT pHeap
    )
{
#if 0
    
    PDPH_HEAP_BLOCK pNode;

    //
    //  Assume CritSect is owned so we're the only thread twiddling
    //  the protection.
    //

    DEBUG_ASSERT( pHeap->HeapFlags & HEAP_PROTECTION_ENABLED );

    if (--pHeap->nUnProtectionReferenceCount == 0) {

        pNode = pHeap->pNodePoolListHead;

        while (pNode != NULL) {

            RtlpDebugPageHeapProtectVM( pNode->pVirtualBlock,
                pNode->nVirtualBlockSize,
                PAGE_READONLY );

            pNode = pNode->pNextAlloc;

        }
    }

    //
    // Protect the main NT heap structure associated with page heap.
    // Nobody should touch this outside of page heap code paths.
    //
    
    RtlpDebugPageHeapProtectVM (pHeap->NormalHeap,
                                PAGE_SIZE,
                                PAGE_READONLY);
#endif
}


VOID
RtlpDebugPageHeapUnProtectStructures(
    IN PDPH_HEAP_ROOT pHeap
    )
{
#if 0
    
    PDPH_HEAP_BLOCK pNode;

    DEBUG_ASSERT( pHeap->HeapFlags & HEAP_PROTECTION_ENABLED );

    if (pHeap->nUnProtectionReferenceCount == 0) {

        pNode = pHeap->pNodePoolListHead;

        while (pNode != NULL) {

            RtlpDebugPageHeapProtectVM( pNode->pVirtualBlock,
                pNode->nVirtualBlockSize,
                PAGE_READWRITE );

            pNode = pNode->pNextAlloc;

        }
    }

    //
    // Unprotect the main NT heap structure associatied with page heap.
    //
    
    RtlpDebugPageHeapProtectVM (pHeap->NormalHeap,
                                PAGE_SIZE,
                                PAGE_READWRITE);

    pHeap->nUnProtectionReferenceCount += 1;

#endif
}


VOID
RtlpDphPreProcessing (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags
    )
{
    RtlpDebugPageHeapEnterCritSect (Heap, Flags);
    DEBUG_CODE (RtlpDebugPageHeapVerifyIntegrity (Heap));
    UNPROTECT_HEAP_STRUCTURES (Heap);

#if 0
    RtlpDphValidateInternalLists (Heap);
#endif
}


VOID
RtlpDphPostProcessing (
    PDPH_HEAP_ROOT Heap
    )
{
#if 0
    RtlpDphValidateInternalLists (Heap);
#endif

    PROTECT_HEAP_STRUCTURES (Heap);
    DEBUG_CODE (RtlpDebugPageHeapVerifyIntegrity (Heap));
    RtlpDebugPageHeapLeaveCritSect (Heap);
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// Exception management
/////////////////////////////////////////////////////////////////////

#define EXN_STACK_OVERFLOW   0
#define EXN_NO_MEMORY        1
#define EXN_ACCESS_VIOLATION 2
#define EXN_IGNORE_AV        3
#define EXN_OTHER            4

ULONG RtlpDphException[8];


ULONG
RtlpDphUnexpectedExceptionFilter (
    ULONG ExceptionCode,
    PVOID ExceptionRecord,
    PDPH_HEAP_ROOT Heap,
    BOOLEAN IgnoreAccessViolations
    )
/*++

Routine Description:

    This routine is the exception filter used by page heap operations. The role
    of the function is to bring the page heap in a consistent state (unlock
    heap lock, protect page heap metadata, etc.) if an exception has been raised.
    The exception can be raised for legitimate reasons (e.g. STATUS_NO_MEMORY 
    from HeapAlloc()) or because there is some sort of corruption. 
    
    Legitimate exceptions do not cause breaks but an unrecognized exception will 
    cause a break. The break is continuable at least with respect to page heap.


Arguments:

    ExceptionCode - exception code
    ExceptionRecord - structure with pointers to .exr and .cxr
    Heap - heap in which code was executing at the time of exception
    IgnoreAccessViolations - sometimes we want to ignore this (e.g. HeapSize).

Return Value:

    Always EXCEPTION_CONTINUE_SEARCH. The philosophy of this exception filter
    function is that if we get an exception we bring back page heap in a consistent
    state and then let the exception go to the next exception handler.


Environment:

    Called within page heap APIs if an exception is raised. 
--*/
{
    if (ExceptionCode == STATUS_NO_MEMORY) {

        //
        // Underlying NT heap functions can legitimately raise this
        // exception. 
        //


        InterlockedIncrement (&(RtlpDphException[EXN_NO_MEMORY]));
    }
    else if (Heap != NULL && ExceptionCode == STATUS_STACK_OVERFLOW) {

        //
        // We go to the next exception handler for stack overflows.
        //

        InterlockedIncrement (&(RtlpDphException[EXN_STACK_OVERFLOW]));
    }
    else if (ExceptionCode == STATUS_ACCESS_VIOLATION) {

        if (IgnoreAccessViolations == FALSE) {
            
            VERIFIER_STOP (APPLICATION_VERIFIER_UNEXPECTED_EXCEPTION,
                           "unexpected exception raised in heap code path",
                           Heap, "Heap handle involved",
                           ExceptionCode, "Exception code",
                           ExceptionRecord, "Exception record (.exr on 1st word, .cxr on 2nd word)",
                           0, "");
            
            InterlockedIncrement (&(RtlpDphException[EXN_ACCESS_VIOLATION]));
        }
        else {
            
            InterlockedIncrement (&(RtlpDphException[EXN_IGNORE_AV]));
        }
    }
    else {

        //
        // Any other exceptions will go to the next exception handler.
        //

        InterlockedIncrement (&(RtlpDphException[EXN_OTHER]));
    }

    RtlpDphPostProcessing (Heap);

    return EXCEPTION_CONTINUE_SEARCH;
}

#if DBG
#define ASSERT_UNEXPECTED_CODE_PATH() ASSERT(0 && "unexpected code path")
#else
#define ASSERT_UNEXPECTED_CODE_PATH()
#endif

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// Internal debug functions
/////////////////////////////////////////////////////////////////////

#if INTERNAL_DEBUG

VOID
RtlpDebugPageHeapVerifyList(
    IN PDPH_HEAP_BLOCK pListHead,
    IN PDPH_HEAP_BLOCK pListTail,
    IN SIZE_T               nExpectedLength,
    IN SIZE_T               nExpectedVirtual,
    IN PCCH                 pListName
    )
{
    PDPH_HEAP_BLOCK pPrev = NULL;
    PDPH_HEAP_BLOCK pNode = pListHead;
    PDPH_HEAP_BLOCK pTest = pListHead ? pListHead->pNextAlloc : NULL;
    ULONG                nNode = 0;
    SIZE_T               nSize = 0;

    while (pNode) {

        if (pNode == pTest) {
            DbgPrint( "Page heap: Internal %s list is circular\n", pListName );
            DbgBreakPoint ();
            return;
        }

        nNode += 1;
        nSize += pNode->nVirtualBlockSize;

        if (pTest) {
            pTest = pTest->pNextAlloc;
            if (pTest) {
                pTest = pTest->pNextAlloc;
            }
        }

        pPrev = pNode;
        pNode = pNode->pNextAlloc;

    }

    if (pPrev != pListTail) {
        DbgPrint( "Page heap: Internal %s list has incorrect tail pointer\n", pListName );
        DbgBreakPoint ();
    }

    if (( nExpectedLength != 0xFFFFFFFF ) && ( nExpectedLength != nNode )) {
        DbgPrint( "Page heap: Internal %s list has incorrect length\n", pListName );
        DbgBreakPoint ();
    }

    if (( nExpectedVirtual != 0xFFFFFFFF ) && ( nExpectedVirtual != nSize )) {
        DbgPrint( "Page heap: Internal %s list has incorrect virtual size\n", pListName );
        DbgBreakPoint ();
    }

}

VOID
RtlpDebugPageHeapVerifyIntegrity(
    IN PDPH_HEAP_ROOT pHeap
    )
{

    RtlpDebugPageHeapVerifyList(
        pHeap->pVirtualStorageListHead,
        pHeap->pVirtualStorageListTail,
        pHeap->nVirtualStorageRanges,
        pHeap->nVirtualStorageBytes,
        "VIRTUAL"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pBusyAllocationListHead,
        pHeap->pBusyAllocationListTail,
        pHeap->nBusyAllocations,
        pHeap->nBusyAllocationBytesCommitted,
        "BUSY"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pFreeAllocationListHead,
        pHeap->pFreeAllocationListTail,
        pHeap->nFreeAllocations,
        pHeap->nFreeAllocationBytesCommitted,
        "FREE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pAvailableAllocationListHead,
        pHeap->pAvailableAllocationListTail,
        pHeap->nAvailableAllocations,
        pHeap->nAvailableAllocationBytesCommitted,
        "AVAILABLE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pUnusedNodeListHead,
        pHeap->pUnusedNodeListTail,
        pHeap->nUnusedNodes,
        0xFFFFFFFF,
        "FREENODE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pNodePoolListHead,
        pHeap->pNodePoolListTail,
        pHeap->nNodePools,
        pHeap->nNodePoolBytes,
        "NODEPOOL"
        );
}

#endif // #if INTERNAL_DEBUG

/////////////////////////////////////////////////////////////////////
///////////////////////////// Exported page heap management functions
/////////////////////////////////////////////////////////////////////

//
//  Here's where the exported interface functions are defined.
//

#if (( DPH_CAPTURE_STACK_TRACE ) && ( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

PVOID
RtlpDebugPageHeapCreate(
    IN ULONG  Flags,
    IN PVOID  HeapBase    OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize  OPTIONAL,
    IN PVOID  Lock        OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )
{
    SYSTEM_BASIC_INFORMATION SystemInfo;
    PDPH_HEAP_BLOCK     Node;
    PDPH_HEAP_ROOT           HeapRoot;
    PVOID                    HeapHandle;
    PUCHAR                   pVirtual;
    SIZE_T                   nVirtual;
    SIZE_T                   Size;
    NTSTATUS                 Status;

    //
    // If `Parameters' is -1 then this is a recursive call to
    // RtlpDebugPageHeapCreate and we will return NULL so that
    // the normal heap manager will create a normal heap.
    // I agree this is a hack but we need this so that we maintain
    // a very loose dependency between the normal and page heap
    // manager.
    //

    if ((SIZE_T)Parameters == (SIZE_T)-1) {
        return NULL;
    }

    //
    //  We don't handle heaps where HeapBase is already allocated
    //  from user or where Lock is provided by user.
    //

    DEBUG_ASSERT( HeapBase == NULL );
    DEBUG_ASSERT( Lock == NULL );

    if (( HeapBase != NULL ) || ( Lock != NULL ))
        return NULL;

    //
    //  Note that we simply ignore ReserveSize, CommitSize, and
    //  Parameters as we always have a growable heap with our
    //  own thresholds, etc.
    //

    ZwQuerySystemInformation( SystemBasicInformation,
        &SystemInfo,
        sizeof( SystemInfo ),
        NULL );

    RETAIL_ASSERT( SystemInfo.PageSize == PAGE_SIZE );
    RETAIL_ASSERT( SystemInfo.AllocationGranularity == VM_UNIT_SIZE );
    DEBUG_ASSERT(( PAGE_SIZE + POOL_SIZE + PAGE_SIZE ) < VM_UNIT_SIZE );

    nVirtual = RESERVE_SIZE;
    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

    if (pVirtual == NULL) {

        nVirtual = VM_UNIT_SIZE;
        pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

        if (pVirtual == NULL) {

            OUT_OF_VM_BREAK( Flags, "Page heap: Insufficient memory to create heap\n" );
            IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
            return NULL;
        }
    }

    if (! RtlpDebugPageHeapProtectVM( pVirtual, PAGE_SIZE + POOL_SIZE + PAGE_SIZE, PAGE_READWRITE )) {

        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
    }

    //
    //  Out of our initial allocation, the initial page is the fake
    //  retail HEAP structure.  The second page begins our DPH_HEAP
    //  structure followed by (POOL_SIZE-sizeof(DPH_HEAP)) bytes for
    //  the initial pool.  The next page contains out CRIT_SECT
    //  variable, which must always be READWRITE.  Beyond that, the
    //  remainder of the virtual allocation is placed on the available
    //  list.
    //
    //  |_____|___________________|_____|__ _ _ _ _ _ _ _ _ _ _ _ _ __|
    //
    //  ^pVirtual
    //
    //  ^FakeRetailHEAP
    //
    //        ^HeapRoot
    //
    //            ^InitialNodePool
    //
    //                            ^CRITICAL_SECTION
    //
    //                                  ^AvailableSpace
    //
    //
    //
    //  Our DPH_HEAP structure starts at the page following the
    //  fake retail HEAP structure pointed to by the "heap handle".
    //  For the fake HEAP structure, we'll fill it with 0xEEEEEEEE
    //  except for the Heap->Flags and Heap->ForceFlags fields,
    //  which we must set to include our HEAP_FLAG_PAGE_ALLOCS flag,
    //  and then we'll make the whole page read-only.
    //

    RtlFillMemory( pVirtual, PAGE_SIZE, FILL_BYTE );

    ((PHEAP)pVirtual)->Flags      = Flags | HEAP_FLAG_PAGE_ALLOCS;
    ((PHEAP)pVirtual)->ForceFlags = Flags | HEAP_FLAG_PAGE_ALLOCS;

    if (! RtlpDebugPageHeapProtectVM( pVirtual, PAGE_SIZE, PAGE_READONLY )) {

        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
    }

    HeapRoot = (PDPH_HEAP_ROOT)( pVirtual + PAGE_SIZE );

    HeapRoot->Signature    = DPH_HEAP_SIGNATURE;
    HeapRoot->HeapFlags    = Flags;
    HeapRoot->HeapCritSect = (PVOID)((PCHAR)HeapRoot + POOL_SIZE );

    //
    // Copy the page heap global flags into per heap flags.
    //

    HeapRoot->ExtraFlags = RtlpDphGlobalFlags;

    //
    // If page heap meta data protection was requested we transfer
    // the bit into the HeapFlags field.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_PROTECT_META_DATA)) {
        HeapRoot->HeapFlags |= HEAP_PROTECTION_ENABLED;
    }

    //
    // If the PAGE_HEAP_UNALIGNED_ALLOCATIONS bit is set
    // in ExtraFlags we will set the HEAP_NO_ALIGNMENT flag
    // in the HeapFlags. This last bit controls if allocations
    // will be aligned or not. The reason we do this transfer is
    // that ExtraFlags can be set from the registry whereas the
    // normal HeapFlags cannot.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_UNALIGNED_ALLOCATIONS)) {
        HeapRoot->HeapFlags |= HEAP_NO_ALIGNMENT;
    }

    //
    // Initialize the seed for the random generator used to decide
    // from where should we make allocations if random decision
    // flag is on.
    //

    {
        LARGE_INTEGER PerformanceCounter;

        PerformanceCounter.LowPart = 0xABCDDCBA;

        NtQueryPerformanceCounter (
            &PerformanceCounter,
            NULL);

        HeapRoot->Seed = PerformanceCounter.LowPart;
    }

    //
    // Create the normal heap associated with the page heap.
    // The last parameter value (-1) is very important because
    // it stops the recursive call into page heap create.
    //
    // Note that it is very important to reset the NO_SERIALIZE
    // bit because normal heap operations can happen in random
    // threads when the free delayed cache gets trimmed.
    //

    HeapRoot->NormalHeap = RtlCreateHeap (
        Flags & (~HEAP_NO_SERIALIZE),
        HeapBase,
        ReserveSize,
        CommitSize,
        Lock,
        (PRTL_HEAP_PARAMETERS)-1 );

    if (HeapRoot->NormalHeap == NULL) {

        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
    }

    //
    // Initialize heap lock.
    //

    RtlInitializeCriticalSection( HeapRoot->HeapCritSect );

    //
    //  On the page that contains our DPH_HEAP structure, use
    //  the remaining memory beyond the DPH_HEAP structure as
    //  pool for allocating heap nodes.
    //

    RtlpDebugPageHeapAddNewPool( HeapRoot,
        HeapRoot + 1,
        POOL_SIZE - sizeof( DPH_HEAP_ROOT ),
        FALSE
        );

    //
    //  Make initial PoolList entry by taking a node from the
    //  UnusedNodeList, which should be guaranteed to be non-empty
    //  since we just added new nodes to it.
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = (PVOID)HeapRoot;
    Node->nVirtualBlockSize = POOL_SIZE;
    RtlpDebugPageHeapPlaceOnPoolList( HeapRoot, Node );

    //
    //  Make VirtualStorageList entry for initial VM allocation
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = pVirtual;
    Node->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapPlaceOnVirtualList( HeapRoot, Node );

    //
    //  Make AvailableList entry containing remainder of initial VM
    //  and add to (create) the AvailableList.
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = pVirtual + ( PAGE_SIZE + POOL_SIZE + PAGE_SIZE );
    Node->nVirtualBlockSize = nVirtual - ( PAGE_SIZE + POOL_SIZE + PAGE_SIZE );
    RtlpDebugPageHeapCoalesceNodeIntoAvailable( HeapRoot, Node );

    //
    // Get heap creation stack trace.
    //

    HeapRoot->CreateStackTrace = RtlpDphLogStackTrace(1);

    //
    //  Initialize heap internal structure protection.
    //

    HeapRoot->nUnProtectionReferenceCount = 1;          // initialize

    //
    //  If this is the first heap creation in this process, then we
    //  need to initialize the process heap list critical section,
    // the global delayed free queue for normal blocks and the
    // trace database.
    //

    if (! RtlpDphHeapListHasBeenInitialized) {

        RtlpDphHeapListHasBeenInitialized = TRUE;

        RtlInitializeCriticalSection( &RtlpDphHeapListCriticalSection );
        RtlpDphInitializeDelayedFreeQueue ();

        //
        // Do not make fuss if the trace database creation fails.
        // This is something we can live with.
        //
        // The number of buckets is chosen to be a prime not too
        // close to a power of two (Knuth says so). Three possible
        // values are: 1567, 3089, 6263.
        //

        RtlpDphTraceDatabase = RtlTraceDatabaseCreate (
            6263,
            RtlpDphTraceDatabaseMaximumSize,
            0,
            0,
            NULL);

#if DBG
        if (RtlpDphTraceDatabase == NULL) {
            DbgPrint ("Page heap: warning: failed to create trace database for %p",
                HeapRoot);
        }
#endif
        //
        // Create the Unicode string containing the target dlls.
        // If no target dlls have been specified the string will
        // be initialized with the empty string.
        //

        RtlInitUnicodeString (
            &RtlpDphTargetDllsUnicode,
            RtlpDphTargetDlls);

        //
        // Initialize the target dlls logic
        //

        RtlpDphTargetDllsLogicInitialize ();
    }

    //
    //  Add this heap entry to the process heap linked list.
    //

    RtlEnterCriticalSection( &RtlpDphHeapListCriticalSection );

    if (RtlpDphHeapListHead == NULL) {
        RtlpDphHeapListHead = HeapRoot;
        RtlpDphHeapListTail = HeapRoot;
    }
    else {
        HeapRoot->pPrevHeapRoot = RtlpDphHeapListTail;
        UNPROTECT_HEAP_STRUCTURES(RtlpDphHeapListTail);
        RtlpDphHeapListTail->pNextHeapRoot = HeapRoot;
        PROTECT_HEAP_STRUCTURES(RtlpDphHeapListTail);
        RtlpDphHeapListTail                = HeapRoot;
    }

    PROTECT_HEAP_STRUCTURES( HeapRoot );                // now protected

    RtlpDphHeapListCount += 1;

    RtlLeaveCriticalSection( &RtlpDphHeapListCriticalSection );

    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));

#if 0 // ISSUE: SilviuC: use DbgPrintEx instead.
    DbgPrint( "Page heap: process 0x%X created heap @ %p (%p, flags 0x%X)\n",
        NtCurrentTeb()->ClientId.UniqueProcess,
        HEAP_HANDLE_FROM_ROOT( HeapRoot ),
        HeapRoot->NormalHeap,
        HeapRoot->ExtraFlags);
#endif

    if ((RtlpDphDebugLevel & DPH_DEBUG_INTERNAL_VALIDATION)) {
        RtlpDphInternalValidatePageHeap (HeapRoot, NULL, 0);
    }

    return HEAP_HANDLE_FROM_ROOT( HeapRoot );       // same as pVirtual

}

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN SIZE_T Size
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK pAvailNode;
    PDPH_HEAP_BLOCK pPrevAvailNode;
    PDPH_HEAP_BLOCK pBusyNode;
    SIZE_T               nBytesAllocate;
    SIZE_T               nBytesAccess;
    SIZE_T               nActual;
    PVOID                pVirtual;
    PVOID                pReturn;
    PUCHAR               pBlockHeader;
    ULONG Reason;
    BOOLEAN ForcePageHeap = FALSE;

    //
    // Reject extreme size requests.
    //

#if defined(_IA64_)
    if (Size > 0x8000000000000000) {
#else
    if (Size > 0x80000000) {
#endif

        VERIFIER_STOP (APPLICATION_VERIFIER_EXTREME_SIZE_REQUEST,
                       "extreme size request",
                       HeapHandle, "Heap handle", 
                       Size, "Size requested", 
                       0, "", 
                       0, "");
        return NULL;
    }

    //
    // Check if it is time to do fault injection.
    //

    if (RtlpDphShouldFaultInject ()) {
        return NULL;
    }

    //
    // Check if we have a biased heap pointer which signals
    // a forced page heap allocation (no normal heap).
    //

    if (IS_BIASED_POINTER(HeapHandle)) {
        HeapHandle = UNBIAS_POINTER(HeapHandle);
        ForcePageHeap = TRUE;
    }

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL)
        return NULL;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);

    try {

        //
        // We cannot validate the heap when a forced allocation into page heap
        // is requested due to accounting problems. Allocate is called in this way
        // from ReAllocate while the old node (just about to be freed) is in limbo
        // and is not accounted in any internal structure.
        //

        if ((RtlpDphDebugLevel & DPH_DEBUG_INTERNAL_VALIDATION) && !ForcePageHeap) {
            RtlpDphInternalValidatePageHeap (HeapRoot, NULL, 0);
        }

        Flags |= HeapRoot->HeapFlags;

        //
        // Figure out if we need to minimize memory impact. This
        // might trigger an allocation in the normal heap.
        //

        if (! ForcePageHeap) {

            if (! (RtlpDphShouldAllocateInPageHeap (HeapRoot, Size))) {

                pReturn = RtlpDphNormalHeapAllocate (
                    HeapRoot,
                    Flags,
                    Size);

                goto EXIT;
            }
        }

        //
        // Check the heap a little bit on checked builds.
        //

        DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));

        pReturn = NULL;

        //
        //  Validate requested size so we don't overflow
        //  while rounding up size computations.  We do this
        //  after we've acquired the critsect so we can still
        //  catch serialization problems.
        //

        if (Size > 0x7FFF0000) {
            OUT_OF_VM_BREAK( Flags, "Page heap: Invalid allocation size\n" );
            goto EXIT;
        }

        //
        //  Determine number of pages needed for READWRITE portion
        //  of allocation and add an extra page for the NO_ACCESS
        //  memory beyond the READWRITE page(s).
        //

        nBytesAccess  = ROUNDUP2( Size + sizeof(DPH_BLOCK_INFORMATION), PAGE_SIZE );
        nBytesAllocate = nBytesAccess + PAGE_SIZE;

        //
        //  RtlpDebugPageHeapFindAvailableMem will first attempt to satisfy
        //  the request from memory on the Available list.  If that fails,
        //  it will coalesce some of the Free list memory into the Available
        //  list and try again.  If that still fails, new VM is allocated and
        //  added to the Available list.  If that fails, the function will
        //  finally give up and return NULL.
        //

        pAvailNode = RtlpDebugPageHeapFindAvailableMem(
            HeapRoot,
            nBytesAllocate,
            &pPrevAvailNode,
            TRUE
            );

        if (pAvailNode == NULL) {
            OUT_OF_VM_BREAK( Flags, "Page heap: Unable to allocate virtual memory\n" );
            goto EXIT;
        }

        //
        //  Now can't call AllocateNode until pAvailNode is
        //  adjusted and/or removed from Avail list since AllocateNode
        //  might adjust the Avail list.
        //

        pVirtual = pAvailNode->pVirtualBlock;

        if (nBytesAccess > 0) {

            if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

                if (! RtlpDebugPageHeapProtectVM( (PUCHAR)pVirtual + PAGE_SIZE, nBytesAccess, PAGE_READWRITE )) {
                    goto EXIT;
                }
            }
            else {

                if (! RtlpDebugPageHeapProtectVM( pVirtual, nBytesAccess, PAGE_READWRITE )) {
                    goto EXIT;
                }
            }
        }

        //
        // If we use uncommitted ranges we need to decommit the protection
        // page at the end. BAckward overruns flag disables smart memory
        // usage flag.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            // nothing

        }
        else {

            if ((HeapRoot->ExtraFlags & PAGE_HEAP_SMART_MEMORY_USAGE)) {

                RtlpDebugPageHeapDecommitVM (
                    (PCHAR)pVirtual + nBytesAccess,
                    PAGE_SIZE);
            }
        }

        //
        //  pAvailNode (still on avail list) points to block large enough
        //  to satisfy request, but it might be large enough to split
        //  into two blocks -- one for request, remainder leave on
        //  avail list.
        //

        if (pAvailNode->nVirtualBlockSize > nBytesAllocate) {

            //
            //  Adjust pVirtualBlock and nVirtualBlock size of existing
            //  node in avail list.  The node will still be in correct
            //  address space order on the avail list.  This saves having
            //  to remove and then re-add node to avail list.  Note since
            //  we're changing sizes directly, we need to adjust the
            //  avail and busy list counters manually.
            //
            //  Note: since we're leaving at least one page on the
            //  available list, we are guaranteed that AllocateNode
            //  will not fail.
            //

            pAvailNode->pVirtualBlock                    += nBytesAllocate;
            pAvailNode->nVirtualBlockSize                -= nBytesAllocate;
            HeapRoot->nAvailableAllocationBytesCommitted -= nBytesAllocate;

            pBusyNode = RtlpDebugPageHeapAllocateNode( HeapRoot );

            DEBUG_ASSERT( pBusyNode != NULL );

            pBusyNode->pVirtualBlock     = pVirtual;
            pBusyNode->nVirtualBlockSize = nBytesAllocate;

        }

        else {

            //
            //  Entire avail block is needed, so simply remove it from avail list.
            //

            RtlpDebugPageHeapRemoveFromAvailableList( HeapRoot, pAvailNode, pPrevAvailNode );

            pBusyNode = pAvailNode;

        }

        //
        //  Now pBusyNode points to our committed virtual block.
        //

        if (HeapRoot->HeapFlags & HEAP_NO_ALIGNMENT)
            nActual = Size;
        else
            nActual = ROUNDUP2( Size, USER_ALIGNMENT );

        pBusyNode->nVirtualAccessSize = nBytesAccess;
        pBusyNode->nUserRequestedSize = Size;
        pBusyNode->nUserActualSize    = nActual;

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            pBusyNode->pUserAllocation    = pBusyNode->pVirtualBlock
                + PAGE_SIZE;
        }
        else {

            pBusyNode->pUserAllocation    = pBusyNode->pVirtualBlock
                + pBusyNode->nVirtualAccessSize
                - nActual;
        }

        pBusyNode->UserValue          = NULL;
        pBusyNode->UserFlags          = Flags & HEAP_SETTABLE_USER_FLAGS;

        //
        //  RtlpDebugPageHeapAllocate gets called from RtlDebugAllocateHeap,
        //  which gets called from RtlAllocateHeapSlowly, which gets called
        //  from RtlAllocateHeap.  To keep from wasting lots of stack trace
        //  storage, we'll skip the bottom 3 entries, leaving RtlAllocateHeap
        //  as the first recorded entry.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {

            pBusyNode->StackTrace = RtlpDphLogStackTrace(3);

            if (pBusyNode->StackTrace) {

                RtlTraceDatabaseLock (RtlpDphTraceDatabase);
                pBusyNode->StackTrace->UserCount += 1;
                pBusyNode->StackTrace->UserSize += pBusyNode->nUserRequestedSize;
                pBusyNode->StackTrace->UserContext = HeapRoot;
                RtlTraceDatabaseUnlock (RtlpDphTraceDatabase);
            }
        }
        else {
            pBusyNode->StackTrace = NULL;
        }

        RtlpDebugPageHeapPlaceOnBusyList( HeapRoot, pBusyNode );

        pReturn = pBusyNode->pUserAllocation;

        //
        //  For requests the specify HEAP_ZERO_MEMORY, we'll fill the
        //  user-requested portion of the block with zeros. For requests
        //  that don't specify HEAP_ZERO_MEMORY, we fill the whole user block
        //  with DPH_PAGE_BLOCK_INFIX.
        //

        if ((Flags & HEAP_ZERO_MEMORY)) {


            RtlZeroMemory( pBusyNode->pUserAllocation, Size );
        }
        else {

            RtlFillMemory( pBusyNode->pUserAllocation, Size, DPH_PAGE_BLOCK_INFIX);
        }

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            // nothing

        }
        else {

            RtlpDphWritePageHeapBlockInformation (
                HeapRoot,
                pBusyNode->pUserAllocation,
                Size,
                nBytesAccess);
        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);

    if (pReturn == NULL) {
        IF_GENERATE_EXCEPTION (Flags, STATUS_NO_MEMORY);
    }

    return pReturn;
}


BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
{

    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK Node, Prev;
    BOOLEAN              Success;
    PCH                  p;
    ULONG Reason;

    //
    // Skip over null frees. These are valid in C++.
    //

    if (Address == NULL) {

        return TRUE;
    }

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL)
        return FALSE;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        if ((RtlpDphDebugLevel & DPH_DEBUG_INTERNAL_VALIDATION)) {
            RtlpDphInternalValidatePageHeap (HeapRoot, NULL, 0);
        }

        Flags |= HeapRoot->HeapFlags;

        Success = FALSE;

        Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, &Prev );

        if (Node == NULL) {

            //
            // No wonder we did not find the block in the page heap
            // structures because the block was probably allocated
            // from the normal heap. Or there is a real bug.
            // If there is a bug NormalHeapFree will break into debugger.
            //

            Success = RtlpDphNormalHeapFree (

                HeapRoot,
                Flags,
                Address);

            goto EXIT;
        }

        //
        // Check if there are any orphan critical sections in the block to be freed.
        //

        RtlpCheckForCriticalSectionsInMemoryRange (Address, 
                                                   Node->nUserRequestedSize,
                                                   NULL);

        //
        //  If tail was allocated, make sure filler not overwritten
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            if (Node->nVirtualAccessSize > 0) {
                RtlpDebugPageHeapProtectVM( Node->pVirtualBlock + PAGE_SIZE,
                    Node->nVirtualAccessSize,
                    PAGE_NOACCESS );
            }
        }
        else {

            if (! (RtlpDphIsPageHeapBlock (HeapRoot, Address, &Reason, TRUE))) {

                RtlpDphReportCorruptedBlock (HeapRoot,
                                             DPH_CONTEXT_FULL_PAGE_HEAP_FREE,
                                             Address, 
                                             Reason);
            }

            if (Node->nVirtualAccessSize > 0) {

                //
                // Mark the block as freed. The information is gone if we
                // will decommit the region but will remain if smart memory
                // flag is not set and can help debug failures.
                //

                {
                    PDPH_BLOCK_INFORMATION Info = (PDPH_BLOCK_INFORMATION)(Node->pUserAllocation);

                    Info -= 1;
                    Info->StartStamp -= 1;
                    Info->EndStamp -= 1;
                }

                RtlpDebugPageHeapProtectVM( Node->pVirtualBlock,
                    Node->nVirtualAccessSize,
                    PAGE_NOACCESS );
            }
        }

        RtlpDebugPageHeapRemoveFromBusyList( HeapRoot, Node, Prev );

        //
        // If we use uncommitted ranges we need to decommit the memory
        // range now for the allocation. Note that the next page (guard)
        // was already decommitted when we allocated the block.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            // nothing

        }
        else {

            if ((HeapRoot->ExtraFlags & PAGE_HEAP_SMART_MEMORY_USAGE)) {

                RtlpDebugPageHeapDecommitVM (
                    Node->pVirtualBlock,
                    Node->nVirtualAccessSize);
            }
        }


        RtlpDebugPageHeapPlaceOnFreeList( HeapRoot, Node );

        //
        //  RtlpDebugPageHeapFree gets called from RtlDebugFreeHeap, which
        //  gets called from RtlFreeHeapSlowly, which gets called from
        //  RtlFreeHeap.  To keep from wasting lots of stack trace storage,
        //  we'll skip the bottom 3 entries, leaving RtlFreeHeap as the
        //  first recorded entry.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {

            if (Node->StackTrace) {

                RtlTraceDatabaseLock (RtlpDphTraceDatabase);

                if (Node->StackTrace->UserCount > 0) {
                    Node->StackTrace->UserCount -= 1;
                }

                if (Node->StackTrace->UserSize >= Node->nUserRequestedSize) {
                    Node->StackTrace->UserSize -= Node->nUserRequestedSize;
                }

                RtlTraceDatabaseUnlock (RtlpDphTraceDatabase);
            }

            Node->StackTrace = RtlpDphLogStackTrace(3);
        }
        else {
            Node->StackTrace = NULL;
        }

        Success = TRUE;
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    if (! Success) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_ACCESS_VIOLATION );
    }

    return Success;
}

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID  Address,
    IN SIZE_T Size
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK OldNode, OldPrev, NewNode;
    PVOID                NewAddress;
    PUCHAR               p;
    SIZE_T               CopyDataSize;
    ULONG                SaveFlags;
    BOOLEAN ReallocInNormalHeap = FALSE;
    ULONG Reason;
    BOOLEAN ForcePageHeap = FALSE;
    BOOLEAN OriginalAllocationInPageHeap = FALSE;

    //
    // Reject extreme size requests.
    //

#if defined(_IA64_)
    if (Size > 0x8000000000000000) {
#else
    if (Size > 0x80000000) {
#endif

        VERIFIER_STOP (APPLICATION_VERIFIER_EXTREME_SIZE_REQUEST,
                       "extreme size request",
                       HeapHandle, "Heap handle", 
                       Size, "Size requested", 
                       0, "",
                       0, "");
        return NULL;
    }

    //
    // Check if it is time to do fault injection.
    //

    if (RtlpDphShouldFaultInject ()) {
        return NULL;
    }

    //
    // Check if we have a biased heap pointer which signals
    // a forced page heap allocation (no normal heap).
    //

    if (IS_BIASED_POINTER(HeapHandle)) {
        HeapHandle = UNBIAS_POINTER(HeapHandle);
        ForcePageHeap = TRUE;
    }

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL)
        return NULL;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        if ((RtlpDphDebugLevel & DPH_DEBUG_INTERNAL_VALIDATION)) {
            RtlpDphInternalValidatePageHeap (HeapRoot, NULL, 0);
        }

        Flags |= HeapRoot->HeapFlags;

        NewAddress = NULL;

        //
        //  Check Flags for non-moveable reallocation and fail it
        //  unconditionally.  Apps that specify this flag should be
        //  prepared to deal with failure anyway.
        //

        if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {
            goto EXIT;
        }

        //
        //  Validate requested size so we don't overflow
        //  while rounding up size computations.  We do this
        //  after we've acquired the critsect so we can still
        //  catch serialization problems.
        //

        if (Size > 0x7FFF0000) {
            OUT_OF_VM_BREAK( Flags, "Page heap: Invalid allocation size\n" );
            goto EXIT;
        }

        OldNode = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, &OldPrev );

        if (OldNode) {
            OriginalAllocationInPageHeap = TRUE;
        }

        if (OldNode == NULL) {

            //
            // No wonder we did not find the block in the page heap
            // structures because the block was probably allocated
            // from the normal heap. Or there is a real bug. If there
            // is a bug NormalHeapReAllocate will break into debugger.
            //

            NewAddress = RtlpDphNormalHeapReAllocate (

                HeapRoot,
                Flags,
                Address,
                Size);

            goto EXIT;
        }

        //
        //  If tail was allocated, make sure filler not overwritten
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            // nothing
        }
        else {

            if (! (RtlpDphIsPageHeapBlock (HeapRoot, Address, &Reason, TRUE))) {

                RtlpDphReportCorruptedBlock (HeapRoot,
                                             DPH_CONTEXT_FULL_PAGE_HEAP_REALLOC,
                                             Address, 
                                             Reason);
            }
        }

        //
        //  Before allocating a new block, remove the old block from
        //  the busy list.  When we allocate the new block, the busy
        //  list pointers will change, possibly leaving our acquired
        //  Prev pointer invalid.
        //

        RtlpDebugPageHeapRemoveFromBusyList( HeapRoot, OldNode, OldPrev );

        //
        //  Allocate new memory for new requested size.  Use try/except
        //  to trap exception if Flags caused out-of-memory exception.
        //

        try {

            if (!ForcePageHeap && !(RtlpDphShouldAllocateInPageHeap (HeapRoot, Size))) {

                NewAddress = RtlpDphNormalHeapAllocate (
                    HeapRoot,
                    Flags,
                    Size);

                ReallocInNormalHeap = TRUE;
            }
            else {

                //
                // Force the allocation in page heap by biasing
                // the heap handle. Validate the heap here since when we use
                // biased pointers validation inside Allocate is disabled.
                //

                if ((RtlpDphDebugLevel & DPH_DEBUG_INTERNAL_VALIDATION)) {
                    RtlpDphInternalValidatePageHeap (HeapRoot, OldNode->pVirtualBlock, OldNode->nVirtualBlockSize);
                }

                NewAddress = RtlpDebugPageHeapAllocate(
                    BIAS_POINTER(HeapHandle),
                    Flags,
                    Size);

                //
                // When we get back from the page heap call we will get
                // back read only meta data that we need to make read write.
                //

                UNPROTECT_HEAP_STRUCTURES( HeapRoot );

                if ((RtlpDphDebugLevel & DPH_DEBUG_INTERNAL_VALIDATION)) {
                    RtlpDphInternalValidatePageHeap (HeapRoot, OldNode->pVirtualBlock, OldNode->nVirtualBlockSize);
                }

                ReallocInNormalHeap = FALSE;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER ) {
        }

        //
        // We managed to make a new allocation (normal or page heap).
        // Now we need to copy from old to new all sorts of stuff
        // (contents, user flags/values).
        //

        if (NewAddress) {

            //
            // Copy old block contents into the new node.
            //

            CopyDataSize = OldNode->nUserRequestedSize;

            if (CopyDataSize > Size) {
                CopyDataSize = Size;
            }

            if (CopyDataSize > 0) {

                RtlCopyMemory(
                    NewAddress,
                    Address,
                    CopyDataSize
                    );
            }

            //
            // If new allocation was done in page heap we need to detect the new node
            // and copy over user flags/values.
            //

            if (! ReallocInNormalHeap) {

                NewNode = RtlpDebugPageHeapFindBusyMem( HeapRoot, NewAddress, NULL );

                //
                // This block could not be in normal heap therefore from this
                // respect the call above should always succeed.
                //

                DEBUG_ASSERT( NewNode != NULL );

                NewNode->UserValue = OldNode->UserValue;
                NewNode->UserFlags = ( Flags & HEAP_SETTABLE_USER_FLAGS ) ?
                    ( Flags & HEAP_SETTABLE_USER_FLAGS ) :
                OldNode->UserFlags;

            }

            //
            // We need to cover the case where old allocation was in page heap.
            // In this case we still need to cleanup the old node and
            // insert it back in free list. Actually the way the code is written
            // we take this code path only if original allocation was in page heap.
            // This is the reason for the assert.
            //


            RETAIL_ASSERT (OriginalAllocationInPageHeap);

            if (OriginalAllocationInPageHeap) {

                if (OldNode->nVirtualAccessSize > 0) {
                    RtlpDebugPageHeapProtectVM( OldNode->pVirtualBlock,
                        OldNode->nVirtualAccessSize,
                        PAGE_NOACCESS );
                }

                //
                // If we use uncommitted ranges we need to decommit the memory
                // range now. Note that the next page (guard) was already decommitted
                // when we made the allocation.
                //

                if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

                    // nothing

                }
                else {

                    if ((HeapRoot->ExtraFlags & PAGE_HEAP_SMART_MEMORY_USAGE)) {

                        RtlpDebugPageHeapDecommitVM (
                            OldNode->pVirtualBlock,
                            OldNode->nVirtualAccessSize);
                    }
                }

                RtlpDebugPageHeapPlaceOnFreeList( HeapRoot, OldNode );

                //
                // RtlpDebugPageHeapReAllocate gets called from RtlDebugReAllocateHeap,
                // which gets called from RtlReAllocateHeap.  To keep from wasting
                // lots of stack trace storage, we'll skip the bottom 2 entries,
                // leaving RtlReAllocateHeap as the first recorded entry in the
                // freed stack trace.
                //
                // Note. For realloc we need to do the accounting for free in the
                // trace block. The accounting for alloc is done in the real
                // alloc operation which always happens for page heap reallocs.
                //

                if ((HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {

                    if (OldNode->StackTrace) {

                        RtlTraceDatabaseLock (RtlpDphTraceDatabase);

                        if (OldNode->StackTrace->UserCount > 0) {
                            OldNode->StackTrace->UserCount -= 1;
                        }

                        if (OldNode->StackTrace->UserSize >= OldNode->nUserRequestedSize) {
                            OldNode->StackTrace->UserSize -= OldNode->nUserRequestedSize;
                        }

                        RtlTraceDatabaseUnlock (RtlpDphTraceDatabase);
                    }

                    OldNode->StackTrace = RtlpDphLogStackTrace(2);
                }
                else {
                    OldNode->StackTrace = NULL;
                }
            }
        }

        else {

            //
            //  Failed to allocate a new block.  Return old block to busy list.
            //

            if (OriginalAllocationInPageHeap) {

                RtlpDebugPageHeapPlaceOnBusyList( HeapRoot, OldNode );
            }

        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    if (NewAddress == NULL) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
    }

    return NewAddress;
}

#if (( DPH_CAPTURE_STACK_TRACE ) && ( i386 ) && ( FPO ))
#pragma optimize( "", on )      // restore original optimizations
#endif

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ROOT       PrevHeapRoot;
    PDPH_HEAP_ROOT       NextHeapRoot;
    PDPH_HEAP_BLOCK Node;
    PDPH_HEAP_BLOCK Next;
    ULONG                Flags;
    PUCHAR               p;
    ULONG Reason;
    PVOID NormalHeap;

    if (HeapHandle == RtlProcessHeap()) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_DESTROY_PROCESS_HEAP,
                       "attempt to destroy process heap", 
                       HeapHandle, "Process heap handle", 
                       0, "", 0, "", 0, "");
        
        return NULL;
    }

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL)
        return NULL;

    // silviuc: should find another way to detect destroy while using
    // Flags = HeapRoot->HeapFlags | HEAP_NO_SERIALIZE;
    Flags = HeapRoot->HeapFlags;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        //
        // Save normal heap pointer for later.
        //

        NormalHeap = HeapRoot->NormalHeap;

        //
        // Free all blocks in the delayed free queue that belong to the
        // normal heap just about to be destroyed. Note that this is
        // not a bug. The application freed the blocks correctly but
        // we delayed the free operation.
        //

        RtlpDphFreeDelayedBlocksFromHeap (HeapRoot, NormalHeap);

        //
        //  Walk all busy allocations and check for tail fill corruption
        //

        Node = HeapRoot->pBusyAllocationListHead;

        while (Node) {

            if (! (HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

                if (! (RtlpDphIsPageHeapBlock (HeapRoot, Node->pUserAllocation, &Reason, TRUE))) {

                    RtlpDphReportCorruptedBlock (HeapRoot,
                                                 DPH_CONTEXT_FULL_PAGE_HEAP_DESTROY,
                                                 Node->pUserAllocation, 
                                                 Reason);
                }
            }

            //
            // Check if this active block contains a critical section. Since the
            // block will be freed this will leak a critical section. Unfortunately
            // we cannot do the same check for light page heap blocks due to the
            // loose interaction between page heap and NT heap (we want to keep it
            // this way to avoid compatibility issues).
            //

            RtlpCheckForCriticalSectionsInMemoryRange (Node->pUserAllocation, 
                                                       Node->nUserRequestedSize,
                                                       NULL);
            
            //
            // Move to next node.
            //

            Node = Node->pNextAlloc;
        }

        //
        //  Remove this heap entry from the process heap linked list.
        //

        RtlEnterCriticalSection( &RtlpDphHeapListCriticalSection );

        if (HeapRoot->pPrevHeapRoot) {
            UNPROTECT_HEAP_STRUCTURES( HeapRoot->pPrevHeapRoot );
            HeapRoot->pPrevHeapRoot->pNextHeapRoot = HeapRoot->pNextHeapRoot;
            PROTECT_HEAP_STRUCTURES( HeapRoot->pPrevHeapRoot );
        }
        else {
            RtlpDphHeapListHead = HeapRoot->pNextHeapRoot;
        }

        if (HeapRoot->pNextHeapRoot) {
            UNPROTECT_HEAP_STRUCTURES( HeapRoot->pNextHeapRoot );
            HeapRoot->pNextHeapRoot->pPrevHeapRoot = HeapRoot->pPrevHeapRoot;
            PROTECT_HEAP_STRUCTURES( HeapRoot->pNextHeapRoot );
        }
        else {
            RtlpDphHeapListTail = HeapRoot->pPrevHeapRoot;
        }

        RtlpDphHeapListCount -= 1;

        RtlLeaveCriticalSection( &RtlpDphHeapListCriticalSection );


        //
        //  Must release critical section before deleting it; otherwise,
        //  checked build Teb->CountOfOwnedCriticalSections gets out of sync.
        //

        RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
        RtlDeleteCriticalSection( HeapRoot->HeapCritSect );

        //
        //  This is weird.  A virtual block might contain storage for
        //  one of the nodes necessary to walk this list.  In fact,
        //  we're guaranteed that the root node contains at least one
        //  virtual alloc node.
        //
        //  Each time we alloc new VM, we make that the head of the
        //  of the VM list, like a LIFO structure.  I think we're ok
        //  because no VM list node should be on a subsequently alloc'd
        //  VM -- only a VM list entry might be on its own memory (as
        //  is the case for the root node).  We read pNode->pNextAlloc
        //  before releasing the VM in case pNode existed on that VM.
        //  I think this is safe -- as long as the VM list is LIFO and
        //  we don't do any list reorganization.
        //

        Node = HeapRoot->pVirtualStorageListHead;

        while (Node) {
            Next = Node->pNextAlloc;
            if (! RtlpDebugPageHeapReleaseVM( Node->pVirtualBlock )) {

                VERIFIER_STOP (APPLICATION_VERIFIER_INTERNAL_ERROR,
                               "unable to release virtual memory",
                               0, "", 0, "", 0, "", 0, "");
            }
            
            Node = Next;
        }

        //
        // Destroy normal heap. Note that this will not make a recursive
        // call into this function because this is not a page heap and
        // code in NT heap manager will detect this.
        //

        RtlDestroyHeap (NormalHeap);

    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              NULL,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    //
    //  That's it.  All the VM, including the root node, should now
    //  be released.  RtlDestroyHeap always returns NULL.
    //

#if 0 // ISSUE: SilviuC: use DbgPrintEx instead.
    DbgPrint( "Page heap: process 0x%X destroyed heap @ %p (%p)\n",
              HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
              HeapRoot,
              NormalHeap);
#endif

    return NULL;
}

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK Node;
    SIZE_T               Size;

    Size = -1;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL) {
        return Size;
    }

    Flags |= HeapRoot->HeapFlags;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

        if (Node == NULL) {

            //
            // No wonder we did not find the block in the page heap
            // structures because the block was probably allocated
            // from the normal heap. Or there is a real bug. If there
            // is a bug NormalHeapSize will break into debugger.
            //

            Size = RtlpDphNormalHeapSize (

                HeapRoot,
                Flags,
                Address);

            goto EXIT;
        }
        else {
            Size = Node->nUserRequestedSize;
        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              TRUE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:
        
    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    if (Size == -1) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_ACCESS_VIOLATION );
    }

    return Size;
}

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    )
{
    PDPH_HEAP_ROOT HeapRoot;
    ULONG          Count;

    //
    //  Although we'd expect GetProcessHeaps never to be called
    //  before at least the very first heap creation, we should
    //  still be safe and initialize the critical section if
    //  necessary.
    //

    if (! RtlpDphHeapListHasBeenInitialized) {
        RtlpDphHeapListHasBeenInitialized = TRUE;
        RtlInitializeCriticalSection( &RtlpDphHeapListCriticalSection );
    }

    RtlEnterCriticalSection( &RtlpDphHeapListCriticalSection );

    if (RtlpDphHeapListCount <= NumberOfHeaps) {

        for (HeapRoot  = RtlpDphHeapListHead, Count = 0;
            HeapRoot != NULL;
            HeapRoot  = HeapRoot->pNextHeapRoot, Count += 1) {

            *ProcessHeaps++ = HEAP_HANDLE_FROM_ROOT( HeapRoot );
        }

        if (Count != RtlpDphHeapListCount) {

            VERIFIER_STOP (APPLICATION_VERIFIER_UNKNOWN_ERROR,
                           "process heap list count is wrong",
                           Count, "Actual count",
                           RtlpDphHeapListCount, "Page heap count",
                           0, "",
                           0, "");
        }

    }
    else {

        //
        //  User's buffer is too small.  Return number of entries
        //  necessary for subsequent call to succeed.  Buffer
        //  remains untouched.
        //

        Count = RtlpDphHeapListCount;

    }

    RtlLeaveCriticalSection( &RtlpDphHeapListCriticalSection );

    return Count;
}

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
{
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL)
        return 0;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );

    //
    //  Don't do anything, but we did want to acquire the critsect
    //  in case this was called with HEAP_NO_SERIALIZE while another
    //  thread is in the heap code.
    //

    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return 0;
}

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK Node;
    BOOLEAN Result = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if (HeapRoot == NULL)
        return FALSE;

    Flags |= HeapRoot->HeapFlags;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        Node = Address ? RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL ) : NULL;

        if (Node == NULL) {

            Result = RtlpDphNormalHeapValidate (
                HeapRoot,
                Flags,
                Address);
        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              TRUE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    if (Address) {
        if (Node) {
            return TRUE;
        }
        else {
            return Result;
        }
    }
    else {
        return TRUE;
    }
}

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )
{
#if DBG
    DbgPrint ("Page heap: warning: failing HeapWalk call with STATUS_NOT_IMPLEMENTED.\n");
#endif

    return STATUS_NOT_IMPLEMENTED;
}

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    )
{
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );

    if (HeapRoot == NULL) {
        return FALSE;
    }

    RtlpDebugPageHeapEnterCritSect( HeapRoot, HeapRoot->HeapFlags );

    return TRUE;
}

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    )
{
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );

    if (HeapRoot == NULL) {
        return FALSE;
    }

    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return TRUE;
}

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

        if ( Node == NULL ) {

            //
            // If we cannot find the node in page heap structures it might be
            // because it has been allocated from normal heap.
            //

            Success = RtlpDphNormalHeapSetUserValue (
                HeapRoot,
                Flags,
                Address,
                UserValue);

            goto EXIT;
        }
        else {
            Node->UserValue = UserValue;
            Success = TRUE;
        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:
        
    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    return Success;
}

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

        if ( Node == NULL ) {

            //
            // If we cannot find the node in page heap structures it might be
            // because it has been allocated from normal heap.
            //

            Success = RtlpDphNormalHeapGetUserInfo (
                HeapRoot,
                Flags,
                Address,
                UserValue,
                UserFlags);

            goto EXIT;
        }
        else {
            if ( UserValue != NULL )
                *UserValue = Node->UserValue;
            if ( UserFlags != NULL )
                *UserFlags = Node->UserFlags;
            Success = TRUE;
        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:
        
    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    return Success;
}

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )
{
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_BLOCK Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

        if ( Node == NULL ) {

            //
            // If we cannot find the node in page heap structures it might be
            // because it has been allocated from normal heap.
            //

            Success = RtlpDphNormalHeapSetUserFlags (
                HeapRoot,
                Flags,
                Address,
                UserFlagsReset,
                UserFlagsSet);

            goto EXIT;
        }
        else {
            Node->UserFlags &= ~( UserFlagsReset );
            Node->UserFlags |=    UserFlagsSet;
            Success = TRUE;
        }
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    EXIT:

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    return Success;
}

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    )
{
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, 0);


    HeapRoot->HeapFlags &= ~HEAP_NO_SERIALIZE;

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);

    return TRUE;
}

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID  Base,
    IN SIZE_T Size
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )
{
    PDPH_HEAP_ROOT HeapRoot;

    //
    //  Partial implementation since this information is kind of meaningless.
    //

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return STATUS_INVALID_PARAMETER;

    if ( Usage->Length != sizeof( RTL_HEAP_USAGE ))
        return STATUS_INFO_LENGTH_MISMATCH;

    memset( Usage, 0, sizeof( RTL_HEAP_USAGE ));
    Usage->Length = sizeof( RTL_HEAP_USAGE );

    //
    // Get the heap lock, unprotect heap structures, etc.
    //

    RtlpDphPreProcessing (HeapRoot, Flags);


    try {

        Usage->BytesAllocated       = HeapRoot->nBusyAllocationBytesAccessible;
        Usage->BytesCommitted       = HeapRoot->nVirtualStorageBytes;
        Usage->BytesReserved        = HeapRoot->nVirtualStorageBytes;
        Usage->BytesReservedMaximum = HeapRoot->nVirtualStorageBytes;
    }
    except (RtlpDphUnexpectedExceptionFilter (_exception_code(), 
                                              _exception_info(),
                                              HeapRoot,
                                              FALSE)) {

        //
        // The exception filter always returns EXCEPTION_CONTINUE_SEARCH.
        //

        ASSERT_UNEXPECTED_CODE_PATH ();
    }

    //
    // Prepare page heap for exit (unlock heap lock, protect structures, etc.).
    //

    RtlpDphPostProcessing (HeapRoot);


    return STATUS_SUCCESS;
}

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    )
{
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    if ( RtlTryEnterCriticalSection( HeapRoot->HeapCritSect )) {
        RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
        return FALSE;
    }
    else {
        return TRUE;
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////// Page heap vs. normal heap decision making
/////////////////////////////////////////////////////////////////////

//
// 0 - full page heap
// 1 - light page heap
//

LONG RtlpDphBlockDistribution[2];

BOOLEAN
RtlpDphShouldAllocateInPageHeap (
    PDPH_HEAP_ROOT HeapRoot,
    SIZE_T Size
    )
/*++

Routine Description:

    This routine decides if the current allocation should be made in full
    page heap or light page heap.

Parameters:

    HeapRoot - heap descriptor for the current allocation request.
    
    Size - size of the current allocation request.

Return Value:

    True if this should be a full page heap allocation and false otherwise.     

--*/
{
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    NTSTATUS Status;
    ULONG Random;
    ULONG Percentage;

    //
    // If page heap is not enabled => normal heap.
    //

    if (! (HeapRoot->ExtraFlags & PAGE_HEAP_ENABLE_PAGE_HEAP)) {
        InterlockedIncrement (&(RtlpDphBlockDistribution[1]));
        return FALSE;
    }

    //
    // If call not generated from one of the target dlls => normal heap
    // We do this check up front to avoid the slow path where we check
    // if VM limits have been hit.
    //

    else if ((HeapRoot->ExtraFlags & PAGE_HEAP_USE_DLL_NAMES)) {

        //
        // We return false. The calls generated from target
        // dlls will never get into this function and therefore
        // we just return false signalling that we do not want
        // page heap verification for the rest of the world.
        //
        
        InterlockedIncrement (&(RtlpDphBlockDistribution[1]));
        return FALSE;
    }

    //
    // Check memory availability. If we tend to exhaust virtual space
    // or page file then we will go to the normal heap.
    //

    else if (RtlpDphVmLimitCanUsePageHeap() == FALSE) {
        InterlockedIncrement (&(RtlpDphBlockDistribution[1]));
        return FALSE;
    }

    //
    // If in size range => page heap
    //

    else if ((HeapRoot->ExtraFlags & PAGE_HEAP_USE_SIZE_RANGE)) {

        if (Size >= RtlpDphSizeRangeStart && Size <= RtlpDphSizeRangeEnd) {
            InterlockedIncrement (&(RtlpDphBlockDistribution[0]));
            return TRUE;
        }
        else {
            InterlockedIncrement (&(RtlpDphBlockDistribution[1]));
            return FALSE;
        }
    }

    //
    // If in dll range => page heap
    //

    else if ((HeapRoot->ExtraFlags & PAGE_HEAP_USE_DLL_RANGE)) {

        PVOID StackTrace[32];
        ULONG Count;
        ULONG Index;
        ULONG Hash;

        Count = RtlCaptureStackBackTrace (
            1,
            32,
            StackTrace,
            &Hash);

        //
        // (SilviuC): should read DllRange as PVOIDs
        //

        for (Index = 0; Index < Count; Index += 1) {
            if (PtrToUlong(StackTrace[Index]) >= RtlpDphDllRangeStart
                && PtrToUlong(StackTrace[Index]) <= RtlpDphDllRangeEnd) {

                InterlockedIncrement (&(RtlpDphBlockDistribution[0]));
                return TRUE;
            }
        }

        InterlockedIncrement (&(RtlpDphBlockDistribution[1]));
        return FALSE;
    }

    //
    // If randomly decided => page heap
    //

    else if ((HeapRoot->ExtraFlags & PAGE_HEAP_USE_RANDOM_DECISION)) {

        Random = RtlRandom (& (HeapRoot->Seed));

        if ((Random % 100) < RtlpDphRandomProbability) {
            InterlockedIncrement (&(RtlpDphBlockDistribution[0]));
            return TRUE;
        }
        else {
            InterlockedIncrement (&(RtlpDphBlockDistribution[1]));
            return FALSE;
        }
    }

    //
    // For all other cases we will allocate in the page heap.
    //

    else {

        InterlockedIncrement (&(RtlpDphBlockDistribution[0]));
        return TRUE;
    }
}

//
// Vm limit related globals.
//

LONG RtlpDphVmLimitNoPageHeap;
LONG RtlpDphVmLimitHits[2];
#define SIZE_1_MB 0x100000

BOOLEAN
RtlpDphVmLimitCanUsePageHeap (
    )
/*++

Routine Description:

    This routine decides if we have good conditions for a full page heap
    allocation to be successful. It checks two things: the pagefile commit
    available on the system and the virtual space available in the current
    process. Since full page heap uses at least 2 pages for each allocation 
    it can potentially exhaust both these resources. The current criteria are:
    
    (1) if less than 32Mb of pagefile commit are left we switch to light 
    page heap
    
    (2) if less than 128Mb of empty virtual space is left we switch to light 
    page heap

Parameters:

    None.

Return Value:

    True if full page heap allocations are allowed and false otherwise.     

--*/
{
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_BASIC_INFORMATION MemInfo;
    VM_COUNTERS VmCounters;
    NTSTATUS Status;
    LONG Value;
    LONG Calls;
    ULONGLONG Total;

    //
    // Find if full page heap is currently allowed.
    //

    Value = InterlockedCompareExchange (&RtlpDphVmLimitNoPageHeap,
                                        0,
                                        0);

    //
    // Query system for page file availability etc.
    //

    Status = NtQuerySystemInformation (SystemPerformanceInformation,
                                       &PerfInfo,
                                       sizeof(PerfInfo),
                                       NULL);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &MemInfo,
                                       sizeof(MemInfo),
                                       NULL);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessVmCounters,
                                        &VmCounters,
                                        sizeof(VM_COUNTERS),
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // First check that we have enough virtual space left in the process.
    // If less than 128Mb are left we will disable full page heap allocs.
    //

    Total = (MemInfo.MaximumUserModeAddress - MemInfo.MinimumUserModeAddress);

    if (Total - VmCounters.VirtualSize < 128 * SIZE_1_MB) {

        if (Value == 0) {
            if ((RtlpDphDebugLevel & DPH_DEBUG_SHOW_VM_LIMITS)) {
                DbgPrint ("Page heap: pid 0x%X: vm limit: vspace: disabling full page heap \n",
                          HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
            }
        }

        InterlockedIncrement (&(RtlpDphVmLimitHits[0]));
        InterlockedExchange (&RtlpDphVmLimitNoPageHeap, 1);
        return FALSE;
    }

    //
    // Next check for page file availability. If less than 32Mb are
    // available for commit we disable full page heap. Note that
    // CommitLimit does not reflect future pagefile extension potential.
    // Therefore pageheap will scale down even if the pagefile has not
    // been extended to its maximum.
    //

    Total = PerfInfo.CommitLimit - PerfInfo.CommittedPages;
    Total *= MemInfo.PageSize;

    if (Total - VmCounters.PagefileUsage < 32 * SIZE_1_MB) {

        if (Value == 0) {
            if ((RtlpDphDebugLevel & DPH_DEBUG_SHOW_VM_LIMITS)) {
                DbgPrint ("Page heap: pid 0x%X: vm limit: pfile: disabling full page heap \n",
                          HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
            }
        }

        InterlockedIncrement (&(RtlpDphVmLimitHits[1]));
        InterlockedExchange (&RtlpDphVmLimitNoPageHeap, 1);
        return FALSE;
    }

    if (Value == 1) {
        
        if ((RtlpDphDebugLevel & DPH_DEBUG_SHOW_VM_LIMITS)) {
            DbgPrint ("Page heap: pid 0x%X: vm limit: reenabling full page heap \n",
                      HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
        }

        InterlockedExchange (&RtlpDphVmLimitNoPageHeap, 0);
    }
    
    return TRUE;
}


/////////////////////////////////////////////////////////////////////
//////////////////////////////////// DPH_BLOCK_INFORMATION management
/////////////////////////////////////////////////////////////////////

VOID
RtlpDphReportCorruptedBlock (
    PVOID Heap,
    ULONG Context,
    PVOID Block,
    ULONG Reason
    )
{
    SIZE_T Size;
    DPH_BLOCK_INFORMATION Info;
    BOOLEAN InfoRead = FALSE;
    BOOLEAN SizeRead = FALSE;

    try {
        RtlCopyMemory (&Info, (PDPH_BLOCK_INFORMATION)Block - 1, sizeof Info);
        InfoRead = TRUE;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
    }

    if (RtlpDphGetBlockSizeFromCorruptedBlock (Block, &Size)) {
        SizeRead = TRUE;
    }

    //
    // If we did not even manage to read the entire block header
    // report exception. If we managed to read the header we will let it
    // run through the other messages and only in the end report exception.
    //

    if (!InfoRead && (Reason & DPH_ERROR_RAISED_EXCEPTION)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "exception raised while verifying block header",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       0, "");
    }

    if ((Reason & DPH_ERROR_DOUBLE_FREE)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "block already freed",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       0, "");
    }
    
    if ((Reason & DPH_ERROR_CORRUPTED_INFIX_PATTERN)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "corrupted infix pattern for freed block",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       0, "");
    }
    
    if ((Reason & DPH_ERROR_CORRUPTED_HEAP_POINTER)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "corrupted heap pointer or using wrong heap",
                       Heap, "Heap used in the call",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       (InfoRead ? (UNSCRAMBLE_POINTER(Info.Heap)) : 0), "Heap owning the block");
    }
    
    if ((Reason & DPH_ERROR_CORRUPTED_SUFFIX_PATTERN)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "corrupted suffix pattern",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       0, "");
    }
    
    if ((Reason & DPH_ERROR_CORRUPTED_PREFIX_PATTERN)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "corrupted prefix pattern",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       0, "");
    }
    
    if ((Reason & DPH_ERROR_CORRUPTED_START_STAMP)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "corrupted start stamp",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       (InfoRead ? Info.StartStamp : 0), "Corrupted stamp");
    }
    
    if ((Reason & DPH_ERROR_CORRUPTED_END_STAMP)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "corrupted end stamp",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       (InfoRead ? Info.EndStamp : 0), "Corrupted stamp");
    }

    if ((Reason & DPH_ERROR_RAISED_EXCEPTION)) {
        
        VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                       "exception raised while verifying block",
                       Heap, "Heap handle",
                       Block, "Heap block", 
                       (SizeRead ? Size : 0), "Block size",
                       0, "");
    }

    //
    // Catch all case.
    //

    VERIFIER_STOP (APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK,
                   "corrupted heap block",
                   Heap, "Heap handle",
                   Block, "Heap block", 
                   (SizeRead ? Size : 0), "Block size",
                   0, "");
}

BOOLEAN
RtlpDphIsPageHeapBlock (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    PULONG Reason,
    BOOLEAN CheckPattern
    )
{
    PDPH_BLOCK_INFORMATION Info;
    BOOLEAN Corrupted = FALSE;
    PUCHAR Current;
    PUCHAR FillStart;
    PUCHAR FillEnd;

    DEBUG_ASSERT (Reason != NULL);
    *Reason = 0;

    try {

        Info = (PDPH_BLOCK_INFORMATION)Block - 1;

        //
        // Start checking ...
        //

        if (Info->StartStamp != DPH_PAGE_BLOCK_START_STAMP_ALLOCATED) {
            *Reason |= DPH_ERROR_CORRUPTED_START_STAMP;
            Corrupted = TRUE;

            if (Info->StartStamp == DPH_PAGE_BLOCK_START_STAMP_FREE) {
                *Reason |= DPH_ERROR_DOUBLE_FREE;
            }
        }

        if (Info->EndStamp != DPH_PAGE_BLOCK_END_STAMP_ALLOCATED) {
            *Reason |= DPH_ERROR_CORRUPTED_END_STAMP;
            Corrupted = TRUE;
        }

        if (Info->Heap != Heap) {
            *Reason |= DPH_ERROR_CORRUPTED_HEAP_POINTER;
            Corrupted = TRUE;
        }

        //
        // Check the block suffix byte pattern.
        //

        if (CheckPattern) {

            FillStart = (PUCHAR)Block + Info->RequestedSize;
            FillEnd = (PUCHAR)ROUNDUP2((ULONG_PTR)FillStart, PAGE_SIZE);

            for (Current = FillStart; Current < FillEnd; Current++) {

                if (*Current != DPH_PAGE_BLOCK_SUFFIX) {

                    *Reason |= DPH_ERROR_CORRUPTED_SUFFIX_PATTERN;
                    Corrupted = TRUE;
                    break;
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        *Reason |= DPH_ERROR_RAISED_EXCEPTION;
        Corrupted = TRUE;
    }

    if (Corrupted) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

BOOLEAN
RtlpDphIsNormalHeapBlock (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    PULONG Reason,
    BOOLEAN CheckPattern
    )
{
    PDPH_BLOCK_INFORMATION Info;
    BOOLEAN Corrupted = FALSE;
    PUCHAR Current;
    PUCHAR FillStart;
    PUCHAR FillEnd;

    DEBUG_ASSERT (Reason != NULL);
    *Reason = 0;

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    try {

        if (UNSCRAMBLE_POINTER(Info->Heap) != Heap) {
            *Reason |= DPH_ERROR_CORRUPTED_HEAP_POINTER;
            Corrupted = TRUE;
        }

        if (Info->StartStamp != DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED) {
            *Reason |= DPH_ERROR_CORRUPTED_START_STAMP;
            Corrupted = TRUE;
            
            if (Info->StartStamp == DPH_NORMAL_BLOCK_START_STAMP_FREE) {
                *Reason |= DPH_ERROR_DOUBLE_FREE;
            }
        }

        if (Info->EndStamp != DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED) {
            *Reason |= DPH_ERROR_CORRUPTED_END_STAMP;
            Corrupted = TRUE;
        }

        //
        // Check the block suffix byte pattern.
        //

        if (CheckPattern) {

            FillStart = (PUCHAR)Block + Info->RequestedSize;
            FillEnd = FillStart + USER_ALIGNMENT;

            for (Current = FillStart; Current < FillEnd; Current++) {

                if (*Current != DPH_NORMAL_BLOCK_SUFFIX) {

                    *Reason |= DPH_ERROR_CORRUPTED_SUFFIX_PATTERN;
                    Corrupted = TRUE;
                    break;
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        *Reason |= DPH_ERROR_RAISED_EXCEPTION;
        Corrupted = TRUE;
    }

    if (Corrupted) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

BOOLEAN
RtlpDphIsNormalFreeHeapBlock (
    PVOID Block,
    PULONG Reason,
    BOOLEAN CheckPattern
    )
{
    PDPH_BLOCK_INFORMATION Info;
    BOOLEAN Corrupted = FALSE;
    PUCHAR Current;
    PUCHAR FillStart;
    PUCHAR FillEnd;

    DEBUG_ASSERT (Reason != NULL);
    *Reason = 0;

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    try {

        //
        // If heap pointer is null we will just ignore this field.
        // This can happen during heap destroy operations where
        // the page heap got destroyed but the normal heap is still
        // alive.
        //

        if (Info->StartStamp != DPH_NORMAL_BLOCK_START_STAMP_FREE) {
            *Reason |= DPH_ERROR_CORRUPTED_START_STAMP;
            Corrupted = TRUE;
        }

        if (Info->EndStamp != DPH_NORMAL_BLOCK_END_STAMP_FREE) {
            *Reason |= DPH_ERROR_CORRUPTED_END_STAMP;
            Corrupted = TRUE;
        }

        //
        // Check the block suffix byte pattern.
        //

        if (CheckPattern) {

            FillStart = (PUCHAR)Block + Info->RequestedSize;
            FillEnd = FillStart + USER_ALIGNMENT;

            for (Current = FillStart; Current < FillEnd; Current++) {

                if (*Current != DPH_NORMAL_BLOCK_SUFFIX) {

                    *Reason |= DPH_ERROR_CORRUPTED_SUFFIX_PATTERN;
                    Corrupted = TRUE;
                    break;
                }
            }
        }

        //
        // Check the block infix byte pattern.
        //

        if (CheckPattern) {

            FillStart = (PUCHAR)Block;
            FillEnd = FillStart
                + ((Info->RequestedSize > USER_ALIGNMENT) ? USER_ALIGNMENT : Info->RequestedSize);

            for (Current = FillStart; Current < FillEnd; Current++) {

                if (*Current != DPH_FREE_BLOCK_INFIX) {

                    *Reason |= DPH_ERROR_CORRUPTED_INFIX_PATTERN;
                    Corrupted = TRUE;
                    break;
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        *Reason |= DPH_ERROR_RAISED_EXCEPTION;
        Corrupted = TRUE;
    }

    if (Corrupted) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}


BOOLEAN
RtlpDphWritePageHeapBlockInformation (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    SIZE_T RequestedSize,
    SIZE_T ActualSize
    )
{
    PDPH_BLOCK_INFORMATION Info;
    PUCHAR FillStart;
    PUCHAR FillEnd;
    ULONG Hash;

    //
    // Size and stamp information
    //

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    Info->Heap = Heap;
    Info->RequestedSize = RequestedSize;
    Info->ActualSize = ActualSize;
    Info->StartStamp = DPH_PAGE_BLOCK_START_STAMP_ALLOCATED;
    Info->EndStamp = DPH_PAGE_BLOCK_END_STAMP_ALLOCATED;

    //
    // Fill the block suffix pattern.
    // We fill up to USER_ALIGNMENT bytes.
    //

    FillStart = (PUCHAR)Block + RequestedSize;
    FillEnd = (PUCHAR)ROUNDUP2((ULONG_PTR)FillStart, PAGE_SIZE);

    RtlFillMemory (FillStart, FillEnd - FillStart, DPH_PAGE_BLOCK_SUFFIX);

    //
    // Capture stack trace
    //

    if ((Heap->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {
        Info->StackTrace = RtlpDphLogStackTrace (3);
    }
    else {
        Info->StackTrace = NULL;
    }

    //
    // Call the old logging function (SteveWo's trace database).
    // We do this so that tools that are used for leak detection
    // (e.g. umdh) will work even if page heap is enabled.
    // If the trace database was not created this function will
    // return immediately.
    //

    Info->TraceIndex = RtlLogStackBackTrace ();

    return TRUE;
}

BOOLEAN
RtlpDphWriteNormalHeapBlockInformation (
    PDPH_HEAP_ROOT Heap,
    PVOID Block,
    SIZE_T RequestedSize,
    SIZE_T ActualSize
    )
{
    PDPH_BLOCK_INFORMATION Info;
    PUCHAR FillStart;
    PUCHAR FillEnd;
    ULONG Hash;
    ULONG Reason;

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    //
    // Size and stamp information
    //

    Info->Heap = SCRAMBLE_POINTER(Heap);
    Info->RequestedSize = RequestedSize;
    Info->ActualSize = ActualSize;
    Info->StartStamp = DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED;
    Info->EndStamp = DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED;

    Info->FreeQueue.Blink = NULL;
    Info->FreeQueue.Flink = NULL;

    //
    // Fill the block suffix pattern.
    // We fill only USER_ALIGNMENT bytes.
    //

    FillStart = (PUCHAR)Block + RequestedSize;
    FillEnd = FillStart + USER_ALIGNMENT;

    RtlFillMemory (FillStart, FillEnd - FillStart, DPH_NORMAL_BLOCK_SUFFIX);

    //
    // Capture stack trace
    //

    if ((Heap->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {

        Info->StackTrace = RtlpDphLogStackTrace (4);

        if (Info->StackTrace) {

            RtlTraceDatabaseLock (RtlpDphTraceDatabase);
            ((PRTL_TRACE_BLOCK)(Info->StackTrace))->UserCount += 1;
            ((PRTL_TRACE_BLOCK)(Info->StackTrace))->UserSize += RequestedSize;
            ((PRTL_TRACE_BLOCK)(Info->StackTrace))->UserContext = Heap;
            RtlTraceDatabaseUnlock (RtlpDphTraceDatabase);
        }

    }
    else {
        Info->StackTrace = NULL;
    }

    //
    // Call the old logging function (SteveWo's trace database).
    // We do this so that tools that are used for leak detection
    // (e.g. umdh) will work even if page heap is enabled.
    // If the trace database was not created this function will
    // return immediately.
    //

    Info->TraceIndex = RtlLogStackBackTrace ();

    return TRUE;
}

BOOLEAN
RtlpDphGetBlockSizeFromCorruptedBlock (
    PVOID Block,
    PSIZE_T Size
    )
//
// This function gets called from RtlpDphReportCorruptedBlock only.
// It tries to extract a size for the block when an error is reported.
// If it cannot get the size it will return false.
//
{
    PDPH_BLOCK_INFORMATION Info;
    BOOLEAN Success = FALSE;

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    try {

        if (Info->StartStamp == DPH_NORMAL_BLOCK_START_STAMP_FREE
            || Info->StartStamp == DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED
            || Info->StartStamp == DPH_PAGE_BLOCK_START_STAMP_FREE
            || Info->StartStamp == DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED) {

            *Size = Info->RequestedSize;
            Success = TRUE;
        }
        else {

            Success = FALSE;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        Success = FALSE;
    }

    return Success;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////// Normal heap allocation/free functions
/////////////////////////////////////////////////////////////////////

PVOID
RtlpDphNormalHeapAllocate (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    SIZE_T Size
    )
{
    PVOID Block;
    PDPH_BLOCK_INFORMATION Info;
    ULONG Hash;
    SIZE_T ActualSize;
    SIZE_T RequestedSize;
    ULONG Reason;

    //
    // Reject extreme size requests.
    //

#if defined(_IA64_)
    if (Size > 0x8000000000000000) {
#else
    if (Size > 0x80000000) {
#endif

        VERIFIER_STOP (APPLICATION_VERIFIER_EXTREME_SIZE_REQUEST,
                       "extreme size request",
                       Heap, "Heap handle", 
                       Size, "Size requested", 
                       0, "",
                       0, "");
        return NULL;
    }

    RequestedSize = Size;
    ActualSize = Size + sizeof(DPH_BLOCK_INFORMATION) + USER_ALIGNMENT;

    //
    // We need to reset the NO_SERIALIZE flag because a free operation can be
    // active in another thread due to free delayed cache trimming. If the
    // allocation operation will raise an exception (e.g. OUT_OF_MEMORY) we are
    // safe to let it go here. It will be caught by the exception handler 
    // established in the main page heap entry (RtlpDebugPageHeapAlloc).
    //

    Block = RtlAllocateHeap (
        Heap->NormalHeap,
        Flags & (~HEAP_NO_SERIALIZE),
        ActualSize);

    if (Block == NULL) {

        //
        // (SilviuC): If we have memory pressure we might want
        // to trim the delayed free queues. We do not do this
        // right now because the threshold is kind of small and there
        // are many benefits in keeping this cache around.
        //

        return NULL;
    }


    RtlpDphWriteNormalHeapBlockInformation (
        Heap,
        (PDPH_BLOCK_INFORMATION)Block + 1,
        RequestedSize,
        ActualSize);

    if (! (Flags & HEAP_ZERO_MEMORY)) {

        RtlFillMemory ((PDPH_BLOCK_INFORMATION)Block + 1,
                       RequestedSize,
                       DPH_NORMAL_BLOCK_INFIX);
    }

    return (PVOID)((PDPH_BLOCK_INFORMATION)Block + 1);
}


BOOLEAN
RtlpDphNormalHeapFree (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    PVOID Block
    )
{
    PDPH_BLOCK_INFORMATION Info;
    BOOLEAN Success;
    ULONG Reason;
    ULONG Hash;
    SIZE_T TrimSize;

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    if (! RtlpDphIsNormalHeapBlock(Heap, Block, &Reason, TRUE)) {

        RtlpDphReportCorruptedBlock (Heap,
                                     DPH_CONTEXT_NORMAL_PAGE_HEAP_FREE,
                                     Block, 
                                     Reason);

        return FALSE;
    }

    //
    // Check if there are any orphan critical sections in the block to be freed.
    //

    RtlpCheckForCriticalSectionsInMemoryRange (Block, 
                                               Info->RequestedSize,
                                               NULL);

    //
    // Save the free stack trace.
    //

    if ((Heap->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {

        if (Info->StackTrace) {

            RtlTraceDatabaseLock (RtlpDphTraceDatabase);
            ((PRTL_TRACE_BLOCK)(Info->StackTrace))->UserCount -= 1;
            ((PRTL_TRACE_BLOCK)(Info->StackTrace))->UserSize -= Info->RequestedSize;
            RtlTraceDatabaseUnlock (RtlpDphTraceDatabase);
        }

        Info->StackTrace = RtlpDphLogStackTrace (3);
    }
    else {
        Info->StackTrace = NULL;
    }

    //
    // Mark the block as freed.
    //

    Info->StartStamp -= 1;
    Info->EndStamp -= 1;

    //
    // Wipe out all the information in the block so that it cannot
    // be used while free. The pattern looks like a kernel pointer
    // and if we are lucky enough the buggy code might use a value
    // from the block as a pointer and instantly access violate.
    //

    RtlFillMemory (Info + 1,
                   Info->RequestedSize,
                   DPH_FREE_BLOCK_INFIX);

    //
    // Add block to the delayed free queue.
    //

    RtlpDphAddToDelayedFreeQueue (Info);

    //
    // If we are over the threshold we need to really free
    // some of the guys.
    //

    Success = TRUE;

    if (RtlpDphNeedToTrimDelayedFreeQueue(&TrimSize)) {

        RtlpDphTrimDelayedFreeQueue (TrimSize, Flags);
    }

    return Success;
}


PVOID
RtlpDphNormalHeapReAllocate (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;
    PDPH_BLOCK_INFORMATION Info;
    ULONG Hash;
    SIZE_T CopySize;
    ULONG Reason;

    //
    // Reject extreme size requests.
    //

#if defined(_IA64_)
    if (Size > 0x8000000000000000) {
#else
    if (Size > 0x80000000) {
#endif

        VERIFIER_STOP (APPLICATION_VERIFIER_EXTREME_SIZE_REQUEST,
                       "extreme size request",
                       Heap, "Heap handle", 
                       Size, "Size requested", 
                       0, "",
                       0, "");
        return NULL;
    }

    Info = (PDPH_BLOCK_INFORMATION)OldBlock - 1;

    if (! RtlpDphIsNormalHeapBlock(Heap, OldBlock, &Reason, TRUE)) {

        RtlpDphReportCorruptedBlock (Heap,
                                     DPH_CONTEXT_NORMAL_PAGE_HEAP_REALLOC,
                                     OldBlock, 
                                     Reason);

        return NULL;
    }

    Block = RtlpDphNormalHeapAllocate (Heap, Flags, Size);

    if (Block == NULL) {
        return NULL;
    }

    //
    // Copy old block stuff into the new block and then
    // free old block.
    //

    if (Size < Info->RequestedSize) {
        CopySize = Size;
    }
    else {
        CopySize = Info->RequestedSize;
    }

    RtlCopyMemory (Block, OldBlock, CopySize);

    //
    // Free the old guy.
    //

    RtlpDphNormalHeapFree (Heap, Flags, OldBlock);

    return Block;
}


SIZE_T
RtlpDphNormalHeapSize (
    PDPH_HEAP_ROOT Heap,
    ULONG Flags,
    PVOID Block
    )
{
    PDPH_BLOCK_INFORMATION Info;
    SIZE_T Result;
    ULONG Reason;

    Info = (PDPH_BLOCK_INFORMATION)Block - 1;

    if (! RtlpDphIsNormalHeapBlock(Heap, Block, &Reason, FALSE)) {

        //
        // We cannot stop here for a wrong block.
        // The users might use this function to validate
        // if a block belongs to the heap or not. However
        // they should use HeapValidate for that.
        //

#if DBG
        DbgPrint ("Page heap: warning: HeapSize called with "
            "invalid block @ %p (reason %0X) \n", Block, Reason);
#endif

        return (SIZE_T)-1;
    }

    Result = RtlSizeHeap (
        Heap->NormalHeap,
        Flags,
        Info);

    if (Result == (SIZE_T)-1) {
        return Result;
    }
    else {
        return Result - sizeof(*Info) - USER_ALIGNMENT;
    }
}


BOOLEAN
RtlpDphNormalHeapSetUserFlags(
    IN PDPH_HEAP_ROOT Heap,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )
{
    BOOLEAN Success;
    ULONG Reason;

    if (! RtlpDphIsNormalHeapBlock(Heap, Address, &Reason, FALSE)) {

        RtlpDphReportCorruptedBlock (Heap,
                                     DPH_CONTEXT_NORMAL_PAGE_HEAP_SETFLAGS,
                                     Address, 
                                     Reason);

        return FALSE;
    }

    Success = RtlSetUserFlagsHeap (
        Heap->NormalHeap,
        Flags,
        (PDPH_BLOCK_INFORMATION)Address - 1,
        UserFlagsReset,
        UserFlagsSet);

    return Success;
}


BOOLEAN
RtlpDphNormalHeapSetUserValue(
    IN PDPH_HEAP_ROOT Heap,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    )
{
    BOOLEAN Success;
    ULONG Reason;

    if (! RtlpDphIsNormalHeapBlock(Heap, Address, &Reason, FALSE)) {

        RtlpDphReportCorruptedBlock (Heap,
                                     DPH_CONTEXT_NORMAL_PAGE_HEAP_SETVALUE,
                                     Address, 
                                     Reason);

        return FALSE;
    }

    Success = RtlSetUserValueHeap (
        Heap->NormalHeap,
        Flags,
        (PDPH_BLOCK_INFORMATION)Address - 1,
        UserValue);

    return Success;
}


BOOLEAN
RtlpDphNormalHeapGetUserInfo(
    IN PDPH_HEAP_ROOT Heap,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    )
{
    BOOLEAN Success;
    ULONG Reason;

    if (! RtlpDphIsNormalHeapBlock(Heap, Address, &Reason, FALSE)) {

        RtlpDphReportCorruptedBlock (Heap,
                                     DPH_CONTEXT_NORMAL_PAGE_HEAP_GETINFO,
                                     Address, 
                                     Reason);

        return FALSE;
    }

    Success = RtlGetUserInfoHeap (
        Heap->NormalHeap,
        Flags,
        (PDPH_BLOCK_INFORMATION)Address - 1,
        UserValue,
        UserFlags);

    return Success;
}


BOOLEAN
RtlpDphNormalHeapValidate(
    IN PDPH_HEAP_ROOT Heap,
    IN ULONG Flags,
    IN PVOID Address
    )
{
    BOOLEAN Success;
    ULONG Reason;

    if (Address == NULL) {

        //
        // Validation for the whole heap.
        //

        Success = RtlValidateHeap (
            Heap->NormalHeap,
            Flags,
            Address);
    }
    else {

        //
        // Validation for a heap block.
        //

        if (! RtlpDphIsNormalHeapBlock(Heap, Address, &Reason, TRUE)) {

            //
            // We cannot break in this case because the function might indeed
            // be called with invalid block. On checked builds we print a
            // warning just in case the invalid block was not intended.
            //

#if DBG
            DbgPrint ("Page heap: warning: validate called with "
                      "invalid block @ %p (reason %0X) \n", Address, Reason);
#endif

            return FALSE;
        }

        Success = RtlValidateHeap (
            Heap->NormalHeap,
            Flags,
            (PDPH_BLOCK_INFORMATION)Address - 1);
    }

    return Success;
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////// Delayed free queue for normal heap
/////////////////////////////////////////////////////////////////////


RTL_CRITICAL_SECTION RtlpDphDelayedFreeQueueLock;

SIZE_T RtlpDphMemoryUsedByDelayedFreeBlocks;
SIZE_T RtlpDphNumberOfDelayedFreeBlocks;

LIST_ENTRY RtlpDphDelayedFreeQueue;

VOID
RtlpDphInitializeDelayedFreeQueue (
    )
{
    RtlInitializeCriticalSection (&RtlpDphDelayedFreeQueueLock);
    InitializeListHead (&RtlpDphDelayedFreeQueue);

    RtlpDphMemoryUsedByDelayedFreeBlocks = 0;
    RtlpDphNumberOfDelayedFreeBlocks = 0;
}


VOID
RtlpDphAddToDelayedFreeQueue (
    PDPH_BLOCK_INFORMATION Info
    )
{
    RtlEnterCriticalSection (&RtlpDphDelayedFreeQueueLock);

    InsertTailList (&(RtlpDphDelayedFreeQueue), &(Info->FreeQueue));

    RtlpDphMemoryUsedByDelayedFreeBlocks += Info->ActualSize;
    RtlpDphNumberOfDelayedFreeBlocks += 1;

    RtlLeaveCriticalSection (&RtlpDphDelayedFreeQueueLock);
}

BOOLEAN
RtlpDphNeedToTrimDelayedFreeQueue (
    PSIZE_T TrimSize
    )
{
    BOOLEAN Result;

    RtlEnterCriticalSection (&RtlpDphDelayedFreeQueueLock);

    if (RtlpDphMemoryUsedByDelayedFreeBlocks > RtlpDphDelayedFreeCacheSize) {

        *TrimSize = RtlpDphMemoryUsedByDelayedFreeBlocks - RtlpDphDelayedFreeCacheSize;

        if (*TrimSize < PAGE_SIZE) {
            *TrimSize = PAGE_SIZE;
        }

        Result = TRUE;
    }
    else {

        Result = FALSE;
    }

    RtlLeaveCriticalSection (&RtlpDphDelayedFreeQueueLock);
    return Result;
}

VOID
RtlpDphTrimDelayedFreeQueue (
    SIZE_T TrimSize,
    ULONG Flags
    )
/*++

Routine Description:

    This routine trims the delayed free queue (global per process).
    If trim size is zero it will trim up to a global threshold
    (RtlpDphDelayedFreeCacheSize) otherwise uses `TrimSize'.

    Note. This function might become a little bit of a bottleneck
    because it is called by every free operation. Because of this
    it is better to always call RtlpDphNeedToTrimDelayedFreeQueue
    first.

Arguments:

    TrimSize: amount to trim (in bytes). If zero it trims down to
    a global threshold.

    Flags: flags for free operation.

Return Value:

    None.

Environment:

    Called from RtlpDphNormalXxx (normal heap management) routines.

--*/

{
    ULONG Reason;
    SIZE_T CurrentTrimmed = 0;
    PDPH_BLOCK_INFORMATION QueueBlock;
    PLIST_ENTRY ListEntry;

    RtlEnterCriticalSection (&RtlpDphDelayedFreeQueueLock);

    if (TrimSize == 0) {
        if (RtlpDphMemoryUsedByDelayedFreeBlocks > RtlpDphDelayedFreeCacheSize) {

            TrimSize = RtlpDphMemoryUsedByDelayedFreeBlocks - RtlpDphDelayedFreeCacheSize;
        }
    }

    while (TRUE) {

        //
        // Did we achieve our trimming goal?
        //

        if (CurrentTrimmed >= TrimSize) {
            break;
        }

        //
        // The list can get empty since we remove blocks from it.
        //

        if (IsListEmpty(&RtlpDphDelayedFreeQueue)) {
            break;
        }

        ListEntry = RemoveHeadList (&RtlpDphDelayedFreeQueue);
        QueueBlock = CONTAINING_RECORD (ListEntry, DPH_BLOCK_INFORMATION, FreeQueue);

        if (! RtlpDphIsNormalFreeHeapBlock(QueueBlock + 1, &Reason, TRUE)) {

            RtlpDphReportCorruptedBlock (NULL,
                                         DPH_CONTEXT_DELAYED_FREE,
                                         QueueBlock + 1, 
                                         Reason);
        }

        RtlpDphMemoryUsedByDelayedFreeBlocks -= QueueBlock->ActualSize;
        RtlpDphNumberOfDelayedFreeBlocks -= 1;
        CurrentTrimmed += QueueBlock->ActualSize;

        QueueBlock->StartStamp -= 1;
        QueueBlock->EndStamp -= 1;

        //
        // We protect against any mishaps when we call into NT heap. Note that we
        // cannot use the original flags used for free because this free operation
        // may happen in another thread. Plus we do not want unsynchronized access
        // anyway.
        //

        try {

            RtlFreeHeap (((PDPH_HEAP_ROOT)(UNSCRAMBLE_POINTER(QueueBlock->Heap)))->NormalHeap, 
                         0, 
                         QueueBlock);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    RtlLeaveCriticalSection (&RtlpDphDelayedFreeQueueLock);
}


VOID
RtlpDphFreeDelayedBlocksFromHeap (
    PVOID PageHeap,
    PVOID NormalHeap
    )
{
    ULONG Reason;
    PDPH_BLOCK_INFORMATION Block;
    PLIST_ENTRY Current;
    PLIST_ENTRY Next;

    RtlEnterCriticalSection (&RtlpDphDelayedFreeQueueLock);

    for (Current = RtlpDphDelayedFreeQueue.Flink;
         Current != &RtlpDphDelayedFreeQueue;
         Current = Next) {

        Next = Current->Flink;

        Block = CONTAINING_RECORD (Current, DPH_BLOCK_INFORMATION, FreeQueue);

        if (UNSCRAMBLE_POINTER(Block->Heap) != PageHeap) {
            continue;
        }

        //
        // We need to delete this block;
        //

        RemoveEntryList (Current);
        Block = CONTAINING_RECORD (Current, DPH_BLOCK_INFORMATION, FreeQueue);

        //
        // Prevent probing of this field during RtlpDphIsNormalFreeBlock.
        //

        Block->Heap = 0;

        //
        // Check if the block about to be freed was touched.
        //

        if (! RtlpDphIsNormalFreeHeapBlock(Block + 1, &Reason, TRUE)) {

            RtlpDphReportCorruptedBlock (PageHeap,
                                         DPH_CONTEXT_DELAYED_DESTROY,
                                         Block + 1, 
                                         Reason);
        }

        RtlpDphMemoryUsedByDelayedFreeBlocks -= Block->ActualSize;
        RtlpDphNumberOfDelayedFreeBlocks -= 1;

        //
        // (SilviuC): ISSUE: Not sure what flags to use here because the flags from the original
        // call have been lost (we do not store them somewhere in the delayed queue). 
        // Zero should work though. The safest fix would be to add a new field in
        // DPH_BLOCK_INFORMATION that stores the flags used during the original free
        // and uses them again here.
        //

        Block->StartStamp -= 1;
        Block->EndStamp -= 1;

        //
        // We protect against any mishaps when we call into NT heap. Note that we
        // cannot use the original flags used for free because this free operation
        // may happen in another thread. Plus we do not want unsynchronized access
        // anyway.
        //

        try {
            
            RtlFreeHeap (NormalHeap, 
                         0, 
                         Block);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    RtlLeaveCriticalSection (&RtlpDphDelayedFreeQueueLock);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Stack trace detection
/////////////////////////////////////////////////////////////////////

PRTL_TRACE_BLOCK
RtlpDphLogStackTrace (
    ULONG FramesToSkip
    )
{
    PVOID Trace [DPH_MAX_STACK_LENGTH];
    ULONG Hash;
    ULONG Count;
    PRTL_TRACE_BLOCK Block;
    BOOLEAN Result;

    Count = RtlCaptureStackBackTrace (
        1 + FramesToSkip,
        DPH_MAX_STACK_LENGTH,
        Trace,
        &Hash);

    if (Count == 0 || RtlpDphTraceDatabase == NULL) {
        return NULL;
    }

    Result = RtlTraceDatabaseAdd (
        RtlpDphTraceDatabase,
        Count,
        Trace,
        &Block);

    if (Result == FALSE) {
        return NULL;
    }
    else {
        return Block;
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Target dlls logic
/////////////////////////////////////////////////////////////////////

RTL_CRITICAL_SECTION RtlpDphTargetDllsLock;
LIST_ENTRY RtlpDphTargetDllsList;
BOOLEAN RtlpDphTargetDllsInitialized;

typedef struct _DPH_TARGET_DLL {

    LIST_ENTRY List;
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;

} DPH_TARGET_DLL, * PDPH_TARGET_DLL;

VOID
RtlpDphTargetDllsLogicInitialize (
    )
{
    RtlInitializeCriticalSection (&RtlpDphTargetDllsLock);
    InitializeListHead (&RtlpDphTargetDllsList);
    RtlpDphTargetDllsInitialized = TRUE;
}

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    )
//
// This function is not called right now but it will get called
// from \base\ntdll\ldrapi.c whenever a dll gets loaded. This
// gives page heap the opportunity to update per dll data structures
// that are not used right now for anything.
//
{
    PDPH_TARGET_DLL Descriptor;

    //
    // Get out if we are in some weird condition.
    //

    if (! RtlpDphTargetDllsInitialized) {
        return;
    }

    if (! RtlpDphIsDllTargeted (Name->Buffer)) {
        return;
    }

    Descriptor = RtlAllocateHeap (RtlProcessHeap(), 0, sizeof *Descriptor);

    if (Descriptor == NULL) {
        return;
    }

    if (! RtlCreateUnicodeString (&(Descriptor->Name), Name->Buffer)) {
        RtlFreeHeap (RtlProcessHeap(), 0, Descriptor);
        return;
    }

    Descriptor->StartAddress = Address;
    Descriptor->EndAddress = (PUCHAR)Address + Size;

    RtlEnterCriticalSection (&RtlpDphTargetDllsLock);
    InsertTailList (&(RtlpDphTargetDllsList), &(Descriptor->List));
    RtlLeaveCriticalSection (&RtlpDphTargetDllsLock);

    //
    // Print a message if a target dll has been identified.
    //

    DbgPrint("Page heap: loaded target dll %ws [%p - %p]\n",
             Descriptor->Name.Buffer,
             Descriptor->StartAddress,
             Descriptor->EndAddress);
}

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    )
{
    const WCHAR * All;
    ULONG I, J;

    All = RtlpDphTargetDllsUnicode.Buffer;

    for (I = 0; All[I]; I += 1) {

        for (J = 0; All[I+J] && Name[J]; J += 1) {
            if (RtlUpcaseUnicodeChar(All[I+J]) != RtlUpcaseUnicodeChar(Name[J])) {
                break;
            }
        }

        if (Name[J]) {
            continue;
        }
        else {
            // we got to the end of string
            return &(All[I]);
        }
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Validation checks
/////////////////////////////////////////////////////////////////////

PDPH_HEAP_BLOCK
RtlpDphSearchBlockInList (
    PDPH_HEAP_BLOCK List,
    PUCHAR Address
    )
{
    PDPH_HEAP_BLOCK Current;

    for (Current = List; Current; Current = Current->pNextAlloc) {
        if (Current->pVirtualBlock == Address) {
            return Current;
        }
    }

    return NULL;
}

PVOID RtlpDphLastValidationStack;
PVOID RtlpDphCurrentValidationStack;

VOID
RtlpDphInternalValidatePageHeap (
    PDPH_HEAP_ROOT Heap,
    PUCHAR ExemptAddress,
    SIZE_T ExemptSize
    )
{
    PDPH_HEAP_BLOCK Range;
    PDPH_HEAP_BLOCK Node;
    PUCHAR Address;
    BOOLEAN FoundLeak;

    RtlpDphLastValidationStack = RtlpDphCurrentValidationStack;
    RtlpDphCurrentValidationStack = RtlpDphLogStackTrace (0);
    FoundLeak = FALSE;

    for (Range = Heap->pVirtualStorageListHead;
         Range != NULL;
         Range = Range->pNextAlloc) {

        Address = Range->pVirtualBlock;

        while (Address < Range->pVirtualBlock + Range->nVirtualBlockSize) {

            //
            // Ignore DPH_HEAP_ROOT structures.
            //

            if ((Address >= (PUCHAR)Heap - PAGE_SIZE) && (Address <  (PUCHAR)Heap + 5 * PAGE_SIZE)) {
                Address += PAGE_SIZE;
                continue;
            }

            //
            // Ignore exempt region (temporarily out of all structures).
            //

            if ((Address >= ExemptAddress) && (Address < ExemptAddress + ExemptSize)) {
                Address += PAGE_SIZE;
                continue;
            }

            Node = RtlpDphSearchBlockInList (Heap->pBusyAllocationListHead, Address);

            if (Node) {
                Address += Node->nVirtualBlockSize;
                continue;
            }

            Node = RtlpDphSearchBlockInList (Heap->pFreeAllocationListHead, Address);

            if (Node) {
                Address += Node->nVirtualBlockSize;
                continue;
            }

            Node = RtlpDphSearchBlockInList (Heap->pAvailableAllocationListHead, Address);

            if (Node) {
                Address += Node->nVirtualBlockSize;
                continue;
            }

            Node = RtlpDphSearchBlockInList (Heap->pNodePoolListHead, Address);

            if (Node) {
                Address += Node->nVirtualBlockSize;
                continue;
            }

            DbgPrint ("Block @ %p has been leaked \n", Address);
            FoundLeak = TRUE;

            Address += PAGE_SIZE;
        }
    }

    if (FoundLeak) {

        DbgPrint ("Page heap: Last stack @ %p, Current stack @ %p \n",
            RtlpDphLastValidationStack,
            RtlpDphCurrentValidationStack);

        DbgBreakPoint ();
    }
}


VOID
RtlpDphValidateInternalLists (
    PDPH_HEAP_ROOT Heap
    )
/*++

Routine Description:

    This routine is called to validate the busy and free lists of a page heap
    if /protect bit is enabled. In the wbemstress lab we have seen a corruption
    of the busy list with the start of the busy list pointing towards the end of
    the free list. This is the reason we touch very carefully the nodes that are
    in the busy list.
    

--*/
{
    
    PDPH_HEAP_BLOCK StartNode;
    PDPH_HEAP_BLOCK EndNode;
    PDPH_HEAP_BLOCK Node;
    ULONG NumberOfBlocks;
    PDPH_BLOCK_INFORMATION Block;

    //
    // Nothing to do if /protect is not enabled.
    //

    if (! (Heap->ExtraFlags & PAGE_HEAP_PROTECT_META_DATA)) {
        return;
    }

    RtlpDphLastValidationStack = RtlpDphCurrentValidationStack;
    RtlpDphCurrentValidationStack = RtlpDphLogStackTrace (0);
    
    StartNode = Heap->pBusyAllocationListHead;
    EndNode = Heap->pBusyAllocationListTail;

    try {

        //
        // Sanity checks.
        //

        if (Heap->nBusyAllocations == 0) {
            
            return;
        }

        if (StartNode == NULL || StartNode->pVirtualBlock == NULL) {


            DbgPrint ("Page heap: corruption detected: %u: \n", __LINE__);
            DbgBreakPoint ();
        }

        if (EndNode == NULL || EndNode->pVirtualBlock == NULL) {


            DbgPrint ("Page heap: corruption detected: %u: \n", __LINE__);
            DbgBreakPoint ();
        }

        //
        // First check if StartNode is also in the free list. This was the typical
        // corruption pattern that I have seen in the past.
        //

        if (RtlpDphSearchBlockInList (Heap->pFreeAllocationListHead, StartNode->pVirtualBlock)) {
            DbgPrint ("Page heap: corruption detected: %u: \n", __LINE__);
            DbgPrint ("Corruption detected: %u: \n", __LINE__);
            DbgBreakPoint ();
        }

        //
        // Make sure that we have in the busy list exactly the number of blocks we think
        // we should have.
        //

        NumberOfBlocks = 0;

        for (Node = StartNode; Node != NULL; Node = Node->pNextAlloc) {

            NumberOfBlocks += 1;
        }

        if (NumberOfBlocks != Heap->nBusyAllocations) {

            DbgPrint ("Page heap: corruption detected: %u: \n", __LINE__);
            DbgBreakPoint ();
        }

        //
        // Take all nodes in the busy list and make sure they seem to be allocated, that is
        // they have the required pattern. This is skipped if we have the /backwards option
        // enabled since in this case we do not put magic patterns.
        //

        if (! (Heap->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

            for (Node = StartNode; Node != NULL; Node = Node->pNextAlloc) {

                Block = (PDPH_BLOCK_INFORMATION)(Node->pUserAllocation) - 1;

                if (Block->StartStamp != DPH_PAGE_BLOCK_START_STAMP_ALLOCATED) {

                    DbgPrint ("Page heap: corruption detected: wrong stamp for node %p \n", Node);
                    DbgBreakPoint ();
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        DbgPrint ("Page heap: corruption detected: exception raised \n");
        DbgBreakPoint ();
    }
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Fault injection logic
/////////////////////////////////////////////////////////////////////

BOOLEAN RtlpDphFaultSeedInitialized;
BOOLEAN RtlpDphFaultProcessEnoughStarted;
ULONG RtlpDphFaultInjectionDisabled;

ULONG RtlpDphFaultSeed;
ULONG RtlpDphFaultSuccessRate;
ULONG RtlpDphFaultFailureRate;

#define NO_OF_FAULT_STACKS 128
PVOID RtlpDphFaultStacks [NO_OF_FAULT_STACKS];
ULONG RtlpDphFaultStacksIndex;

#define ENOUGH_TIME ((DWORDLONG)(5 * 1000 * 1000 * 10)) // 5 secs
LARGE_INTEGER RtlpDphFaultStartTime;
LARGE_INTEGER RtlpDphFaultCurrentTime;

BOOLEAN
RtlpDphShouldFaultInject (
    )
{
    ULONG Index;
    DWORDLONG Delta;

    if (RtlpDphFaultProbability == 0) {
        return FALSE;
    }

    if (RtlpDphDisableFaults != 0) {
        return FALSE;
    }

    //
    // Make sure we do not fault inject if at least one guy
    // requested our mercy by calling RtlpDphDisableFaultInjection.
    //
    if (InterlockedExchangeAdd (&RtlpDphFaultInjectionDisabled, 1) > 0) {

        InterlockedDecrement (&RtlpDphFaultInjectionDisabled);
        return FALSE;
    }
    else {

        InterlockedDecrement (&RtlpDphFaultInjectionDisabled);
    }

    //
    // Make sure we do not fault while the process is getting
    // initialized. In principle we should deal with these bugs
    // also but it is not really a priority right now.
    //

    if (RtlpDphFaultProcessEnoughStarted == FALSE) {

        if ((DWORDLONG)(RtlpDphFaultStartTime.QuadPart) == 0) {

                NtQuerySystemTime (&RtlpDphFaultStartTime);
                return FALSE;
            }
        else {

            NtQuerySystemTime (&RtlpDphFaultCurrentTime);
            Delta = (DWORDLONG)(RtlpDphFaultCurrentTime.QuadPart)
                - (DWORDLONG)(RtlpDphFaultStartTime.QuadPart);

            if (Delta < ENOUGH_TIME) {
                return FALSE;
            }

            if (Delta <= ((DWORDLONG)RtlpDphFaultTimeOut * 1000 * 1000 * 10)) {
                return FALSE;
            }

            DbgPrint( "Page heap: enabling fault injection for process 0x%X \n",
                      HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));

            RtlpDphFaultProcessEnoughStarted = TRUE;
        }
    }

    //
    // Initialize the seed if we need to.
    //

    if (RtlpDphFaultSeedInitialized == FALSE) {

        LARGE_INTEGER PerformanceCounter;

        PerformanceCounter.LowPart = 0xABCDDCBA;

        NtQueryPerformanceCounter (
            &PerformanceCounter,
            NULL);

        RtlpDphFaultSeed = PerformanceCounter.LowPart;
        RtlpDphFaultSeedInitialized = TRUE;
    }

    if ((RtlRandom(&RtlpDphFaultSeed) % 10000) < RtlpDphFaultProbability) {

        Index = InterlockedExchangeAdd (&RtlpDphFaultStacksIndex, 1);
        Index &= (NO_OF_FAULT_STACKS - 1);
        RtlpDphFaultStacks[Index] = RtlpDphLogStackTrace (2);

        RtlpDphFaultFailureRate += 1;
        return TRUE;
    }
    else {

        RtlpDphFaultSuccessRate += 1;
        return FALSE;
    }
}

ULONG RtlpDphFaultInjectionDisabled;

VOID
RtlpDphDisableFaultInjection (
    )
{
    InterlockedIncrement (&RtlpDphFaultInjectionDisabled);
}

VOID
RtlpDphEnableFaultInjection (
    )
{
    InterlockedDecrement (&RtlpDphFaultInjectionDisabled);
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// Debug code
/////////////////////////////////////////////////////////////////////

#if INTERNAL_DEBUG

PVOID RtlpDphLastCheckTrace [16];


VOID
RtlpDphCheckFreeDelayedCache (
    PVOID CheckBlock,
    SIZE_T CheckSize
    )
{
    ULONG Reason;
    PDPH_BLOCK_INFORMATION Block;
    PLIST_ENTRY Current;
    PLIST_ENTRY Next;
    ULONG Hash;

    if (RtlpDphDelayedFreeQueue.Flink == NULL) {
        return;
    }

    RtlEnterCriticalSection (&RtlpDphDelayedFreeQueueLock);

    for (Current = RtlpDphDelayedFreeQueue.Flink;
         Current != &RtlpDphDelayedFreeQueue;
         Current = Next) {

        Next = Current->Flink;

        if (Current >= (PLIST_ENTRY)CheckBlock &&
            Current < (PLIST_ENTRY)((SIZE_T)CheckBlock + CheckSize)) {

            DbgPrint ("Page heap: block %p contains freed block %p \n", CheckBlock, Current);
            DbgBreakPoint ();
        }


        Block = CONTAINING_RECORD (Current, DPH_BLOCK_INFORMATION, FreeQueue);

        Block->Heap = UNSCRAMBLE_POINTER(Block->Heap);

        //
        // Check if the block about to be freed was touched.
        //

        if (! RtlpDphIsNormalFreeHeapBlock(Block + 1, &Reason, FALSE)) {

            RtlpDphReportCorruptedBlock (NULL,
                                         DPH_CONTEXT_DELAYED_FREE,
                                         Block + 1, 
                                         Reason);
        }

        //
        // Check busy bit
        //

        if ((((PHEAP_ENTRY)Block - 1)->Flags & HEAP_ENTRY_BUSY) == 0) {
            DbgPrint ("Page heap: block %p has busy bit reset \n", Block);
            DbgBreakPoint ();
        }
        
        Block->Heap = SCRAMBLE_POINTER(Block->Heap);
    }

    RtlZeroMemory (RtlpDphLastCheckTrace, 
                   sizeof RtlpDphLastCheckTrace);

    RtlCaptureStackBackTrace (0,
                              16,
                              RtlpDphLastCheckTrace,
                              &Hash);
    
    RtlLeaveCriticalSection (&RtlpDphDelayedFreeQueueLock);
}

#endif // #if INTERNAL_DEBUG


/////////////////////////////////////////////////////////////////////
///////////////////////////////////// Page heap global initialization
/////////////////////////////////////////////////////////////////////

#if 0

//
// It is not worth intercepting exceptions before anybody else. On one hand
// it is useful to detect if there is code that hides problems behind try/except's
// but on the other hand the code to detect if it is a legitimate AV or a
// bad one is fairly complicated and we have chances of getting double exceptions
// and other weird issues. We better leave all this business to the debugger if
// for instance it is configured to catch first chance exceptions.
//

LONG 
NTAPI
RtlpDphPageHeapExceptionFilter (
    struct _EXCEPTION_POINTERS * ExnInfo
    )
{
    PEXCEPTION_RECORD Exn;
    HANDLE CurrentThread;

    Exn = ExnInfo->ExceptionRecord;

    if (Exn->ExceptionCode == STATUS_ACCESS_VIOLATION) {

        if (NtCurrentPeb()->BeingDebugged) {

            if (Exn->NumberParameters > 1) {

                //
                // We skip over AV's in the first 64K. This skips C++ issues
                // where people free(0). This happens in Java VM stuff for instance.
                //

                if (Exn->ExceptionInformation[1] > 0x10000) {

                    VERIFIER_STOP (APPLICATION_VERIFIER_ACCESS_VIOLATION
                                   | APPLICATION_VERIFIER_DO_NOT_BREAK,
                                   "first chance access violation (address, .exr, .cxr)",
                                   Exn->ExceptionInformation[1],
                                   ExnInfo->ExceptionRecord,
                                   ExnInfo->ContextRecord,
                                   0);
                }
            }
        }
    }

    return EXCEPTION_CONTINUE_SEARCH;
}


BOOLEAN
RtlpDphInitializePageHeapPackage (
    )
{
    //
    // SilviuC: we do not establish a first chance AV filter for now.
    //

    PVOID Handler;

    Handler = RtlAddVectoredExceptionHandler (1, RtlpDphPageHeapExceptionFilter);

    if (Handler == NULL) {
        
        DbgPrint ("Page heap: failed to establish an exception filter \n");
        
        return FALSE;
    }

    return TRUE;
}

#endif // #if 0

#endif // DEBUG_PAGE_HEAP

//
// End of module
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heappriv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heappriv.h

Abstract:

    Private include file used by heap allocator (heap.c, heapdll.c and
    heapdbg.c)

Author:

    Steve Wood (stevewo) 25-Oct-1994

Revision History:

--*/

#ifndef _RTL_HEAP_PRIVATE_
#define _RTL_HEAP_PRIVATE_

#include "heappage.h"

//
//  In private builds (PRERELEASE = 1) we allow using the new low fragmentation heap
//  for processes that set the DisableLookaside registry key. The main purpose is to
//  allow testing the new heap API.
//

#ifndef PRERELEASE

#define DISABLE_REGISTRY_TEST_HOOKS

#endif

//
//  Disable FPO optimization so even retail builds get somewhat reasonable
//  stack backtraces
//

#if i386
// #pragma optimize("y",off)
#endif

#if DBG
#define HEAPASSERT(exp) if (!(exp)) RtlAssert( #exp, __FILE__, __LINE__, NULL )
#else
#define HEAPASSERT(exp)
#endif

//
// Define Minimum lookaside list depth.
//

#define MINIMUM_LOOKASIDE_DEPTH 4

//
//  This variable contains the fill pattern used for heap tail checking
//

extern const UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ];


//
//  Here are the locking routines for the heap (kernel and user)
//

#ifdef NTOS_KERNEL_RUNTIME

//
//  Kernel mode heap uses the kernel resource package for locking
//

#define RtlInitializeLockRoutine(L) ExInitializeResourceLite((PERESOURCE)(L))
#define RtlAcquireLockRoutine(L)    ExAcquireResourceExclusiveLite((PERESOURCE)(L),TRUE)
#define RtlReleaseLockRoutine(L)    ExReleaseResourceLite((PERESOURCE)(L))
#define RtlDeleteLockRoutine(L)     ExDeleteResourceLite((PERESOURCE)(L))
#define RtlOkayToLockRoutine(L)     ExOkayToLockRoutineLite((PERESOURCE)(L))

#else // #ifdef NTOS_KERNEL_ROUTINE

//
//  User mode heap uses the critical section package for locking
//

#ifndef PREALLOCATE_EVENT_MASK

#define PREALLOCATE_EVENT_MASK  0x80000000  // Defined only in dll\resource.c

#endif // PREALLOCATE_EVENT_MASK

#define RtlInitializeLockRoutine(L) RtlInitializeCriticalSectionAndSpinCount((PRTL_CRITICAL_SECTION)(L),(PREALLOCATE_EVENT_MASK | 4000))
#define RtlAcquireLockRoutine(L)    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlReleaseLockRoutine(L)    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlDeleteLockRoutine(L)     RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlOkayToLockRoutine(L)     NtdllOkayToLockRoutine((PVOID)(L))

#endif // #ifdef NTOS_KERNEL_RUNTIME


//
//  Here are some debugging macros for the heap
//

#ifdef NTOS_KERNEL_RUNTIME

#define HEAP_DEBUG_FLAGS   0
#define DEBUG_HEAP(F)      FALSE
#define SET_LAST_STATUS(S) NOTHING;

#else // #ifdef NTOS_KERNEL_ROUTINE

#define HEAP_DEBUG_FLAGS   (HEAP_VALIDATE_PARAMETERS_ENABLED | \
                            HEAP_VALIDATE_ALL_ENABLED        | \
                            HEAP_CAPTURE_STACK_BACKTRACES    | \
                            HEAP_CREATE_ENABLE_TRACING       | \
                            HEAP_FLAG_PAGE_ALLOCS)
#define DEBUG_HEAP(F)      ((F & HEAP_DEBUG_FLAGS) && !(F & HEAP_SKIP_VALIDATION_CHECKS))
#define SET_LAST_STATUS(S) {NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError( NtCurrentTeb()->LastStatusValue = (ULONG)(S) );}

#endif // #ifdef NTOS_KERNEL_RUNTIME


//
//  Here are the macros used for debug printing and breakpoints
//

#ifdef NTOS_KERNEL_RUNTIME

#define HeapDebugPrint( _x_ ) {DbgPrint _x_;}

#define HeapDebugBreak( _x_ ) {if (KdDebuggerEnabled) DbgBreakPoint();}

#else // #ifdef NTOS_KERNEL_ROUTINE

#define HeapDebugPrint( _x_ )                                   \
{                                                               \
    PLIST_ENTRY _Module;                                        \
    PLDR_DATA_TABLE_ENTRY _Entry;                               \
                                                                \
    _Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink; \
    _Entry = CONTAINING_RECORD( _Module,                        \
                                LDR_DATA_TABLE_ENTRY,           \
                                InLoadOrderLinks);              \
    DbgPrint("HEAP[%wZ]: ", &_Entry->BaseDllName);              \
    DbgPrint _x_;                                               \
}

#define HeapDebugBreak( _x_ )                    \
{                                                \
    VOID RtlpBreakPointHeap( PVOID BadAddress ); \
                                                 \
    RtlpBreakPointHeap( (_x_) );                 \
}

#endif // #ifdef NTOS_KERNEL_RUNTIME

//
//  Virtual memory hook for virtual alloc functions
//

#ifdef NTOS_KERNEL_RUNTIME

#define RtlpHeapFreeVirtualMemory(P,A,S,F) \
    ZwFreeVirtualMemory(P,A,S,F)

#else // NTOS_KERNEL_RUNTIME

//
//  The user mode call needs to call the secmem virtual free
//  as well to update the memory counters per heap 
//

#define RtlpHeapFreeVirtualMemory(P,A,S,F)   \
    RtlpSecMemFreeVirtualMemory(P,A,S,F)

#endif // NTOS_KERNEL_RUNTIME



//
//  Implemented in heap.c
//

BOOLEAN
RtlpInitializeHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UnCommittedAddress,
    IN PVOID CommitLimitAddress
    );

PHEAP_FREE_ENTRY
RtlpCoalesceFreeBlocks (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN OUT PSIZE_T FreeSize,
    IN BOOLEAN RemoveFromFreeList
    );

VOID
RtlpDeCommitFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    );

VOID
RtlpInsertFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    );

PHEAP_FREE_ENTRY
RtlpFindAndCommitPages (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN OUT PSIZE_T Size,
    IN PVOID AddressWanted OPTIONAL
    );

PVOID
RtlAllocateHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlFreeHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

SIZE_T
RtlpGetSizeOfBigBlock (
    IN PHEAP_ENTRY BusyBlock
    );

PHEAP_ENTRY_EXTRA
RtlpGetExtraStuffPointer (
    PHEAP_ENTRY BusyBlock
    );

BOOLEAN
RtlpCheckBusyBlockTail (
    IN PHEAP_ENTRY BusyBlock
    );


//
//  Implemented in heapdll.c
//

VOID
RtlpAddHeapToProcessList (
    IN PHEAP Heap
    );

VOID
RtlpRemoveHeapFromProcessList (
    IN PHEAP Heap
    );

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    );

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    );

VOID
RtlDetectHeapLeaks();


//
//  Implemented in heapdbg.c
//

BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    );

BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    );

VOID
RtlpUpdateHeapListIndex (
    USHORT OldIndex,
    USHORT NewIndex
    );

BOOLEAN
RtlpValidateHeapHeaders(
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    );


#ifndef NTOS_KERNEL_RUNTIME

//
//  Nondedicated free list optimization
//

#if DBG

//
//  Define HEAP_VALIDATE_INDEX to activate a validation of the index
//  after each operation with non-dedicated list
//  This is only for debug-test, to make sure the list and index is consistent
//

//#define HEAP_VALIDATE_INDEX

#endif  // DBG


#define HEAP_FRONT_LOOKASIDE        1
#define HEAP_FRONT_LOWFRAGHEAP      2

#define RtlpGetLookasideHeap(H) \
    (((H)->FrontEndHeapType == HEAP_FRONT_LOOKASIDE) ? (H)->FrontEndHeap : NULL)
    
#define RtlpGetLowFragHeap(H) \
    (((H)->FrontEndHeapType == HEAP_FRONT_LOWFRAGHEAP) ? (H)->FrontEndHeap : NULL)

#define RtlpIsFrontHeapUnlocked(H)  \
    ((H)->FrontHeapLockCount == 0)

#define RtlpLockFrontHeap(H)            \
    {                                   \
        (H)->FrontHeapLockCount += 1;   \
    }

#define RtlpUnlockFrontHeap(H)          \
    {                                   \
        (H)->FrontHeapLockCount -= 1;   \
    }


#define HEAP_INDEX_THRESHOLD 32

//
//  Heap performance counter support
//

#define HEAP_OP_COUNT 2

#define HEAP_OP_ALLOC 0
#define HEAP_OP_FREE 1

//
//  The time / per operation is measured ones at 16 operations
//

#define HEAP_SAMPLING_MASK 0x000001FF

#define HEAP_SAMPLING_COUNT 100

typedef struct _HEAP_PERF_DATA {

    UINT64 CountFrequence;
    UINT64 OperationTime[HEAP_OP_COUNT];

    //
    //  The data bellow are only for sampling
    //

    ULONG  Sequence;

    UINT64 TempTime[HEAP_OP_COUNT];
    ULONG  TempCount[HEAP_OP_COUNT];

} HEAP_PERF_DATA, *PHEAP_PERF_DATA;

#define HEAP_PERF_DECLARE_TIMER()                                           \
    UINT64 _HeapPerfStartTimer, _HeapPerfEndTimer;                         

#define HEAP_PERF_START_TIMER(H)                                            \
{                                                                           \
    PHEAP_INDEX HeapIndex = (PHEAP_INDEX)(H)->LargeBlocksIndex;             \
    if ( (HeapIndex != NULL) &&                                             \
         (!((HeapIndex->PerfData.Sequence++) & HEAP_SAMPLING_MASK)) ) {     \
                                                                            \
        NtQueryPerformanceCounter( (PLARGE_INTEGER)&_HeapPerfStartTimer , NULL); \
    } else {                                                                     \
        _HeapPerfStartTimer = 0;                                                 \
    }                                                                            \
}

#define HEAP_PERF_STOP_TIMER(H,OP)                                              \
{                                                                               \
    if (_HeapPerfStartTimer) {                                                  \
        PHEAP_INDEX HeapIndex = (PHEAP_INDEX)(H)->LargeBlocksIndex;             \
                                                                                \
        NtQueryPerformanceCounter( (PLARGE_INTEGER)&_HeapPerfEndTimer , NULL);  \
        HeapIndex->PerfData.TempTime[OP] += (_HeapPerfEndTimer - _HeapPerfStartTimer);  \
                                                                                \
        if ((HeapIndex->PerfData.TempCount[OP]++) >= HEAP_SAMPLING_COUNT) {     \
            HeapIndex->PerfData.OperationTime[OP] = HeapIndex->PerfData.TempTime[OP] / (HeapIndex->PerfData.TempCount[OP] - 1);  \
                                                                                \
            HeapIndex->PerfData.TempCount[OP] = 0;                              \
            HeapIndex->PerfData.TempTime[OP] = 0;                               \
        }                                                                       \
    }                                                                           \
}                                                                               
                                                                                
#define RtlpRegisterOperation(H,S,Op)                               \
{                                                                   \
    PHEAP_LOOKASIDE Lookaside;                                      \
                                                                    \
    if ( (Lookaside = (PHEAP_LOOKASIDE)RtlpGetLookasideHeap(H)) ) { \
                                                                    \
        SIZE_T Index = (S) >> 10;                                   \
                                                                    \
        if (Index >= HEAP_MAXIMUM_FREELISTS) {                      \
                                                                    \
            Index = HEAP_MAXIMUM_FREELISTS - 1;                     \
        }                                                           \
                                                                    \
        Lookaside[Index].Counters[(Op)] += 1;                       \
    }                                                               \
}

//
//  The heap index structure
//

typedef struct _HEAP_INDEX {
    
    ULONG ArraySize;
    ULONG VirtualMemorySize;

    //
    //  The timing counters are available only on heaps
    //  with an index created
    //

    HEAP_PERF_DATA PerfData;

    LONG LargeBlocksCacheDepth;
    LONG LargeBlocksCacheMaxDepth;
    LONG LargeBlocksCacheMinDepth;
    LONG LargeBlocksCacheSequence;

    struct {

        ULONG Committs;
        ULONG Decommitts;
        LONG  LargestDepth;
        LONG  LargestRequiredDepth;

    } CacheStats;

    union {
        
        PULONG FreeListsInUseUlong;
        PUCHAR FreeListsInUseBytes;
    } u;

    PHEAP_FREE_ENTRY * FreeListHints;

} HEAP_INDEX, *PHEAP_INDEX;

//
//  Macro for setting a bit in the freelist vector to indicate entries are
//  present.
//

#define SET_INDEX_BIT( HeapIndex, AllocIndex )                        \
{                                                                     \
    ULONG _Index_;                                                    \
    ULONG _Bit_;                                                      \
                                                                      \
    _Index_ = (AllocIndex) >> 3;                                      \
    _Bit_ = (1 << ((AllocIndex) & 7));                                \
                                                                      \
    (HeapIndex)->u.FreeListsInUseBytes[ _Index_ ] |= _Bit_;           \
}

//
//  Macro for clearing a bit in the freelist vector to indicate entries are
//  not present.
//

#define CLEAR_INDEX_BIT( HeapIndex, AllocIndex )               \
{                                                              \
    ULONG _Index_;                                             \
    ULONG _Bit_;                                               \
                                                               \
    _Index_ = (AllocIndex) >> 3;                               \
    _Bit_ = (1 << ((AllocIndex) & 7));                         \
                                                               \
    (HeapIndex)->u.FreeListsInUseBytes[ _Index_ ] ^= _Bit_;    \
}

VOID
RtlpInitializeListIndex (
    IN PHEAP Heap
    );

PLIST_ENTRY
RtlpFindEntry (
    IN PHEAP Heap,
    IN ULONG Size
    );

VOID 
RtlpUpdateIndexRemoveBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeEntry
    );

VOID 
RtlpUpdateIndexInsertBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeEntry
    );

VOID 
RtlpFlushCacheContents (
    IN PHEAP Heap
    );

extern LONG RtlpSequenceNumberTest;

#define RtlpCheckLargeCache(H)                                              \
{                                                                           \
    PHEAP_INDEX HeapIndex = (PHEAP_INDEX)(H)->LargeBlocksIndex;             \
    if ((HeapIndex != NULL) &&                                              \
        (HeapIndex->LargeBlocksCacheSequence >= RtlpSequenceNumberTest)) {  \
                                                                            \
        RtlpFlushCacheContents(Heap);                                       \
    }                                                                       \
}

VOID 
RtlpFlushLargestCacheBlock (
    IN PHEAP Heap
    );

#ifdef HEAP_VALIDATE_INDEX

//
//  The validation code for index
//

BOOLEAN
RtlpValidateNonDedicatedList (
    IN PHEAP Heap
    );


#else // HEAP_VALIDATE_INDEX

#define RtlpValidateNonDedicatedList(H)

#endif // HEAP_VALIDATE_INDEX


#else  //  NTOS_KERNEL_RUNTIME

#define HEAP_PERF_DECLARE_TIMER()                                           

#define HEAP_PERF_START_TIMER(H)                                             

#define HEAP_PERF_STOP_TIMER(H,Op) 

#define RtlpRegisterOperation(H,S,Op)                              


#define RtlpInitializeListIndex(H)

#define RtlpFindEntry(H,S) (NULL)

#define RtlpUpdateIndexRemoveBlock(H,F)

#define RtlpUpdateIndexInsertBlock(H,F)

#define RtlpCheckLargeCache(H)

#define RtlpValidateNonDedicatedList(H)

#endif  // NTOS_KERNEL_RUNTIME


//
//  An extra bitmap manipulation routine
//

#define RtlFindFirstSetRightMember(Set)                     \
    (((Set) & 0xFFFF) ?                                     \
        (((Set) & 0xFF) ?                                   \
            RtlpBitsClearLow[(Set) & 0xFF] :                \
            RtlpBitsClearLow[((Set) >> 8) & 0xFF] + 8) :    \
        ((((Set) >> 16) & 0xFF) ?                           \
            RtlpBitsClearLow[ ((Set) >> 16) & 0xFF] + 16 :  \
            RtlpBitsClearLow[ (Set) >> 24] + 24)            \
    )


//
//  Macro for setting a bit in the freelist vector to indicate entries are
//  present.
//

#define SET_FREELIST_BIT( H, FB )                                     \
{                                                                     \
    ULONG _Index_;                                                    \
    ULONG _Bit_;                                                      \
                                                                      \
    HEAPASSERT((FB)->Size < HEAP_MAXIMUM_FREELISTS);                  \
                                                                      \
    _Index_ = (FB)->Size >> 3;                                        \
    _Bit_ = (1 << ((FB)->Size & 7));                                  \
                                                                      \
    HEAPASSERT(((H)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_) == 0); \
                                                                      \
    (H)->u.FreeListsInUseBytes[ _Index_ ] |= _Bit_;                   \
}

//
//  Macro for clearing a bit in the freelist vector to indicate entries are
//  not present.
//

#define CLEAR_FREELIST_BIT( H, FB )                            \
{                                                              \
    ULONG _Index_;                                             \
    ULONG _Bit_;                                               \
                                                               \
    HEAPASSERT((FB)->Size < HEAP_MAXIMUM_FREELISTS);           \
                                                               \
    _Index_ = (FB)->Size >> 3;                                 \
    _Bit_ = (1 << ((FB)->Size & 7));                           \
                                                               \
    HEAPASSERT((H)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_); \
    HEAPASSERT(IsListEmpty(&(H)->FreeLists[ (FB)->Size ]));    \
                                                               \
    (H)->u.FreeListsInUseBytes[ _Index_ ] ^= _Bit_;            \
}


//
//  This macro inserts a free block into the appropriate free list including
//  the [0] index list with entry filling if necessary
//

#define RtlpInsertFreeBlockDirect( H, FB, SIZE )                          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
    (FB)->Flags &= ~(HEAP_ENTRY_FILL_PATTERN |                            \
                     HEAP_ENTRY_EXTRA_PRESENT |                           \
                     HEAP_ENTRY_BUSY);                                    \
                                                                          \
    if ((H)->Flags & HEAP_FREE_CHECKING_ENABLED) {                        \
                                                                          \
        RtlFillMemoryUlong( (PCHAR)((FB) + 1),                            \
                            ((SIZE) << HEAP_GRANULARITY_SHIFT) -          \
                                sizeof( *(FB) ),                          \
                            FREE_HEAP_FILL );                             \
                                                                          \
        (FB)->Flags |= HEAP_ENTRY_FILL_PATTERN;                           \
    }                                                                     \
                                                                          \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                                \
                                                                          \
        _HEAD = &(H)->FreeLists[ (SIZE) ];                                \
                                                                          \
        if (IsListEmpty(_HEAD)) {                                         \
                                                                          \
            SET_FREELIST_BIT( H, FB );                                    \
        }                                                                 \
                                                                          \
    } else {                                                              \
                                                                          \
        _HEAD = &(H)->FreeLists[ 0 ];                                     \
        _NEXT = (H)->LargeBlocksIndex ?                                   \
                    RtlpFindEntry(H, SIZE) :                              \
                    _HEAD->Flink;                                         \
                                                                          \
        while (_HEAD != _NEXT) {                                          \
                                                                          \
            _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList ); \
                                                                          \
            if ((SIZE) <= _FB1->Size) {                                   \
                                                                          \
                break;                                                    \
                                                                          \
            } else {                                                      \
                                                                          \
                _NEXT = _NEXT->Flink;                                     \
            }                                                             \
        }                                                                 \
                                                                          \
        _HEAD = _NEXT;                                                    \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
    RtlpUpdateIndexInsertBlock(H, FB);                                    \
    RtlpValidateNonDedicatedList(H);                                      \
}

//
//  This version of RtlpInsertFreeBlockDirect does no filling.
//

#define RtlpFastInsertFreeBlockDirect( H, FB, SIZE )              \
{                                                                 \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                        \
                                                                  \
        RtlpFastInsertDedicatedFreeBlockDirect( H, FB, SIZE );    \
                                                                  \
    } else {                                                      \
                                                                  \
        RtlpFastInsertNonDedicatedFreeBlockDirect( H, FB, SIZE ); \
    }                                                             \
}

//
//  This version of RtlpInsertFreeBlockDirect only works for dedicated free
//  lists and doesn't do any filling.
//

#define RtlpFastInsertDedicatedFreeBlockDirect( H, FB, SIZE )             \
{                                                                         \
    PLIST_ENTRY _HEAD;                                                    \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
                                                                          \
    if (!((FB)->Flags & HEAP_ENTRY_LAST_ENTRY)) {                         \
                                                                          \
        HEAPASSERT(((PHEAP_ENTRY)(FB) + (SIZE))->PreviousSize == (SIZE)); \
    }                                                                     \
                                                                          \
    (FB)->Flags &= HEAP_ENTRY_LAST_ENTRY;                                 \
                                                                          \
    _HEAD = &(H)->FreeLists[ (SIZE) ];                                    \
                                                                          \
    if (IsListEmpty(_HEAD)) {                                             \
                                                                          \
        SET_FREELIST_BIT( H, FB );                                        \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

//
//  This version of RtlpInsertFreeBlockDirect only works for nondedicated free
//  lists and doesn't do any filling.
//

#define RtlpFastInsertNonDedicatedFreeBlockDirect( H, FB, SIZE )          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
                                                                          \
    if (!((FB)->Flags & HEAP_ENTRY_LAST_ENTRY)) {                         \
                                                                          \
        HEAPASSERT(((PHEAP_ENTRY)(FB) + (SIZE))->PreviousSize == (SIZE)); \
    }                                                                     \
                                                                          \
    (FB)->Flags &= (HEAP_ENTRY_LAST_ENTRY);                               \
                                                                          \
    _HEAD = &(H)->FreeLists[ 0 ];                                         \
    _NEXT = (H)->LargeBlocksIndex ?                                       \
                RtlpFindEntry(H, SIZE) :                                  \
                _HEAD->Flink;                                             \
                                                                          \
    while (_HEAD != _NEXT) {                                              \
                                                                          \
        _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList );     \
                                                                          \
        if ((SIZE) <= _FB1->Size) {                                       \
                                                                          \
            break;                                                        \
                                                                          \
        } else {                                                          \
                                                                          \
            _NEXT = _NEXT->Flink;                                         \
        }                                                                 \
    }                                                                     \
                                                                          \
    InsertTailList( _NEXT, &(FB)->FreeList );                             \
    RtlpUpdateIndexInsertBlock(H, FB);                                    \
    RtlpValidateNonDedicatedList(H);                                      \
}


//
//  This macro removes a block from its free list with fill checking if
//  necessary
//

#define RtlpRemoveFreeBlock( H, FB )                                              \
{                                                                                 \
    RtlpFastRemoveFreeBlock( H, FB )                                              \
                                                                                  \
    if ((FB)->Flags & HEAP_ENTRY_FILL_PATTERN) {                                  \
                                                                                  \
        SIZE_T cb, cbEqual;                                                       \
        PVOID p;                                                                  \
                                                                                  \
        cb = ((FB)->Size << HEAP_GRANULARITY_SHIFT) - sizeof( *(FB) );            \
                                                                                  \
        if ((FB)->Flags & HEAP_ENTRY_EXTRA_PRESENT &&                             \
            cb > sizeof( HEAP_FREE_ENTRY_EXTRA )) {                               \
                                                                                  \
            cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );                                \
        }                                                                         \
                                                                                  \
        cbEqual = RtlCompareMemoryUlong( (PCHAR)((FB) + 1),                       \
                                                 cb,                              \
                                                 FREE_HEAP_FILL );                \
                                                                                  \
        if (cbEqual != cb) {                                                      \
                                                                                  \
            HeapDebugPrint((                                                      \
                "HEAP: Free Heap block %lx modified at %lx after it was freed\n", \
                (FB),                                                             \
                (PCHAR)((FB) + 1) + cbEqual ));                                   \
                                                                                  \
            HeapDebugBreak((FB));                                                 \
        }                                                                         \
    }                                                                             \
}

//
//  This version of RtlpRemoveFreeBlock does no fill checking
//

#define RtlpFastRemoveFreeBlock( H, FB )         \
{                                                \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_Flink;                       \
    RtlpUpdateIndexRemoveBlock(H, FB);           \
                                                 \
    _EX_Flink = (FB)->FreeList.Flink;            \
    _EX_Blink = (FB)->FreeList.Blink;            \
                                                 \
    _EX_Blink->Flink = _EX_Flink;                \
    _EX_Flink->Blink = _EX_Blink;                \
                                                 \
    if ((_EX_Flink == _EX_Blink) &&              \
        ((FB)->Size < HEAP_MAXIMUM_FREELISTS)) { \
                                                 \
        CLEAR_FREELIST_BIT( H, FB );             \
    }                                            \
    RtlpValidateNonDedicatedList(H);             \
}

//
//  This version of RtlpRemoveFreeBlock only works for dedicated free lists
//  (where we know that (FB)->Mask != 0) and doesn't do any fill checking
//

#define RtlpFastRemoveDedicatedFreeBlock( H, FB ) \
{                                                 \
    PLIST_ENTRY _EX_Blink;                        \
    PLIST_ENTRY _EX_Flink;                        \
                                                  \
    _EX_Flink = (FB)->FreeList.Flink;             \
    _EX_Blink = (FB)->FreeList.Blink;             \
                                                  \
    _EX_Blink->Flink = _EX_Flink;                 \
    _EX_Flink->Blink = _EX_Blink;                 \
                                                  \
    if (_EX_Flink == _EX_Blink) {                 \
                                                  \
        CLEAR_FREELIST_BIT( H, FB );              \
    }                                             \
}

//
//  This version of RtlpRemoveFreeBlock only works for dedicated free lists
//  (where we know that (FB)->Mask == 0) and doesn't do any fill checking
//

#define RtlpFastRemoveNonDedicatedFreeBlock( H, FB ) \
{                                                    \
    RtlpUpdateIndexRemoveBlock(H, FB);               \
    RemoveEntryList(&(FB)->FreeList);                \
    RtlpValidateNonDedicatedList(H);                 \
}


//
//  Heap tagging routines implemented in heapdll.c
//

#if DBG

#define IS_HEAP_TAGGING_ENABLED() (TRUE)

#else

#define IS_HEAP_TAGGING_ENABLED() (RtlGetNtGlobalFlags() & FLG_HEAP_ENABLE_TAGGING)

#endif // DBG

//
//  ORDER IS IMPORTANT HERE...SEE RtlpUpdateTagEntry sources
//

typedef enum _HEAP_TAG_ACTION {

    AllocationAction,
    VirtualAllocationAction,
    FreeAction,
    VirtualFreeAction,
    ReAllocationAction,
    VirtualReAllocationAction

} HEAP_TAG_ACTION;

PWSTR
RtlpGetTagName (
    PHEAP Heap,
    USHORT TagIndex
    );

USHORT
RtlpUpdateTagEntry (
    PHEAP Heap,
    USHORT TagIndex,
    SIZE_T OldSize,      // Only valid for ReAllocation and Free actions
    SIZE_T NewSize,      // Only valid for ReAllocation and Allocation actions
    HEAP_TAG_ACTION Action
    );

VOID
RtlpResetTags (
    PHEAP Heap
    );

VOID
RtlpDestroyTags (
    PHEAP Heap
    );


//
// Define heap lookaside list allocation functions.
//

typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Counters[2];

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;

NTKERNELAPI
VOID
RtlpInitializeHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
RtlpDeleteHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    );

VOID
RtlpAdjustHeapLookasideDepth (
    IN PHEAP_LOOKASIDE Lookaside
    );

NTKERNELAPI
PVOID
RtlpAllocateFromHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    );

NTKERNELAPI
BOOLEAN
RtlpFreeToHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN PVOID Entry
    );

#ifndef NTOS_KERNEL_RUNTIME

//
//  Low Fragmentation Heap  data structures and internal APIs
//

//
//  The memory barrier exists on IA64 only
//

#if defined(_IA64_)

#define  RtlMemoryBarrier() __mf ()

#else // #if defined(_IA64_)

//
//  On x86 and AMD64 ignore the memory barrier
//

#define  RtlMemoryBarrier()

#endif  //  #if defined(_IA64_)

extern ULONG RtlpDisableHeapLookaside;

#define HEAP_ENABLE_LOW_FRAG_HEAP         8

typedef struct _BLOCK_ENTRY {
    
    HEAP_ENTRY;

    USHORT LinkOffset;
    USHORT Reserved2;

} BLOCK_ENTRY, *PBLOCK_ENTRY;


typedef struct _INTERLOCK_SEQ {

    union {

        struct {
            
            union {

                struct {

                    USHORT Depth;
                    USHORT FreeEntryOffset;
                };
                volatile ULONG OffsetAndDepth;
            };
            volatile ULONG  Sequence;
        };

        volatile LONGLONG Exchg;
    };

} INTERLOCK_SEQ, *PINTERLOCK_SEQ;

struct _HEAP_USERDATA_HEADER;

typedef struct _HEAP_SUBSEGMENT {
    
    PVOID Bucket;
    
    volatile struct _HEAP_USERDATA_HEADER * UserBlocks;
    
    INTERLOCK_SEQ AggregateExchg;

    union {

        struct {
            USHORT BlockSize;
            USHORT FreeThreshold;
            USHORT BlockCount;
            UCHAR  SizeIndex;
            UCHAR  AffinityIndex;
        };
        ULONG Alignment[2];
    };
    
    SINGLE_LIST_ENTRY SFreeListEntry;
    volatile ULONG Lock;

} HEAP_SUBSEGMENT, *PHEAP_SUBSEGMENT;
    
typedef struct _HEAP_USERDATA_HEADER {

    union {
        
        SINGLE_LIST_ENTRY SFreeListEntry;
        PHEAP_SUBSEGMENT SubSegment;
    };

    PVOID HeapHandle;

    ULONG_PTR SizeIndex;
    ULONG_PTR Signature;

} HEAP_USERDATA_HEADER, *PHEAP_USERDATA_HEADER;

#define HEAP_LFH_INDEX 0xFF
#define HEAP_LFH_IN_CONVERSION 0xFE

#define HEAP_NO_CACHE_BLOCK    0x800000
#define HEAP_LARGEST_LFH_BLOCK 0x4000
#define HEAP_LFH_USER_SIGNATURE  0xF0E0D0C0

#ifdef DISABLE_REGISTRY_TEST_HOOKS

#define RtlpIsLowFragHeapEnabled() FALSE

#else //DISABLE_REGISTRY_TEST_HOOKS

#define RtlpIsLowFragHeapEnabled()   \
    ((RtlpDisableHeapLookaside & HEAP_ENABLE_LOW_FRAG_HEAP) != 0)

#endif //DISABLE_REGISTRY_TEST_HOOKS


ULONG
FORCEINLINE
RtlpGetAllocationUnits(
    PHEAP Heap,
    PHEAP_ENTRY Block
    )
{

    PHEAP_SUBSEGMENT SubSegment = (PHEAP_SUBSEGMENT)Block->SubSegment;

    RtlMemoryBarrier();

    if (Block->SegmentIndex == HEAP_LFH_INDEX) {

        ULONG ReturnSize = *((volatile USHORT *)&SubSegment->BlockSize);
        
        //
        //  ISSUE: Workaround the x86 compiler bug which eliminates the second test
        //      if (Block->SegmentIndex == HEAP_LFH_INDEX)
        //

        #if !defined(_WIN64)
        _asm {

            nop
        }
        #endif

        RtlMemoryBarrier();

        if (Block->SegmentIndex == HEAP_LFH_INDEX) {

            return ReturnSize;
        }
    } 
    
    if (Block->SegmentIndex == HEAP_LFH_IN_CONVERSION) {

        //
        //  This should be a very rare case when this query is
        //  done in the small window when the conversion code sets the 
        //  Size & PrevSize fields.
        //

        RtlLockHeap(Heap);
        RtlUnlockHeap(Heap);

        //
        //  This makes sure the conversion completed, so we can grab the 
        //  block size like for a regular block
        //

    }

    return Block->Size;
}

VOID
FORCEINLINE
RtlpSetUnusedBytes(PHEAP Heap, PHEAP_ENTRY Block, SIZE_T UnusedBytes)
{                                                   
    if (UnusedBytes < 0xff) {                              
                                                    
        Block->UnusedBytes = (UCHAR)(UnusedBytes);             
                                                    
    } else {

        PSIZE_T UnusedBytesULong = (PSIZE_T)(Block + RtlpGetAllocationUnits(Heap, Block));

        UnusedBytesULong -= 1;                      
        Block->UnusedBytes = 0xff;                    
        *UnusedBytesULong = UnusedBytes;                   
    }                                               
}

SIZE_T
FORCEINLINE
RtlpGetUnusedBytes(PHEAP Heap, PHEAP_ENTRY Block)
{
    if (Block->UnusedBytes < 0xff) {

        return Block->UnusedBytes;
    
    } else {

        PSIZE_T UnusedBytesULong = (PSIZE_T)(Block + RtlpGetAllocationUnits(Heap, Block));
        UnusedBytesULong -= 1;                     

        return (*UnusedBytesULong);
    }
}

VOID
RtlpInitializeLowFragHeapManager();

HANDLE
FASTCALL
RtlpCreateLowFragHeap( 
    HANDLE Heap
    );

VOID
FASTCALL
RtlpDestroyLowFragHeap( 
    HANDLE LowFragHeapHandle
    );

PVOID
FASTCALL
RtlpLowFragHeapAlloc(
    HANDLE LowFragHeapHandle,
    SIZE_T BlockSize
    );

BOOLEAN
FASTCALL
RtlpLowFragHeapFree(
    HANDLE LowFragHeapHandle, 
    PVOID p
    );

NTSTATUS
RtlpActivateLowFragmentationHeap(
    IN PVOID HeapHandle
    );

#else  // NTOS_KERNEL_RUNTIME

//
//  The kernel mode heap does not ajdust the heap granularity
//  therefore the unused bytes always fit the UCHAR. 
//  No need to check for overflow here
//

ULONG
FORCEINLINE
RtlpGetAllocationUnits(
    PHEAP Heap,
    PHEAP_ENTRY Block
    )
{
    return Block->Size;
}

VOID
FORCEINLINE
RtlpSetUnusedBytes(PHEAP Heap, PHEAP_ENTRY Block, SIZE_T UnusedBytes)
{                                                   
    Block->UnusedBytes = (UCHAR)(UnusedBytes);             
}

SIZE_T
FORCEINLINE
RtlpGetUnusedBytes(PHEAP Heap, PHEAP_ENTRY Block)
{
    return Block->UnusedBytes;
}

#endif  // NTOS_KERNEL_RUNTIME

#endif // _RTL_HEAP_PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\imagedir.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Author:

    Steve Wood (stevewo) 18-Aug-1989

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include "ntrtlp.h"

#if defined(NTOS_KERNEL_RUNTIME)

VOID
RtlpTouchMemory(
    IN PVOID Address,
    IN ULONG Length
    );

VOID
RtlpMakeStackTraceDataPresentForImage(
    IN PVOID ImageBase
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,RtlpTouchMemory)
#pragma alloc_text(PAGE,RtlMakeStackTraceDataPresent)
#pragma alloc_text(PAGE,RtlpMakeStackTraceDataPresentForImage)
#endif
#endif

PIMAGE_NT_HEADERS
RtlImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
#if defined (BLDR_KERNEL_RUNTIME) || defined(NTOS_KERNEL_RUNTIME)
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

#if defined(NTOS_KERNEL_RUNTIME)
            if (Base < MM_HIGHEST_USER_ADDRESS) {
                if ((PVOID)NtHeaders >= MM_HIGHEST_USER_ADDRESS) {
                    return NULL;
                }
                if ((PVOID)((PCHAR)NtHeaders + sizeof (IMAGE_NT_HEADERS)) >= MM_HIGHEST_USER_ADDRESS) {
                    return NULL;
                }
            }
#endif

            if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                NtHeaders = NULL;
            }
        }
    }

    return NtHeaders;
#else
    return RtlpImageNtHeader( Base );
#endif
}


PIMAGE_SECTION_HEADER
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns a pointer to the
    section table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if ((ULONG)Address >= NtSection->VirtualAddress &&
            (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns the seek address
    of the data the Directory describes.

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = RtlSectionTableFromVirtualAddress( NtHeaders,
                                                   Base,
                                                   Address
                                                 );
    if (NtSection != NULL) {
        return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
    else {
        return( NULL );
        }
}


PVOID
RtlpImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

#if defined(NTOS_KERNEL_RUNTIME)
    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {
            return( NULL );
        }
    }
#endif

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( RtlAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
RtlpImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS64 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

#if defined(NTOS_KERNEL_RUNTIME)
    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {
            return( NULL );
        }
    }
#endif

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( RtlAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
RtlImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if (LDR_IS_DATAFILE(Base)) {
        Base = LDR_DATAFILE_TO_VIEW(Base);
        MappedAsImage = FALSE;
        }

    NtHeaders = RtlImageNtHeader(Base);

    if (!NtHeaders)
        return NULL;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (RtlpImageDirectoryEntryToData32(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS32)NtHeaders));
    } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (RtlpImageDirectoryEntryToData64(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS64)NtHeaders));
    } else {
        return (NULL);
    }
}

#if defined(NTOS_KERNEL_RUNTIME)

VOID
RtlMakeStackTraceDataPresent(
    VOID
    )

/*++

Routine Description:

    This function walks the loaded user-mode images and makes present the
    portions of the data necessary to support a kernel-debugger stack
    dump of the user-mode stack.

    N.B. The necessary pieces are merely touched to be brought in.  In a low
         memory situation, some of the previously-touched pages may be paged
         out in order for the new ones to be brought in.  This routine is
         not guaranteed to do anything useful, however it does more often than
         not.

Arguments:

    None.

Return value:

    None.

--*/

{
    PPEB peb;
    PLIST_ENTRY head;
    PLIST_ENTRY next;
    PVOID imageBase;
    ULONG imageCount;
    LDR_DATA_TABLE_ENTRY UNALIGNED *ldrDataTableEntry;

    RTL_PAGED_CODE();

    //
    // The image list is in user mode and is not to be trusted.  The
    // surrounding try/except block will guard against most forms of
    // list corruption.  imageCount is used to bail in finite time
    // in the event of a cyclic image list.
    //

    imageCount = 0;
    try {

        peb = NtCurrentPeb();
        head = &peb->Ldr->InLoadOrderModuleList;

        ProbeForReadSmallStructure( head,
                                    sizeof(LIST_ENTRY),
                                    PROBE_ALIGNMENT(LIST_ENTRY) );

        next = head;
        while (imageCount < 1000) {

            next = next->Flink;
            if (next == head) {
                break;
            }
            imageCount += 1;

            //
            // Locate the base address of the image
            //

            ldrDataTableEntry = CONTAINING_RECORD(next,
                                                  LDR_DATA_TABLE_ENTRY,
                                                  InLoadOrderLinks);

            ProbeForReadSmallStructure( ldrDataTableEntry,
                                        sizeof(LDR_DATA_TABLE_ENTRY),
                                        PROBE_ALIGNMENT(LDR_DATA_TABLE_ENTRY) );

            imageBase = ldrDataTableEntry->DllBase;
            ProbeForReadSmallStructure (imageBase, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

            //
            // Make the stack trace data present for this image.  Use a
            // seperate try/except block here so that subsequent images
            // will be processed in the event of a failure.
            //

            try {
                RtlpMakeStackTraceDataPresentForImage(imageBase);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }
}

VOID
RtlpMakeStackTraceDataPresentForImage(
    IN PVOID ImageBase
    )

/*++

Routine Description:

    This function attempts to make present the portions of an image necessary
    to support a kernel-debugger stack dump of the user-mode stack.

Arguments:

    ImageBase - Supplies the VA of the base of the image to process.

Return value:

    None.

--*/

{
    PVOID directory;
    ULONG directorySize;
    PIMAGE_RUNTIME_FUNCTION_ENTRY functionEntry;
    PIMAGE_RUNTIME_FUNCTION_ENTRY lastFunctionEntry;
    PCHAR imageBase;

#if defined(_IA64_)
    PUNWIND_INFO unwindInfo;
#endif

    RTL_PAGED_CODE();

    //
    // Make present the IMAGE_DIRECTORY_EXCEPTION section.
    //

    directory = RtlImageDirectoryEntryToData(ImageBase,
                                             TRUE,
                                             IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                             &directorySize);
    if (directory == NULL) {
        return;
    }

    RtlpTouchMemory(directory, directorySize);

#if defined(_IA64_)

    //
    // The IMAGE_DIRECTORY_EXCEPTION section is an array of
    // IMAGE_RUNTIME_FUNCTION_ENTRY structures.  Each function entry
    // refers, via UnwindInfoAddress (expressed as an image offset) to
    // an UNWIND_INFO structure.
    //
    // All UNWIND_INFO structures must be made present.
    //

    functionEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)directory;
    lastFunctionEntry = functionEntry +
        directorySize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);

    while (functionEntry < lastFunctionEntry) {

        unwindInfo = (PUNWIND_INFO)((PCHAR)ImageBase +
                        functionEntry->UnwindInfoAddress);

        //
        // An UNWIND_INFO structure consists of a fixed header plus
        // a variable-length portion.
        //

        RtlpTouchMemory(unwindInfo,
                        sizeof(UNWIND_INFO) +
                        unwindInfo->DataLength * sizeof(ULONGLONG));

        functionEntry += 1;
    }

    //
    // Make present the IMAGE_DIRECTORY_ENTRY_GLOBALPTR section.
    //

    directory = RtlImageDirectoryEntryToData(ImageBase,
                                             TRUE,
                                             IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                                             &directorySize);
    if (directory == NULL) {
        return;
    }

    RtlpTouchMemory(directory, directorySize);

#endif  // _IA64_
}

VOID
RtlpTouchMemory(
    IN PVOID Address,
    IN ULONG Length
    )
/*++

Routine Description:

    This function touches all of the pages within a given region.

Arguments:

    Address - Supplies the VA of the start of the image to make present.

    Length - Supplies the length, in bytes, of the image to make present.

Return value:

    None.

--*/
{
    PCHAR regionStart;
    PCHAR regionEnd;

    RTL_PAGED_CODE();

    regionStart = Address;
    regionEnd = regionStart + Length;

    while (regionStart < regionEnd) {
        *(volatile UCHAR *)regionStart;
        regionStart = PAGE_ALIGN(regionStart + PAGE_SIZE);
    }
}

#endif

#if !defined(NTOS_KERNEL_RUNTIME) && !defined(BLDR_KERNEL_RUNTIME)

PIMAGE_SECTION_HEADER
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The RVA was not found within any of the sections of the image.

    NON-NULL - Returns the pointer to the image section that contains
               the RVA

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}



PVOID
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (!ARGUMENT_PRESENT( LastRvaSection ) ||
        (NtSection = *LastRvaSection) == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = RtlImageRvaToSection( NtHeaders,
                                          Base,
                                          Rva
                                        );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\intbits.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    intbits.c

Abstract:

    This module contains routines to do interlocked bit manipulation

Author:

    Neill Clift  (NeillC)  12-May-2000

Environment:

    User and kernel mode.

Revision History:

    Rob Earhart (earhart) October 13, 2000
      Moved from Ex to Rtl

--*/

#include "ntrtlp.h"

#pragma hdrstop

#undef RtlInterlockedSetBits

NTKERNELAPI
ULONG
FASTCALL
RtlInterlockedSetBits (
    IN OUT PULONG Flags,
    IN ULONG Flag
    )
/*++

Routine Description:

    This function atomically sets the specified flags in the target

Arguments:

    Flags - Pointer to variable containing current mask.

    Flag  - Flags to set in target

Return Value:

    ULONG - Old value of mask before modification

--*/
{
    ULONG NewFlags, OldFlags;

    OldFlags = *Flags;
    NewFlags = OldFlags | Flag;
    while (NewFlags != OldFlags) {
        NewFlags = InterlockedCompareExchange ((PLONG) Flags, (LONG) NewFlags, (LONG) OldFlags);
        if (NewFlags == OldFlags) {
            break;
        }
        OldFlags = NewFlags;
        NewFlags |= Flag;
    }
    return OldFlags;
}

#undef RtlInterlockedClearBits

NTKERNELAPI
ULONG
FASTCALL
RtlInterlockedClearBits (
    IN OUT PULONG Flags,
    IN ULONG Flag
    )
/*++

Routine Description:

    This function atomically clears the specified flags in the target

Arguments:

    Flags - Pointer to variable containing current mask.

    Flag  - Flags to clear in target

Return Value:

    ULONG - Old value of mask before modification

--*/
{
    ULONG NewFlags, OldFlags;

    OldFlags = *Flags;
    NewFlags = OldFlags & ~Flag;
    while (NewFlags != OldFlags) {
        NewFlags = InterlockedCompareExchange ((PLONG) Flags, (LONG) NewFlags, (LONG) OldFlags);
        if (NewFlags == OldFlags) {
            break;
        }
        OldFlags = NewFlags;
        NewFlags &= ~Flag;
    }
    return OldFlags;
}

#undef RtlInterlockedSetClearBits

NTKERNELAPI
ULONG
FASTCALL
RtlInterlockedSetClearBits (
    IN OUT PULONG Flags,
    IN ULONG sFlag,
    IN ULONG cFlag
    )
/*++

Routine Description:

    This function atomically sets and clears the specified flags in the target

Arguments:

    Flags - Pointer to variable containing current mask.

    sFlag  - Flags to set in target

    CFlag  - Flags to clear in target

Return Value:

    ULONG - Old value of mask before modification

--*/
{
    ULONG NewFlags, OldFlags;

    OldFlags = *Flags;
    NewFlags = (OldFlags | sFlag) & ~cFlag;
    while (NewFlags != OldFlags) {
        NewFlags = InterlockedCompareExchange ((PLONG) Flags, (LONG) NewFlags, (LONG) OldFlags);
        if (NewFlags == OldFlags) {
            break;
        }
        OldFlags = NewFlags;
        NewFlags = (NewFlags | sFlag) & ~cFlag;
    }
    return OldFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\ldrreloc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

Author:

    Mike O'Leary (mikeol) 03-Feb-1992

Revision History:

--*/

#include "ntrtlp.h"

#if 0 // These are not actually used.
      // See also ntrtl.h, RtlUshortByteSwap, RtlUlongByteSwap, RtlUlonglongByteSwap.
//
// byte swapping macros (LE/BE) used for IA64 relocations
// source != destination
//

//#define SWAP_SHORT(_dst,_src)                                                  \
//   ((((unsigned char *)_dst)[1] = ((unsigned char *)_src)[0]),                 \
//    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[1]))

//#define SWAP_INT(_dst,_src)                                                    \
//   ((((unsigned char *)_dst)[3] = ((unsigned char *)_src)[0]),                 \
//    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[1]),                 \
//    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[2]),                 \
//    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[3]))

//#define SWAP_LONG_LONG(_dst,_src)                                              \
//   ((((unsigned char *)_dst)[7] = ((unsigned char *)_src)[0]),                 \
//    (((unsigned char *)_dst)[6] = ((unsigned char *)_src)[1]),                 \
//    (((unsigned char *)_dst)[5] = ((unsigned char *)_src)[2]),                 \
//    (((unsigned char *)_dst)[4] = ((unsigned char *)_src)[3]),                 \
//    (((unsigned char *)_dst)[3] = ((unsigned char *)_src)[4]),                 \
//    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[5]),                 \
//    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[6]),                 \
//    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[7]))

#endif

//
// Mark a HIGHADJ entry as needing an increment if reprocessing.
//
#define LDRP_RELOCATION_INCREMENT   0x1

//
// Mark a HIGHADJ entry as not suitable for reprocessing.
//
#define LDRP_RELOCATION_FINAL       0x2

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );

#if defined(NTOS_KERNEL_RUNTIME)

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,LdrRelocateImage)
#pragma alloc_text(PAGE,LdrRelocateImageWithBias)
#pragma alloc_text(PAGE,LdrProcessRelocationBlock)
#pragma alloc_text(PAGE,LdrProcessRelocationBlockLongLong)
#endif // ALLOC_PRAGMA

#if defined(_ALPHA_)

PIMAGE_BASE_RELOCATION
LdrpProcessVolatileRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff,
    IN LONG_PTR OldDiff,
    IN ULONG_PTR OldBase
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,LdrDoubleRelocateImage)
#pragma alloc_text(INIT,LdrpProcessVolatileRelocationBlock)
#endif // ALLOC_PRAGMA
#endif // _ALPHA_

#endif // NTOS_KERNEL_RUNTIME

#if defined(BLDR_KERNEL_RUNTIME)

typedef LDR_RELOCATE_IMAGE_RETURN_TYPE ARC_STATUS;

#else

typedef LDR_RELOCATE_IMAGE_RETURN_TYPE NTSTATUS;

#endif

LDR_RELOCATE_IMAGE_RETURN_TYPE
LdrRelocateImage (
    IN PVOID NewBase,
    IN CONST CHAR* LoaderName,
    IN LDR_RELOCATE_IMAGE_RETURN_TYPE Success,
    IN LDR_RELOCATE_IMAGE_RETURN_TYPE Conflict,
    IN LDR_RELOCATE_IMAGE_RETURN_TYPE Invalid
    )
/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    //
    // Just call LdrRelocateImageWithBias() with a zero bias.
    //

    return LdrRelocateImageWithBias( NewBase,
                                     0,
                                     LoaderName,
                                     Success,
                                     Conflict,
                                     Invalid );
}


LDR_RELOCATE_IMAGE_RETURN_TYPE
LdrRelocateImageWithBias (
    IN PVOID NewBase,
    IN LONGLONG AdditionalBias,
    IN CONST CHAR* LoaderName,
    IN LDR_RELOCATE_IMAGE_RETURN_TYPE Success,
    IN LDR_RELOCATE_IMAGE_RETURN_TYPE Conflict,
    IN LDR_RELOCATE_IMAGE_RETURN_TYPE Invalid
    )
/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    AdditionalBias - An additional quantity to add to all fixups.  The
                     32-bit X86 loader uses this when loading 64-bit images
                     to specify a NewBase that is actually a 64-bit value.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONGLONG Diff;
    ULONG TotalCountBytes = 0;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset = NULL;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;
    LDR_RELOCATE_IMAGE_RETURN_TYPE Status;

    RTL_PAGED_CODE();

    NtHeaders = RtlImageNtHeader( NewBase );
    if ( NtHeaders ) {
        OldBase = NtHeaders->OptionalHeader.ImageBase;
        }
    else {
        Status = Invalid;
        goto Exit;
        }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    //
    // It is possible for a file to have no relocations, but the relocations
    // must not have been stripped.
    //

    if (!NextBlock || !TotalCountBytes) {
    
        if (NtHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) {

#if DBG

            DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);

#endif // DBG

            Status = Conflict;

        } else {
            Status = Success;
        }

        goto Exit;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //
    Diff = (PCHAR)NewBase - (PCHAR)OldBase + AdditionalBias;
    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;

        if ( !(NextBlock = LdrProcessRelocationBlockLongLong( VA,
                                                              SizeOfBlock,
                                                              NextOffset,
                                                              Diff)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            Status = Invalid;
            goto Exit;
        }
    }

    Status = Success;
Exit:
    if (Status != Success) {
        DbgPrint(
            "%s: %s() failed 0x%lx\n"
            "%s: OldBase     : %p\n"
            "%s: NewBase     : %p\n"
            "%s: Diff        : 0x%I64x\n"
            "%s: NextOffset  : %p\n"
            "%s: *NextOffset : 0x%x\n"
            "%s: SizeOfBlock : 0x%lx\n",
            LoaderName, __FUNCTION__, Status,
            LoaderName, OldBase,
            LoaderName, NewBase,
            LoaderName, Diff,
            LoaderName, NextOffset,
            LoaderName, (NextOffset != NULL) ? *NextOffset : 0,
            LoaderName, SizeOfBlock
            );
#if DBG
        DbgBreakPoint();
#endif
    }
    return Status;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PIMAGE_BASE_RELOCATION baseRelocation;

    baseRelocation = LdrProcessRelocationBlockLongLong( VA,
                                                        SizeOfBlock,
                                                        NextOffset,
                                                        (LONGLONG)Diff );

    return baseRelocation;
}


PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlockLongLong(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    LONG TempOrig;
    ULONG Temp32;
    ULONGLONG Value64;
    LONGLONG Temp64;
    LONG_PTR ActualDiff;

    RTL_PAGED_CODE();

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

#if defined(NTOS_KERNEL_RUNTIME)
                //
                // If the address has already been relocated then don't
                // process it again now or information will be lost.
                //
                if (Offset & LDRP_RELOCATION_FINAL) {
                    ++NextOffset;
                    --SizeOfBlock;
                    break;
                }
#endif

                Temp = *(PUSHORT)FixupVA << 16;
#if defined(BLDR_KERNEL_RUNTIME)
                TempOrig = Temp;
#endif
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

#if defined(BLDR_KERNEL_RUNTIME)
                ActualDiff = ((((ULONG_PTR)(Temp - TempOrig)) >> 16) -
                              (((ULONG_PTR)Diff) >> 16 ));

                if (ActualDiff == 1) {
                    //
                    // Mark the relocation as needing an increment if it is
                    // relocated again.
                    //
                    *(NextOffset - 1) |= LDRP_RELOCATION_INCREMENT;
                }
                else if (ActualDiff != 0) {
                    //
                    // Mark the relocation as cannot be reprocessed.
                    //
                    *(NextOffset - 1) |= LDRP_RELOCATION_FINAL;
                }
#endif

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                FixupVA = (PUCHAR)((ULONG_PTR)FixupVA & ~(15));
                Value64 = (ULONGLONG)0;

                //
                // Extract the lower 32 bits of IMM64 from bundle
                //


                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);

                EXT_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                EXT_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                EXT_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                //
                // Update 64-bit address
                //

                Value64+=Diff;

                //
                // Insert IMM64 into bundle
                //

                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                break;

            case IMAGE_REL_BASED_DIR64:

                *(ULONGLONG UNALIGNED *)FixupVA += Diff;

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //
                Temp = (*(PULONG)FixupVA & 0x3ffffff) << 2;
                Temp += (ULONG) Diff;
                *(PULONG)FixupVA = (*(PULONG)FixupVA & ~0x3ffffff) |
                                                ((Temp >> 2) & 0x3ffffff);

                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

#if defined(NTOS_KERNEL_RUNTIME) && defined(_ALPHA_)

NTSTATUS
LdrDoubleRelocateImage (
    IN PVOID NewBase,
    IN PVOID CurrentBase,
    IN CONST CHAR* LoaderName,
    IN NTSTATUS Success,
    IN NTSTATUS Conflict,
    IN NTSTATUS Invalid
    )

/*++

Routine Description:

    This routine handles the volatile relocations that cannot be easily repeated
    on an image file that has already been relocated at least once.

    Since this only needs to be done once (at kernel startup time), the
    decision was made to split this into a separate routine so as not to
    impact the mainline code.

    N.B. This function is for use by memory management ONLY.

Arguments:

    NewBase - Supplies a pointer to the new (second relocated) image base.

    CurrentBase - Supplies a pointer to the first relocated image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    LONG_PTR OldDiff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    RTL_PAGED_CODE();

    NtHeaders = RtlImageNtHeader( NewBase );

    OldBase = NtHeaders->OptionalHeader.ImageBase;
    OldDiff = (PCHAR)CurrentBase - (PCHAR)OldBase;

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    Diff = (PCHAR)NewBase - (PCHAR)OldBase;

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;

        if ( !(NextBlock = LdrpProcessVolatileRelocationBlock(VA,SizeOfBlock,NextOffset,Diff, OldDiff, OldBase)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrpProcessVolatileRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff,
    IN LONG_PTR OldDiff,
    IN ULONG_PTR OldBase
    )

/*++

Routine Description:

    This routine handles the volatile relocations that cannot be easily repeated
    on an image file that has already been relocated at least once.

    Since this only needs to be done once (at kernel startup time), the
    decision was made to split this into a separate routine so as not to
    impact the mainline code.

    N.B. This function is for use by memory management ONLY.

Arguments:

    TBD.

Return Value:

    Next relocation entry to process.

--*/

{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG Temp32;
    USHORT TempShort1;
    USHORT TempShort2;
    ULONGLONG Value64;
    LONGLONG Temp64;
    USHORT RelocationType;
    IN PVOID CurrentBase;

    RTL_PAGED_CODE();

    CurrentBase = (PVOID)((ULONG_PTR)OldDiff + OldBase);

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                //
                // Return the relocation to its original state, checking for
                // whether the entry was sign extended the 1st time it was
                // relocated.
                //
                FixupVA = (PUCHAR)((LONG_PTR)FixupVA & (LONG_PTR)~(LDRP_RELOCATION_FINAL | LDRP_RELOCATION_INCREMENT));
                Temp = *(PUSHORT)(FixupVA) << 16;

                ++NextOffset;
                --SizeOfBlock;

                // remove the carry bit from the low word
                Temp -= ((LONG)(*(PSHORT)NextOffset) + (USHORT)OldDiff + 0x8000) & ~0xFFFF;

                Temp -= (LONG)(OldDiff & ~0xffff);

                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                //
                // Mark the relocation as needing no further reprocessing.
                //
                *(NextOffset - 1) |= LDRP_RELOCATION_FINAL;
                break;

            default :
               break;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

#endif // NTOS_KERNEL_RUNTIME && _ALPHA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\heappagi.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagi.h

Abstract:

    The following definitions are internal to the debug heap manager,
    but are placed in this include file so that debugger extensions
    can reference the same structure definitions.  The following
    definitions are not intended to be referenced externally except
    by debugger extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

//
// Stack trace size. 
//
                                
#define DPH_MAX_STACK_LENGTH   16

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// DPH_HEAP_BLOCK
//

typedef struct _DPH_HEAP_BLOCK DPH_HEAP_BLOCK, *PDPH_HEAP_BLOCK;

struct _DPH_HEAP_BLOCK {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_BLOCK pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

    PRTL_TRACE_BLOCK StackTrace;
};


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_BLOCK  pVirtualStorageListHead;
    PDPH_HEAP_BLOCK  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_BLOCK  pBusyAllocationListHead;
    PDPH_HEAP_BLOCK  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_BLOCK  pFreeAllocationListHead;
    PDPH_HEAP_BLOCK  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_BLOCK  pAvailableAllocationListHead;
    PDPH_HEAP_BLOCK  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_BLOCK  pUnusedNodeListHead;
    PDPH_HEAP_BLOCK  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_BLOCK  pNodePoolListHead;
    PDPH_HEAP_BLOCK  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    PDPH_HEAP_ROOT        pNextHeapRoot;
    PDPH_HEAP_ROOT        pPrevHeapRoot;

    ULONG                 nUnProtectionReferenceCount;
    ULONG                 InsideAllocateNode;           // only for debugging

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;

    //
    // Heap creation stack trace.
    //

    PRTL_TRACE_BLOCK      CreateStackTrace;

    //
    // Thread ID of the first thread inside the heap.
    //

    HANDLE FirstThread;
};


//
// DPH_BLOCK_INFORMATION
//
// This structure is stored in every page heap allocated block.
// This information is not saved if the catch backward overruns
// flag is set.
//

#define DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED   0xABCDAAAA
#define DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED     0xDCBAAAAA
#define DPH_NORMAL_BLOCK_START_STAMP_FREE        (0xABCDAAAA - 1)
#define DPH_NORMAL_BLOCK_END_STAMP_FREE          (0xDCBAAAAA - 1)

#define DPH_PAGE_BLOCK_START_STAMP_ALLOCATED     0xABCDBBBB
#define DPH_PAGE_BLOCK_END_STAMP_ALLOCATED       0xDCBABBBB
#define DPH_PAGE_BLOCK_START_STAMP_FREE          (0xABCDBBBB - 1)
#define DPH_PAGE_BLOCK_END_STAMP_FREE            (0xDCBABBBB - 1)

#define DPH_NORMAL_BLOCK_SUFFIX 	0xA0
#define DPH_PAGE_BLOCK_PREFIX 	    0xB0
#define DPH_PAGE_BLOCK_INFIX 	    0xC0
#define DPH_PAGE_BLOCK_SUFFIX 	    0xD0
#define DPH_NORMAL_BLOCK_INFIX 	    0xE0
#define DPH_FREE_BLOCK_INFIX 	    0xF0

typedef struct _DPH_BLOCK_INFORMATION {

    ULONG StartStamp;

    PVOID Heap;
    SIZE_T RequestedSize;
    SIZE_T ActualSize;

    union {
        LIST_ENTRY FreeQueue;
        USHORT TraceIndex;
    };

    PVOID StackTrace;
    
    ULONG EndStamp;

    //
    // (SilviuC): This structure needs to be 8-byte aligned.
    // If it is not, applications expecting aligned blocks will get
    // unaligned ones because this structure will prefix their
    // allocations. Internet Explorer is one such application
    // that stops working in these conditions.
    //

} DPH_BLOCK_INFORMATION, * PDPH_BLOCK_INFORMATION;

//
// Error reasons used in debug messages
//

#define DPH_SUCCESS                           0x0000
#define DPH_ERROR_CORRUPTED_START_STAMP       0x0001
#define DPH_ERROR_CORRUPTED_END_STAMP         0x0002
#define DPH_ERROR_CORRUPTED_HEAP_POINTER      0x0004
#define DPH_ERROR_CORRUPTED_PREFIX_PATTERN    0x0008
#define DPH_ERROR_CORRUPTED_SUFFIX_PATTERN    0x0010
#define DPH_ERROR_RAISED_EXCEPTION            0x0020
#define DPH_ERROR_NO_NORMAL_HEAP              0x0040
#define DPH_ERROR_CORRUPTED_INFIX_PATTERN     0x0080
#define DPH_ERROR_DOUBLE_FREE                 0x0100


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\ldrrsrc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name: 
 
    ldrrsrc.c

Abstract:

    Loader API calls for accessing resource sections.

Author:

    Steve Wood (stevewo) 16-Sep-1991

Revision History:

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,LdrAccessResource)
#pragma alloc_text(PAGE,LdrpAccessResourceData)
#pragma alloc_text(PAGE,LdrpAccessResourceDataNoMultipleLanguage)
#pragma alloc_text(PAGE,LdrFindEntryForAddress)
#pragma alloc_text(PAGE,LdrFindResource_U)
#pragma alloc_text(PAGE,LdrFindResourceEx_U)
#pragma alloc_text(PAGE,LdrFindResourceDirectory_U)
#pragma alloc_text(PAGE,LdrpCompareResourceNames_U)
#pragma alloc_text(PAGE,LdrpSearchResourceSection_U)
#pragma alloc_text(PAGE,LdrEnumResources)
#endif

#define USE_RC_CHECKSUM

// winuser.h
#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16) == 0)
#define RT_VERSION                         16
#define RT_MANIFEST                        24
#define CREATEPROCESS_MANIFEST_RESOURCE_ID  1
#define ISOLATIONAWARE_MANIFEST_RESOURCE_ID 2
#define MINIMUM_RESERVED_MANIFEST_RESOURCE_ID 1
#define MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID 16

#define LDRP_MIN(x,y) (((x)<(y)) ? (x) : (y))

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

#ifndef NTOS_KERNEL_RUNTIME
#include <md5.h>

//
// The size in byte of the resource MD5 checksum.  16 bytes = 128 bits.
//
#define RESOURCE_CHECKSUM_SIZE          16
//
// The registry key path which stores the file version information for MUI files.
//
#define REG_MUI_PATH                    L"Software\\Microsoft\\Windows\\CurrentVersion"
#define REG_MUI_RC_PATH                 L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\MUILanguages\\RC" 
#define MUI_MUILANGUAGES_KEY_NAME       L"MUILanguages"
#define MUI_FILE_VERSION_KEY_NAME       L"FileVersions"

#define MUI_ALTERNATE_VERSION_KEY       L"MUIVer"
#define MUI_RC_CHECKSUM_DISABLE_KEY     L"ChecksumDisable"

PALT_RESOURCE_MODULE AlternateResourceModules;
ULONG AlternateResourceModuleCount;
ULONG AltResMemBlockCount;
LANGID UILangId, InstallLangId;

#define DWORD_ALIGNMENT(x) (((x)+3) & ~3)
#define  MEMBLOCKSIZE 16
#define  RESMODSIZE sizeof(ALT_RESOURCE_MODULE)

#define uint32 unsigned int

#define ENG_US_LANGID  MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US )

#endif

#if defined(_X86_) && !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
// appcompat: There's some code that depends on the Win2k instruction stream - duplicate it here.
__declspec(naked)
#endif
NTSTATUS
LdrAccessResource(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceDataEntry - Supplies a pointer to the resource data entry in
        the resource data section of the image file specified by the
        DllHandle parameter.  This pointer should have been one returned
        by the LdrFindResource function.

    Address - Optional pointer to a variable that will receive the
        address of the resource specified by the first two parameters.

    Size - Optional pointer to a variable that will receive the size of
        the resource specified by the first two parameters.

Return Value:

    TBD

--*/

{
#if defined(_X86_) && !defined(BLDR_KERNEL_RUNTIME) && !defined(NTOS_KERNEL_RUNTIME)
    __asm {
        push [esp+0x10]       // Size
        push [esp+0x10]       // Address
        push [esp+0x10]       // ResourceDataEntry
        push [esp+0x10]       // DllHandle
        call LdrpAccessResourceData
        ret  16
    }
#else

    NTSTATUS Status;
    RTL_PAGED_CODE();

    Status =
        LdrpAccessResourceData(
          DllHandle,
          ResourceDataEntry,
          Address,
          Size
          );

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
    return Status;
#endif
}

NTSTATUS
LdrpAccessResourceDataNoMultipleLanguage(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    )

/*++

Routine Description:

    This function returns the data necessary to actually examine the
    contents of a particular resource, without allowing for the .mui
    feature. It used to be the tail of LdrpAccessResourceData, from
    which it is now called.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceDataEntry - Supplies a pointer to the resource data entry in
        the resource data directory of the image file specified by the
        DllHandle parameter.  This pointer should have been one returned
        by the LdrFindResource function.

    Address - Optional pointer to a variable that will receive the
        address of the resource specified by the first two parameters.

    Size - Optional pointer to a variable that will receive the size of
        the resource specified by the first two parameters.


Return Value:

    TBD

--*/

{
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG_PTR VirtualAddressOffset;
    PIMAGE_SECTION_HEADER NtSection;
    NTSTATUS Status = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    try {
        ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(DllHandle,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &ResourceSize
                                         );
        if (!ResourceDirectory) {
            return STATUS_RESOURCE_DATA_NOT_FOUND;
        }

        if (LDR_IS_DATAFILE(DllHandle)) {
            ULONG ResourceRVA;
            DllHandle = LDR_DATAFILE_TO_VIEW(DllHandle);
            NtHeaders = RtlImageNtHeader( DllHandle );
            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                ResourceRVA=((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
            } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                ResourceRVA=((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_RESOURCE ].VirtualAddress;
            } else {
                ResourceRVA = 0;
            }

            if (!ResourceRVA) {
                return STATUS_RESOURCE_DATA_NOT_FOUND;
                }

            VirtualAddressOffset = (ULONG_PTR)DllHandle + ResourceRVA - (ULONG_PTR)ResourceDirectory;

            //
            // Now, we must check to see if the resource is not in the
            // same section as the resource table.  If it's in .rsrc1,
            // we've got to adjust the RVA in the ResourceDataEntry
            // to point to the correct place in the non-VA data file.
            //
            NtSection = RtlSectionTableFromVirtualAddress( NtHeaders, DllHandle, ResourceRVA);

            if (!NtSection) {
                return STATUS_RESOURCE_DATA_NOT_FOUND;
            }

            if ( ResourceDataEntry->OffsetToData > NtSection->Misc.VirtualSize ) {
                ULONG rva;

                rva = NtSection->VirtualAddress;
                NtSection = RtlSectionTableFromVirtualAddress(NtHeaders,
                                                             DllHandle,
                                                             ResourceDataEntry->OffsetToData
                                                             );
                if (!NtSection) {
                    return STATUS_RESOURCE_DATA_NOT_FOUND;
                }
                VirtualAddressOffset +=
                        ((ULONG_PTR)NtSection->VirtualAddress - rva) -
                        ((ULONG_PTR)RtlAddressInSectionTable ( NtHeaders, DllHandle, NtSection->VirtualAddress ) - (ULONG_PTR)ResourceDirectory);
            }
        } else {
            VirtualAddressOffset = 0;
        }

        if (ARGUMENT_PRESENT( Address )) {
            *Address = (PVOID)( (PCHAR)DllHandle +
                                (ResourceDataEntry->OffsetToData - VirtualAddressOffset)
                              );
        }

        if (ARGUMENT_PRESENT( Size )) {
            *Size = ResourceDataEntry->Size;
        }

    }    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
    return Status;
}


NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    )

/*++

Routine Description:

    This function returns the data necessary to actually examine the
    contents of a particular resource.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceDataEntry - Supplies a pointer to the resource data entry in
   the resource data directory of the image file specified by the
        DllHandle parameter.  This pointer should have been one returned
        by the LdrFindResource function.

    Address - Optional pointer to a variable that will receive the
        address of the resource specified by the first two parameters.

    Size - Optional pointer to a variable that will receive the size of
        the resource specified by the first two parameters.


Return Value:

    TBD

--*/

{
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS Status = STATUS_SUCCESS;

    RTL_PAGED_CODE();

#ifndef NTOS_KERNEL_RUNTIME
    ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData(DllHandle,
                                     TRUE,
                                     IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                     &ResourceSize
                                     );
    if (!ResourceDirectory) {
        Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        goto Exit;
    }

    if ((ULONG_PTR)ResourceDataEntry < (ULONG_PTR) ResourceDirectory ){
        DllHandle = LdrLoadAlternateResourceModule (DllHandle, NULL);
    } else{
        NtHeaders = RtlImageNtHeader(LDR_DATAFILE_TO_VIEW(DllHandle));
        if (NtHeaders) {
            // Find the bounds of the image so we can see if this resource entry is in an alternate
            // resource dll.

            ULONG_PTR ImageStart = (ULONG_PTR)LDR_DATAFILE_TO_VIEW(DllHandle);
            SIZE_T ImageSize = 0;

            if (LDR_IS_DATAFILE(DllHandle)) {
                // mapped as datafile.  Ask mm for the size
                NTSTATUS Status;
                MEMORY_BASIC_INFORMATION MemInfo;

                Status = NtQueryVirtualMemory(
                            NtCurrentProcess(),
                            (PVOID) ImageStart,
                            MemoryBasicInformation,
                            &MemInfo,
                            sizeof(MemInfo),
                            NULL
                            );

                if ( !NT_SUCCESS(Status) ) {
                    ImageSize = 0;
                } else {
                    ImageSize = MemInfo.RegionSize;
                }
            } else {
                ImageSize = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.SizeOfImage;
            }

            if (!(((ULONG_PTR)ResourceDataEntry >= ImageStart) && ((ULONG_PTR)ResourceDataEntry < (ImageStart + ImageSize)))) {
                // Doesn't fall within the specified image.  Must be an alternate dll.
                DllHandle = LdrLoadAlternateResourceModule (DllHandle, NULL);
            }
        }
    }

    if (!DllHandle){
        Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        goto Exit;
    }
#endif

    Status =
        LdrpAccessResourceDataNoMultipleLanguage(
            DllHandle,
            ResourceDataEntry,
            Address,
            Size
            );

#ifndef NTOS_KERNEL_RUNTIME
Exit:
#endif
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
    return Status;
}


NTSTATUS
LdrFindEntryForAddress(
    IN PVOID Address,
    OUT PLDR_DATA_TABLE_ENTRY *TableEntry
    )
/*++

Routine Description:

    This function returns the load data table entry that describes the virtual
    address range that contains the passed virtual address.

Arguments:

    Address - Supplies a 32-bit virtual address.

    TableEntry - Supplies a pointer to the variable that will receive the
        address of the loader data table entry.


Return Value:

    Status

--*/
{
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY Head, Next;
    PLDR_DATA_TABLE_ENTRY Entry;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID ImageBase;
    PVOID EndOfImage;
    NTSTATUS Status;

    Ldr = NtCurrentPeb()->Ldr;
    if (Ldr == NULL) {
        Status = STATUS_NO_MORE_ENTRIES;
        goto Exit;
        }

    Entry = (PLDR_DATA_TABLE_ENTRY) Ldr->EntryInProgress;
    if (Entry != NULL) {
        NtHeaders = RtlImageNtHeader( Entry->DllBase );
        if (NtHeaders != NULL) {
            ImageBase = (PVOID)Entry->DllBase;

            EndOfImage = (PVOID)
                ((ULONG_PTR)ImageBase + NtHeaders->OptionalHeader.SizeOfImage);

            if ((ULONG_PTR)Address >= (ULONG_PTR)ImageBase && (ULONG_PTR)Address < (ULONG_PTR)EndOfImage) {
                *TableEntry = Entry;
                Status = STATUS_SUCCESS;
                goto Exit;
                }
            }
        }

    Head = &Ldr->InMemoryOrderModuleList;
    Next = Head->Flink;
    while ( Next != Head ) {
        Entry = CONTAINING_RECORD( Next, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks );

        NtHeaders = RtlImageNtHeader( Entry->DllBase );
        if (NtHeaders != NULL) {
            ImageBase = (PVOID)Entry->DllBase;

            EndOfImage = (PVOID)
                ((ULONG_PTR)ImageBase + NtHeaders->OptionalHeader.SizeOfImage);

            if ((ULONG_PTR)Address >= (ULONG_PTR)ImageBase && (ULONG_PTR)Address < (ULONG_PTR)EndOfImage) {
                *TableEntry = Entry;
                Status = STATUS_SUCCESS;
                goto Exit;
                }
            }

        Next = Next->Flink;
        }

    Status = STATUS_NO_MORE_ENTRIES;
Exit:
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    }
    return( Status );
}


NTSTATUS
LdrFindResource_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a STRING structure that specifies a resource name.  The array
        is used to traverse the directory structure contained in the
        resource section in the image file specified by the DllHandle
        parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    ResourceDataEntry - Supplies a pointer to a variable that will
        receive the address of the resource data entry in the resource
        data section of the image file specified by the DllHandle
        parameter.

Return Value:

    TBD

--*/

{
    RTL_PAGED_CODE();

    return LdrpSearchResourceSection_U(
      DllHandle,
      ResourceIdPath,
      ResourceIdPathLength,
      0,                // Look for a leaf node, ineaxt lang match
      (PVOID *)ResourceDataEntry
      );
}

NTSTATUS
LdrFindResourceEx_U(
    IN ULONG Flags,
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:
    Flags -
        LDRP_FIND_RESOURCE_DIRECTORY        
        searching for a resource directory, otherwise the caller is
        searching for a resource data entry.
        
        LDR_FIND_RESOURCE_LANGUAGE_EXACT                
        searching for a resource with, and only with, the language id
        specified in ResourceIdPath, otherwise the caller wants the routine
        to come up with default when specified langid is not found.
        
        LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION
        searching for a resource version in both main and alternative 
        module paths

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a STRING structure that specifies a resource name.  The array
        is used to traverse the directory structure contained in the
        resource section in the image file specified by the DllHandle
        parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    ResourceDataEntry - Supplies a pointer to a variable that will
        receive the address of the resource data entry in the resource
        data section of the image file specified by the DllHandle
        parameter.

Return Value:

    TBD

--*/

{
    RTL_PAGED_CODE();

    return LdrpSearchResourceSection_U(
      DllHandle,
      ResourceIdPath,
      ResourceIdPathLength,
      Flags,
      (PVOID *)ResourceDataEntry
      );
}



NTSTATUS
LdrFindResourceDirectory_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory
    )

/*++

Routine Description:

    This function locates the address of the specified resource directory in
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource
        directory is contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a STRING structure that specifies a resource name.  The array
        is used to traverse the directory structure contained in the
        resource section in the image file specified by the DllHandle
        parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    ResourceDirectory - Supplies a pointer to a variable that will
        receive the address of the resource directory specified by
        ResourceIdPath in the resource data section of the image file
        the DllHandle parameter.

Return Value:

    TBD

--*/

{
    RTL_PAGED_CODE();

    return LdrpSearchResourceSection_U(
      DllHandle,
      ResourceIdPath,
      ResourceIdPathLength,
      LDRP_FIND_RESOURCE_DIRECTORY,                 // Look for a directory node
      (PVOID *)ResourceDirectory
      );
}


LONG
LdrpCompareResourceNames_U(
    IN ULONG_PTR ResourceName,
    IN const IMAGE_RESOURCE_DIRECTORY* ResourceDirectory,
    IN const IMAGE_RESOURCE_DIRECTORY_ENTRY* ResourceDirectoryEntry
    )
{
    LONG li;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;

    if (ResourceName & LDR_RESOURCE_ID_NAME_MASK) {
        if (!ResourceDirectoryEntry->NameIsString) {
            return( -1 );
            }

        ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
            ((PCHAR)ResourceDirectory + ResourceDirectoryEntry->NameOffset);

        li = wcsncmp( (LPWSTR)ResourceName,
            ResourceNameString->NameString,
            ResourceNameString->Length
          );

        if (!li && wcslen((PWSTR)ResourceName) != ResourceNameString->Length) {
       return( 1 );
       }

   return(li);
        }
    else {
        if (ResourceDirectoryEntry->NameIsString) {
            return( 1 );
            }

        return( (ULONG)(ResourceName - ResourceDirectoryEntry->Name) );
        }
}

// Language ids are 16bits so any value with any bits
// set above 16 should be ok, and this value only has
// to fit in a ULONG_PTR. 0x10000 should be sufficient.
// The value used is actually 0xFFFF regardless of 32bit or 64bit,
// I guess assuming this is not an actual langid, which it isn't,
// due to the relatively small number of languages, around 70.
#define  USE_FIRSTAVAILABLE_LANGID   (0xFFFFFFFF & ~LDR_RESOURCE_ID_NAME_MASK)

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN ULONG Flags,
    OUT PVOID *ResourceDirectoryOrData
    )

/*++

Routine Description:

    This function locates the address of the specified resource in the
    specified DLL and returns its address.

Arguments:

    DllHandle - Supplies a handle to the image file that the resource is
        contained in.

    ResourceIdPath - Supplies a pointer to an array of 32-bit resource
        identifiers.  Each identifier is either an integer or a pointer
        to a null terminated string (PSZ) that specifies a resource
        name.  The array is used to traverse the directory structure
        contained in the resource section in the image file specified by
        the DllHandle parameter.

    ResourceIdPathLength - Supplies the number of elements in the
        ResourceIdPath array.

    Flags -
        LDRP_FIND_RESOURCE_DIRECTORY        
        searching for a resource directory, otherwise the caller is
        searching for a resource data entry.
        
        LDR_FIND_RESOURCE_LANGUAGE_EXACT                
        searching for a resource with, and only with, the language id
        specified in ResourceIdPath, otherwise the caller wants the routine
        to come up with default when specified langid is not found.
        
        LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION
        searching for a resource version in main and alternative 
        modules paths

    FindDirectoryEntry - Supplies a boolean that is TRUE if caller is
        searching for a resource directory, otherwise the caller is
        searching for a resource data entry.

    ExactLangMatchOnly - Supplies a boolean that is TRUE if caller is
        searching for a resource with, and only with, the language id
        specified in ResourceIdPath, otherwise the caller wants the routine
        to come up with default when specified langid is not found.

    ResourceDirectoryOrData - Supplies a pointer to a variable that will
        receive the address of the resource directory or data entry in
        the resource data section of the image file specified by the
        DllHandle parameter.

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    PIMAGE_RESOURCE_DIRECTORY LanguageResourceDirectory, ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirEntLow;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirEntMiddle;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirEntHigh;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceEntry;
    USHORT n, half;
    LONG dir;
    ULONG size;
    ULONG_PTR ResourceIdRetry;
    ULONG RetryCount;
    LANGID NewLangId;
    const ULONG_PTR* IdPath = ResourceIdPath;
    ULONG IdPathLength = ResourceIdPathLength;
    BOOLEAN fIsNeutral = FALSE;
    LANGID GivenLanguage;
#ifndef NTOS_KERNEL_RUNTIME
    LCID DefaultThreadLocale, DefaultSystemLocale;
    PVOID AltResourceDllHandle = NULL;
    ULONG_PTR UIResourceIdPath[3];
#endif

    RTL_PAGED_CODE();

    try {
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(DllHandle,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &size
                                         );
        if (!TopResourceDirectory) {
            return( STATUS_RESOURCE_DATA_NOT_FOUND );
        }

        ResourceDirectory = TopResourceDirectory;
        ResourceIdRetry = USE_FIRSTAVAILABLE_LANGID;
        RetryCount = 0;
        ResourceEntry = NULL;
        LanguageResourceDirectory = NULL;
        while (ResourceDirectory != NULL && ResourceIdPathLength--) {
            //
            // If search path includes a language id, then attempt to
            // match the following language ids in this order:
            //
            //   (0)  use given language id
            //   (1)  use primary language of given language id
            //   (2)  use id 0  (neutral resource)
            //   (3)  use thread language id for console app
            //
            // If the PRIMARY language id is ZERO, then ALSO attempt to
            // match the following language ids in this order:
            //
            //   (4)  use user UI language
            //   (5)  use lang id of TEB for windows app if it is different from user locale
            //   (6)  use UI lang from exe resource
            //   (7)  use primary UI lang from exe resource
            //   (8)  use Install Language
            //   (9)  use lang id from user's locale id
            //   (10)  use primary language of user's locale id
            //   (11) use lang id from system default locale id
            //   (12) use lang id of system default locale id
            //   (13) use primary language of system default locale id
            //   (14) use US English lang id
            //   (15) use any lang id that matches requested info
            //
            if (ResourceIdPathLength == 0 && IdPathLength == 3) {
                LanguageResourceDirectory = ResourceDirectory;
                }

            if (LanguageResourceDirectory != NULL) {
                GivenLanguage = (LANGID)IdPath[ 2 ];
                fIsNeutral = (PRIMARYLANGID( GivenLanguage ) == LANG_NEUTRAL);
TryNextLangId:
                switch( RetryCount++ ) {
#ifdef NTOS_KERNEL_RUNTIME
                    case 0:     // Use given language id
                        NewLangId = GivenLanguage;
                        break;

                    case 1:     // Use primary language of given language id
                        NewLangId = PRIMARYLANGID( GivenLanguage );
                        break;

                    case 2:     // Use id 0  (neutral resource)
                        NewLangId = 0;
                        break;

                    case 3:     // Use user's default UI language
                        NewLangId = (LANGID)ResourceIdRetry;
                        break;

                    case 4:     // Use native UI language
                        if ( !fIsNeutral ) {
                            // Stop looking - Not in the neutral case
                            goto ReturnFailure;
                            break;
                        }
                        NewLangId = PsInstallUILanguageId;
                        break;

                    case 5:     // Use default system locale
                        NewLangId = LANGIDFROMLCID(PsDefaultSystemLocaleId);
                        break;

                    case 6:
                        // Use US English language
                        NewLangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
                        break;

                    case 7:     // Take any lang id that matches
                        NewLangId = USE_FIRSTAVAILABLE_LANGID;
                        break;

#else
                    case 0:     // Use given language id
                        NewLangId = GivenLanguage;
                        break;

                    case 1:     // Use primary language of given language id
                        if ( Flags & LDR_FIND_RESOURCE_LANGUAGE_EXACT) {
                            //
                            //  Did not find an exact language match.
                            //  Stop looking.
                            //
                            goto ReturnFailure;
                        }
                        NewLangId = PRIMARYLANGID( GivenLanguage );
                        break;

                    case 2:     // Use id 0  (neutral resource)
                        NewLangId = 0;
                        break;

                    case 3:     
                        
                        if ( !fIsNeutral ) {
                            // Stop looking - Not in the neutral case
                            NewLangId = (LANGID)ResourceIdRetry;
                            break;
                        }
                        // Use thread langid if caller is a console app
                        if (NtCurrentPeb()->ProcessParameters->ConsoleHandle)
                        {
                            NewLangId = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);
                        }
                        else
                        {
                            NewLangId = (LANGID)ResourceIdRetry;
                        }
                        break;

                    case 4:     // Use user's default UI language
                        if (!UILangId || NtCurrentTeb()->ImpersonationLocale){
                            Status = NtQueryDefaultUILanguage( &UILangId );
                            if (!NT_SUCCESS( Status )) {
                                //
                                // Failed reading key.  Skip this lookup.
                                //
                                NewLangId = (LANGID)ResourceIdRetry;
                                break;
                            }
                        }

                        if (NtCurrentPeb()->ProcessParameters->ConsoleHandle &&
                            LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale) != UILangId)
                        {
                            NewLangId = (LANGID)ResourceIdRetry;
                            break;
                        }

                        NewLangId = UILangId;

                        //
                        // Arabic/Hebrew MUI files may contain resources with LANG ID different than 401/40d.
                        // e.g. Comdlg32.dll has two sets of Arabic/Hebrew resources one mirrored (401/40d)
                        // and one flipped (801/80d).
                        //
                        if( !fIsNeutral &&
                            ((PRIMARYLANGID (GivenLanguage) == LANG_ARABIC) || (PRIMARYLANGID (GivenLanguage) == LANG_HEBREW)) &&
                            (PRIMARYLANGID (GivenLanguage) == PRIMARYLANGID (NewLangId))
                          ) {
                            NewLangId = GivenLanguage;
                        }

                        //
                        // Bug #246044 WeiWu 12/07/00
                        // BiDi modules use version block FileDescription field to store LRM markers, 
                        // LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION will allow lpk.dll to get version resource from MUI alternative modules.
                        //
                        if ((IdPath[0] != RT_VERSION) ||
                            (Flags & LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION)) {                          
                            //
                            //  Load alternate resource dll when:
                            //      1. language is neutral
                            //         or 
                            //         Given language is not tried.
                            //      and
                            //      2. the resource to load is not a version info.
                            //
                            AltResourceDllHandle=LdrLoadAlternateResourceModule(
                                                    DllHandle,
                                                    NULL);

                            if (!AltResourceDllHandle){
                                //
                                //  Alternate resource dll not available.
                                //  Skip this lookup.
                                //
                                NewLangId = (LANGID)ResourceIdRetry;
                                break;

                            }

                            //
                            //  Map to alternate resource dll and search
                            //  it instead.
                            //

                            UIResourceIdPath[0]=IdPath[0];
                            UIResourceIdPath[1]=IdPath[1];
                            UIResourceIdPath[2]=NewLangId;

                            Status = LdrpSearchResourceSection_U(
                                        AltResourceDllHandle,
                                        UIResourceIdPath,
                                        3,
                                        Flags | LDR_FIND_RESOURCE_LANGUAGE_EXACT,
                                        (PVOID *)ResourceDirectoryOrData
                                        );

                            if (NT_SUCCESS(Status)){
                                //
                                // We sucessfully found alternate resource,
                                // return it.
                                //
                                return Status;
                            }


                        }
                        //
                        //  Caller does not want alternate resource, or
                        //  alternate resource not found.
                        //
                        NewLangId = (LANGID)ResourceIdRetry;
                        break;

                    case 5:     // Use langid of the thread locale if caller is a Windows app and thread locale is different from user locale
                        if ( !fIsNeutral ) {
                            // Stop looking - Not in the neutral case
                            goto ReturnFailure;
                            break;
                        }

                        if (!NtCurrentPeb()->ProcessParameters->ConsoleHandle && NtCurrentTeb()){
                            Status = NtQueryDefaultLocale(
                                        TRUE,
                                        &DefaultThreadLocale
                                        );
                            if (NT_SUCCESS( Status ) &&
                                DefaultThreadLocale !=
                                NtCurrentTeb()->CurrentLocale) {
                                //
                                // Thread locale is different from
                                // default locale.
                                //
                                NewLangId = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);
                                break;
                            }
                        }


                        NewLangId = (LANGID)ResourceIdRetry;
                        break;

                    case 6:   // UI language from the executable resource

                        if (!UILangId){
                            NewLangId = (LANGID)ResourceIdRetry;
                        } else {
                            NewLangId = UILangId;
                        }
                        break;

                    case 7:   // Parimary lang of UI language from the executable resource

                        if (!UILangId){
                            NewLangId = (LANGID)ResourceIdRetry;
                        } else {
                            NewLangId = PRIMARYLANGID( (LANGID) UILangId );
                        }
                        break;

                    case 8:   // Use install -native- language
                        //
                        // Thread locale is the same as the user locale, then let's
                        // try loading the native (install) ui language resources.
                        //
                        if (!InstallLangId){
                            Status = NtQueryInstallUILanguage(&InstallLangId);
                            if (!NT_SUCCESS( Status )) {
                                //
                                // Failed reading key.  Skip this lookup.
                                //
                                NewLangId = (LANGID)ResourceIdRetry;
                                break;

                            }
                        }

                        NewLangId = InstallLangId;
                        break;

                    case 9:     // Use lang id from locale in TEB
                        if (SUBLANGID( GivenLanguage ) == SUBLANG_SYS_DEFAULT) {
                            // Skip over all USER locale options
                            DefaultThreadLocale = 0;
                            RetryCount += 2;
                            break;
                        }

                        if (NtCurrentTeb() != NULL) {
                            NewLangId = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);
                        }
                        break;

                    case 10:     // Use User's default locale
                        Status = NtQueryDefaultLocale( TRUE, &DefaultThreadLocale );
                        if (NT_SUCCESS( Status )) {
                            NewLangId = LANGIDFROMLCID(DefaultThreadLocale);
                            break;
                            }

                        RetryCount++;
                        break;

                    case 11:     // Use primary language of User's default locale
                        NewLangId = PRIMARYLANGID( (LANGID)ResourceIdRetry );
                        break;

                    case 12:     // Use System default locale
                        Status = NtQueryDefaultLocale( FALSE, &DefaultSystemLocale );
                        if (!NT_SUCCESS( Status )) {
                            RetryCount++;
                            break;
                        }
                        if (DefaultSystemLocale != DefaultThreadLocale) {
                            NewLangId = LANGIDFROMLCID(DefaultSystemLocale);
                            break;
                        }

                        RetryCount += 2;
                        // fall through

                    case 14:     // Use US English language
                        NewLangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
                        break;

                    case 13:     // Use primary language of System default locale
                        NewLangId = PRIMARYLANGID( (LANGID)ResourceIdRetry );
                        break;

                    case 15:     // Take any lang id that matches
                        NewLangId = USE_FIRSTAVAILABLE_LANGID;
                        break;
#endif
                    default:    // No lang ids to match
                        goto ReturnFailure;
                        break;
                }

                //
                // If looking for a specific language id and same as the
                // one we just looked up, then skip it.
                //
                if (NewLangId != USE_FIRSTAVAILABLE_LANGID &&
                    NewLangId == ResourceIdRetry
                   ) {
                    goto TryNextLangId;
                    }

                //
                // Try this new language Id
                //
                ResourceIdRetry = (ULONG_PTR)NewLangId;
                ResourceIdPath = &ResourceIdRetry;
                ResourceDirectory = LanguageResourceDirectory;
                }

            n = ResourceDirectory->NumberOfNamedEntries;
            ResourceDirEntLow = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
            if (!(*ResourceIdPath & LDR_RESOURCE_ID_NAME_MASK)) {
                ResourceDirEntLow += n;
                n = ResourceDirectory->NumberOfIdEntries;
                }

            if (!n) {
                ResourceDirectory = NULL;
                goto NotFound;
                }

            if (LanguageResourceDirectory != NULL &&
                *ResourceIdPath == USE_FIRSTAVAILABLE_LANGID
               ) {
                ResourceDirectory = NULL;
                ResourceIdRetry = ResourceDirEntLow->Name;
                ResourceEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                    ((PCHAR)TopResourceDirectory +
                            ResourceDirEntLow->OffsetToData
                    );

                break;
                }

            ResourceDirectory = NULL;
            ResourceDirEntHigh = ResourceDirEntLow + n - 1;
            while (ResourceDirEntLow <= ResourceDirEntHigh) {
                if ((half = (n >> 1)) != 0) {
                    ResourceDirEntMiddle = ResourceDirEntLow;
                    if (*(PUCHAR)&n & 1) {
                        ResourceDirEntMiddle += half;
                        }
                    else {
                        ResourceDirEntMiddle += half - 1;
                        }
                    dir = LdrpCompareResourceNames_U( *ResourceIdPath,
                                                      TopResourceDirectory,
                                                      ResourceDirEntMiddle
                                                    );
                    if (!dir) {
                        if (ResourceDirEntMiddle->DataIsDirectory) {
                            ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                    ((PCHAR)TopResourceDirectory +
                                    ResourceDirEntMiddle->OffsetToDirectory
                                );
                            }
                        else {
                            ResourceDirectory = NULL;
                            ResourceEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                ((PCHAR)TopResourceDirectory +
                  ResourceDirEntMiddle->OffsetToData
                                );
                            }

                        break;
                        }
                    else {
                        if (dir < 0) {
                            ResourceDirEntHigh = ResourceDirEntMiddle - 1;
                            if (*(PUCHAR)&n & 1) {
                                n = half;
                                }
                            else {
                                n = half - 1;
                                }
                            }
                        else {
                            ResourceDirEntLow = ResourceDirEntMiddle + 1;
                            n = half;
                            }
                        }
                    }
                else {
                    if (n != 0) {
                        dir = LdrpCompareResourceNames_U( *ResourceIdPath,
                          TopResourceDirectory,
                                                          ResourceDirEntLow
                                                        );
                        if (!dir) {
                            if (ResourceDirEntLow->DataIsDirectory) {
                                ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                                    ((PCHAR)TopResourceDirectory +
                                        ResourceDirEntLow->OffsetToDirectory
                                    );
                                }
                            else {
                                ResourceEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                    ((PCHAR)TopResourceDirectory +
                      ResourceDirEntLow->OffsetToData
                                    );
                                }
                            }
                        }

                    break;
                    }
                }

            ResourceIdPath++;
            }

        if (ResourceEntry != NULL && !(Flags & LDRP_FIND_RESOURCE_DIRECTORY)) {
            *ResourceDirectoryOrData = (PVOID)ResourceEntry;
            Status = STATUS_SUCCESS;
            }
        else
        if (ResourceDirectory != NULL && (Flags & LDRP_FIND_RESOURCE_DIRECTORY)) {
            *ResourceDirectoryOrData = (PVOID)ResourceDirectory;
            Status = STATUS_SUCCESS;
            }
        else {
NotFound:
            switch( IdPathLength - ResourceIdPathLength) {
                case 3:     Status = STATUS_RESOURCE_LANG_NOT_FOUND; break;
                case 2:     Status = STATUS_RESOURCE_NAME_NOT_FOUND; break;
                case 1:     Status = STATUS_RESOURCE_TYPE_NOT_FOUND; break;
                default:    Status = STATUS_INVALID_PARAMETER; break;
                }
            }

        if (Status == STATUS_RESOURCE_LANG_NOT_FOUND &&
            LanguageResourceDirectory != NULL
           ) {
            ResourceEntry = NULL;
            goto TryNextLangId;
ReturnFailure: ;
            Status = STATUS_RESOURCE_LANG_NOT_FOUND;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

#ifndef NTOS_KERNEL_RUNTIME // { {

VOID
NTAPI
LdrDestroyOutOfProcessImage(
    IN OUT PLDR_OUT_OF_PROCESS_IMAGE Image
    )
/*++

Routine Description:

Arguments:

    Image - 


Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlFreeBuffer(&Image->HeadersBuffer);
    Image->Flags = 0;
    Image->ProcessHandle = NULL;
    Image->DllHandle = NULL;
}

NTSTATUS
NTAPI
LdrCreateOutOfProcessImage(
    IN ULONG                      Flags,
    IN HANDLE                     ProcessHandle,
    IN PVOID                      DllHandle,
    OUT PLDR_OUT_OF_PROCESS_IMAGE Image
    )
/*++

Routine Description:

    This function initialized the out parameter Image for use with
    other functions, like LdrFindOutOfProcessResource.

    It reads in the headers, in order to work with many existing inproc
        RtlImage* functions, without reading them in for every operation.

    When you are done with the Image, pass it to LdrDestroyOutOfProcessImage.

Arguments:

    Flags - fiddle with the behavior of the function
          LDR_DLL_MAPPED_AS_DATA  - "flat" memory mapping of file
          LDR_DLL_MAPPED_AS_IMAGE - SEC_IMAGE was passed to NtCreateSection, inter section padding
                                    reflected in offsets stored on disk is reflected in the address
                                    space this is the simpler situation
          LDR_DLL_MAPPED_AS_UNFORMATED_IMAGE - LDR_DLL_MAPPED_AS_IMAGE but LdrpWx86FormatVirtualImage
                                               hasn't run yet.

    ProcessHandle - The process DllHandle is in a mapped section in

    DllHandle - the base address of a mapped view in process ProcessHandle
        for legacy reasons, the lowest bit of this implies LDR_DLL_MAPPED_AS_DATA

    Image - an opaque object that you can pass to other "OutOfProcessImage" functions.


Return Value:

    NTSTATUS

--*/
{
    PUCHAR               RemoteAddress = NULL;
    PRTL_BUFFER          Buffer = NULL;
    PIMAGE_DOS_HEADER    DosHeader = NULL;
    SIZE_T               Headers32Offset = 0;
    PIMAGE_NT_HEADERS32  Headers32 = NULL;
    SIZE_T               BytesRead = 0;
    SIZE_T               BytesToRead = 0;
    SIZE_T               Offset = 0;
    SIZE_T               InitialReadSize = 4096;
                     C_ASSERT(PAGE_SIZE >= 4096);
    NTSTATUS             Status = STATUS_SUCCESS;

    KdPrintEx((
        DPFLTR_LDR_ID,
        DPFLTR_TRACE_LEVEL,
        "LDR: %s(%lx, %p, %p, %p) beginning\n",
        __FUNCTION__,
        Flags,
        ProcessHandle,
        DllHandle,
        Image
        ));

    // if this assertion triggers, you probably passed a handle instead of a base address
    ASSERT(((ULONG_PTR)DllHandle) >= 0xffff);

    // Unformated images are only ever 32bit on 64bit.
    // The memory manager doesn't "spread them out", ntdll.dll does it.
    // There is only a short span of time between the mapping of the image and
    // the code in ntdll.dll reformating it, we leave it to our caller to know
    // if they are in that path.
#if !defined(_WIN64) && !defined(BUILD_WOW6432)
    if ((Flags & LDR_DLL_MAPPED_AS_MASK) == LDR_DLL_MAPPED_AS_UNFORMATED_IMAGE) {
        Flags = (Flags & ~LDR_DLL_MAPPED_AS_MASK) | LDR_DLL_MAPPED_AS_IMAGE;
    }
#endif

    if (LDR_IS_DATAFILE(DllHandle)) {
        DllHandle = LDR_DATAFILE_TO_VIEW(DllHandle);
        ASSERT((Flags & LDR_DLL_MAPPED_AS_MASK) == 0 || (Flags & LDR_DLL_MAPPED_AS_MASK) == LDR_DLL_MAPPED_AS_DATA);
        Flags |= LDR_DLL_MAPPED_AS_DATA;
    }

    Image->Flags = Flags;
    Image->ProcessHandle = ProcessHandle;
    Image->DllHandle = DllHandle;

    RemoteAddress = (PUCHAR)DllHandle;
    Buffer = &Image->HeadersBuffer;
    RtlInitBuffer(Buffer, Image->PreallocatedHeadersBuffer, sizeof(Image->PreallocatedHeadersBuffer));

    if (ProcessHandle == NtCurrentProcess()) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // first read 4k since that is generally enough and we can avoid
    // multiple calls to NtReadVirtualMemory
    //
    // 4k is also the smallest page NT has run on, so even if the .exe is
    // smaller than 4k, we should be able to read 4k
    //
    BytesToRead = InitialReadSize;
    if (!NT_SUCCESS(Status = RtlEnsureBufferSize(0, Buffer, Offset + BytesToRead))) {
        goto Exit;
    }
    Status = NtReadVirtualMemory(ProcessHandle, RemoteAddress + Offset, Buffer->Buffer + Offset, BytesToRead, &BytesRead);
    if (Status == STATUS_PARTIAL_COPY && BytesRead != 0) {
        InitialReadSize = BytesRead;
    }
    else if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s(): NtReadVirtualMemory failed.\n", __FUNCTION__));
        goto Exit;
    }

    BytesToRead = sizeof(*DosHeader);
    if (Offset + BytesToRead > InitialReadSize) {
        if (!NT_SUCCESS(Status = RtlEnsureBufferSize(0, Buffer, Offset + BytesToRead))) {
            goto Exit;
        }
        if (!NT_SUCCESS(Status = NtReadVirtualMemory(ProcessHandle, RemoteAddress + Offset, Buffer->Buffer + Offset, BytesToRead, &BytesRead))) {
            KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s(): NtReadVirtualMemory failed.\n", __FUNCTION__));
            goto Exit;
        }
        if (BytesToRead != BytesRead) {
            goto ReadTruncated;
        }
    }
    DosHeader = (PIMAGE_DOS_HEADER)Buffer->Buffer;
    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        goto InvalidImageFormat;
    }

    if (DosHeader->e_lfanew >= RTLP_IMAGE_MAX_DOS_HEADER) {
        goto InvalidImageFormat;
    }

    Offset += DosHeader->e_lfanew;

    BytesToRead =  RTL_SIZEOF_THROUGH_FIELD(IMAGE_NT_HEADERS32, FileHeader);
    {
        C_ASSERT(RTL_SIZEOF_THROUGH_FIELD(IMAGE_NT_HEADERS32, FileHeader)
            == RTL_SIZEOF_THROUGH_FIELD(IMAGE_NT_HEADERS64, FileHeader));
    }
    if (Offset + BytesToRead > InitialReadSize) {
        if (!NT_SUCCESS(Status = RtlEnsureBufferSize(0, Buffer, Offset + BytesToRead))) {
            goto Exit;
        }
        if (!NT_SUCCESS(Status = NtReadVirtualMemory(ProcessHandle, RemoteAddress + Offset, Buffer->Buffer + Offset, BytesToRead, &BytesRead))) {
            goto Exit;
        }
        if (BytesToRead != BytesRead) {
            goto ReadTruncated;
        }
    }
    Headers32Offset = Offset;
    Headers32 = (PIMAGE_NT_HEADERS32)(Buffer->Buffer + Headers32Offset); // correct for 64bit too
    if (Headers32->Signature != IMAGE_NT_SIGNATURE) {
        goto InvalidImageFormat;
    }

    Offset += BytesToRead;
    BytesToRead = Headers32->FileHeader.SizeOfOptionalHeader
        + Headers32->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER;

    if (Offset + BytesToRead > InitialReadSize) {
        if (!NT_SUCCESS(Status = RtlEnsureBufferSize(0, Buffer, Offset + BytesToRead))) {
            goto Exit;
        }
        if (!NT_SUCCESS(Status = NtReadVirtualMemory(ProcessHandle, RemoteAddress + Offset, Buffer->Buffer + Offset, BytesToRead, &BytesRead))) {
            goto Exit;
        }
        if (BytesToRead != BytesRead) {
            goto ReadTruncated;
        }
    }
    Headers32 = (PIMAGE_NT_HEADERS32)(Buffer->Buffer + Headers32Offset); // correct for 64bit too
    if (Headers32->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC
        && Headers32->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC
        ) {
        goto InvalidImageFormat;
    }
#if defined(_WIN64) || defined(BUILD_WOW6432)
#define NATIVE_PAGE_SIZE  0x2000
    if ((Image->Flags & LDR_DLL_MAPPED_AS_MASK) == LDR_DLL_MAPPED_AS_UNFORMATED_IMAGE) {
        PIMAGE_NT_HEADERS64  Headers64 = (PIMAGE_NT_HEADERS64)Headers32;

        // This test is copied from ntdll.dll's conditionall call to LdrpWx86FormatVirtualImage.
        if (
              Headers32->FileHeader.Machine == IMAGE_FILE_MACHINE_I386
           && Headers32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC
           && Headers32->OptionalHeader.SectionAlignment < NATIVE_PAGE_SIZE
           ) {
            Image->Flags = (Image->Flags & ~LDR_DLL_MAPPED_AS_MASK) | LDR_DLL_MAPPED_AS_DATA;
        } else {
            Image->Flags = (Image->Flags & ~LDR_DLL_MAPPED_AS_MASK) | LDR_DLL_MAPPED_AS_IMAGE;
        }
    }
#endif
    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status)) {
        LdrDestroyOutOfProcessImage(Image);
    }
    KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    return Status;

ReadTruncated:
    Status = STATUS_UNSUCCESSFUL;
    goto Exit;

InvalidImageFormat:
    Status = STATUS_INVALID_IMAGE_FORMAT;
    goto Exit;
}

NTSTATUS
NTAPI
LdrFindCreateProcessManifest(
    IN ULONG                         Flags,
    IN OUT PLDR_OUT_OF_PROCESS_IMAGE Image,
    IN const ULONG_PTR*              IdPath,
    IN ULONG                         IdPathLength,
    OUT PIMAGE_RESOURCE_DATA_ENTRY   OutDataEntry
    )
/*++

Routine Description:

    This function is like LdrFindResource_U, but it can load resources
      from a file mapped into another process. It only works as much
      as has been needed.

Arguments:

    Flags -
        LDR_FIND_RESOURCE_LANGUAGE_CAN_FALLBACK - if the specified langid is not found,
                                            fallback on the usual or any strategy,
                                            the current implementation always loads the
                                            first langid
        LDR_FIND_RESOURCE_LANGUAGE_EXACT - only load the resource with exactly
                                            specified langid

    ProcessHandle - The process the DllHandle is valid in. Passed to NtReadVirtualMemory.

    DllHandle - Same as LdrFindResource_U
    ResourceIdPath - Same as LdrFindResource_U
    ResourceIdPathLength - Same as LdrFindResource_U
    OutDataEntry - Similar to LdrFindResource_U, but returned by value instead of address.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SIZE_T   BytesRead = 0;
    SIZE_T   BytesToRead = 0;
#if DBG
    ULONG Line = __LINE__;
#endif

    // we depend on these values sorting first
    C_ASSERT(CREATEPROCESS_MANIFEST_RESOURCE_ID == 1);
    C_ASSERT(ISOLATIONAWARE_MANIFEST_RESOURCE_ID == 2);

#if DBG
    KdPrintEx((
        DPFLTR_LDR_ID,
        DPFLTR_TRACE_LEVEL,
        "LDR: %s(0x%lx, %p, %p[%Id, %Id, %Id], %lu, %p) beginning\n",
        __FUNCTION__,
        Flags,
        Image,
        IdPath,
        // 3 is the usual number, type, id/name, language
        (IdPath != NULL && IdPathLength > 0) ? IdPath[0] : 0,
        (IdPath != NULL && IdPathLength > 1) ? IdPath[1] : 0,
        (IdPath != NULL && IdPathLength > 2) ? IdPath[2] : 0,
        IdPathLength,
        OutDataEntry
        ));
#endif

#define LDRP_CHECK_PARAMETER(x) if (!(x)) { ASSERT(x); return STATUS_INVALID_PARAMETER; }
    LDRP_CHECK_PARAMETER(Image != NULL);
    LDRP_CHECK_PARAMETER(Image->DllHandle != NULL);
    LDRP_CHECK_PARAMETER(Image->ProcessHandle != NULL);
    LDRP_CHECK_PARAMETER(Image->HeadersBuffer.Buffer != NULL);
    LDRP_CHECK_PARAMETER(OutDataEntry != NULL);
    LDRP_CHECK_PARAMETER(IdPath != NULL);

    LDRP_CHECK_PARAMETER((Image->Flags & LDR_DLL_MAPPED_AS_MASK) != LDR_DLL_MAPPED_AS_UNFORMATED_IMAGE);

    // not all flags are implemented (only image vs. data is)
    LDRP_CHECK_PARAMETER((Flags & LDR_FIND_RESOURCE_LANGUAGE_EXACT) == 0);
    LDRP_CHECK_PARAMETER((Flags & LDRP_FIND_RESOURCE_DIRECTORY   ) == 0);

    RtlZeroMemory(OutDataEntry, sizeof(OutDataEntry));

    if (Image->ProcessHandle == NtCurrentProcess()) {
        PVOID  DirectoryOrData = NULL;

        Status = LdrpSearchResourceSection_U(
            (Image->Flags & LDR_DLL_MAPPED_AS_DATA)
                ? LDR_VIEW_TO_DATAFILE(Image->DllHandle)
                : Image->DllHandle,
            IdPath,
            IdPathLength,
            Flags,            
            &DirectoryOrData
            );
        if (NT_SUCCESS(Status) && DirectoryOrData != NULL && OutDataEntry != NULL) {
            *OutDataEntry = *(PIMAGE_RESOURCE_DATA_ENTRY)DirectoryOrData;
        }
        goto Exit;
    }

    //
    // All we handle cross process currently is finding the first resource id,
    // first langid, of a given type.
    //
    // And we only handle numbers, not strings/names.
    //
    LDRP_CHECK_PARAMETER(IdPathLength == 3); // type, id/name, langid
    LDRP_CHECK_PARAMETER(IdPath[0] != 0); // type
    LDRP_CHECK_PARAMETER(IdPath[1] == 0 || IdPath[1] == CREATEPROCESS_MANIFEST_RESOURCE_ID); // just find first id
    LDRP_CHECK_PARAMETER(IdPath[2] == 0); // first langid

    // no strings/names, just numbers
    LDRP_CHECK_PARAMETER(IS_INTRESOURCE(IdPath[0]));
    LDRP_CHECK_PARAMETER(IS_INTRESOURCE(IdPath[1]));
    LDRP_CHECK_PARAMETER(IS_INTRESOURCE(IdPath[2]));

    __try {
        USHORT n = 0;
        USHORT half = 0;
        LONG   dir = 0;

        SIZE_T                        TopDirectorySize = 0;
        ULONG                         Size = 0;
        PIMAGE_RESOURCE_DIRECTORY     Directory = NULL;
        PIMAGE_RESOURCE_DIRECTORY     RemoteDirectoryAddress = NULL;
        UCHAR                         DirectoryBuffer[
                                          sizeof(IMAGE_RESOURCE_DIRECTORY)
                                          + sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY)
                                          ];
        PIMAGE_RESOURCE_DIRECTORY     TopDirectory = NULL;
        PIMAGE_RESOURCE_DIRECTORY     RemoteTopDirectoryAddress = NULL;
        RTL_BUFFER                    TopDirectoryBuffer = {0};
        UCHAR                         TopStaticDirectoryBuffer[256];
        C_ASSERT(sizeof(TopStaticDirectoryBuffer) >= sizeof(*RemoteTopDirectoryAddress));

        IMAGE_RESOURCE_DATA_ENTRY     DataEntry;
        PIMAGE_RESOURCE_DATA_ENTRY    RemoteDataEntryAddress = NULL;

        PIMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntry = NULL;

        PIMAGE_RESOURCE_DIRECTORY_ENTRY DirEntLow = NULL;
        PIMAGE_RESOURCE_DIRECTORY_ENTRY DirEntMiddle = NULL;
        PIMAGE_RESOURCE_DIRECTORY_ENTRY DirEntHigh = NULL;
        __try {
            RtlInitBuffer(&TopDirectoryBuffer, TopStaticDirectoryBuffer, sizeof(TopStaticDirectoryBuffer));
            Status = RtlEnsureBufferSize(0, &TopDirectoryBuffer, TopDirectoryBuffer.StaticSize);
            ASSERT(NT_SUCCESS(Status));

            RemoteTopDirectoryAddress = (PIMAGE_RESOURCE_DIRECTORY)
                RtlImageDirectoryEntryToData(Image->HeadersBuffer.Buffer,
                                            (Image->Flags & LDR_DLL_MAPPED_AS_DATA) ? FALSE : TRUE,
                                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                             &Size
                                             );

            if (RemoteTopDirectoryAddress == NULL) {
                Status = STATUS_RESOURCE_DATA_NOT_FOUND;
                goto Exit;
            }
            //
            // rebase..
            //
            RemoteTopDirectoryAddress =
                (PIMAGE_RESOURCE_DIRECTORY)
                (((PUCHAR)Image->DllHandle)
                + (((PUCHAR)RemoteTopDirectoryAddress)
                - ((PUCHAR)Image->HeadersBuffer.Buffer)));

            Status = NtReadVirtualMemory(Image->ProcessHandle, RemoteTopDirectoryAddress, TopDirectoryBuffer.Buffer, TopDirectoryBuffer.Size, &BytesRead);
            if (Status == STATUS_PARTIAL_COPY && BytesRead >= sizeof(*TopDirectory)) {
                // nothing
            }
            else if (!NT_SUCCESS(Status)) {
                goto Exit;
            }


            TopDirectory = (PIMAGE_RESOURCE_DIRECTORY)TopDirectoryBuffer.Buffer;

            //
            // determine the size of the entire directory, including the named entries,
            // since they occur before the  numbered ones (note that we currently
            // don't optimize away reading of the named ones, even though we never
            // search them)
            //
            TopDirectorySize = sizeof(*TopDirectory)
                + (TopDirectory->NumberOfIdEntries + TopDirectory->NumberOfNamedEntries)
                   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY);

            //
            // now check the result of NtReadVirtualMemory again, if our guess was
            // big enough, but the read was not, error
            //
            if (TopDirectorySize <= TopDirectoryBuffer.Size
                && BytesRead < TopDirectorySize) {
                // REVIEW STATUS_PARTIAL_COPY is only a warning. Is it a strong enough return value?
                // Should we return STATUS_INVALID_IMAGE_FORMAT or STATUS_ACCESS_DENIED instead?
                // There are other places in this file where we propogate STATUS_PARTIAL_COPY, if
                // zero bytes are actually read.
                if (Status == STATUS_PARTIAL_COPY) {
                    goto Exit;
                }
#if DBG
                Line = __LINE__;
#endif
                goto ReadTruncated;
            }

            //
            // if our initial guessed size was too small, read the correct size
            //
            if (TopDirectorySize > TopDirectoryBuffer.Size) {
                KdPrintEx((
                    DPFLTR_LDR_ID,
                    DPFLTR_ERROR_LEVEL, // otherwise we'll never see it
                    "LDR: %s(): %Id was not enough of a preread for a resource directory, %Id required.\n",
                    __FUNCTION__,
                    TopDirectoryBuffer.Size,
                    TopDirectorySize
                    ));
                Status = RtlEnsureBufferSize(0, &TopDirectoryBuffer, TopDirectorySize);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }
                Status = NtReadVirtualMemory(Image->ProcessHandle, RemoteTopDirectoryAddress, TopDirectoryBuffer.Buffer, TopDirectoryBuffer.Size, &BytesRead);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }
                if (BytesRead != TopDirectoryBuffer.Size) {
#if DBG
                    Line = __LINE__;
#endif
                    goto ReadTruncated;
                }

                TopDirectory = (PIMAGE_RESOURCE_DIRECTORY) TopDirectoryBuffer.Buffer;
            }

            // point to start of named entries
            DirEntLow = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(TopDirectory + 1);

            // move past named entries to numbered entries
            DirEntLow += TopDirectory->NumberOfNamedEntries;

            n = TopDirectory->NumberOfIdEntries;
            
            if (n == 0) {
                Status = STATUS_RESOURCE_TYPE_NOT_FOUND;
                goto Exit;
            }

            DirectoryEntry = NULL;
            Directory = NULL;
            DirEntHigh = DirEntLow + n - 1;
            while (DirEntLow <= DirEntHigh) {
                if ((half = (n >> 1)) != 0) {
                    DirEntMiddle = DirEntLow;
                    if (n & 1) {
                        DirEntMiddle += half;
                    }
                    else {
                        DirEntMiddle += half - 1;
                    }
                    if (DirEntMiddle->NameIsString) {
                        KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: No strings expected in %s().\n", __FUNCTION__));
                        ASSERT(FALSE);
                        Status = STATUS_INVALID_PARAMETER;
                        goto Exit;
                    }
                    dir = LdrpCompareResourceNames_U( *IdPath,
                                                      TopDirectory,
                                                      DirEntMiddle
                                                    );
                    if (dir == 0) {
                        if (DirEntMiddle->DataIsDirectory) {
                            Directory = (PIMAGE_RESOURCE_DIRECTORY)
                                    (((PCHAR)TopDirectory)
                                        + DirEntMiddle->OffsetToDirectory);
                        }
                        else {
                            KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s(): First id in resource path is expected to be a directory.\n", __FUNCTION__));
                            Status = STATUS_INVALID_PARAMETER;
                            goto Exit;
                            /* This is what you do if we allow specifying the id and language,
                            which we might do in the future.
                            Directory = NULL;
                            Entry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                     (((PCHAR)TopDirectory)
                                        + DirEntMiddle->OffsetToData);
                            */
                        }
                        break;
                    }
                    else {
                        if (dir < 0) {
                            DirEntHigh = DirEntMiddle - 1;
                            if (n & 1) {
                                n = half;
                            }
                            else {
                                n = half - 1;
                            }
                        }
                        else {
                            DirEntLow = DirEntMiddle + 1;
                            n = half;
                        }
                    }
                }
                else {
                    if (n != 0) {
                        if (DirEntLow->NameIsString) {
                            KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s() No strings expected.\n", __FUNCTION__));
                            Status = STATUS_INVALID_PARAMETER;
                            goto Exit;
                        }
                        dir = LdrpCompareResourceNames_U( *IdPath,
                                                  TopDirectory,
                                                  DirEntLow
                                                 );
                        if (dir == 0) {
                            if (DirEntLow->DataIsDirectory) {
                                Directory = (PIMAGE_RESOURCE_DIRECTORY)
                                        (((PCHAR)TopDirectory)
                                            + DirEntLow->OffsetToDirectory);
                            }
                            else {
                                KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s() First id in resource path is expected to be a directory", __FUNCTION__));
                                Status = STATUS_INVALID_PARAMETER;
                                goto Exit;
                                /*
                                Entry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                        (((PCHAR)TopDirectory)
                                            + DirEntLow->OffsetToData);
                                            */
                            }
                        }
                    }
                    break;
                }
            }
            //
            // ok, now we have found address of the type's name/id directory (or not)
            //
            if (Directory == NULL) {
                Status = STATUS_RESOURCE_TYPE_NOT_FOUND;
                goto Exit;
            }

            //
            // we copied the binary search and didn't quite compute what we want,
            // it found the local address, change this to an offset and apply
            // to the remote address ("rebase")
            //
            RemoteDirectoryAddress =
                (PIMAGE_RESOURCE_DIRECTORY)(
                  ((ULONG_PTR)RemoteTopDirectoryAddress)
                + ((ULONG_PTR)Directory)
                - ((ULONG_PTR)TopDirectory));

            //
            // Now do the read of both the directory and the first entry.
            //
            Directory = (PIMAGE_RESOURCE_DIRECTORY)&DirectoryBuffer;
            Status = NtReadVirtualMemory(Image->ProcessHandle, RemoteDirectoryAddress, Directory, sizeof(DirectoryBuffer), &BytesRead);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s() NtReadVirtualMemory failed.", __FUNCTION__));
                goto Exit;
            }
            if (BytesRead != sizeof(DirectoryBuffer)) {
#if DBG
                Line = __LINE__;
#endif
                goto ReadTruncated;
            }
            if ((Directory->NumberOfNamedEntries + Directory->NumberOfIdEntries) == 0) {
                Status = STATUS_RESOURCE_NAME_NOT_FOUND;
                goto Exit;
            }

            if (IdPath[1] == CREATEPROCESS_MANIFEST_RESOURCE_ID && Directory->NumberOfNamedEntries != 0) {
                KdPrintEx((
                    DPFLTR_LDR_ID,
                    DPFLTR_ERROR_LEVEL,
                    "LDR: %s() caller asked for id==1 but there are named entries we are not bothering to skip.\n",
                    __FUNCTION__
                    ));
                Status = STATUS_RESOURCE_NAME_NOT_FOUND;
                goto Exit;
            }

            //
            // grab the entry for the first id
            //
            DirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(Directory + 1);
            if (!DirectoryEntry->DataIsDirectory) {
                KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: Second level of resource directory is expected to be a directory\n"));
                Status = STATUS_INVALID_IMAGE_FORMAT; // REVIEW too strong?
                goto Exit;
            }

            //
            // If there is more than one entry, ensure no conflicts.
            //
            if (Directory->NumberOfIdEntries > 1
                && DirectoryEntry->Id >= MINIMUM_RESERVED_MANIFEST_RESOURCE_ID
                && DirectoryEntry->Id <= MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID
                ) {
                PIMAGE_RESOURCE_DIRECTORY_ENTRY  RemoteDirectoryEntryPointer;
                IMAGE_RESOURCE_DIRECTORY_ENTRY   DirectoryEntries[
                                                    MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID
                                                    - MINIMUM_RESERVED_MANIFEST_RESOURCE_ID
                                                    + 1];
                ULONG ResourceId;
                ULONG NumberOfEntriesToCheck;
                ULONG CountOfReservedManifestIds;

                C_ASSERT(MINIMUM_RESERVED_MANIFEST_RESOURCE_ID == 1);

                RemoteDirectoryEntryPointer = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(RemoteDirectoryAddress + 1);

                NumberOfEntriesToCheck = LDRP_MIN(RTL_NUMBER_OF(DirectoryEntries), Directory->NumberOfIdEntries);
                BytesToRead = sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) * NumberOfEntriesToCheck;
                ASSERT(BytesToRead <= sizeof(DirectoryEntries));

                Status = NtReadVirtualMemory(Image->ProcessHandle, RemoteDirectoryEntryPointer, &DirectoryEntries, BytesToRead, &BytesRead);
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s() NtReadVirtualMemory failed.", __FUNCTION__));
                    goto Exit;
                }
                if (BytesRead != BytesToRead) {
#if DBG
                    Line = __LINE__;
#endif
                    goto ReadTruncated;
                }

                CountOfReservedManifestIds = 0;

                for (ResourceId = MINIMUM_RESERVED_MANIFEST_RESOURCE_ID;
                     ResourceId != MINIMUM_RESERVED_MANIFEST_RESOURCE_ID + NumberOfEntriesToCheck;
                     ResourceId += 1
                    ) {
                    if (DirectoryEntries[ResourceId - MINIMUM_RESERVED_MANIFEST_RESOURCE_ID].Id >= MINIMUM_RESERVED_MANIFEST_RESOURCE_ID
                        && DirectoryEntries[ResourceId - MINIMUM_RESERVED_MANIFEST_RESOURCE_ID].Id <= MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID
                        ) {
                        CountOfReservedManifestIds += 1;
                        if (CountOfReservedManifestIds > 1) {
#if DBG
                            DbgPrintEx(
                                DPFLTR_LDR_ID,
                                DPFLTR_ERROR_LEVEL,
                                "LDR: %s() multiple reserved manifest resource ids present\n",
                                __FUNCTION__
                                );
#endif
                            Status = STATUS_INVALID_PARAMETER;
                            goto Exit;
                        }
                    }
                }
            }

            if (IdPath[1] == CREATEPROCESS_MANIFEST_RESOURCE_ID && DirectoryEntry->Id != CREATEPROCESS_MANIFEST_RESOURCE_ID) {
                Status = STATUS_RESOURCE_NAME_NOT_FOUND;
                goto Exit;
            }

            //
            // now get address of langid directory
            //
            RemoteDirectoryAddress =
                (PIMAGE_RESOURCE_DIRECTORY)(
                  ((ULONG_PTR)RemoteTopDirectoryAddress)
                + DirectoryEntry->OffsetToDirectory);

            //
            // now read the langid directory and its first entry
            //
            Status = NtReadVirtualMemory(Image->ProcessHandle, RemoteDirectoryAddress, Directory, sizeof(DirectoryBuffer), &BytesRead);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s() NtReadVirtualMemory failed.", __FUNCTION__));
                goto Exit;
            }
            if (BytesRead != sizeof(DirectoryBuffer)) {
                goto ReadTruncated;
            }
            if ((Directory->NumberOfNamedEntries + Directory->NumberOfIdEntries) == 0) {
                Status = STATUS_RESOURCE_LANG_NOT_FOUND;
                goto Exit;
            }

            //
            // look at the langid directory's first entry
            //
            if (DirectoryEntry->DataIsDirectory) {
                KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: Third level of resource directory is not expected to be a directory\n"));
                Status = STATUS_INVALID_IMAGE_FORMAT; // REVIEW too strong?
                goto Exit;
            }
            RemoteDataEntryAddress =
                (PIMAGE_RESOURCE_DATA_ENTRY)(
                  ((ULONG_PTR)RemoteTopDirectoryAddress)
                + DirectoryEntry->OffsetToData);

            //
            // read the data entry
            //
            Status = NtReadVirtualMemory(Image->ProcessHandle, RemoteDataEntryAddress, &DataEntry, sizeof(DataEntry), &BytesRead);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL, "LDR: %s() NtReadVirtualMemory failed.", __FUNCTION__));
                goto Exit;
            }
            if (BytesRead != sizeof(DataEntry)) {
                goto ReadTruncated;
            }

            *OutDataEntry = DataEntry;
            Status = STATUS_SUCCESS;
        }
        __finally {
            RtlFreeBuffer(&TopDirectoryBuffer);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
Exit:
#if DBG
    //
    // Fix/raid dcpromo, msiexec, etc..
    // DPFLTR_LEVEL_STATUS filters all forms of resource not found.
    //
    if (DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL) {
        KdPrintEx((
            DPFLTR_LDR_ID,
            DPFLTR_LEVEL_STATUS(Status),
            "LDR: %s(0x%lx, %p, %p[%Id, %Id, %Id], %lu, %p) failed %08x\n",
            __FUNCTION__,
            Flags,
            Image,
            IdPath,
            // 3 is the usual number, type, id/name, language
            (IdPath != NULL && IdPathLength > 0) ? IdPath[0] : 0,
            (IdPath != NULL && IdPathLength > 1) ? IdPath[1] : 0,
            (IdPath != NULL && IdPathLength > 2) ? IdPath[2] : 0,
            IdPathLength,
            OutDataEntry,
            Status
            ));
        KdPrintEx((
            DPFLTR_LDR_ID,
            DPFLTR_LEVEL_STATUS(Status),
            "LDR: %s() returning Status:0x%lx IMAGE_RESOURCE_DATA_ENTRY:{OffsetToData=%#lx, Size=%#lx}\n",
            __FUNCTION__,
            Status,
            (OutDataEntry != NULL) ? OutDataEntry->OffsetToData : 0,
            (OutDataEntry != NULL) ? OutDataEntry->Size : 0
            ));
    }
#endif
    return Status;

ReadTruncated:
#if DBG
    DbgPrintEx(DPFLTR_LDR_ID, DPFLTR_ERROR_LEVEL,
        "LDR: %s(): Line %lu NtReadVirtualMemory() succeeded, but returned too few bytes (0x%Ix out of 0x%Ix).\n",
        __FUNCTION__, Line, BytesRead, BytesToRead);
#endif
    Status = STATUS_UNSUCCESSFUL;
    goto Exit;
}

NTSTATUS
NTAPI
LdrAccessOutOfProcessResource(
    IN ULONG                            Flags,
    IN OUT PLDR_OUT_OF_PROCESS_IMAGE    Image, // currently only IN
    IN const IMAGE_RESOURCE_DATA_ENTRY* DataEntry,
    OUT PVOID*                          Address OPTIONAL,
    OUT PULONG                          Size OPTIONAL
    )
/*++

Routine Description:

    This function is like LdrAccessResource, but it works on images
    mapped out of process.

Arguments:

    Flags -

    Image - an opaque object representing an image or file mapped into another process,
        created with LdrCreateOutOfProcessImage.

    DataEntry - Same as LdrAccessResource, but returned by-value from LdrFindOutOfProcessResource

    Address - Same as LdrAccessResource

    Size - Same as LdrAccessResource

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;

    ASSERT(Image != NULL);
    ASSERT(Image->DllHandle != NULL);
    ASSERT(Image->ProcessHandle != NULL);
    ASSERT(Image->HeadersBuffer.Buffer != NULL);

    if (Image->ProcessHandle != NtCurrentProcess()) {

        Status = LdrpAccessResourceDataNoMultipleLanguage(
            (Image->Flags & LDR_DLL_MAPPED_AS_DATA)
                ? LDR_VIEW_TO_DATAFILE(Image->HeadersBuffer.Buffer)
                : Image->HeadersBuffer.Buffer,
            DataEntry,
            Address,
            Size
            );

        //
        // rebase..
        //
        if (NT_SUCCESS(Status) && Address != NULL && *Address != NULL) {
            *Address =
                (((PUCHAR)Image->DllHandle)
                + (((PUCHAR)*Address)
                - ((PUCHAR)Image->HeadersBuffer.Buffer)));
        }
    } else {

        Status = LdrpAccessResourceDataNoMultipleLanguage(
            (Image->Flags & LDR_DLL_MAPPED_AS_DATA)
                ? LDR_VIEW_TO_DATAFILE(Image->DllHandle)
                : Image->DllHandle,
            DataEntry,
            Address,
            Size
            );
    }

    KdPrintEx((DPFLTR_LDR_ID, DPFLTR_LEVEL_STATUS(Status), "LDR: %s() exiting 0x%08lx\n", __FUNCTION__, Status));
    return Status;
}

#endif // } }

NTSTATUS
LdrEnumResources(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN OUT PULONG NumberOfResources,
    OUT PLDR_ENUM_RESOURCE_ENTRY Resources OPTIONAL
    )
{
    NTSTATUS Status;
    PIMAGE_RESOURCE_DIRECTORY TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY TypeResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY NameResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY LangResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY TypeResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY NameResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY LangResourceDirectoryEntry;
    ULONG TypeDirectoryIndex, NumberOfTypeDirectoryEntries;
    ULONG NameDirectoryIndex, NumberOfNameDirectoryEntries;
    ULONG LangDirectoryIndex, NumberOfLangDirectoryEntries;
    BOOLEAN ScanTypeDirectory;
    BOOLEAN ScanNameDirectory;
    BOOLEAN ReturnThisResource;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    ULONG_PTR TypeResourceNameOrId;
    ULONG_PTR NameResourceNameOrId;
    ULONG_PTR LangResourceNameOrId;
    PLDR_ENUM_RESOURCE_ENTRY ResourceInfo;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    ULONG ResourceIndex, MaxResourceIndex;
    ULONG Size;

    ResourceIndex = 0;
    if (!ARGUMENT_PRESENT( Resources )) {
        MaxResourceIndex = 0;
        }
    else {
        MaxResourceIndex = *NumberOfResources;
        }
    *NumberOfResources = 0;

    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData( DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &Size
                                    );
    if (!TopResourceDirectory) {
        return STATUS_RESOURCE_DATA_NOT_FOUND;
        }

    TypeResourceDirectory = TopResourceDirectory;
    TypeResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(TypeResourceDirectory+1);
    NumberOfTypeDirectoryEntries = TypeResourceDirectory->NumberOfNamedEntries +
                                   TypeResourceDirectory->NumberOfIdEntries;
    TypeDirectoryIndex = 0;
    Status = STATUS_SUCCESS;
    for (TypeDirectoryIndex=0;
         TypeDirectoryIndex<NumberOfTypeDirectoryEntries;
         TypeDirectoryIndex++, TypeResourceDirectoryEntry++
        ) {
        if (ResourceIdPathLength > 0) {
            ScanTypeDirectory = LdrpCompareResourceNames_U( ResourceIdPath[ 0 ],
                                                            TopResourceDirectory,
                                                            TypeResourceDirectoryEntry
                                                          ) == 0;
            }
        else {
            ScanTypeDirectory = TRUE;
            }
        if (ScanTypeDirectory) {
            if (!TypeResourceDirectoryEntry->DataIsDirectory) {
                return STATUS_INVALID_IMAGE_FORMAT;
                }
            if (TypeResourceDirectoryEntry->NameIsString) {
                ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                    ((PCHAR)TopResourceDirectory + TypeResourceDirectoryEntry->NameOffset);

                TypeResourceNameOrId = (ULONG_PTR)ResourceNameString;
                }
            else {
                TypeResourceNameOrId = (ULONG_PTR)TypeResourceDirectoryEntry->Id;
                }

            NameResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                ((PCHAR)TopResourceDirectory + TypeResourceDirectoryEntry->OffsetToDirectory);
            NameResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(NameResourceDirectory+1);
            NumberOfNameDirectoryEntries = NameResourceDirectory->NumberOfNamedEntries +
                                           NameResourceDirectory->NumberOfIdEntries;
            for (NameDirectoryIndex=0;
                 NameDirectoryIndex<NumberOfNameDirectoryEntries;
                 NameDirectoryIndex++, NameResourceDirectoryEntry++
                ) {
                if (ResourceIdPathLength > 1) {
                    ScanNameDirectory = LdrpCompareResourceNames_U( ResourceIdPath[ 1 ],
                                                                    TopResourceDirectory,
                                                                    NameResourceDirectoryEntry
                                                                  ) == 0;
                    }
                else {
                    ScanNameDirectory = TRUE;
                    }
                if (ScanNameDirectory) {
                    if (!NameResourceDirectoryEntry->DataIsDirectory) {
                        return STATUS_INVALID_IMAGE_FORMAT;
                        }

                    if (NameResourceDirectoryEntry->NameIsString) {
                        ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                            ((PCHAR)TopResourceDirectory + NameResourceDirectoryEntry->NameOffset);

                        NameResourceNameOrId = (ULONG_PTR)ResourceNameString;
                        }
                    else {
                        NameResourceNameOrId = (ULONG_PTR)NameResourceDirectoryEntry->Id;
                        }

                    LangResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                        ((PCHAR)TopResourceDirectory + NameResourceDirectoryEntry->OffsetToDirectory);

                    LangResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(LangResourceDirectory+1);
                    NumberOfLangDirectoryEntries = LangResourceDirectory->NumberOfNamedEntries +
                                                   LangResourceDirectory->NumberOfIdEntries;
                    LangDirectoryIndex = 0;
                    for (LangDirectoryIndex=0;
                         LangDirectoryIndex<NumberOfLangDirectoryEntries;
                         LangDirectoryIndex++, LangResourceDirectoryEntry++
                        ) {
                        if (ResourceIdPathLength > 2) {
                            ReturnThisResource = LdrpCompareResourceNames_U( ResourceIdPath[ 2 ],
                                                                             TopResourceDirectory,
                                                                             LangResourceDirectoryEntry
                                                                           ) == 0;
                            }
                        else {
                            ReturnThisResource = TRUE;
                            }
                        if (ReturnThisResource) {
                            if (LangResourceDirectoryEntry->DataIsDirectory) {
                                return STATUS_INVALID_IMAGE_FORMAT;
                                }

                            if (LangResourceDirectoryEntry->NameIsString) {
                                ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                                    ((PCHAR)TopResourceDirectory + LangResourceDirectoryEntry->NameOffset);

                                LangResourceNameOrId = (ULONG_PTR)ResourceNameString;
                                }
                            else {
                                LangResourceNameOrId = (ULONG_PTR)LangResourceDirectoryEntry->Id;
                                }

                            ResourceDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                                    ((PCHAR)TopResourceDirectory + LangResourceDirectoryEntry->OffsetToData);

                            ResourceInfo = &Resources[ ResourceIndex++ ];
                            if (ResourceIndex <= MaxResourceIndex) {
                                ResourceInfo->Path[ 0 ].NameOrId = TypeResourceNameOrId;
                                ResourceInfo->Path[ 1 ].NameOrId = NameResourceNameOrId;
                                ResourceInfo->Path[ 2 ].NameOrId = LangResourceNameOrId;
                                ResourceInfo->Data = (PVOID)((ULONG_PTR)DllHandle + ResourceDataEntry->OffsetToData);
                                ResourceInfo->Size = ResourceDataEntry->Size;
                                ResourceInfo->Reserved = 0;
                                }
                            else {
                                Status = STATUS_INFO_LENGTH_MISMATCH;
                                }
                            }
                        }
                    }
                }
            }
        }

    *NumberOfResources = ResourceIndex;
    return Status;
}

#ifndef NTOS_KERNEL_RUNTIME

BOOLEAN
LdrAlternateResourcesEnabled(
    VOID
    )

/*++

Routine Description:

    This function determines if the althernate resources are enabled.

Arguments:

    None.

Return Value:

    True - Alternate Resource enabled.
    False - Alternate Resource not enabled.

--*/

{
    NTSTATUS Status;

    if (!UILangId || NtCurrentTeb()->ImpersonationLocale){
        Status = NtQueryDefaultUILanguage( &UILangId );

        if (!NT_SUCCESS( Status )) {
            //
            //  Failed to get UI LangID.  AltResource not enabled.
            //
            return FALSE;
            }
        }

    if (!InstallLangId){
        Status = NtQueryInstallUILanguage( &InstallLangId);

        if (!NT_SUCCESS( Status )) {
            //
            //  Failed to get Intall LangID.  AltResource not enabled.
            //
            return FALSE;
            }
        }

    if (UILangId == InstallLangId) {
        //
        //  UI Lang matches Installed Lang. AltResource not enabled.
        //
        return FALSE;
        }
    return TRUE;
}

PVOID
LdrGetAlternateResourceModuleHandle(
    IN PVOID Module
    )
/*++

Routine Description:

    This function gets the alternate resource module from the table
    containing the handle.

Arguments:

    Module - Module of which alternate resource module needs to loaded.

Return Value:

   Handle of the alternate resource module.

--*/

{
    ULONG ModuleIndex;

    for (ModuleIndex = 0;
         ModuleIndex < AlternateResourceModuleCount;
         ModuleIndex++ ){
        if (AlternateResourceModules[ModuleIndex].ModuleBase ==
            Module){
            return AlternateResourceModules[ModuleIndex].AlternateModule;
        }
    }
    return NULL;
}

BOOLEAN
LdrpGetFileVersion(
    IN  PVOID      ImageBase,
    IN  LANGID     LangId,
    OUT PULONGLONG Version
    )

/*++

Routine Description:

    Get the version stamp out of the VS_FIXEDFILEINFO resource in a PE
    image.

Arguments:

    ImageBase - supplies the address in memory where the file is mapped in.

    Version - receives 64bit version number, or 0 if the file is not
        a PE image or has no version data.

Return Value:

    None.

--*/

{
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    NTSTATUS Status;
    ULONG_PTR IdPath[3];
    ULONG ResourceSize;


    typedef struct tagVS_FIXEDFILEINFO
    {
        LONG   dwSignature;            /* e.g. 0xfeef04bd */
        LONG   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
        LONG   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
        LONG   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
        LONG   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
        LONG   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
        LONG   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
        LONG   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
        LONG   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
        LONG   dwFileType;             /* e.g. VFT_DRIVER */
        LONG   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
        LONG   dwFileDateMS;           /* e.g. 0 */
        LONG   dwFileDateLS;           /* e.g. 0 */
    } VS_FIXEDFILEINFO;

    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];              // L"VS_VERSION_INFO" + unicode null terminator
        VS_FIXEDFILEINFO FixedFileInfo;
    } *Resource;

    *Version = 0;


    IdPath[0] = RT_VERSION;
    IdPath[1] = 1;
    IdPath[2] = LangId;

    try {
        Status = LdrpSearchResourceSection_U(
                    ImageBase,
                    IdPath,
                    3,
                    LDR_FIND_RESOURCE_LANGUAGE_EXACT,
                    &DataEntry);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }

    if(!NT_SUCCESS(Status)) {
        return FALSE;
    }

    try {
        Status = LdrpAccessResourceData(
                    ImageBase,
                    DataEntry,
                    &Resource,
                    &ResourceSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }

    if(!NT_SUCCESS(Status)) {
        return FALSE;
    }

    try {
        if((ResourceSize >= sizeof(*Resource))
            && !_wcsicmp(Resource->Name,L"VS_VERSION_INFO")) {

            *Version = ((ULONGLONG)Resource->FixedFileInfo.dwFileVersionMS << 32)
                     | (ULONGLONG)Resource->FixedFileInfo.dwFileVersionLS;

        } else {
            DbgPrint(("LDR: Warning: invalid version resource\n"));
            return FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint(("LDR: Exception encountered processing bogus version resource\n"));
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
LdrpGetResourceChecksum(
    IN PVOID Module,
    OUT unsigned char** ppMD5Checksum
    )
{
    NTSTATUS Status;
    ULONG_PTR IdPath[3];
    ULONG ResourceSize;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;

    LONG BlockLen;
    LONG VarFileInfoSize;

    typedef struct tagVS_FIXEDFILEINFO
    {
        LONG   dwSignature;            /* e.g. 0xfeef04bd */
        LONG   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
        LONG   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
        LONG   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
        LONG   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
        LONG   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
        LONG   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
        LONG   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
        LONG   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
        LONG   dwFileType;             /* e.g. VFT_DRIVER */
        LONG   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
        LONG   dwFileDateMS;           /* e.g. 0 */
        LONG   dwFileDateLS;           /* e.g. 0 */
    } VS_FIXEDFILEINFO;

    struct 
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];              // L"VS_VERSION_INFO" + unicode null terminator
        // Note that the previous 4 members has 16*2 + 3*2 = 38 bytes. 
        // So that compiler will silently add a 2 bytes padding to make
        // FixedFileInfo to align in DWORD boundary.
        VS_FIXEDFILEINFO FixedFileInfo;
    } *Resource;

    typedef struct tagVERBLOCK
    {
        USHORT wTotalLen;
        USHORT wValueLen;
        USHORT wType;
        WCHAR szKey[1];
        // BYTE[] padding
        // WORD value;
    } VERBLOCK;
    VERBLOCK *pVerBlock;
    
    IdPath[0] = RT_VERSION;
    IdPath[1] = 1;
    IdPath[2] = 0;

    //
    // find the version resource data entry
    //
    try 
    {
        Status = LdrFindResource_U(Module,IdPath,3,&DataEntry);
    } except(EXCEPTION_EXECUTE_HANDLER) 
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    if(!NT_SUCCESS(Status)) 
    {
        return (FALSE);
    }

    //
    // Access the version resource data.
    //
    try 
    {
        Status = LdrpAccessResourceData(
                    Module,
                    DataEntry,
                    &Resource,
                    &ResourceSize);
    } except(EXCEPTION_EXECUTE_HANDLER) 
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    if(!NT_SUCCESS(Status)) 
    {
        return FALSE;
    }

    try 
    {
        if((ResourceSize < sizeof(*Resource))
            || _wcsicmp(Resource->Name,L"VS_VERSION_INFO") != 0) 
        {
            DbgPrint(("LDR: Warning: invalid version resource\n"));
            return FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint(("LDR: Exception encountered processing bogus version resource\n"));
        return FALSE;
    }

    ResourceSize -= DWORD_ALIGNMENT(sizeof(*Resource));

    //
    // Get the beginning address of the children of the version information.
    //
    pVerBlock = (VERBLOCK*)(Resource + 1);
    while (ResourceSize > 0)
    {        
        if (wcscmp(pVerBlock->szKey, L"VarFileInfo") == 0)
        {
            //
            // Find VarFileInfo block. Search the ResourceChecksum block.
            // 
            VarFileInfoSize = pVerBlock->wTotalLen;
            BlockLen =DWORD_ALIGNMENT(sizeof(*pVerBlock) -1 + sizeof(L"VarFileInfo"));
            VarFileInfoSize -= BlockLen;
            pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
            while (VarFileInfoSize > 0)
            {
                if (wcscmp(pVerBlock->szKey, L"ResourceChecksum") == 0)
                {
                    *ppMD5Checksum = (unsigned char*)DWORD_ALIGNMENT((UINT_PTR)(pVerBlock->szKey) + sizeof(L"ResourceChecksum"));
                    return (TRUE);
                }
                BlockLen = DWORD_ALIGNMENT(pVerBlock->wTotalLen);
                pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
                VarFileInfoSize -= BlockLen;
            }
            return (FALSE);
        }
        BlockLen = DWORD_ALIGNMENT(pVerBlock->wTotalLen);
        pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
        ResourceSize -= BlockLen;
    }
    return (FALSE); 
}

BOOLEAN
LdrpCalcResourceChecksum(
    IN PVOID Module,
    OUT unsigned char* MD5Checksum
    )
/*++
Rountine Description:
    Enumerate resources in the specified module, and generate a MD5 checksum.
--*/
{
    // The top resource directory.
    PIMAGE_RESOURCE_DIRECTORY TopDirectory;

    // The resource type directory.
    PIMAGE_RESOURCE_DIRECTORY TypeDirectory; 
    // The resource name directory.
    PIMAGE_RESOURCE_DIRECTORY NameDirectory; 
    // The resource language directory.
    PIMAGE_RESOURCE_DIRECTORY LangDirectory; 
    
    PIMAGE_RESOURCE_DIRECTORY_ENTRY TypeDirectoryEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY NameDirectoryEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY LangDirectoryEntry;

    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    
    ULONG Size;
    ULONG NumTypeDirectoryEntries;
    ULONG NumNameDirectoryEntries;
    ULONG NumLangDirectoryEntries;

    PVOID ResourceData;
    ULONG ResourceSize;

    ULONG i, j, k;

    LANGID ChecksumLangID;
    ULONGLONG Version;

    try 
    {
        MD5_CTX ChecksumContext;
        //
        // we specify the langauge ID for checksum calculation.
        // First, we search with InstallLangID, If it succeed, InsallID will be used, if not, English used.
        // InatallLangID is already set in LdrAlternateResourcesEnabled and LdrpVerifyAlternateResourceModule.
        //
        ChecksumLangID = ENG_US_LANGID;

        if (InstallLangId != ENG_US_LANGID)
        {
            if (LdrpGetFileVersion(Module, InstallLangId, &Version))
            {
                ChecksumLangID = InstallLangId;
            }
        }
        
        MD5Init(&ChecksumContext);

        //
        // TopDirectory is our reference point to directory offsets.
        //
        TopDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( Module,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &Size
                                        );
        if (!TopDirectory) 
        {
            return (FALSE);
        }

        //
        // Point to the children of the TopResourceDirecotry. 
        // This is the beginning of the type resource directory.
        //
        TypeDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(TopDirectory+1);

        //
        // Get the total number of the types (named resource types + ID resource types)
        //
        NumTypeDirectoryEntries = TopDirectory->NumberOfNamedEntries +
                                       TopDirectory->NumberOfIdEntries;
        for (i=0; i<NumTypeDirectoryEntries; i++, TypeDirectoryEntry++) 
        {
            if (!TypeDirectoryEntry->NameIsString) 
            {
                // If the directory type is an ID, check if this is a version info.
                if (TypeDirectoryEntry->Id == RT_VERSION)
                {
                    //
                    // If this is a version info, just skip it. 
                    // When calculation checksum for resources, version info should not be
                    // included, since they will always be updated when a new version
                    // of the file is created.
                    //
                    continue;
                }
            }
        
            NameDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                ((PCHAR)TopDirectory + TypeDirectoryEntry->OffsetToDirectory);
                    
            //
            // Point to the children of this TypeResourceDirecotry.
            // This will be the beginning of the name resource directory.
            //
            NameDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(NameDirectory+1);

            //
            // Get the total number of the names for the specified type (named resource + ID resource)
            //
            NumNameDirectoryEntries = NameDirectory->NumberOfNamedEntries +
                                           NameDirectory->NumberOfIdEntries;
            for (j=0; j<NumNameDirectoryEntries; j++, NameDirectoryEntry++ ) 
            {   
                LangDirectory = (PIMAGE_RESOURCE_DIRECTORY)
                    ((PCHAR)TopDirectory + NameDirectoryEntry->OffsetToDirectory);

                LangDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(LangDirectory+1);
                NumLangDirectoryEntries = LangDirectory->NumberOfNamedEntries +
                                               LangDirectory->NumberOfIdEntries;
                for (k=0; k<NumLangDirectoryEntries; k++, LangDirectoryEntry++) 
                {
                    NTSTATUS Status;
                    // we caculate RC only based of English language.
                    if ( LangDirectoryEntry->Id != ChecksumLangID )
                    {
                        continue;
                    }
                    ResourceDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)
                            ((PCHAR)TopDirectory + LangDirectoryEntry->OffsetToData);

                    Status = LdrpAccessResourceDataNoMultipleLanguage(
                                            Module,
                                            (const PIMAGE_RESOURCE_DATA_ENTRY)ResourceDataEntry,
                                            &ResourceData,
                                            &ResourceSize
                                            );

                    if (!NT_SUCCESS(Status)) 
                    {
                        return (FALSE);
                    }
                    MD5Update(&ChecksumContext, (unsigned char*)ResourceData, ResourceSize);
                }
            }
        }
        
        MD5Final(&ChecksumContext);
        memcpy(MD5Checksum, ChecksumContext.digest, RESOURCE_CHECKSUM_SIZE);
    } except (EXCEPTION_EXECUTE_HANDLER)
    {
        return (FALSE);
    }
    return (TRUE);
}

BOOLEAN 
LdrpGetRegValueKey(
    IN HANDLE Handle, 
    IN LPWSTR KeyValueName, 
    IN ULONG  KeyValueType,
    OUT PVOID Buffer,
    IN ULONG  BufferSize)
/*++

Routine Description:

    This function returns the the registry key value for MUI versioning.

Arguments:

    Handle - Supplies a handle to the registry which contains MUI versioning
        information.

    KeyValueName - the key name. The values are used to retreive original versiong,
        working version and MUI version.

    KeyValueType - the type of the key value.        

    Buffer - pointer to a variable that will receive the retrieved information.

    BufferSize - The size of the buffer.

Return Value:

    False if the query of the registry fails.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING KeyValueString;
    
    CHAR KeyValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 128 * sizeof(WCHAR)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    RtlInitUnicodeString(&KeyValueString, KeyValueName);
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;    
    Status = NtQueryValueKey( Handle,
                              &KeyValueString,
                              KeyValuePartialInformation,
                              KeyValueInformation,
                              sizeof( KeyValueBuffer ),
                              &ResultLength
                            );

    if (!NT_SUCCESS(Status) || KeyValueInformation->Type != KeyValueType)
    {
        return (FALSE);
    }    

    memcpy(Buffer, KeyValueInformation->Data, BufferSize);
    return (TRUE);
}

NTSTATUS
LdrpCreateKey(
    IN PUNICODE_STRING KeyName,
    IN HANDLE  ParentHandle,
    OUT PHANDLE ChildHandle
    )
/*++

Routine Description:

    Creates a registry key for writting.
    This is a thin wrapper over NtCreateKey().

Arguments:

    KeyName        - Name of the key to create
    ParentHandle    - Handle of parent key
    ChildHandle     - Pointer to where the handle is returned

Return Value:

    Status of create/open

--*/
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;

    //
    // Initialize the OBJECT Attributes to a known value
    //
    InitializeObjectAttributes(
        &objectAttributes,
        KeyName,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL
        );

    //
    // Create the key here
    //
    *ChildHandle = 0;
    status = NtCreateKey(
        ChildHandle,
        KEY_ALL_ACCESS,
        &objectAttributes,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        NULL
        );

    return (status);
}


NTSTATUS
LdrpOpenKey(
    IN PUNICODE_STRING KeyName,
    IN HANDLE  ParentHandle,
    OUT PHANDLE ChildHandle
    )
/*++

Routine Description:

    Open a registry key. This is a thin wrapper of NtOpenKey().

Arguments:

    KeyName        - Name of the key to create
    ParentHandle    - Handle of parent key
    ChildHandle     - Pointer to where the handle is returned

Return Value:

    Status of open registry.

--*/
{
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;

    //
    // Initialize the OBJECT Attributes to a known value
    //
    InitializeObjectAttributes(
        &objectAttributes,
        KeyName,
        OBJ_CASE_INSENSITIVE,
        ParentHandle,
        NULL
        );

    //
    // Create the key here
    //
    *ChildHandle = 0;
    status = NtOpenKey(ChildHandle, KEY_READ, &objectAttributes);

    return (status);
}

BOOLEAN LdrpOpenFileVersionKey(
    IN LPWSTR LangID,
    IN LPWSTR BaseDllName, 
    IN ULONGLONG AltModuleVersion,
    IN LPWSTR AltModuleVersionStr, 
    OUT PHANDLE pHandle)
/*++
Routine Description:

    Open the registry key which contains the versioning information for the specified alternate resource module.

Arguments:

    LangID          - The UI langauge of the resource.
    BaseDllName     - The name of the base DLL.
    AltModulePath   - The full path of the alternate resource module.
    pHandle          - The registry key which stores the version information for this alternate resource module

Return Value:

    Return TRUE if succeeds in opening/creating the key. Otherwise return FALSE.

--*/
{
    BOOLEAN Result = FALSE;    
    HANDLE NlsHandle = NULL, MuiHandle = NULL, VersionHandle = NULL, LangHandle = NULL, DllKeyHandle = NULL;
    UNICODE_STRING BufferString;
    NTSTATUS Status;
    PKEY_BASIC_INFORMATION KeyInfo;
    ULONG ResultLength, Index;    
    
    CHAR ValueBuffer[sizeof(KEY_BASIC_INFORMATION) + 32];
    WCHAR buffer[32];   // Temp string buffer.

    ULONGLONG CachedAlternateVersion;

    CHAR KeyFullInfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION ) + DOS_MAX_PATH_LENGTH * sizeof(WCHAR)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyFullInfo = (PKEY_VALUE_PARTIAL_INFORMATION )KeyFullInfoBuffer;

    ULONG ChecksumDisabled;
    HANDLE UserKeyHandle;              // HKEY_CURRENT_USER equivalent
    ULONG rc;

    *pHandle = NULL;

    rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserKeyHandle);
    if (!NT_SUCCESS(rc))
    {
        return (FALSE);
    }
    
    
    // Open registry REG_MUI_PATH ("HKCU\Software\\Microsoft\\Windows\\CurrentVersion")
    //
    RtlInitUnicodeString(&BufferString, REG_MUI_PATH);
    if (!NT_SUCCESS(LdrpCreateKey(&BufferString, UserKeyHandle, &NlsHandle)))
    {
        goto Exit;
    }
    
    //
    // Open/Create registry in REG_MUI_PATH\MUILanguages
    //
    RtlInitUnicodeString(&BufferString, MUI_MUILANGUAGES_KEY_NAME);
    if (!NT_SUCCESS(LdrpCreateKey(&BufferString, NlsHandle, &MuiHandle)))
    {
        goto Exit;
    }

    //
    // Open/Create REG_MUI_PATH\MUILanguages\FileVersions
    //
    RtlInitUnicodeString(&BufferString, MUI_FILE_VERSION_KEY_NAME);
    if (!NT_SUCCESS(LdrpCreateKey(&BufferString, MuiHandle, &VersionHandle)))
    {
        goto Exit;
    }

    if (LdrpGetRegValueKey(VersionHandle, MUI_RC_CHECKSUM_DISABLE_KEY, REG_DWORD, &ChecksumDisabled, sizeof(ChecksumDisabled)) &&
        ChecksumDisabled == 1)
    {
        goto Exit;
    }
    //
    // Open/Create ""\\HKCU\Software\\Microsoft\\Windows\\CurrentVersion"\\MUILanguages\\FileVersions\\<LangID>"
    //
    RtlInitUnicodeString(&BufferString, LangID);
    if (!NT_SUCCESS(LdrpCreateKey(&BufferString, VersionHandle, &LangHandle)))
    {
        goto Exit;
    }

    //
    // Open/Create "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\MUILanguages\\FileVersions\\<LandID>\\<Name of DLL>"
    //
    RtlInitUnicodeString(&BufferString, BaseDllName);
    if (!NT_SUCCESS(LdrpCreateKey(&BufferString, LangHandle, &DllKeyHandle)))
    {
        goto Exit;
    }

    if (!LdrpGetRegValueKey(DllKeyHandle, MUI_ALTERNATE_VERSION_KEY, REG_QWORD, &CachedAlternateVersion, sizeof(CachedAlternateVersion)))
    {
        RtlInitUnicodeString(&BufferString, MUI_ALTERNATE_VERSION_KEY);
        Result = NT_SUCCESS(NtSetValueKey(DllKeyHandle, &BufferString, 0, REG_QWORD, &AltModuleVersion, sizeof(AltModuleVersion)));
        if (Result) 
        {
            *pHandle = DllKeyHandle;
        }
        goto Exit;
    }

    if (CachedAlternateVersion == AltModuleVersion)
    {
        *pHandle = DllKeyHandle;
        Result = TRUE;
    } else
    {
        //
        // Open/Create "\Registry\Machine\System\CurrentControlSet\Control\Nls\MUILanguages\FileVersions
        //      \<LandID>\<Name of DLL>\<AltVersionStr>"
        //
        RtlInitUnicodeString(&BufferString, AltModuleVersionStr);
        Result = NT_SUCCESS(LdrpCreateKey(&BufferString, DllKeyHandle, pHandle));
    }
Exit:
    if (UserKeyHandle)  {NtClose(UserKeyHandle);}
    if (NlsHandle)      {NtClose(NlsHandle);}
    if (MuiHandle)      {NtClose(MuiHandle);}
    if (VersionHandle)  {NtClose(VersionHandle);}
    if (LangHandle)     {NtClose(LangHandle);}
    // If DllKeyHandle is the handle that we are going to return,
    // we can not close it.
    if (DllKeyHandle && *pHandle != DllKeyHandle)   
    {
        NtClose(DllKeyHandle);
    }
    return (Result);
}

void 
LdrpConvertVersionString(
    IN ULONGLONG ModuleVersion,
    OUT LPWSTR ModuleVersionStr
    )
/*++

Routine Description:
    Convert a 64-bit version information into a Unicode string.

Arguments:

    ModuleVersion - The 64-b8t version information.

    ModuleVersionStr - The converted string.
    
Return Value:

    None.
--*/
{
    LPWSTR StringStart = ModuleVersionStr;
    WCHAR digit;
    // Put the null-terminated char at the end of the converted string.
    ModuleVersionStr[16] = L'\0';       
    ModuleVersionStr += 15;
    while (ModuleVersionStr >= StringStart)
    {
        digit = (WCHAR)(ModuleVersion & (ULONGLONG)0xf);
        *ModuleVersionStr-- = (digit < 10 ? digit + '0' : (digit - 10) + 'a');
        ModuleVersion >>= 4;
    }
    
}

BOOLEAN
LdrpCompareResourceChecksum(
    IN LPWSTR LangID,
    IN PVOID Module,
    IN ULONGLONG ModuleVersion,
    IN PVOID AlternateModule,
    IN ULONGLONG AltModuleVersion,
    IN LPWSTR BaseDllName
    )    
/*++

Routine Description:

    In the case that the version for the original module is different from that
    of the alternate module, check if the alternate module can still be used
    for the original version.

    First, the function will look at the registry to see if there is information
    cached for the module.

    In the case that the information is not cached for this module, 
    this function will retrieve the MD5 resource checksum from the alternate 
    resource module.  And then check if the MD5 resource checksum is embeded
    in the original module.  If MD5 resource checksum is not in the original
    moduel, it will enumerate all resources in the module to calculate the
    MD5 checksum.

Arguments:

    LangID - Supplies a language of the resource to be loaded.

    Module - The original module.

    ModuleVersion - The version for the original version.

    AlternateModule - The alternate module.

    AltModuleVersion - The version for the alternate module.

    BaseDllName - The name of the DLL.
    
Return Value:

    Ture if the alternate module can be used.

    Otherwise, return false.

--*/
{
    // Flag to indicate if the alternate resource can be used for this module.
    ULONG UseAlternateResource = 0;

    unsigned char* ModuleChecksum;                      // The 128-bit MD5 resource checksum for the module.
    unsigned char  CalculatedModuleChecksum[RESOURCE_CHECKSUM_SIZE];        // The calculated 128-bit MD5 resource checksum for the module.
    unsigned char* AlternateModuleChecksum;             // The 128-bit MD5 resource checksum embeded in the alternate module.

    WCHAR ModuleVersionStr[17];                         // The string for the 16 heximal digit version.
    WCHAR AltModuleVersionStr[17];

    HANDLE Handle = NULL;                                      // The registry which caches the information for this module.
    // Flag to indicate if we have retrieved or calucated the MD5 resource checksum for the original module successfully.
    BOOLEAN FoundModuleChecksum;

    UNICODE_STRING BufferString;

    HANDLE   RCHandle = NULL;
    HANDLE   RCFileHandle = NULL;
    unsigned char  RegisteredModuleChecksum[RESOURCE_CHECKSUM_SIZE];
    BOOLEAN  fIsRCInRegsitry = FALSE;
    
    //
    // Check the cached information in the registry first.
    //
    LdrpConvertVersionString(AltModuleVersion, AltModuleVersionStr);
    //
    // Open the version information key under:
    //      HKCU\Control Panel\International\MUI\FileVersions\<LangID>\<BaseDllName>
    //    
    if (LdrpOpenFileVersionKey(LangID, BaseDllName, AltModuleVersion, AltModuleVersionStr, &Handle))
    {
        LdrpConvertVersionString(ModuleVersion, ModuleVersionStr);
        //
        // Try to check if this module exists in version information.
        // If yes, see if the AlternateModule can be used.
        //

        //
        // Get the cached version information in the registry to see if the original module can re-use the alternative module.
        //    
        if (LdrpGetRegValueKey(Handle, ModuleVersionStr, REG_DWORD, &UseAlternateResource, sizeof(UseAlternateResource))) 
        {
            // Get the cached information.  Let's bail and return the cached result in UseAlternativeResource.
            goto exit;
        }
    }
    
    //
    // When we are here, we know that we either:
    //  1. Can't open the registry key which cached the information. Or
    //  2. This file has never been looked before.
    //        
    // Get the resource checksum for the alternate module.
    //

    //
    // Some US binary in SP has different checksum value from RTM MUI, so we want to look for 
    // special registry created for this purpose before we get checksum from MUI.
    //
    

    RtlInitUnicodeString(&BufferString, REG_MUI_RC_PATH);
    if (NT_SUCCESS(LdrpOpenKey(&BufferString, NULL, &RCHandle)))
    {
        //
        // We open a file key and read a US_SP binary checksum from same Alterhnatve Module.
        //
        RtlInitUnicodeString(&BufferString, BaseDllName);
        if (NT_SUCCESS(LdrpOpenKey(&BufferString, RCHandle, &RCFileHandle)))
        {
            if(LdrpGetRegValueKey(RCFileHandle, AltModuleVersionStr, REG_BINARY, &RegisteredModuleChecksum, RESOURCE_CHECKSUM_SIZE ))
            {
                AlternateModuleChecksum = RegisteredModuleChecksum;
                fIsRCInRegsitry = TRUE;
            }
        }
        
    }

    //
    // Reading checksum from registry or MUI file
    //
    if ( fIsRCInRegsitry || LdrpGetResourceChecksum(AlternateModule, &AlternateModuleChecksum) )
    {
        //
        // First, check if the resource checksum is built in the module.
        //
        if (!(FoundModuleChecksum = LdrpGetResourceChecksum(Module, &ModuleChecksum))) {
            //
            // If not, calculate the resource checksum for the current module.
            //
            if (FoundModuleChecksum = LdrpCalcResourceChecksum(Module, CalculatedModuleChecksum))
            {        
                ModuleChecksum = CalculatedModuleChecksum;
            }
        }
        if (FoundModuleChecksum) 
        {
            if (memcmp(ModuleChecksum, AlternateModuleChecksum, RESOURCE_CHECKSUM_SIZE) == 0)
            {
                //
                // If the checksums are equal, the working version is the module version.
                //
                UseAlternateResource = 1;
            }
        }
    }
    if (Handle != NULL) {
        // If we find the version registry key successfully, cache the result in the registry.
        //
        // Write the working module information into registry.
        //
        RtlInitUnicodeString(&BufferString, ModuleVersionStr);
        NtSetValueKey(Handle, &BufferString, 0, REG_DWORD, &UseAlternateResource, sizeof(UseAlternateResource));
    }
exit:    
    if (Handle != NULL) {NtClose(Handle);}
    if (RCHandle != NULL) {NtClose(RCHandle);}
    if (RCFileHandle != NULL) {NtClose(RCFileHandle);}

    return ((BOOLEAN)(UseAlternateResource));
}

BOOLEAN
LdrpVerifyAlternateResourceModule(
    IN PWSTR LangID,
    IN PVOID Module,
    IN PVOID AlternateModule,
    IN LPWSTR BaseDllName
    )

/*++

Routine Description:

    This function verifies if the alternate resource module has the same
    version of the base module.

Arguments:

    Module - The handle of the base module.
    AlternateModule - The handle of the alternate resource module
    BaseDllName - The file name of base DLL.

Return Value:

    TBD.

--*/

{
    ULONGLONG ModuleVersion;
    ULONGLONG AltModuleVersion;
    NTSTATUS Status;

    if (!UILangId || NtCurrentTeb()->ImpersonationLocale){
        Status = NtQueryDefaultUILanguage( &UILangId);
        if (!NT_SUCCESS( Status )) {
            //
            //  Failed to get UI LangID.  AltResource not enabled.
            //
            return FALSE;
            }
        } 

    if (!LdrpGetFileVersion(AlternateModule, UILangId, &AltModuleVersion)){
        return FALSE;
        }

    if (!InstallLangId){
        Status = NtQueryInstallUILanguage (&InstallLangId);
        if (!NT_SUCCESS( Status )) {
            //
            //  Failed to get Install LangID.  AltResource not enabled.
            //
            return FALSE;
            }
        }

    if (!LdrpGetFileVersion(Module, InstallLangId, &ModuleVersion) && 
         !LdrpGetFileVersion(Module, ENG_US_LANGID, &ModuleVersion)){
            return FALSE;
        }
    
    if (ModuleVersion == AltModuleVersion){
        return TRUE;
        }
    else
    {
#ifdef USE_RC_CHECKSUM
        return (LdrpCompareResourceChecksum(LangID, Module, ModuleVersion, AlternateModule, AltModuleVersion, BaseDllName));
#else        
        return FALSE;
#endif        
    }
}

BOOLEAN
LdrpSetAlternateResourceModuleHandle(
    IN PVOID Module,
    IN PVOID AlternateModule
    )

/*++

Routine Description:

    This function records the handle of the base module and alternate
    resource module in an array.

Arguments:

    Module - The handle of the base module.
    AlternateModule - The handle of the alternate resource module

Return Value:

    TBD.

--*/

{
    PALT_RESOURCE_MODULE NewModules;

    if (AlternateResourceModules == NULL){
        //
        //  Allocate memory of initial size MEMBLOCKSIZE.
        //
        NewModules = RtlAllocateHeap(
                        RtlProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        RESMODSIZE * MEMBLOCKSIZE);
        if (!NewModules){
            return FALSE;
            }
        AlternateResourceModules = NewModules;
        AltResMemBlockCount = MEMBLOCKSIZE;
        }
    else
    if (AlternateResourceModuleCount >= AltResMemBlockCount ){
        //
        //  ReAllocate another chunk of memory.
        //
        NewModules = RtlReAllocateHeap(
                        RtlProcessHeap(),
                        0,
                        AlternateResourceModules,
                        (AltResMemBlockCount + MEMBLOCKSIZE) * RESMODSIZE
                        );

        if (!NewModules){
            return FALSE;
            }
        AlternateResourceModules = NewModules;
        AltResMemBlockCount += MEMBLOCKSIZE;
        }

    AlternateResourceModules[AlternateResourceModuleCount].ModuleBase = Module;
    AlternateResourceModules[AlternateResourceModuleCount].AlternateModule = AlternateModule;



    AlternateResourceModuleCount++;

    return TRUE;

}

PVOID
LdrLoadAlternateResourceModule(
    IN PVOID Module,
    IN LPCWSTR PathToAlternateModule OPTIONAL
    )

/*++

Routine Description:

    This function does the acutally loading into memory of the alternate
    resource module, or loads from the table if it was loaded before.

Arguments:

    Module - The handle of the base module.
    PathToAlternateModule - Optional path from which module is being loaded.

Return Value:

    Handle to the alternate resource module.

--*/

{
    PVOID AlternateModule, DllBase;
    PLDR_DATA_TABLE_ENTRY Entry;
    HANDLE FileHandle, MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING AltDllName;
    PVOID FreeBuffer;
    LPWSTR BaseDllName = NULL, p;
    WCHAR DllPathName[DOS_MAX_PATH_LENGTH];
    ULONG DllPathNameLength, BaseDllNameLength, CopyCount;
    ULONG Digit;
    int i, RetryCount;
    WCHAR AltModulePath[DOS_MAX_PATH_LENGTH];
    WCHAR AltModulePathMUI[DOS_MAX_PATH_LENGTH];
    WCHAR AltModulePathFallback[DOS_MAX_PATH_LENGTH];
    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME RelativeName;
    SIZE_T ViewSize;
    LARGE_INTEGER SectionOffset;
    WCHAR LangIdDir[6];
    PVOID ReturnValue = NULL;

    //
    // The full path of the current MUI file that we are searching.
    //
    UNICODE_STRING CurrentAltModuleFile;
    UNICODE_STRING NtSystemRoot;

    //
    // The current MUI folder that we are searching.
    //
    UNICODE_STRING CurrentAltModulePath;
    WCHAR CurrentAltModulePathBuffer[DOS_MAX_PATH_LENGTH];

    //
    // The string contains the first MUI folder that we will search.
    // This is the folder which lives under the folder of the base DLL.
    // AltDllMUIPath = [the folder of the base DLL] + "\mui" + "\[UI Language]";
    //      E.g. if the base DLL is "c:\winnt\system32\ntdll.dll" and UI language is 0411,
    //      AltDllMUIPath will be "c:\winnt\system32\mui\0411\"
    //
    UNICODE_STRING AltDllMUIPath;         
    WCHAR AltDllMUIPathBuffer[DOS_MAX_PATH_LENGTH];

    //
    // MUI Redir
    //
    UNICODE_STRING BaseDllNameUstr;
    UNICODE_STRING StaticStringAltModulePathRedirected;         
    UNICODE_STRING DynamicStringAltModulePathRedirected;
    PUNICODE_STRING FullPathStringFoundAltModulePathRedirected = NULL;
    BOOLEAN fRedirMUI = FALSE;
    PVOID LockCookie = NULL;

    // bail out early if this isn't a MUI-enabled system
    if (!LdrAlternateResourcesEnabled()) {
        return NULL;
        }
    
    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {
        //
        // Look at the cache of the alternate module first.
        //
        AlternateModule = LdrGetAlternateResourceModuleHandle(Module);
        if (AlternateModule == NO_ALTERNATE_RESOURCE_MODULE) {
            //
            //  We tried to load this module before but failed. Don't try
            //  again in the future.
            //
            return NULL;
        } else if (AlternateModule > 0) {
            //
            //  We found the previously loaded match
            //
            return AlternateModule;
        }

        AlternateModule = NULL;

        if (ARGUMENT_PRESENT(PathToAlternateModule)) {
            //
            //  Caller suplied path.
            //

            p = wcsrchr(PathToAlternateModule, L'\\');

            if (p == NULL)
                goto error_exit;

            p++;

            DllPathNameLength = (ULONG)(p - PathToAlternateModule) * sizeof(WCHAR);

            RtlCopyMemory(
                DllPathName,
                PathToAlternateModule,
                DllPathNameLength);

            BaseDllName = p;
            BaseDllNameLength = wcslen(p);

        } else {
            //
            //  Try to get full dll path from Ldr data table.
            //

            Status = LdrFindEntryForAddress(Module, &Entry);
            if (!NT_SUCCESS(Status))
                goto error_exit;

            DllPathNameLength = Entry->FullDllName.Length - Entry->BaseDllName.Length;

            RtlCopyMemory(
                DllPathName,
                Entry->FullDllName.Buffer,
                DllPathNameLength);

            BaseDllName = Entry->BaseDllName.Buffer;
            BaseDllNameLength = Entry->BaseDllName.Length;
        }

        DllPathName[DllPathNameLength / sizeof(WCHAR)] = UNICODE_NULL;

        //
        // dll redirection for the dll to be loaded xiaoyuw@10/31/2000
        //
        StaticStringAltModulePathRedirected.Buffer = AltModulePath;  // reuse the array instead of define another array
        StaticStringAltModulePathRedirected.Length = 0; 
        StaticStringAltModulePathRedirected.MaximumLength = sizeof(AltModulePath); 

        DynamicStringAltModulePathRedirected.Buffer = NULL; 
        DynamicStringAltModulePathRedirected.Length = 0; 
        DynamicStringAltModulePathRedirected.MaximumLength = 0; 
    
        BaseDllNameUstr.Buffer = AltModulePathMUI; // reuse the array instead of define another array
        BaseDllNameUstr.Length = 0;
        BaseDllNameUstr.MaximumLength = sizeof(AltModulePathMUI);
    
        RtlAppendUnicodeToString(&BaseDllNameUstr, BaseDllName);
        RtlAppendUnicodeToString(&BaseDllNameUstr, L".mui");
    
        Status = RtlDosApplyFileIsolationRedirection_Ustr(
                            RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
                            &BaseDllNameUstr, NULL, 
                            &StaticStringAltModulePathRedirected, 
                            &DynamicStringAltModulePathRedirected, 
                            &FullPathStringFoundAltModulePathRedirected, 
                            NULL,NULL, NULL);
        if (!NT_SUCCESS(Status)) // no redirection info found for this string
        { 
            if (Status != STATUS_SXS_KEY_NOT_FOUND)
                goto error_exit;

            //
            //  Generate the langid directory like "0804\"
            //
            if (!UILangId || NtCurrentTeb()->ImpersonationLocale){
                Status = NtQueryDefaultUILanguage( &UILangId );
                if (!NT_SUCCESS( Status )) {
                    goto error_exit;
                    }
                }

            CopyCount = 0;
            for (i = 12; i >= 0; i -= 4) {
                Digit = ((UILangId >> i) & 0xF);
                if (Digit >= 10) {
                    LangIdDir[CopyCount++] = (WCHAR) (Digit - 10 + L'A');
                } else {
                    LangIdDir[CopyCount++] = (WCHAR) (Digit + L'0');
                }
            }

            LangIdDir[CopyCount++] = L'\\';
            LangIdDir[CopyCount++] = UNICODE_NULL;

            //
            // Create the MUI path under the directory of the base DLL.
            //
            AltDllMUIPath.Buffer = AltDllMUIPathBuffer;
            AltDllMUIPath.Length = 0;
            AltDllMUIPath.MaximumLength = sizeof(AltDllMUIPathBuffer);

            RtlAppendUnicodeToString(&AltDllMUIPath, DllPathName);  // e.g. "c:\winnt\system32\"
            RtlAppendUnicodeToString(&AltDllMUIPath, L"mui\\");     // e.g. "c:\winnt\system32\mui\"
            RtlAppendUnicodeToString(&AltDllMUIPath, LangIdDir);    // e.g. "c:\winnt\system32\mui\0411\"

            CurrentAltModulePath.Buffer = CurrentAltModulePathBuffer;
            CurrentAltModulePath.Length = 0;
            CurrentAltModulePath.MaximumLength = sizeof(CurrentAltModulePathBuffer);
        } else {
            fRedirMUI = TRUE; 
        
            //set CurrentAltModuleFile and CurrentAltModulePath        
            CurrentAltModuleFile.Buffer = AltModulePathMUI;
            CurrentAltModuleFile.Length = 0;
            CurrentAltModuleFile.MaximumLength = sizeof(AltModulePathMUI);

            RtlCopyUnicodeString(&CurrentAltModuleFile, FullPathStringFoundAltModulePathRedirected);
        }

    
        //
        //  Try name with .mui extesion first.
        //
        RetryCount = 0;
        while (RetryCount < 3){
            if ( ! fRedirMUI ) 
            {
        
                switch (RetryCount)
                {
                    case 0:
                        //
                        //  Generate the first path under the folder of the base DLL 
                        //      (e.g. c:\winnt\system32\mui\0804\ntdll.dll)
                        //
                        CurrentAltModuleFile.Buffer = AltModulePathMUI;
                        CurrentAltModuleFile.Length = 0;
                        CurrentAltModuleFile.MaximumLength = sizeof(AltModulePathMUI);

                        RtlCopyUnicodeString(&CurrentAltModuleFile, &AltDllMUIPath);    // e.g. "c:\winnt\system32\mui\0411\"
                        RtlCopyUnicodeString(&CurrentAltModulePath, &AltDllMUIPath);                
                
                        RtlAppendUnicodeToString(&CurrentAltModuleFile, BaseDllName);   // e.g. "c:\winnt\system32\mui\0411\ntdll.dll"
                        RtlAppendUnicodeToString(&CurrentAltModuleFile, L".mui");       // e.g. "c:\winnt\system32\mui\0411\ntdll.dll.mui"      
                        break;
                    case 1:
                        //
                        //  Generate the second path c:\winnt\system32\mui\0804\ntdll.dll.mui
                        //
                        CurrentAltModuleFile.Buffer = AltModulePath;
                        CurrentAltModuleFile.Length = 0;
                        CurrentAltModuleFile.MaximumLength = sizeof(AltModulePath);

                        RtlCopyUnicodeString(&CurrentAltModuleFile, &AltDllMUIPath);    // e.g. "c:\winnt\system32\mui\0411\"    
                        RtlAppendUnicodeToString(&CurrentAltModuleFile, BaseDllName);   // e.g. "c:\winnt\system32\mui\0411\ntdll.dll"
                        break;
                    case 2:
                        //
                        //  Generate path c:\winnt\mui\fallback\0804\foo.exe.mui
                        //
                        CurrentAltModuleFile.Buffer = AltModulePathFallback;
                        CurrentAltModuleFile.Length = 0;
                        CurrentAltModuleFile.MaximumLength = sizeof(AltModulePathFallback);
                
                        RtlInitUnicodeString(&NtSystemRoot, USER_SHARED_DATA->NtSystemRoot);    // e.g. "c:\winnt\system32\"
                        RtlAppendUnicodeStringToString(&CurrentAltModuleFile, &NtSystemRoot);   // e.g. "c:\winnt\system32\"
                        RtlAppendUnicodeToString(&CurrentAltModuleFile, L"\\mui\\fallback\\");  // e.g. "c:\winnt\system32\mui\fallback\"
                        RtlAppendUnicodeToString(&CurrentAltModuleFile, LangIdDir);             // e.g. "c:\winnt\system32\mui\fallback\0411\"

                        RtlCopyUnicodeString(&CurrentAltModulePath, &CurrentAltModuleFile);

                        RtlAppendUnicodeToString(&CurrentAltModuleFile, BaseDllName);           // e.g. "c:\winnt\system32\mui\fallback\0411\ntdll.dll"
                        RtlAppendUnicodeToString(&CurrentAltModuleFile, L".mui");               // e.g. "c:\winnt\system32\mui\fallback\0411\ntdll.dll.mui"
            
                        break;
                }
            }

            if (!RtlDosPathNameToNtPathName_U(
                        CurrentAltModuleFile.Buffer,
                        &AltDllName,
                        NULL,
                        &RelativeName))
                goto error_exit;

            FreeBuffer = AltDllName.Buffer;
            if (RelativeName.RelativeName.Length != 0) {
                AltDllName = *(PUNICODE_STRING)&RelativeName.RelativeName;
            } else {
                RelativeName.ContainingDirectory = NULL;
            }

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AltDllName,
                OBJ_CASE_INSENSITIVE,
                RelativeName.ContainingDirectory,
                NULL
                );

            Status = NtCreateFile(
                    &FileHandle,
                    (ACCESS_MASK) GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    0L,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    0L,
                    NULL,
                    0L
                    );
        
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

            if (NT_SUCCESS(Status)) {
                goto CreateSection;
            }

            if (fRedirMUI) { // definitely failed 
                goto error_exit; 
            }

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND && RetryCount == 0) {
                //
                //  Error other than the file name with .mui not found.
                //  Most likely directory is missing.  Skip file name w/o .mui
                //  and goto fallback directory.
                //
                RetryCount++;
            }

            RetryCount++;
        }

        // No alternate resource was found during the iterations.  Fail!
        goto error_exit;

    CreateSection:
        Status = NtCreateSection(
                    &MappingHandle,
                    STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ,
                    NULL,
                    NULL,
                    PAGE_WRITECOPY,
                    SEC_COMMIT,
                    FileHandle
                    );

        NtClose( FileHandle );

        if (!NT_SUCCESS(Status)) {
            goto error_exit;
        }

        SectionOffset.LowPart = 0;
        SectionOffset.HighPart = 0;
        ViewSize = 0;
        DllBase = NULL;

        Status = NtMapViewOfSection(
                    MappingHandle,
                    NtCurrentProcess(),
                    &DllBase,
                    0L,
                    0L,
                    &SectionOffset,
                    &ViewSize,
                    ViewShare,
                    0L,
                    PAGE_WRITECOPY
                    );

        NtClose(MappingHandle);

        if (!NT_SUCCESS(Status)){
            goto error_exit;
        }

        NtHeaders = RtlImageNtHeader(DllBase);
        if (!NtHeaders) {
            NtUnmapViewOfSection(NtCurrentProcess(), (PVOID) DllBase);
            goto error_exit;
        }

        AlternateModule = LDR_VIEW_TO_DATAFILE(DllBase);

        if(!LdrpVerifyAlternateResourceModule(LangIdDir, Module, AlternateModule, BaseDllName)) {
            NtUnmapViewOfSection(NtCurrentProcess(), (PVOID) DllBase);
            goto error_exit;
            }

        LdrpSetAlternateResourceModuleHandle(Module, AlternateModule);
        return AlternateModule;

error_exit:
        if (BaseDllName != NULL) {
            //
            // If we looked for a MUI file and couldn't find one keep track.  If
            // we couldn't get the base dll name (e.g. someone passing in a
            // mapped image with the low bit set but no path name), we don't want
            // to "remember" that there's no MUI.
            //
            LdrpSetAlternateResourceModuleHandle(Module, NO_ALTERNATE_RESOURCE_MODULE);
        }

        return NULL;
    } __finally {
        Status = LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    // Compiler *should* be smart enough to recognize that we don't need a return here...
}

BOOLEAN
LdrUnloadAlternateResourceModule(
    IN PVOID Module
    )

/*++

Routine Description:

    This function unmaps an alternate resource module from the process'
    address space and updates alternate resource module table.

Arguments:

    Module - handle of the base module.

Return Value:

    TBD.

--*/

{
    ULONG ModuleIndex;
    PALT_RESOURCE_MODULE AltModule;
    NTSTATUS Status;
    PVOID LockCookie = NULL;

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    __try {
        if (AlternateResourceModuleCount == 0)
            return TRUE;

        for (ModuleIndex = AlternateResourceModuleCount;
             ModuleIndex > 0;
             ModuleIndex--) {
             if (AlternateResourceModules[ModuleIndex-1].ModuleBase == Module) {
                break;
            }
        }

        if (ModuleIndex == 0)
            return FALSE;

        //
        //  Adjust to the actual index
        //
        ModuleIndex --;

        AltModule = &AlternateResourceModules[ModuleIndex];
        if (AltModule->AlternateModule != NO_ALTERNATE_RESOURCE_MODULE) {
            NtUnmapViewOfSection(
                NtCurrentProcess(),
                LDR_DATAFILE_TO_VIEW(AltModule->AlternateModule));
        }

        if (ModuleIndex != AlternateResourceModuleCount - 1) {
            //
            //  Consolidate the array.  Skip this if unloaded item
            //  is the last element.
            //
            RtlMoveMemory(
                AltModule,
                AltModule + 1,
                (AlternateResourceModuleCount - ModuleIndex - 1) * RESMODSIZE);
        }

        AlternateResourceModuleCount--;

        if (AlternateResourceModuleCount == 0){
            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                AlternateResourceModules
                );
            AlternateResourceModules = NULL;
            AltResMemBlockCount = 0;
        } else {
            if (AlternateResourceModuleCount < AltResMemBlockCount - MEMBLOCKSIZE) {
                AltModule = RtlReAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                AlternateResourceModules,
                                (AltResMemBlockCount - MEMBLOCKSIZE) * RESMODSIZE);

                if (!AltModule)
                    return FALSE;

                AlternateResourceModules = AltModule;
                AltResMemBlockCount -= MEMBLOCKSIZE;
            }
        }
    } __finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    return TRUE;
}


BOOLEAN
LdrFlushAlternateResourceModules(
    VOID
    )

/*++

Routine Description:

    This function unmaps all the alternate resouce modules for the
    process address space. This function would be used mainly by
    CSRSS, and any sub-systems that are permanent during logon and
    logoff.


Arguments:

    None

Return Value:

    TRUE  : Successful
    FALSE : Failed

--*/

{
    ULONG ModuleIndex;
    PALT_RESOURCE_MODULE AltModule;
    NTSTATUS Status;
    PVOID LockCookie = NULL;

    //
    // Grab the loader lock
    //

    Status = LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
    if (!NT_SUCCESS(Status)) {
        // This function erroneously doesn't have any way to communicate failure statuses up so
        // we're stuck with just returning false.
        return FALSE;
    }
    __try {
        if (AlternateResourceModuleCount > 0) {
            //
            // Let's unmap the alternate resource modules from the process
            // address space
            //
            for (ModuleIndex=0;
                 ModuleIndex<AlternateResourceModuleCount;
                 ModuleIndex++) {

                AltModule = &AlternateResourceModules[ModuleIndex];

                if (AltModule->AlternateModule != NO_ALTERNATE_RESOURCE_MODULE) {
                    NtUnmapViewOfSection(NtCurrentProcess(),
                                         LDR_DATAFILE_TO_VIEW(AltModule->AlternateModule));
                }
            }

            //
            // Cleanup alternate resource modules memory
            //
            RtlFreeHeap(RtlProcessHeap(), 0, AlternateResourceModules);
            AlternateResourceModules = NULL;
            AlternateResourceModuleCount = 0;
            AltResMemBlockCount = 0;
        }

        //
        // Re-Initialize the UI language for the current process,
        //
        UILangId = 0;
    } __finally {
        LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
    }

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\lookasid.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookasid.c

Abstract:

    This module implements heap lookaside list function.

Author:

    David N. Cutler (davec) 19-Feb-1995

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

// begin_ntslist

#if !defined(NTSLIST_ASSERT)
#define NTSLIST_ASSERT(x) ASSERT(x)
#endif // !defined(NTSLIST_ASSERT)

#ifdef _NTSLIST_DIRECT_
#define INLINE_SLIST __inline
#define RtlInitializeSListHead       _RtlInitializeSListHead
#define _RtlFirstEntrySList          FirstEntrySList

PSINGLE_LIST_ENTRY
FirstEntrySList (
    const SLIST_HEADER *ListHead
    );

#define RtlInterlockedPopEntrySList  _RtlInterlockedPopEntrySList
#define RtlInterlockedPushEntrySList _RtlInterlockedPushEntrySList
#define RtlInterlockedFlushSList     _RtlInterlockedFlushSList
#define _RtlQueryDepthSList          RtlpQueryDepthSList
#else
#define INLINE_SLIST
#endif // _NTSLIST_DIRECT_

// end_ntslist

//
// Define minimum allocation threshold.
//

#define MINIMUM_ALLOCATION_THRESHOLD 25


// begin_ntslist

//
// Define forward referenced function prototypes.
//

VOID
RtlpInitializeSListHead (
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

PSINGLE_LIST_ENTRY
FASTCALL
RtlpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

USHORT
RtlpQueryDepthSList (
    IN PSLIST_HEADER SListHead
    );

// end_ntslist

VOID
RtlpInitializeHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a heap lookaside list structure

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

    Allocate - Supplies a pointer to an allocate function.

    Free - Supplies a pointer to a free function.

    HeapHandle - Supplies a pointer to the heap that backs this lookaside list

    Flags - Supplies a set of heap flags.

    Size - Supplies the size for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

    //
    // Initialize the lookaside list structure.
    //

    RtlInitializeSListHead(&Lookaside->ListHead);

    Lookaside->Depth = MINIMUM_LOOKASIDE_DEPTH;
    Lookaside->MaximumDepth = 256; //Depth;
    Lookaside->TotalAllocates = 0;
    Lookaside->AllocateMisses = 0;
    Lookaside->TotalFrees = 0;
    Lookaside->FreeMisses = 0;

    Lookaside->LastTotalAllocates = 0;
    Lookaside->LastAllocateMisses = 0;

    return;
}

VOID
RtlpDeleteHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;

    return;
}

VOID
RtlpAdjustHeapLookasideDepth (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function is called periodically to adjust the maximum depth of
    a single heap lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

Return Value:

    None.

--*/

{

    ULONG Allocates;
    ULONG Misses;

    //
    // Compute the total number of allocations and misses for this scan
    // period.
    //

    Allocates = Lookaside->TotalAllocates - Lookaside->LastTotalAllocates;
    Lookaside->LastTotalAllocates = Lookaside->TotalAllocates;
    Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
    Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;

    //
    // Compute target depth of lookaside list.
    //

    {
        ULONG Ratio;
        ULONG Target;

        //
        // If the allocate rate is less than the mimimum threshold, then lower
        // the maximum depth of the lookaside list. Otherwise, if the miss rate
        // is less than .5%, then lower the maximum depth. Otherwise, raise the
        // maximum depth based on the miss rate.
        //

        if (Misses >= Allocates) {
            Misses = Allocates;
        }

        if (Allocates == 0) {
            Allocates = 1;
        }

        Ratio = (Misses * 1000) / Allocates;
        Target = Lookaside->Depth;
        if (Allocates < MINIMUM_ALLOCATION_THRESHOLD) {
            if (Target > (MINIMUM_LOOKASIDE_DEPTH + 10)) {
                Target -= 10;

            } else {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }

        } else if (Ratio < 5) {
            if (Target > (MINIMUM_LOOKASIDE_DEPTH + 1)) {
                Target -= 1;

            } else {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }

        } else {
            Target += ((Ratio * Lookaside->MaximumDepth) / (1000 * 2)) + 5;
            if (Target > Lookaside->MaximumDepth) {
                Target = Lookaside->MaximumDepth;
            }
        }

        Lookaside->Depth = (USHORT)Target;
    }

    return;
}

PVOID
RtlpAllocateFromHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    heap lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->TotalAllocates += 1;

    //
    //  We need to protect ourselves from a second thread that can cause us
    //  to fault on the pop. If we do fault then we'll just do a regular pop
    //  operation
    //

    __try {
        Entry = RtlpInterlockedPopEntrySList(&Lookaside->ListHead);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Entry = NULL;
    }

    if (Entry != NULL) {
        return Entry;
    }

    Lookaside->AllocateMisses += 1;
    return NULL;
}

BOOLEAN
RtlpFreeToHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    BOOLEAN - TRUE if the entry was put on the lookaside list and FALSE
        otherwise.

--*/

{

    Lookaside->TotalFrees += 1;
    if (RtlpQueryDepthSList(&Lookaside->ListHead) < Lookaside->Depth) {
        RtlpInterlockedPushEntrySList(&Lookaside->ListHead,
                                      (PSINGLE_LIST_ENTRY)Entry);

        return TRUE;
    }

    Lookaside->FreeMisses += 1;
    return FALSE;
}

// begin_ntslist

INLINE_SLIST
VOID
RtlInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

{

    RtlpInitializeSListHead(SListHead);
    return;
}

INLINE_SLIST
PSINGLE_LIST_ENTRY
RtlInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    )

/*++

Routine Description:

    This function removes an entry from the front of a sequenced singly
    linked list so that access to the list is synchronized in a MP system.
    If there are no entries in the list, then a value of NULL is returned.
    Otherwise, the address of the entry that is removed is returned as the
    function value.

Arguments:

    ListHead - Supplies a pointer to the sequenced listhead from which
        an entry is to be removed.

Return Value:

   The address of the entry removed from the list, or NULL if the list is
   empty.

--*/

{

    ULONG Count;

    //
    // It is posible during the pop of the sequenced list that an access
    // violation can occur if a stale pointer is dereferenced. This is an
    // acceptable result and the operation can be retried.
    //
    // N.B. The count is used to distinguish the case where the list head
    //      itself causes the access violation and therefore no progress
    //      can be made by repeating the operation.
    //

    Count = 0;
    do {
        __try {
            return RtlpInterlockedPopEntrySList(ListHead);

        } __except (Count++ < 20 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            continue;
        }

    } while (TRUE);
}

INLINE_SLIST
PSINGLE_LIST_ENTRY
RtlInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This function inserts an entry at the head of a sequenced singly linked
    list so that access to the list is synchronized in an MP system.

Arguments:

    ListHead - Supplies a pointer to the sequenced listhead into which
        an entry is to be inserted.

    ListEntry - Supplies a pointer to the entry to be inserted at the
        head of the list.

Return Value:

    The address of the previous firt entry in the list. NULL implies list
    went from empty to not empty.

--*/

{
    NTSLIST_ASSERT(((ULONG_PTR)ListEntry & 0x7) == 0);

    return RtlpInterlockedPushEntrySList(ListHead, ListEntry);
}

INLINE_SLIST
PSINGLE_LIST_ENTRY
RtlInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    )

/*++

Routine Description:

    This function flushes the entire list of entries on a sequenced singly
    linked list so that access to the list is synchronized in a MP system.
    If there are no entries in the list, then a value of NULL is returned.
    Otherwise, the address of the firt entry on the list is returned as the
    function value.

Arguments:

    ListHead - Supplies a pointer to the sequenced listhead from which
        an entry is to be removed.

Return Value:

    The address of the entry removed from the list, or NULL if the list is
    empty.

--*/

{

    return RtlpInterlockedFlushSList(ListHead);
}

// end_ntslist

USHORT
RtlQueryDepthSList (
    IN PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function queries the depth of the specified SLIST.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    The current depth of the specified SLIST is returned as the function
    value.

--*/

{
     return RtlpQueryDepthSList(SListHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\mrcf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrcf.c

Abstract:

    This module implements the Mrcf compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:

--*/

#include "ntrtlp.h"

#include <stdio.h>


//
//  To decompress/compress a block of data the user needs to
//  provide a work space as an extra parameter to all the exported
//  procedures.  That way the routines will not need to use excessive
//  stack space and will still be multithread safe
//

//
//  Variables for reading and writing bits
//

typedef struct _MRCF_BIT_IO {

    USHORT  abitsBB;        //  16-bit buffer being read
    LONG    cbitsBB;        //  Number of bits left in abitsBB

    PUCHAR  pbBB;           //  Pointer to byte stream being read
    ULONG   cbBB;           //  Number of bytes left in pbBB
    ULONG   cbBBInitial;    //  Initial size of pbBB

} MRCF_BIT_IO;
typedef MRCF_BIT_IO *PMRCF_BIT_IO;

//
//  Maximum back-pointer value, also used to indicate end of compressed stream!
//

#define wBACKPOINTERMAX                  (4415)

//
//  MDSIGNATURE - Signature at start of each compressed block
//
//      This 4-byte signature is used as a check to ensure that we
//      are decompressing data we compressed, and also to indicate
//      which compression method was used.
//
//      NOTE: A compressed block consists of one or more "chunks", separated
//            by the bitsEND_OF_STREAM pattern.
//
//            Byte          Word
//        -----------    ---------
//         0  1  2  3      0    1      Meaning
//        -- -- -- --    ---- ----     ----------------
//        44 53 00 01    5344 0100     MaxCompression
//        44 53 00 02    5344 0200     StandardCompression
//
//      NOTE: The *WORD* values are listed to be clear about the
//            byte ordering!
//

typedef struct _MDSIGNATURE {

    //
    //  Must be MD_STAMP
    //

    USHORT sigStamp;

    //
    //  mdsSTANDARD or mdsMAX
    //

    USHORT sigType;

} MDSIGNATURE;
typedef MDSIGNATURE *PMDSIGNATURE;

#define MD_STAMP        0x5344  // Signature stamp at start of compressed blk
#define MASK_VALID_mds  0x0300  // All other bits must be zero


//
//  Local procedure declarations and macros
//

#define minimum(a,b) (a < b ? a : b)

//
//  Local procedure prototypes
//

VOID
MrcfSetBitBuffer (
    PUCHAR pb,
    ULONG cb,
    PMRCF_BIT_IO BitIo
    );

VOID
MrcfFillBitBuffer (
    PMRCF_BIT_IO BitIo
    );

USHORT
MrcfReadBit (
    PMRCF_BIT_IO BitIo
    );

USHORT
MrcfReadNBits (
    LONG cbits,
    PMRCF_BIT_IO BitIo
    );


NTSTATUS
RtlDecompressBufferMrcf (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine decompresses a buffer of StandardCompressed or MaxCompressed
    data.

Arguments:

    UncompressedBuffer - buffer to receive uncompressed data

    UncompressedBufferSize - length of UncompressedBuffer

          NOTE: UncompressedBufferSize must be the EXACT length of the uncompressed
                data, as Decompress uses this information to detect
                when decompression is complete.  If this value is
                incorrect, Decompress may crash!

    CompressedBuffer - buffer containing compressed data

    CompressedBufferSize - length of CompressedBuffer

    WorkSpace - pointer to a private work area for use by this operation

Return Value:

    ULONG - Returns the size of the decompressed data in bytes. Returns 0 if
        there was an error in the decompress.

--*/

{
    MRCF_BIT_IO WorkSpace;

    ULONG  cbMatch; //  Length of match string
    ULONG  i;       //  Index in UncompressedBuffer to receive decoded data
    ULONG  iMatch;  //  Index in UncompressedBuffer of matched string
    ULONG  k;       //  Number of bits in length string
    ULONG  off;     //  Offset from i in UncompressedBuffer of match string
    USHORT x;       //  Current bit being examined
    ULONG  y;

    //
    //  verify that compressed data starts with proper signature
    //

    if (CompressedBufferSize < sizeof(MDSIGNATURE) ||                            // Must have signature
        ((PMDSIGNATURE)CompressedBuffer)->sigStamp != MD_STAMP ||            // Stamp must be OK
        ((PMDSIGNATURE)CompressedBuffer)->sigType & (~MASK_VALID_mds)) {     // Type must be OK

        *FinalUncompressedSize = 0;
        return STATUS_BAD_COMPRESSION_BUFFER;
    }

    //
    //  Skip over the valid signature
    //

    CompressedBufferSize -= sizeof(MDSIGNATURE);
    CompressedBuffer += sizeof(MDSIGNATURE);

    //
    //  Set up for decompress, start filling UncompressedBuffer at front
    //

    i = 0;

    //
    //  Set statics to save parm passing
    //

    MrcfSetBitBuffer(CompressedBuffer,CompressedBufferSize,&WorkSpace);

    while (TRUE) {

        y = MrcfReadNBits(2,&WorkSpace);

        //
        //  Check if next 7 bits are a byte
        //  1 if 128..255 (0x80..0xff), 2 if 0..127 (0x00..0x7f)
        //

        if (y == 1 || y == 2) {

            ASSERTMSG("Don't exceed expected length ", i<UncompressedBufferSize);

            UncompressedBuffer[i] = (UCHAR)((y == 1 ? 0x80 : 0) | MrcfReadNBits(7,&WorkSpace));

            i++;

        } else {

            //
            //  Have match sequence
            //

            //
            // Get the offset
            //

            if (y == 0) {

                //
                //  next 6 bits are offset
                //

                off = MrcfReadNBits(6,&WorkSpace);

                ASSERTMSG("offset 0 is invalid ", off != 0);

            } else {

                x = MrcfReadBit(&WorkSpace);

                if (x == 0) {

                    //
                    //  next 8 bits are offset-64 (0x40)
                    //

                    off = MrcfReadNBits(8, &WorkSpace) + 64;

                } else {

                    //
                    //  next 12 bits are offset-320 (0x140)
                    //

                    off = MrcfReadNBits(12, &WorkSpace) + 320;

                    if (off == wBACKPOINTERMAX) {

                        //
                        //  EOS marker
                        //

                        if (i >= UncompressedBufferSize) {

                            //
                            // Done with entire buffer
                            //

                            *FinalUncompressedSize = i;
                            return STATUS_SUCCESS;

                        } else {

                            //
                            //  More to do
                            //  Done with a 512-byte chunk
                            //

                            continue;
                        }
                    }
                }
            }

            ASSERTMSG("Don't exceed expected length ", i<UncompressedBufferSize);
            ASSERTMSG("Cannot match before start of uncoded buffer! ", off <= i);

            //
            //  Get the length  - logarithmically encoded
            //

            for (k=0; (x=MrcfReadBit(&WorkSpace)) == 0; k++) { NOTHING; }

            ASSERT(k <= 8);

            if (k == 0) {

                //
                //  All matches at least 2 chars long
                //

                cbMatch = 2;

            } else {

                cbMatch = (1 << k) + 1 + MrcfReadNBits(k, &WorkSpace);
            }

            ASSERTMSG("Don't exceed buffer size ", (i - off + cbMatch - 1) <= UncompressedBufferSize);

            //
            //  Copy the matched string
            //

            iMatch = i - off;

            while ( (cbMatch > 0) && (i<UncompressedBufferSize) ) {

                UncompressedBuffer[i++] = UncompressedBuffer[iMatch++];
                cbMatch--;
            }

            ASSERTMSG("Should have copied it all ", cbMatch == 0);
        }
    }
}


//
//  Internal Support Routine
//

VOID
MrcfSetBitBuffer (
    PUCHAR pb,
    ULONG cb,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Set statics with coded buffer pointer and length

Arguments:

    pb - pointer to compressed data buffer

    cb - length of compressed data buffer

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    None.

--*/

{
    BitIo->pbBB        = pb;
    BitIo->cbBB        = cb;
    BitIo->cbBBInitial = cb;
    BitIo->cbitsBB     = 0;
    BitIo->abitsBB     = 0;
}


//
//  Internal Support Routine
//

USHORT
MrcfReadBit (
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Get next bit from bit buffer

Arguments:

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    USHORT - Returns next bit (0 or 1)

--*/

{
    USHORT bit;

    //
    //  Check if no bits available
    //

    if ((BitIo->cbitsBB) == 0) {

        MrcfFillBitBuffer(BitIo);
    }

    //
    //  Decrement the bit count
    //  get the bit, remove it, and return the bit
    //

    (BitIo->cbitsBB)--;
    bit = (BitIo->abitsBB) & 1;
    (BitIo->abitsBB) >>= 1;

    return bit;
}


//
//  Internal Support Routine
//

USHORT
MrcfReadNBits (
    LONG cbits,
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Get next N bits from bit buffer

Arguments:

    cbits - count of bits to get

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    USHORT - Returns next cbits bits.

--*/

{
    ULONG abits;        // Bits to return
    LONG cbitsPart;    // Partial count of bits
    ULONG cshift;       // Shift count
    ULONG mask;         // Mask

    //
    //  Largest number of bits we should read at one time is 12 bits for
    //  a 12-bit offset.  The largest length field component that we
    //  read is 8 bits.  If this routine were used for some other purpose,
    //  it can support up to 15 (NOT 16) bit reads, due to how the masking
    //  code works.
    //

    ASSERT(cbits <= 12);

    //
    //  No shift and no bits yet
    //

    cshift = 0;
    abits = 0;

    while (cbits > 0) {

        //
        //  If not bits available get some bits
        //

        if ((BitIo->cbitsBB) == 0) {

            MrcfFillBitBuffer(BitIo);
        }

        //
        //  Number of bits we can read
        //

        cbitsPart = minimum((BitIo->cbitsBB), cbits);

        //
        //  Mask for bits we want, extract and store them
        //

        mask = (1 << cbitsPart) - 1;
        abits |= ((BitIo->abitsBB) & mask) << cshift;

        //
        //  Remember the next chunk of bits
        //

        cshift = cbitsPart;

        //
        //  Update bit buffer, move remaining bits down and
        //  update count of bits left
        //

        (BitIo->abitsBB) >>= cbitsPart;
        (BitIo->cbitsBB) -= cbitsPart;

        //
        //  Update count of bits left to read
        //

        cbits -= cbitsPart;
    }

    //
    //  Return requested bits
    //

    return (USHORT)abits;
}


//
//  Internal Support Routine
//

VOID
MrcfFillBitBuffer (
    PMRCF_BIT_IO BitIo
    )

/*++

Routine Description:

    Fill abitsBB from static bit buffer

Arguments:

    BitIo - Supplies a pointer to the bit buffer statics

Return Value:

    None.

--*/

{
    ASSERT((BitIo->cbitsBB) == 0);

    switch (BitIo->cbBB) {

    case 0:

        ASSERTMSG("no bits left in coded buffer!", FALSE);

        break;

    case 1:

        //
        //  Get last byte and adjust count
        //

        BitIo->cbitsBB = 8;
        BitIo->abitsBB = *(BitIo->pbBB)++;
        BitIo->cbBB--;

        break;

    default:

        //
        //  Get word and adjust count
        //

        BitIo->cbitsBB = 16;
        BitIo->abitsBB = *((USHORT *)(BitIo->pbBB))++;
        BitIo->cbBB -= 2;

        break;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\lznt1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LZNT1.c

Abstract:

    This module implements the LZNT1 compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:

--*/

#include "ntrtlp.h"

#include <stdio.h>


//
//  Boolean which controls whether the asserts will fire.
//

#if DBG
#if !BLDR_KERNEL_RUNTIME
BOOLEAN Lznt1Break = TRUE;
#else
BOOLEAN Lznt1Break = FALSE;
#endif
#endif

//
//  Declare the internal workspace that we need
//

typedef struct _LZNT1_STANDARD_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

    PUCHAR IndexPTable[4096][2];

} LZNT1_STANDARD_WORKSPACE, *PLZNT1_STANDARD_WORKSPACE;

typedef struct _LZNT1_MAXIMUM_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

} LZNT1_MAXIMUM_WORKSPACE, *PLZNT1_MAXIMUM_WORKSPACE;

typedef struct _LZNT1_FRAGMENT_WORKSPACE {

    UCHAR Buffer[0x1000];

} LZNT1_FRAGMENT_WORKSPACE, *PLZNT1_FRAGMENT_WORKSPACE;

typedef struct _LZNT1_HIBER_WORKSPACE {

    ULONG IndexTable[1<<12];

} LZNT1_HIBER_WORKSPACE, *PLZNT1_HIBER_WORKSPACE;

//
//  Now define the local procedure prototypes.
//

typedef ULONG (*PLZNT1_MATCH_FUNCTION) (
    );

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    );

NTSTATUS
LZNT1CompressChunkHiber (
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    );

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    );

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    );

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlCompressBufferLZNT1_HIBER (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );


//
//  Local data structures
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} COMPRESSED_CHUNK_HEADER, *PCOMPRESSED_CHUNK_HEADER;

#define MAX_UNCOMPRESSED_CHUNK_SIZE (4096)

//
//  USHORT
//  GetCompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  USHORT
//  GetUncompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  VOID
//  SetCompressedChunkHeader (
//      IN OUT COMPRESSED_CHUNK_HEADER ChunkHeader,
//      IN USHORT CompressedChunkSize,
//      IN BOOLEAN IsChunkCompressed
//      );
//

#define GetCompressedChunkSize(CH)   (       \
    (CH).Chunk.CompressedChunkSizeMinus3 + 3 \
)

#define GetUncompressedChunkSize(CH) (MAX_UNCOMPRESSED_CHUNK_SIZE)

#define SetCompressedChunkHeader(CH,CCS,ICC) {        \
    ASSERT((CCS) >= 4 && (CCS) <= 4098);              \
    (CH).Chunk.CompressedChunkSizeMinus3 = (CCS) - 3; \
    (CH).Chunk.ChunkSignature = 3;                    \
    (CH).Chunk.IsChunkCompressed = (ICC);             \
}


//
//  Local macros
//

#define FlagOn(F,SF)    ((F) & (SF))
#define SetFlag(F,SF)   { (F) |= (SF); }
#define ClearFlag(F,SF) { (F) &= ~(SF); }

#define Minimum(A,B)    ((A) < (B) ? (A) : (B))
#define Maximum(A,B)    ((A) > (B) ? (A) : (B))

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

//
// N.B. Several functions below are placed in the PAGELK section
//      because they need to be locked down in memory during Hibernation,
//      since they are used to enable compression of the Hiberfile.
//

#pragma alloc_text(PAGELK, RtlCompressWorkSpaceSizeLZNT1)
#pragma alloc_text(PAGELK, RtlCompressBufferLZNT1)
#pragma alloc_text(PAGELK, RtlCompressBufferLZNT1_HIBER)

#pragma alloc_text(PAGE, RtlDecompressBufferLZNT1)
#pragma alloc_text(PAGE, RtlDecompressFragmentLZNT1)
#pragma alloc_text(PAGE, RtlDescribeChunkLZNT1)
#pragma alloc_text(PAGE, RtlReserveChunkLZNT1)

#pragma alloc_text(PAGELK, LZNT1CompressChunk)
#pragma alloc_text(PAGELK, LZNT1CompressChunkHiber)

#if !defined(_X86_)
#pragma alloc_text(PAGE, LZNT1DecompressChunk)
#endif

#pragma alloc_text(PAGELK, LZNT1FindMatchStandard)
#pragma alloc_text(PAGE, LZNT1FindMatchMaximum)

#endif


NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT Engine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_STANDARD_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_MAXIMUM_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
RtlCompressBufferLZNT1_HIBER (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

    This routine is only to be used on the hibernate path.  It is faster than the normal
    compress code but 5% less space efficient.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Ignored.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    NTSTATUS Status;

    PLZNT1_MATCH_FUNCTION MatchFunction;

    PUCHAR UncompressedChunk;
    PUCHAR CompressedChunk;
    LONG CompressedChunkSize;

    //
    //  The following variable is used to tell if we have processed an entire
    //  buffer of zeros and that we should return an alternate status value
    //

    BOOLEAN AllZero = TRUE;

    //
    //  The following variables are pointers to the byte following the
    //  end of each appropriate buffer.
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    // Only supports HIBER ENGINE
    //
    if (Engine != COMPRESSION_ENGINE_HIBER) {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  For each uncompressed chunk (even the odd sized ending buffer) we will
    //  try and compress the chunk
    //

    for (UncompressedChunk = UncompressedBuffer, CompressedChunk = CompressedBuffer;
         UncompressedChunk < EndOfUncompressedBuffer;
         UncompressedChunk += MAX_UNCOMPRESSED_CHUNK_SIZE, CompressedChunk += CompressedChunkSize) {

        ASSERT(EndOfUncompressedBuffer >= UncompressedChunk);
        ASSERT(EndOfCompressedBuffer >= CompressedChunk);

        //
        //  Call the appropriate engine to compress one chunk. and
        //  return an error if we got one.
        //

        if (!NT_SUCCESS(Status = LZNT1CompressChunkHiber( UncompressedChunk,
                                                          EndOfUncompressedBuffer,
                                                          CompressedChunk,
                                                          EndOfCompressedBuffer,
                                                          &CompressedChunkSize,
                                                          WorkSpace ))) {

            return Status;
        }

        //
        //  See if we stay all zeros.  If not then all zeros will become
        //  false and stay that way no matter what we later compress
        //

        AllZero = AllZero && (Status == STATUS_BUFFER_ALL_ZEROS);
    }

    //
    //  If we are not within two bytes of the end of the compressed buffer then we
    //  need to zero out two more for the ending compressed header and update
    //  the compressed chunk pointer value.  Don't include these bytes in
    //  the count however, as that may force our caller to allocate an unneeded
    //  cluster, since on decompress we will terminate either on these two
    //  bytes of 0, or byte count.
    //

    if (CompressedChunk <= (EndOfCompressedBuffer - 2)) {

        *(CompressedChunk) = 0;
        *(CompressedChunk + 1) = 0;
    }

    //
    //  The final compressed size is the difference between the start of the
    //  compressed buffer and where the compressed chunk pointer was left
    //

    *FinalCompressedSize = (ULONG)(CompressedChunk - CompressedBuffer);

    //
    //  Check if the input buffer was all zeros and return the alternate status
    //  if appropriate
    //

    if (AllZero) { return STATUS_BUFFER_ALL_ZEROS; }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Ignored.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    NTSTATUS Status;

    PLZNT1_MATCH_FUNCTION MatchFunction;

    PUCHAR UncompressedChunk;
    PUCHAR CompressedChunk;
    LONG CompressedChunkSize;

    //
    //  The following variable is used to tell if we have processed an entire
    //  buffer of zeros and that we should return an alternate status value
    //

    BOOLEAN AllZero = TRUE;

    //
    //  The following variables are pointers to the byte following the
    //  end of each appropriate buffer.
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Get the match function we are to be using
    //

    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        MatchFunction = LZNT1FindMatchStandard;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        MatchFunction = LZNT1FindMatchMaximum;

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  For each uncompressed chunk (even the odd sized ending buffer) we will
    //  try and compress the chunk
    //

    for (UncompressedChunk = UncompressedBuffer, CompressedChunk = CompressedBuffer;
         UncompressedChunk < EndOfUncompressedBuffer;
         UncompressedChunk += MAX_UNCOMPRESSED_CHUNK_SIZE, CompressedChunk += CompressedChunkSize) {

        ASSERT(EndOfUncompressedBuffer >= UncompressedChunk);
        ASSERT(EndOfCompressedBuffer >= CompressedChunk);

        //
        //  Call the appropriate engine to compress one chunk. and
        //  return an error if we got one.
        //

        if (!NT_SUCCESS(Status = LZNT1CompressChunk( MatchFunction,
                                                     UncompressedChunk,
                                                     EndOfUncompressedBuffer,
                                                     CompressedChunk,
                                                     EndOfCompressedBuffer,
                                                     &CompressedChunkSize,
                                                     WorkSpace ))) {

            return Status;
        }

        //
        //  See if we stay all zeros.  If not then all zeros will become
        //  false and stay that way no matter what we later compress
        //

        AllZero = AllZero && (Status == STATUS_BUFFER_ALL_ZEROS);
    }

    //
    //  If we are not within two bytes of the end of the compressed buffer then we
    //  need to zero out two more for the ending compressed header and update
    //  the compressed chunk pointer value.  Don't include these bytes in
    //  the count however, as that may force our caller to allocate an unneeded
    //  cluster, since on decompress we will terminate either on these two
    //  bytes of 0, or byte count.
    //

    if (CompressedChunk <= (EndOfCompressedBuffer - 2)) {

        *(CompressedChunk) = 0;
        *(CompressedChunk + 1) = 0;
    }

    //
    //  The final compressed size is the difference between the start of the
    //  compressed buffer and where the compressed chunk pointer was left
    //

    *FinalCompressedSize = (ULONG)(CompressedChunk - CompressedBuffer);

    //
    //  Check if the input buffer was all zeros and return the alternate status
    //  if appropriate
    //

    if (AllZero) { return STATUS_BUFFER_ALL_ZEROS; }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and produces
    its uncompressed equivalent provided the uncompressed data fits
    within the specified destination buffer.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed data.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;
    PUCHAR UncompressedChunk = UncompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    LONG SavedChunkSize;

    LONG UncompressedChunkSize;
    LONG CompressedChunkSize;

    //
    //  The following to variables are pointers to the byte following the
    //  end of each appropriate buffer.  This saves us from doing the addition
    //  for each loop check
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, and then get the first chunk header and make sure it
    //  is not an ending chunk header.
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 4);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );

    //
    //  Now while there is space in the uncompressed buffer to store data
    //  we will loop through decompressing chunks
    //

    while (TRUE) {

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  First make sure the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  Decompress a chunk and return if we get an error
            //

            if (!NT_SUCCESS(Status = LZNT1DecompressChunk( UncompressedChunk,
                                                           EndOfUncompressedBuffer,
                                                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                           CompressedChunk + CompressedChunkSize,
                                                           &UncompressedChunkSize ))) {

                *FinalUncompressedSize = UncompressedChunkSize;

                return Status;
            }

        } else {

            //
            //  The chunk does not contain compressed data so we need to simply
            //  copy over the uncompressed data
            //

            UncompressedChunkSize = GetUncompressedChunkSize( ChunkHeader );

            //
            //  Make sure the data will fit into the output buffer
            //

            if (UncompressedChunk + UncompressedChunkSize > EndOfUncompressedBuffer) {

                UncompressedChunkSize = (ULONG)(EndOfUncompressedBuffer - UncompressedChunk);
            }

            //
            //  Check that the compressed chunk has this many bytes to copy.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + UncompressedChunkSize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( UncompressedChunk,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedChunkSize );
        }

        //
        //  Now update the compressed and uncompressed chunk pointers with
        //  the size of the compressed chunk and the number of bytes we
        //  decompressed into, and then make sure we didn't exceed our buffers
        //

        CompressedChunk += CompressedChunkSize;
        UncompressedChunk += UncompressedChunkSize;

        ASSERT( CompressedChunk <= EndOfCompressedBuffer );
        ASSERT( UncompressedChunk <= EndOfUncompressedBuffer );

        //
        //  Now if the uncompressed is full then we are done
        //

        if (UncompressedChunk == EndOfUncompressedBuffer) { break; }

        //
        //  Otherwise we need to get the next chunk header.  We first
        //  check if there is one, save the old chunk size for the
        //  chunk we just read in, get the new chunk, and then check
        //  if it is the ending chunk header
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        SavedChunkSize = GetUncompressedChunkSize(ChunkHeader);

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );
        if (ChunkHeader.Short == 0) { break; }

        //
        //  At this point we are not at the end of the uncompressed buffer
        //  and we have another chunk to process.  But before we go on we
        //  need to see if the last uncompressed chunk didn't fill the full
        //  uncompressed chunk size.
        //

        if (UncompressedChunkSize < SavedChunkSize) {

            LONG t1;
            PUCHAR t2;

            //
            //  Now we only need to zero out data if the really are going
            //  to process another chunk, to test for that we check if
            //  the zero will go beyond the end of the uncompressed buffer
            //

            if ((t2 = (UncompressedChunk +
                       (t1 = (SavedChunkSize -
                              UncompressedChunkSize)))) >= EndOfUncompressedBuffer) {

                break;
            }

            RtlZeroMemory( UncompressedChunk, t1);
            UncompressedChunk = t2;
        }
    }

    //
    //  If we got out of the loop with the compressed chunk pointer beyond the
    //  end of compressed buffer then the compression buffer is ill formed.
    //

    if (CompressedChunk > EndOfCompressedBuffer) {

        *FinalUncompressedSize = PtrToUlong(CompressedChunk);

        return STATUS_BAD_COMPRESSION_BUFFER;
    }

    //
    //  The final uncompressed size is the difference between the start of the
    //  uncompressed buffer and where the uncompressed chunk pointer was left
    //

    *FinalUncompressedSize = (ULONG)(UncompressedChunk - UncompressedBuffer);

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PLZNT1_FRAGMENT_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and extract an
    uncompressed fragment.

    Output bytes are copied to the fragment buffer until either the
    fragment buffer is full or the end of the uncompressed buffer is
    reached.

    An output variable indicates the number of bytes used to store the
    uncompressed fragment.

Arguments:

    UncompressedFragment - Supplies a pointer to where the uncompressed
        fragment is to be stored.

    UncompressedFragmentSize - Supplies the size, in bytes, of the
        uncompressed fragment buffer.

    CompressedBuffer - Supplies a pointer to the compressed data buffer.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FragmentOffset - Supplies the offset (zero based) where the uncompressed
        fragment is being extract from.  The offset is the position within
        the original uncompressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the Uncompressed fragment buffer to store the data.

    WorkSpace - Stop looking.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    ULONG UncompressedChunkSize;
    ULONG CompressedChunkSize;

    PUCHAR EndOfUncompressedFragment = UncompressedFragment + UncompressedFragmentSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;
    PUCHAR CurrentUncompressedFragment;

    ULONG CopySize;

    ASSERT(UncompressedFragmentSize > 0);

    //
    //  Get the chunk header for the first chunk in the
    //  compressed buffer and extract the uncompressed and
    //  the compressed chunk sizes
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 2);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );
    ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

    UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
    CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

    //
    //  Now we want to skip over chunks that precede the fragment
    //  we're after.  To do that we'll loop until the fragment
    //  offset is within the current chunk.  If it is not within
    //  the current chunk then we'll skip to the next chunk and
    //  subtract the uncompressed chunk size from the fragment offset
    //

    while (FragmentOffset >= UncompressedChunkSize) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  Adjust the fragment offset and move the compressed
        //  chunk pointer to the next chunk
        //

        FragmentOffset -= UncompressedChunkSize;
        CompressedChunk += CompressedChunkSize;

        //
        //  Get the next chunk header and if it is not in use
        //  then the fragment that the user wants is beyond the
        //  compressed data so we'll return a zero sized fragment
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  At this point the current chunk contains the starting point
    //  for the fragment.  Now we'll loop extracting data until
    //  we've filled up the uncompressed fragment buffer or until
    //  we've run out of chunks.  Both test are done near the end of
    //  the loop
    //

    CurrentUncompressedFragment = UncompressedFragment;

    while (TRUE) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }


        //
        //  Now we need to compute the amount of data to copy from the
        //  chunk.  It will be based on either to the end of the chunk
        //  size or the amount of data the user specified
        //

        CopySize = Minimum( UncompressedChunkSize - FragmentOffset, UncompressedFragmentSize );

        //
        //  Now check if the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  The chunk is compressed but now check if the amount
            //  we need to get is the entire chunk and if so then
            //  we can do the decompress straight into the caller's
            //  buffer
            //

            if ((FragmentOffset == 0) && (CopySize == UncompressedChunkSize)) {

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( CurrentUncompressedFragment,
                                                               EndOfUncompressedFragment,
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &CopySize ))) {

                    *FinalUncompressedSize = CopySize;

                    return Status;
                }

            } else {

                //
                //  The caller wants only a portion of this compressed chunk
                //  so we need to read it into our work buffer and then copy
                //  the parts from the work buffer into the caller's buffer
                //

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( (PUCHAR)WorkSpace,
                                                               &WorkSpace->Buffer[0] + sizeof(LZNT1_FRAGMENT_WORKSPACE),
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &UncompressedChunkSize ))) {

                    *FinalUncompressedSize = UncompressedChunkSize;

                    return Status;
                }

                //
                //  If we got less than we were looking for then we are at the
                //  end of the file.  Remember the real uncompressed size and
                //  break out of the loop.
                //

                if ((UncompressedChunkSize - FragmentOffset) < CopySize) {

                    RtlCopyMemory( CurrentUncompressedFragment,
                                   &WorkSpace->Buffer[ FragmentOffset ],
                                   (UncompressedChunkSize - FragmentOffset) );

                    CurrentUncompressedFragment += (UncompressedChunkSize - FragmentOffset);
                    break;
                }

                RtlCopyMemory( CurrentUncompressedFragment,
                               &WorkSpace->Buffer[ FragmentOffset ],
                               CopySize );
            }

        } else {

            //
            //  The chunk is not compressed so we can do a simple copy of the
            //  data.  First verify that the compressed buffer holds this much
            //  data.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset + CopySize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( CurrentUncompressedFragment,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset,
                           CopySize );
        }

        //
        //  Now that we've done at least one copy make sure the fragment
        //  offset is set to zero so the next time through the loop will
        //  start at the right offset
        //

        FragmentOffset = 0;

        //
        //  Adjust the uncompressed fragment information by moving the
        //  pointer up by the copy size and subtracting copy size from
        //  the amount of data the user wants
        //

        CurrentUncompressedFragment += CopySize;
        UncompressedFragmentSize -= CopySize;

        //
        //  Now if the uncompressed fragment size is zero then we're
        //  done
        //

        if (UncompressedFragmentSize == 0) { break; }

        //
        //  Otherwise the user wants more data so we'll move to the
        //  next chunk, and then check if the chunk is is use.  If
        //  it is not in use then we the user is trying to read beyond
        //  the end of compressed data so we'll break out of the loop
        //

        CompressedChunk += CompressedChunkSize;

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) { break; }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  Now either we finished filling up the caller's buffer (and
    //  uncompressed fragment size is zero) or we've exhausted the
    //  compresed buffer (and chunk header is zero).  In either case
    //  we're done and we can now compute the size of the fragment
    //  that we're returning to the caller it is simply the difference
    //  between the start of the buffer and the current position
    //

    *FinalUncompressedSize = (ULONG)(CurrentUncompressedFragment - UncompressedFragment);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and returns
    a description of the current chunk in that buffer, updating
    the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Receives the size of the current chunk pointed
        to by CompressedBuffer.  Returns 0 if STATUS_NO_MORE_ENTRIES.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_NO_MORE_ENTRIES - There is no chunk at the current pointer.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    NTSTATUS Status = STATUS_NO_MORE_ENTRIES;

    //
    //  First initialize outputs
    //

    *ChunkBuffer = *CompressedBuffer;
    *ChunkSize = 0;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, otherwise just return a zero chunk.
    //

    if (*CompressedBuffer <= EndOfCompressedBufferPlus1 - 4) {

        RtlRetrieveUshort( &ChunkHeader, *CompressedBuffer );

        //
        //  Check for end of chunks, terminated by USHORT of 0.
        //  First assume there are no more.
        //

        if (ChunkHeader.Short != 0) {

            Status = STATUS_SUCCESS;

            *ChunkSize = GetCompressedChunkSize(ChunkHeader);
            *CompressedBuffer += *ChunkSize;

            //
            //  Check that the chunk actually fits in the buffer supplied
            //  by the caller.  If not, restore *CompressedBuffer for debug!
            //

            if ((*CompressedBuffer > EndOfCompressedBufferPlus1) ||
                (ChunkHeader.Chunk.ChunkSignature != 3)) {

                ASSERTMSG("CompressedBuffer is bad or too small", !Lznt1Break);

                *CompressedBuffer -= *ChunkSize;

                Status = STATUS_BAD_COMPRESSION_BUFFER;

            //
            //  First make sure the chunk contains compressed data
            //

            } else if (!ChunkHeader.Chunk.IsChunkCompressed) {

                //
                //  The uncompressed chunk must be exactly this size!
                //  If not, restore *CompressedBuffer for debug!
                //

                if (*ChunkSize != MAX_UNCOMPRESSED_CHUNK_SIZE + 2) {

                    ASSERTMSG("Uncompressed chunk is wrong size", !Lznt1Break);

                    *CompressedBuffer -= *ChunkSize;

                    Status = STATUS_BAD_COMPRESSION_BUFFER;

                //
                //  The chunk does not contain compressed data so we need to
                //  remove the chunk header from the chunk description.
                //

                } else {

                    *ChunkBuffer += 2;
                    *ChunkSize -= 2;
                }

            //
            //  Otherwise we have a compressed chunk, and we only need to
            //  see if it is all zeros!  Since the header is already interpreted,
            //  we only have to see if there is exactly one literal and if it
            //  is zero - it doesn't matter what the copy token says - we have
            //  a chunk of zeros!
            //

            } else if ((*ChunkSize == 6) && (*(*ChunkBuffer + 2) == 2) && (*(*ChunkBuffer + 3) == 0)) {

                *ChunkSize = 0;
            }
        }
    }

    return Status;
}


NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This routine reserves space for a chunk of the specified
    size in the buffer, writing in a chunk header if necessary
    (uncompressed or all zeros case).  On return the CompressedBuffer
    pointer points to the next chunk.

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Supplies the compressed size of the chunk to be received.
                Two special values are 0 and MAX_UNCOMPRESSED_CHUNK_SIZE (4096).
                0 means the chunk should be filled with a pattern that equates
                to 4096 0's.  4096 implies that the compression routine should
                prepare to receive all of the data in uncompressed form.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    BOOLEAN Compressed;
    PUCHAR Tail, NextChunk, DontCare;
    ULONG Size;
    NTSTATUS Status;

    ASSERT(ChunkSize <= MAX_UNCOMPRESSED_CHUNK_SIZE);

    //
    //  Calculate the address of the tail of this buffer and its
    //  size, so it can be moved before we store anything.
    //

    Tail = NextChunk = *CompressedBuffer;
    while (NT_SUCCESS(Status = RtlDescribeChunkLZNT1( &NextChunk,
                                                      EndOfCompressedBufferPlus1,
                                                      &DontCare,
                                                      &Size))) {

        //
        //  First time through the loop, capture the address of the next chunk.
        //

        if (Tail == *CompressedBuffer) {
            Tail = NextChunk;
        }
    }

    //
    //  The buffer could be invalid.
    //

    if (Status == STATUS_NO_MORE_ENTRIES) {

        //
        //  The only way to successfully terminate the loop is by finding a USHORT
        //  terminator of 0.  Now calculate the size including the final USHORT
        //  we stopped on.
        //

        Size = (ULONG) (NextChunk - Tail + sizeof(USHORT));

        //
        //  First initialize outputs
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        *ChunkBuffer = *CompressedBuffer;

        //
        //  Make sure that the compressed buffer is at least four bytes long to
        //  start with, otherwise just return a zero chunk.
        //

        if (*CompressedBuffer <= (EndOfCompressedBufferPlus1 - ChunkSize)) {

            //
            //  If the chunk is uncompressed, then we have to adjust the
            //  chunk description for the header.
            //

            if (ChunkSize == MAX_UNCOMPRESSED_CHUNK_SIZE) {

                //
                //  Increase ChunkSize to include header.
                //

                ChunkSize += 2;

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it for an uncompressed chunk.
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              MAX_UNCOMPRESSED_CHUNK_SIZE + 2,
                                              FALSE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Advance to where the uncompressed data goes.
                    //

                    *ChunkBuffer += 2;

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise, if this is a zero chunk we have to build it.
            //

            } else if (ChunkSize == 0) {

                //
                //  It takes 6 bytes to describe a chunk of zeros.
                //

                ChunkSize = 6;

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    //
                    //  Move the tail now that we know where to put it.
                    //

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              6,
                                              TRUE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Now store the mask byte with one literal and the literal
                    //  is 0.
                    //

                    RtlStoreUshort( (*CompressedBuffer + 2), (USHORT)2 );

                    //
                    //  Now store the copy token for copying 4095 bytes from
                    //  the preceding byte (stored as offset 0).
                    //

                    RtlStoreUshort( (*CompressedBuffer + 4), (USHORT)(4095-3));

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise we have a normal compressed chunk.
            //

            } else {

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    Status = STATUS_SUCCESS;
                }
            }

            //
            //  Advance the *CompressedBuffer before return
            //

            *CompressedBuffer += ChunkSize;
        }
    }

    return Status;
}


//
//  The Copy token is two bytes in size.
//  Our definition uses a union to make it easier to set and retrieve token values.
//
//  Copy Token
//
//          Length            Displacement
//
//      12 bits 3 to 4098    4 bits 1 to 16
//      11 bits 3 to 2050    5 bits 1 to 32
//      10 bits 3 to 1026    6 bits 1 to 64
//       9 bits 3 to 514     7 bits 1 to 128
//       8 bits 3 to 258     8 bits 1 to 256
//       7 bits 3 to 130     9 bits 1 to 512
//       6 bits 3 to 66     10 bits 1 to 1024
//       5 bits 3 to 34     11 bits 1 to 2048
//       4 bits 3 to 18     12 bits 1 to 4096
//

#define FORMAT412 0
#define FORMAT511 1
#define FORMAT610 2
#define FORMAT79  3
#define FORMAT88  4
#define FORMAT97  5
#define FORMAT106 6
#define FORMAT115 7
#define FORMAT124 8

//                                4/12  5/11  6/10   7/9   8/8   9/7  10/6  11/5  12/4

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGELKCONST")
#endif
const ULONG FormatMaxLength[]       = { 4098, 2050, 1026,  514,  258,  130,   66,   34,   18 };
const ULONG FormatMaxDisplacement[] = {   16,   32,   64,  128,  256,  512, 1024, 2048, 4096 };

typedef union _LZNT1_COPY_TOKEN {

    struct { USHORT Length : 12; USHORT Displacement :  4; } Fields412;
    struct { USHORT Length : 11; USHORT Displacement :  5; } Fields511;
    struct { USHORT Length : 10; USHORT Displacement :  6; } Fields610;
    struct { USHORT Length :  9; USHORT Displacement :  7; } Fields79;
    struct { USHORT Length :  8; USHORT Displacement :  8; } Fields88;
    struct { USHORT Length :  7; USHORT Displacement :  9; } Fields97;
    struct { USHORT Length :  6; USHORT Displacement : 10; } Fields106;
    struct { USHORT Length :  5; USHORT Displacement : 11; } Fields115;
    struct { USHORT Length :  4; USHORT Displacement : 12; } Fields124;

    UCHAR Bytes[2];

} LZNT1_COPY_TOKEN, *PLZNT1_COPY_TOKEN;

//
//  USHORT
//  GetLZNT1Length (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  USHORT
//  GetLZNT1Displacement (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  VOID
//  SetLZNT1 (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken,
//      IN USHORT Length,
//      IN USHORT Displacement
//      );
//

#define GetLZNT1Length(F,CT) (                   \
    ( F == FORMAT412 ? (CT).Fields412.Length + 3 \
    : F == FORMAT511 ? (CT).Fields511.Length + 3 \
    : F == FORMAT610 ? (CT).Fields610.Length + 3 \
    : F == FORMAT79  ? (CT).Fields79.Length  + 3 \
    : F == FORMAT88  ? (CT).Fields88.Length  + 3 \
    : F == FORMAT97  ? (CT).Fields97.Length  + 3 \
    : F == FORMAT106 ? (CT).Fields106.Length + 3 \
    : F == FORMAT115 ? (CT).Fields115.Length + 3 \
    :                  (CT).Fields124.Length + 3 \
    )                                            \
)

#define GetLZNT1Displacement(F,CT) (                   \
    ( F == FORMAT412 ? (CT).Fields412.Displacement + 1 \
    : F == FORMAT511 ? (CT).Fields511.Displacement + 1 \
    : F == FORMAT610 ? (CT).Fields610.Displacement + 1 \
    : F == FORMAT79  ? (CT).Fields79.Displacement  + 1 \
    : F == FORMAT88  ? (CT).Fields88.Displacement  + 1 \
    : F == FORMAT97  ? (CT).Fields97.Displacement  + 1 \
    : F == FORMAT106 ? (CT).Fields106.Displacement + 1 \
    : F == FORMAT115 ? (CT).Fields115.Displacement + 1 \
    :                  (CT).Fields124.Displacement + 1 \
    )                                                  \
)

#define SetLZNT1(F,CT,L,D) {                                                                             \
    if      (F == FORMAT412) { (CT).Fields412.Length = (L) - 3; (CT).Fields412.Displacement = (D) - 1; } \
    else if (F == FORMAT511) { (CT).Fields511.Length = (L) - 3; (CT).Fields511.Displacement = (D) - 1; } \
    else if (F == FORMAT610) { (CT).Fields610.Length = (L) - 3; (CT).Fields610.Displacement = (D) - 1; } \
    else if (F == FORMAT79)  { (CT).Fields79.Length  = (L) - 3; (CT).Fields79.Displacement  = (D) - 1; } \
    else if (F == FORMAT88)  { (CT).Fields88.Length  = (L) - 3; (CT).Fields88.Displacement  = (D) - 1; } \
    else if (F == FORMAT97)  { (CT).Fields97.Length  = (L) - 3; (CT).Fields97.Displacement  = (D) - 1; } \
    else if (F == FORMAT106) { (CT).Fields106.Length = (L) - 3; (CT).Fields106.Displacement = (D) - 1; } \
    else if (F == FORMAT115) { (CT).Fields115.Length = (L) - 3; (CT).Fields115.Displacement = (D) - 1; } \
    else                     { (CT).Fields124.Length = (L) - 3; (CT).Fields124.Displacement = (D) - 1; } \
}



#pragma optimize("t", on)

//
//  Local support routine
//

NTSTATUS
LZNT1CompressChunkHiber (
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PLZNT1_HIBER_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed chunk and produces
    one compressed chunk provided the compressed data fits within
    the specified destination buffer.

    The LZNT1 format used to store the compressed buffer.

    An output variable indicates the number of bytes used to store
    the compressed chunk.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed chunk.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to where the compressed chunk
        is to be stored.

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalCompressedChunkSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed chunk.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input chunk was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    ULONG  IndexOrigin = WorkSpace->IndexTable[0] + 2*MAX_UNCOMPRESSED_CHUNK_SIZE;
    PUCHAR EndOfCompressedChunkPlus1;
    PUCHAR EndOfCompressedChunkPlus1Minus16;

    PUCHAR InputPointer;
    PUCHAR OutputPointer;

    PUCHAR FlagPointer;
    UCHAR FlagByte;
    ULONG FlagBit;

    ULONG Length;

    UCHAR NullCharacter = 0;

    ULONG Format;
    ULONG MaxLength;
    PUCHAR MaxInputPointer;


    //
    //  First adjust the end of the uncompressed buffer pointer to the smaller
    //  of what we're passed in and the uncompressed chunk size.  We use this
    //  to make sure we never compress more than a chunk worth at a time
    //

    if ((UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE) < EndOfUncompressedBufferPlus1) {

        EndOfUncompressedBufferPlus1 = UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE;
    }

    //
    //  Now set the end of the compressed chunk pointer to be the smaller of the
    //  compressed size necessary to hold the data in an uncompressed form and
    //  the compressed buffer size.  We use this to decide if we can't compress
    //  any more because the buffer is too small or just because the data
    //  doesn't compress very well.
    //

    if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1) < EndOfCompressedBufferPlus1) {

        EndOfCompressedChunkPlus1 = CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1;

    } else {

        EndOfCompressedChunkPlus1 = EndOfCompressedBufferPlus1;
    }
    EndOfCompressedChunkPlus1Minus16 = EndOfCompressedChunkPlus1 - 16;

    //
    //  Now set the input and output pointers to the next byte we are
    //  go to process and asser that the user gave use buffers that were
    //  large enough to hold the minimum size chunks
    //

    InputPointer = UncompressedBuffer;
    OutputPointer = CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER);

    ASSERT(InputPointer < EndOfUncompressedBufferPlus1);
    //**** ASSERT(OutputPointer + 2 <= EndOfCompressedChunkPlus1);

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing.  The Flag pointer denotes
    //  where in the compressed buffer we will store the current
    //  flag byte
    //

    FlagPointer = OutputPointer++;
    FlagBit = 0;
    FlagByte = 0;

    //
    //  While there is some more data to be compressed we will do the
    //  following loop
    //

    //
    //  Ensure that there are at least 3 characters in the buffer
    //  It takes at least that many to make a match
    //

    Format = FORMAT412;
    MaxLength = FormatMaxLength[Format];
    MaxInputPointer = UncompressedBuffer + FormatMaxDisplacement[Format];

    if (OutputPointer < EndOfCompressedChunkPlus1Minus16) {
        PUCHAR EndOfUncompressedBufferPlus1Minus3 = EndOfUncompressedBufferPlus1 - 3;
        while (InputPointer <= EndOfUncompressedBufferPlus1Minus3) {

            UCHAR InputPointer0;
            ULONG Index;
            ULONG InputOffset;
            ULONG MatchedOffset;
            ULONG MatchedIndex;
            PUCHAR MatchedString;

            Index = InputPointer[0];
            Index = ( (Index << 8) | (Index >> 4) );
            Index = ( Index ^ InputPointer[1] ^ (InputPointer[2]<<4) ) & 0xfff;

            MatchedIndex = (ULONG)(WorkSpace->IndexTable[Index]);
            InputOffset = (ULONG)(InputPointer - UncompressedBuffer);
            WorkSpace->IndexTable[Index] = (IndexOrigin + InputOffset);
            MatchedOffset = (ULONG)(MatchedIndex - IndexOrigin);

            //
            //  Check whether purported match lies within current buffer
            //  Recall that the hint vector may contain arbitrary garbage
            //

            if ( (MatchedOffset < InputOffset)
              && ( (MatchedString = UncompressedBuffer + MatchedOffset)
                 , (MatchedString[0] == InputPointer[0]) ) //  do at least 3 characters match?
              && (MatchedString[1] == InputPointer[1])
              && (MatchedString[2] == InputPointer[2]) ) {

                ULONG MaxLength1;
                ULONG MaxLength4;

                while (MaxInputPointer < InputPointer) {
                    Format += 1;
                    MaxLength = FormatMaxLength[Format];
                    MaxInputPointer = UncompressedBuffer + FormatMaxDisplacement[Format];
                }

                MaxLength1 = (ULONG)(EndOfUncompressedBufferPlus1 - InputPointer);
                if (MaxLength < MaxLength1) MaxLength1 = MaxLength;
                MaxLength4 = MaxLength1 - (4 - 1);

                Length = 3;

                for (;;) {
                    if ((long)Length < (long)MaxLength4) {
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        if (InputPointer[Length] != MatchedString[Length]) break;
                        Length++;
                        continue;
                    } else {
                        while (Length < MaxLength1) {
                            if (InputPointer[Length] != MatchedString[Length]) break;
                            Length++;
                        }
                        break;
                    }
                }

                //
                //  We need to output a two byte copy token
                //  Ensure that there is room in the output buffer
                //

                ASSERT((OutputPointer+1) < EndOfCompressedChunkPlus1);

                //
                //  Compute the displacement from the current pointer
                //  to the matched string
                //

                SetFlag(FlagByte, (1 << FlagBit));

                {
                    ULONG Displacement = (ULONG)(InputPointer - MatchedString);
                    ULONG token = ( ( (Displacement-1) << (12-Format) ) | (Length-3) );

                    ASSERT( 0 == ( (Displacement-1) & ~( (1 << (4+Format) ) - 1) ) );
                    ASSERT( 0 == ( (Length-3)       & ~( (1 << (12-Format) ) - 1) ) );

                    *(OutputPointer++) = (UCHAR)(token);
                    *(OutputPointer++) = (UCHAR)(token>>8);
                }

                InputPointer += Length;

            } else {

                //
                //  There is more data to output now make sure the output
                //  buffer is not already full and can contain at least one
                //  more byte
                //

                ASSERT(OutputPointer < EndOfCompressedChunkPlus1);

                ASSERT(!FlagOn(FlagByte, (1 << FlagBit)));

                NullCharacter |= *(OutputPointer++) = *(InputPointer++);

            }

            //
            //  Now adjust the flag bit and check if the flag byte
            //  should now be output.  If so output the flag byte
            //  and scarf up a new byte in the output buffer for the
            //  next flag byte.  Do not advance OutputPointer if we
            //  have no more input anyway!
            //

            FlagBit = (FlagBit + 1) % 8;

            if (!FlagBit) {

                *FlagPointer = FlagByte;
                FlagByte = 0;

                FlagPointer = (OutputPointer++);

                //
                //  Ensure that we have room for the at most 16 bytes
                //  that this flag byte may describe
                //

                if (OutputPointer >= EndOfCompressedChunkPlus1Minus16) { break; }
            }
        }
    }

    //
    //  UNDONE: Could pick up another match or two right at the end of the buffer
    //

    //
    //  Too few characters left for a match, emit them as literals
    //

    if (OutputPointer < EndOfCompressedChunkPlus1Minus16) {
        while (InputPointer < EndOfUncompressedBufferPlus1) {

            while (MaxInputPointer < InputPointer) {
                Format += 1;
                MaxLength = FormatMaxLength[Format];
                MaxInputPointer = UncompressedBuffer + FormatMaxDisplacement[Format];
            }

            //
            //  There is more data to output now make sure the output
            //  buffer is not already full and can contain at least one
            //  more byte
            //

            ASSERT(OutputPointer < EndOfCompressedChunkPlus1);

            ASSERT(!FlagOn(FlagByte, (1 << FlagBit)));

            NullCharacter |= *(OutputPointer++) = *(InputPointer++);

            //
            //  Now adjust the flag bit and check if the flag byte
            //  should now be output.  If so output the flag byte
            //  and scarf up a new byte in the output buffer for the
            //  next flag byte.  Do not advance OutputPointer if we
            //  have no more input anyway!
            //

            FlagBit = (FlagBit + 1) % 8;

            if (!FlagBit) {

                *FlagPointer = FlagByte;
                FlagByte = 0;

                FlagPointer = (OutputPointer++);

                //
                //  Ensure that we have room for the at most 16 bytes
                //  that this flag byte may describe
                //

                if (OutputPointer >= EndOfCompressedChunkPlus1Minus16) { break; }
            }

        }
    }

    //
    //  We've exited the preceeding loop because either the input buffer is
    //  all compressed or because we ran out of space in the output buffer.
    //  Check here if the input buffer is not exhasted (i.e., we ran out
    //  of space)
    //

    if (InputPointer < EndOfUncompressedBufferPlus1) {

        //
        //  We ran out of space, but now if the total space available
        //  for the compressed chunk is equal to the uncompressed data plus
        //  the header then we will make this an uncompressed chunk and copy
        //  over the uncompressed data
        //

        if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER)) <= EndOfCompressedBufferPlus1) {

            COMPRESSED_CHUNK_HEADER ChunkHeader;

            RtlCopyMemory( CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedBuffer,
                           MAX_UNCOMPRESSED_CHUNK_SIZE );

            *FinalCompressedChunkSize = MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER);

            ChunkHeader.Short = 0;

            SetCompressedChunkHeader( ChunkHeader,
                                      (USHORT)*FinalCompressedChunkSize,
                                      FALSE );

            RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

            WorkSpace->IndexTable[0] = IndexOrigin;

            return STATUS_SUCCESS;
        }

        //
        //  Otherwise the input buffer really is too small to store the
        //  compressed chuunk
        //

        WorkSpace->IndexTable[0] = IndexOrigin;

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  At this point the entire input buffer has been compressed so we need
    //  to output the last flag byte, provided it fits in the compressed buffer,
    //  set and store the chunk header.  Now if the Flag pointer doesn't fit
    //  in the output buffer that is because it is one beyond the end and
    //  we incremented output pointer too far so now bring output pointer
    //  back down.
    //

    if (FlagPointer < EndOfCompressedChunkPlus1) {

        *FlagPointer = FlagByte;

    } else {

        OutputPointer--;
    }

    {
        COMPRESSED_CHUNK_HEADER ChunkHeader;

        *FinalCompressedChunkSize = (ULONG)(OutputPointer - CompressedBuffer);

        ChunkHeader.Short = 0;

        SetCompressedChunkHeader( ChunkHeader,
                                  (USHORT)*FinalCompressedChunkSize,
                                  TRUE );

        RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );
    }

    //
    //  Now if the only literal we ever output was a null then the
    //  input buffer was all zeros.
    //

    if (!NullCharacter) {

        WorkSpace->IndexTable[0] = IndexOrigin;

        return STATUS_BUFFER_ALL_ZEROS;
    }

    //
    //  Otherwise return to our caller
    //

    WorkSpace->IndexTable[0] = IndexOrigin;

    return STATUS_SUCCESS;
}

#pragma optimize("t", off)


//
//  Local support routine
//

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed chunk and produces
    one compressed chunk provided the compressed data fits within
    the specified destination buffer.

    The LZNT1 format used to store the compressed buffer.

    An output variable indicates the number of bytes used to store
    the compressed chunk.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed chunk.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to where the compressed chunk
        is to be stored.

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalCompressedChunkSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed chunk.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input chunk was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    PUCHAR EndOfCompressedChunkPlus1;

    PUCHAR InputPointer;
    PUCHAR OutputPointer;

    PUCHAR FlagPointer;
    UCHAR FlagByte;
    ULONG FlagBit;

    LONG Length;
    LONG Displacement;

    LZNT1_COPY_TOKEN CopyToken;

    COMPRESSED_CHUNK_HEADER ChunkHeader;

    UCHAR NullCharacter = 0;

    ULONG Format = FORMAT412;

    //
    //  First adjust the end of the uncompressed buffer pointer to the smaller
    //  of what we're passed in and the uncompressed chunk size.  We use this
    //  to make sure we never compress more than a chunk worth at a time
    //

    if ((UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE) < EndOfUncompressedBufferPlus1) {

        EndOfUncompressedBufferPlus1 = UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE;
    }

    //
    //  Now set the end of the compressed chunk pointer to be the smaller of the
    //  compressed size necessary to hold the data in an uncompressed form and
    //  the compressed buffer size.  We use this to decide if we can't compress
    //  any more because the buffer is too small or just because the data
    //  doesn't compress very well.
    //

    if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1) < EndOfCompressedBufferPlus1) {

        EndOfCompressedChunkPlus1 = CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1;

    } else {

        EndOfCompressedChunkPlus1 = EndOfCompressedBufferPlus1;
    }

    //
    //  Now set the input and output pointers to the next byte we are
    //  go to process and asser that the user gave use buffers that were
    //  large enough to hold the minimum size chunks
    //

    InputPointer = UncompressedBuffer;
    OutputPointer = CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER);

    ASSERT(InputPointer < EndOfUncompressedBufferPlus1);
    //**** ASSERT(OutputPointer + 2 <= EndOfCompressedChunkPlus1);

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing.  The Flag pointer denotes
    //  where in the compressed buffer we will store the current
    //  flag byte
    //

    FlagPointer = OutputPointer++;
    FlagBit = 0;
    FlagByte = 0;

    ChunkHeader.Short = 0;

    //
    //  While there is some more data to be compressed we will do the
    //  following loop
    //

    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->UncompressedBuffer = UncompressedBuffer;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->EndOfUncompressedBufferPlus1 = EndOfUncompressedBufferPlus1;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FormatMaxLength[FORMAT412];

    while (InputPointer < EndOfUncompressedBufferPlus1) {

        while (UncompressedBuffer + FormatMaxDisplacement[Format] < InputPointer) {

            Format += 1;
            ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FormatMaxLength[Format];
        }

        //
        //  Search for a string in the Lempel
        //

        Length = 0;
        if ((InputPointer + 3) <= EndOfUncompressedBufferPlus1) {

            Length = (MatchFunction)( InputPointer, WorkSpace );
        }

        //
        //  If the return length is zero then we need to output
        //  a literal.  We clear the flag bit to denote the literal
        //  output the charcter and build up a character bits
        //  composite that if it is still zero when we are done then
        //  we know the uncompressed buffer contained only zeros.
        //

        if (!Length) {

            //
            //  There is more data to output now make sure the output
            //  buffer is not already full and can contain at least one
            //  more byte
            //

            if (OutputPointer >= EndOfCompressedChunkPlus1) { break; }

            ClearFlag(FlagByte, (1 << FlagBit));

            NullCharacter |= *(OutputPointer++) = *(InputPointer++);

        } else {

            //
            //  We need to output two byte, now make sure that
            //  the output buffer can contain at least two more
            //  bytes.
            //

            if ((OutputPointer+1) >= EndOfCompressedChunkPlus1) { break; }

            //
            //  Compute the displacement from the current pointer
            //  to the matched string
            //

            Displacement = (ULONG)(InputPointer - ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MatchedString);

            SetFlag(FlagByte, (1 << FlagBit));

            SetLZNT1(Format, CopyToken, (USHORT)Length, (USHORT)Displacement);

            *(OutputPointer++) = CopyToken.Bytes[0];
            *(OutputPointer++) = CopyToken.Bytes[1];

            InputPointer += Length;
        }

        //
        //  Now adjust the flag bit and check if the flag byte
        //  should now be output.  If so output the flag byte
        //  and scarf up a new byte in the output buffer for the
        //  next flag byte.  Do not advance OutputPointer if we
        //  have no more input anyway!
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit && (InputPointer < EndOfUncompressedBufferPlus1)) {

            *FlagPointer = FlagByte;
            FlagByte = 0;

            FlagPointer = (OutputPointer++);
        }
    }

    //
    //  We've exited the preceeding loop because either the input buffer is
    //  all compressed or because we ran out of space in the output buffer.
    //  Check here if the input buffer is not exhasted (i.e., we ran out
    //  of space)
    //

    if (InputPointer < EndOfUncompressedBufferPlus1) {

        //
        //  We ran out of space, but now if the total space available
        //  for the compressed chunk is equal to the uncompressed data plus
        //  the header then we will make this an uncompressed chunk and copy
        //  over the uncompressed data
        //

        if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER)) <= EndOfCompressedBufferPlus1) {

            RtlCopyMemory( CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedBuffer,
                           MAX_UNCOMPRESSED_CHUNK_SIZE );

            *FinalCompressedChunkSize = MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER);

            SetCompressedChunkHeader( ChunkHeader,
                                      (USHORT)*FinalCompressedChunkSize,
                                      FALSE );

            RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

            return STATUS_SUCCESS;
        }

        //
        //  Otherwise the input buffer really is too small to store the
        //  compressed chuunk
        //

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  At this point the entire input buffer has been compressed so we need
    //  to output the last flag byte, provided it fits in the compressed buffer,
    //  set and store the chunk header.  Now if the Flag pointer doesn't fit
    //  in the output buffer that is because it is one beyond the end and
    //  we incremented output pointer too far so now bring output pointer
    //  back down.
    //

    if (FlagPointer < EndOfCompressedChunkPlus1) {

        *FlagPointer = FlagByte;

    } else {

        OutputPointer--;
    }

    *FinalCompressedChunkSize = (ULONG)(OutputPointer - CompressedBuffer);

    SetCompressedChunkHeader( ChunkHeader,
                              (USHORT)*FinalCompressedChunkSize,
                              TRUE );

    RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

    //
    //  Now if the only literal we ever output was a null then the
    //  input buffer was all zeros.
    //

    if (!NullCharacter) {

        return STATUS_BUFFER_ALL_ZEROS;
    }

    //
    //  Otherwise return to our caller
    //

    return STATUS_SUCCESS;
}


#if !defined(_X86_)
//
//  Local support routine
//

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed chunk and produces its
    uncompressed equivalent chunk provided the uncompressed data fits
    within the specified destination buffer.

    The compressed buffer must be stored in the LZNT1 format.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        chunk is to be stored.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to the compressed chunk.  (This
        pointer has already been adjusted to point past the chunk header.)

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalUncompressedChunkSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed chunk.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    PUCHAR OutputPointer;
    PUCHAR InputPointer;

    UCHAR FlagByte;
    ULONG FlagBit;

    ULONG Format = FORMAT412;

    //
    //  The two pointers will slide through our input and input buffer.
    //  For the input buffer we skip over the chunk header.
    //

    OutputPointer = UncompressedBuffer;
    InputPointer = CompressedBuffer;

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing
    //

    FlagByte = *(InputPointer++);
    FlagBit = 0;

    //
    //  While we haven't exhausted either the input or output buffer
    //  we will do some more decompression
    //

    while ((OutputPointer < EndOfUncompressedBufferPlus1) && (InputPointer < EndOfCompressedBufferPlus1)) {

        while (UncompressedBuffer + FormatMaxDisplacement[Format] < OutputPointer) { Format += 1; }

        //
        //  Check the current flag if it is zero then the current
        //  input token is a literal byte that we simply copy over
        //  to the output buffer
        //

        if (!FlagOn(FlagByte, (1 << FlagBit))) {

            *(OutputPointer++) = *(InputPointer++);

        } else {

            LZNT1_COPY_TOKEN CopyToken;
            LONG Displacement;
            LONG Length;

            //
            //  The current input is a copy token so we'll get the
            //  copy token into our variable and extract the
            //  length and displacement from the token
            //

            if (InputPointer+1 >= EndOfCompressedBufferPlus1) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  Now grab the next input byte and extract the
            //  length and displacement from the copy token
            //

            CopyToken.Bytes[0] = *(InputPointer++);
            CopyToken.Bytes[1] = *(InputPointer++);

            Displacement = GetLZNT1Displacement(Format, CopyToken);
            Length = GetLZNT1Length(Format, CopyToken);

            //
            //  At this point we have the length and displacement
            //  from the copy token, now we need to make sure that the
            //  displacement doesn't send us outside the uncompressed buffer
            //

            if (Displacement > (OutputPointer - UncompressedBuffer)) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  We also need to adjust the length to keep the copy from
            //  overflowing the output buffer
            //

            if ((OutputPointer + Length) >= EndOfUncompressedBufferPlus1) {

                Length = (ULONG)(EndOfUncompressedBufferPlus1 - OutputPointer);
            }

            //
            //  Now we copy bytes.  We cannot use Rtl Move Memory here because
            //  it does the copy backwards from what the LZ algorithm needs.
            //

            while (Length > 0) {

                *(OutputPointer) = *(OutputPointer-Displacement);

                Length -= 1;
                OutputPointer += 1;
            }
        }

        //
        //  Before we go back to the start of the loop we need to adjust the
        //  flag bit value (it goes from 0, 1, ... 7) and if the flag bit
        //  is back to zero we need to read in the next flag byte.  In this
        //  case we are at the end of the input buffer we'll just break out
        //  of the loop because we're done.
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit) {

            if (InputPointer >= EndOfCompressedBufferPlus1) { break; }

            FlagByte = *(InputPointer++);
        }
    }

    //
    //  The decompression is done so now set the final uncompressed
    //  chunk size and return success to our caller
    //

    *FinalUncompressedChunkSize = (ULONG)(OutputPointer - UncompressedBuffer);

    return STATUS_SUCCESS;
}
#endif // _X86_


//
//  Local support routine
//

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG Index;

    PUCHAR FirstEntry;
    ULONG  FirstLength;

    PUCHAR SecondEntry;
    ULONG  SecondLength;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    Index = ((40543*((((ZivString[0]<<4)^ZivString[1])<<4)^ZivString[2]))>>4) & 0xfff;

    FirstEntry  = WorkSpace->IndexPTable[Index][0];
    FirstLength = 0;

    SecondEntry  = WorkSpace->IndexPTable[Index][1];
    SecondLength = 0;

    //
    //  Check if first entry is good, and if so then get its length
    //

    if ((FirstEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (FirstEntry < ZivString)           &&

        (FirstEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (FirstEntry[1] == ZivString[1])    &&
        (FirstEntry[2] == ZivString[2])) {

        FirstLength = 3;

        while ((FirstLength < MaxLength)

                 &&

               (ZivString + FirstLength < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[FirstLength] == FirstEntry[FirstLength])) {

            FirstLength++;
        }
    }

    //
    //  Check if second entry is good, and if so then get its length
    //

    if ((SecondEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (SecondEntry < ZivString)           &&

        (SecondEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (SecondEntry[1] == ZivString[1])    &&
        (SecondEntry[2] == ZivString[2])) {

        SecondLength = 3;

        while ((SecondLength < MaxLength)

                 &&

               (ZivString + SecondLength< EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[SecondLength] == SecondEntry[SecondLength])) {

            SecondLength++;
        }
    }

    if ((FirstLength >= SecondLength)) {

        WorkSpace->IndexPTable[Index][1] = FirstEntry;
        WorkSpace->IndexPTable[Index][0] = ZivString;

        WorkSpace->MatchedString = FirstEntry;
        return FirstLength;
    }

    WorkSpace->IndexPTable[Index][1] = FirstEntry;
    WorkSpace->IndexPTable[Index][0] = ZivString;

    WorkSpace->MatchedString = SecondEntry;
    return SecondLength;
}


//
//  Local support routine
//

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PLZNT1_MAXIMUM_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

    If the matched string is two or more characters long then this
    routine does not update the lookup state information.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG i;
    ULONG BestMatchedLength;
    PUCHAR q;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    BestMatchedLength = 0;

    for (q = UncompressedBuffer; q < ZivString; q += 1) {

        i = 0;

        while ((i < MaxLength)

                 &&

               (ZivString + i < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[i] == q[i])) {

            i++;
        }

        if (i >= BestMatchedLength) {

            BestMatchedLength = i;
            WorkSpace->MatchedString = q;
        }
    }

    if (BestMatchedLength < 3) {

        return 0;

    } else {

        return BestMatchedLength;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\message.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    message.c

Abstract:

    Message table resource accessing functions

Author:

    Steve Wood (stevewo) 10-Sep-1991

Revision History:

--*/

#include "ntrtlp.h"
#include "string.h"
#include "stdio.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlFindMessage)
#endif

NTSTATUS
RtlFindMessage(
    IN PVOID DllHandle,
    IN ULONG MessageTableId,
    IN ULONG MessageLanguageId,
    IN ULONG MessageId,
    OUT PMESSAGE_RESOURCE_ENTRY *MessageEntry
    )
{
    NTSTATUS Status;
    ULONG NumberOfBlocks;
    ULONG EntryIndex;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    PMESSAGE_RESOURCE_DATA  MessageData;
    PMESSAGE_RESOURCE_BLOCK MessageBlock;
    PCHAR s;
    ULONG_PTR ResourceIdPath[ 3 ];

    RTL_PAGED_CODE();

    ResourceIdPath[ 0 ] = MessageTableId;
    ResourceIdPath[ 1 ] = 1;
    ResourceIdPath[ 2 ] = MessageLanguageId;

    Status = LdrpSearchResourceSection_U( DllHandle,
                                          ResourceIdPath,
                                          3,
                                          0,
                                          (PVOID *)&ResourceDataEntry
                                        );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = LdrpAccessResourceData( DllHandle,
                                     ResourceDataEntry,
                                     (PVOID *)&MessageData,
                                     NULL
                                   );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    NumberOfBlocks = MessageData->NumberOfBlocks;
    MessageBlock = &MessageData->Blocks[ 0 ];
    while (NumberOfBlocks--) {
        if (MessageId >= MessageBlock->LowId &&
            MessageId <= MessageBlock->HighId
           ) {
            s = (PCHAR)MessageData + MessageBlock->OffsetToEntries;
            EntryIndex = MessageId - MessageBlock->LowId;
            while (EntryIndex--) {
                s += ((PMESSAGE_RESOURCE_ENTRY)s)->Length;
                }

            *MessageEntry = (PMESSAGE_RESOURCE_ENTRY)s;
            return( STATUS_SUCCESS );
            }

        MessageBlock++;
        }

    return( STATUS_MESSAGE_NOT_FOUND );
}

#ifndef NTOS_KERNEL_RUNTIME

#define MAX_INSERTS 200

NTSTATUS
RtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Column;
    int cchRemaining, cchWritten;
    PULONG_PTR ArgumentsArray = (PULONG_PTR)Arguments;
    ULONG_PTR rgInserts[ MAX_INSERTS ];
    ULONG cSpaces;
    ULONG MaxInsert, CurInsert;
    ULONG PrintParameterCount;
    ULONG_PTR PrintParameter1;
    ULONG_PTR PrintParameter2;
    WCHAR PrintFormatString[ 32 ];
    BOOLEAN DefaultedFormatString;
    WCHAR c;
    PWSTR s, s1, s2, s3;
    PWSTR lpDst, lpDstBeg, lpDstLastSpace;
    BOOLEAN WideArg = FALSE;

    cchRemaining = Length / sizeof( WCHAR );
    lpDst = Buffer;
    MaxInsert = 0;
    lpDstLastSpace = NULL;
    Column = 0;
    s = MessageFormat;
    while (*s != UNICODE_NULL) {
        if (*s == L'%') {
            s++;
            lpDstBeg = lpDst;
            if (*s >= L'1' && *s <= L'9') {
                CurInsert = *s++ - L'0';
                if (*s >= L'0' && *s <= L'9') {
                    CurInsert = (CurInsert * 10) + (*s++ - L'0');
                    if (*s >= L'0' && *s <= L'9') {
                        CurInsert = (CurInsert * 10) + (*s++ - L'0');
                        if (*s >= L'0' && *s <= L'9') {
                            return( STATUS_INVALID_PARAMETER );
                        }
                    }
                }
                CurInsert -= 1;

                PrintParameterCount = 0;
                if (*s == L'!') {
                    DefaultedFormatString = FALSE;
                    s1 = PrintFormatString;
                    *s1++ = L'%';
                    s2 = s1;
                    s++;
                    while (*s != L'!') {
                        if (*s != UNICODE_NULL) {
                            if (s1 >= &PrintFormatString[ 31 ]) {
                                return( STATUS_INVALID_PARAMETER );
                            }

                            if (*s == L'*') {
                                if (PrintParameterCount++ > 1) {
                                    return( STATUS_INVALID_PARAMETER );
                                }
                            }

                            *s1++ = *s++;
                        } else {
                            return( STATUS_INVALID_PARAMETER );
                        }
                    }

                    s++;
                    *s1 = UNICODE_NULL;
                    WideArg = FALSE;
#if !defined(_IA64_)
                    // look for I64 format string
                    s3 = s2;
                    while (*s3 && !WideArg) {
                        if (s3[0] == L'I' && s3[1] == L'6' && s3[2] == L'4') {
                            WideArg = TRUE;
                        }
                        s3 += 1;
                    }
#endif
                } else {
                    DefaultedFormatString = TRUE;
                    wcscpy( PrintFormatString, L"%s" );
                    s1 = PrintFormatString + wcslen( PrintFormatString );
                    WideArg = FALSE;
                }

                if (IgnoreInserts) {
                    if (!wcscmp( PrintFormatString, L"%s" )) {
                        cchWritten = _snwprintf( lpDst,
                                                 cchRemaining,
                                                 L"%%%u",
                                                 CurInsert+1
                                               );
                    } else {
                        cchWritten = _snwprintf( lpDst,
                                                 cchRemaining,
                                                 L"%%%u!%s!",
                                                 CurInsert+1,
                                                 &PrintFormatString[ 1 ]
                                               );
                    }

                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                } else if (ARGUMENT_PRESENT( Arguments )) {
                    if ((CurInsert+PrintParameterCount) >= MAX_INSERTS) {
                        return( STATUS_INVALID_PARAMETER );
                    }

                    if (ArgumentsAreAnsi) {
                        if (s1[ -1 ] == L'c' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hc" );
                        } else if (s1[ -1 ] == L's' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], L"hs" );
                        } else if (s1[ -1 ] == L'S') {
                            s1[ -1 ] = L's';
                        } else if (s1[ -1 ] == L'C') {
                            s1[ -1 ] = L'c';
                        }
                    }

                    while (CurInsert >= MaxInsert) {
                        if (ArgumentsAreAnArray) {
                            rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                        } else {
                            if (WideArg) {
                                rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                                rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            } else {
                                rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }
                        }
                    }

                    s1 = (PWSTR)rgInserts[ CurInsert ];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0) {
                        if (ArgumentsAreAnArray) {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                        } else {
                            PrintParameter1 = va_arg( *Arguments, ULONG_PTR );
                        }

                        if (PrintParameterCount > 1) {
                            if (ArgumentsAreAnArray) {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *((PULONG_PTR)Arguments)++;
                            } else {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }
                        }
                    }

                    if (WideArg) {
                        cchWritten = _snwprintf(
                            lpDst,
                            cchRemaining,
                            PrintFormatString,
                            *(PULONGLONG)&rgInserts[CurInsert],
                            PrintParameter1,
                            PrintParameter2
                            );
                    } else {
                        cchWritten = _snwprintf(
                            lpDst,
                            cchRemaining,
                            PrintFormatString,
                            s1,
                            PrintParameter1,
                            PrintParameter2
                            );
                    }

                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                } else {
                    return( STATUS_INVALID_PARAMETER );
                }

                if ((cchRemaining -= cchWritten) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                lpDst += cchWritten;
            } else if (*s == L'0') {
                break;
            } else if (!*s) {
                return( STATUS_INVALID_PARAMETER );
            } else if (*s == L'r') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                *lpDst++ = L'\r';
                s++;
                lpDstBeg = NULL;
            } else if (*s == L'n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                s++;
                lpDstBeg = NULL;
            } else if (*s == L't') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                if (Column % 8) {
                    Column = (Column + 7) & ~7;
                } else {
                    Column += 8;
                }

                lpDstLastSpace = lpDst;
                *lpDst++ = L'\t';
                s++;
            } else if (*s == L'b') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                lpDstLastSpace = lpDst;
                *lpDst++ = L' ';
                s++;
            } else if (IgnoreInserts) {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                *lpDst++ = L'%';
                *lpDst++ = *s++;
            } else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                *lpDst++ = *s++;
            }

            if (lpDstBeg == NULL) {
                lpDstLastSpace = NULL;
                Column = 0;
            } else {
                Column += (ULONG)(lpDst - lpDstBeg);
            }
        } else {
            c = *s++;
            if (c == L'\r' || c == L'\n') {
                if ((c == L'\n' && *s == L'\r') ||
                    (c == L'\r' && *s == L'\n')
                   )
                {
                    s++;
                }

                if (MaximumWidth != 0) {
                    lpDstLastSpace = lpDst;
                    c = L' ';
                } else {
                    c = L'\n';
                }
            }

            if (c == L'\n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
            } else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                }

                if (c == L' ') {
                    lpDstLastSpace = lpDst;
                }

                *lpDst++ = c;
                Column += 1;
            }
        }

        if (MaximumWidth != 0 &&
            MaximumWidth != 0xFFFFFFFF &&
            Column >= MaximumWidth
           ) {
            if (lpDstLastSpace != NULL) {
                lpDstBeg = lpDstLastSpace;
                while (*lpDstBeg == L' ' || *lpDstBeg == L'\t') {
                    lpDstBeg += 1;
                    if (lpDstBeg == lpDst) {
                        break;
                        }
                    }
                while (lpDstLastSpace > Buffer) {
                    if (lpDstLastSpace[ -1 ] == L' ' || lpDstLastSpace[ -1 ] == L'\t') {
                        lpDstLastSpace -= 1;
                        }
                    else {
                        break;
                        }
                    }

                cSpaces = (ULONG)(lpDstBeg - lpDstLastSpace);
                if (cSpaces == 1) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }
                    }
                else
                if (cSpaces > 2) {
                    cchRemaining += (cSpaces - 2);
                    }

                memmove( lpDstLastSpace + 2,
                         lpDstBeg,
                         (ULONG) ((lpDst - lpDstBeg) * sizeof( WCHAR ))
                       );
                *lpDstLastSpace++ = L'\r';
                *lpDstLastSpace++ = L'\n';
                Column = (ULONG)(lpDst - lpDstBeg);
                lpDst = lpDstLastSpace + Column;
                lpDstLastSpace = NULL;
                }
            else {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            }
        }

    if ((cchRemaining -= 1) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\0';
    if ( ARGUMENT_PRESENT(ReturnLength) ) {
        *ReturnLength = (ULONG)(lpDst - Buffer) * sizeof( WCHAR );
        }
    return( STATUS_SUCCESS );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\pctohdr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pctohdr.c

Abstract:

    This module implements code to locate the file header for an image or
    dll given a PC value that lies within the image.

    N.B. This routine is conditionalized for user mode and kernel mode.

Author:

    Steve Wood (stevewo) 18-Aug-1989

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#if defined(NTOS_KERNEL_RUNTIME)
#include "ntos.h"
#else
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#if !defined(NTOS_KERNEL_RUNTIME)
extern PVOID NtDllBase;             // defined in ntdll\ldrinit.c
#endif

PVOID
RtlPcToFileHeader(
    IN PVOID PcValue,
    OUT PVOID *BaseOfImage
    )

/*++

Routine Description:

    This function returns the base of an image that contains the
    specified PcValue. An image contains the PcValue if the PcValue
    is within the ImageBase, and the ImageBase plus the size of the
    virtual image.

Arguments:

    PcValue - Supplies a PcValue.  All of the modules mapped into the
        calling processes address space are scanned to compute which
        module contains the PcValue.

    BaseOfImage - Returns the base address for the image containing the
        PcValue.  This value must be added to any relative addresses in
        the headers to locate portions of the image.

Return Value:

    NULL - No image was found that contains the PcValue.

    NON-NULL - Returns the base address of the image that contain the
        PcValue.

--*/

{

#if defined(NTOS_KERNEL_RUNTIME)

    extern LIST_ENTRY PsLoadedModuleList;
    extern KSPIN_LOCK PsLoadedModuleSpinLock;

    PVOID Base;
    ULONG_PTR Bounds;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Next;
    KIRQL OldIrql;

    //
    // Acquire the loaded module list spinlock and scan the list for the
    // specified PC value if the list has been initialized.
    //

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < DISPATCH_LEVEL) {
        KeRaiseIrqlToDpcLevel();
    }

    ExAcquireSpinLockAtDpcLevel(&PsLoadedModuleSpinLock);
    Next = PsLoadedModuleList.Flink;
    if (Next != NULL) {
        while (Next != &PsLoadedModuleList) {
            Entry = CONTAINING_RECORD(Next,
                                      LDR_DATA_TABLE_ENTRY,
                                      InLoadOrderLinks);

            Next = Next->Flink;
            Base = Entry->DllBase;
            Bounds = (ULONG_PTR)Base + Entry->SizeOfImage;
            if (((ULONG_PTR)PcValue >= (ULONG_PTR)Base) && ((ULONG_PTR)PcValue < Bounds)) {
                ExReleaseSpinLock(&PsLoadedModuleSpinLock, OldIrql);
                *BaseOfImage = Base;
                return Base;
            }
        }
    }

    //
    // Release the loaded module list spin lock and return NULL.
    //

    ExReleaseSpinLock(&PsLoadedModuleSpinLock, OldIrql);
    *BaseOfImage = NULL;
    return NULL;

#else

    PVOID Base;
    ULONG_PTR Bounds;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY ModuleListHead;
    PLIST_ENTRY Next;
    PIMAGE_NT_HEADERS NtHeaders;
    PPEB Peb;
    PTEB Teb;
    MEMORY_BASIC_INFORMATION MemInfo;
    NTSTATUS st;
    ULONG LoaderLockDisposition;
    PVOID LockCookie = NULL;

    //
    // Acquire the Loader lock for the current process and scan the loaded
    // module list for the specified PC value if all the data structures
    // have been initialized.
    //

    LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY | LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, &LoaderLockDisposition, &LockCookie);

    if (LoaderLockDisposition == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED) {
        //
        // We could not get the loader lock, so call the system to find the image that
        // contains this pc
        //

        st = NtQueryVirtualMemory(
                NtCurrentProcess(),
                PcValue,
                MemoryBasicInformation,
                &MemInfo,
                sizeof(MemInfo),
                NULL);
        if ( !NT_SUCCESS(st) ) {
            MemInfo.AllocationBase = NULL;
        } else {
            if ( MemInfo.Type == MEM_IMAGE ) {
                try {
                    *BaseOfImage = MemInfo.AllocationBase;
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    MemInfo.AllocationBase = NULL;
                }
            } else {
                MemInfo.AllocationBase = NULL;;
            }
        }
        return MemInfo.AllocationBase;
    }

    // If we *did* get the loader lock, let's avoid the syscall and search the tables.
    __try {
        Teb = NtCurrentTeb();
        if (Teb != NULL) {
            Peb = Teb->ProcessEnvironmentBlock;
            if (Peb->Ldr != NULL) {
                ModuleListHead = &Peb->Ldr->InLoadOrderModuleList;
                Next = ModuleListHead->Flink;
                if (Next != NULL) {
                    while (Next != ModuleListHead) {
                        Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                        Next = Next->Flink;
                        Base = Entry->DllBase;
                        NtHeaders = RtlImageNtHeader(Base);
                        Bounds = (ULONG_PTR)Base + NtHeaders->OptionalHeader.SizeOfImage;
                        if (((ULONG_PTR)PcValue >= (ULONG_PTR)Base) && ((ULONG_PTR)PcValue < Bounds)) {
                            goto Done;
                        }
                    }
                }

            } else {

                //
                //  ( Peb->Ldr == NULL )
                //
                //  If called during process intialization before the Ldr
                //  module list has been setup, code executing must be in
                //  NTDLL module.  If NtDllBase is non-NULL and the PcValue
                //  falls into the NTDLL range, return a valid Base.  This
                //  allows DbgPrint's during LdrpInitializeProcess to work
                //  on RISC machines.
                //

                if (NtDllBase != NULL) {
                    Base = NtDllBase;
                    NtHeaders = RtlImageNtHeader(Base);
                    if (NtHeaders == NULL) {
                        Base = NULL;
                        goto Done;
                    }

                    Bounds = (ULONG_PTR)Base + NtHeaders->OptionalHeader.SizeOfImage;
                    if (((ULONG_PTR)PcValue >= (ULONG_PTR)Base) && ((ULONG_PTR)PcValue < Bounds))
                        goto Done;
                }
            }
        }

        Base = NULL;
Done:
        ;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Base = NULL;
    }

    LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);

    *BaseOfImage = Base;
    return Base;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\ntrtlp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtlp.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems, but which are private interfaces.

Author:

    David N. Cutler (davec) 15-Aug-1989

Environment:

    These routines are dynamically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _NTRTLP_
#define _NTRTLP_
#include <ntos.h>
#include <nturtl.h>
#include <zwapi.h>
#include <sxstypes.h>

#if defined(_AMD64_)
#include "amd64\ntrtlamd64.h"

#elif defined(_X86_)
#include "i386\ntrtl386.h"

#elif defined(_IA64_)
#include "ia64\ntrtli64.h"

#else
#error "no target architecture"
#endif

#ifdef BLDR_KERNEL_RUNTIME
#undef try
#define try if(1)
#undef except
#define except(a) else if (0)
#undef finally
#define finally if (1)
#undef GetExceptionCode
#define GetExceptionCode() 1
#define finally if (1)
#endif

#include "string.h"
#include "wchar.h"

//
//  Machine state reporting.  See machine specific includes for more.
//

VOID
RtlpGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

#if defined(_WIN64)

PRUNTIME_FUNCTION
RtlpLookupFunctionTable (
    IN PVOID ControlPc,
    OUT PVOID *ImageBase,

#if defined(_IA64_)

    OUT PULONG64 Gp,
#endif

    OUT PULONG SizeOfTable
    );

extern PVOID RtlpFunctionAddressTable[];
extern UNWIND_HISTORY_TABLE RtlpUnwindHistoryTable;

#endif

LONG
LdrpCompareResourceNames(
    IN ULONG ResourceName,
    IN const IMAGE_RESOURCE_DIRECTORY* ResourceDirectory,
    IN const IMAGE_RESOURCE_DIRECTORY_ENTRY* ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN BOOLEAN FindDirectoryEntry,
    OUT PVOID *ResourceDirectoryOrData
    );

LONG
LdrpCompareResourceNames_U(
    IN ULONG_PTR ResourceName,
    IN const IMAGE_RESOURCE_DIRECTORY* ResourceDirectory,
    IN const IMAGE_RESOURCE_DIRECTORY_ENTRY* ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN const ULONG_PTR* ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN ULONG Flags,
    OUT PVOID *ResourceDirectoryOrData
    );

NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

NTSTATUS
LdrpAccessResourceDataNoMultipleLanguage(
    IN PVOID DllHandle,
    IN const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

VOID
RtlpAnsiPszToUnicodePsz(
    IN PCHAR AnsiString,
    IN WCHAR *UnicodeString,
    IN USHORT AnsiStringLength
    );

BOOLEAN
RtlpDidUnicodeToOemWork(
    IN PCOEM_STRING OemString,
    IN PCUNICODE_STRING UnicodeString
    );

extern CONST CCHAR RtlpBitsClearAnywhere[256];
extern CONST CCHAR RtlpBitsClearLow[256];
extern CONST CCHAR RtlpBitsClearHigh[256];
extern CONST CCHAR RtlpBitsClearTotal[256];

//
//  Macro that tells how many contiguous bits are set (i.e., 1) in
//  a byte
//

#define RtlpBitSetAnywhere( Byte ) RtlpBitsClearAnywhere[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous LOW order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetLow( Byte ) RtlpBitsClearLow[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous HIGH order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetHigh( Byte ) RtlpBitsClearHigh[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many set bits (i.e., 1) there are in a byte
//

#define RtlpBitsSetTotal( Byte ) RtlpBitsClearTotal[ (~(Byte) & 0xFF) ]



//
// Upcase data table
//

extern PUSHORT Nls844UnicodeUpcaseTable;
extern PUSHORT Nls844UnicodeLowercaseTable;


//
// Macros for Upper Casing a Unicode Code Point.
//

#define LOBYTE(w)           ((UCHAR)((w)))
#define HIBYTE(w)           ((UCHAR)(((USHORT)((w)) >> 8) & 0xFF))
#define GET8(w)             ((ULONG)(((w) >> 8) & 0xff))
#define GETHI4(w)           ((ULONG)(((w) >> 4) & 0xf))
#define GETLO4(w)           ((ULONG)((w) & 0xf))

/***************************************************************************\
* TRAVERSE844W
*
* Traverses the 8:4:4 translation table for the given wide character.  It
* returns the final value of the 8:4:4 table, which is a WORD in length.
*
*   Broken Down Version:
*   --------------------
*       Incr = pTable[GET8(wch)];
*       Incr = pTable[Incr + GETHI4(wch)];
*       Value = pTable[Incr + GETLO4(wch)];
*
* DEFINED AS A MACRO.
*
* 05-31-91    JulieB    Created.
\***************************************************************************/

#define TRAVERSE844W(pTable, wch)                                               \
    ( (pTable)[(pTable)[(pTable)[GET8((wch))] + GETHI4((wch))] + GETLO4((wch))] )

//
// NLS_UPCASE - Based on julieb's macros in nls.h
//
// We will have this upcase macro quickly shortcircuit out if the value
// is within the normal ANSI range (i.e., < 127).  We actually won't bother
// with the 5 values above 'z' because they won't happen very often and
// coding it this way lets us get out after 1 compare for value less than
// 'a' and 2 compares for lowercase a-z.
//

#define NLS_UPCASE(wch) (                                                   \
    ((wch) < 'a' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'z' ?                                                     \
            (wch) - ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeUpcaseTable,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#define NLS_DOWNCASE(wch) (                                                 \
    ((wch) < 'A' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'Z' ?                                                     \
            (wch) + ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeLowercaseTable,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#if DBG && defined(NTOS_KERNEL_RUNTIME)
#define RTL_PAGED_CODE() PAGED_CODE()
#else
#define RTL_PAGED_CODE()
#endif


//
// The follow definition is used to support the Rtl compression engine
// Every compression format that NT supports will need to supply
// these set of routines in order to be called by NtRtl.
//

typedef NTSTATUS (*PRTL_COMPRESS_WORKSPACE_SIZE) (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

typedef NTSTATUS (*PRTL_COMPRESS_BUFFER) (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_BUFFER) (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_FRAGMENT) (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DESCRIBE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

typedef NTSTATUS (*PRTL_RESERVE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

//
// Here is the declarations of the LZNT1 routines
//

NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );


NTSTATUS
RtlpSecMemFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
     );

//
// Define procedure prototypes for architecture specific debug support routines.
//

NTSTATUS
DebugPrint(
    IN PSTRING Output,
    IN ULONG ComponentId,
    IN ULONG Level
    );

ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    );

#endif  // _NTRTLP_

//
// Procedure prototype for exception logging routines.

ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    );

VOID
RtlpLogLastExceptionDisposition(
    IN ULONG LogIndex,
    IN EXCEPTION_DISPOSITION Disposition
    );

#ifndef NTOS_KERNEL_RUNTIME

BOOLEAN
RtlCallVectoredExceptionHandlers(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    );

#define NO_ALTERNATE_RESOURCE_MODULE    ((PVOID)(LONG_PTR)-1)

typedef struct _ALT_RESOURCE_MODULE {
    //
    // Module handle for module known to application,
    // whose resource accesses we want to redirect.
    //
    PVOID ModuleBase;
    //
    // Module handle for module we loaded under the covers,
    // to which resource access will be redirected; will be
    // NO_ALTERNATE_RESOURCE_MODULE if we tried and failed to load
    // the alternate resource module for the module represented by
    // ModuleBase.
    //
    PVOID AlternateModule;
} ALT_RESOURCE_MODULE, *PALT_RESOURCE_MODULE;

BOOLEAN
LdrpVerifyAlternateResourceModule(
    IN PWSTR LangID,
    IN PVOID Module,
    IN PVOID AlternateModule,
    IN LPWSTR BaseDllName
    );

BOOLEAN
LdrpSetAlternateResourceModuleHandle(
    IN PVOID Module,
    IN PVOID AlternateModule
    );
#endif

#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

#if !defined(NTOS_KERNEL_RUNTIME)

#if DBG
PCUNICODE_STRING RtlpGetImagePathName(VOID);
#define RtlpGetCurrentProcessId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess))
#define RtlpGetCurrentThreadId() (HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread))
#endif

NTSTATUS
RtlpThreadPoolGetActiveActivationContext(
    PACTIVATION_CONTEXT* ActivationContext
    );

#endif // !defined(NTOS_KERNEL_RUNTIME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\nls.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nls.c

Abstract:

    This module implements NLS support functions for NT.

Author:

    Mark Lucovsky (markl) 16-Apr-1991

Environment:

    Kernel or user-mode

Revision History:

    16-Feb-1993    JulieB    Added Upcase Rtl Routines.
    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.
    02-Apr-1993    JulieB    Fixed RtlAnsiCharToUnicodeChar to use transl. tbls.
    02-Apr-1993    JulieB    Fixed BUFFER_TOO_SMALL check.
    28-May-1993    JulieB    Fixed code to properly handle DBCS.

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlAnsiStringToUnicodeString)
#pragma alloc_text(PAGE,RtlAnsiCharToUnicodeChar)
#pragma alloc_text(PAGE,RtlUnicodeStringToAnsiString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToAnsiString)
#pragma alloc_text(PAGE,RtlOemStringToUnicodeString)
#pragma alloc_text(PAGE,RtlUnicodeStringToOemString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToOemString)
#pragma alloc_text(PAGE,RtlOemStringToCountedUnicodeString)
#pragma alloc_text(PAGE,RtlUnicodeStringToCountedOemString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToCountedOemString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeString)
#pragma alloc_text(PAGE,RtlDowncaseUnicodeString)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeChar)
#pragma alloc_text(PAGE,RtlDowncaseUnicodeChar)
#pragma alloc_text(PAGE,RtlFreeUnicodeString)
#pragma alloc_text(PAGE,RtlFreeAnsiString)
#pragma alloc_text(PAGE,RtlFreeOemString)
#pragma alloc_text(PAGE,RtlxUnicodeStringToAnsiSize)
#pragma alloc_text(PAGE,RtlxUnicodeStringToOemSize)
#pragma alloc_text(PAGE,RtlxAnsiStringToUnicodeSize)
#pragma alloc_text(PAGE,RtlxOemStringToUnicodeSize)
#pragma alloc_text(PAGE,RtlCompareUnicodeString)
#pragma alloc_text(PAGE,RtlEqualUnicodeString)
#pragma alloc_text(PAGE,RtlPrefixUnicodeString)
#pragma alloc_text(PAGE,RtlCreateUnicodeString)
#pragma alloc_text(PAGE,RtlEqualDomainName)
#pragma alloc_text(PAGE,RtlEqualComputerName)
#pragma alloc_text(PAGE,RtlIsTextUnicode)
#pragma alloc_text(PAGE,RtlDnsHostNameToComputerName)
#pragma alloc_text(PAGE,RtlHashUnicodeString)
#pragma alloc_text(PAGE,RtlDuplicateUnicodeString)
#pragma alloc_text(PAGE,RtlFindCharInUnicodeString)
#endif




//
// Global data used for translations.
//

extern const PUSHORT  NlsAnsiToUnicodeData;    // Ansi CP to Unicode translation table
extern const PUSHORT  NlsLeadByteInfo;         // Lead byte info for ACP

//
// Pulled from lmcons.h:
//

#ifndef NETBIOS_NAME_LEN
#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)
#endif // NETBIOS_NAME_LEN



NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlAnsiStringToUnicodeSize(SourceString);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlMultiByteToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;

}


WCHAR
RtlAnsiCharToUnicodeChar(
    IN OUT PUCHAR *SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified ansi character to unicode and
    returns the unicode value.  The purpose for this routine is to allow
    for character by character ansi to unicode translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies a pointer to an ansi character pointer.
        Through two levels of indirection, this supplies an ansi
        character that is to be translated to unicode.  After
        translation, the ansi character pointer is modified to point to
        the next character to be converted.  This is done to allow for
        dbcs ansi characters.

Return Value:

    Returns the unicode equivalent of the specified ansi character.

--*/

{
    WCHAR UnicodeCharacter;
    ULONG cbCharSize;
    NTSTATUS st;


    RTL_PAGED_CODE();


    //
    // Translate the ansi character to unicode - this handles DBCS.
    //
    UnicodeCharacter = 0x0020;
    cbCharSize = NlsLeadByteInfo[ **SourceCharacter ] ? 2 : 1;
    st = RtlMultiByteToUnicodeN ( &UnicodeCharacter,
                                  sizeof ( WCHAR ),
                                  NULL,
                                  *SourceCharacter,
                                  cbCharSize );

    //
    // Check for error - The only time this will happen is if there is
    // a leadbyte without a trail byte.
    //
    if ( ! NT_SUCCESS( st ) )
    {
        // Use space as default.
        UnicodeCharacter = 0x0020;
    }

    //
    // Advance the source pointer and return the Unicode character.
    //
    (*SourceCharacter) += cbCharSize;
    return UnicodeCharacter;
}


NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    AnsiLength = RtlUnicodeStringToAnsiSize(SourceString);
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    st = RtlUnicodeToMultiByteN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}


NTSTATUS
RtlUpcaseUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions upper cases the specified unicode source string and then
    converts it into an ansi string. The translation is done with respect
    to the current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set
        if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to upper case ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    AnsiLength = RtlUnicodeStringToAnsiSize(SourceString);
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUpcaseUnicodeToMultiByteN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


NTSTATUS
RtlOemStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCOEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    installed OEM code page (OCP).

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the oem source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the oem source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlOemStringToUnicodeSize(SourceString);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlOemToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;

}


NTSTATUS
RtlUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM code
    page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    OemLength = RtlUnicodeStringToOemSize(SourceString);
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function upper cases the specified unicode source string and then
    converts it into an oem string. The translation is done with respect
    to the OEM code page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    OemLength = RtlUnicodeStringToOemSize(SourceString);
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUpcaseUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    //
    //  Now do a check here to see if there was really a mapping for all
    //  characters converted.
    //

    if (NT_SUCCESS(st) &&
        !RtlpDidUnicodeToOemWork( DestinationString, SourceString )) {

        st = STATUS_UNMAPPABLE_CHARACTER;
    }

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return STATUS_SUCCESS;
}


NTSTATUS
RtlOemStringToCountedUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCOEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    installed OEM code page (OCP).

    The destination string is NOT unnaturally null terminated.  It is a
    counted string as counted strings are meant to be.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the oem source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the oem source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlOemStringToCountedUnicodeSize(SourceString);

    if ( UnicodeLength == 0 ) {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;

        return STATUS_SUCCESS;
    }

    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlOemToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlUnicodeStringToCountedOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM code
    page (OCP).

    The destination string is NOT unnaturally null terminated.  It is a
    counted string as counted strings are meant to be.

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    OemLength = RtlUnicodeStringToCountedOemSize(SourceString);

    if ( OemLength == 0 ) {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;

        return STATUS_SUCCESS;
    }

    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    //
    //  Now do a check here to see if there was really a mapping for all
    //  characters converted.
    //

    if (NT_SUCCESS(st) &&
        !RtlpDidUnicodeToOemWork( DestinationString, SourceString )) {

        st = STATUS_UNMAPPABLE_CHARACTER;
    }

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeStringToCountedOemString(
    OUT POEM_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    then converts it into an oem string. The translation is done with
    respect to the OEM code page (OCP).

    The destination string is NOT unnaturally null terminated.  It is a
    counted string as counted strings are meant to be.

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set
        if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    OemLength = RtlUnicodeStringToCountedOemSize(SourceString);

    if ( OemLength == 0 ) {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;

        return STATUS_SUCCESS;
    }

    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (RtlAllocateStringRoutine)(OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlUpcaseUnicodeToOemN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    //
    //  Now do a check here to see if there was really a mapping for all
    //  characters converted.
    //

    if (NT_SUCCESS(st) &&
        !RtlpDidUnicodeToOemWork( DestinationString, SourceString )) {

        st = STATUS_UNMAPPABLE_CHARACTER;
    }

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            (RtlFreeStringRoutine)(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (RtlAllocateStringRoutine)((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (RtlAllocateStringRoutine)((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode chararacter.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_UPCASE(SourceCharacter);
}


WCHAR
RtlDowncaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent downcased unicode chararacter.  The purpose for this routine
    is to allow for character by character downcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be downcased.

Return Value:

    Returns the downcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_DOWNCASE(SourceCharacter);
}


VOID
RtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (UnicodeString->Buffer) {
        (RtlFreeStringRoutine)(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


VOID
RtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (AnsiString->Buffer) {
        (RtlFreeStringRoutine)(AnsiString->Buffer);
        memset( AnsiString, 0, sizeof( *AnsiString ) );
        }
}


VOID
RtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (OemString->Buffer) {(RtlFreeStringRoutine)(OemString->Buffer);}
}


ULONG
RtlxUnicodeStringToAnsiSize(
    IN PCUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store
    a NULL terminated ansi string that is equivalent to the specified
    unicode string. If an ansi string can not be formed, the return value
    is 0.

Arguments:

    UnicodeString - Supplies a unicode string whose equivalent size as
        an ansi string is to be calculated.

Return Value:

    0 - The operation failed, the unicode string can not be translated
        into ansi using the current system locale therefore no storage
        is needed for the ansi string.

    !0 - The operation was successful.  The return value specifies the
        number of bytes required to hold an NULL terminated ansi string
        equivalent to the specified unicode string.

--*/

{
    ULONG  cbMultiByteString;

    RTL_PAGED_CODE();

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlUnicodeToMultiByteSize( &cbMultiByteString,
                               UnicodeString->Buffer,
                               UnicodeString->Length );

    //
    // Return the size in bytes.
    //
    return (cbMultiByteString + 1);
}


ULONG
RtlxUnicodeStringToOemSize(
    IN PCUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store
    a NULL terminated oem string that is equivalent to the specified
    unicode string. If an oem string can not be formed, the return value
    is 0.

Arguments:

    UnicodeString - Supplies a unicode string whose equivalent size as
        an oem string is to be calculated.

Return Value:

    0 - The operation failed, the unicode string can not be translated
        into oem using the OEM code page therefore no storage is
        needed for the oem string.

    !0 - The operation was successful.  The return value specifies the
        number of bytes required to hold an NULL terminated oem string
        equivalent to the specified unicode string.

--*/

{
    ULONG  cbMultiByteString;

    RTL_PAGED_CODE();

    //
    // LATER:  Define an RtlUnicodeToOemSize.
    //         In the Japanese version, it's safe to call
    //         RtlUnicodeToMultiByteSize because the Ansi code page
    //         and the OEM code page are the same.
    //

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlUnicodeToMultiByteSize( &cbMultiByteString,
                               UnicodeString->Buffer,
                               UnicodeString->Length );

    //
    // Return the size in bytes.
    //
    return (cbMultiByteString + 1);
}


ULONG
RtlxAnsiStringToUnicodeSize(
    IN PCANSI_STRING AnsiString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store a NULL
    terminated unicode string that is equivalent to the specified ansi
    string.

Arguments:

    AnsiString - Supplies an ansi string whose equivalent size as a
        unicode string is to be calculated.  The ansi string is
        interpreted relative to the current system locale.

Return Value:

    The return value specifies the number of bytes required to hold a
    NULL terminated unicode string equivalent to the specified ansi
    string.

--*/

{
    ULONG cbConverted;

    RTL_PAGED_CODE();

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlMultiByteToUnicodeSize( &cbConverted ,
                               AnsiString->Buffer,
                               AnsiString->Length );

    //
    // Return the size in bytes.
    //
    return ( cbConverted + sizeof(UNICODE_NULL) );
}


ULONG
RtlxOemStringToUnicodeSize(
    IN PCOEM_STRING OemString
    )

/*++

Routine Description:

    This function computes the number of bytes required to store a NULL
    terminated unicode string that is equivalent to the specified oem
    string.

Arguments:

    OemString - Supplies an oem string whose equivalent size as a
        unicode string is to be calculated.  The oem string is
        interpreted relative to the current oem code page (OCP).

Return Value:

    The return value specifies the number of bytes required to hold a
    NULL terminated unicode string equivalent to the specified oem
    string.

--*/

{
    ULONG cbConverted;

    RTL_PAGED_CODE();

    //
    // LATER:  Define an RtlOemToUnicodeSize.
    //         In the Japanese version, it's safe to call
    //         RtlMultiByteToUnicodeSize because the Ansi code page
    //         and the OEM code page are the same.
    //

    //
    // Get the size of the string - this call handles DBCS.
    //
    RtlMultiByteToUnicodeSize( &cbConverted,
                               OemString->Buffer,
                               OemString->Length );

    //
    // Return the size in bytes.
    //
    return ( cbConverted + sizeof(UNICODE_NULL) );
}


LONG
RtlCompareUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PCWSTR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    RTL_PAGED_CODE();

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    ASSERT((n1 & 1) == 0);
    ASSERT((n2 & 1) == 0);
    ASSERT(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {

                //
                // Note that this needs to reference the translation table!
                //

                c1 = NLS_UPCASE(c1);
                c2 = NLS_UPCASE(c2);
                if (c1 != c2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


BOOLEAN
RtlEqualUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    RTL_PAGED_CODE();

    n1 = String1->Length;
    n2 = String2->Length;

    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;

        Limit = (PWCHAR)((PCHAR)s1 + (n1&~(sizeof(WCHAR) - 1)));
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                    return FALSE;
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}


BOOLEAN
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixUnicodeString function determines if the String1
    counted string parameter is a prefix of the String2 counted string
    parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first unicode string.

    String2 - Pointer to the second unicode string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PWSTR s1, s2;
    ULONG n;
    WCHAR c1, c2;

    RTL_PAGED_CODE();

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return( FALSE );
        }

    n = n / sizeof(c1);
    if (CaseInSensitive) {
        while (n) {
            c1 = *s1++;
            c2 = *s2++;

            if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                return( FALSE );
                }

            n--;
            }
        }
    else {
        while (n) {
            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n--;
            }
        }

    return TRUE;
}


VOID
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (ARGUMENT_PRESENT(SourceString)) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        RtlCopyMemory(dst, src, n);
        if (DestinationString->Length < DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

    } else {
        DestinationString->Length = 0;
    }

    return;
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        RtlInitUnicodeString(&UniSource, Source);

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeStringToString (
    IN OUT PUNICODE_STRING Destination,
    IN PCUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}

BOOLEAN
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    )
{
    ULONG cb;

    RTL_PAGED_CODE();

    cb = (wcslen( SourceString ) + 1) * sizeof( WCHAR );
    DestinationString->Buffer = (RtlAllocateStringRoutine)( cb );
    if (DestinationString->Buffer) {
        RtlCopyMemory( DestinationString->Buffer, SourceString, cb );
        DestinationString->MaximumLength = (USHORT)cb;
        DestinationString->Length = (USHORT)(cb - sizeof( UNICODE_NULL ));
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


BOOLEAN
RtlEqualDomainName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualDomainName function compares two domain names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReturnValue = FALSE;
    OEM_STRING OemString1;
    OEM_STRING OemString2;

    RTL_PAGED_CODE();

    //
    // Upper case and convert the first string to OEM
    //

    Status = RtlUpcaseUnicodeStringToOemString( &OemString1,
                                                String1,
                                                TRUE );   // Allocate Dest

    if ( NT_SUCCESS( Status ) ) {

        //
        // Upper case and convert the second string to OEM
        //

        Status = RtlUpcaseUnicodeStringToOemString( &OemString2,
                                                    String2,
                                                    TRUE );   // Allocate Dest

        if ( NT_SUCCESS( Status ) ) {

            //
            // Do a case insensitive comparison.
            //

            ReturnValue = RtlEqualString( &OemString1,
                                          &OemString2,
                                          FALSE );

            RtlFreeOemString( &OemString2 );
        }

        RtlFreeOemString( &OemString1 );
    }

    return ReturnValue;
}



BOOLEAN
RtlEqualComputerName(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualComputerName function compares two computer names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    return RtlEqualDomainName( String1, String2 );
}

/**


**/

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028

#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))


BOOLEAN
RtlIsTextUnicode(
    IN PVOID Buffer,
    IN ULONG Size,
    IN OUT PULONG Result OPTIONAL
    )

/*++

Routine Description:

    IsTextUnicode performs a series of inexpensive heuristic checks
    on a buffer in order to verify that it contains Unicode data.


    [[ need to fix this section, see at the end ]]

    Found            Return Result

    BOM              TRUE   BOM
    RBOM             FALSE  RBOM
    FFFF             FALSE  Binary
    NULL             FALSE  Binary
    null             TRUE   null bytes
    ASCII_CRLF       FALSE  CRLF
    UNICODE_TAB etc. TRUE   Zero Ext Controls
    UNICODE_TAB_R    FALSE  Reversed Controls
    UNICODE_ZW  etc. TRUE   Unicode specials

    1/3 as little variation in hi-byte as in lo byte: TRUE   Correl
    3/1 or worse   "                                  FALSE  AntiCorrel

Arguments:

    Buffer - pointer to buffer containing text to examine.

    Size - size of buffer in bytes.  At most 256 characters in this will
           be examined.  If the size is less than the size of a unicode
           character, then this function returns FALSE.

    Result - optional pointer to a flag word that contains additional information
             about the reason for the return value.  If specified, this value on
             input is a mask that is used to limit the factors this routine uses
             to make its decision.  On output, this flag word is set to contain
             those flags that were used to make its decision.

Return Value:

    Boolean value that is TRUE if Buffer contains unicode characters.

--*/
{
    UNALIGNED WCHAR *lpBuff = Buffer;
    PUCHAR lpb = Buffer;
    ULONG iBOM = 0;
    ULONG iCR = 0;
    ULONG iLF = 0;
    ULONG iTAB = 0;
    ULONG iSPACE = 0;
    ULONG iCJK_SPACE = 0;
    ULONG iFFFF = 0;
    ULONG iPS = 0;
    ULONG iLS = 0;

    ULONG iRBOM = 0;
    ULONG iR_CR = 0;
    ULONG iR_LF = 0;
    ULONG iR_TAB = 0;
    ULONG iR_SPACE = 0;

    ULONG iNull = 0;
    ULONG iUNULL = 0;
    ULONG iCRLF = 0;
    ULONG iTmp;
    ULONG LastLo = 0;
    ULONG LastHi = 0;
    ULONG iHi, iLo;
    ULONG HiDiff = 0;
    ULONG LoDiff = 0;
    ULONG cLeadByte = 0;
    ULONG cWeird = 0;

    ULONG iResult = 0;

    ULONG iMaxTmp = __min(256, Size / sizeof(WCHAR));

    //
    //  Special case when the size is less than or equal to 2.
    //  Make sure we don't have a character followed by a null byte.
    //
    if ((Size < 2) ||
        ((Size == 2) && (lpBuff[0] != 0) && (lpb[1] == 0)))
    {
        if (ARGUMENT_PRESENT(Result))
        {
            *Result = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
        }

        return (FALSE);
    }
    else if ((Size > 2) && ((Size / sizeof(WCHAR)) <= 256))
    {
        //
        //  If the Size passed in is an even number, we don't want to
        //  use the last WCHAR because it will contain the final null
        //  byte.
        //
        if (((Size % sizeof(WCHAR)) == 0) &&
            ((lpBuff[iMaxTmp - 1] & 0xff00) == 0))
        {
            iMaxTmp--;
        }
    }

    //
    //  Check at most 256 wide characters, collect various statistics.
    //
    for (iTmp = 0; iTmp < iMaxTmp; iTmp++)
    {
        switch (lpBuff[iTmp])
        {
            case BYTE_ORDER_MARK:
                iBOM++;
                break;
            case PARAGRAPH_SEPARATOR:
                iPS++;
                break;
            case LINE_SEPARATOR:
                iLS++;
                break;
            case UNICODE_LF:
                iLF++;
                break;
            case UNICODE_TAB:
                iTAB++;
                break;
            case UNICODE_SPACE:
                iSPACE++;
                break;
            case UNICODE_CJK_SPACE:
                iCJK_SPACE++;
                break;
            case UNICODE_CR:
                iCR++;
                break;

            //
            //  The following codes are expected to show up in
            //  byte reversed files.
            //
            case REVERSE_BYTE_ORDER_MARK:
                iRBOM++;
                break;
            case UNICODE_R_LF:
                iR_LF++;
                break;
            case UNICODE_R_TAB:
                iR_TAB++;
                break;
            case UNICODE_R_CR:
                iR_CR++;
                break;
            case UNICODE_R_SPACE:
                iR_SPACE++;
                break;

            //
            //  The following codes are illegal and should never occur.
            //
            case UNICODE_FFFF:
                iFFFF++;
                break;
            case UNICODE_NULL:
                iUNULL++;
                break;

            //
            //  The following is not currently a Unicode character
            //  but is expected to show up accidentally when reading
            //  in ASCII files which use CRLF on a little endian machine.
            //
            case ASCII_CRLF:
                iCRLF++;
                break;       /* little endian */
        }

        //
        //  Collect statistics on the fluctuations of high bytes
        //  versus low bytes.
        //
        iHi = HIBYTE(lpBuff[iTmp]);
        iLo = LOBYTE(lpBuff[iTmp]);

        //
        //  Count cr/lf and lf/cr that cross two words.
        //
        if ((iLo == '\r' && LastHi == '\n') ||
            (iLo == '\n' && LastHi == '\r'))
        {
            cWeird++;
        }

        iNull += (iHi ? 0 : 1) + (iLo ? 0 : 1);   /* count Null bytes */

        HiDiff += __max(iHi, LastHi) - __min(LastHi, iHi);
        LoDiff += __max(iLo, LastLo) - __min(LastLo, iLo);

        LastLo = iLo;
        LastHi = iHi;
    }

    //
    //  Count cr/lf and lf/cr that cross two words.
    //
    if ((iLo == '\r' && LastHi == '\n') ||
        (iLo == '\n' && LastHi == '\r'))
    {
        cWeird++;
    }

    if (iHi == '\0')     /* don't count the last null */
        iNull--;
    if (iHi == 26)       /* count ^Z at end as weird */
        cWeird++;

    iMaxTmp = __min(256 * sizeof(WCHAR), Size);
    if (NlsMbCodePageTag)
    {
        for (iTmp = 0; iTmp < iMaxTmp; iTmp++)
        {
            if (NlsLeadByteInfo[lpb[iTmp]])
            {
                cLeadByte++;
                iTmp++;         /* should check for trailing-byte range */
            }
        }
    }

    //
    //  Sift through the statistical evidence.
    //
    if (LoDiff < 127 && HiDiff == 0)
    {
        iResult |= IS_TEXT_UNICODE_ASCII16;         /* likely 16-bit ASCII */
    }

    if (HiDiff && LoDiff == 0)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_ASCII16; /* reverse 16-bit ASCII */
    }

    //
    //  Use leadbyte info to weight statistics.
    //
    if (!NlsMbCodePageTag || cLeadByte == 0 ||
        !ARGUMENT_PRESENT(Result) || !(*Result & IS_TEXT_UNICODE_DBCS_LEADBYTE))
    {
        iHi = 3;
    }
    else
    {
        //
        //  A ratio of cLeadByte:cb of 1:2 ==> dbcs
        //  Very crude - should have a nice eq.
        //
        iHi = __min(256, Size / sizeof(WCHAR)) / 2;
        if (cLeadByte < (iHi - 1) / 3)
        {
            iHi = 3;
        }
        else if (cLeadByte < (2 * (iHi - 1)) / 3)
        {
            iHi = 2;
        }
        else
        {
            iHi = 1;
        }
        iResult |= IS_TEXT_UNICODE_DBCS_LEADBYTE;
    }

    if (iHi * HiDiff < LoDiff)
    {
        iResult |= IS_TEXT_UNICODE_STATISTICS;
    }

    if (iHi * LoDiff < HiDiff)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_STATISTICS;
    }

    //
    //  Any control codes widened to 16 bits? Any Unicode character
    //  which contain one byte in the control code range?
    //
    if (iCR + iLF + iTAB + iSPACE + iCJK_SPACE /*+iPS+iLS*/)
    {
        iResult |= IS_TEXT_UNICODE_CONTROLS;
    }

    if (iR_LF + iR_CR + iR_TAB + iR_SPACE)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_CONTROLS;
    }

    //
    //  Any characters that are illegal for Unicode?
    //
    if ((iRBOM + iFFFF + iUNULL + iCRLF) != 0 ||
         (cWeird != 0 && cWeird >= iMaxTmp/40))
    {
        iResult |= IS_TEXT_UNICODE_ILLEGAL_CHARS;
    }

    //
    //  Odd buffer length cannot be Unicode.
    //
    if (Size & 1)
    {
        iResult |= IS_TEXT_UNICODE_ODD_LENGTH;
    }

    //
    //  Any NULL bytes? (Illegal in ANSI)
    //
    if (iNull)
    {
        iResult |= IS_TEXT_UNICODE_NULL_BYTES;
    }

    //
    //  POSITIVE evidence, BOM or RBOM used as signature.
    //
    if (*lpBuff == BYTE_ORDER_MARK)
    {
        iResult |= IS_TEXT_UNICODE_SIGNATURE;
    }
    else if (*lpBuff == REVERSE_BYTE_ORDER_MARK)
    {
        iResult |= IS_TEXT_UNICODE_REVERSE_SIGNATURE;
    }

    //
    //  Limit to desired categories if requested.
    //
    if (ARGUMENT_PRESENT(Result))
    {
        iResult &= *Result;
        *Result = iResult;
    }

    //
    //  There are four separate conclusions:
    //
    //  1: The file APPEARS to be Unicode     AU
    //  2: The file CANNOT be Unicode         CU
    //  3: The file CANNOT be ANSI            CA
    //
    //
    //  This gives the following possible results
    //
    //      CU
    //      +        -
    //
    //      AU       AU
    //      +   -    +   -
    //      --------  --------
    //      CA +| 0   0    2   3
    //      |
    //      -| 1   1    4   5
    //
    //
    //  Note that there are only 6 really different cases, not 8.
    //
    //  0 - This must be a binary file
    //  1 - ANSI file
    //  2 - Unicode file (High probability)
    //  3 - Unicode file (more than 50% chance)
    //  5 - No evidence for Unicode (ANSI is default)
    //
    //  The whole thing is more complicated if we allow the assumption
    //  of reverse polarity input. At this point we have a simplistic
    //  model: some of the reverse Unicode evidence is very strong,
    //  we ignore most weak evidence except statistics. If this kind of
    //  strong evidence is found together with Unicode evidence, it means
    //  its likely NOT Text at all. Furthermore if a REVERSE_BYTE_ORDER_MARK
    //  is found, it precludes normal Unicode. If both byte order marks are
    //  found it's not Unicode.
    //

    //
    //  Unicode signature : uncontested signature outweighs reverse evidence.
    //
    if ((iResult & IS_TEXT_UNICODE_SIGNATURE) &&
        !(iResult & (IS_TEXT_UNICODE_NOT_UNICODE_MASK&(~IS_TEXT_UNICODE_DBCS_LEADBYTE))))
    {
        return (TRUE);
    }

    //
    //  If we have conflicting evidence, it's not Unicode.
    //
    if (iResult & IS_TEXT_UNICODE_REVERSE_MASK)
    {
        return (FALSE);
    }

    //
    //  Statistical and other results (cases 2 and 3).
    //
    if (!(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK) &&
         ((iResult & IS_TEXT_UNICODE_NOT_ASCII_MASK) ||
          (iResult & IS_TEXT_UNICODE_UNICODE_MASK)))
    {
        return (TRUE);
    }

    return (FALSE);
}


NTSTATUS
RtlDnsHostNameToComputerName(
    OUT PUNICODE_STRING ComputerNameString,
    IN PCUNICODE_STRING DnsHostNameString,
    IN BOOLEAN AllocateComputerNameString
    )

/*++

Routine Description:

    The RtlDnsHostNameToComputerName API converts a DNS-style host name to a
    Netbios-style computer name.

    This API does a syntactical mapping of the name.  As such, it should not
    be used to convert a DNS domain name to a Netbios domain name.
    There is no syntactical mapping for domain names.

    DNS-style names consist of one or more "labels" separated by a period
    (e.g., xxx.nt.microsoft.com).  Each label can be up to 63 bytes of
    UTF-8 characters and must consist only of characters specified
    by the DnsValidateDnsName API.  Upper and lower case characters are treated
    as the same character.  DNS names are represented in the UTF-8 character set
    or UNICODE.

    Netbios computer names consist of up to 15 bytes of OEM characters
    including letters, digits, hyphens, periods and various other characters.
    Some of these characters are specific to the character set. Netbios names
    are typically represented in the OEM character set.  The OEM character
    set is different depending on the locale of the particular version of the OS
    (e.g., the German version has a different character set than the US version).
    Some OEM character sets represent certain characters as 2 bytes
    (e.g., Japanese).  Netbios names, by convention, are represented in
    uppercase where the translation algorithm from lowercase to uppercase
    is OEM character set dependent.

    These characteristics make translating between DNS name and Netbios name
    difficult.

    RtlDnsHostNameToComputerName enforces a textual convention for
    mapping between the two names.  This convention limits the names of
    computers to be the common subset of the names.  Specifically, the leftmost
    label of the DNS name is truncated to 15-bytes of OEM characters.
    As such, RtlDnsHostNameToComputerName simply interprets the leftmost label
    of the DNS name as the Netbios name.  If the DNS name doesn't meet the
    criteria of a valid translatable name, a distinct error code is returned.

Arguments:

    ComputerNameString - Returns a unicode string that is equivalent to
        the DNS source string. The maximum length field is only
        set if AllocateComputerNameString is TRUE.

    DnsHostNameString - Supplies the DNS host name source string that is to be
        converted to a netbios computer name.

        This routine does NOT attempt to validate that the passed in DnsHostNameString
        is a valid DNS host a DNS host name.  Rather it assumes that the passed in
        name is valid and converts it on a best effort basis.

    AllocateComputerNameString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_NO_MEMORY - There is not enough memory to allocate the return buffer.

    STATUS_INVALID_COMPUTER_NAME - The DnsHostName has no first label or
        one or more characters of the DnsHostName could not be converted to
        the OEM character set.

--*/

{
    NTSTATUS Status;


    UNICODE_STRING LocalDnsHostNameString;

    OEM_STRING OemString;
    ULONG ActualOemLength;
    CHAR OemStringBuffer[16];

    ULONG i;

    RTL_PAGED_CODE();

    //
    // Truncate the dns name to the first label
    //

    LocalDnsHostNameString = *DnsHostNameString;

    for ( i=0; i<LocalDnsHostNameString.Length/sizeof(WCHAR); i++ ) {

        if ( LocalDnsHostNameString.Buffer[i] == L'.' ) {
            LocalDnsHostNameString.Length = (USHORT)(i * sizeof(WCHAR));
            break;
        }
    }

    if ( LocalDnsHostNameString.Length < sizeof(WCHAR) ) {
        return STATUS_INVALID_COMPUTER_NAME;
    }

    //
    // Convert the DNS name to OEM truncating at 15 OEM bytes.
    //

    Status = RtlUpcaseUnicodeToOemN(
                OemStringBuffer,
                NETBIOS_NAME_LEN-1,         // truncate to 15 bytes
                &ActualOemLength,
                LocalDnsHostNameString.Buffer,
                LocalDnsHostNameString.Length );

    if ( !NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW ) {
        return Status;
    }


    //
    // Check to see if any characters are not valid OEM characters.
    //

    OemString.Buffer = OemStringBuffer;
    OemString.MaximumLength = OemString.Length = (USHORT) ActualOemLength;

    if ( !RtlpDidUnicodeToOemWork( &OemString, &LocalDnsHostNameString )) {
        return STATUS_INVALID_COMPUTER_NAME;
    }


    //
    // Convert the OEM string back to UNICODE
    //

    Status = RtlOemStringToUnicodeString(
                ComputerNameString,
                &OemString,
                AllocateComputerNameString );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlHashUnicodeString(
    const UNICODE_STRING *String,
    BOOLEAN CaseInSensitive,
    ULONG HashAlgorithm,
    PULONG HashValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TmpHashValue = 0;
    ULONG Chars;
    PCWSTR Buffer;

    if ((String == NULL) ||
        (HashValue == NULL))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Buffer = String->Buffer;

    *HashValue = 0;
    Chars = String->Length / sizeof(WCHAR);

    switch (HashAlgorithm)
    {
    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
        break;

    case HASH_STRING_ALGORITHM_DEFAULT:
    case HASH_STRING_ALGORITHM_X65599:
        if (CaseInSensitive)
        {
            while (Chars-- != 0)
            {
                WCHAR Char = *Buffer++;
                TmpHashValue = (TmpHashValue * 65599) + NLS_UPCASE(Char);
            }
        }
        else
        {
            while (Chars-- != 0)
                TmpHashValue = (TmpHashValue * 65599) + *Buffer++;
        }

        break;
    }

    *HashValue = TmpHashValue;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Flags == 0);

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String != NULL) {
        if (((String->Length % 2) != 0) ||
            ((String->MaximumLength % 2) != 0) ||
            (String->Length > String->MaximumLength)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (((String->Length != 0) ||
             (String->MaximumLength != 0)) &&
            (String->Buffer == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlDuplicateUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringIn,
    PUNICODE_STRING StringOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Length = 0;
    USHORT NewMaximumLength = 0;
    PWSTR Buffer = NULL;

    if (((Flags & ~(
            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
            RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING)) != 0) ||
        (StringOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // It doesn't make sense to force allocation of a null string unless you
    // want null termination.
    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) &&
        !(Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlValidateUnicodeString(0, StringIn);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (StringIn != NULL)
        Length = StringIn->Length;

    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) &&
        (Length == UNICODE_STRING_MAX_BYTES)) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)
        NewMaximumLength = (USHORT) (Length + sizeof(WCHAR));
    else
        NewMaximumLength = Length;

    // If it's a zero length string in, force the allocation length to zero
    // unless the caller said that they want zero length strings allocated.
    if (((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) == 0) &&
        (Length == 0)) {
        NewMaximumLength = 0;
    }

    if (NewMaximumLength != 0) {
        Buffer = (RtlAllocateStringRoutine)(NewMaximumLength);
        if (Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        // If there's anything to copy, copy it.  We explicitly test Length because
        // StringIn could be a NULL pointer, so dereferencing it to get the Buffer
        // pointer would access violate.
        if (Length != 0) {
            RtlCopyMemory(
                Buffer,
                StringIn->Buffer,
                Length);
        }

        if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) {
            Buffer[Length / sizeof(WCHAR)] = L'\0';
        }
    }

    StringOut->Buffer = Buffer;
    StringOut->MaximumLength = NewMaximumLength;
    StringOut->Length = Length;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

NTSTATUS
RtlFindCharInUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringToSearch,
    PCUNICODE_STRING CharSet,
    USHORT *NonInclusivePrefixLength
    )
{
    NTSTATUS Status;
    USHORT PrefixLengthFound = 0;
    USHORT CharsToSearch = 0;
    int MovementDirection = 0;
    PCWSTR Cursor = NULL;
    BOOLEAN Found = FALSE;
    USHORT CharSetChars = 0;
    PCWSTR CharSetBuffer = NULL;
    USHORT i;

    if (NonInclusivePrefixLength != 0)
        *NonInclusivePrefixLength = 0;

    if (((Flags & ~(RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END |
                    RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET |
                    RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE)) != 0) ||
        (NonInclusivePrefixLength == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = RtlValidateUnicodeString(0, StringToSearch);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = RtlValidateUnicodeString(0, CharSet);
    if (!NT_SUCCESS(Status))
        goto Exit;

    CharsToSearch = StringToSearch->Length / sizeof(WCHAR);
    CharSetChars = CharSet->Length / sizeof(WCHAR);
    CharSetBuffer = CharSet->Buffer;

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END) {
        MovementDirection = -1;
        Cursor = StringToSearch->Buffer + CharsToSearch - 1;
    } else {
        MovementDirection = 1;
        Cursor = StringToSearch->Buffer;
    }

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_CASE_INSENSITIVE) {
        // Unicode standard says to always do case insensitive comparisons in lower case since the case mappings are
        // asymmetric.
        WCHAR CharSetStackBuffer[32]; // optimized pre-downcased for case insensitive

        // Optimization for the case of a relatively small char set to match
        if (CharSetChars <= RTL_NUMBER_OF(CharSetStackBuffer)) {

            for (i=0; i<CharSetChars; i++)
                CharSetStackBuffer[i] = RtlDowncaseUnicodeChar(CharSetBuffer[i]);

            while (CharsToSearch != 0) {
                const WCHAR wch = RtlDowncaseUnicodeChar(*Cursor);

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetStackBuffer[i])
                            break;
                    }

                    if (i == CharSetChars)
                        break;
                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetStackBuffer[i])
                            break;
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        } else {
            while (CharsToSearch != 0) {
                const WCHAR wch = RtlDowncaseUnicodeChar(*Cursor);

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == RtlDowncaseUnicodeChar(CharSetBuffer[i])) {
                            break;
                        }
                    }

                    if (i == CharSetChars)
                        break;
                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == RtlDowncaseUnicodeChar(CharSetBuffer[i])) {
                            break;
                        }
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        }
    } else {
        if (CharSetChars == 1) {
            // Significant optimization for looking for one character.
            const WCHAR wchSearchChar = CharSetBuffer[0];

            if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                while (CharsToSearch != 0) {
                    if (*Cursor != wchSearchChar)
                        break;
                    CharsToSearch--;
                    Cursor += MovementDirection;
                }
            } else {
                while (CharsToSearch != 0) {
                    if (*Cursor == wchSearchChar)
                        break;
                    CharsToSearch--;
                    Cursor += MovementDirection;
                }
            }
        } else {
            while (CharsToSearch != 0) {
                const WCHAR wch = *Cursor;

                if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_COMPLEMENT_CHAR_SET) {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetBuffer[i])
                            break;
                    }

                    if (i == CharSetChars)
                        break;

                } else {
                    for (i=0; i<CharSetChars; i++) {
                        if (wch == CharSetBuffer[i])
                            break;
                    }

                    if (i != CharSetChars)
                        break;
                }

                CharsToSearch--;
                Cursor += MovementDirection;
            }
        }
    }

    if (CharsToSearch == 0) {
        Status = STATUS_NOT_FOUND;
        goto Exit;
    }

    CharsToSearch--;

    if (Flags & RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END)
        PrefixLengthFound = (USHORT) (CharsToSearch * sizeof(WCHAR));
    else
        PrefixLengthFound = (USHORT) (StringToSearch->Length - (CharsToSearch * sizeof(WCHAR)));

    *NonInclusivePrefixLength = PrefixLengthFound;

    Status = STATUS_SUCCESS;

Exit:
    return Status;
}

NTSTATUS
NTAPI
RtlFindAndReplaceCharacterInString(
    ULONG           Flags,
    PVOID           Reserved,
    PUNICODE_STRING String,
    WCHAR           Find,
    WCHAR           Replace
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;
    ULONG Length = 0;
    typedef WCHAR TChar;

    if (Flags & ~RTL_FIND_AND_REPLACE_CHARACTER_IN_STRING_CASE_SENSITIVE) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Reserved != NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String == NULL
        || Find == Replace
        ) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Length = RTL_STRING_GET_LENGTH_CHARS(String);
    if (Length == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if ((Flags & RTL_FIND_AND_REPLACE_CHARACTER_IN_STRING_CASE_SENSITIVE) != 0) {
        for (Index = 0 ; Index != Length ; ++Index) {
            if (   String->Buffer[Index] == Find
                ) {
                String->Buffer[Index] = Replace;
            }
        }
    }
    else {
        TChar DownFind = RtlDowncaseUnicodeChar(Find);
        TChar UpFind   = RtlUpcaseUnicodeChar(Find);
        for (Index = 0 ; Index != Length ; ++Index) {
            const TChar Char = String->Buffer[Index];
            if (   Char == Find
                || Char == UpFind
                || Char == DownFind
                ) {
                String->Buffer[Index] = Replace;
            }
            else {
                TChar DownChar = RtlDowncaseUnicodeChar(Char);
                if (   DownChar == Find
                    //|| DownChar == UpFind // presumably not possible
                    || DownChar == DownFind
                    ) {
                    String->Buffer[Index] = Replace;
                }
                else if (DownChar != Char) {
                    TChar UpChar = RtlUpcaseUnicodeChar(Char);
                    if (   UpChar == Find
                        || UpChar == UpFind
                        //||UpChar == DownFind // presumably not possible
                        ) {
                        String->Buffer[Index] = Replace;
                    }
                }
            }
        }
    }
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\nlsxlat.c ===
/****************************** Module Header ******************************\
* Module Name: nlsxlat.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the private routines for character translation:
* 8-bit <=> Unicode.
*
* History:
* 03-Jan-1992    gregoryw
* 16-Feb-1993    JulieB      Added Upcase Routines & Macros.
* 17-Feb-1993    JulieB      Fixed Tables; Fixed DBCS Code.
* 08-Mar-1993    JulieB      Moved Upcase Macro to ntrtlp.h.
\***************************************************************************/

#include "ntrtlp.h"


NTSTATUS
RtlConsoleMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString,
    OUT PULONG pdwSpecialChar );

VOID
RtlpInitUpcaseTable(
    IN PUSHORT TableBase,
    OUT PNLSTABLEINFO CodePageTable
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlConsoleMultiByteToUnicodeN)
#pragma alloc_text(PAGE,RtlMultiByteToUnicodeN)
#pragma alloc_text(PAGE,RtlOemToUnicodeN)
#pragma alloc_text(PAGE,RtlUnicodeToMultiByteN)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeToMultiByteN)
#pragma alloc_text(PAGE,RtlUnicodeToOemN)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeToOemN)
#pragma alloc_text(PAGE,RtlpDidUnicodeToOemWork)
#pragma alloc_text(PAGE,RtlCustomCPToUnicodeN)
#pragma alloc_text(PAGE,RtlUnicodeToCustomCPN)
#pragma alloc_text(PAGE,RtlUpcaseUnicodeToCustomCPN)
#pragma alloc_text(PAGE,RtlInitCodePageTable)
#pragma alloc_text(PAGE,RtlpInitUpcaseTable)
#pragma alloc_text(PAGE,RtlInitNlsTables)
#pragma alloc_text(PAGE,RtlResetRtlTranslations)
#pragma alloc_text(PAGE,RtlMultiByteToUnicodeSize)
#pragma alloc_text(PAGE,RtlUnicodeToMultiByteSize)
#pragma alloc_text(PAGE,RtlGetDefaultCodePage)
#endif



//
// Various defines and convenient macros for data access
//

#define DBCS_TABLE_SIZE 256


/*
 * Global data used by the translation routines.
 *
 */

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

//
// Upcase and Lowercase data
//
PUSHORT Nls844UnicodeUpcaseTable = NULL;
PUSHORT Nls844UnicodeLowercaseTable = NULL;

//
// ACP related data
//
USHORT   NlsLeadByteInfoTable[DBCS_TABLE_SIZE] = {0}; // Lead byte info. for ACP
USHORT   NlsAnsiCodePage = 0;               // Default ANSI code page
USHORT   NlsOemCodePage = 0;                // Default OEM code page
const PUSHORT  NlsLeadByteInfo = NlsLeadByteInfoTable;
PUSHORT  NlsMbAnsiCodePageTables = NULL;   // Multibyte to Unicode translation tables
PUSHORT  NlsAnsiToUnicodeData = NULL;      // Ansi CP to Unicode translation table
PCH      NlsUnicodeToAnsiData = NULL;      // Unicode to Ansi CP translation table
PUSHORT  NlsUnicodeToMbAnsiData = NULL;    // Unicode to Multibyte Ansi CP translation table
BOOLEAN  NlsMbCodePageTag = FALSE;         // TRUE -> Multibyte ACP, FALSE -> Singlebyte ACP

//
// OEM related data
//
USHORT   NlsOemLeadByteInfoTable[DBCS_TABLE_SIZE] = {0}; // Lead byte info. for 0CP
const PUSHORT  NlsOemLeadByteInfo = NlsOemLeadByteInfoTable;
PUSHORT  NlsMbOemCodePageTables = NULL;       // OEM Multibyte to Unicode translation tables
PUSHORT  NlsOemToUnicodeData = NULL;          // Oem CP to Unicode translation table
PCH      NlsUnicodeToOemData = NULL;          // Unicode to Oem CP translation table
PUSHORT  NlsUnicodeToMbOemData = NULL;        // Unicode to Multibyte Oem CP translation table
BOOLEAN  NlsMbOemCodePageTag = FALSE;         // TRUE -> Multibyte OCP, FALSE -> Singlebyte OCP

//
// Default info taken from data files
//
USHORT   UnicodeDefaultChar = 0;

USHORT   OemDefaultChar = 0;
USHORT   OemTransUniDefaultChar = 0;

//
// Default info NOT taken from data files
//
#define UnicodeNull 0x0000



NTSTATUS
RtlConsoleMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString,
    OUT PULONG pdwSpecialChar )

/*++

Routine Description:

    This function is a superset of MultiByteToUnicode for the
    console.  It works just like the other, except it will detect
    if any characters were under 0x20.

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

    pdwSpecialChar - will be zero if non detected, else it will contain the
       approximate index (can be off by 32).

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    *pdwSpecialChar = 0;

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    if (!NlsMbCodePageTag) {

        LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                     MaxCharsInUnicodeString : BytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

        TranslateTable = NlsAnsiToUnicodeData;  // used to help the mips compiler

        quick_copy:
            switch( LoopCount ) {
            default:
                if ((UCHAR)MultiByteString[0x1F] < 0x20)    goto  bad_case;
                UnicodeString[0x1F] = TranslateTable[(UCHAR)MultiByteString[0x1F]];
            case 0x1F:
                if ((UCHAR)MultiByteString[0x1E] < 0x20)    goto  bad_case;
                UnicodeString[0x1E] = TranslateTable[(UCHAR)MultiByteString[0x1E]];
            case 0x1E:
                if ((UCHAR)MultiByteString[0x1D] < 0x20)    goto  bad_case;
                UnicodeString[0x1D] = TranslateTable[(UCHAR)MultiByteString[0x1D]];
            case 0x1D:
                if ((UCHAR)MultiByteString[0x1C] < 0x20)    goto  bad_case;
                UnicodeString[0x1C] = TranslateTable[(UCHAR)MultiByteString[0x1C]];
            case 0x1C:
                if ((UCHAR)MultiByteString[0x1B] < 0x20)    goto  bad_case;
                UnicodeString[0x1B] = TranslateTable[(UCHAR)MultiByteString[0x1B]];
            case 0x1B:
                if ((UCHAR)MultiByteString[0x1A] < 0x20)    goto  bad_case;
                UnicodeString[0x1A] = TranslateTable[(UCHAR)MultiByteString[0x1A]];
            case 0x1A:
                if ((UCHAR)MultiByteString[0x19] < 0x20)    goto  bad_case;
                UnicodeString[0x19] = TranslateTable[(UCHAR)MultiByteString[0x19]];
            case 0x19:
                if ((UCHAR)MultiByteString[0x18] < 0x20)    goto  bad_case;
                UnicodeString[0x18] = TranslateTable[(UCHAR)MultiByteString[0x18]];
            case 0x18:
                if ((UCHAR)MultiByteString[0x17] < 0x20)    goto  bad_case;
                UnicodeString[0x17] = TranslateTable[(UCHAR)MultiByteString[0x17]];
            case 0x17:
                if ((UCHAR)MultiByteString[0x16] < 0x20)    goto  bad_case;
                UnicodeString[0x16] = TranslateTable[(UCHAR)MultiByteString[0x16]];
            case 0x16:
                if ((UCHAR)MultiByteString[0x15] < 0x20)    goto  bad_case;
                UnicodeString[0x15] = TranslateTable[(UCHAR)MultiByteString[0x15]];
            case 0x15:
                if ((UCHAR)MultiByteString[0x14] < 0x20)    goto  bad_case;
                UnicodeString[0x14] = TranslateTable[(UCHAR)MultiByteString[0x14]];
            case 0x14:
                if ((UCHAR)MultiByteString[0x13] < 0x20)    goto  bad_case;
                UnicodeString[0x13] = TranslateTable[(UCHAR)MultiByteString[0x13]];
            case 0x13:
                if ((UCHAR)MultiByteString[0x12] < 0x20)    goto  bad_case;
                UnicodeString[0x12] = TranslateTable[(UCHAR)MultiByteString[0x12]];
            case 0x12:
                if ((UCHAR)MultiByteString[0x11] < 0x20)    goto  bad_case;
                UnicodeString[0x11] = TranslateTable[(UCHAR)MultiByteString[0x11]];
            case 0x11:
                if ((UCHAR)MultiByteString[0x10] < 0x20)    goto  bad_case;
                UnicodeString[0x10] = TranslateTable[(UCHAR)MultiByteString[0x10]];
            case 0x10:
                if ((UCHAR)MultiByteString[0x0F] < 0x20)    goto  bad_case;
                UnicodeString[0x0F] = TranslateTable[(UCHAR)MultiByteString[0x0F]];
            case 0x0F:
                if ((UCHAR)MultiByteString[0x0E] < 0x20)    goto  bad_case;
                UnicodeString[0x0E] = TranslateTable[(UCHAR)MultiByteString[0x0E]];
            case 0x0E:
                if ((UCHAR)MultiByteString[0x0D] < 0x20)    goto  bad_case;
                UnicodeString[0x0D] = TranslateTable[(UCHAR)MultiByteString[0x0D]];
            case 0x0D:
                if ((UCHAR)MultiByteString[0x0C] < 0x20)    goto  bad_case;
                UnicodeString[0x0C] = TranslateTable[(UCHAR)MultiByteString[0x0C]];
            case 0x0C:
                if ((UCHAR)MultiByteString[0x0B] < 0x20)    goto  bad_case;
                UnicodeString[0x0B] = TranslateTable[(UCHAR)MultiByteString[0x0B]];
            case 0x0B:
                if ((UCHAR)MultiByteString[0x0A] < 0x20)    goto  bad_case;
                UnicodeString[0x0A] = TranslateTable[(UCHAR)MultiByteString[0x0A]];
            case 0x0A:
                if ((UCHAR)MultiByteString[0x09] < 0x20)    goto  bad_case;
                UnicodeString[0x09] = TranslateTable[(UCHAR)MultiByteString[0x09]];
            case 0x09:
                if ((UCHAR)MultiByteString[0x08] < 0x20)    goto  bad_case;
                UnicodeString[0x08] = TranslateTable[(UCHAR)MultiByteString[0x08]];
            case 0x08:
                if ((UCHAR)MultiByteString[0x07] < 0x20)    goto  bad_case;
                UnicodeString[0x07] = TranslateTable[(UCHAR)MultiByteString[0x07]];
            case 0x07:
                if ((UCHAR)MultiByteString[0x06] < 0x20)    goto  bad_case;
                UnicodeString[0x06] = TranslateTable[(UCHAR)MultiByteString[0x06]];
            case 0x06:
                if ((UCHAR)MultiByteString[0x05] < 0x20)    goto  bad_case;
                UnicodeString[0x05] = TranslateTable[(UCHAR)MultiByteString[0x05]];
            case 0x05:
                if ((UCHAR)MultiByteString[0x04] < 0x20)    goto  bad_case;
                UnicodeString[0x04] = TranslateTable[(UCHAR)MultiByteString[0x04]];
            case 0x04:
                if ((UCHAR)MultiByteString[0x03] < 0x20)    goto  bad_case;
                UnicodeString[0x03] = TranslateTable[(UCHAR)MultiByteString[0x03]];
            case 0x03:
                if ((UCHAR)MultiByteString[0x02] < 0x20)    goto  bad_case;
                UnicodeString[0x02] = TranslateTable[(UCHAR)MultiByteString[0x02]];
            case 0x02:
                if ((UCHAR)MultiByteString[0x01] < 0x20)    goto  bad_case;
                UnicodeString[0x01] = TranslateTable[(UCHAR)MultiByteString[0x01]];
            case 0x01:
                if ((UCHAR)MultiByteString[0x00] < 0x20)    goto  bad_case;
                UnicodeString[0x00] = TranslateTable[(UCHAR)MultiByteString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount > 0x20 ) {
                LoopCount -= 0x20;
                UnicodeString += 0x20;
                MultiByteString += 0x20;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;

        PWCH UnicodeStringAnchor = UnicodeString;
        TranslateTable = (PUSHORT)NlsMbAnsiCodePageTables;

        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (MaxCharsInUnicodeString && BytesInMultiByteString) {
            MaxCharsInUnicodeString--;
            BytesInMultiByteString--;
            if (NlsLeadByteInfo[*(PUCHAR)MultiByteString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInMultiByteString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsLeadByteInfo[*(PUCHAR)MultiByteString++];
                *UnicodeString = (WCHAR)TranslateTable[ Entry + *(PUCHAR)MultiByteString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in multibyte string to account
                // for the double byte character.
                //
                BytesInMultiByteString--;
            } else {
                //
                // Single byte character.
                //
                if ((UCHAR)MultiByteString[0x00] < 0x20)
                    *pdwSpecialChar = 1;
                *UnicodeString++ = NlsAnsiToUnicodeData[*(PUCHAR)MultiByteString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    return STATUS_SUCCESS;

    bad_case:
        //
        // this is a low probability case, so we optimized the loop.  If have a
        // special char, finish trans and notify caller.
        //
        *pdwSpecialChar = 1;
        return RtlMultiByteToUnicodeN(UnicodeString, MaxBytesInUnicodeString,
                NULL, MultiByteString, LoopCount);
}


NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.  For single-byte character sets, this address
        CAN be the same as UnicodeString.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG TmpCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);
    if (!NlsMbCodePageTag) {

        LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                     MaxCharsInUnicodeString : BytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

        TranslateTable = NlsAnsiToUnicodeData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x1F;
        UnicodeString += (LoopCount - TmpCount);
        MultiByteString += (LoopCount - TmpCount);
        quick_copy:
            switch( TmpCount ) {
            default:
                UnicodeString[0x1F] = TranslateTable[(UCHAR)MultiByteString[0x1F]];
            case 0x1F:
                UnicodeString[0x1E] = TranslateTable[(UCHAR)MultiByteString[0x1E]];
            case 0x1E:
                UnicodeString[0x1D] = TranslateTable[(UCHAR)MultiByteString[0x1D]];
            case 0x1D:
                UnicodeString[0x1C] = TranslateTable[(UCHAR)MultiByteString[0x1C]];
            case 0x1C:
                UnicodeString[0x1B] = TranslateTable[(UCHAR)MultiByteString[0x1B]];
            case 0x1B:
                UnicodeString[0x1A] = TranslateTable[(UCHAR)MultiByteString[0x1A]];
            case 0x1A:
                UnicodeString[0x19] = TranslateTable[(UCHAR)MultiByteString[0x19]];
            case 0x19:
                UnicodeString[0x18] = TranslateTable[(UCHAR)MultiByteString[0x18]];
            case 0x18:
                UnicodeString[0x17] = TranslateTable[(UCHAR)MultiByteString[0x17]];
            case 0x17:
                UnicodeString[0x16] = TranslateTable[(UCHAR)MultiByteString[0x16]];
            case 0x16:
                UnicodeString[0x15] = TranslateTable[(UCHAR)MultiByteString[0x15]];
            case 0x15:
                UnicodeString[0x14] = TranslateTable[(UCHAR)MultiByteString[0x14]];
            case 0x14:
                UnicodeString[0x13] = TranslateTable[(UCHAR)MultiByteString[0x13]];
            case 0x13:
                UnicodeString[0x12] = TranslateTable[(UCHAR)MultiByteString[0x12]];
            case 0x12:
                UnicodeString[0x11] = TranslateTable[(UCHAR)MultiByteString[0x11]];
            case 0x11:
                UnicodeString[0x10] = TranslateTable[(UCHAR)MultiByteString[0x10]];
            case 0x10:
                UnicodeString[0x0F] = TranslateTable[(UCHAR)MultiByteString[0x0F]];
            case 0x0F:
                UnicodeString[0x0E] = TranslateTable[(UCHAR)MultiByteString[0x0E]];
            case 0x0E:
                UnicodeString[0x0D] = TranslateTable[(UCHAR)MultiByteString[0x0D]];
            case 0x0D:
                UnicodeString[0x0C] = TranslateTable[(UCHAR)MultiByteString[0x0C]];
            case 0x0C:
                UnicodeString[0x0B] = TranslateTable[(UCHAR)MultiByteString[0x0B]];
            case 0x0B:
                UnicodeString[0x0A] = TranslateTable[(UCHAR)MultiByteString[0x0A]];
            case 0x0A:
                UnicodeString[0x09] = TranslateTable[(UCHAR)MultiByteString[0x09]];
            case 0x09:
                UnicodeString[0x08] = TranslateTable[(UCHAR)MultiByteString[0x08]];
            case 0x08:
                UnicodeString[0x07] = TranslateTable[(UCHAR)MultiByteString[0x07]];
            case 0x07:
                UnicodeString[0x06] = TranslateTable[(UCHAR)MultiByteString[0x06]];
            case 0x06:
                UnicodeString[0x05] = TranslateTable[(UCHAR)MultiByteString[0x05]];
            case 0x05:
                UnicodeString[0x04] = TranslateTable[(UCHAR)MultiByteString[0x04]];
            case 0x04:
                UnicodeString[0x03] = TranslateTable[(UCHAR)MultiByteString[0x03]];
            case 0x03:
                UnicodeString[0x02] = TranslateTable[(UCHAR)MultiByteString[0x02]];
            case 0x02:
                UnicodeString[0x01] = TranslateTable[(UCHAR)MultiByteString[0x01]];
            case 0x01:
                UnicodeString[0x00] = TranslateTable[(UCHAR)MultiByteString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount >= 0x20 ) {
                TmpCount = 0x20;
                LoopCount -= 0x20;
                UnicodeString -= 0x20;
                MultiByteString -= 0x20;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;
        PWCH UnicodeStringAnchor = UnicodeString;
        TranslateTable = (PUSHORT)NlsMbAnsiCodePageTables;

        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (MaxCharsInUnicodeString && BytesInMultiByteString) {
            MaxCharsInUnicodeString--;
            BytesInMultiByteString--;
            if (NlsLeadByteInfo[*(PUCHAR)MultiByteString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInMultiByteString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsLeadByteInfo[*(PUCHAR)MultiByteString++];
                *UnicodeString = (WCHAR)TranslateTable[ Entry + *(PUCHAR)MultiByteString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in multibyte string to account
                // for the double byte character.
                //
                BytesInMultiByteString--;
            } else {
                //
                // Single byte character.
                //
                *UnicodeString++ = NlsAnsiToUnicodeData[*(PUCHAR)MultiByteString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    return STATUS_SUCCESS;

}


NTSTATUS
RtlOemToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH OemString,
    IN ULONG BytesInOemString)

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    OEM Code Page (OCP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the oem source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of OemString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    OemString - Supplies the oem source string that is to be
        converted to unicode.

    BytesInOemString - The number of bytes in the string pointed to
        by OemString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_ILLEGAL_CHARACTER - The final Oem character was illegal

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole Oem string.  It was converted correct to the point though.

--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    // The OCP is a multibyte code page.  Check each character
    // to see if it is a lead byte before doing the translation.

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    if (!NlsMbOemCodePageTag) {

        LoopCount = (MaxCharsInUnicodeString < BytesInOemString) ?
                     MaxCharsInUnicodeString : BytesInOemString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);


        TranslateTable = NlsOemToUnicodeData;  // used to help the mips compiler

        quick_copy:
            switch( LoopCount ) {
            default:
                UnicodeString[0x0F] = TranslateTable[(UCHAR)OemString[0x0F]];
            case 0x0F:
                UnicodeString[0x0E] = TranslateTable[(UCHAR)OemString[0x0E]];
            case 0x0E:
                UnicodeString[0x0D] = TranslateTable[(UCHAR)OemString[0x0D]];
            case 0x0D:
                UnicodeString[0x0C] = TranslateTable[(UCHAR)OemString[0x0C]];
            case 0x0C:
                UnicodeString[0x0B] = TranslateTable[(UCHAR)OemString[0x0B]];
            case 0x0B:
                UnicodeString[0x0A] = TranslateTable[(UCHAR)OemString[0x0A]];
            case 0x0A:
                UnicodeString[0x09] = TranslateTable[(UCHAR)OemString[0x09]];
            case 0x09:
                UnicodeString[0x08] = TranslateTable[(UCHAR)OemString[0x08]];
            case 0x08:
                UnicodeString[0x07] = TranslateTable[(UCHAR)OemString[0x07]];
            case 0x07:
                UnicodeString[0x06] = TranslateTable[(UCHAR)OemString[0x06]];
            case 0x06:
                UnicodeString[0x05] = TranslateTable[(UCHAR)OemString[0x05]];
            case 0x05:
                UnicodeString[0x04] = TranslateTable[(UCHAR)OemString[0x04]];
            case 0x04:
                UnicodeString[0x03] = TranslateTable[(UCHAR)OemString[0x03]];
            case 0x03:
                UnicodeString[0x02] = TranslateTable[(UCHAR)OemString[0x02]];
            case 0x02:
                UnicodeString[0x01] = TranslateTable[(UCHAR)OemString[0x01]];
            case 0x01:
                UnicodeString[0x00] = TranslateTable[(UCHAR)OemString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount > 0x10 ) {
                LoopCount -= 0x10;
                OemString += 0x10;
                UnicodeString += 0x10;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;
        PWCH UnicodeStringAnchor = UnicodeString;

        TranslateTable = (PUSHORT)NlsMbOemCodePageTables;

        while (MaxCharsInUnicodeString && BytesInOemString) {
            MaxCharsInUnicodeString--;
            BytesInOemString--;
            if (NlsOemLeadByteInfo[*(PUCHAR)OemString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInOemString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsOemLeadByteInfo[*(PUCHAR)OemString++];
                *UnicodeString = TranslateTable[ Entry + *(PUCHAR)OemString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in oem string to account
                // for the double byte character.
                //
                BytesInOemString--;
            } else {
                //
                // Single byte character.
                //
                *UnicodeString++ = NlsOemToUnicodeData[*(PUCHAR)OemString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Oem String
    //
    return (BytesInOemString <= MaxCharsInUnicodeString) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlMultiByteToUnicodeSize(
    OUT PULONG BytesInUnicodeString,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified ANSI source string in Unicode string (not counting the
    null terminator)
    The translation is done with respect to the ANSI Code Page (ACP) installed
    at boot time.  Single byte characters in the range 0x00 - 0x7f are simply
    zero extended as a performance enhancement.  In some far eastern code pages
    0x5c is defined as the Yen sign.  For system translation we always want to
    consider 0x5c to be the backslash character.  We get this for free by zero
    extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    BytesInUnicodeString - Returns the number of bytes a Unicode translation
        of the ANSI string pointed to by MultiByteString would contain.

    MultiByteString - Supplies the ansi source string whose Unicode length
        is to be calculated.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful


--*/

{
    ULONG cbUnicode = 0;

    RTL_PAGED_CODE();

    if (NlsMbCodePageTag) {
        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (BytesInMultiByteString--) {
            if (NlsLeadByteInfo[*(PUCHAR)MultiByteString++]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.  NOTE: make sure
                // we have a trail byte to convert.
                //
                if (BytesInMultiByteString == 0) {
                    //
                    // RtlMultibyteToUnicodeN() uses the unicode
                    // default character if the last multibyte
                    // character is a lead byte.
                    //
                    cbUnicode += sizeof(WCHAR);
                    break;
                } else {
                    BytesInMultiByteString--;
                    MultiByteString++;
                }
            }
            cbUnicode += sizeof(WCHAR);
        }
        *BytesInUnicodeString = cbUnicode;
    } else {
        //
        // The ACP is a single byte code page.
        //
        *BytesInUnicodeString = BytesInMultiByteString * sizeof(WCHAR);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteSize(
    OUT PULONG BytesInMultiByteString,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified Unicode source string as an ANSI string (not counting the
    null terminator)

Arguments:

    BytesInMultiByteString - Returns the number of bytes an ANSI translation
        of the Unicode string pointed to by UnicodeString would contain.

    UnicodeString - Supplies the unicode source string whose ANSI length
        is to be calculated.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The conversion failed.  A unicode character was encountered
        that has no translation for the current ANSI Code Page (ACP).

--*/

{
    ULONG cbMultiByte = 0;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    /*
     * convert from bytes to chars for easier loop handling.
     */
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    if (NlsMbCodePageTag) {
        USHORT MbChar;

        while (CharsInUnicodeString--) {
            MbChar = NlsUnicodeToMbAnsiData[ *UnicodeString++ ];
            if (HIBYTE(MbChar) == 0) {
                cbMultiByte++ ;
            } else {
                cbMultiByte += 2;
            }
        }
        *BytesInMultiByteString = cbMultiByte;
    }
    else {
        *BytesInMultiByteString = CharsInUnicodeString;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                     CharsInUnicodeString : MaxBytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = LoopCount;

        TranslateTable = NlsUnicodeToAnsiData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        MultiByteString += TmpCount;

        do
        {
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                MultiByteString += 0x10;

                MultiByteString[-0x10] = TranslateTable[UnicodeString[-0x10]];
            case 0x0F:
                MultiByteString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
            case 0x0E:
                MultiByteString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
            case 0x0D:
                MultiByteString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
            case 0x0C:
                MultiByteString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
            case 0x0B:
                MultiByteString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
            case 0x0A:
                MultiByteString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
            case 0x09:
                MultiByteString[-0x09] = TranslateTable[UnicodeString[-0x09]];
            case 0x08:
                MultiByteString[-0x08] = TranslateTable[UnicodeString[-0x08]];
            case 0x07:
                MultiByteString[-0x07] = TranslateTable[UnicodeString[-0x07]];
            case 0x06:
                MultiByteString[-0x06] = TranslateTable[UnicodeString[-0x06]];
            case 0x05:
                MultiByteString[-0x05] = TranslateTable[UnicodeString[-0x05]];
            case 0x04:
                MultiByteString[-0x04] = TranslateTable[UnicodeString[-0x04]];
            case 0x03:
                MultiByteString[-0x03] = TranslateTable[UnicodeString[-0x03]];
            case 0x02:
                MultiByteString[-0x02] = TranslateTable[UnicodeString[-0x02]];
            case 0x01:
                MultiByteString[-0x01] = TranslateTable[UnicodeString[-0x01]];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        PCH MultiByteStringAnchor = MultiByteString;

        while ( CharsInUnicodeString && MaxBytesInMultiByteString ) {

            MbChar = NlsUnicodeToMbAnsiData[ *UnicodeString++ ];
            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInMultiByteString-- < 2) {
                    break;
                }
                *MultiByteString++ = HIBYTE(MbChar);  // lead byte
            }
            *MultiByteString++ = LOBYTE(MbChar);
            MaxBytesInMultiByteString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                     CharsInUnicodeString : MaxBytesInMultiByteString;

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = LoopCount;

        TranslateTable = NlsUnicodeToAnsiData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        MultiByteString += TmpCount;

        do
        {
            //
            // Convert to ANSI and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                MultiByteString += 0x10;

                SbChar = TranslateTable[UnicodeString[-0x10]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x10] = TranslateTable[UnicodeChar];
            case 0x0F:
                SbChar = TranslateTable[UnicodeString[-0x0F]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0F] = TranslateTable[UnicodeChar];
            case 0x0E:
                SbChar = TranslateTable[UnicodeString[-0x0E]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0E] = TranslateTable[UnicodeChar];
            case 0x0D:
                SbChar = TranslateTable[UnicodeString[-0x0D]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0D] = TranslateTable[UnicodeChar];
            case 0x0C:
                SbChar = TranslateTable[UnicodeString[-0x0C]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0C] = TranslateTable[UnicodeChar];
            case 0x0B:
                SbChar = TranslateTable[UnicodeString[-0x0B]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0B] = TranslateTable[UnicodeChar];
            case 0x0A:
                SbChar = TranslateTable[UnicodeString[-0x0A]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x0A] = TranslateTable[UnicodeChar];
            case 0x09:
                SbChar = TranslateTable[UnicodeString[-0x09]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x09] = TranslateTable[UnicodeChar];
            case 0x08:
                SbChar = TranslateTable[UnicodeString[-0x08]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x08] = TranslateTable[UnicodeChar];
            case 0x07:
                SbChar = TranslateTable[UnicodeString[-0x07]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x07] = TranslateTable[UnicodeChar];
            case 0x06:
                SbChar = TranslateTable[UnicodeString[-0x06]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x06] = TranslateTable[UnicodeChar];
            case 0x05:
                SbChar = TranslateTable[UnicodeString[-0x05]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x05] = TranslateTable[UnicodeChar];
            case 0x04:
                SbChar = TranslateTable[UnicodeString[-0x04]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x04] = TranslateTable[UnicodeChar];
            case 0x03:
                SbChar = TranslateTable[UnicodeString[-0x03]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x03] = TranslateTable[UnicodeChar];
            case 0x02:
                SbChar = TranslateTable[UnicodeString[-0x02]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x02] = TranslateTable[UnicodeChar];
            case 0x01:
                SbChar = TranslateTable[UnicodeString[-0x01]];
                UnicodeChar = NlsAnsiToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                MultiByteString[-0x01] = TranslateTable[UnicodeChar];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        register USHORT Entry;
        PCH MultiByteStringAnchor = MultiByteString;

        while ( CharsInUnicodeString && MaxBytesInMultiByteString ) {
            //
            // Convert to ANSI and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            MbChar = NlsUnicodeToMbAnsiData[ *UnicodeString++ ];
            if ( NlsLeadByteInfo[HIBYTE(MbChar)] ) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.
                //
                Entry = NlsLeadByteInfo[HIBYTE(MbChar)];
                UnicodeChar = (WCHAR)NlsMbAnsiCodePageTables[ Entry + LOBYTE(MbChar) ];
            } else {
                //
                // Single byte character.
                //
                UnicodeChar = NlsAnsiToUnicodeData[LOBYTE(MbChar)];
            }
            UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
            MbChar = NlsUnicodeToMbAnsiData[UnicodeChar];

            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInMultiByteString-- < 2) {
                    break;
                }
                *MultiByteString++ = HIBYTE(MbChar);  // lead byte
            }
            *MultiByteString++ = LOBYTE(MbChar);
            MaxBytesInMultiByteString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInMultiByteString))
            *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToOemN(
    OUT PCH OemString,
    IN ULONG MaxBytesInOemString,
    OUT PULONG BytesInOemString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM Code
    Page (OCP) loaded at boot time.

Arguments:

    OemString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInOemString - Supplies the maximum number of bytes to be
        written to OemString.  If this causes OemString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInOemString - Returns the number of bytes in the returned
        oem string pointed to by OemString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to oem.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole Oem string.  It was converted correct to the point though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbOemCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInOemString) ?
                     CharsInUnicodeString : MaxBytesInOemString;

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = LoopCount;

        TranslateTable = NlsUnicodeToOemData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        OemString += TmpCount;

        do
        {
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                OemString += 0x10;

                OemString[-0x10] = TranslateTable[UnicodeString[-0x10]];
            case 0x0F:
                OemString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
            case 0x0E:
                OemString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
            case 0x0D:
                OemString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
            case 0x0C:
                OemString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
            case 0x0B:
                OemString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
            case 0x0A:
                OemString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
            case 0x09:
                OemString[-0x09] = TranslateTable[UnicodeString[-0x09]];
            case 0x08:
                OemString[-0x08] = TranslateTable[UnicodeString[-0x08]];
            case 0x07:
                OemString[-0x07] = TranslateTable[UnicodeString[-0x07]];
            case 0x06:
                OemString[-0x06] = TranslateTable[UnicodeString[-0x06]];
            case 0x05:
                OemString[-0x05] = TranslateTable[UnicodeString[-0x05]];
            case 0x04:
                OemString[-0x04] = TranslateTable[UnicodeString[-0x04]];
            case 0x03:
                OemString[-0x03] = TranslateTable[UnicodeString[-0x03]];
            case 0x02:
                OemString[-0x02] = TranslateTable[UnicodeString[-0x02]];
            case 0x01:
                OemString[-0x01] = TranslateTable[UnicodeString[-0x01]];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        register USHORT MbChar;
        PCH OemStringAnchor = OemString;

        while ( CharsInUnicodeString && MaxBytesInOemString ) {

            MbChar = NlsUnicodeToMbOemData[ *UnicodeString++ ];
            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInOemString-- < 2) {
                    break;
                }
                *OemString++ = HIBYTE(MbChar);  // lead byte
            }
            *OemString++ = LOBYTE(MbChar);
            MaxBytesInOemString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = (ULONG)(OemString - OemStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInOemString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlUpcaseUnicodeToOemN(
    OUT PCH OemString,
    IN ULONG MaxBytesInOemString,
    OUT PULONG BytesInOemString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an oem string. The translation is done with respect
    to the OEM Code Page (OCP) loaded at boot time.

Arguments:

    OemString - Returns an oem string that is equivalent to the upper
        case of the unicode source string.  If the translation can not
        be done, an error is returned.

    MaxBytesInOemString - Supplies the maximum number of bytes to be
        written to OemString.  If this causes OemString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInOemString - Returns the number of bytes in the returned
        oem string pointed to by OemString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to oem.

    BytesInUnicodeString - The number of bytes in the the string pointed
        to by UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to
        hold the whole Oem string.  It was converted correctly to that
        point, though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!NlsMbOemCodePageTag) {

        LoopCount = (CharsInUnicodeString < MaxBytesInOemString) ?
                     CharsInUnicodeString : MaxBytesInOemString;

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = LoopCount;

        TranslateTable = NlsUnicodeToOemData;  // used to help the mips compiler

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        OemString += TmpCount;

        do
        {
            //
            // Convert to OEM and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                OemString += 0x10;

                SbChar = TranslateTable[UnicodeString[-0x10]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x10] = TranslateTable[UnicodeChar];
            case 0x0F:
                SbChar = TranslateTable[UnicodeString[-0x0F]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0F] = TranslateTable[UnicodeChar];
            case 0x0E:
                SbChar = TranslateTable[UnicodeString[-0x0E]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0E] = TranslateTable[UnicodeChar];
            case 0x0D:
                SbChar = TranslateTable[UnicodeString[-0x0D]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0D] = TranslateTable[UnicodeChar];
            case 0x0C:
                SbChar = TranslateTable[UnicodeString[-0x0C]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0C] = TranslateTable[UnicodeChar];
            case 0x0B:
                SbChar = TranslateTable[UnicodeString[-0x0B]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0B] = TranslateTable[UnicodeChar];
            case 0x0A:
                SbChar = TranslateTable[UnicodeString[-0x0A]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x0A] = TranslateTable[UnicodeChar];
            case 0x09:
                SbChar = TranslateTable[UnicodeString[-0x09]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x09] = TranslateTable[UnicodeChar];
            case 0x08:
                SbChar = TranslateTable[UnicodeString[-0x08]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x08] = TranslateTable[UnicodeChar];
            case 0x07:
                SbChar = TranslateTable[UnicodeString[-0x07]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x07] = TranslateTable[UnicodeChar];
            case 0x06:
                SbChar = TranslateTable[UnicodeString[-0x06]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x06] = TranslateTable[UnicodeChar];
            case 0x05:
                SbChar = TranslateTable[UnicodeString[-0x05]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x05] = TranslateTable[UnicodeChar];
            case 0x04:
                SbChar = TranslateTable[UnicodeString[-0x04]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x04] = TranslateTable[UnicodeChar];
            case 0x03:
                SbChar = TranslateTable[UnicodeString[-0x03]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x03] = TranslateTable[UnicodeChar];
            case 0x02:
                SbChar = TranslateTable[UnicodeString[-0x02]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x02] = TranslateTable[UnicodeChar];
            case 0x01:
                SbChar = TranslateTable[UnicodeString[-0x01]];
                UnicodeChar = NlsOemToUnicodeData[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                OemString[-0x01] = TranslateTable[UnicodeChar];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        register USHORT Entry;
        PCH OemStringAnchor = OemString;

        while ( CharsInUnicodeString && MaxBytesInOemString ) {
            //
            // Convert to OEM and back to Unicode before upper casing
            // to ensure the visual best fits are converted and
            // upper cased properly.
            //
            MbChar = NlsUnicodeToMbOemData[ *UnicodeString++ ];
            if (NlsOemLeadByteInfo[HIBYTE(MbChar)]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.
                //
                Entry = NlsOemLeadByteInfo[HIBYTE(MbChar)];
                UnicodeChar = (WCHAR)NlsMbOemCodePageTables[ Entry + LOBYTE(MbChar) ];
            } else {
                //
                // Single byte character.
                //
                UnicodeChar = NlsOemToUnicodeData[LOBYTE(MbChar)];
            }
            UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
            MbChar = NlsUnicodeToMbOemData[UnicodeChar];

            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInOemString-- < 2) {
                    break;
                }
                *OemString++ = HIBYTE(MbChar);  // lead byte
            }
            *OemString++ = LOBYTE(MbChar);
            MaxBytesInOemString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInOemString))
            *BytesInOemString = (ULONG)(OemString - OemStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInOemString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}

BOOLEAN
RtlpDidUnicodeToOemWork(
    IN PCOEM_STRING OemString,
    IN PCUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function looks for the default character in the Oem string, making
    sure it was not a correct translation from the Unicode source string.

    This allows us to test whether or not a translation was really successful.

Arguments:

    OemString - The result of conversion from the unicode string.

    UnicodeString - The source of the Oem string.

Return Value:

    TRUE if the Unicode to Oem translation caused no default characters to be
        inserted.  FALSE otherwise.

--*/

{
    ULONG OemOffset;
    BOOLEAN Result = TRUE;

    RTL_PAGED_CODE();

    if (!NlsMbOemCodePageTag) {

        for (OemOffset = 0;
             OemOffset < OemString->Length;
             OemOffset += 1) {

            if ((OemString->Buffer[OemOffset] == (UCHAR)OemDefaultChar) &&
                (UnicodeString->Buffer[OemOffset] != OemTransUniDefaultChar)) {

                Result = FALSE;
                break;
            }
        }

    } else {

        ULONG UnicodeOffset;

        for (OemOffset = 0, UnicodeOffset = 0;
             OemOffset < OemString->Length;
             OemOffset += 1, UnicodeOffset += 1) {

            //
            //  If we landed on a DBCS character handle it accordingly
            //

            if (NlsOemLeadByteInfo[(UCHAR)OemString->Buffer[OemOffset]]) {

                USHORT DbcsChar;

                ASSERT( OemOffset + 1 < OemString->Length );

                DbcsChar = (OemString->Buffer[OemOffset] << 8) + (UCHAR)OemString->Buffer[OemOffset+1];
                OemOffset++;

                if ((DbcsChar == OemDefaultChar) &&
                    (UnicodeString->Buffer[UnicodeOffset] != OemTransUniDefaultChar)) {

                    Result = FALSE;
                    break;
                }

                continue;
            }

            if ((OemString->Buffer[OemOffset] == (UCHAR)OemDefaultChar) &&
                (UnicodeString->Buffer[UnicodeOffset] != OemTransUniDefaultChar)) {

                Result = FALSE;
                break;
            }
        }
    }

    return Result;
}


NTSTATUS
RtlCustomCPToUnicodeN(
    IN PCPTABLEINFO CustomCP,
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH CustomCPString,
    IN ULONG BytesInCustomCPString)

/*++

Routine Description:

    This functions converts the specified CustomCP source string into a
    Unicode string. The translation is done with respect to the
    CustomCP Code Page specified.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    CustomCP - Supplies the address of the code page that translations
        are done relative to

    UnicodeString - Returns a unicode string that is equivalent to
        the CustomCP source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of CustomCPString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    CustomCPString - Supplies the CustomCP source string that is to be
        converted to unicode.

    BytesInCustomCPString - The number of bytes in the string pointed to
        by CustomCPString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_ILLEGAL_CHARACTER - The final CustomCP character was illegal

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole CustomCP string.  It was converted correct to the point though.

--*/

{
    ULONG LoopCount;
    PUSHORT TranslateTable;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    if (!(CustomCP->DBCSCodePage)) {
        //
        // The Custom CP is a single byte code page.
        //

        LoopCount = (MaxCharsInUnicodeString < BytesInCustomCPString) ?
                     MaxCharsInUnicodeString : BytesInCustomCPString;

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = LoopCount * sizeof(WCHAR);


        TranslateTable = CustomCP->MultiByteTable;

        quick_copy:
            switch( LoopCount ) {
            default:
                UnicodeString[0x0F] = TranslateTable[(UCHAR)CustomCPString[0x0F]];
            case 0x0F:
                UnicodeString[0x0E] = TranslateTable[(UCHAR)CustomCPString[0x0E]];
            case 0x0E:
                UnicodeString[0x0D] = TranslateTable[(UCHAR)CustomCPString[0x0D]];
            case 0x0D:
                UnicodeString[0x0C] = TranslateTable[(UCHAR)CustomCPString[0x0C]];
            case 0x0C:
                UnicodeString[0x0B] = TranslateTable[(UCHAR)CustomCPString[0x0B]];
            case 0x0B:
                UnicodeString[0x0A] = TranslateTable[(UCHAR)CustomCPString[0x0A]];
            case 0x0A:
                UnicodeString[0x09] = TranslateTable[(UCHAR)CustomCPString[0x09]];
            case 0x09:
                UnicodeString[0x08] = TranslateTable[(UCHAR)CustomCPString[0x08]];
            case 0x08:
                UnicodeString[0x07] = TranslateTable[(UCHAR)CustomCPString[0x07]];
            case 0x07:
                UnicodeString[0x06] = TranslateTable[(UCHAR)CustomCPString[0x06]];
            case 0x06:
                UnicodeString[0x05] = TranslateTable[(UCHAR)CustomCPString[0x05]];
            case 0x05:
                UnicodeString[0x04] = TranslateTable[(UCHAR)CustomCPString[0x04]];
            case 0x04:
                UnicodeString[0x03] = TranslateTable[(UCHAR)CustomCPString[0x03]];
            case 0x03:
                UnicodeString[0x02] = TranslateTable[(UCHAR)CustomCPString[0x02]];
            case 0x02:
                UnicodeString[0x01] = TranslateTable[(UCHAR)CustomCPString[0x01]];
            case 0x01:
                UnicodeString[0x00] = TranslateTable[(UCHAR)CustomCPString[0x00]];
            case 0x00:
                ;
            }

            if ( LoopCount > 0x10 ) {
                LoopCount -= 0x10;
                CustomCPString += 0x10;
                UnicodeString += 0x10;

                goto  quick_copy;
            }
        /* end of copy... */
    } else {
        register USHORT Entry;
        PWCH UnicodeStringAnchor = UnicodeString;
        PUSHORT NlsCustomLeadByteInfo = CustomCP->DBCSOffsets;

        //
        // The CP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        TranslateTable = (PUSHORT)(CustomCP->DBCSOffsets);

        while (MaxCharsInUnicodeString && BytesInCustomCPString) {
            MaxCharsInUnicodeString--;
            BytesInCustomCPString--;
            if (NlsCustomLeadByteInfo[*(PUCHAR)CustomCPString]) {
                //
                // Lead byte - Make sure there is a trail byte.  If not,
                // pass back a space rather than an error.  Some 3.x
                // applications pass incorrect strings and don't expect
                // to get an error.
                //
                if (BytesInCustomCPString == 0)
                {
                    *UnicodeString++ = UnicodeNull;
                    break;
                }

                //
                // Get the unicode character.
                //
                Entry = NlsCustomLeadByteInfo[*(PUCHAR)CustomCPString++];
                *UnicodeString = TranslateTable[ Entry + *(PUCHAR)CustomCPString++ ];
                UnicodeString++;

                //
                // Decrement count of bytes in multibyte string to account
                // for the double byte character.
                //
                BytesInCustomCPString--;
            } else {
                //
                // Single byte character.
                //
                *UnicodeString++ = (CustomCP->MultiByteTable)[*(PUCHAR)CustomCPString++];
            }
        }

        if (ARGUMENT_PRESENT(BytesInUnicodeString))
            *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    //
    //  Check if we were able to use all of the source CustomCP String
    //
    return ( BytesInCustomCPString <= MaxCharsInUnicodeString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT PULONG BytesInCustomCPString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    CustomCP string.  The translation is done with respect to the
    CustomCP Code Page specified by CustomCp.

Arguments:

    CustomCP - Supplies the address of the code page that translations
        are done relative to

    CustomCPString - Returns an CustomCP string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInCustomCPString - Supplies the maximum number of bytes to be
        written to CustomCPString.  If this causes CustomCPString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInCustomCPString - Returns the number of bytes in the returned
        CustomCP string pointed to by CustomCPString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to CustomCP.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold
        the whole CustomCP string.  It was converted correct to the point though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    PUSHORT WideTranslateTable;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!(CustomCP->DBCSCodePage)) {

        LoopCount = (CharsInUnicodeString < MaxBytesInCustomCPString) ?
                     CharsInUnicodeString : MaxBytesInCustomCPString;

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = LoopCount;

        TranslateTable = CustomCP->WideCharTable;

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        CustomCPString += TmpCount;

        do
        {
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                CustomCPString += 0x10;

                CustomCPString[-0x10] = TranslateTable[UnicodeString[-0x10]];
            case 0x0F:
                CustomCPString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
            case 0x0E:
                CustomCPString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
            case 0x0D:
                CustomCPString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
            case 0x0C:
                CustomCPString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
            case 0x0B:
                CustomCPString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
            case 0x0A:
                CustomCPString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
            case 0x09:
                CustomCPString[-0x09] = TranslateTable[UnicodeString[-0x09]];
            case 0x08:
                CustomCPString[-0x08] = TranslateTable[UnicodeString[-0x08]];
            case 0x07:
                CustomCPString[-0x07] = TranslateTable[UnicodeString[-0x07]];
            case 0x06:
                CustomCPString[-0x06] = TranslateTable[UnicodeString[-0x06]];
            case 0x05:
                CustomCPString[-0x05] = TranslateTable[UnicodeString[-0x05]];
            case 0x04:
                CustomCPString[-0x04] = TranslateTable[UnicodeString[-0x04]];
            case 0x03:
                CustomCPString[-0x03] = TranslateTable[UnicodeString[-0x03]];
            case 0x02:
                CustomCPString[-0x02] = TranslateTable[UnicodeString[-0x02]];
            case 0x01:
                CustomCPString[-0x01] = TranslateTable[UnicodeString[-0x01]];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        PCH CustomCPStringAnchor = CustomCPString;

        WideTranslateTable = CustomCP->WideCharTable;

        while (CharsInUnicodeString && MaxBytesInCustomCPString) {

            MbChar = WideTranslateTable[ *UnicodeString++ ];
            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInCustomCPString-- < 2) {
                    break;
                }
                *CustomCPString++ = HIBYTE(MbChar);  // lead byte
            }
            *CustomCPString++ = LOBYTE(MbChar);
            MaxBytesInCustomCPString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = (ULONG)(CustomCPString - CustomCPStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInCustomCPString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}


NTSTATUS
RtlUpcaseUnicodeToCustomCPN(
    IN PCPTABLEINFO CustomCP,
    OUT PCH CustomCPString,
    IN ULONG MaxBytesInCustomCPString,
    OUT PULONG BytesInCustomCPString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into a CustomCP string.  The translation is done with
    respect to the CustomCP Code Page specified by CustomCp.

Arguments:

    CustomCP - Supplies the address of the code page that translations
        are done relative to

    CustomCPString - Returns an CustomCP string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInCustomCPString - Supplies the maximum number of bytes to be
        written to CustomCPString.  If this causes CustomCPString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInCustomCPString - Returns the number of bytes in the returned
        CustomCP string pointed to by CustomCPString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to CustomCP.

    BytesInUnicodeString - The number of bytes in the the string pointed
        to by UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to
        hold the whole CustomCP string.  It was converted correctly to
        that point, though.

--*/

{
    ULONG TmpCount;
    ULONG LoopCount;
    PCH TranslateTable;
    PUSHORT WideTranslateTable;
    ULONG CharsInUnicodeString;
    UCHAR SbChar;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    if (!(CustomCP->DBCSCodePage)) {

        LoopCount = (CharsInUnicodeString < MaxBytesInCustomCPString) ?
                     CharsInUnicodeString : MaxBytesInCustomCPString;

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = LoopCount;

        TranslateTable = CustomCP->WideCharTable;

        TmpCount = LoopCount & 0x0F;
        UnicodeString += TmpCount;
        CustomCPString += TmpCount;

        do
        {
            //
            // Convert to Single Byte and back to Unicode before upper
            // casing to ensure the visual best fits are converted and
            // upper cased properly.
            //
            switch( TmpCount ) {
            default:
                UnicodeString += 0x10;
                CustomCPString += 0x10;

                SbChar = TranslateTable[UnicodeString[-0x10]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x10] = TranslateTable[UnicodeChar];
            case 0x0F:
                SbChar = TranslateTable[UnicodeString[-0x0F]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0F] = TranslateTable[UnicodeChar];
            case 0x0E:
                SbChar = TranslateTable[UnicodeString[-0x0E]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0E] = TranslateTable[UnicodeChar];
            case 0x0D:
                SbChar = TranslateTable[UnicodeString[-0x0D]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0D] = TranslateTable[UnicodeChar];
            case 0x0C:
                SbChar = TranslateTable[UnicodeString[-0x0C]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0C] = TranslateTable[UnicodeChar];
            case 0x0B:
                SbChar = TranslateTable[UnicodeString[-0x0B]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0B] = TranslateTable[UnicodeChar];
            case 0x0A:
                SbChar = TranslateTable[UnicodeString[-0x0A]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x0A] = TranslateTable[UnicodeChar];
            case 0x09:
                SbChar = TranslateTable[UnicodeString[-0x09]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x09] = TranslateTable[UnicodeChar];
            case 0x08:
                SbChar = TranslateTable[UnicodeString[-0x08]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x08] = TranslateTable[UnicodeChar];
            case 0x07:
                SbChar = TranslateTable[UnicodeString[-0x07]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x07] = TranslateTable[UnicodeChar];
            case 0x06:
                SbChar = TranslateTable[UnicodeString[-0x06]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x06] = TranslateTable[UnicodeChar];
            case 0x05:
                SbChar = TranslateTable[UnicodeString[-0x05]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x05] = TranslateTable[UnicodeChar];
            case 0x04:
                SbChar = TranslateTable[UnicodeString[-0x04]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x04] = TranslateTable[UnicodeChar];
            case 0x03:
                SbChar = TranslateTable[UnicodeString[-0x03]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x03] = TranslateTable[UnicodeChar];
            case 0x02:
                SbChar = TranslateTable[UnicodeString[-0x02]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x02] = TranslateTable[UnicodeChar];
            case 0x01:
                SbChar = TranslateTable[UnicodeString[-0x01]];
                UnicodeChar = (CustomCP->MultiByteTable)[SbChar];
                UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
                CustomCPString[-0x01] = TranslateTable[UnicodeChar];
            case 0x00:
                ;
            }

            LoopCount -= TmpCount;
            TmpCount = 0x10;
        } while ( LoopCount > 0 );

        /* end of copy... */
    } else {
        USHORT MbChar;
        register USHORT Entry;
        PCH CustomCPStringAnchor = CustomCPString;
        PUSHORT NlsCustomLeadByteInfo = CustomCP->DBCSOffsets;

        WideTranslateTable = CustomCP->WideCharTable;

        while ( CharsInUnicodeString && MaxBytesInCustomCPString ) {
            //
            // Convert to Single Byte and back to Unicode before upper
            // casing to ensure the visual best fits are converted and
            // upper cased properly.
            //
            MbChar = WideTranslateTable[ *UnicodeString++ ];
            if (NlsCustomLeadByteInfo[HIBYTE(MbChar)]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.
                //
                Entry = NlsCustomLeadByteInfo[HIBYTE(MbChar)];
                UnicodeChar = NlsCustomLeadByteInfo[ Entry + LOBYTE(MbChar) ];
            } else {
                //
                // Single byte character.
                //
                UnicodeChar = (CustomCP->MultiByteTable)[LOBYTE(MbChar)];
            }
            UnicodeChar = (WCHAR)NLS_UPCASE(UnicodeChar);
            MbChar = WideTranslateTable[UnicodeChar];

            if (HIBYTE(MbChar) != 0) {
                //
                // Need at least 2 bytes to copy a double byte char.
                // Don't want to truncate in the middle of a DBCS char.
                //
                if (MaxBytesInCustomCPString-- < 2) {
                    break;
                }
                *CustomCPString++ = HIBYTE(MbChar);  // lead byte
            }
            *CustomCPString++ = LOBYTE(MbChar);
            MaxBytesInCustomCPString--;

            CharsInUnicodeString--;
        }

        if (ARGUMENT_PRESENT(BytesInCustomCPString))
            *BytesInCustomCPString = (ULONG)(CustomCPString - CustomCPStringAnchor);
    }

    //
    //  Check if we were able to use all of the source Unicode String
    //
    return ( CharsInUnicodeString <= MaxBytesInCustomCPString ) ?
           STATUS_SUCCESS :
           STATUS_BUFFER_OVERFLOW;
}

#define MB_TBL_SIZE      256             /* size of MB tables */
#define GLYPH_TBL_SIZE   MB_TBL_SIZE     /* size of GLYPH tables */
#define DBCS_TBL_SIZE    256             /* size of DBCS tables */
#define GLYPH_HEADER     1               /* size of GLYPH table header */
#define DBCS_HEADER      1               /* size of DBCS table header */
#define LANG_HEADER      1               /* size of LANGUAGE file header */
#define UP_HEADER        1               /* size of UPPERCASE table header */
#define LO_HEADER        1               /* size of LOWERCASE table header */

VOID
RtlInitCodePageTable(
    IN PUSHORT TableBase,
    OUT PCPTABLEINFO CodePageTable
    )
{
    USHORT offMB;
    USHORT offWC;
    PUSHORT pGlyph;
    PUSHORT pRange;

    RTL_PAGED_CODE();

    //
    // Get the offsets.
    //

    offMB = TableBase[0];
    offWC = offMB + TableBase[offMB];


    //
    // Attach Code Page Info to CP hash node.
    //

    CodePageTable->CodePage = TableBase[1];
    CodePageTable->MaximumCharacterSize = TableBase[2];
    CodePageTable->DefaultChar = TableBase[3];           // default character (MB)
    CodePageTable->UniDefaultChar = TableBase[4];        // default character (Unicode)
    CodePageTable->TransDefaultChar = TableBase[5];      // trans of default char (Unicode)
    CodePageTable->TransUniDefaultChar = TableBase[6];   // trans of Uni default char (MB)
    RtlCopyMemory(
        &CodePageTable->LeadByte,
        &TableBase[7],
        MAXIMUM_LEADBYTES
        );
    CodePageTable->MultiByteTable = (TableBase + offMB + 1);

    pGlyph = CodePageTable->MultiByteTable + MB_TBL_SIZE;

    if (pGlyph[0] != 0) {
        pRange = CodePageTable->DBCSRanges = pGlyph + GLYPH_HEADER + GLYPH_TBL_SIZE;
        }
    else {
        pRange = CodePageTable->DBCSRanges = pGlyph + GLYPH_HEADER;
        }

    //
    //  Attach DBCS information to CP hash node.
    //

    if (pRange[0] > 0) {
        CodePageTable->DBCSOffsets = pRange + DBCS_HEADER;
        CodePageTable->DBCSCodePage = 1;
        }
    else {
        CodePageTable->DBCSCodePage = 0;
        CodePageTable->DBCSOffsets = NULL;
        }

    CodePageTable->WideCharTable = (TableBase + offWC + 1);
}


VOID
RtlpInitUpcaseTable(
    IN PUSHORT TableBase,
    OUT PNLSTABLEINFO CodePageTable
    )
{
    USHORT offUP;
    USHORT offLO;

    //
    // Get the offsets.
    //

    offUP = LANG_HEADER;
    offLO = offUP + TableBase[offUP];

    CodePageTable->UpperCaseTable = TableBase + offUP + UP_HEADER;
    CodePageTable->LowerCaseTable = TableBase + offLO + LO_HEADER;
}


VOID
RtlInitNlsTables(
    IN PUSHORT AnsiNlsBase,
    IN PUSHORT OemNlsBase,
    IN PUSHORT LanguageNlsBase,
    OUT PNLSTABLEINFO TableInfo
    )
{
    RTL_PAGED_CODE();

    RtlInitCodePageTable(AnsiNlsBase,&TableInfo->AnsiTableInfo);
    RtlInitCodePageTable(OemNlsBase,&TableInfo->OemTableInfo);
    RtlpInitUpcaseTable(LanguageNlsBase,TableInfo);
}


VOID
RtlResetRtlTranslations(
    PNLSTABLEINFO TableInfo
    )
{
    RTL_PAGED_CODE();

    if ( TableInfo->AnsiTableInfo.DBCSCodePage ) {
        RtlMoveMemory(NlsLeadByteInfo,TableInfo->AnsiTableInfo.DBCSOffsets,DBCS_TBL_SIZE*sizeof(USHORT));
        }
    else {
        RtlZeroMemory(NlsLeadByteInfo,DBCS_TBL_SIZE*sizeof(USHORT));
        }

    NlsMbAnsiCodePageTables = (PUSHORT)TableInfo->AnsiTableInfo.DBCSOffsets;

    NlsAnsiToUnicodeData = TableInfo->AnsiTableInfo.MultiByteTable;
    NlsUnicodeToAnsiData = (PCH)TableInfo->AnsiTableInfo.WideCharTable;
    NlsUnicodeToMbAnsiData = (PUSHORT)TableInfo->AnsiTableInfo.WideCharTable;
    NlsMbCodePageTag = TableInfo->AnsiTableInfo.DBCSCodePage ? TRUE : FALSE;
    NlsAnsiCodePage = TableInfo->AnsiTableInfo.CodePage;

    if ( TableInfo->OemTableInfo.DBCSCodePage ) {
        RtlMoveMemory(NlsOemLeadByteInfo,TableInfo->OemTableInfo.DBCSOffsets,DBCS_TBL_SIZE*sizeof(USHORT));
        }
    else {
        RtlZeroMemory(NlsOemLeadByteInfo,DBCS_TBL_SIZE*sizeof(USHORT));
        }

    NlsMbOemCodePageTables = (PUSHORT)TableInfo->OemTableInfo.DBCSOffsets;

    NlsOemToUnicodeData = TableInfo->OemTableInfo.MultiByteTable;
    NlsUnicodeToOemData = (PCH)TableInfo->OemTableInfo.WideCharTable;
    NlsUnicodeToMbOemData = (PUSHORT)TableInfo->OemTableInfo.WideCharTable;
    NlsMbOemCodePageTag = TableInfo->OemTableInfo.DBCSCodePage ? TRUE : FALSE;
    NlsOemCodePage = TableInfo->OemTableInfo.CodePage;
    OemDefaultChar = TableInfo->OemTableInfo.DefaultChar;
    OemTransUniDefaultChar = TableInfo->OemTableInfo.TransDefaultChar;

    Nls844UnicodeUpcaseTable = TableInfo->UpperCaseTable;
    Nls844UnicodeLowercaseTable = TableInfo->LowerCaseTable;
    UnicodeDefaultChar = TableInfo->AnsiTableInfo.UniDefaultChar;
}

void
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    )
{
    RTL_PAGED_CODE();
    *AnsiCodePage = NlsAnsiCodePage;
    *OemCodePage = NlsOemCodePage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\lookup.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    lookup.c

Abstract:

    This module implements function table lookup for platforms with table
    base exception handling.

Author:

    David N. Cutler (davec) 30-May-2001

Revision History:

--*/

#include "ntrtlp.h"

//
// Define external data.
//

#if defined(NTOS_KERNEL_RUNTIME)

#if defined(_AMD64_) // ****** temp ******

#pragma alloc_text(INIT, RtlInitializeHistoryTable)

#endif // ****** temp ******

#else

#include "..\ntdll\ldrp.h"

extern PVOID NtDllBase;

#endif

//
// Define global unwind history table to hold the constant unwind entries
// for exception dispatch followed by unwind.
//

UNWIND_HISTORY_TABLE RtlpUnwindHistoryTable = {
    0, UNWIND_HISTORY_TABLE_NONE, - 1, 0};

#if defined(_AMD64_) // ****** temp ******

VOID
RtlInitializeHistoryTable (
    VOID
    )

/*++

Routine Description:

    This function initializes the global unwind history table.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG64 BeginAddress;
    ULONG64 ControlPc;
    ULONG64 EndAddress;
    PVOID *FunctionAddressTable;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG64 ImageBase;
    ULONG Index;

    //
    // Lookup function entries from the function address table until a NULL
    // entry is encountered or the unwind history table is full.
    //

    FunctionAddressTable = &RtlpFunctionAddressTable[0];
    Index = 0;
    while ((Index < UNWIND_HISTORY_TABLE_SIZE) &&
           (*FunctionAddressTable != NULL)) {

        ControlPc = (ULONG64)*FunctionAddressTable++;
        FunctionEntry = RtlLookupFunctionEntry(ControlPc,
                                               &ImageBase,
                                               NULL);

        ASSERT(FunctionEntry != NULL);

        BeginAddress = FunctionEntry->BeginAddress + ImageBase;
        EndAddress = FunctionEntry->EndAddress + ImageBase;
        RtlpUnwindHistoryTable.Entry[Index].ImageBase = ImageBase;
        RtlpUnwindHistoryTable.Entry[Index].FunctionEntry = FunctionEntry;
        if (BeginAddress < RtlpUnwindHistoryTable.LowAddress) {
            RtlpUnwindHistoryTable.LowAddress = BeginAddress;
        }

        if (EndAddress > RtlpUnwindHistoryTable.HighAddress) {
            RtlpUnwindHistoryTable.HighAddress = EndAddress;
        }

        Index += 1;
    }

    RtlpUnwindHistoryTable.Count = Index;
    return;
}

#endif // ****** temp ******

PRUNTIME_FUNCTION
RtlpSearchInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ControlPc,
    OUT PVOID *ImageBase,

#if defined(_IA64_)

    OUT PULONG64 Gp,
#endif

    OUT PULONG SizeOfTable
    )

/*++

Routine Description:

    This function searches for a matching entry in an inverted function
    table using the specified control PC value.

    N.B. It is assumed that appropriate locks are held when this routine
         is called.

Arguments:

    InvertedTable - Supplies a pointer to an inverted function table.

    ControlPc - Supplies a PC value to to use in searching the inverted
        function table.

    ImageBase - Supplies a pointer to a variable that receives the base
         address of the corresponding module.

    SizeOfTable - Supplies a pointer to a variable that recevies the size
         of the function table in bytes.

Return Value:

    If a matching entry is located in the specified function table, then
    the function table address is returned as the function value. Otherwise,
    a value of NULL is returned.

--*/

{

    PVOID Bound;
    LONG High;
    ULONG Index;
    PINVERTED_FUNCTION_TABLE_ENTRY InvertedEntry;
    LONG Low;
    LONG Middle;

    //
    // If there are any entries in the specified inverted function table,
    // then search the table for a matching entry.
    //

    if (InvertedTable->CurrentSize != 0) {
        Low = 0;
        High = InvertedTable->CurrentSize - 1;
        while (High >= Low) {

            //
            // Compute next probe index and test entry. If the specified
            // control PC is greater than of equal to the beginning address
            // and less than the ending address of the inverted function
            // table entry, then return the address of the function table.
            // Otherwise, continue the search.
            //

            Middle = (Low + High) >> 1;
            InvertedEntry = &InvertedTable->TableEntry[Middle];
            Bound = (PVOID)((ULONG_PTR)InvertedEntry->ImageBase + InvertedEntry->SizeOfImage);
            if (ControlPc < InvertedEntry->ImageBase) {
                High = Middle - 1;

            } else if (ControlPc >= Bound) {
                Low = Middle + 1;

            } else {
                *ImageBase = InvertedEntry->ImageBase;

#if defined(_IA64_)

                *Gp = InvertedEntry->Gp;

#endif

                *SizeOfTable = InvertedEntry->SizeOfTable;
                return InvertedEntry->FunctionTable;
            }
        }
    }

    return NULL;
}

PRUNTIME_FUNCTION
RtlpLookupFunctionTable (
    IN PVOID ControlPc,
    OUT PVOID *ImageBase,

#if defined(_IA64_)

    OUT PULONG64 Gp,

#endif

    OUT PULONG SizeOfTable
    )

/*++

Routine Description:

    This function looks up the control PC in the loaded module list, and
    returns the image base, the size of the function table, and the address
    of the function table.

Arguments:

    ControlPc - Supplies an address in the module to be looked up.

    ImageBase - Supplies a pointer to a variable that receives the base
         address of the corresponding module.

    SizeOfTable - Supplies a pointer to a variable that recevies the size
         of the function table in bytes.

Return Value:

    If a module is found that contains the specified control PC value and
    that module contains a function table, then the address of the function
    table is returned as the function value. Otherwise, NULL is returned.

--*/

{

    PVOID Base;
    ULONG_PTR Bound;
    PLDR_DATA_TABLE_ENTRY Entry;
    PRUNTIME_FUNCTION FunctionTable;
    PLIST_ENTRY Next;

#if defined(NTOS_KERNEL_RUNTIME)

    KIRQL OldIrql;

    //
    // Acquire the loaded module list spinlock and scan the list for the
    // specified PC value if the list has been initialized.
    //

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < DISPATCH_LEVEL) {
        KeRaiseIrqlToDpcLevel();
    }

    ExAcquireSpinLockAtDpcLevel(&PsLoadedModuleSpinLock);
    FunctionTable = RtlpSearchInvertedFunctionTable(&PsInvertedFunctionTable,
                                                    ControlPc,
                                                    &Base,

#if defined(_IA64_)

                                                    Gp,

#endif

                                                    SizeOfTable);

    if ((FunctionTable == NULL) &&
        (PsInvertedFunctionTable.Overflow != FALSE)) {

        Next = PsLoadedModuleList.Flink;
        if (Next != NULL) {
            while (Next != &PsLoadedModuleList) {
                Entry = CONTAINING_RECORD(Next,
                                          LDR_DATA_TABLE_ENTRY,
                                          InLoadOrderLinks);
    
                Next = Next->Flink;
                Base = Entry->DllBase;
                Bound = (ULONG_PTR)Base + Entry->SizeOfImage;
                if (((ULONG_PTR)ControlPc >= (ULONG_PTR)Base) &&
                    ((ULONG_PTR)ControlPc < Bound)) {
    
                    //
                    // Lookup function table address and size.
                    //
    
#if defined(_IA64_)
                    
                    *Gp = (ULONG64)(RtlImageDirectoryEntryToData(Base,
                                                                 TRUE,
                                                                 IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                                                                 SizeOfTable));

#endif

                    FunctionTable = RtlImageDirectoryEntryToData(Base,
                                                                 TRUE,
                                                                 IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                                 SizeOfTable);

                    break;
                }
            }
        }
    }

    //
    // Release the loaded module list spin lock.
    //

    ExReleaseSpinLock(&PsLoadedModuleSpinLock, OldIrql);

#else

    BOOLEAN InLdrInit;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    PLIST_ENTRY ModuleListHead;
    PIMAGE_NT_HEADERS NtHeaders;
    PPEB Peb;
    PTEB Teb;
    NTSTATUS Status;

    //
    // Acquire the Loader lock for the current process and scan the loaded
    // module list for the specified PC value if all the data structures
    // have been initialized.
    //

    FunctionTable = NULL;
    InLdrInit = LdrpInLdrInit;
    if ((InLdrInit == FALSE) &&
        (RtlTryEnterCriticalSection(&LdrpLoaderLock) == FALSE)) {

        //
        // The loader lock could not be acquired. Call the system to find the
        // image that contains the control PC.
        //

        Status = NtQueryVirtualMemory(NtCurrentProcess(),
                                      ControlPc,
                                      MemoryBasicInformation,
                                      &MemoryInformation,
                                      sizeof(MEMORY_BASIC_INFORMATION),
                                      NULL);

        if (NT_SUCCESS(Status) &&
            (MemoryInformation.Type == MEM_IMAGE)) {

            //
            // Lookup function table address and size.
            //

            Base = MemoryInformation.AllocationBase;

#if defined(_IA64_)
            
            *Gp = (ULONG64)(RtlImageDirectoryEntryToData(Base,
                                                         TRUE,
                                                         IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                                                         SizeOfTable));

#endif

            FunctionTable = RtlImageDirectoryEntryToData(Base,
                                                         TRUE,
                                                         IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                         SizeOfTable);
        }

    } else {

        //
        // The loader lock was acquired or the loader is being initialized.
        // Search the loaded module list if it is currently defined. Otherwise,
        // set the values for ntdll.
        //

        Teb = NtCurrentTeb();
        if (Teb != NULL) {
            Peb = Teb->ProcessEnvironmentBlock;
            if (Peb->Ldr != NULL) {

                FunctionTable = RtlpSearchInvertedFunctionTable(&LdrpInvertedFunctionTable,
                                                                ControlPc,
                                                                &Base,
        
#if defined(_IA64_)

                                                                Gp,

#endif

                                                                SizeOfTable);

                if ((FunctionTable == NULL) &&
                    ((InLdrInit != FALSE) ||
                     (LdrpInvertedFunctionTable.Overflow != FALSE))) {

                    ModuleListHead = &Peb->Ldr->InLoadOrderModuleList;
                    Next = ModuleListHead->Flink;
                    if (Next != NULL) {
                        while (Next != ModuleListHead) {
                            Entry = CONTAINING_RECORD(Next,
                                                      LDR_DATA_TABLE_ENTRY,
                                                      InLoadOrderLinks);
    
                            Next = Next->Flink;
                            Base = Entry->DllBase;
                            Bound = (ULONG_PTR)Base + Entry->SizeOfImage;
                            if (((ULONG_PTR)ControlPc >= (ULONG_PTR)Base) &&
                                ((ULONG_PTR)ControlPc < Bound)) {
                        
#if defined(_IA64_)
            
                                *Gp = (ULONG64)(RtlImageDirectoryEntryToData(Base,
                                                                             TRUE,
                                                                             IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                                                                             SizeOfTable));

#endif

                                FunctionTable = RtlImageDirectoryEntryToData(Base,
                                                                             TRUE,
                                                                             IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                                             SizeOfTable);
                
                                break;
                            }
                        }
                    }
                }
        
            } else {
        
                //
                // The loaded module list has not been initialized. Therefore,
                // the current executing code must be in ntdll. If ntddl base
                // is not NULL and the control PC is within the ntdll range,
                // then return the information for ntdll.
                //
    
                if (NtDllBase != NULL) {
                    Base = NtDllBase;
                    NtHeaders = RtlImageNtHeader(Base);
                    if (NtHeaders != NULL) {
                        Bound = (ULONG_PTR)Base + NtHeaders->OptionalHeader.SizeOfImage;
                        if (((ULONG_PTR)ControlPc >= (ULONG_PTR)Base) &&
                            ((ULONG_PTR)ControlPc < Bound)) { 
    
#if defined(_IA64_)
            
                            *Gp = (ULONG64)(RtlImageDirectoryEntryToData(Base,
                                                                             TRUE,
                                                                             IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                                                                             SizeOfTable));

#endif

                            FunctionTable = RtlImageDirectoryEntryToData(Base,
                                                                         TRUE,
                                                                         IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                                         SizeOfTable);
                        }
                    }
                }
            }
        }

        //
        // Release the loader lock if it was acquired.
        //

        if (InLdrInit == FALSE) {
            RtlLeaveCriticalSection(&LdrpLoaderLock);
        }
    }

#endif

    //
    // Set the image base address and return the function table address.
    //

    *ImageBase = Base;
    return FunctionTable;
}

VOID
RtlInsertInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ImageBase,
    ULONG SizeOfImage
    )

/*++

Routine Description:

    This function inserts an entry in an inverted function table if there
    is room in the table. Otherwise, no operation is performed.

    N.B. It is assumed that appropriate locks are held when this routine
         is called.

    N.B. If the inverted function table overflows, then it is treated as
         a cache. This is unlikely to happen, however.

Arguments:

    InvertedTable - Supplies a pointer to the inverted function table in
        which the specified entry is to be inserted.

    ImageBase - Supplies the base address of the containing image.

    SizeOfImage - Supplies the size of the image.

Return Value:

    None.

--*/

{

    ULONG CurrentSize;
    PRUNTIME_FUNCTION FunctionTable;

#if defined(_IA64_)

    ULONG64 Gp;

#endif

    ULONG Index;
    ULONG SizeOfTable;

    //
    // If the inverted table is not full, then insert the entry in the
    // specified inverted table.
    //

    CurrentSize = InvertedTable->CurrentSize;
    if (CurrentSize != InvertedTable->MaximumSize) {

        //
        // If the inverted table has no entries, then insert the new entry as
        // the first entry. Otherwise, search the inverted table for the proper
        // insert position, shuffle the table, and insert the new entry.
        //
    
        Index = 0;
        if (CurrentSize != 0) {
            for (Index = 0; Index < CurrentSize; Index += 1) {
                if (ImageBase < InvertedTable->TableEntry[Index].ImageBase) {
                    break;
                }
            }

            //
            // If the new entry does not go at the end of the specified table,
            // then shuffle the table down to make room for the new entry.
            //

            if (Index != CurrentSize) {
                RtlMoveMemory(&InvertedTable->TableEntry[Index + 1],
                              &InvertedTable->TableEntry[Index],
                              (CurrentSize - Index) * sizeof(INVERTED_FUNCTION_TABLE_ENTRY));
            }
        }
    
        //
        // Insert the specified entry in the specified inverted function table.
        //
    
        FunctionTable = RtlImageDirectoryEntryToData (ImageBase,
                                                      TRUE,
                                                      IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                                      &SizeOfTable);

        InvertedTable->TableEntry[Index].FunctionTable = FunctionTable;
        InvertedTable->TableEntry[Index].ImageBase = ImageBase;
        InvertedTable->TableEntry[Index].SizeOfImage = SizeOfImage;
        InvertedTable->TableEntry[Index].SizeOfTable = SizeOfTable;
    
#if defined(_IA64_)
    
        Gp = (ULONG64)RtlImageDirectoryEntryToData (ImageBase,
                                                    TRUE,
                                                    IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
                                                    &SizeOfTable);

        InvertedTable->TableEntry[Index].Gp = Gp;
    
#endif
    
        InvertedTable->CurrentSize += 1;

    } else {
        InvertedTable->Overflow = TRUE;
    }

    return;
}

VOID
RtlRemoveInvertedFunctionTable (
    PINVERTED_FUNCTION_TABLE InvertedTable,
    PVOID ImageBase
    )

/*++

Routine Description:

    This routine removes an entry from an inverted function table.

    N.B. It is assumed that appropriate locks are held when this routine
         is called.

Arguments:

    InvertedTable - Supplies a pointer to the inverted function table from
        which the specified entry is to be removed.

    ImageBase - Supplies the base address of the containing image. 

Return Value:

    None.

--*/

{

    ULONG CurrentSize;
    ULONG Index;

    //
    // Search for an entry in the specified inverted table that matches the
    // image base.
    //
    // N.B. It is possible a matching entry is not in the inverted table
    //      the table was full when an attempt was made to insert the
    //      corresponding entry.
    //

    CurrentSize = InvertedTable->CurrentSize;
    for (Index = 0; Index < CurrentSize; Index += 1) {
        if (ImageBase == InvertedTable->TableEntry[Index].ImageBase) {
            break;
        }
    }

    //
    // If the entry was found in the inverted table, then remove the entry
    // and reduce the size of the table.
    //

    if (Index != CurrentSize) {

        //
        // If the size of the table is not one, then shuffle the table and
        // remove the specified entry.
        //
    
        if (CurrentSize != 1) {
            RtlCopyMemory(&InvertedTable->TableEntry[Index],
                          &InvertedTable->TableEntry[Index + 1],
                          (CurrentSize - Index - 1) * sizeof(INVERTED_FUNCTION_TABLE_ENTRY));
        }
    
        //
        // Reduce the size of the inverted table.
        //
    
        InvertedTable->CurrentSize -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\range.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    range.h

Abstract:

    Kernel-mode range list support for arbiters

Author:

    Andy Thornton (andrewth) 02/17/97

Revision History:

--*/

#ifndef _RANGE_
#define _RANGE_
            
//
// Debugging options
//

#if DBG && !defined(NTOS_KERNEL_RUNTIME)
    #include <stdio.h>
#endif

#undef MAX_ULONGLONG
#define MAX_ULONGLONG   ((ULONGLONG)-1)

#define RTL_RANGE_LIST_ENTRY_TAG    'elRR'
#define RTL_RANGE_LIST_MISC_TAG     'mlRR'

#if DBG
    #define DEBUG_PRINT(Level, Message) \
        if (Level <= RtlRangeDebugLevel) DbgPrint Message
#else
    #define DEBUG_PRINT(Level, Message) 
#endif // DBG
    
//
// Range list structures
//

#define RTLP_RANGE_LIST_ENTRY_MERGED         0x0001

typedef struct _RTLP_RANGE_LIST_ENTRY {

    //
    // Common data
    //
    ULONGLONG Start;
    ULONGLONG End;
  
    union {
        
        //
        // An Allocated range
        //
        struct {
            
            //
            // Data from the user given in AddRange
            //
            PVOID UserData;
            
            //
            // The owner of the range
            //
            PVOID Owner;
        
        } Allocated;

        //
        // A Merged range
        //
        struct {
            
            //
            // List of ranges that overlap between Start and End
            //
            LIST_ENTRY ListHead;
        
        } Merged;
   
    };

    //
    // User defined flags given in AddRange
    //
    UCHAR Attributes;
    
    //
    // Range descriptors
    //
    UCHAR PublicFlags;          // use RANGE_*
    
    //
    // Control information
    //
    USHORT PrivateFlags;        // use RANGE_LIST_ENTRY_*

    //
    // Main linked list entry
    //
    LIST_ENTRY ListEntry;    

} RTLP_RANGE_LIST_ENTRY, *PRTLP_RANGE_LIST_ENTRY;


//
// Useful macros for dealing with range list entries
//

#define MERGED(Entry)   (BOOLEAN)((Entry)->PrivateFlags & RTLP_RANGE_LIST_ENTRY_MERGED)
#define SHARED(Entry)   (BOOLEAN)((Entry)->PublicFlags & RTL_RANGE_SHARED)
#define CONFLICT(Entry) (BOOLEAN)((Entry)->PublicFlags & RTL_RANGE_CONFLICT)

//
// List Traversing Macros
//

#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

#define FOR_ALL_IN_LIST_SAFE(Type, Head, Current, Next)                 \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry),  \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                       Type, ListEntry);                \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = (Next),                                              \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                     Type, ListEntry)                   \
       )


#define FOR_REST_IN_LIST(Type, Head, Current)                           \
    for(;                                                               \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

#define FOR_REST_IN_LIST_SAFE(Type, Head, Current, Next)                \
    for((Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,          \
                                       Type, ListEntry);                \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = (Next),                                              \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                     Type, ListEntry)                   \
       )

//
// Backwards List Traversing Macros
//

#define FOR_ALL_IN_LIST_BACKWARDS(Type, Head, Current)                  \
    for((Current) = CONTAINING_RECORD((Head)->Blink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Blink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

#define FOR_ALL_IN_LIST_SAFE_BACKWARDS(Type, Head, Current, Next)       \
    for((Current) = CONTAINING_RECORD((Head)->Blink, Type, ListEntry),  \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Blink,      \
                                       Type, ListEntry);                \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = (Next),                                              \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Blink,      \
                                     Type, ListEntry)                   \
       )


#define FOR_REST_IN_LIST_BACKWARDS(Type, Head, Current)                 \
    for(;                                                               \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Blink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

#define FOR_REST_IN_LIST_SAFE_BACKWARDS(Type, Head, Current, Next)      \
    for((Next) = CONTAINING_RECORD((Current)->ListEntry.Blink,          \
                                       Type, ListEntry);                \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = (Next),                                              \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Blink,      \
                                     Type, ListEntry)                   \
       )

//
// Misc Macros
//

#define LAST_IN_LIST(ListHead, Entry)                                   \
    ( (Entry)->ListEntry.Flink == ListHead )

#define FIRST_IN_LIST(ListHead, Entry)                                  \
    ( (Entry)->ListEntry.Blink == ListHead )


#define RANGE_DISJOINT(a,b)                                             \
    ( ((a)->Start < (b)->Start && (a)->End < (b)->Start)                \
    ||((b)->Start < (a)->Start && (b)->End < (a)->Start) )

#define RANGE_INTERSECT(a,b)                                            \
    !RANGE_DISJOINT((a),(b))

#define RANGE_LIMITS_DISJOINT(s1,e1,s2,e2)                              \
    ( ((s1) < (s2) && (e1) < (s2))                                      \
    ||((s2) < (s1) && (e2) < (s1)) )

#define RANGE_LIMITS_INTERSECT(s1,e1,s2,e2)                             \
    !RANGE_LIMITS_DISJOINT((s1),(e1),(s2),(e2))

#define RANGE_LIST_ENTRY_FROM_LIST_ENTRY(Entry)                         \
    CONTAINING_RECORD((Entry), RTLP_RANGE_LIST_ENTRY, ListEntry)    

#define RANGE_LIST_FROM_LIST_HEAD(Head)                                 \
    CONTAINING_RECORD((Head), RTL_RANGE_LIST, ListHead)    

#define FOR_REST_OF_RANGES(_Iterator, _Current, _Forward)               \
    for ((_Current) = (PRTL_RANGE)(_Iterator)->Current;                 \
         (_Current) != NULL;                                            \
         RtlGetNextRange((_Iterator), &(_Current), (_Forward))          \
         )

//
//  VOID
//  InsertEntryList(
//      PLIST_ENTRY Previous,
//      PLIST_ENTRY Entry
//      );
//

#define InsertEntryList(Previous, Entry) {                              \
    PLIST_ENTRY _EX_Next = (Previous)->Flink;                           \
    PLIST_ENTRY _EX_Previous = (Previous);                              \
    (Entry)->Flink = _EX_Next;                                          \
    (Entry)->Blink = _EX_Previous;                                      \
    _EX_Next->Blink = (Entry);                                          \
    _EX_Previous->Flink = (Entry);                                      \
    }
    



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\range.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    range.c

Abstract:

    Kernel-mode range list support for arbiters

Author:

    Andy Thornton (andrewth) 02/17/97

Revision History:

--*/

#include "ntrtlp.h"
#include "range.h"

#if DBG

//
// Debug print level:
//    -1 = no messages
//     0 = vital messages only
//     1 = call trace
//     2 = verbose messages
//

LONG RtlRangeDebugLevel = 0;

#endif

NTSTATUS
RtlpAddRange(
    IN OUT PLIST_ENTRY ListHead,
    IN PRTLP_RANGE_LIST_ENTRY Entry,
    IN ULONG AddRangeFlags
    );

NTSTATUS
RtlpAddToMergedRange(
    IN PRTLP_RANGE_LIST_ENTRY Merged,
    IN PRTLP_RANGE_LIST_ENTRY Entry,
    IN ULONG AddRangeFlags
    );

NTSTATUS
RtlpConvertToMergedRange(
    IN PRTLP_RANGE_LIST_ENTRY Entry
    );

PRTLP_RANGE_LIST_ENTRY
RtlpCreateRangeListEntry(
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN PVOID UserData,
    IN PVOID Owner
    );

NTSTATUS
RtlpAddIntersectingRanges(
    IN PLIST_ENTRY ListHead,
    IN PRTLP_RANGE_LIST_ENTRY First,
    IN PRTLP_RANGE_LIST_ENTRY Entry,
    IN ULONG AddRangeFlags
    );

NTSTATUS
RtlpDeleteFromMergedRange(
    IN PRTLP_RANGE_LIST_ENTRY Delete,
    IN PRTLP_RANGE_LIST_ENTRY Merged
    );

PRTLP_RANGE_LIST_ENTRY
RtlpCopyRangeListEntry(
    PRTLP_RANGE_LIST_ENTRY Entry
    );

VOID
RtlpDeleteRangeListEntry(
    IN PRTLP_RANGE_LIST_ENTRY Entry
    );

BOOLEAN
RtlpIsRangeAvailable(
    IN PRTL_RANGE_LIST_ITERATOR Iterator,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR AttributeAvailableMask,
    IN BOOLEAN SharedOK,
    IN BOOLEAN NullConflictOK,
    IN BOOLEAN Forward,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL
    );

#if DBG

VOID
RtlpDumpRangeListEntry(
    LONG Level,
    PRTLP_RANGE_LIST_ENTRY Entry,
    BOOLEAN Indent
    );

VOID
RtlpDumpRangeList(
    LONG Level,
    PRTL_RANGE_LIST RangeList
    );

#else

#define RtlpDumpRangeListEntry(Level, Entry, Indent)
#define RtlpDumpRangeList(Level, RangeList)

#endif // DBG

//
// Make everything pageable or init
//

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

#pragma alloc_text(INIT, RtlInitializeRangeListPackage)

#pragma alloc_text(PAGE, RtlpAddRange)
#pragma alloc_text(PAGE, RtlpAddToMergedRange)
#pragma alloc_text(PAGE, RtlpConvertToMergedRange)
#pragma alloc_text(PAGE, RtlpCreateRangeListEntry)
#pragma alloc_text(PAGE, RtlpAddIntersectingRanges)
#pragma alloc_text(PAGE, RtlpDeleteFromMergedRange)
#pragma alloc_text(PAGE, RtlpCopyRangeListEntry)
#pragma alloc_text(PAGE, RtlpDeleteRangeListEntry)
#pragma alloc_text(PAGE, RtlpIsRangeAvailable)

#if DBG
#pragma alloc_text(PAGE, RtlpDumpRangeListEntry)
#pragma alloc_text(PAGE, RtlpDumpRangeList)
#endif

#pragma alloc_text(PAGE, RtlInitializeRangeList)
#pragma alloc_text(PAGE, RtlAddRange)
#pragma alloc_text(PAGE, RtlDeleteRange)
#pragma alloc_text(PAGE, RtlDeleteOwnersRanges)
#pragma alloc_text(PAGE, RtlCopyRangeList)
#pragma alloc_text(PAGE, RtlFreeRangeList)
#pragma alloc_text(PAGE, RtlIsRangeAvailable)
#pragma alloc_text(PAGE, RtlFindRange)
#pragma alloc_text(PAGE, RtlGetFirstRange)
#pragma alloc_text(PAGE, RtlGetLastRange)
#pragma alloc_text(PAGE, RtlGetNextRange)
#pragma alloc_text(PAGE, RtlMergeRangeLists)
#pragma alloc_text(PAGE, RtlInvertRangeList)

#endif // ALLOC_PRAGMA

//
// Range List memory allocation
//

#if defined(NTOS_KERNEL_RUNTIME)

//
// The kernel mode range list API uses a lookaside list to speed allocation
// of range list entries.  The PAGED_LOOKASIDE_LIST structure should be non-paged.
//

#define RTLP_RANGE_LIST_ENTRY_LOOKASIDE_DEPTH   16

PAGED_LOOKASIDE_LIST RtlpRangeListEntryLookasideList;

VOID
RtlInitializeRangeListPackage(
    VOID
    )
/*++

Routine Description:

    This routine initializes the stuctures required by the range list
    APIs.  It is called during system initialization (Phase1Initialization)
    and should be before any of the range list apis are called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ExInitializePagedLookasideList(
        &RtlpRangeListEntryLookasideList,
        NULL,
        NULL,
        POOL_COLD_ALLOCATION,
        sizeof(RTLP_RANGE_LIST_ENTRY),
        RTL_RANGE_LIST_ENTRY_TAG,
        RTLP_RANGE_LIST_ENTRY_LOOKASIDE_DEPTH
        );

}

//
// PRANGE_LIST_ENTRY
// RtlpAllocateRangeListEntry(
//     VOID
//     )
//
#define RtlpAllocateRangeListEntry()                                    \
    (PRTLP_RANGE_LIST_ENTRY) ExAllocateFromPagedLookasideList(          \
        &RtlpRangeListEntryLookasideList                                \
        )

//
// VOID
// RtlpFreeRangeListEntry(
//     IN PRTLP_RANGE_LIST_ENTRY Entry
//     )
//
#define RtlpFreeRangeListEntry(Entry)                                   \
    ExFreeToPagedLookasideList(&RtlpRangeListEntryLookasideList, (Entry))


//
// PVOID
// RtlpRangeListAllocatePool(
//     IN ULONG Size
//     )
//
#define RtlpRangeListAllocatePool(Size)                                 \
    ExAllocatePoolWithTag(PagedPool, (Size), RTL_RANGE_LIST_MISC_TAG)

//
// VOID
// RtlpRangeListFreePool(
//     IN PVOID Free
//     )
//
#define RtlpRangeListFreePool(Free)                                     \
    ExFreePool(Free)


#else // defined(NTOS_KERNEL_RUNTIME)


//
// Usermode range lists use the standard Rtl heap for allocations
//

//
// PRANGE_LIST_ENTRY
// RtlpAllocateRangeListEntry(
//     VOID
//     );
//
#define RtlpAllocateRangeListEntry()                                    \
    (PRTLP_RANGE_LIST_ENTRY) RtlAllocateHeap(                           \
        RtlProcessHeap(),                                               \
        RTL_RANGE_LIST_ENTRY_TAG,                                       \
        sizeof(RTLP_RANGE_LIST_ENTRY)                                   \
        )

//
// VOID
// RtlpFreeRangeListEntry(
//     IN PRTLP_RANGE_LIST_ENTRY Entry
//     )
//
#define RtlpFreeRangeListEntry(Entry)                                   \
    RtlFreeHeap( RtlProcessHeap(), 0, (Entry) )

//
// PVOID
// RtlpRangeListAllocatePool(
//     IN ULONG Size
//     )
//
#define RtlpRangeListAllocatePool(Size)                                 \
    RtlAllocateHeap(RtlProcessHeap(), RTL_RANGE_LIST_MISC_TAG, (Size))

//
// VOID
// RtlpRangeListFreePool(
//     IN PVOID Free
//     )
//
#define RtlpRangeListFreePool(Free)                                     \
    RtlFreeHeap( RtlProcessHeap(), 0, (Free) )


#endif // defined(NTOS_KERNEL_RUNTIME)

VOID
RtlInitializeRangeList(
    IN OUT PRTL_RANGE_LIST RangeList
    )
/*++

Routine Description:

    This routine initializes a range list.  It must be called before the range
    list is passed to any of the other range list functions.  Initially the
    range list contains no ranges

Arguments:

    RangeList - Pointer to a user allocated RTL_RANGE_LIST structre to be
        initialized.

Return Value:

    None.

--*/
{
    RTL_PAGED_CODE();

    ASSERT(RangeList);

    DEBUG_PRINT(1, ("RtlInitializeRangeList(0x%08x)\n", RangeList));

    InitializeListHead(&RangeList->ListHead);
    RangeList->Flags = 0;
    RangeList->Count = 0;
    RangeList->Stamp = 0;
}

NTSTATUS
RtlAddRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN ULONG Flags,
    IN PVOID UserData, OPTIONAL
    IN PVOID Owner     OPTIONAL
    )
/*++

Routine Description:

    This routine adds a new range with the specified properties to a range list.

Arguments:

    RangeList - Pointer to the range list to which the new range is to be added.
        It must have been previously initialized using RtlInitializeRangeList.

    Start - The location of the start of the new range.

    End - The location of the end of the new range.

    Flags - These determine the range's properties and how it is added:

        RTL_RANGE_LIST_ADD_IF_CONFLICT - The range should be added even if it
            overlaps another range.  In this case the RTL_RANGE_CONFLICT flag
            is set.

        RTL_RANGE_LIST_ADD_SHARED - The range is marked as an RTL_RANGE_SHARED
            and will successfully be added if it overlaps another shared range.
            It can be speficied in conjunction with the above ADD_IF_CONFLICT
            flag in which case if the range overlaps a non-shared range it will
            be marked as both RTL_RANGE_SHARED and RTL_RANGE_CONFLICT.

    UserData - Extra data to be stored with the range.  The system will not
        attempt to interpret it.

    Owner - A cookie that represents the entity that owns this range.  (A
        pointer to some object is the most likley).  The system will not
        attempt to interpret it, just use it to distinguish the range from
        another with the same start and end.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INVALID_PARAMETER
    STATUS_RANGE_LIST_CONFLICT
    STATUS_INSUFFICIENT_RESOURCES

--*/
{

    NTSTATUS status;
    PRTLP_RANGE_LIST_ENTRY newEntry = NULL;

    RTL_PAGED_CODE();

    DEBUG_PRINT(1,
        ("RtlAddRange(0x%08x, 0x%I64x, 0x%I64x, 0x%08x, 0x%08x, 0x%08x)\n",
        RangeList,
        Start,
        End,
        Flags,
        UserData,
        Owner
        ));

    //
    // Validate parameters
    //

    if (End < Start) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create a new entry
    //

    if (!(newEntry = RtlpCreateRangeListEntry(Start, End, Attributes, UserData, Owner))) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Mark the new entry as shared if appropriate
    //

    if (Flags & RTL_RANGE_LIST_ADD_SHARED) {
        newEntry->PublicFlags |= RTL_RANGE_SHARED;
    }

    status = RtlpAddRange(&RangeList->ListHead,
                        newEntry,
                        Flags
                        );

    if (NT_SUCCESS(status)) {

        //
        // We added a range so bump the count
        //
        RangeList->Count++;
        RangeList->Stamp++;

    } else {

        //
        // We didn't add a range so free up the entry
        //

        RtlpFreeRangeListEntry(newEntry);
    }

    return status;

}

NTSTATUS
RtlpAddRange(
    IN OUT PLIST_ENTRY ListHead,
    IN PRTLP_RANGE_LIST_ENTRY Entry,
    IN ULONG AddRangeFlags
    )
/*++

Routine Description:

    This routine implement the AddRange operation adding the range in the
    appropriate place in the sorted range list, converting ranges to merged
    ranges and setting RTL_RANGE_CONFLICT flags as necessary.

Arguments:

    ListHead - The list of the range list to which the range should be added.

    Entry - The new entry to be added to the range list

    AddRangeFlags - The Flags argument to RtlAddRange, see above.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_RANGE_LIST_CONFLICT
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PRTLP_RANGE_LIST_ENTRY previous, current;
    ULONGLONG start, end;

    DEBUG_PRINT(2,
                ("RtlpAddRange(0x%08x, 0x%08x{0x%I64x-0x%I64x}, 0x%08x)\n",
                ListHead,
                Entry,
                Entry->Start,
                Entry->End,
                AddRangeFlags
                ));

    RTL_PAGED_CODE();
    ASSERT(Entry);

    start = Entry->Start;
    end = Entry->End;

    //
    // Clear the conflict flag if it was left around
    //

    Entry->PublicFlags &= ~RTL_RANGE_CONFLICT;

    //
    // Iterate through the list and find where to insert the entry
    //

    FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY, ListHead, current) {

        if (end < current->Start) {

            //
            // The new range is completely before this one
            //

            DEBUG_PRINT(2, ("Completely before\n"));

            InsertEntryList(current->ListEntry.Blink,
                            &Entry->ListEntry
                            );

            goto exit;

        } else if (RANGE_INTERSECT(Entry, current)) {

            status = RtlpAddIntersectingRanges(ListHead,
                       current,
                       Entry,
                       AddRangeFlags);

            goto exit;

        }
    }

    //
    // New range is after all existing ranges
    //

    DEBUG_PRINT(2, ("After all existing ranges\n"));

    InsertTailList(ListHead,
                   &Entry->ListEntry
                  );

exit:

    return status;

}

NTSTATUS
RtlpAddToMergedRange(
    IN PRTLP_RANGE_LIST_ENTRY Merged,
    IN PRTLP_RANGE_LIST_ENTRY Entry,
    IN ULONG AddRangeFlags
    )
/*++

Routine Description:

    This routine adds a new range to a merged range, setting the
    RTL_RANGE_CONFLICT flags if necessary.

Arguments:

    Merged - The merged range to which Entry should be added.

    Entry - The new entry to be added to the range list

    AddRangeFlags - The Flags argument to RtlAddRange, see above.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_RANGE_LIST_CONFLICT - indictates that the range was not added because
        it conflicted with another range and conflicts are not allowed

--*/
{
    PRTLP_RANGE_LIST_ENTRY current;
    PLIST_ENTRY insert = NULL;
    BOOLEAN entryShared;

    RTL_PAGED_CODE();
    ASSERT(Merged);
    ASSERT(Entry);
    ASSERT(MERGED(Merged));

    entryShared = SHARED(Entry);

    //
    // Insert it into the merged list, this is sorted in order of start
    //

    FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY, &Merged->Merged.ListHead, current) {

        //
        // Do we conflict?
        //

        if (RANGE_INTERSECT(current, Entry)
        && !(entryShared && SHARED(current))) {

            //
            // Are conflicts ok?
            //

            if (AddRangeFlags & RTL_RANGE_LIST_ADD_IF_CONFLICT) {

                //
                // Yes - Mark both entries as conflicting
                //

                current->PublicFlags |= RTL_RANGE_CONFLICT;
                Entry->PublicFlags |= RTL_RANGE_CONFLICT;

            } else {

                //
                // No - Fail
                //

                return STATUS_RANGE_LIST_CONFLICT;

            }
        }

        //
        // Have we not yet found the insertion point and just passed it?
        //

        if (!insert && current->Start > Entry->Start) {

            //
            // Insert is before current
            //

            insert = current->ListEntry.Blink;
        }
    }

    //
    // Did we find where to insert the new range?
    //

    if (!insert) {

        //
        // New range is after all existing ranges
        //

        InsertTailList(&Merged->Merged.ListHead,
                       &Entry->ListEntry
                      );

    } else {

        //
        // Insert in the list
        //

        InsertEntryList(insert,
                        &Entry->ListEntry
                        );
    }


    //
    // Expand the merged range if necessary
    //

    if (Entry->Start < Merged->Start) {
        Merged->Start = Entry->Start;
    }

    if (Entry->End > Merged->End) {
        Merged->End = Entry->End;
    }

    //
    // If we just added a shared range to a completely shared merged
    // range then the shared flag can stay otherwise it must go
    //

    if (SHARED(Merged) && !entryShared) {

        DEBUG_PRINT(2,
            ("RtlpAddToMergedRange: Merged range no longer completely shared\n"));

        Merged->PublicFlags &= ~RTL_RANGE_SHARED;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlpConvertToMergedRange(
    IN PRTLP_RANGE_LIST_ENTRY Entry
    )
/*++

Routine Description:

    This converts a non-merged range into a merged range with one member, the
    range that was just converted.

Arguments:

    Entry - The entry to be converted into a merged range.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PRTLP_RANGE_LIST_ENTRY newEntry;

    RTL_PAGED_CODE();
    ASSERT(Entry);
    ASSERT(!MERGED(Entry));
    ASSERT(!CONFLICT(Entry));

    //
    // Create a new entry
    //

    if (!(newEntry = RtlpCopyRangeListEntry(Entry))) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Convert the current entry into a merged one NB. Throw away all the
    // private flags but leave the public ones as they can only be shared.
    //

    InitializeListHead(&Entry->Merged.ListHead);
    Entry->PrivateFlags = RTLP_RANGE_LIST_ENTRY_MERGED;

    ASSERT(Entry->PublicFlags == RTL_RANGE_SHARED || Entry->PublicFlags == 0);

    //
    // Add the range
    //

    InsertHeadList(&Entry->Merged.ListHead,
                   &newEntry->ListEntry
                   );


    return STATUS_SUCCESS;
}

PRTLP_RANGE_LIST_ENTRY
RtlpCreateRangeListEntry(
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR Attributes,
    IN PVOID UserData,
    IN PVOID Owner
    )
/*++

Routine Description:

    This routine allocates a new range list entry and fills it in the the data
    provided.

Arguments:

    Start - The location of the start of the new range.

    End - The location of the end of the new range.

    Attributes - Extra data (normally flags) to be stored with the range. The
        system will not attempt to interpret it.

    UserData - Extra data to be stored with the range.  The system will not
        attempt to interpret it.

    Owner - A cookie that represents the entity that owns this range.  (A
        pointer to some object is the most likley).  The system will not
        attempt to interpret it, just use it to distinguish the range from
        another with the same start and end.

Return Value:

    Pointer to the new range list entry or NULL if a new entry could not be
    allocated.

--*/
{
    PRTLP_RANGE_LIST_ENTRY entry;

    RTL_PAGED_CODE();
    ASSERT(Start <= End);

    //
    // Allocate a new entry
    //

    if (entry = RtlpAllocateRangeListEntry()) {

        //
        // Fill in the details
        //

#if DBG
        entry->ListEntry.Flink = NULL;
        entry->ListEntry.Blink = NULL;
#endif

        entry->PublicFlags = 0;
        entry->PrivateFlags = 0;
        entry->Start = Start;
        entry->End = End;
        entry->Allocated.UserData = UserData;
        entry->Allocated.Owner = Owner;
        entry->Attributes = Attributes;
    }

    return entry;

}

NTSTATUS
RtlpAddIntersectingRanges(
    IN PLIST_ENTRY ListHead,
    IN PRTLP_RANGE_LIST_ENTRY First,
    IN PRTLP_RANGE_LIST_ENTRY Entry,
    IN ULONG AddRangeFlags
    )
/*++

Routine Description:

    This routine adds a range to a range list when the new range overlaps
    an existing range.  Ranges are converted to mergedranges and the
    RTL_RANGE_CONFLICT flag is set as necessary.

Arguments:

    ListHead - The list of the range list to which the range should be added.

    First - The first range that intersects

    Entry - The new range to be added

    AddRangeFlags - The Flags argument to RtlAddRange, see above.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_RANGE_LIST_CONFLICT

--*/
{
    NTSTATUS status;
    PRTLP_RANGE_LIST_ENTRY current, next, currentMerged, nextMerged;
    BOOLEAN entryShared;

    RTL_PAGED_CODE();
    ASSERT(First);
    ASSERT(Entry);

    entryShared = SHARED(Entry);

    //
    // If we care about conflicts see if we conflict with anyone
    //

    if (!(AddRangeFlags & RTL_RANGE_LIST_ADD_IF_CONFLICT)) {

        //
        // Examine all ranges after the first intersecting one
        //

        current = First;
        FOR_REST_IN_LIST(RTLP_RANGE_LIST_ENTRY, ListHead, current) {

            if (Entry->End < current->Start) {

                //
                // We don't intersect anymore so there arn't any more
                // conflicts
                //

                break;

            } else if (MERGED(current)) {

                //
                // Check if any of the merged ranges conflict
                //

                FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY,
                                &current->Merged.ListHead,
                                currentMerged) {

                    //
                    // Do we conflict?
                    //

                    if (RANGE_INTERSECT(currentMerged, Entry)
                    && !(entryShared && SHARED(currentMerged))) {

                        //
                        // We conflict with one of the merged ranges
                        //

                        return STATUS_RANGE_LIST_CONFLICT;

                    }
                }

            } else if (!(entryShared && SHARED(current))) {

                //
                // We conflict with a non shared region in the  main list.
                //

                return STATUS_RANGE_LIST_CONFLICT;
            }
        }
    }

    //
    // Ok - either we didn't find any conflicts or we don't care about
    // them.  Now its safe to perform the merge.   Make the first
    // overlapping range into a header if it is not already one and then
    // add the rest of the ranges
    //

    if (!MERGED(First)) {

        status = RtlpConvertToMergedRange(First);

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }

    ASSERT(MERGED(First));

    current = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(First->ListEntry.Flink);

    //
    // Consider the entries between the one following first and the last
    // intersecting one.
    //

    FOR_REST_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY, ListHead, current, next) {

         if (Entry->End < current->Start) {

            //
            // We don't intersect any more
            //

            break;
         }

        if (MERGED(current)) {

            //
            // Add all the merged ranges to the new entry
            //

            FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                                 &current->Merged.ListHead,
                                 currentMerged,
                                 nextMerged) {

                //
                // Remove the entry from the current list
                //

                RemoveEntryList(&currentMerged->ListEntry);

                //
                // Add the entry to the new merged range
                //

                status = RtlpAddToMergedRange(First,
                                            currentMerged,
                                            AddRangeFlags
                                            );

                //
                // We should not be able to fail the add but just to be
                // on the safe side...
                //

                ASSERT(NT_SUCCESS(status));

            }

            //
            // Remove and free the now empty header
            //

            ASSERT(IsListEmpty(&current->Merged.ListHead));

            RemoveEntryList(&current->ListEntry);
            RtlpFreeRangeListEntry(current);

        } else {

            //
            // Remove the entry from the main list
            //

            RemoveEntryList(&current->ListEntry);

            //
            // Add the entry to the new merged range
            //

            status = RtlpAddToMergedRange(First,
                                        current,
                                        AddRangeFlags
                                        );

            //
            // We should not be able to fail the add but just to be
            // on the safe side...
            //

            ASSERT(NT_SUCCESS(status));

        }
    }

    //
    // Finally add the entry that did the overlapping
    //

    status = RtlpAddToMergedRange(First,
                                Entry,
                                AddRangeFlags
                                );

    ASSERT(NT_SUCCESS(status));

cleanup:

    return status;

}

NTSTATUS
RtlDeleteRange(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN PVOID Owner
    )
/*++

Routine Description:

    This routine deletes a range from a range list.

Arguments:

    Start - The location of the start of the range to be deleted.

    End - The location of the end of the range to be deleted.

    Owner -  The owner of the range to be deleted, used to distinguish the
    range from another with the same start and end.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_RANGE_LIST_CONFLICT

--*/
{
    NTSTATUS status = STATUS_RANGE_NOT_FOUND;
    PRTLP_RANGE_LIST_ENTRY current, next, currentMerged, nextMerged;

    RTL_PAGED_CODE();
    ASSERT(RangeList);

    DEBUG_PRINT(1,
        ("RtlDeleteRange(0x%08x, 0x%I64x, 0x%I64x, 0x%08x)\n",
        RangeList,
        Start,
        End,
        Owner
        ));


    FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                         &RangeList->ListHead,
                         current,
                         next) {

        //
        // We're passed all possible intersections
        //

        if (End < current->Start) {

            //
            // We didn't find a match
            //

            break;
        }

        if (MERGED(current)) {

            //
            // COuld our range exist in this merged range?
            //

            if (Start >= current->Start && End <= current->End) {

                FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                                     &current->Merged.ListHead,
                                     currentMerged,
                                     nextMerged) {

                    if (currentMerged->Start == Start
                    && currentMerged->End == End
                    && currentMerged->Allocated.Owner == Owner) {

                        //
                        // This is the range - delete it and rebuild the merged
                        // range appropriately
                        //

                        status = RtlpDeleteFromMergedRange(currentMerged,
                                                         current
                                                         );
                        goto exit;
                    }

                }
            }

        } else if (current->Start == Start
               && current->End == End
               && current->Allocated.Owner == Owner) {

            //
            // This is the range - delete it!
            //

            RemoveEntryList(&current->ListEntry);
            RtlpFreeRangeListEntry(current);
            status = STATUS_SUCCESS;
            goto exit;
        }
    }

exit:

    if (NT_SUCCESS(status)) {

        //
        // We have removed a range so decrement the count in the header
        //

        RangeList->Count--;
        RangeList->Stamp++;

    }

    return status;
}

NTSTATUS
RtlDeleteOwnersRanges(
    IN OUT PRTL_RANGE_LIST RangeList,
    IN PVOID Owner
    )
/*++

Routine Description:

    This routine deletes all the ranges owned by a specific owner from a range
    list.

Arguments:

    Owner -  The owner of the ranges to be deleted.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PRTLP_RANGE_LIST_ENTRY current, next, currentMerged, nextMerged;

    RTL_PAGED_CODE();
    ASSERT(RangeList);

    DEBUG_PRINT(1,
                ("RtlDeleteOwnersRanges(0x%08x, 0x%08x)\n",
                RangeList,
                Owner
                ));

findNext:

    FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                         &RangeList->ListHead,
                         current,
                         next) {

        if (MERGED(current)) {

            FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                                 &current->Merged.ListHead,
                                 currentMerged,
                                 nextMerged) {

                if (currentMerged->Allocated.Owner == Owner) {

                    //
                    // This is the range - delete it and rebuild the merged
                    // range appropriately
                    //

                    DEBUG_PRINT(2,
                        ("RtlDeleteOwnersRanges: Deleting merged range \
                            (Start=%I64x, End=%I64x)\n",
                        currentMerged->Start,
                        currentMerged->End
                        ));

                    status = RtlpDeleteFromMergedRange(currentMerged,
                                                     current
                                                     );
                    if (!NT_SUCCESS(status)) {
                        goto cleanup;
                    }

                    RangeList->Count--;
                    RangeList->Stamp++;

                    //
                    // Can't keep scanning the list as it might have changed
                    // underneath us - start from the beginning again...
                    // (We could keep a last safe position to go from...)
                    //
                    goto findNext;

                }
            }

        } else if (current->Allocated.Owner == Owner) {

            //
            // This is the range - delete it!
            //

            RemoveEntryList(&current->ListEntry);
            RtlpFreeRangeListEntry(current);

            DEBUG_PRINT(2,
                ("RtlDeleteOwnersRanges: Deleting range (Start=%I64x,End=%I64x)\n",
                current->Start,
                current->End
                ));

            RangeList->Count--;
            RangeList->Stamp++;

            status = STATUS_SUCCESS;

        }
    }

cleanup:

    return status;

}

NTSTATUS
RtlpDeleteFromMergedRange(
    IN PRTLP_RANGE_LIST_ENTRY Delete,
    IN PRTLP_RANGE_LIST_ENTRY Merged
    )
/*++

Routine Description:

    This routine deletes a range from a merged range and rebuilds the merged
    range as appropriate.  This includes adding new merged and unmerged ranges.
    If no ranges are left in the merged range it will be deleted.

Arguments:
    
    Delete - Range list entry to delete
    
    Merged - Merged range that contains it

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PRTLP_RANGE_LIST_ENTRY current, next;
    LIST_ENTRY keepList;
    PLIST_ENTRY previousInsert, nextInsert;

    RTL_PAGED_CODE();
    ASSERT(MERGED(Merged));

    //
    // Remove the entry
    //

    RemoveEntryList(&Delete->ListEntry);

    //
    // Initialize the temporary list where the new list will be build
    //

    InitializeListHead(&keepList);

    //
    // Add the previously merged ranges into the keep list and put
    // any duplicates of the delete range into the delete list
    //

    FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                         &Merged->Merged.ListHead,
                         current,
                         next) {

        //
        // Add it to the keepList.  Explicitly remove the entries from the
        // list so it is still valid if we need to rebuild it.
        //

        RemoveEntryList(&current->ListEntry);

        //
        // Clear the conflict flag - if there is still a conflict RtlpAddRange
        // should set it again.
        //

        current->PublicFlags &= ~RTL_RANGE_CONFLICT;

        status = RtlpAddRange(&keepList,
                              current,
                              RTL_RANGE_LIST_ADD_IF_CONFLICT
                             );

        if (!NT_SUCCESS(status)) {
            //
            // This should only happen if we run out of pool
            //
            goto cleanup;
        }
    }

    if (!IsListEmpty(&keepList)) {

        //
        // Everything went well so splice this temporary list into the
        // main list where Merged used to be
        //

        previousInsert = Merged->ListEntry.Blink;
        nextInsert = Merged->ListEntry.Flink;

        previousInsert->Flink = keepList.Flink;
        keepList.Flink->Blink = previousInsert;

        nextInsert->Blink = keepList.Blink;
        keepList.Blink->Flink = nextInsert;

    } else {

        RemoveEntryList(&Merged->ListEntry);

    }

    //
    // Finally free the range we deleted and the merged range we have orphaned
    //

    RtlpFreeRangeListEntry(Delete);
    RtlpFreeRangeListEntry(Merged);

    return status;

cleanup:

    //
    // Things went wrong - should only be a STATUS_INSUFFICIENT_RESOURCES
    // Reconstruct the list as it was before the call using the keepList and
    // deleteList.
    //

    ASSERT(status == STATUS_INSUFFICIENT_RESOURCES);

    //
    // Add all the ranges we moved to the keepList back into Merged
    //

    FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY, &keepList, current, next) {

        status = RtlpAddToMergedRange(Merged,
                                    current,
                                    RTL_RANGE_LIST_ADD_IF_CONFLICT
                                    );

        ASSERT(NT_SUCCESS(status));
    }

    //
    // And the one were meant to delete
    //

    status = RtlpAddToMergedRange(Merged,
                                  Delete,
                                  RTL_RANGE_LIST_ADD_IF_CONFLICT
                                 );

    return status;
}

PRTLP_RANGE_LIST_ENTRY
RtlpCopyRangeListEntry(
    PRTLP_RANGE_LIST_ENTRY Entry
    )
/*++

Routine Description:

    This routine copies a range list entry.  If the entry is merged all the
    member ranges are copied too.

Arguments:

    Entry - the range list entry to be copied.

Return Value:

    Pointer to the new range list entry or NULL if a new entry could not be
    allocated.

--*/
{
    PRTLP_RANGE_LIST_ENTRY newEntry;

    RTL_PAGED_CODE();
    ASSERT(Entry);

    if (newEntry = RtlpAllocateRangeListEntry()) {

        RtlCopyMemory(newEntry, Entry, sizeof(RTLP_RANGE_LIST_ENTRY));

#if DBG
        newEntry->ListEntry.Flink = NULL;
        newEntry->ListEntry.Blink = NULL;
#endif

        if (MERGED(Entry)) {

            //
            // Copy the merged list
            //

            PRTLP_RANGE_LIST_ENTRY current, newMerged;

            InitializeListHead(&newEntry->Merged.ListHead);

            FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY,
                            &Entry->Merged.ListHead,
                            current) {

                //
                // Allocate a new entry and copy the contents
                //

                newMerged = RtlpAllocateRangeListEntry();

                if (!newMerged) {
                    goto cleanup;
                }

                RtlCopyMemory(newMerged, current, sizeof(RTLP_RANGE_LIST_ENTRY));

                //
                // Insert the new entry
                //

                InsertTailList(&newEntry->Merged.ListHead, &newMerged->ListEntry);
            }
        }
    }

    return newEntry;

cleanup:

    //
    // Free the partially build copy
    //

    RtlpDeleteRangeListEntry(newEntry);

    return NULL;

}

NTSTATUS
RtlCopyRangeList(
    OUT PRTL_RANGE_LIST CopyRangeList,
    IN PRTL_RANGE_LIST RangeList
    )
/*++

Routine Description:

    This routine copies a range list.

Arguments:

    CopyRangeList - An initialized but empty range list where RangeList should
        be copied to.

    RangeList - The range list that is to be copied.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_INVALID_PARAMETER

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PRTLP_RANGE_LIST_ENTRY current, newEntry, currentMerged, newMerged;

    RTL_PAGED_CODE();
    ASSERT(RangeList);
    ASSERT(CopyRangeList);


    DEBUG_PRINT(1,
                ("RtlCopyRangeList(0x%08x, 0x%08x)\n",
                CopyRangeList,
                RangeList
                ));

    //
    // Sanity checks...
    //

    if (CopyRangeList->Count != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy the header information
    //

    CopyRangeList->Flags = RangeList->Flags;
    CopyRangeList->Count = RangeList->Count;
    CopyRangeList->Stamp = RangeList->Stamp;

    //
    // Perform the copy
    //

    FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY, &RangeList->ListHead, current) {

        //
        // Copy the current entry
        //

        newEntry = RtlpCopyRangeListEntry(current);

        if (!newEntry) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // Add it into the list
        //

        InsertTailList(&CopyRangeList->ListHead, &newEntry->ListEntry);
    }

    return status;

cleanup:

    //
    // Free up the partially complete range list
    //

    RtlFreeRangeList(CopyRangeList);
    return status;

}

VOID
RtlpDeleteRangeListEntry(
    IN PRTLP_RANGE_LIST_ENTRY Entry
    )
/*++

Routine Description:

    This routine deletes a range list entry - if the entry is merged then all
    the member ranges will be deleted as well.  The entry will not be removed
    from any list before deletion - this should be done before calling this
    routine.

Arguments:

    Entry - The entry to be deleted.

Return Value:

    None

--*/

{
    RTL_PAGED_CODE();

    if (MERGED(Entry)) {

        PRTLP_RANGE_LIST_ENTRY current, next;

        //
        // Free all member ranges first
        //

        FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                             &Entry->Merged.ListHead,
                             current,
                             next) {

            RtlpFreeRangeListEntry(current);
        }
    }

    RtlpFreeRangeListEntry(Entry);
}

VOID
RtlFreeRangeList(
    IN PRTL_RANGE_LIST RangeList
    )
/*++

Routine Description:

    This routine deletes all the ranges in a range list.

Arguments:

    RangeList - the range list to operate on.

Return Value:

    None

--*/
{

    PRTLP_RANGE_LIST_ENTRY current, next;

    //
    // Sanity checks...
    //

    RTL_PAGED_CODE();
    ASSERT(RangeList);

    //
    // Clean up the header information
    //

    RangeList->Flags = 0;
    RangeList->Count = 0;

    FOR_ALL_IN_LIST_SAFE(RTLP_RANGE_LIST_ENTRY,
                         &RangeList->ListHead,
                         current,
                         next) {

        //
        // Delete the current entry
        //

        RemoveEntryList(&current->ListEntry);
        RtlpDeleteRangeListEntry(current);
    }
}

NTSTATUS
RtlIsRangeAvailable(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PBOOLEAN Available
    )
/*++

Routine Description:

    This routine determines if a given range is available.

Arguments:

    RangeList - The range list to test availability on.

    Start - The start of the range to test for availability.

    End - The end of the range to test for availability.

    Flags - Modify the behaviour of the routine.

        RTL_RANGE_LIST_SHARED_OK - indicates that shared ranges should be
            considered to be available.

    AttributeAvailableMask - Any range encountered with any of these bits set will be
        consideredto be available.

    Available -  Pointer to a boolean which will be set to TRUE if the range
        is available, otherwise FALSE;

Return Value:

    Status code that indicates whether or not the function was successful:

--*/
{
    NTSTATUS status;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE dummy;

    RTL_PAGED_CODE();

    ASSERT(RangeList);
    ASSERT(Available);

    DEBUG_PRINT(1,
        ("RtlIsRangeAvailable(0x%08x, 0x%I64x, 0x%I64x, 0x%08x, 0x%08x)\n",
        RangeList,
        Start,
        End,
        Flags,
        Available
        ));

    //
    // Initialize iterator to the start of the list
    //
    status = RtlGetFirstRange(RangeList, &iterator, &dummy);


    if (status == STATUS_NO_MORE_ENTRIES) {
        //
        // The range list is empty therefore the range is available
        //

        *Available = TRUE;
        return STATUS_SUCCESS;

    } else if (!NT_SUCCESS(status)) {

        return status;

    }

    *Available = RtlpIsRangeAvailable(&iterator,
                                      Start,
                                      End,
                                      AttributeAvailableMask,
                                      (BOOLEAN)(Flags & RTL_RANGE_LIST_SHARED_OK),
                                      (BOOLEAN)(Flags & RTL_RANGE_LIST_NULL_CONFLICT_OK),
                                      TRUE,
                                      Context,
                                      Callback
                                      );

    return STATUS_SUCCESS;

}

BOOLEAN
RtlpIsRangeAvailable(
    IN PRTL_RANGE_LIST_ITERATOR Iterator,
    IN ULONGLONG Start,
    IN ULONGLONG End,
    IN UCHAR AttributeAvailableMask,
    IN BOOLEAN SharedOK,
    IN BOOLEAN NullConflictOK,
    IN BOOLEAN Forward,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL
    )
/*++

Routine Description:

    This routine determines if a given range is available.

Arguments:

    Iterator - An iterator set to the first range to test in the range list.

    Start - The start of the range to test for availability.

    End - The end of the range to test for availability.

    AttributeAvailableMask - Any range encountered with any of these bits set will be
        considered to be available.

    SharedOK - Indicated whether or not shared ranges are considered to be
        available.

Return Value:

    TRUE if the range is available, FALSE otherwise.

--*/
{
    PRTL_RANGE current;

    RTL_PAGED_CODE();

    ASSERT(Iterator);

    FOR_REST_OF_RANGES(Iterator, current, Forward) {

        //
        // If we have passed all possible intersections then break out.  This
        // can't be done in a merged region because of possible overlaps.
        //

        if (Forward) {
            if (!Iterator->MergedHead && End < current->Start) {
                break;
            }
        } else {
            if (!Iterator->MergedHead && Start > current->End) {
                break;
            }
        }

        //
        // Do we intersect?
        //
        if (RANGE_LIMITS_INTERSECT(Start, End, current->Start, current->End)) {

            DEBUG_PRINT(2,
                ("Intersection 0x%I64x-0x%I64x and 0x%I64x-0x%I64x\n",
                Start,
                End,
                current->Start,
                current->End
                ));

            //
            // Is the intersection not Ok because it is with a non-shared
            // region or we don't want a shared region? Or the user said that
            // it should be considered available because of the user flags set.
            //

            if (!((SharedOK && (current->Flags & RTL_RANGE_SHARED))
                  || (current->Attributes & AttributeAvailableMask)
                  || (NullConflictOK && (current->Owner == NULL))
                  )
                )  {

                //
                // If the caller provided a callback to support extra conflict
                // semantics call it
                //

                if (ARGUMENT_PRESENT(Callback)) {
                    if ((*Callback)(Context, (PRTL_RANGE)current)) {

                    DEBUG_PRINT(2,
                        ("User provided callback overrode conflict\n",
                        Start,
                        End,
                        current->Start,
                        current->End
                        ));

                        continue;
                    }
                }

                return FALSE;
            }
        }
    }


    return TRUE;
}

NTSTATUS
RtlFindRange(
    IN PRTL_RANGE_LIST RangeList,
    IN ULONGLONG Minimum,
    IN ULONGLONG Maximum,
    IN ULONG Length,
    IN ULONG Alignment,
    IN ULONG Flags,
    IN UCHAR AttributeAvailableMask,
    IN PVOID Context OPTIONAL,
    IN PRTL_CONFLICT_RANGE_CALLBACK Callback OPTIONAL,
    OUT PULONGLONG Start
    )
/*++

Routine Description:

    This routine finds the first available range that meets the criterion specified.

Arguments:

    RangeList - The range list to find a range in.

    Minimum - The minimum acceptable value of the start of the range.

    Maximum - The maximum acceptable value of the end of the range.

    Length - The length of the range required.

    Alignmnent - The alignment of the start of the range.

    Flags - Modify the behaviour of the routine.

        RTL_RANGE_LIST_SHARED_OK - indicates that shared ranges should be
            considered to be available.

    AttributeAvailableMask - Any range encountered with any of these bits set will be
        considered to be available.

    Start - Pointer to a ULONGLONG where the start value will be returned on
        success.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_UNSUCCESSFUL
    STATUS_INVALID_PARAMETER

--*/
{

    ULONGLONG start, end;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE dummy;
    BOOLEAN sharedOK, nullConflictOK;

    RTL_PAGED_CODE();

    ASSERT(RangeList);
    ASSERT(Start);
    ASSERT(Alignment > 0);
    ASSERT(Length > 0);

    DEBUG_PRINT(1,
        ("RtlFindRange(0x%08x, 0x%I64x, 0x%I64x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        RangeList,
        Minimum,
        Maximum,
        Length,
        Alignment,
        Flags,
        Start
        ));

    //
    // Search from high to low, Align start if necessary
    //

    start = Maximum - (Length - 1);
    start -= start % Alignment;

    //
    // Valiate parameters
    //

    if ((Minimum > Maximum)
    || (Maximum - Minimum < Length - 1)
    || (Minimum + Alignment < Minimum)
    || (start < Minimum)
    || (Length == 0)
    || (Alignment == 0)) {

        return STATUS_INVALID_PARAMETER;
    }

    sharedOK = (BOOLEAN) Flags & RTL_RANGE_LIST_SHARED_OK;
    nullConflictOK = (BOOLEAN) Flags & RTL_RANGE_LIST_NULL_CONFLICT_OK;
    //
    // Calculate the end
    //

    end = start + Length - 1;

    //
    // Initialze the iterator to the end of the list
    //

    RtlGetLastRange(RangeList, &iterator, &dummy);

    //
    // Keep trying to find ranges until we run out of room or we
    // wrap around
    //

    do {

        DEBUG_PRINT(2,
            ("RtlFindRange: Testing range %I64x-%I64x\n",
            start,
            end
            ));

        if (RtlpIsRangeAvailable(&iterator,
                                 start,
                                 end,
                                 AttributeAvailableMask,
                                 sharedOK,
                                 nullConflictOK,
                                 FALSE,
                                 Context,
                                 Callback)) {

            *Start = start;

            //
            // Assert our result, if we produced one, is in the in
            // the range specified
            //

            ASSERT(*Start >= Minimum && *Start + Length - 1 <= Maximum);

            return STATUS_SUCCESS;
        }

        //
        // Find a suitable range starting from the one we conflicted with,
        // that is the current range in the iterator - this breaks the
        // abstraction of the iterator in the name of efficiency.
        //

        start = ((PRTLP_RANGE_LIST_ENTRY)(iterator.Current))->Start;
        if ((start - Length) > start) {

            //
            // Wrapped, fail.
            //

            break;
        }

        start -= Length;
        start -= start % Alignment;
        end = start + Length - 1;

    } while ( start >= Minimum );

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
RtlGetFirstRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    )
/*++

Routine Description:

    This routine extracts the first range in a range list.  If there are no
    ranges then STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    RangeList - The range list to operate on.

    Iterator - On success this contains the state of the iteration and can be
        passed to RtlGetNextRange.

    Range - On success this contains a pointer to the first range

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_NO_MORE_ENTRIES

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PRTLP_RANGE_LIST_ENTRY first;

    RTL_PAGED_CODE();

    //
    // Fill in the first part of the iterator
    //

    Iterator->RangeListHead = &RangeList->ListHead;
    Iterator->Stamp = RangeList->Stamp;

    if (!IsListEmpty(&RangeList->ListHead)) {

        first = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(RangeList->ListHead.Flink);

        //
        // Fill in the iterator and update to point to the first merged
        // range if we are merged
        //

        if (MERGED(first)) {

            ASSERT(!IsListEmpty(&first->Merged.ListHead));

            Iterator->MergedHead = &first->Merged.ListHead;
            Iterator->Current = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                                    first->Merged.ListHead.Flink
                                    );

        } else {

            Iterator->MergedHead = NULL;
            Iterator->Current = first;
        }

        *Range = (PRTL_RANGE) Iterator->Current;

    } else {

        Iterator->Current = NULL;
        Iterator->MergedHead = NULL;

        *Range = NULL;

        status = STATUS_NO_MORE_ENTRIES;
    }

    return status;
}

NTSTATUS
RtlGetLastRange(
    IN PRTL_RANGE_LIST RangeList,
    OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT PRTL_RANGE *Range
    )
/*++

Routine Description:

    This routine extracts the first range in a range list.  If there are no
    ranges then STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    RangeList - The range list to operate on.

    Iterator - On success this contains the state of the iteration and can be
        passed to RtlGetNextRange.

    Range - On success this contains a pointer to the first range

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_NO_MORE_ENTRIES

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PRTLP_RANGE_LIST_ENTRY first;

    RTL_PAGED_CODE();

    //
    // Fill in the first part of the iterator
    //

    Iterator->RangeListHead = &RangeList->ListHead;
    Iterator->Stamp = RangeList->Stamp;

    if (!IsListEmpty(&RangeList->ListHead)) {

        first = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(RangeList->ListHead.Blink);

        //
        // Fill in the iterator and update to point to the first merged
        // range if we are merged
        //

        if (MERGED(first)) {

            ASSERT(!IsListEmpty(&first->Merged.ListHead));

            Iterator->MergedHead = &first->Merged.ListHead;
            Iterator->Current = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                                    first->Merged.ListHead.Blink
                                    );

        } else {

            Iterator->MergedHead = NULL;
            Iterator->Current = first;
        }

        *Range = (PRTL_RANGE) Iterator->Current;

    } else {

        Iterator->Current = NULL;
        Iterator->MergedHead = NULL;

        *Range = NULL;

        status = STATUS_NO_MORE_ENTRIES;
    }

    return status;
}

NTSTATUS
RtlGetNextRange(
    IN OUT PRTL_RANGE_LIST_ITERATOR Iterator,
    OUT    PRTL_RANGE *Range,
    IN     BOOLEAN MoveForwards
    )
/*++

Routine Description:

    This routine extracts the next range in a range list.  If there are no
    more ranges then STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    Iterator     - The iterator filled in by RtlGet{First|Next}Range which will
                   be update on success.
    Range        - On success this contains a pointer to the next range
    MoveForwards - If true, go forwards thru the list, otherwise,
                   go backwards.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_NO_MORE_ENTRIES
    STATUS_INVALID_PARAMETER

Note:

    Add/Delete operations can not be performed on the list between calls to
    RtlGetFirstRange / RtlGetNextRange and RtlGetNextRange / RtlGetNextRange.
    If such calls are made the routine will detect and fail the call.

--*/
{
    PRTLP_RANGE_LIST_ENTRY mergedEntry, next;
    PLIST_ENTRY entry;

    RTL_PAGED_CODE();

    //
    // Make sure that we haven't changed the list between calls
    //

    if (RANGE_LIST_FROM_LIST_HEAD(Iterator->RangeListHead)->Stamp !=
            Iterator->Stamp) {

        ASSERTMSG(
            "RtlGetNextRange: Add/Delete operations have been performed while \
            iterating through a list\n", FALSE);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // If we have already reached the end of the list then return
    //

    if (!Iterator->Current) {
        *Range = NULL;
        return STATUS_NO_MORE_ENTRIES;
    }

    entry = &((PRTLP_RANGE_LIST_ENTRY)(Iterator->Current))->ListEntry;
    next = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
               MoveForwards ? entry->Flink : entry->Blink);

    ASSERT(next);

    //
    // Are we in a merged range?
    //
    if (Iterator->MergedHead) {

        //
        // Have we reached the end of the merged range?
        //
        if (&next->ListEntry == Iterator->MergedHead) {

            //
            // Get back to the merged entry
            //
            mergedEntry = CONTAINING_RECORD(
                              Iterator->MergedHead,
                              RTLP_RANGE_LIST_ENTRY,
                              Merged.ListHead
                              );

            //
            // Move on to the next entry in the main list
            //

            next = MoveForwards ?
                       RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                           mergedEntry->ListEntry.Flink
                           )
                   :   RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                           mergedEntry->ListEntry.Blink
                           );
            Iterator->MergedHead = NULL;

        } else {

            //
            // There are merged ranges left - return the next one
            //
            Iterator->Current = next;
            *Range = (PRTL_RANGE) next;

            return STATUS_SUCCESS;
        }
    }

    //
    // Have we reached the end of the main list?
    //
    if (&next->ListEntry == Iterator->RangeListHead) {

        //
        // Tell the caller there are no more ranges
        //
        Iterator->Current = NULL;
        *Range = NULL;
        return STATUS_NO_MORE_ENTRIES;

    } else {

        //
        // Is the next range merged?
        //

        if (MERGED(next)) {

            //
            // Goto the first merged entry
            //
            ASSERT(!Iterator->MergedHead);

            Iterator->MergedHead = &next->Merged.ListHead;
            Iterator->Current = MoveForwards ?
                                    RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                                        next->Merged.ListHead.Flink
                                        )
                                :   RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                                        next->Merged.ListHead.Blink
                                        );
        } else {

            //
            // Go to the next entry in the main list
            //

            Iterator->Current = RANGE_LIST_ENTRY_FROM_LIST_ENTRY(
                                    &next->ListEntry
                                    );
        }

        *Range = (PRTL_RANGE) Iterator->Current;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlMergeRangeLists(
    OUT PRTL_RANGE_LIST MergedRangeList,
    IN PRTL_RANGE_LIST RangeList1,
    IN PRTL_RANGE_LIST RangeList2,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine merges two range lists into one.

Arguments:

    MergedRangeList - An empty range list where on success the result of the
        merge will be placed.

    RangeList1 - One of the range lists to be merged.

    RangeList2 - The other the range list to merged.

    Flags - Modifies the behaviour of the routine:

        RTL_RANGE_LIST_MERGE_IF_CONFLICT - Merged ranges even if the conflict.

Return Value:

    Status code that indicates whether or not the function was successful:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_RANGE_LIST_CONFLICT

--*/
{
    NTSTATUS status;
    PRTLP_RANGE_LIST_ENTRY current, currentMerged, newEntry;
    ULONG addFlags;

    RTL_PAGED_CODE();

    DEBUG_PRINT(1,
            ("RtlMergeRangeList(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
            MergedRangeList,
            RangeList1,
            RangeList2,
            Flags
            ));

    //
    // Copy the first range list
    //

    status = RtlCopyRangeList(MergedRangeList, RangeList1);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Add all ranges from 2nd list
    //

    FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY, &RangeList2->ListHead, current) {

        if (MERGED(current)) {

            FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY,
                            &current->Merged.ListHead,
                            currentMerged) {

                if (!(newEntry = RtlpCopyRangeListEntry(currentMerged))) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto cleanup;
                }

                if (CONFLICT(currentMerged)) {

                    //
                    // If a range was already conflicting in then it will conflict in
                    // the merged range list - allow this.
                    //

                    addFlags = Flags | RTL_RANGE_LIST_ADD_IF_CONFLICT;
                } else {

                    addFlags = Flags;
                }

                status = RtlpAddRange(&MergedRangeList->ListHead,
                                      newEntry,
                                      addFlags
                                      );

            }

        } else {


            if (!(newEntry = RtlpCopyRangeListEntry(current))){
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto cleanup;
            }

            if (CONFLICT(current)) {

                //
                // If a range was already conflicting in then it will conflict in
                // the merged range list - allow this.
                //

                addFlags = Flags | RTL_RANGE_LIST_ADD_IF_CONFLICT;
            } else {
                addFlags = Flags;
            }

            status = RtlpAddRange(&MergedRangeList->ListHead,
                                  newEntry,
                                  addFlags
                                  );

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }
        }

    }
    //
    // Correct the count
    //

    MergedRangeList->Count += RangeList2->Count;
    MergedRangeList->Stamp += RangeList2->Count;

    return status;

cleanup:

    //
    // Something went wrong... Free up what we have built of the
    // new list and return the error
    //

    RtlFreeRangeList(MergedRangeList);

    return status;

}

NTSTATUS
RtlInvertRangeList(
    OUT PRTL_RANGE_LIST InvertedRangeList,
    IN PRTL_RANGE_LIST RangeList
    )
/*

Routine Description:

    This inverts a range list so that all areas which are allocated
    in InvertedRangeList will not be in RangeList, and vice
    versa. The ranges in InvertedRangeList will all be owned by NULL.

Arguments:

    InvertedRangeList - a pointer to an empty Range List to be filled
        with the inverted list

    RangeList - a pointer to the Range List to be inverted

Return Value:

    Status of operation.

*/

{

    PRTLP_RANGE_LIST_ENTRY currentRange;
    ULONGLONG currentStart = 0;
    NTSTATUS status;

    RTL_PAGED_CODE();

    //
    // if Inverted List does not start out empty, the inverted list
    // is meaningless
    //

    ASSERT(InvertedRangeList->Count == 0);

    //
    // iterate through all elements of the ReverseAllocation
    // adding the unallocated part before the current element
    // to the RealAllocation
    //

    FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY,
                    &RangeList->ListHead,
                    currentRange) {

        if (currentRange->Start > currentStart) {

            //
            // we want a NULL range owner to show that the
            // range is unavailable
            //
            status = RtlAddRange(InvertedRangeList,
                                 currentStart,
                                 currentRange->Start-1,
                                 0,            // Attributes
                                 0,            // Flags
                                 0,            // UserData
                                 NULL);        // Owner

            if (!NT_SUCCESS(status)) {
                return status;
            }
        }

        currentStart = currentRange->End + 1;
    }

    //
    // add the portion of the address space above the last
    // element in the ReverseAllocation to the RealAllocation
    //
    // unless we've wrapped, in which case we've already added
    // the last element
    //

    if (currentStart > (currentStart - 1)) {

        status = RtlAddRange(InvertedRangeList,
                             currentStart,
                             MAX_ULONGLONG,
                             0,
                             0,
                             0,
                             NULL);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    return STATUS_SUCCESS;

}


#if DBG

VOID
RtlpDumpRangeListEntry(
    LONG Level,
    PRTLP_RANGE_LIST_ENTRY Entry,
    BOOLEAN Indent
    )
{
    PWSTR indentString;
    PRTLP_RANGE_LIST_ENTRY current;

    RTL_PAGED_CODE();

    if (Indent) {
        indentString = L"\t\t";
    } else {
        indentString = L"";
    }
    //
    // Print the range
    //

    DEBUG_PRINT(Level,
                ("%sRange (0x%08x): 0x%I64x-0x%I64x\n",
                indentString,
                Entry,
                Entry->Start,
                Entry->End
                ));

    //
    // Print the flags
    //

    DEBUG_PRINT(Level, ("%s\tPrivateFlags: ", indentString));

    if (MERGED(Entry)) {
        DEBUG_PRINT(Level, ("MERGED "));

    }

    DEBUG_PRINT(Level, ("\n%s\tPublicFlags: ", indentString));

    if (SHARED(Entry)) {
        DEBUG_PRINT(Level, ("SHARED "));
    }

    if (CONFLICT(Entry)) {
        DEBUG_PRINT(Level, ("CONFLICT "));
    }

    DEBUG_PRINT(Level, ("\n"));


    if (MERGED(Entry)) {

        DEBUG_PRINT(Level, ("%sMerged entries:\n", indentString));

        //
        // Print the merged entries
        //

        FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY,
                        &Entry->Merged.ListHead,
                        current) {
            RtlpDumpRangeListEntry(Level, current, TRUE);
        }


    } else {

        //
        // Print the other data
        //

        DEBUG_PRINT(Level,
            ("%s\tUserData: 0x%08x\n\tOwner: 0x%08x\n",
            indentString,
            Entry->Allocated.UserData,
            Entry->Allocated.Owner
            ));
    }
}

VOID
RtlpDumpRangeList(
    LONG Level,
    PRTL_RANGE_LIST RangeList
    )

{
    PRTLP_RANGE_LIST_ENTRY current, currentMerged;

    RTL_PAGED_CODE();

    DEBUG_PRINT(Level,
                ("*** Range List (0x%08x) - Count: %i\n",
                RangeList,
                RangeList->Count
                ));

    FOR_ALL_IN_LIST(RTLP_RANGE_LIST_ENTRY, &RangeList->ListHead, current) {

        //
        // Print the entry
        //

        RtlpDumpRangeListEntry(Level, current, FALSE);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\recip.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    recip.c

Abstract:

    This module generates reciprocol fractions for implementing integer
    division by multiplication.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    User mode.

Revision History:

--*/

#include <stdio.h>

typedef struct _large_integer {
    unsigned long LowPart;
    long HighPart;
    } large_integer;

//long Divisors[] = {2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 0};
long Divisors[] = {10, 10000, 10000000, 86400000, 0};

void
main (argc, argv)
    int argc;
    char *argv[];
{

    large_integer Fraction;
    long Index;
    long NumberBits;
    long Remainder;

    long i;

    //
    // Compute first few reciprocols.
    //

    for (Index = Divisors[i = 0]; Index != 0L; Index = Divisors[++i]) {
        NumberBits = 0L;
        Remainder = 1L;
        Fraction.LowPart = 0L;
        Fraction.HighPart = 0L;
        while (Fraction.HighPart >= 0L) {
            NumberBits += 1L;
            Fraction.HighPart <<= 1L;
            if ((Fraction.LowPart & 0x80000000) != 0L) {
                Fraction.HighPart += 1L;
            }
            Fraction.LowPart <<= 1L;
            Remainder <<= 1L;
            if (Remainder >= Index) {
                Remainder -= Index;
                Fraction.LowPart |= 1L;
            }
        }
        if (Remainder) {
            if ((Fraction.LowPart == -1L) && (Fraction.HighPart == -1L)) {
                Fraction.LowPart = 0L;
                Fraction.HighPart = 0x80000000;
                NumberBits -= 1L;
            } else {
                if (Fraction.LowPart == -1L) {
                    Fraction.LowPart = 0L;
                    Fraction.HighPart += 1L;
                } else {
                    Fraction.LowPart += 1L;
                }
            }
        }

        printf("Divisor %2ld,  Fraction %8lx, %8lx Shift  %ld\n", Index,
               Fraction.HighPart, Fraction.LowPart, NumberBits - 64L);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\prodtype.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    prodtype.c

Abstract:

    This module defines a function to determine the product type.

Author:

    Cliff Van Dyke (CliffV) 20-Mar-1992

Revision History:


--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlGetNtProductType)
#endif


BOOLEAN
RtlGetNtProductType(
    OUT PNT_PRODUCT_TYPE    NtProductType
    )

/*++

Routine Description:

    Returns the product type of the current system.

Arguments:

    NtProductType - Returns the product type.  Either NtProductWinNt or
        NtProductLanManNt.

Return Value:

    TRUE on success, FALSE on failure
    The product type will be set to WinNt on failure

--*/

{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG KeyValueInfoLength;
    ULONG ResultLength;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;
    UNICODE_STRING Value;
    UNICODE_STRING WinNtValue;
    UNICODE_STRING LanmanNtValue;
    UNICODE_STRING ServerNtValue;
    BOOLEAN Result;

    RTL_PAGED_CODE();

    //
    // if we are in gui setup mode, product type is read from the registry since
    // gui setup mode is the only time product type can be changed.
    // All other times, the "captured at boot" version of product type is used
    //

    if ( USER_SHARED_DATA->ProductTypeIsValid ) {
        *NtProductType = USER_SHARED_DATA->NtProductType;
        return TRUE;
        }

    //
    // Prepare default value for failure case
    //

    *NtProductType = NtProductWinNt;
    Result = FALSE;

    RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ProductOptions" );
    RtlInitUnicodeString( &ValueName, L"ProductType" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = ZwOpenKey( &KeyHandle,
                        MAXIMUM_ALLOWED,
                        &ObjectAttributes
                      );
    KeyValueInformation = NULL;
    if (NT_SUCCESS( Status )) {
        KeyValueInfoLength = 256;
#if defined(NTOS_KERNEL_RUNTIME)
        KeyValueInformation = ExAllocatePool( PagedPool, KeyValueInfoLength);
#else
        KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               KeyValueInfoLength
                                             );
#endif

        if (KeyValueInformation == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            Status = ZwQueryValueKey( KeyHandle,
                                      &ValueName,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      KeyValueInfoLength,
                                      &ResultLength
                                    );
        }
    } else {
        KeyHandle = NULL;
    }

    if (NT_SUCCESS( Status ) && KeyValueInformation->Type == REG_SZ) {

        //
        // Decide which product we are installed as
        //

        Value.Buffer = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        Value.Length = (USHORT)(KeyValueInformation->DataLength - sizeof( UNICODE_NULL ));
        Value.MaximumLength = (USHORT)(KeyValueInformation->DataLength);
        RtlInitUnicodeString(&WinNtValue, L"WinNt");
        RtlInitUnicodeString(&LanmanNtValue, L"LanmanNt");
        RtlInitUnicodeString(&ServerNtValue, L"ServerNt");

        if (RtlEqualUnicodeString(&Value, &WinNtValue, TRUE)) {
            *NtProductType = NtProductWinNt;
            Result = TRUE;
        } else if (RtlEqualUnicodeString(&Value, &LanmanNtValue, TRUE)) {
            *NtProductType = NtProductLanManNt;
            Result = TRUE;
        } else if (RtlEqualUnicodeString(&Value, &ServerNtValue, TRUE)) {
            *NtProductType = NtProductServer;
            Result = TRUE;
        } else {
#if DBG
            DbgPrint("RtlGetNtProductType: Product type unrecognised <%wZ>\n", &Value);
#endif // DBG
        }
    } else {
#if DBG
        DbgPrint("RtlGetNtProductType: %wZ\\%wZ not found or invalid type\n", &KeyPath, &ValueName );
#endif // DBG
    }

    //
    // Clean up our resources.
    //

    if (KeyValueInformation != NULL) {
#if defined(NTOS_KERNEL_RUNTIME)
        ExFreePool(KeyValueInformation);
#else
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
#endif
    }

    if (KeyHandle != NULL) {
        ZwClose( KeyHandle );
    }

    //
    // Return result.
    //

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\peb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Peb.c

Abstract:

    Get the PEB for the current process safely

Author:

    Neill Clift (neillc) 16-JUN-2000

Revision History:

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlGetCurrentPeb)
#pragma alloc_text(PAGE,RtlSetProcessIsCritical)
#pragma alloc_text(PAGE,RtlSetThreadIsCritical)
#endif

PPEB
RtlGetCurrentPeb (
    VOID)
{
#if defined(NTOS_KERNEL_RUNTIME)

    PAGED_CODE ();

    return PsGetCurrentProcess ()->Peb;
#else

    return NtCurrentTeb()->ProcessEnvironmentBlock;

#endif
}

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    )
{
    PPEB     Peb;
    ULONG    Enable;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(OldValue) ) {
        *OldValue = FALSE;
    }

    Peb = RtlGetCurrentPeb();
    if ( CheckFlag
         && ! (Peb->NtGlobalFlag & FLG_ENABLE_SYSTEM_CRIT_BREAKS) ) {
        return STATUS_UNSUCCESSFUL;
    }
    if ( ARGUMENT_PRESENT(OldValue) ) {
        NtQueryInformationProcess(NtCurrentProcess(),
                                  ProcessBreakOnTermination,
                                  &Enable,
                                  sizeof(Enable),
                                  NULL);

        *OldValue = (BOOLEAN) Enable;
    }

    Enable = NewValue;

    Status = NtSetInformationProcess(NtCurrentProcess(),
                                     ProcessBreakOnTermination,
                                     &Enable,
                                     sizeof(Enable));

    return Status;
}

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    IN  BOOLEAN  NewValue,
    OUT PBOOLEAN OldValue OPTIONAL,
    IN  BOOLEAN  CheckFlag
    )
{
    PPEB     Peb;
    ULONG    Enable;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(OldValue) ) {
        *OldValue = FALSE;
    }

    Peb = RtlGetCurrentPeb();
    if ( CheckFlag
         && ! (Peb->NtGlobalFlag & FLG_ENABLE_SYSTEM_CRIT_BREAKS) ) {
        return STATUS_UNSUCCESSFUL;
    }
    if ( ARGUMENT_PRESENT(OldValue) ) {
        NtQueryInformationThread(NtCurrentThread(),
                                 ThreadBreakOnTermination,
                                 &Enable,
                                 sizeof(Enable),
                                 NULL);

        *OldValue = (BOOLEAN) Enable;
    }

    Enable = NewValue;

    Status = NtSetInformationThread(NtCurrentThread(),
                                    ThreadBreakOnTermination,
                                    &Enable,
                                    sizeof(Enable));

    return Status;
}

NTSYSAPI
NTSTATUS
NTAPI
RtlCheckProcessParameters(PVOID p1,
                          PWSTR p2,
                          PULONG p3,
                          ULONG v1)
{
    while (*p2) {
        p3[2] = p3[1];
        p3[1] = p3[0];
        p3[0] = *p2;
        p2++;
    }

    v1 = * (volatile WCHAR *) p2;
    v1 *= ((PULONG) p1)[0];
    p3[v1] += ((PULONG) p1)[2];
    v1 += 2;
    p3[v1] = v1 * 3;
    return (NTSTATUS) 0xc0000578;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\prefix.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Prefix.c

Abstract:

    This module implements the prefix table utility.  The two structures
    used in a prefix table are the PREFIX_TABLE and PREFIX_TABLE_ENTRY.
    Each table has one prefix table and multiple prefix table entries
    corresponding to each prefix stored in the table.

    A prefix table is a list of prefix trees, where each tree contains
    the prefixes corresponding to a particular name length (i.e., all
    prefixes of length 1 are stored in one tree, prefixes of length 2
    are stored in another tree, and so forth).  A prefixes name length
    is the number of separate names that appear in the string, and not
    the number of characters in the string (e.g., Length("\alpha\beta") = 2).

    The elements of each tree are ordered lexicalgraphically (case blind)
    using a splay tree data structure.  If two or more prefixes are identical
    except for case then one of the corresponding table entries is actually
    in the tree, while the other entries are in a circular linked list joined
    with the tree member.

Author:

    Gary Kimura     [GaryKi]    3-Aug-1989

Environment:

    Pure utility routine

Revision History:

    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.

--*/

#include "ntrtlp.h"

//
//  Local procedures and types used only in this package
//

typedef enum _COMPARISON {
    IsLessThan,
    IsPrefix,
    IsEqual,
    IsGreaterThan
} COMPARISON;

CLONG
ComputeNameLength(
    IN PSTRING Name
    );

COMPARISON
CompareNamesCaseSensitive (
    IN PSTRING Prefix,
    IN PSTRING Name
    );

CLONG
ComputeUnicodeNameLength(
    IN PUNICODE_STRING Name
    );

COMPARISON
CompareUnicodeStrings (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Name,
    IN ULONG CaseInsensitiveIndex
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,ComputeNameLength)
#pragma alloc_text(PAGE,CompareNamesCaseSensitive)
#pragma alloc_text(PAGE,PfxInitialize)
#pragma alloc_text(PAGE,PfxInsertPrefix)
#pragma alloc_text(PAGE,PfxRemovePrefix)
#pragma alloc_text(PAGE,PfxFindPrefix)
#pragma alloc_text(PAGE,ComputeUnicodeNameLength)
#pragma alloc_text(PAGE,CompareUnicodeStrings)
#pragma alloc_text(PAGE,RtlInitializeUnicodePrefix)
#pragma alloc_text(PAGE,RtlInsertUnicodePrefix)
#pragma alloc_text(PAGE,RtlRemoveUnicodePrefix)
#pragma alloc_text(PAGE,RtlFindUnicodePrefix)
#pragma alloc_text(PAGE,RtlNextUnicodePrefix)
#endif


//
//  The node type codes for the prefix data structures
//

#define RTL_NTC_PREFIX_TABLE             ((CSHORT)0x0200)
#define RTL_NTC_ROOT                     ((CSHORT)0x0201)
#define RTL_NTC_INTERNAL                 ((CSHORT)0x0202)


VOID
PfxInitialize (
    IN PPREFIX_TABLE PrefixTable
    )

/*++

Routine Description:

    This routine initializes a prefix table record to the empty state.

Arguments:

    PrefixTable - Supplies the prefix table being initialized

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    PrefixTable->NodeTypeCode = RTL_NTC_PREFIX_TABLE;

    PrefixTable->NameLength = 0;

    PrefixTable->NextPrefixTree = (PPREFIX_TABLE_ENTRY)PrefixTable;

    //
    //  return to our caller
    //

    return;
}


BOOLEAN
PfxInsertPrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PSTRING Prefix,
    IN PPREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine inserts a new prefix into the specified prefix table

Arguments:

    PrefixTable - Supplies the target prefix table

    Prefix - Supplies the string to be inserted in the prefix table

    PrefixTableEntry - Supplies the entry to use to insert the prefix

Return Value:

    BOOLEAN - TRUE if the Prefix is not already in the table, and FALSE
        otherwise

--*/

{
    ULONG PrefixNameLength;

    PPREFIX_TABLE_ENTRY PreviousTree;
    PPREFIX_TABLE_ENTRY CurrentTree;
    PPREFIX_TABLE_ENTRY NextTree;

    PPREFIX_TABLE_ENTRY Node;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    PrefixNameLength = ComputeNameLength(Prefix);

    //
    //  Setup parts of the prefix table entry that we will always need
    //

    PrefixTableEntry->NameLength = (CSHORT)PrefixNameLength;
    PrefixTableEntry->Prefix = Prefix;

    RtlInitializeSplayLinks(&PrefixTableEntry->Links);

    //
    //  find the corresponding tree, or find where the tree should go
    //

    PreviousTree = (PPREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)PrefixNameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;

    }

    //
    //  If the name length of the current tree is not equal to the
    //  prefix name length then the tree does not exist and we need
    //  to make a new tree node.
    //

    if (CurrentTree->NameLength != (CSHORT)PrefixNameLength) {

        //
        //  Insert the new prefix entry to the list between
        //  previous and current tree
        //

        PreviousTree->NextPrefixTree = PrefixTableEntry;
        PrefixTableEntry->NextPrefixTree = CurrentTree;

        //
        //  And set the node type code
        //

        PrefixTableEntry->NodeTypeCode = RTL_NTC_ROOT;

        //
        //  And tell our caller everything worked fine
        //

        return TRUE;

    }

    //
    //  The tree does exist so now search the tree for our
    //  position in it.  We only exit the loop if we've inserted
    //  a new node, and node is left is left pointing to the
    //  tree position
    //

    Node = CurrentTree;

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert
        //

        Comparison = CompareNamesCaseSensitive(Node->Prefix, Prefix);

        //
        //  If we do match case sensitive then we cannot add
        //  this prefix so we return false.  Note this is the
        //  only condition where we return false
        //

        if (Comparison == IsEqual) {

            return FALSE;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == IsGreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild(&Node->Links) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;

                RtlInsertAsLeftChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild(&Node->Links),
                                          PREFIX_TABLE_ENTRY,
                                          Links );

            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases a less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild(&Node->Links) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;

                RtlInsertAsRightChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild(&Node->Links),
                                          PREFIX_TABLE_ENTRY,
                                          Links );
            }

        }

    }

    //
    //  Now that we've inserted the new node we can splay the tree.
    //  To do this we need to remember how we find this tree in the root
    //  tree list, set the root to be an internal, splay, the tree, and
    //  then setup the new root node.  Note: we cannot splay the prefix table
    //  entry because it might be a case match node so we only splay
    //  the Node variable, which for case match insertions is the
    //  internal node for the case match and for non-case match insertions
    //  the Node variable is the parent node.
    //

    //
    //  Save a pointer to the next tree, we already have the previous tree
    //

    NextTree = CurrentTree->NextPrefixTree;

    //
    //  Reset the current root to be an internal node
    //

    CurrentTree->NodeTypeCode = RTL_NTC_INTERNAL;
    CurrentTree->NextPrefixTree = NULL;

    //
    //  Splay the tree and get the root
    //

    Node = CONTAINING_RECORD(RtlSplay(&Node->Links), PREFIX_TABLE_ENTRY, Links);

    //
    //  Set the new root's node type code and make it part of the
    //  root tree list
    //

    Node->NodeTypeCode = RTL_NTC_ROOT;
    PreviousTree->NextPrefixTree = Node;
    Node->NextPrefixTree = NextTree;

    //
    //  tell our caller everything worked fine
    //

    return TRUE;
}


VOID
PfxRemovePrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PPREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine removes the indicated prefix table entry from
    the prefix table

Arguments:

    PrefixTable - Supplies the prefix table affected

    PrefixTableEntry - Supplies the prefix entry to remove

Return Value:

    None.

--*/

{
    PRTL_SPLAY_LINKS Links;

    PPREFIX_TABLE_ENTRY Root;
    PPREFIX_TABLE_ENTRY NewRoot;

    PPREFIX_TABLE_ENTRY PreviousTree;

    RTL_PAGED_CODE();

    //
    //  case on the type of node that we are trying to delete
    //

    switch (PrefixTableEntry->NodeTypeCode) {

    case RTL_NTC_INTERNAL:
    case RTL_NTC_ROOT:

        //
        //  The node is internal or root node so we need to delete it from
        //  the tree, but first find the root of the tree
        //

        Links = &PrefixTableEntry->Links;

        while (!RtlIsRoot(Links)) {

            Links = RtlParent(Links);
        }

        Root = CONTAINING_RECORD( Links, PREFIX_TABLE_ENTRY, Links );

        //
        //  Now delete the node
        //

        Links = RtlDelete(&PrefixTableEntry->Links);

        //
        //  Now see if the tree is deleted
        //

        if (Links == NULL) {

            //
            //  The tree is now empty so remove this tree from
            //  the tree list, by first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  We've located the previous tree so now just have it
            //  point around the deleted node
            //

            PreviousTree->NextPrefixTree = Root->NextPrefixTree;

            //
            //  and return the our caller
            //

            return;
        }

        //
        //  The tree is not deleted but see if we changed roots
        //

        if (&Root->Links != Links) {

            //
            //  Get a pointer to the new root
            //

            NewRoot = CONTAINING_RECORD(Links, PREFIX_TABLE_ENTRY, Links);

            //
            //  We changed root so we better need to make the new
            //  root part of the prefix data structure, by
            //  first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  Set the new root
            //

            NewRoot->NodeTypeCode = RTL_NTC_ROOT;

            PreviousTree->NextPrefixTree = NewRoot;
            NewRoot->NextPrefixTree = Root->NextPrefixTree;

            //
            //  Set the old root to be an internal node
            //

            Root->NodeTypeCode = RTL_NTC_INTERNAL;

            Root->NextPrefixTree = NULL;

            //
            //  And return to our caller
            //

            return;
        }

        //
        //  We didn't change roots so everything is fine and we can
        //  simply return to our caller
        //

        return;

    default:

        //
        //  If we get here then there was an error and the node type
        //  code is unknown
        //

        return;
    }
}


PPREFIX_TABLE_ENTRY
PfxFindPrefix (
    IN PPREFIX_TABLE PrefixTable,
    IN PSTRING FullName
    )

/*++

Routine Description:

    This routine finds if a full name has a prefix in a prefix table.
    It returns a pointer to the largest proper prefix found if one exists.

Arguments:

    PrefixTable - Supplies the prefix table to search

    FullString - Supplies the name to search for

Return Value:

    PPREFIX_TABLE_ENTRY - a pointer to the longest prefix found if one
        exists, and NULL otherwise

--*/

{
    CLONG NameLength;

    PPREFIX_TABLE_ENTRY PreviousTree;
    PPREFIX_TABLE_ENTRY CurrentTree;
    PPREFIX_TABLE_ENTRY NextTree;

    PRTL_SPLAY_LINKS Links;

    PPREFIX_TABLE_ENTRY Node;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    NameLength = ComputeNameLength(FullName);

    //
    //  Locate the first tree that can contain a prefix
    //

    PreviousTree = (PPREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)NameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  Now search for a prefix until we find one or until we exhaust
    //  the prefix trees
    //

    while (CurrentTree->NameLength > 0) {

        Links = &CurrentTree->Links;

        while (Links != NULL) {

            Node = CONTAINING_RECORD(Links, PREFIX_TABLE_ENTRY, Links);

            //
            //  Compare the prefix in the tree with the full name
            //

            Comparison = CompareNamesCaseSensitive(Node->Prefix, FullName);

            //
            //  See if they don't match
            //

            if (Comparison == IsGreaterThan) {

                //
                //  The prefix is greater than the full name
                //  so we go down the left child
                //

                Links = RtlLeftChild(Links);

                //
                //  And continue searching down this tree
                //

            } else if (Comparison == IsLessThan) {

                //
                //  The prefix is less than the full name
                //  so we go down the right child
                //

                Links = RtlRightChild(Links);

                //
                //  And continue searching down this tree
                //

            } else {

                //
                //  We found it.
                //
                //  Now that we've located the node we can splay the tree.
                //  To do this we need to remember how we find this tree in the root
                //  tree list, set the root to be an internal, splay, the tree, and
                //  then setup the new root node.
                //

                if (Node->NodeTypeCode == RTL_NTC_INTERNAL) {

                    //DbgPrint("PrefixTable  = %08lx\n", PrefixTable);
                    //DbgPrint("Node         = %08lx\n", Node);
                    //DbgPrint("CurrentTree  = %08lx\n", CurrentTree);
                    //DbgPrint("PreviousTree = %08lx\n", PreviousTree);
                    //DbgBreakPoint();

                    //
                    //  Save a pointer to the next tree, we already have the previous tree
                    //

                    NextTree = CurrentTree->NextPrefixTree;

                    //
                    //  Reset the current root to be an internal node
                    //

                    CurrentTree->NodeTypeCode = RTL_NTC_INTERNAL;
                    CurrentTree->NextPrefixTree = NULL;

                    //
                    //  Splay the tree and get the root
                    //

                    Node = CONTAINING_RECORD(RtlSplay(&Node->Links), PREFIX_TABLE_ENTRY, Links);

                    //
                    //  Set the new root's node type code and make it part of the
                    //  root tree list
                    //

                    Node->NodeTypeCode = RTL_NTC_ROOT;
                    PreviousTree->NextPrefixTree = Node;
                    Node->NextPrefixTree = NextTree;
                }

                return Node;
            }
        }

        //
        //  This tree is done so now find the next tree
        //

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  We sesarched everywhere and didn't find a prefix so tell the
    //  caller none was found
    //

    return NULL;
}


CLONG
ComputeNameLength(
    IN PSTRING Name
    )

/*++

Routine Description:

    This routine counts the number of names appearing in the input string.
    It does this by simply counting the number of backslashes in the string.
    To handle ill-formed names (i.e., names that do not contain a backslash)
    this routine really returns the number of backslashes plus 1.

Arguments:

    Name - Supplies the input name to examine

Returns Value:

    CLONG - the number of names in the input string

--*/

{
    ULONG NameLength;
    ULONG i;
    ULONG Count;

    extern const PUSHORT NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )
    extern BOOLEAN NlsMbCodePageTag;

    RTL_PAGED_CODE();

    //
    //  Save the name length, this should make the compiler be able to
    //  optimize not having to reload the length each time
    //

    NameLength = Name->Length - 1;

    //
    //  Now loop through the input string counting back slashes
    //

    if (NlsMbCodePageTag) {

        //
        // ComputeNameLength() skip DBCS character when counting '\'
        //

        for (i = 0, Count = 1; i < NameLength; ) {

            if (NlsLeadByteInfo[(UCHAR)Name->Buffer[i]]) {

                i += 2;

            } else {

                if (Name->Buffer[i] == '\\') {

                    Count += 1;
                }

                i += 1;
            }
        }

    } else {

        for (i = 0, Count = 1; i < NameLength; i += 1) {

            //
            //  check for a back slash
            //

            if (Name->Buffer[i] == '\\') {

                Count += 1;
            }
        }
    }

    //
    //  return the number of back slashes we found
    //

    //DbgPrint("ComputeNameLength(%s) = %x\n", Name->Buffer, Count);

    return Count;
}


COMPARISON
CompareNamesCaseSensitive (
    IN PSTRING Prefix,
    IN PSTRING Name
    )

/*++

Routine Description:

    This routine takes a prefix string and a full name string and determines
    if the prefix string is a proper prefix of the name string (case sensitive)

Arguments:

    Prefix - Supplies the input prefix string

    Name - Supplies the full name input string

Return Value:

    COMPARISON - returns

        IsLessThan    if Prefix < Name lexicalgraphically,
        IsPrefix      if Prefix is a proper prefix of Name
        IsEqual       if Prefix is equal to Name, and
        IsGreaterThan if Prefix > Name lexicalgraphically

--*/

{
    ULONG PrefixLength;
    ULONG NameLength;
    ULONG MinLength;
    ULONG i;

    UCHAR PrefixChar;
    UCHAR NameChar;

    extern const PUSHORT NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )
    extern BOOLEAN NlsMbCodePageTag;

    RTL_PAGED_CODE();

    //DbgPrint("CompareNamesCaseSensitive(\"%s\", \"%s\") = ", Prefix->Buffer, Name->Buffer);

    //
    //  Save the length of the prefix and name string, this should allow
    //  the compiler to not need to reload the length through a pointer every
    //  time we need their values
    //

    PrefixLength = Prefix->Length;
    NameLength = Name->Length;

    //
    //  Special case the situation where the prefix string is simply "\" and
    //  the name starts with an "\"
    //

    if ((Prefix->Length == 1) && (Prefix->Buffer[0] == '\\') &&
        (Name->Length > 1) && (Name->Buffer[0] == '\\')) {
        //DbgPrint("IsPrefix\n");
        return IsPrefix;
    }

    //
    //  Figure out the minimum of the two lengths
    //

    MinLength = (PrefixLength < NameLength ? PrefixLength : NameLength);

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = (ULONG) RtlCompareMemory( &Prefix->Buffer[0], &Name->Buffer[0], MinLength );

    if (i < MinLength) {

        UCHAR c;

        //
        //  Get both characters to examine and keep their case
        //

        PrefixChar = ((c = Prefix->Buffer[i]) == '\\' ? (CHAR)0 : c);
        NameChar   = ((c = Name->Buffer[i])   == '\\' ? (CHAR)0 : c);

        //
        //  Unfortunately life is not so easy in DBCS land.
        //

        if (NlsMbCodePageTag) {

            //
            // CompareNamesCaseSensitive(): check backslash in trailing bytes
            //

            if (Prefix->Buffer[i] == '\\') {

                ULONG j;
                extern const PUSHORT   NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )

                for (j = 0; j < i;) {

                    j += NlsLeadByteInfo[(UCHAR)Prefix->Buffer[j]] ? 2 : 1;
                }

                if (j != i) {

                    PrefixChar = '\\';
                    //DbgPrint("RTL:CompareNamesCaseSensitive encountered a fake backslash!\n");
                }
            }

            if (Name->Buffer[i] == '\\') {

                ULONG j;
                extern const PUSHORT   NlsLeadByteInfo;  // Lead byte info. for ACP ( nlsxlat.c )

                for (j = 0; j < i;) {

                    j += NlsLeadByteInfo[(UCHAR)Name->Buffer[j]] ? 2 : 1;
                }

                if (j != i) {

                    NameChar = '\\';
                    //DbgPrint("RTL:CompareNamesCaseSensitive encountered a fake backslash!\n");
                }
            }
        }

        //
        //  Now compare the characters
        //

        if (PrefixChar < NameChar) {

            return IsLessThan;

        } else if (PrefixChar > NameChar) {

            return IsGreaterThan;
        }
    }

    //
    //  They match upto the minimum length so now figure out the largest string
    //  and see if one is a proper prefix of the other
    //

    if (PrefixLength < NameLength) {

        //
        //  The prefix string is shorter so if it is a proper prefix we
        //  return prefix otherwise we return less than (e.g., "\a" < "\ab")
        //

        if (Name->Buffer[PrefixLength] == '\\') {

            return IsPrefix;

        } else {

            return IsLessThan;
        }

    } else if (PrefixLength > NameLength) {

        //
        //  The Prefix string is longer so we say that the prefix is
        //  greater than the name (e.g., "\ab" > "\a")
        //

        return IsGreaterThan;

    } else {

        //
        //  They lengths are equal so the strings are equal
        //

        return IsEqual;
    }
}


//
//  The node type codes for the prefix data structures
//

#define RTL_NTC_UNICODE_PREFIX_TABLE     ((CSHORT)0x0800)
#define RTL_NTC_UNICODE_ROOT             ((CSHORT)0x0801)
#define RTL_NTC_UNICODE_INTERNAL         ((CSHORT)0x0802)
#define RTL_NTC_UNICODE_CASE_MATCH       ((CSHORT)0x0803)


VOID
RtlInitializeUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable
    )

/*++

Routine Description:

    This routine initializes a unicode prefix table record to the empty state.

Arguments:

    PrefixTable - Supplies the prefix table being initialized

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    PrefixTable->NodeTypeCode = RTL_NTC_UNICODE_PREFIX_TABLE;
    PrefixTable->NameLength = 0;
    PrefixTable->NextPrefixTree = (PUNICODE_PREFIX_TABLE_ENTRY)PrefixTable;
    PrefixTable->LastNextEntry = NULL;

    //
    //  return to our caller
    //

    return;
}


BOOLEAN
RtlInsertUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine inserts a new unicode prefix into the specified prefix table

Arguments:

    PrefixTable - Supplies the target prefix table

    Prefix - Supplies the string to be inserted in the prefix table

    PrefixTableEntry - Supplies the entry to use to insert the prefix

Return Value:

    BOOLEAN - TRUE if the Prefix is not already in the table, and FALSE
        otherwise

--*/

{
    ULONG PrefixNameLength;

    PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
    PUNICODE_PREFIX_TABLE_ENTRY CurrentTree;
    PUNICODE_PREFIX_TABLE_ENTRY NextTree;

    PUNICODE_PREFIX_TABLE_ENTRY Node;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    PrefixNameLength = ComputeUnicodeNameLength(Prefix);

    //
    //  Setup parts of the prefix table entry that we will always need
    //

    PrefixTableEntry->NameLength = (CSHORT)PrefixNameLength;
    PrefixTableEntry->Prefix = Prefix;

    RtlInitializeSplayLinks(&PrefixTableEntry->Links);

    //
    //  find the corresponding tree, or find where the tree should go
    //

    PreviousTree = (PUNICODE_PREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)PrefixNameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  If the name length of the current tree is not equal to the
    //  prefix name length then the tree does not exist and we need
    //  to make a new tree node.
    //

    if (CurrentTree->NameLength != (CSHORT)PrefixNameLength) {

        //
        //  Insert the new prefix entry to the list between
        //  previous and current tree
        //

        PreviousTree->NextPrefixTree = PrefixTableEntry;
        PrefixTableEntry->NextPrefixTree = CurrentTree;

        //
        //  And set the node type code, case match for the root tree node
        //

        PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_ROOT;
        PrefixTableEntry->CaseMatch = PrefixTableEntry;

        //
        //  And tell our caller everything worked fine
        //

        return TRUE;
    }

    //
    //  The tree does exist so now search the tree for our
    //  position in it.  We only exit the loop if we've inserted
    //  a new node, and node is left is left pointing to the
    //  tree position
    //

    Node = CurrentTree;

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.  Do the compare case blind
        //

        Comparison = CompareUnicodeStrings(Node->Prefix, Prefix, 0);

        //
        //  If they are equal then this node gets added as a case
        //  match, provided it doesn't case sensitive match anyone
        //

        if (Comparison == IsEqual) {

            PUNICODE_PREFIX_TABLE_ENTRY Next;

            //
            //  Loop through the case match list checking to see if we
            //  match case sensitive with anyone.  Get the first node
            //

            Next = Node;

            //
            //  And loop checking each node until we're back to where
            //  we started
            //

            do {

                //
                //  If we do match case sensitive then we cannot add
                //  this prefix so we return false.  Note this is the
                //  only condition where we return false
                //

                if (CompareUnicodeStrings(Next->Prefix, Prefix, MAXULONG) == IsEqual) {

                    return FALSE;
                }

                //
                //  Get the next node in the case match list
                //

                Next = Next->CaseMatch;

                //
                //  And continue looping until we're back where we started
                //

            } while ( Next != Node );

            //
            //  We've searched the case match and didn't find an exact match
            //  so we can insert this node in the case match list
            //

            PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_CASE_MATCH;
            PrefixTableEntry->NextPrefixTree = NULL;

            PrefixTableEntry->CaseMatch = Node->CaseMatch;
            Node->CaseMatch = PrefixTableEntry;

            //
            //  And exit out of the while loop
            //

            break;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == IsGreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild(&Node->Links) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;
                PrefixTableEntry->CaseMatch = PrefixTableEntry;

                RtlInsertAsLeftChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild(&Node->Links),
                                          UNICODE_PREFIX_TABLE_ENTRY,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases a less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild(&Node->Links) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                PrefixTableEntry->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
                PrefixTableEntry->NextPrefixTree = NULL;
                PrefixTableEntry->CaseMatch = PrefixTableEntry;

                RtlInsertAsRightChild(&Node->Links, &PrefixTableEntry->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild(&Node->Links),
                                          UNICODE_PREFIX_TABLE_ENTRY,
                                          Links );
            }
        }
    }

    //
    //  Now that we've inserted the new node we can splay the tree.
    //  To do this we need to remember how we find this tree in the root
    //  tree list, set the root to be an internal, splay, the tree, and
    //  then setup the new root node.  Note: we cannot splay the prefix table
    //  entry because it might be a case match node so we only splay
    //  the Node variable, which for case match insertions is the
    //  internal node for the case match and for non-case match insertions
    //  the Node variable is the parent node.
    //

    //
    //  Save a pointer to the next tree, we already have the previous tree
    //

    NextTree = CurrentTree->NextPrefixTree;

    //
    //  Reset the current root to be an internal node
    //

    CurrentTree->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
    CurrentTree->NextPrefixTree = NULL;

    //
    //  Splay the tree and get the root
    //

    Node = CONTAINING_RECORD(RtlSplay(&Node->Links), UNICODE_PREFIX_TABLE_ENTRY, Links);

    //
    //  Set the new root's node type code and make it part of the
    //  root tree list
    //

    Node->NodeTypeCode = RTL_NTC_UNICODE_ROOT;
    PreviousTree->NextPrefixTree = Node;
    Node->NextPrefixTree = NextTree;

    //
    //  tell our caller everything worked fine
    //

    return TRUE;
}


VOID
RtlRemoveUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry
    )

/*++

Routine Description:

    This routine removes the indicated prefix table entry from
    the prefix table

Arguments:

    PrefixTable - Supplies the prefix table affected

    PrefixTableEntry - Supplies the prefix entry to remove

Return Value:

    None.

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY PreviousCaseMatch;

    PRTL_SPLAY_LINKS Links;

    PUNICODE_PREFIX_TABLE_ENTRY Root;
    PUNICODE_PREFIX_TABLE_ENTRY NewRoot;

    PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;

    RTL_PAGED_CODE();

    //
    //  Wipe out the next last entry field of the prefix table
    //

    PrefixTable->LastNextEntry = NULL;

    //
    //  case on the type of node that we are trying to delete
    //

    switch (PrefixTableEntry->NodeTypeCode) {

    case RTL_NTC_UNICODE_CASE_MATCH:

        //
        //  The prefix entry is a case match record so
        //  we only need to remove it from the case match list.
        //  Locate the previous PrefixTableEntry that reference this
        //  case match record
        //

        PreviousCaseMatch = PrefixTableEntry->CaseMatch;

        while ( PreviousCaseMatch->CaseMatch != PrefixTableEntry ) {

             PreviousCaseMatch = PreviousCaseMatch->CaseMatch;
        }

        //
        //  Now that we have the previous record just have it point
        //  around the case match that is being deleted
        //

        PreviousCaseMatch->CaseMatch = PrefixTableEntry->CaseMatch;

        //
        //  And return to our caller
        //

        return;

    case RTL_NTC_UNICODE_INTERNAL:
    case RTL_NTC_UNICODE_ROOT:

        //
        //  The prefix entry is an internal/root node so check to see if it
        //  has any case match nodes with it
        //

        if (PrefixTableEntry->CaseMatch != PrefixTableEntry) {

            //
            //  There is at least one case match that goes with this
            //  node, so we need to make the next case match the
            //  new node and remove this node.
            //  Locate the previous prefix table entry that references this
            //  case match record
            //

            PreviousCaseMatch = PrefixTableEntry->CaseMatch;

            while ( PreviousCaseMatch->CaseMatch != PrefixTableEntry ) {

                PreviousCaseMatch = PreviousCaseMatch->CaseMatch;
            }

            //
            //  Now that we have the previous record just have it point
            //  around the node being deleted
            //

            PreviousCaseMatch->CaseMatch = PrefixTableEntry->CaseMatch;

            //
            //  Now make the previous case match in the new node
            //

            PreviousCaseMatch->NodeTypeCode = PrefixTableEntry->NodeTypeCode;
            PreviousCaseMatch->NextPrefixTree = PrefixTableEntry->NextPrefixTree;
            PreviousCaseMatch->Links = PrefixTableEntry->Links;

            //
            //  Now take care of the back pointers to this new internal
            //  node in the splay tree, first do the parent's pointer to us.
            //

            if (RtlIsRoot(&PrefixTableEntry->Links)) {

                //
                //  This is the root so make this new node the root
                //

                PreviousCaseMatch->Links.Parent = &PreviousCaseMatch->Links;

                //
                //  Fix up the root tree list, by first finding the previous
                //  pointer to us

                PreviousTree = PrefixTableEntry->NextPrefixTree;

                while ( PreviousTree->NextPrefixTree != PrefixTableEntry ) {

                    PreviousTree = PreviousTree->NextPrefixTree;
                }

                //
                //  We've located the previous tree so now have the previous
                //  tree point to our new root
                //

                PreviousTree->NextPrefixTree = PreviousCaseMatch;

            } else if (RtlIsLeftChild(&PrefixTableEntry->Links)) {

                //
                //  The node was the left child so make the new node the
                //  left child
                //

                RtlParent(&PrefixTableEntry->Links)->LeftChild = &PreviousCaseMatch->Links;

            } else {

                //
                //  The node was the right child so make the new node the
                //  right child
                //

                RtlParent(&PrefixTableEntry->Links)->RightChild = &PreviousCaseMatch->Links;
            }

            //
            //  Now update the parent pointer for our new children
            //

            if (RtlLeftChild(&PreviousCaseMatch->Links) != NULL) {

                RtlLeftChild(&PreviousCaseMatch->Links)->Parent = &PreviousCaseMatch->Links;
            }

            if (RtlRightChild(&PreviousCaseMatch->Links) != NULL) {

                RtlRightChild(&PreviousCaseMatch->Links)->Parent = &PreviousCaseMatch->Links;
            }

            //
            //  And return to our caller
            //

            return;
        }

        //
        //  The node is internal or root node and does not have any case match
        //  nodes so we need to delete it from the tree, but first find
        //  the root of the tree
        //

        Links = &PrefixTableEntry->Links;

        while (!RtlIsRoot(Links)) {

            Links = RtlParent(Links);
        }

        Root = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links );

        //
        //  Now delete the node
        //

        Links = RtlDelete(&PrefixTableEntry->Links);

        //
        //  Now see if the tree is deleted
        //

        if (Links == NULL) {

            //
            //  The tree is now empty so remove this tree from
            //  the tree list, by first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  We've located the previous tree so now just have it
            //  point around the deleted node
            //

            PreviousTree->NextPrefixTree = Root->NextPrefixTree;

            //
            //  and return the our caller
            //

            return;
        }

        //
        //  The tree is not deleted but see if we changed roots
        //

        if (&Root->Links != Links) {

            //
            //  Get a pointer to the new root
            //

            NewRoot = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

            //
            //  We changed root so we better need to make the new
            //  root part of the prefix data structure, by
            //  first finding the previous tree that
            //  references us
            //

            PreviousTree = Root->NextPrefixTree;

            while ( PreviousTree->NextPrefixTree != Root ) {

                PreviousTree = PreviousTree->NextPrefixTree;
            }

            //
            //  Set the new root
            //

            NewRoot->NodeTypeCode = RTL_NTC_UNICODE_ROOT;

            PreviousTree->NextPrefixTree = NewRoot;
            NewRoot->NextPrefixTree = Root->NextPrefixTree;

            //
            //  Set the old root to be an internal node
            //

            Root->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;

            Root->NextPrefixTree = NULL;

            //
            //  And return to our caller
            //

            return;
        }

        //
        //  We didn't change roots so everything is fine and we can
        //  simply return to our caller
        //

        return;

    default:

        //
        //  If we get here then there was an error and the node type
        //  code is unknown
        //

        return;
    }
}


PUNICODE_PREFIX_TABLE_ENTRY
RtlFindUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN PUNICODE_STRING FullName,
    IN ULONG CaseInsensitiveIndex
    )

/*++

Routine Description:

    This routine finds if a full name has a prefix in a prefix table.
    It returns a pointer to the largest proper prefix found if one exists.

Arguments:

    PrefixTable - Supplies the prefix table to search

    FullString - Supplies the name to search for

    CaseInsensitiveIndex - Indicates the wchar index at which to do a case
        insensitive search.  All characters before the index are searched
        case sensitive and all characters at and after the index are searched
        insensitive.

Return Value:

    PPREFIX_TABLE_ENTRY - a pointer to the longest prefix found if one
        exists, and NULL otherwise

--*/

{
    CLONG NameLength;

    PUNICODE_PREFIX_TABLE_ENTRY PreviousTree;
    PUNICODE_PREFIX_TABLE_ENTRY CurrentTree;
    PUNICODE_PREFIX_TABLE_ENTRY NextTree;

    PRTL_SPLAY_LINKS Links;

    PUNICODE_PREFIX_TABLE_ENTRY Node;
    PUNICODE_PREFIX_TABLE_ENTRY Next;

    COMPARISON Comparison;

    RTL_PAGED_CODE();

    //
    //  Determine the name length of the input string
    //

    NameLength = ComputeUnicodeNameLength(FullName);

    //
    //  Locate the first tree that can contain a prefix
    //

    PreviousTree = (PUNICODE_PREFIX_TABLE_ENTRY)PrefixTable;
    CurrentTree = PreviousTree->NextPrefixTree;

    while (CurrentTree->NameLength > (CSHORT)NameLength) {

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  Now search for a prefix until we find one or until we exhaust
    //  the prefix trees
    //

    while (CurrentTree->NameLength > 0) {

        Links = &CurrentTree->Links;

        while (Links != NULL) {

            Node = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

            //
            //  Compare the prefix in the tree with the full name, do the
            //  compare case blind
            //

            Comparison = CompareUnicodeStrings(Node->Prefix, FullName, 0);

            //
            //  See if they don't match
            //

            if (Comparison == IsGreaterThan) {

                //
                //  The prefix is greater than the full name
                //  so we go down the left child
                //

                Links = RtlLeftChild(Links);

                //
                //  And continue searching down this tree
                //

            } else if (Comparison == IsLessThan) {

                //
                //  The prefix is less than the full name
                //  so we go down the right child
                //

                Links = RtlRightChild(Links);

                //
                //  And continue searching down this tree
                //

            } else {

                //
                //  We have either a prefix or a match either way
                //  we need to check if we should do case sensitive
                //  seearches
                //

                if (CaseInsensitiveIndex == 0) {

                    //
                    //  The caller wants case insensitive so we'll
                    //  return the first one we found
                    //
                    //  Now that we've located the node we can splay the tree.
                    //  To do this we need to remember how we find this tree in the root
                    //  tree list, set the root to be an internal, splay, the tree, and
                    //  then setup the new root node.
                    //

                    if (Node->NodeTypeCode == RTL_NTC_UNICODE_INTERNAL) {

                        //DbgPrint("PrefixTable  = %08lx\n", PrefixTable);
                        //DbgPrint("Node         = %08lx\n", Node);
                        //DbgPrint("CurrentTree  = %08lx\n", CurrentTree);
                        //DbgPrint("PreviousTree = %08lx\n", PreviousTree);
                        //DbgBreakPoint();

                        //
                        //  Save a pointer to the next tree, we already have the previous tree
                        //

                        NextTree = CurrentTree->NextPrefixTree;

                        //
                        //  Reset the current root to be an internal node
                        //

                        CurrentTree->NodeTypeCode = RTL_NTC_UNICODE_INTERNAL;
                        CurrentTree->NextPrefixTree = NULL;

                        //
                        //  Splay the tree and get the root
                        //

                        Node = CONTAINING_RECORD(RtlSplay(&Node->Links), UNICODE_PREFIX_TABLE_ENTRY, Links);

                        //
                        //  Set the new root's node type code and make it part of the
                        //  root tree list
                        //

                        Node->NodeTypeCode = RTL_NTC_UNICODE_ROOT;
                        PreviousTree->NextPrefixTree = Node;
                        Node->NextPrefixTree = NextTree;
                    }

                    //
                    //  Now return the root to our caller
                    //

                    return Node;
                }

                //
                //  The caller wants an exact match so search the case match
                //  until we find a complete match.  Get the first node
                //

                Next = Node;

                //
                //  Loop through the case match list checking to see if we
                //  match case sensitive with anyone.
                //

                do {

                    //
                    //  If we do match case sensitive then we found one
                    //  and we return it to our caller
                    //

                    Comparison = CompareUnicodeStrings( Next->Prefix,
                                                        FullName,
                                                        CaseInsensitiveIndex );

                    if ((Comparison == IsEqual) || (Comparison == IsPrefix)) {

                        //
                        //  We found a good one, so return it to our caller
                        //

                        return Next;
                    }

                    //
                    //  Get the next case match record
                    //

                    Next = Next->CaseMatch;

                    //
                    //  And continue the loop until we reach the original
                    //  node again
                    //

                } while ( Next != Node );

                //
                //  We found a case blind prefix but the caller wants
                //  case sensitive and we weren't able to find one of those
                //  so we need to go on to the next tree, by breaking out
                //  of the inner while-loop
                //

                break;
            }
        }

        //
        //  This tree is done so now find the next tree
        //

        PreviousTree = CurrentTree;
        CurrentTree = CurrentTree->NextPrefixTree;
    }

    //
    //  We sesarched everywhere and didn't find a prefix so tell the
    //  caller none was found
    //

    return NULL;
}


PUNICODE_PREFIX_TABLE_ENTRY
RtlNextUnicodePrefix (
    IN PUNICODE_PREFIX_TABLE PrefixTable,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    This routine returns the next prefix entry stored in the prefix table

Arguments:

    PrefixTable - Supplies the prefix table to enumerate

    Restart - Indicates if the enumeration should start over

Return Value:

    PPREFIX_TABLE_ENTRY - A pointer to the next prefix table entry if
        one exists otherwise NULL

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY Node;

    PRTL_SPLAY_LINKS Links;

    RTL_PAGED_CODE();

    //
    //  See if we are restarting the sequence
    //

    if (Restart || (PrefixTable->LastNextEntry == NULL)) {

        //
        //  we are restarting the sequence so locate the first entry
        //  in the first tree
        //

        Node = PrefixTable->NextPrefixTree;

        //
        //  Make sure we've pointing at a prefix tree
        //

        if (Node->NodeTypeCode == RTL_NTC_UNICODE_PREFIX_TABLE) {

            //
            //  No we aren't so the table must be empty
            //

            return NULL;
        }

        //
        //  Find the first node in the tree
        //

        Links = &Node->Links;

        while (RtlLeftChild(Links) != NULL) {

            Links = RtlLeftChild(Links);
        }

        //
        //  Set it as our the node we're returning
        //

        Node = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

    } else if (PrefixTable->LastNextEntry->CaseMatch->NodeTypeCode == RTL_NTC_UNICODE_CASE_MATCH) {

        //
        //  The last node has a case match that we should be returning
        //  this time around
        //

        Node = PrefixTable->LastNextEntry->CaseMatch;

    } else {

        //
        //  Move over the last node returned by the case match link, this
        //  will enable us to finish off the last case match node if there
        //  was one, and go to the next internal/root node. If this node
        //  does not have a case match then we simply circle back to ourselves
        //

        Node = PrefixTable->LastNextEntry->CaseMatch;

        //
        //  Find the successor for the last node we returned
        //

        Links = RtlRealSuccessor(&Node->Links);

        //
        //  If links is null then we've exhausted this tree and need to
        //  the the next tree to use
        //

        if (Links == NULL) {

            Links = &PrefixTable->LastNextEntry->Links;

            while (!RtlIsRoot(Links)) {

                Links = RtlParent(Links);
            }

            Node = CONTAINING_RECORD(Links, UNICODE_PREFIX_TABLE_ENTRY, Links);

            //
            //  Now we've found the root see if there is another
            //  tree to enumerate
            //

            Node = Node->NextPrefixTree;

            if (Node->NameLength <= 0) {

                //
                //  We've run out of tree so tell our caller there
                //  are no more
                //

                return NULL;
            }

            //
            //  We have another tree to go down
            //

            Links = &Node->Links;

            while (RtlLeftChild(Links) != NULL) {

                Links = RtlLeftChild(Links);
            }
        }

        //
        //  Set it as our the node we're returning
        //

        Node = CONTAINING_RECORD( Links, UNICODE_PREFIX_TABLE_ENTRY, Links);
    }

    //
    //  Save node as the last next entry
    //

    PrefixTable->LastNextEntry = Node;

    //
    //  And return this entry to our caller
    //

    return Node;
}


CLONG
ComputeUnicodeNameLength(
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine counts the number of names appearing in the input string.
    It does this by simply counting the number of backslashes in the string.
    To handle ill-formed names (i.e., names that do not contain a backslash)
    this routine really returns the number of backslashes plus 1.

Arguments:

    Name - Supplies the input name to examine

Returns Value:

    CLONG - the number of names in the input string

--*/

{
    WCHAR UnicodeBackSlash = '\\';
    ULONG NameLength;
    ULONG i;
    ULONG Count;

    RTL_PAGED_CODE();

    //
    //  Save the name length, this should make the compiler be able to
    //  optimize not having to reload the length each time
    //

    NameLength = (ULONG)Name->Length/2;

    //
    //  Now loop through the input string counting back slashes
    //

    for (i = 0, Count = 1; i < (ULONG)NameLength - 1; i += 1) {

        //
        //  check for a back slash
        //

        if (Name->Buffer[i] == UnicodeBackSlash) {

            Count += 1;
        }
    }

    //
    //  return the number of back slashes we found
    //

    //DbgPrint("ComputeUnicodeNameLength(%Z) = %x\n", Name, Count);

    return Count;
}


COMPARISON
CompareUnicodeStrings (
    IN PUNICODE_STRING Prefix,
    IN PUNICODE_STRING Name,
    IN ULONG CaseInsensitiveIndex
    )

/*++

Routine Description:

    This routine takes a prefix string and a full name string and determines
    if the prefix string is a proper prefix of the name string (case sensitive)

Arguments:

    Prefix - Supplies the input prefix string

    Name - Supplies the full name input string

    CaseInsensitiveIndex - Indicates the wchar index at which to do a case
        insensitive search.  All characters before the index are searched
        case sensitive and all characters at and after the index are searched

Return Value:

    COMPARISON - returns

        IsLessThan    if Prefix < Name lexicalgraphically,
        IsPrefix      if Prefix is a proper prefix of Name
        IsEqual       if Prefix is equal to Name, and
        IsGreaterThan if Prefix > Name lexicalgraphically

--*/

{
    WCHAR UnicodeBackSlash = '\\';
    ULONG PrefixLength;
    ULONG NameLength;
    ULONG MinLength;
    ULONG i;

    WCHAR PrefixChar;
    WCHAR NameChar;

    RTL_PAGED_CODE();

    //DbgPrint("CompareUnicodeStrings(\"%Z\", \"%Z\") = ", Prefix, Name);

    //
    //  Save the length of the prefix and name string, this should allow
    //  the compiler to not need to reload the length through a pointer every
    //  time we need their values
    //

    PrefixLength = (ULONG)Prefix->Length/2;
    NameLength = (ULONG)Name->Length/2;

    //
    //  Special case the situation where the prefix string is simply "\" and
    //  the name starts with an "\"
    //

    if ((PrefixLength == 1) && (Prefix->Buffer[0] == UnicodeBackSlash) &&
        (NameLength > 1) && (Name->Buffer[0] == UnicodeBackSlash)) {
        //DbgPrint("IsPrefix\n");
        return IsPrefix;
    }

    //
    //  Figure out the minimum of the two lengths
    //

    MinLength = (PrefixLength < NameLength ? PrefixLength : NameLength);

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty.  First to the CaseSensitive part, then the
    //  CaseInsensitive part.
    //

    if (CaseInsensitiveIndex > MinLength) {

        CaseInsensitiveIndex = MinLength;
    }

    //
    //  CaseSensitive compare
    //

    for (i = 0; i < CaseInsensitiveIndex; i += 1) {

        PrefixChar = Prefix->Buffer[i];
        NameChar   = Name->Buffer[i];

        if (PrefixChar != NameChar) {

            break;
        }
    }

    //
    //  If we didn't break out of the above loop, do the
    //  CaseInsensitive compare.
    //

    if (i == CaseInsensitiveIndex) {

        WCHAR *s1 = &Prefix->Buffer[i];
        WCHAR *s2 = &Name->Buffer[i];

        for (; i < MinLength; i += 1) {

            PrefixChar = *s1++;
            NameChar = *s2++;

            if (PrefixChar != NameChar) {

                PrefixChar = NLS_UPCASE(PrefixChar);
                NameChar   = NLS_UPCASE(NameChar);

                if (PrefixChar != NameChar) {
                    break;
                }
            }
        }
    }

    //
    //  If we broke out of the above loop because of a mismatch, determine
    //  the result of the comparison.
    //

    if (i < MinLength) {

        //
        //  We also need to treat "\" as less than all other characters, so
        //  if the char is a "\" we'll drop it down to a value of zero.
        //

        if (PrefixChar == UnicodeBackSlash) {

            return IsLessThan;
        }

        if (NameChar == UnicodeBackSlash) {

            return IsGreaterThan;
        }

        //
        //  Now compare the characters
        //

        if (PrefixChar < NameChar) {

            return IsLessThan;

        } else if (PrefixChar > NameChar) {

            return IsGreaterThan;
        }
    }

    //
    //  They match upto the minimum length so now figure out the largest string
    //  and see if one is a proper prefix of the other
    //

    if (PrefixLength < NameLength) {

        //
        //  The prefix string is shorter so if it is a proper prefix we
        //  return prefix otherwise we return less than (e.g., "\a" < "\ab")
        //

        if (Name->Buffer[PrefixLength] == UnicodeBackSlash) {

            //DbgPrint("IsPrefix\n");

            return IsPrefix;

        } else {

            //DbgPrint("IsLessThan\n");

            return IsLessThan;
        }

    } else if (PrefixLength > NameLength) {

        //
        //  The Prefix string is longer so we say that the prefix is
        //  greater than the name (e.g., "\ab" > "\a")
        //

        //DbgPrint("IsGreaterThan\n");

        return IsGreaterThan;

    } else {

        //
        //  They lengths are equal so the strings are equal
        //

        //DbgPrint("IsEqual\n");

        return IsEqual;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\random.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Random.c

Abstract:

    This module implements a simple random number generator

Author:

    Gary Kimura     [GaryKi]    26-May-1989

Environment:

    Pure utility routine

Revision History:

    Vishnu Patankar [VishnuP]  12-Nov-2000
            Added new random number generator RtlRandomEx()

--*/

#include <ntrtlp.h>

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE, RtlRandom)
#endif

#define Multiplier ((ULONG)(0x80000000ul - 19)) // 2**31 - 19
#define Increment  ((ULONG)(0x80000000ul - 61)) // 2**31 - 61
#define Modulus    ((ULONG)(0x80000000ul - 1))  // 2**31 - 1

#if !defined(NTOS_KERNEL_RUNTIME)
ULONG
RtlUniform (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    A simple uniform random number generator, based on D.H. Lehmer's 1948
    alrogithm.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    *Seed = ((Multiplier * (*Seed)) + Increment) % Modulus;
    return *Seed;
}
#endif

#define UniformMacro(Seed) (                                 \
    *Seed = (((Multiplier * (*Seed)) + Increment) % Modulus) \
    )


extern ULONG RtlpRandomConstantVector[];

ULONG
RtlRandom (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    An every better random number generator based on MacLaren and Marsaglia.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    ULONG X;
    ULONG Y;
    ULONG j;
    ULONG Result;

    RTL_PAGED_CODE();

    X = UniformMacro(Seed);
    Y = UniformMacro(Seed);

    j = Y % 128;

    Result = RtlpRandomConstantVector[j];

    RtlpRandomConstantVector[j] = X;

    return Result;

}

extern ULONG RtlpRandomExAuxVarY;
extern ULONG RtlpRandomExConstantVector[];

ULONG
RtlRandomEx(
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    This algorithm is preferred over RtlRandom() for two reasons:

    (a) it is faster than RtlRandom() since it saves one multiplication, one addition and
    one modulus operation. This almost doubles the performance since it halves the number of
    clocks even on a pipelined Integer Unit such as the P6/ia64 processors i.e. ~ 52% perf gain.
    Plain RtlRandom() suffers from a RAW data dependency that integer pipelines cannot exploit.

    (b) it produces better random numbers than RtlRandom() since the period of the random
    numbers generated is comparatively higher.

    The algorithm here is based on a paper by Carter Bays and S.D.Durham [ACM Trans. Math.
    Software 2, pp. 59-64].
    Knuth's The Art of Computer Programming (Seminumerical Algorithms) outlines the algorithm
    with proofs to support claims (a) and (b) above.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    ULONG j;
    ULONG Result;

    RTL_PAGED_CODE();

    j = RtlpRandomExAuxVarY % 128;

    RtlpRandomExAuxVarY = RtlpRandomExConstantVector[j];

    Result = RtlpRandomExAuxVarY;

    RtlpRandomExConstantVector[j] = UniformMacro(Seed);

    return Result;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\registry.c ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    registry.c

Abstract:

    (This file has been copied from the temporary hack that BryanWi and
    ScottBi did in kernel mode.  I saw no need to have it be in kernel
    mode and it had many bugs caused as a result of being in kernel mode,
    so I made it caller mode.  Jim Kelly).



   This module represents a quick and dirty Nt level registry.  Each key
   in the Registry is implemented as a file directory within a directory
   tree whose root is the directory "\Registry" on the system disk.
   A key's data is stored within a file called  "Data.Reg" in the key's
   directory, and a key's attributes is stored as the file "Attr.Reg"
   within the directory.






Author:

    Bryan M. Willman (bryanwi) 30-Apr-1991
    Scott Birrell (ScottBi) 6-Jun-1991

Environment:

    callable from Kernel or user mode.

Revision History:

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlpNtOpenKey)
#pragma alloc_text(PAGE,RtlpNtCreateKey)
#pragma alloc_text(PAGE,RtlpNtQueryValueKey)
#pragma alloc_text(PAGE,RtlpNtSetValueKey)
#pragma alloc_text(PAGE,RtlpNtMakeTemporaryKey)
#pragma alloc_text(PAGE,RtlpNtEnumerateSubKey)
#endif

#define REG_INVALID_ATTRIBUTES (OBJ_EXCLUSIVE | OBJ_PERMANENT)



//
// Temporary Registry User APIs.
//
// NOTE:  These are temporary implementations.  Although there is no code
// within that requires these API to be implemented as system services, the
// eventual replacements for these routines will use the Object Manager and
// hence require to be system services.
//


NTSTATUS
RtlpNtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Options
    )

/*++

Routine Description:

    This function opens a key in the Registry.  The key must already exist.

Arguments:

    KeyHandle - Receives a value called a Handle which is used to access
        the specified key in the Registration Database.

    DesiredAccess - Specifies the Accesses desired

        REG_KEY_READ - Generic Read access to key
          REG_KEY_QUERY_VALUE - Query Key's value
        REG_KEY_WRITE - Generic Write access to key
          REG_KEY_SET_VALUE - Set Key's value

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory
        is specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry, that
        is, all names beginning "\Registry".  RootHandle, if present, must
        be a handle to "\", or "\Registry", or a key under "\Registry".

    Options - REG_OPTION_READ_FUZZY - Allow Read access on handle even if
        it is open for Read/Write access.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - The open was successful.

        STATUS_INVALID_PARAMETER - A parameter other that object name was
            invalid.

        STATUS_OBJECT_NAME_INVALID - The key name has invalid syntax

        STATUS_OBJECT_NAME_NOT_FOUND - No key of the given name exists

        STATUS_ACCESS_DENIED - Caller does not have the requested access
            to the specified key.
--*/

{
    RTL_PAGED_CODE();

    if (ARGUMENT_PRESENT(ObjectAttributes)) {
        ObjectAttributes->Attributes &= ~(REG_INVALID_ATTRIBUTES);
    }

    return( NtOpenKey( KeyHandle,
                       DesiredAccess,
                       ObjectAttributes
                       ) );

    DBG_UNREFERENCED_PARAMETER( Options );
}


NTSTATUS
RtlpNtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Options,
    IN PUNICODE_STRING Provider,
    OUT OPTIONAL PULONG Disposition
    )

/*++

Routine Description:

    This function creates or opens the specified key in the Registry.  If
    the key does not exist, it is created.  If the key already exists, it
    is opened.

Arguments:

    KeyHandle - Receives a value called a Handle which is used to access
        the specified key in the Registration Database.

    DesiredAccess - Specifies the Accesses desired

        REG_KEY_READ - Generic Read access to key
          REG_KEY_QUERY_VALUE - Query Key's value
        REG_KEY_WRITE - Generic Write access to key
          REG_KEY_SET_VALUE - Set Key's value

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory
        is specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry, that
        is, all names beginning "\Registry".  RootHandle, if present, must
        be a handle to "\", or "\Registry", or a key under "\Registry".


    Options - REG_OPTION_READ_FUZZY - Allow Read access on handle even if it is
                                      open for READ_WRITE access.

              REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Provider - This parameter is reserved for future use and must currently
        be set to NULL.  It will be used in the future to specify the name of
        the provider to be used for operations on this node and its descendant
        nodes.

    Disposition - This optional parameter is a pointer to a variable that
        will receive a value indicating whether a new Registry key was
        created or an existing one opened.

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - The open was successful.

        STATUS_INVALID_PARAMETER - A parameter other that object name was
--*/

{
    RTL_PAGED_CODE();

    if (ARGUMENT_PRESENT(ObjectAttributes)) {
        ObjectAttributes->Attributes &= ~(REG_INVALID_ATTRIBUTES);
    }


    return(NtCreateKey( KeyHandle,
                        DesiredAccess,
                        ObjectAttributes,
                        0,                          //TitleIndex
                        NULL,                       //Class OPTIONAL,
                        REG_OPTION_NON_VOLATILE,    //CreateOptions,
                        Disposition
                        ) );

    DBG_UNREFERENCED_PARAMETER( Options );
    DBG_UNREFERENCED_PARAMETER( Provider );
}



NTSTATUS
RtlpNtQueryValueKey(
    IN HANDLE KeyHandle,
    OUT OPTIONAL PULONG KeyValueType,
    OUT OPTIONAL PVOID KeyValue,
    IN OUT OPTIONAL PULONG KeyValueLength,
    OUT OPTIONAL PLARGE_INTEGER LastWriteTime
    )

/*++

Routine Description:

    This function queries the value of a key.

Arguments:

    KeyHandle - Handle of a key opened for GENERIC_READ access via NtOpenKey.

    KeyValueType - Optional pointer to variable that will receive the
        client-defined type of the key value (if any).  If no value has been
        set for the key, 0 is returned.

    KeyValue - Optional pointer to buffer in which part or all of the key's
        value (as set on the most recent call to NtSetValueKey) will be
        returned.  If the key's value is too large to fit into the supplied
        buffer, as much of the value as will fit into the buffer will be
        returned and the warning STATUS_BUFFER_OVERFLOW is returned.  If no
        value has ever been set, nothing is returned.  If NULL is specified
        for this parameter, no Key Value is returned.

    KeyValueLength - On input, this optional parameter points to a variable
        that contains the length in bytes of the KeyValue buffer (if any).  If
        no KeyValue buffer is specified, the variable content on entry is
        ignored.  On return, the referenced variable (if any) receives the
        FULL length in bytes of the key value.  If the key's value is too
        large to fit into the supplied buffer, as much of the value as will
        fit into the buffer will be returned and the warning
        STATUS_BUFFER_OVERFLOW is returned.

        The returned length is intended for use by calling code in allocating
        a buffer of sufficient size to hold the key's value.  After receiving
        STATUS_BUFFER_OVERFLOW from NtQueryValueKey, calling code may make a
        subsequent call to NtQueryValueKey with a buffer of size equal to the
        length returned by the prior call.

        If no value has been set for the key, 0 is returned.

    LastWriteTime - Optional parameter to variable which receives a time stamp
        specifying the last time that the key was written.

Return Value:

    NTSTATUS - Result code

        STATUS_SUCCESS - Call was successful

        STATUS_INVALID_PARAMETER - Invalid parameter

        STATUS_ACCESS_DENIED - Caller does not have GENERIC_READ access to
            the specified key

        STATUS_BUFFER_OVERFLOW - This is a warning that the key's value
            is too large for the buffer specified by the KeyValue and
            KeyValueLength parameters.  Use the length returned to
            determine the size of buffer to allocate for a subsequent
            call of NtQueryValueKey.

--*/

{

    UNICODE_STRING NullName;
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInformation;
    ULONG ValueLength;

    RTL_PAGED_CODE();

    //
    // Compute the size of the buffer needed to hold the key value information.
    //

    ValueLength = 0;
    if (ARGUMENT_PRESENT(KeyValueLength)) {
        ValueLength = *KeyValueLength;
    }

    ValueLength += FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
    ValueInformation = RtlAllocateHeap(RtlProcessHeap(), 0, ValueLength);
    if (ValueInformation == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the key value.
    //

    NullName.Length = 0;
    Status = NtQueryValueKey(KeyHandle,
                             &NullName,
                             KeyValuePartialInformation,
                             ValueInformation,
                             ValueLength,
                             &ValueLength);

    //
    // Temporary hack to allow query of "" attribute when it hasn't
    // yet been set.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = STATUS_SUCCESS;
        ValueInformation->DataLength = 0;
        ValueInformation->Type = 0;
    }

    //
    // If requested return the key value length and the key type.
    //

    if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW)) {
        if (ARGUMENT_PRESENT(KeyValueLength)) {
            *KeyValueLength = ValueInformation->DataLength;
        }

        if (ARGUMENT_PRESENT(KeyValueType)) {
            *KeyValueType = ValueInformation->Type;
        }
    }

    //
    // If the query was successful and buffer overflow did not occur, then
    // return the key value information.
    //

    if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(KeyValue)) {
        RtlCopyMemory(KeyValue,
                      &ValueInformation->Data[0],
                      ValueInformation->DataLength);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, ValueInformation);
    return Status;
}

NTSTATUS
RtlpNtSetValueKey(
    IN HANDLE KeyHandle,
    IN ULONG KeyValueType,
    IN OPTIONAL PVOID KeyValue,
    IN ULONG KeyValueLength
    )

/*++

Routine Description:

    This function sets the type and value of a key.

Arguments:

    KeyHandle - Specifies a handle of the key whose type and value are to
        be set.  The key must have been opened with GENERIC_WRITE access.

    KeyValueType - This is a value that the client of the registry defines to
        distinguish different client-defined types of data value stored
        with the key.  When setting the value of a key that has previously
        had a Type and Value stored, the Type may be changed.

    KeyValue - Optional pointer to the data to be optionally stored as the
        value of the key.  If NULL is specified for this parameter, only
        the value type will be written.

    KeyValueLength - Specifies the length in bytes of the data to be stored as
        the key's value.  A zero value indicates that no data is being stored:
        if zero is specified, the Value parameter will be ignored.

Return Value:

    NTSTATUS - Result code.  The following values are returned

        STATUS_SUCCESS - The call was successful

        STATUS_INVALID_PARAMETER - Invalid Parameter(s)
--*/

{
    UNICODE_STRING NullName;
    NullName.Length = 0;

    RTL_PAGED_CODE();

    return( NtSetValueKey( KeyHandle,
                           &NullName,       // ValueName
                           0,               // TitleIndex
                           KeyValueType,
                           KeyValue,
                           KeyValueLength
                           ) );
}



NTSTATUS
RtlpNtMakeTemporaryKey(
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This function makes a Registry key temporary.  The key will be deleted
    when the last handle to it is closed.

Arguments:

    KeyHandle - Specifies the handle of the Key.  This is also the handle
        of the key's directory.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified handle is invalid.

        STATUS_ACCESS_DENIED - The specified handle does not specify delet
            access.

--*/

{
    RTL_PAGED_CODE();

    return( NtDeleteKey(KeyHandle) );
}


NTSTATUS
RtlpNtEnumerateSubKey(
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING SubKeyName,
    IN ULONG Index,
    OUT PLARGE_INTEGER LastWriteTime
    )

/*++

Routine Description:

    This function finds the name of the next sub key of a given key.  By
    making successive calls, all of the sub keys of a key can be determined.


Arguments:

    KeyHandle - Handle of the key whose sub keys are to be enumerated.

    SubKeyName - Pointer to a Unicode String in which the name of the sub
        key will be returned.

    Index - Specifies the (ZERO-based) number of the sub key to be returned.


    LastWriteTime - Receives the time stamp that specifies when the key
        was last written.

Return Value:

    NTSTATUS - Result code

        STATUS_SUCCESS - The call succeeded

        STATUS_INVALID_PARAMETER - Invalid parameter

        STATUS_NO_MORE_ENTRIES - There is no key having the specified index

        STATUS_BUFFER_OVERFLOW - The buffer of the output string was not
            large enough to hold the next sub-key name. SubKeyName->Length
            contains the number of bytes required.

        STATUS_NO_MEMORY - There was not sufficient heap to perform the
            requested operation.

--*/

{
    NTSTATUS Status;
    PKEY_BASIC_INFORMATION KeyInformation = NULL;
    ULONG LocalBufferLength, ResultLength;

    RTL_PAGED_CODE();

    LocalBufferLength = 0;
    if (SubKeyName->MaximumLength > 0) {

        LocalBufferLength = SubKeyName->MaximumLength +
                            FIELD_OFFSET(KEY_BASIC_INFORMATION, Name);
        KeyInformation = RtlAllocateHeap( RtlProcessHeap(), 0,
                                          LocalBufferLength
                                          );
        if (KeyInformation == NULL) {
            return(STATUS_NO_MEMORY);
        }
    }

    Status = NtEnumerateKey( KeyHandle,
                             Index,
                             KeyBasicInformation,    //KeyInformationClass
                             (PVOID)KeyInformation,
                             LocalBufferLength,
                             &ResultLength
                             );

    if (NT_SUCCESS(Status) && (KeyInformation != NULL)) {

        if ( SubKeyName->MaximumLength >= KeyInformation->NameLength) {

            SubKeyName->Length = (USHORT)KeyInformation->NameLength;

            RtlCopyMemory( SubKeyName->Buffer,
                           &KeyInformation->Name[0],
                           SubKeyName->Length
                           );
        } else {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    //
    // Return the length required if we failed due to a small buffer
    //

    if (Status == STATUS_BUFFER_OVERFLOW) {
        SubKeyName->Length = (USHORT)(ResultLength -
                                      FIELD_OFFSET(KEY_BASIC_INFORMATION, Name));
    }


    //
    // Free up any memory we allocated
    //

    if (KeyInformation != NULL) {

        RtlFreeHeap( RtlProcessHeap(), 0,
                     KeyInformation
                     );
    }


    return(Status);

    DBG_UNREFERENCED_PARAMETER( LastWriteTime );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\remlock.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#define RTL_REMOVE_LOCK_SIG     'COLR'

#if DBG
typedef struct _RTL_REMOVE_LOCK_TRACKING_BLOCK {
    struct _RTL_REMOVE_LOCK_TRACKING_BLOCK * Link;
    PVOID           Tag;
    LARGE_INTEGER   TimeLocked;
    PCSTR           File;
    ULONG           Line;
} RTL_REMOVE_LOCK_TRACKING_BLOCK, *PRTL_REMOVE_LOCK_TRACKING_BLOCK;
#endif


typedef struct _RTL_REMOVE_LOCK {
    LONG        Signature;
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    LONG        IoCount;
    KEVENT      RemoveEvent;
#if DBG
    LONG        HighWatermark;
    LONG        MaxLockedMinutes;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    RTL_REMOVE_LOCK_TRACKING_BLOCK Blocks;
#endif
} RTL_REMOVE_LOCK, *PRTL_REMOVE_LOCK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\regutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    This file contains support routines for accessing the registry.

Author:

    Steve Wood (stevewo) 15-Apr-1992

Revision History:

--*/

#include "ntrtlp.h"
#include <ctype.h>

NTSTATUS
RtlpGetRegistryHandle(
    IN ULONG RelativeTo,
    IN PCWSTR KeyName,
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    );

NTSTATUS
RtlpQueryRegistryDirect(
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN OUT PVOID Destination
    );

NTSTATUS
RtlpCallQueryRegistryRoutine(
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    IN OUT PULONG PKeyValueInfoLength,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    );

PVOID
RtlpAllocDeallocQueryBuffer(
   IN OUT SIZE_T    *PAllocLength            OPTIONAL,
   IN     PVOID      OldKeyValueInformation  OPTIONAL,
   IN     SIZE_T     OldAllocLength          OPTIONAL,
      OUT NTSTATUS  *pStatus                 OPTIONAL
    );

NTSTATUS
RtlpInitCurrentUserString(
    OUT PUNICODE_STRING UserString
    );


NTSTATUS
RtlpGetTimeZoneInfoHandle(
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlpGetRegistryHandle)
#pragma alloc_text(PAGE,RtlpQueryRegistryDirect)
#pragma alloc_text(PAGE,RtlpCallQueryRegistryRoutine)
#pragma alloc_text(PAGE,RtlpAllocDeallocQueryBuffer)
#pragma alloc_text(PAGE,RtlQueryRegistryValues)
#pragma alloc_text(PAGE,RtlWriteRegistryValue)
#pragma alloc_text(PAGE,RtlCheckRegistryKey)
#pragma alloc_text(PAGE,RtlCreateRegistryKey)
#pragma alloc_text(PAGE,RtlDeleteRegistryValue)
#pragma alloc_text(PAGE,RtlExpandEnvironmentStrings_U)
#pragma alloc_text(PAGE,RtlFormatCurrentUserKeyPath)
#pragma alloc_text(PAGE,RtlGetNtGlobalFlags)
#pragma alloc_text(PAGE,RtlpInitCurrentUserString)
#pragma alloc_text(PAGE,RtlOpenCurrentUser)
#pragma alloc_text(PAGE,RtlpGetTimeZoneInfoHandle)
#pragma alloc_text(PAGE,RtlQueryTimeZoneInformation)
#pragma alloc_text(PAGE,RtlSetTimeZoneInformation)
#pragma alloc_text(PAGE,RtlSetActiveTimeBias)
#endif

extern  const PWSTR RtlpRegistryPaths[ RTL_REGISTRY_MAXIMUM ];

NTSTATUS
RtlpGetRegistryHandle(
    IN ULONG RelativeTo,
    IN PCWSTR KeyName,
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
    UNICODE_STRING KeyPath;
    UNICODE_STRING CurrentUserKeyPath;
    BOOLEAN OptionalPath;

    if (RelativeTo & RTL_REGISTRY_HANDLE) {
        *Key = (HANDLE)KeyName;
        return STATUS_SUCCESS;
    }

    if (RelativeTo & RTL_REGISTRY_OPTIONAL) {
        RelativeTo &= ~RTL_REGISTRY_OPTIONAL;
        OptionalPath = TRUE;
    } else {
        OptionalPath = FALSE;
    }

    if (RelativeTo >= RTL_REGISTRY_MAXIMUM) {
        return STATUS_INVALID_PARAMETER;
    }

    KeyPath.Buffer = KeyPathBuffer;
    KeyPath.Length = 0;
    KeyPath.MaximumLength = sizeof( KeyPathBuffer );
    if (RelativeTo != RTL_REGISTRY_ABSOLUTE) {
        if (RelativeTo == RTL_REGISTRY_USER &&
            NT_SUCCESS( RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath ) )
           ) {
            Status = RtlAppendUnicodeStringToString( &KeyPath, &CurrentUserKeyPath );
            RtlFreeUnicodeString( &CurrentUserKeyPath );
        } else {
            Status = RtlAppendUnicodeToString( &KeyPath, RtlpRegistryPaths[ RelativeTo ] );
        }

        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        Status = RtlAppendUnicodeToString( &KeyPath, L"\\" );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }
    }

    Status = RtlAppendUnicodeToString( &KeyPath, KeyName );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }


    //
    // Use a kernel-mode handle for the registry key to prevent
    // malicious apps from hijacking it.
    //
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );
    if (WriteAccess) {
        Status = ZwCreateKey( Key,
                              GENERIC_WRITE,
                              &ObjectAttributes,
                              0,
                              (PUNICODE_STRING) NULL,
                              0,
                              NULL
                            );
    } else {
        Status = ZwOpenKey( Key,
                            MAXIMUM_ALLOWED | GENERIC_READ,
                            &ObjectAttributes
                          );
    }

    return Status;
}

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )

//
// This is the maximum MaximumLength for a UNICODE_STRING that still leaves
// room for a UNICODE_NULL.
//
#define MAX_NONNULL_USTRING ( MAX_USTRING - sizeof(UNICODE_NULL) )

//
// Return a registry value for RTL_QUERY_REGISTRY_DIRECT.
// For string values, ValueLength includes the UNICODE_NULL.
// Truncate string values if they don't fit within a UNICODE_STRING.
//
NTSTATUS
RtlpQueryRegistryDirect(
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN OUT PVOID Destination
    )
{

    if (ValueType == REG_SZ ||
        ValueType == REG_EXPAND_SZ ||
        ValueType == REG_MULTI_SZ
       ) {
        PUNICODE_STRING DestinationString;
        USHORT TruncValueLength;

        //
        // Truncate ValueLength to be represented in a UNICODE_STRING
        //
        if ( ValueLength <= MAX_USTRING ) {
            TruncValueLength = (USHORT)ValueLength;
        } else {
            TruncValueLength = MAX_USTRING;

#if DBG
            DbgPrint("RtlpQueryRegistryDirect: truncating SZ Value length: %x -> %x\n",
                     ValueLength, TruncValueLength);
#endif //DBG
        }

        DestinationString = (PUNICODE_STRING)Destination;
        if (DestinationString->Buffer == NULL) {

            DestinationString->Buffer = RtlAllocateStringRoutine( TruncValueLength );
            if (!DestinationString->Buffer) {
                return STATUS_NO_MEMORY;
            }
            DestinationString->MaximumLength = TruncValueLength;
        } else if (TruncValueLength > DestinationString->MaximumLength) {
                return STATUS_BUFFER_TOO_SMALL;
        }

        RtlCopyMemory( DestinationString->Buffer, ValueData, TruncValueLength );
        DestinationString->Length = (TruncValueLength - sizeof(UNICODE_NULL));

    } else if (ValueLength <= sizeof( ULONG )) {
        RtlCopyMemory( Destination, ValueData, ValueLength );

    } else {
        PULONG DestinationLength;

        DestinationLength = (PULONG)Destination;
        if ((LONG)*DestinationLength < 0) {
            ULONG n = -(LONG)*DestinationLength;

            if (n < ValueLength) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            RtlCopyMemory( DestinationLength, ValueData, ValueLength );

        } else {
            if (*DestinationLength < (2 * sizeof(*DestinationLength) + ValueLength)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *DestinationLength++ = ValueLength;
            *DestinationLength++ = ValueType;
            RtlCopyMemory( DestinationLength, ValueData, ValueLength );
        }
    }

    return STATUS_SUCCESS;
}

#define QuadAlignPtr(P) (             \
    (PVOID)((((ULONG_PTR)(P)) + 7) & (-8)) \
)

NTSTATUS
RtlpCallQueryRegistryRoutine(
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    IN OUT PULONG PKeyValueInfoLength,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    )

/*++

Routine Description:

    This function implements the caller out the a caller specified
    routine.  It is reponsible for capturing the arguments for the
    routine and then calling it.  If not specifically disabled, this
    routine will converted REG_EXPAND_SZ Registry values to REG_SZ by
    calling RtlExpandEnvironmentStrings_U prior to calling the routine.
    It will also converted REG_MULTI_SZ registry values into multiple
    REG_SZ calls to the specified routine.

    N.B. UNICODE_STRINGs cannot handle strings exceeding MAX_USTRING bytes. This creates
    issues both for expansion and for returning queries.  Whenever this limitation
    is a encountered, we punt as best we can -- often returning an unexpanded, or perhaps
    truncated stream -- since this seems to create fewer problems for our callers than
    if we unexpectedly fail.

Arguments:

    QueryTable - specifies the current query table entry.

    KeyValueInformation - points to a buffer that contains the information
        about the current registry value.

    PKeyValueInfoLength - pointer to the maximum length of the KeyValueInformation
        buffer.  This function will use the
        unused portion at the end of this buffer for storing null terminated
        value name strings and the expanded version of REG_EXPAND_SZ values.
        PKeyValueInfoLength returns an estimate of the space required if
        STATUS_BUFFER_TOO_SMALL is returned.  This estimate can be used to retry
        with a larger buffer. Two retries may be required if REG_EXPAND_SZ is specified.

    Context - specifies a 32-bit quantity that is passed uninterpreted to
        each QueryRoutine called.

    Environment - optional parameter, that if specified is the environment
        used when expanding variable values in REG_EXPAND_SZ registry
        values.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    ULONG ValueType;
    PWSTR ValueName;
    PVOID ValueData;
    ULONG ValueLength;
    PWSTR s;
    PCHAR FreeMem;
    PCHAR EndFreeMem;
    LONG  FreeMemSize;
    ULONG KeyValueInfoLength;
    int   retries;


    //
    // Return 0 length unless we return STATUS_BUFFER_TOO_SMALL.
    //
    KeyValueInfoLength = *PKeyValueInfoLength;
    *PKeyValueInfoLength = 0;

    //
    // the registry has signaled no data for this value
    //
    if( KeyValueInformation->DataOffset == (ULONG)-1 ) {
        //
        // Return success unless this is a required value.
        //
        if ( QueryTable->Flags & RTL_QUERY_REGISTRY_REQUIRED ) {
           return STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
           return STATUS_SUCCESS;
        }
    }

    //
    // Initially assume the entire KeyValueInformation buffer is unused.
    //

    FreeMem = (PCHAR)KeyValueInformation;
    FreeMemSize = KeyValueInfoLength;
    EndFreeMem = FreeMem + FreeMemSize;

    if (KeyValueInformation->Type == REG_NONE ||
        (KeyValueInformation->DataLength == 0 &&
         KeyValueInformation->Type == QueryTable->DefaultType)
       ) {

        //
        // If there is no registry value then see if they want to default
        // this value.
        //
        if (QueryTable->DefaultType == REG_NONE) {
            //
            // No default value specified.  Return success unless this is
            // a required value.
            //
            if ( QueryTable->Flags & RTL_QUERY_REGISTRY_REQUIRED ) {
               return STATUS_OBJECT_NAME_NOT_FOUND;
            } else {
               return STATUS_SUCCESS;
            }
        }

        //
        // Default requested.  Setup the value data pointers from the
        // information in the table entry.
        //

        ValueName = QueryTable->Name,
        ValueType = QueryTable->DefaultType;
        ValueData = QueryTable->DefaultData;
        ValueLength = QueryTable->DefaultLength;
        if (ValueLength == 0) {
            //
            // If the length of the value is zero, then calculate the
            // actual length for REG_SZ, REG_EXPAND_SZ and REG_MULTI_SZ
            // value types.
            //

            s = (PWSTR)ValueData;
            if (ValueType == REG_SZ || ValueType == REG_EXPAND_SZ) {
                while (*s++ != UNICODE_NULL) {
                }
                ValueLength = (ULONG)((PCHAR)s - (PCHAR)ValueData);

            } else if (ValueType == REG_MULTI_SZ) {
                while (*s != UNICODE_NULL) {
                    while (*s++ != UNICODE_NULL) {
                        }
                    }
                ValueLength = (ULONG)((PCHAR)s - (PCHAR)ValueData) + sizeof( UNICODE_NULL );
            }
        }

    } else {
        if (!(QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT)) {
            LONG ValueSpaceNeeded;

            //
            // There is a registry value.  Calculate a pointer to the
            // free memory at the end of the value information buffer,
            // and its size.
            //
            if (KeyValueInformation->DataLength) {
                FreeMem += KeyValueInformation->DataOffset +
                           KeyValueInformation->DataLength;
            } else {
                FreeMem += FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) +
                           KeyValueInformation->NameLength;
            }
            FreeMem = (PCHAR)QuadAlignPtr(FreeMem);
            FreeMemSize = (ULONG) (EndFreeMem - FreeMem);

            //
            // See if there is room in the free memory area for a null
            // terminated copy of the value name string.  If not return
            // the length we require (so far) and an error.
            //
            ValueSpaceNeeded = KeyValueInformation->NameLength + sizeof(UNICODE_NULL);
            if ( FreeMemSize < ValueSpaceNeeded ) {

               *PKeyValueInfoLength = (ULONG)(((PCHAR)FreeMem - (PCHAR)KeyValueInformation) + ValueSpaceNeeded);
                return STATUS_BUFFER_TOO_SMALL;
            }

            //
            // There is room, so copy the string, and null terminate it.
            //

            ValueName = (PWSTR)FreeMem;
            RtlCopyMemory( ValueName,
                           KeyValueInformation->Name,
                           KeyValueInformation->NameLength
                         );
            *(PWSTR)((PCHAR)ValueName + KeyValueInformation->NameLength) = UNICODE_NULL;

            //
            // Update the free memory pointer and size to reflect the space we
            // just used for the null terminated value name.
            //
            FreeMem += ValueSpaceNeeded;
            FreeMem = (PCHAR)QuadAlignPtr(FreeMem);
            FreeMemSize = (LONG) (EndFreeMem - FreeMem);

        } else {
            ValueName = QueryTable->Name;
        }

        //
        // Get the remaining data for the registry value.
        //

        ValueType = KeyValueInformation->Type;
        ValueData = (PCHAR)KeyValueInformation + KeyValueInformation->DataOffset;
        ValueLength = KeyValueInformation->DataLength;
    }

    //
    // Unless specifically disabled for this table entry, preprocess
    // registry values of type REG_EXPAND_SZ and REG_MULTI_SZ
    //

    if (!(QueryTable->Flags & RTL_QUERY_REGISTRY_NOEXPAND)) {
        if (ValueType == REG_MULTI_SZ) {
            PWSTR ValueEnd;

            //
            // For REG_MULTI_SZ value type, call the query routine once
            // for each null terminated string in the registry value.  Fake
            // like this is multiple REG_SZ values with the same value name.
            //

            Status = STATUS_SUCCESS;
            ValueEnd = (PWSTR)((PCHAR)ValueData + ValueLength) - sizeof(UNICODE_NULL);
            s = (PWSTR)ValueData;
            while (s < ValueEnd) {
                while (*s++ != UNICODE_NULL) {
                }

                ValueLength = (ULONG)((PCHAR)s - (PCHAR)ValueData);
                if (QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT) {
                    Status = RtlpQueryRegistryDirect( REG_SZ,
                                                      ValueData,
                                                      ValueLength,
                                                      QueryTable->EntryContext
                                                    );
                    (PUNICODE_STRING)(QueryTable->EntryContext) += 1;

                } else {
                    Status = (QueryTable->QueryRoutine)( ValueName,
                                                         REG_SZ,
                                                         ValueData,
                                                         ValueLength,
                                                         Context,
                                                         QueryTable->EntryContext
                                                       );
                }

                //
                // We ignore failures where the buffer is too small.
                //
                if (Status == STATUS_BUFFER_TOO_SMALL) {
                   Status = STATUS_SUCCESS;
                }

                if (!NT_SUCCESS( Status )) {
                    break;
                }

                ValueData = (PVOID)s;
            }

            return Status;
        }

        //
        // If requested, expand the Value -- but only if the unexpanded value
        // can be represented with a UNICODE_STRING.
        //
        if ((ValueType == REG_EXPAND_SZ) &&
            (ValueLength >= sizeof(WCHAR)) &&
            (ValueLength <= MAX_NONNULL_USTRING)) {
            //
            // For REG_EXPAND_SZ value type, expand any environment variable
            // references in the registry value string using the Rtl function.
            //

            UNICODE_STRING Source;
            UNICODE_STRING Destination;
            PWCHAR  Src;
            ULONG   SrcLength;
            ULONG   RequiredLength;
            BOOLEAN PercentFound;

            //
            // Don't expand unless we have to since expansion doubles buffer usage.
            //

            PercentFound = FALSE;
            SrcLength = ValueLength - sizeof(WCHAR);
            Src = (PWSTR)ValueData;
            while (SrcLength) {
                if (*Src == L'%') {
                    PercentFound = TRUE;
                    break;
                }
                Src++;
                SrcLength -= sizeof(WCHAR);
            }

            if ( PercentFound ) {
                Source.Buffer = (PWSTR)ValueData;
                Source.MaximumLength = (USHORT)ValueLength;
                Source.Length = (USHORT)(Source.MaximumLength - sizeof(UNICODE_NULL));
                Destination.Buffer = (PWSTR)FreeMem;
                Destination.Length = 0;

                if (FreeMemSize <= 0) {
                    Destination.MaximumLength = 0;
                } else if (FreeMemSize <= MAX_USTRING) {
                    Destination.MaximumLength = (USHORT)FreeMemSize;
                    Destination.Buffer[FreeMemSize/sizeof(WCHAR) - 1] = UNICODE_NULL;
                } else {
                    Destination.MaximumLength = MAX_USTRING;
                    Destination.Buffer[MAX_USTRING/sizeof(WCHAR) - 1] = UNICODE_NULL;
                }

                Status = RtlExpandEnvironmentStrings_U( Environment,
                                                        &Source,
                                                        &Destination,
                                                        &RequiredLength
                                                      );
                ValueType = REG_SZ;

                if ( NT_SUCCESS(Status) ) {
                    ValueData = Destination.Buffer;
                    ValueLength = Destination.Length + sizeof( UNICODE_NULL );
                } else {
                    if (Status == STATUS_BUFFER_TOO_SMALL) {
                       *PKeyValueInfoLength = (ULONG)((PCHAR)FreeMem - (PCHAR)KeyValueInformation) + RequiredLength;
                    }
//#if DBG
                    if (Status == STATUS_BUFFER_TOO_SMALL) {
                       DbgPrint( "RTL: Expand variables for %wZ failed - Status == %lx Size %x > %x <%x>\n",
                                     &Source, Status, *PKeyValueInfoLength, KeyValueInfoLength,
                                     Destination.MaximumLength );
                    } else {
                       DbgPrint( "RTL: Expand variables for %wZ failed - Status == %lx\n", &Source, Status );
                    }
//#endif  // DBG
                    if ( Status == STATUS_BUFFER_OVERFLOW ||
                         Status == STATUS_BUFFER_TOO_SMALL &&
                        ( Destination.MaximumLength == MAX_USTRING
                         || RequiredLength > MAX_NONNULL_USTRING ) ) {

                       // We can't do variable expansion because the required buffer can't be described
                       // by a UNICODE_STRING, so we silently ignore expansion.
//#if DBG
                       DbgPrint("RtlpCallQueryRegistryRoutine: skipping expansion.  Status=%x RequiredLength=%x\n",
                         Status, RequiredLength);
//#endif //DBG
                   } else {
                        return Status;
                   }
                }
            }
        }
//#if DBG
        else if (ValueType == REG_EXPAND_SZ  &&  ValueLength > MAX_NONNULL_USTRING) {
            DbgPrint("RtlpCallQueryRegistryRoutine: skipping environment expansion.  ValueLength=%x\n",
                     ValueLength);
        }
//#endif //DBG
    }

    //
    // No special process of the registry value required so just call
    // the query routine.
    //
    if (QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT) {
        Status = RtlpQueryRegistryDirect( ValueType,
                                          ValueData,
                                          ValueLength,
                                          QueryTable->EntryContext
                                        );
    } else {
        Status = (QueryTable->QueryRoutine)( ValueName,
                                             ValueType,
                                             ValueData,
                                             ValueLength,
                                             Context,
                                             QueryTable->EntryContext
                                           );

    }

    //
    // At this point we fail silently if the buffer is too small.
    //
    if (Status == STATUS_BUFFER_TOO_SMALL) {
        Status = STATUS_SUCCESS;
    }
    return Status;
}

//
// Most of the registry queries in the kernel are small (40-50 bytes).
// User queries use ZwAllocateVirtualMemory, so nothing less than a page will do.
//
#ifdef NTOS_KERNEL_RUNTIME
#if defined(ALLOC_DATA_PRAGMA)
#pragma const_seg("PAGECONST")
#endif
const SIZE_T RtlpRegistryQueryInitialBuffersize = 0x80 + sizeof(PVOID);
#else
const SIZE_T RtlpRegistryQueryInitialBuffersize = PAGE_SIZE;
#endif

//
// Allocate, Free, or Free/Allocate space for registry queries.
//
PVOID
RtlpAllocDeallocQueryBuffer(
   IN OUT SIZE_T    *PAllocLength            OPTIONAL,
   IN     PVOID      OldKeyValueInformation  OPTIONAL,
   IN     SIZE_T     OldAllocLength          OPTIONAL,
      OUT NTSTATUS  *pStatus                 OPTIONAL
   )
{
   PVOID    Ptr     = NULL;
   NTSTATUS Status  = STATUS_SUCCESS;

#ifdef NTOS_KERNEL_RUNTIME

   //
   // Kernel version
   //

   UNREFERENCED_PARAMETER( OldAllocLength );

   if ( ARGUMENT_PRESENT(OldKeyValueInformation) ) {
      ExFreePool( OldKeyValueInformation );
   }

   if ( ARGUMENT_PRESENT(PAllocLength) ) {
      Ptr = ExAllocatePoolWithTag( PagedPool, *PAllocLength, 'vrqR' );
      if (Ptr == NULL) {
         Status = STATUS_NO_MEMORY;
      }
   }

#else

   //
   // User version
   //

   if ( ARGUMENT_PRESENT(OldKeyValueInformation) ) {
       Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                     &OldKeyValueInformation,
                                     &OldAllocLength,
                                     MEM_RELEASE );
   }

   if ( ARGUMENT_PRESENT(PAllocLength) ) {

       Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                     &Ptr,
                                     0,
                                     PAllocLength,
                                     MEM_COMMIT,
                                     PAGE_READWRITE );
       if (!NT_SUCCESS(Status)) {
          Ptr = NULL;
       }
   }

#endif

   if ( ARGUMENT_PRESENT(pStatus) ) {
      *pStatus = Status;
   }

   return Ptr;
}

NTSTATUS
RtlQueryRegistryValues(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PRTL_QUERY_REGISTRY_TABLE QueryTable,
    IN PVOID Context,
    IN PVOID Environment OPTIONAL
    )

/*++

Routine Description:

    This function allows the caller to query multiple values from the registry
    sub-tree with a single call.  The caller specifies an initial key path,
    and a table.  The table contains one or more entries that describe the
    key values and subkey names the caller is interested in.  This function
    starts at the initial key and enumerates the entries in the table.  For
    each entry that specifies a value name or subkey name that exists in
    the registry, this function calls the caller's query routine associated
    with each table entry.  The caller's query routine is passed the value
    name, type, data and data length, to do with what they wish.

Arguments:

    RelativeTo - specifies that the Path parameter is either an absolute
        registry path, or a path relative to a predefined key path.  The
        following values are defined:

        RTL_REGISTRY_ABSOLUTE   - Path is an absolute registry path
        RTL_REGISTRY_SERVICES   - Path is relative to \Registry\Machine\System\CurrentControlSet\Services
        RTL_REGISTRY_CONTROL    - Path is relative to \Registry\Machine\System\CurrentControlSet\Control
        RTL_REGISTRY_WINDOWS_NT - Path is relative to \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
        RTL_REGISTRY_DEVICEMAP  - Path is relative to \Registry\Machine\Hardware\DeviceMap
        RTL_REGISTRY_USER       - Path is relative to \Registry\User\CurrentUser

        RTL_REGISTRY_OPTIONAL   - Bit that specifies the key referenced by
                                  this parameter and the Path parameter is
                                  optional.

        RTL_REGISTRY_HANDLE     - Bit that specifies that the Path parameter
                                  is actually a registry handle to use.
                                  optional.

    Path - specifies either an absolute registry path, or a path relative to the
        known location specified by the RelativeTo parameter.  If the the
        RTL_REGISTRY_HANDLE flag is specified, then this parameter is a
        registry handle to use directly.

    QueryTable - specifies a table of one or more value names and subkey names
        that the caller is interested.  Each table entry contains a query routine
        that will be called for each value name that exists in the registry.
        The table is terminated when a NULL table entry is reached.  A NULL
        table entry is defined as a table entry with a NULL QueryRoutine
        and a NULL Name field.

        QueryTable entry fields:

        PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine - This routine is
            called with the name, type, data and data length of a
            registry value.  If this field is NULL, then it marks the
            end of the table.

        ULONG Flags - These flags control how the following fields are
            interpreted.  The following flags are defined:

            RTL_QUERY_REGISTRY_SUBKEY - says the Name field of this
                table entry is another path to a registry key and all
                following table entries are for that key rather than the
                key specified by the Path parameter.  This change in
                focus lasts until the end of the table or another
                RTL_QUERY_REGISTRY_SUBKEY entry is seen or
                RTL_QUERY_REGISTRY_TOPKEY entry is seen.  Each such
                entry must specify a path that is relative to the Path
                specified on the call to this function.

            RTL_QUERY_REGISTRY_TOPKEY - resets the current registry key
                handle to the original one specified by the RelativeTo
                and Path parameters.  Useful for getting back to the
                original node after descending into subkeys with the
                RTL_QUERY_REGISTRY_SUBKEY flag.

            RTL_QUERY_REGISTRY_REQUIRED - specifies that this value is
                required and if not found then STATUS_OBJECT_NAME_NOT_FOUND
                is returned.  For a table entry that specifies a NULL
                name so that this function will enumerate all of the
                value names under a key, STATUS_OBJECT_NAME_NOT_FOUND
                will be returned only if there are no value keys under
                the current key.

            RTL_QUERY_REGISTRY_NOVALUE - specifies that even though
                there is no Name field for this table entry, all the
                caller wants is a call back, it does NOT want to
                enumerate all the values under the current key.  The
                query routine is called with NULL for ValueData,
                REG_NONE for ValueType and zero for ValueLength.

            RTL_QUERY_REGISTRY_NOEXPAND - specifies that if the value
                type of this registry value is REG_EXPAND_SZ or
                REG_MULTI_SZ, then this function is NOT to do any
                preprocessing of the registry values prior to calling
                the query routine.  Default behavior is to expand
                environment variable references in REG_EXPAND_SZ
                values and to enumerate the NULL terminated strings
                in a REG_MULTI_SZ value and call the query routine
                once for each, making it look like multiple REG_SZ
                values with the same ValueName.

            RTL_QUERY_REGISTRY_DIRECT QueryRoutine field ignored.
                EntryContext field points to location to store value.
                For null terminated strings, EntryContext points to
                UNICODE_STRING structure that that describes maximum
                size of buffer.  If .Buffer field is NULL then a buffer
                is allocated.

            RTL_QUERY_REGISTRY_DELETE Used to delete value keys after
                they are queried.

        PWSTR Name - This field gives the name of a Value the caller
            wants to query the value of.  If this field is NULL, then
            the QueryRoutine specified for this table entry is called
            for all values associated with the current registry key.

        PVOID EntryContext - This field is an arbitrary 32-bit field
            that is passed uninterpreted to each QueryRoutine called.

        ULONG DefaultType
        PVOID DefaultData
        ULONG DefaultLength If there is no value name that matches the
            name given by the Name field, and the DefaultType field is
            not REG_NONE, then the QueryRoutine for this table entry is
            called with the contents of the following fields as if the
            value had been found in the registry.  If the DefaultType is
            REG_SZ, REG_EXPANDSZ or REG_MULTI_SZ and the DefaultLength
            is 0 then the value of DefaultLength will be computed based
            on the length of unicode string pointed to by DefaultData

    Context - specifies a 32-bit quantity that is passed uninterpreted to
        each QueryRoutine called.

    Environment - optional parameter, that if specified is the environment
        used when expanding variable values in REG_EXPAND_SZ registry
        values.

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    KeyPath, KeyValueName;
    HANDLE  Key, Key1;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    SIZE_T  KeyValueInfoLength;
    ULONG   ValueIndex;
    SIZE_T  AllocLength;
    ULONG   KeyResultLength;
    int     retries;

    RTL_PAGED_CODE();

    KeyValueInformation = NULL;

    Status = RtlpGetRegistryHandle( RelativeTo, Path, FALSE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if ((RelativeTo & RTL_REGISTRY_HANDLE) == 0) {
        RtlInitUnicodeString(&KeyPath, Path);
    } else {
        RtlInitUnicodeString(&KeyPath, NULL);
    }

    AllocLength = RtlpRegistryQueryInitialBuffersize;

    KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength, NULL, 0, &Status );
    if ( KeyValueInformation == NULL ) {
        if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
            ZwClose( Key );
        }
        return Status;
    }

    KeyValueInformation->DataOffset = 0;
    KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
    Key1 = Key;
    while (QueryTable->QueryRoutine != NULL ||
           (QueryTable->Flags & (RTL_QUERY_REGISTRY_SUBKEY | RTL_QUERY_REGISTRY_DIRECT))
          ) {

        if ((QueryTable->Flags & RTL_QUERY_REGISTRY_DIRECT) &&
            (QueryTable->Name == NULL ||
             (QueryTable->Flags & RTL_QUERY_REGISTRY_SUBKEY) ||
             QueryTable->QueryRoutine != NULL)
           ) {

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if (QueryTable->Flags & (RTL_QUERY_REGISTRY_TOPKEY | RTL_QUERY_REGISTRY_SUBKEY)) {
            if (Key1 != Key) {
                NtClose( Key1 );
                Key1 = Key;
            }
        }

        if (QueryTable->Flags & RTL_QUERY_REGISTRY_SUBKEY) {
            if (QueryTable->Name == NULL) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                RtlInitUnicodeString( &KeyPath, QueryTable->Name );
                //
                // Use a kernel-mode handle for the registry key to prevent
                // malicious apps from hijacking it.
                //
                InitializeObjectAttributes( &ObjectAttributes,
                                            &KeyPath,
                                            OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                            Key,
                                            NULL
                                            );

                Status = ZwOpenKey( &Key1,
                                    MAXIMUM_ALLOWED,
                                    &ObjectAttributes
                                  );
                if (NT_SUCCESS( Status )) {
                    if (QueryTable->QueryRoutine != NULL) {
                        goto enumvalues;
                    }
                }
            }

        } else if (QueryTable->Name != NULL) {
                RtlInitUnicodeString( &KeyValueName, QueryTable->Name );
                retries = 0;
    retryqueryvalue:
                //
                // A maximum of two retries is expected. If we see more we must
                // have miscomputed how much is required for the query buffer.
                //
                if (retries++ > 4) {
//#if DBG
                   DbgPrint("RtlQueryRegistryValues: Miscomputed buffer size at line %d\n", __LINE__);
//#endif
                   break;
                }

                Status = ZwQueryValueKey( Key1,
                                          &KeyValueName,
                                          KeyValueFullInformation,
                                          KeyValueInformation,
                                          (ULONG) KeyValueInfoLength,
                                          &KeyResultLength
                                        );
                //
                // ZwQueryValueKey returns overflow even though the problem is that
                // the specified buffer was too small, so we fix that up here so we
                // can decide correctly whether to retry or not below.
                //
                if (Status == STATUS_BUFFER_OVERFLOW) {
                   Status = STATUS_BUFFER_TOO_SMALL;
                }

                if (!NT_SUCCESS( Status )) {
                    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

                        KeyValueInformation->Type = REG_NONE;
                        KeyValueInformation->DataLength = 0;
                        KeyResultLength = (ULONG)KeyValueInfoLength;
                        Status = RtlpCallQueryRegistryRoutine( QueryTable,
                                                               KeyValueInformation,
                                                               &KeyResultLength,
                                                               Context,
                                                               Environment
                                                             );
                    }

                   if (Status == STATUS_BUFFER_TOO_SMALL) {
                        //
                        // Try to allocate a larger buffer as this is one humongous
                        // value.
                        //
                        AllocLength = KeyResultLength + sizeof(PVOID) + sizeof(UNICODE_NULL);
                        KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength,
                                                                           KeyValueInformation,
                                                                           AllocLength,
                                                                           &Status
                                                                         );
                        if ( KeyValueInformation == NULL) {
                           break;
                        }
                        KeyValueInformation->DataOffset = 0;
                        KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
                        goto retryqueryvalue;
                    }

                } else {
                    //
                    // KeyResultLength holds the length of the data returned by ZwQueryKeyValue.
                    // If this is a MULTI_SZ value, catenate a NUL.
                    //
                    if ( KeyValueInformation->Type == REG_MULTI_SZ ) {
                            *(PWCHAR) ((PUCHAR)KeyValueInformation + KeyResultLength) = UNICODE_NULL;
                            KeyValueInformation->DataLength += sizeof(UNICODE_NULL);
                    }

                    KeyResultLength = (ULONG)KeyValueInfoLength;
                    Status = RtlpCallQueryRegistryRoutine( QueryTable,
                                                           KeyValueInformation,
                                                           &KeyResultLength,
                                                           Context,
                                                           Environment
                                                         );

                    if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                         //
                         // Try to allocate a larger buffer as this is one humongous
                         // value.
                         //
                         AllocLength = KeyResultLength + sizeof(PVOID) + sizeof(UNICODE_NULL);
                         KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength,
                                                                            KeyValueInformation,
                                                                            AllocLength,
                                                                            &Status
                                                                          );
                         if ( KeyValueInformation == NULL) {
                            break;
                         }
                         KeyValueInformation->DataOffset = 0;
                         KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
                         goto retryqueryvalue;
                     }

                    //
                    // If requested, delete the value key after it has been successfully queried.
                    //

                    if (NT_SUCCESS( Status ) && QueryTable->Flags & RTL_QUERY_REGISTRY_DELETE) {
                        ZwDeleteValueKey (Key1, &KeyValueName);
                    }
                }

        } else if (QueryTable->Flags & RTL_QUERY_REGISTRY_NOVALUE) {
            Status = (QueryTable->QueryRoutine)( NULL,
                                                 REG_NONE,
                                                 NULL,
                                                 0,
                                                 Context,
                                                 QueryTable->EntryContext
                                               );
        } else {

        enumvalues:
            retries = 0;
            for (ValueIndex = 0; TRUE; ValueIndex++) {
                Status = ZwEnumerateValueKey( Key1,
                                              ValueIndex,
                                              KeyValueFullInformation,
                                              KeyValueInformation,
                                              (ULONG) KeyValueInfoLength,
                                              &KeyResultLength
                                            );
                //
                // ZwEnumerateValueKey returns overflow even though the problem is that
                // the specified buffer was too small, so we fix that up here so we
                // can decide correctly whether to retry or not below.
                //
                if (Status == STATUS_BUFFER_OVERFLOW) {
                   Status = STATUS_BUFFER_TOO_SMALL;
                }

                if (Status == STATUS_NO_MORE_ENTRIES) {
                    if (ValueIndex == 0 && (QueryTable->Flags & RTL_QUERY_REGISTRY_REQUIRED)) {
                       Status = STATUS_OBJECT_NAME_NOT_FOUND;
                    } else {
                        Status = STATUS_SUCCESS;
                    }
                    break;
                }

                if ( NT_SUCCESS( Status ) ) {

                    KeyResultLength = (ULONG)KeyValueInfoLength;
                    Status = RtlpCallQueryRegistryRoutine( QueryTable,
                                                           KeyValueInformation,
                                                           &KeyResultLength,
                                                           Context,
                                                           Environment
                                                         );
                }

                if (Status == STATUS_BUFFER_TOO_SMALL) {
                    //
                    // Allocate a larger buffer and try again.
                    //
                    AllocLength = KeyResultLength + sizeof(PVOID) + sizeof(UNICODE_NULL);
                    KeyValueInformation = RtlpAllocDeallocQueryBuffer( &AllocLength,
                                                                       KeyValueInformation,
                                                                       AllocLength,
                                                                       &Status
                                                                     );
                    if (KeyValueInformation == NULL) {
                       break;
                    }
                    KeyValueInformation->DataOffset = 0;
                    KeyValueInfoLength = AllocLength - sizeof(UNICODE_NULL);
                    ValueIndex -= 1;

                    //
                    // A maximum of two retries is expected per loop iteration.
                    // If we see more we must have miscomputed
                    // how much is required for the query buffer.
                    //
                    if (retries++ <= 4) {
                        continue;
                    }
//#if DBG
                    DbgPrint("RtlQueryRegistryValues: Miscomputed buffer size at line %d\n", __LINE__);
//#endif
                    break;
                }

                if (!NT_SUCCESS( Status )) {
                    break;
                }

                retries = 0;

                //
                // If requested, delete the value key after it has been successfully queried.
                // After deletion the current ValueIndex is for the next sub-key, so adjust it.
                // KeyValueInformation->NameLength should fit in a USHORT, but we don't check since
                // it only harms our caller.
                //

                if (QueryTable->Flags & RTL_QUERY_REGISTRY_DELETE) {
                    KeyValueName.Buffer = KeyValueInformation->Name;
                    KeyValueName.Length = (USHORT)KeyValueInformation->NameLength;
                    KeyValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;
                    Status = ZwDeleteValueKey( Key1,
                                               &KeyValueName
                                             );
                    if (NT_SUCCESS( Status )) {
                        ValueIndex -= 1;
                    }
                }
            }
        }

        if (!NT_SUCCESS( Status )) {
            break;
        }

        QueryTable++;
    }

    if (Key != NULL && !(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }

    if (Key1 != NULL && Key1 != Key) {
        ZwClose( Key1 );
    }

    //
    // Free any query buffer we allocated.
    //
    (void) RtlpAllocDeallocQueryBuffer( NULL, KeyValueInformation, AllocLength, NULL );
    return Status;
}


NTSTATUS
RtlWriteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyValueName;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    Status = ZwSetValueKey( Key,
                            &KeyValueName,
                            0,
                            ValueType,
                            ValueData,
                            ValueLength
                          );
    if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }

    return Status;
}


NTSTATUS
RtlCheckRegistryKey(
    IN ULONG RelativeTo,
    IN PWSTR Path
    )
{
    NTSTATUS Status;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, FALSE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    ZwClose( Key );
    return STATUS_SUCCESS;
}


NTSTATUS
RtlCreateRegistryKey(
    IN ULONG RelativeTo,
    IN PWSTR Path
    )
{
    NTSTATUS Status;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }
    return STATUS_SUCCESS;
}


NTSTATUS
RtlDeleteRegistryValue(
    IN ULONG RelativeTo,
    IN PCWSTR Path,
    IN PCWSTR ValueName
    )
{
    NTSTATUS Status;
    UNICODE_STRING KeyValueName;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetRegistryHandle( RelativeTo, Path, TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    Status = ZwDeleteValueKey( Key, &KeyValueName );

    if (!(RelativeTo & RTL_REGISTRY_HANDLE)) {
        ZwClose( Key );
    }
    return Status;
}


NTSTATUS
RtlExpandEnvironmentStrings_U(
    IN PVOID Environment OPTIONAL,
    IN PUNICODE_STRING Source,
    OUT PUNICODE_STRING Destination,
    OUT PULONG ReturnedLength OPTIONAL
    )
{
    NTSTATUS Status, Status1;
    PWCHAR Src, Src1, Dst;
    UNICODE_STRING VariableName, VariableValue;
    ULONG SrcLength, DstLength, VarLength, RequiredLength;

    RTL_PAGED_CODE();

    Src = Source->Buffer;
    SrcLength = Source->Length;
    Dst = Destination->Buffer;
    DstLength = Destination->MaximumLength;
    Status = STATUS_SUCCESS;
    RequiredLength = 0;
    while (SrcLength >= sizeof(WCHAR)) {
        if (*Src == L'%') {
            Src1 = Src + 1;
            VarLength = 0;
            VariableName.Length = 0;
            VariableName.Buffer = Src1;

            while (VarLength < (SrcLength - sizeof(WCHAR))) {
                if (*Src1 == L'%') {
                    if (VarLength) {
                        VariableName.Length = (USHORT)VarLength;
                        VariableName.MaximumLength = (USHORT)VarLength;
                    }
                    break;

                }

                Src1++;
                VarLength += sizeof(WCHAR);
            }

            if (VariableName.Length) {
                VariableValue.Buffer = Dst;
                VariableValue.Length = 0;
                VariableValue.MaximumLength = (USHORT)DstLength;
                Status1 = RtlQueryEnvironmentVariable_U( Environment,
                                                         &VariableName,
                                                         &VariableValue
                                                       );
                if (NT_SUCCESS( Status1 ) || Status1 == STATUS_BUFFER_TOO_SMALL) {
                    RequiredLength += VariableValue.Length;
                    Src = Src1 + 1;
                    SrcLength -= (VarLength + 2*sizeof(WCHAR));

                    if (NT_SUCCESS( Status1 )) {
                        DstLength -= VariableValue.Length;
                        Dst += VariableValue.Length / sizeof(WCHAR);

                    } else {
                        Status = Status1;
                    }

                    continue;
                }
            }
        }

        if (NT_SUCCESS( Status )) {
            if (DstLength > sizeof(WCHAR)) {
                DstLength -= sizeof(WCHAR);
                *Dst++ = *Src;

            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }

        RequiredLength += sizeof(WCHAR);
        SrcLength -= sizeof(WCHAR);
        Src++;
    }

    if (NT_SUCCESS( Status )) {
        if (DstLength) {
            DstLength -= sizeof(WCHAR);
            *Dst = UNICODE_NULL;

        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    RequiredLength += sizeof(WCHAR);

    if (ARGUMENT_PRESENT( ReturnedLength )) {
        *ReturnedLength = RequiredLength;
    }

    if (NT_SUCCESS( Status )) {
        Destination->Length = (USHORT)(RequiredLength - sizeof(WCHAR));
    }

    return Status;
}


ULONG
RtlGetNtGlobalFlags( VOID )
{
#ifdef NTOS_KERNEL_RUNTIME
    return NtGlobalFlag;
#else
    return NtCurrentPeb()->NtGlobalFlag;
#endif
}


//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES


NTSTATUS
RtlFormatCurrentUserKeyPath(
    OUT PUNICODE_STRING CurrentUserKeyPath
    )

/*++

Routine Description:

    Initialize the supplied buffer with a string representation
    of the current user's SID.

Arguments:

    CurrentUserKeyPath - Returns a string that represents the current
        user's root key in the Registry.  Caller must call
        RtlFreeUnicodeString to free the buffer when done with it.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS if the user string was
        succesfully initialized.

--*/

{
    HANDLE TokenHandle;
    UCHAR TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG ReturnLength;
    ULONG SidStringLength ;
    UNICODE_STRING SidString ;
    NTSTATUS Status;

    Status = ZwOpenThreadTokenEx( NtCurrentThread(),
                                 TOKEN_READ,
                                 TRUE,
                                 OBJ_KERNEL_HANDLE,
                                 &TokenHandle
                                );

    if ( !NT_SUCCESS( Status ) && ( Status != STATUS_NO_TOKEN ) ) {
        return Status;
    }

    if ( !NT_SUCCESS( Status ) ) {

        Status = ZwOpenProcessTokenEx( NtCurrentProcess(),
                                       TOKEN_READ,
                                       OBJ_KERNEL_HANDLE,
                                       &TokenHandle
                                     );
        if ( !NT_SUCCESS( Status )) {
            return Status;
        }
    }

    Status = ZwQueryInformationToken( TokenHandle,
                                      TokenUser,
                                      TokenInformation,
                                      sizeof( TokenInformation ),
                                      &ReturnLength
                                    );

    ZwClose( TokenHandle );

    if ( !NT_SUCCESS( Status )) {
        return Status;
    }

    Status = RtlLengthSidAsUnicodeString(
                        ((PTOKEN_USER)TokenInformation)->User.Sid,
                        &SidStringLength
                        );

    if ( !NT_SUCCESS( Status ) ) {
        return Status ;
    }

    CurrentUserKeyPath->Length = 0;
    CurrentUserKeyPath->MaximumLength = (USHORT)(SidStringLength +
                                        sizeof( L"\\REGISTRY\\USER\\" ) +
                                        sizeof( UNICODE_NULL ));
    CurrentUserKeyPath->Buffer = (RtlAllocateStringRoutine)( CurrentUserKeyPath->MaximumLength );
    if (CurrentUserKeyPath->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Copy "\REGISTRY\USER" to the current user string.
    //

    RtlAppendUnicodeToString( CurrentUserKeyPath, L"\\REGISTRY\\USER\\" );

    SidString.MaximumLength = (USHORT)SidStringLength ;
    SidString.Length = 0 ;
    SidString.Buffer = CurrentUserKeyPath->Buffer +
            (CurrentUserKeyPath->Length / sizeof(WCHAR) );

    Status = RtlConvertSidToUnicodeString( &SidString,
                                           ((PTOKEN_USER)TokenInformation)->User.Sid,
                                           FALSE
                                         );
    if ( !NT_SUCCESS( Status )) {
        RtlFreeUnicodeString( CurrentUserKeyPath );

    } else {
        CurrentUserKeyPath->Length += SidString.Length ;
    }

    return Status;
}


NTSTATUS
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CURRENT_USER predefined handle.

Arguments:

    DesiredAccess - Specifies the access to open the key for.

    CurrentUserKey - Returns a handle to the key \REGISTRY\USER\*.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING      CurrentUserKeyPath;
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    RTL_PAGED_CODE();

    //
    // Format the registry path for the current user.
    //

    Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
    if ( NT_SUCCESS(Status) ) {

        InitializeObjectAttributes( &Obja,
                                    &CurrentUserKeyPath,
                                    OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE|OBJ_FORCE_ACCESS_CHECK,
                                    NULL,
                                    NULL
                                  );
        Status = ZwOpenKey( CurrentUserKey,
                            DesiredAccess,
                            &Obja
                          );
        RtlFreeUnicodeString( &CurrentUserKeyPath );
    }

    if ( !NT_SUCCESS(Status) ) {
        //
        // Opening \REGISTRY\USER\<SID> failed, try \REGISTRY\USER\.DEFAULT
        //
        RtlInitUnicodeString( &CurrentUserKeyPath, RtlpRegistryPaths[ RTL_REGISTRY_USER ] );
        InitializeObjectAttributes( &Obja,
                                    &CurrentUserKeyPath,
                                    OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE|OBJ_FORCE_ACCESS_CHECK,
                                    NULL,
                                    NULL
                                  );

        Status = ZwOpenKey( CurrentUserKey,
                            DesiredAccess,
                            &Obja
                          );

    }

    return Status;
}


NTSTATUS
RtlpGetTimeZoneInfoHandle(
    IN BOOLEAN WriteAccess,
    OUT PHANDLE Key
    )
{
    return RtlpGetRegistryHandle( RTL_REGISTRY_CONTROL, L"TimeZoneInformation", WriteAccess, Key );
}



extern  const WCHAR szBias[];
extern  const WCHAR szStandardName[];
extern  const WCHAR szStandardBias[];
extern  const WCHAR szStandardStart[];
extern  const WCHAR szDaylightName[];
extern  const WCHAR szDaylightBias[];
extern  const WCHAR szDaylightStart[];

NTSTATUS
RtlQueryTimeZoneInformation(
    OUT PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    )
{
    NTSTATUS Status;
    HANDLE Key;
    UNICODE_STRING StandardName, DaylightName;
    RTL_QUERY_REGISTRY_TABLE RegistryConfigurationTable[ 8 ];

    RTL_PAGED_CODE();

    Status = RtlpGetTimeZoneInfoHandle( FALSE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    RtlZeroMemory( TimeZoneInformation, sizeof( *TimeZoneInformation ) );
    RtlZeroMemory( RegistryConfigurationTable, sizeof( RegistryConfigurationTable ) );

    RegistryConfigurationTable[ 0 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 0 ].Name = (PWSTR)szBias;
    RegistryConfigurationTable[ 0 ].EntryContext = &TimeZoneInformation->Bias;


    StandardName.Buffer = TimeZoneInformation->StandardName;
    StandardName.Length = 0;
    StandardName.MaximumLength = sizeof( TimeZoneInformation->StandardName );
    RegistryConfigurationTable[ 1 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 1 ].Name = (PWSTR)szStandardName;
    RegistryConfigurationTable[ 1 ].EntryContext = &StandardName;

    RegistryConfigurationTable[ 2 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 2 ].Name = (PWSTR)szStandardBias;
    RegistryConfigurationTable[ 2 ].EntryContext = &TimeZoneInformation->StandardBias;

    RegistryConfigurationTable[ 3 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 3 ].Name = (PWSTR)szStandardStart;
    RegistryConfigurationTable[ 3 ].EntryContext = &TimeZoneInformation->StandardStart;
    *(PLONG)(RegistryConfigurationTable[ 3 ].EntryContext) = -(LONG)sizeof( TIME_FIELDS );

    DaylightName.Buffer = TimeZoneInformation->DaylightName;
    DaylightName.Length = 0;
    DaylightName.MaximumLength = sizeof( TimeZoneInformation->DaylightName );
    RegistryConfigurationTable[ 4 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 4 ].Name = (PWSTR)szDaylightName;
    RegistryConfigurationTable[ 4 ].EntryContext = &DaylightName;

    RegistryConfigurationTable[ 5 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 5 ].Name = (PWSTR)szDaylightBias;
    RegistryConfigurationTable[ 5 ].EntryContext = &TimeZoneInformation->DaylightBias;

    RegistryConfigurationTable[ 6 ].Flags = RTL_QUERY_REGISTRY_DIRECT;
    RegistryConfigurationTable[ 6 ].Name = (PWSTR)szDaylightStart;
    RegistryConfigurationTable[ 6 ].EntryContext = &TimeZoneInformation->DaylightStart;
    *(PLONG)(RegistryConfigurationTable[ 6 ].EntryContext) = -(LONG)sizeof( TIME_FIELDS );

    Status = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE,
                                     (PWSTR)Key,
                                     RegistryConfigurationTable,
                                     NULL,
                                     NULL
                                   );
    ZwClose( Key );
    return Status;
}


NTSTATUS
RtlSetTimeZoneInformation(
    IN PRTL_TIME_ZONE_INFORMATION TimeZoneInformation
    )
{
    NTSTATUS Status;
    HANDLE Key;

    RTL_PAGED_CODE();

    Status = RtlpGetTimeZoneInfoHandle( TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                    (PWSTR)Key,
                                    szBias,
                                    REG_DWORD,
                                    &TimeZoneInformation->Bias,
                                    sizeof( TimeZoneInformation->Bias )
                                  );
    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szStandardName,
                                        REG_SZ,
                                        TimeZoneInformation->StandardName,
                                        (wcslen( TimeZoneInformation->StandardName ) + 1) * sizeof( WCHAR )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szStandardBias,
                                        REG_DWORD,
                                        &TimeZoneInformation->StandardBias,
                                        sizeof( TimeZoneInformation->StandardBias )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szStandardStart,
                                        REG_BINARY,
                                        &TimeZoneInformation->StandardStart,
                                        sizeof( TimeZoneInformation->StandardStart )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szDaylightName,
                                        REG_SZ,
                                        TimeZoneInformation->DaylightName,
                                        (wcslen( TimeZoneInformation->DaylightName ) + 1) * sizeof( WCHAR )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szDaylightBias,
                                        REG_DWORD,
                                        &TimeZoneInformation->DaylightBias,
                                        sizeof( TimeZoneInformation->DaylightBias )
                                      );
    }

    if (NT_SUCCESS( Status )) {
        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        szDaylightStart,
                                        REG_BINARY,
                                        &TimeZoneInformation->DaylightStart,
                                        sizeof( TimeZoneInformation->DaylightStart )
                                      );
    }

    ZwClose( Key );
    return Status;
}


NTSTATUS
RtlSetActiveTimeBias(
    IN LONG ActiveBias
    )
{
    NTSTATUS Status;
    HANDLE Key;
    RTL_QUERY_REGISTRY_TABLE RegistryConfigurationTable[ 2 ];
    LONG CurrentActiveBias;

    RTL_PAGED_CODE();

    Status = RtlpGetTimeZoneInfoHandle( TRUE, &Key );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    RtlZeroMemory( RegistryConfigurationTable, sizeof( RegistryConfigurationTable ) );
    RegistryConfigurationTable[ 0 ].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    RegistryConfigurationTable[ 0 ].Name = L"ActiveTimeBias";
    RegistryConfigurationTable[ 0 ].EntryContext = &CurrentActiveBias;

    Status = RtlQueryRegistryValues( RTL_REGISTRY_HANDLE,
                                     (PWSTR)Key,
                                     RegistryConfigurationTable,
                                     NULL,
                                     NULL
                                   );

    if ( !NT_SUCCESS(Status) || CurrentActiveBias != ActiveBias ) {

        Status = RtlWriteRegistryValue( RTL_REGISTRY_HANDLE,
                                        (PWSTR)Key,
                                        L"ActiveTimeBias",
                                        REG_DWORD,
                                        &ActiveBias,
                                        sizeof( ActiveBias )
                                      );
    }

    ZwClose( Key );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\remlock.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <ntos.h>

#include <remlock.h>

#define MinutesToTicks(x) \
        (ULONGLONG) KeQueryTimeIncrement() * \
        10 * \
        1000 * \
        1000 * \
        60 * \
        x
// 10 -> microseconds, 1000 -> miliseconds, 1000 -> seconds, 60 -> minutes

// LIST_ENTRY RtlpRemoveLockList;

NTSYSAPI
PRTL_REMOVE_LOCK
NTAPI
RtlAllocateRemoveLock(
    IN  ULONG   MaxLockedMinutes,
    IN  ULONG   AllocateTag,
    IN  ULONG   HighWatermark
    )
/*++

Routine Description:

    This routine is called to initialize the remove lock for a device object.

--*/
{
    PRTL_REMOVE_LOCK lock;

    lock = ExAllocatePoolWithTag (NonPagedPool,
                                  sizeof (RTL_REMOVE_LOCK),
                                  AllocateTag);

    if (lock) {

        lock->Signature = RTL_REMOVE_LOCK_SIG;
        lock->Removed = FALSE;
        lock->IoCount = 1;
        KeInitializeEvent(&lock->RemoveEvent, SynchronizationEvent, FALSE);
#if DBG
        lock->HighWatermark = HighWatermark;
        lock->MaxLockedMinutes = MaxLockedMinutes;
        lock->AllocateTag = AllocateTag;
        KeInitializeSpinLock (&lock->Spin);
        lock->Blocks.Link = NULL;
#endif
    }

    return lock;
}


NTSYSAPI
NTSTATUS
NTAPI
RtlAcquireRemoveLockEx(
    IN PRTL_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID   Tag,
    IN PCSTR            File,
    IN ULONG            Line
    )

/*++

Routine Description:

    This routine is called to acquire the remove lock for a device object.
    While the lock is held, the caller can assume that no pending pnp REMOVE
    requests will be completed.

    The lock should be acquired immediately upon entering a dispatch routine.
    It should also be acquired before creating any new reference to the
    device object if there's a chance of releasing the reference before the
    new one is done.

Arguments:

    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.

    Tag - Used for tracking lock allocation and release.  If an irp is
          specified when acquiring the lock then the same Tag must be
          used to release the lock before the Tag is completed.

    File - set to __FILE__ as the location in the code where the lock was taken.

    Line - set to __LINE__.

Return Value:

    Returns whether or not the remove lock was obtained.
    If successful the caller should continue with work calling
    RtlReleaseRemoveLock when finished.

    If not successful the lock was not obtained.  The caller should abort the
    work but not call RtlReleaseRemoveLock.

--*/

{
    LONG        lockValue;
    NTSTATUS    status;

#if DBG
    PRTL_REMOVE_LOCK_TRACKING_BLOCK trackingBlock;
#endif

    //
    // Grab the remove lock
    //

    lockValue = InterlockedIncrement(&RemoveLock->IoCount);

    ASSERTMSG("RtlAcquireRemoveLock - lock value was negative : ",
              (lockValue > 0));

    ASSERTMSG("RemoveLock increased to meet LockHighWatermark",
              ((0 == RemoveLock->HighWatermark) ||
               (lockValue <= RemoveLock->HighWatermark)));

    if (! RemoveLock->Removed) {

#if DBG
        trackingBlock = ExAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(RTL_REMOVE_LOCK_TRACKING_BLOCK),
                            RemoveLock->AllocateTag);

        RtlZeroMemory (trackingBlock,
                       sizeof (RTL_REMOVE_LOCK_TRACKING_BLOCK));

        if (NULL == trackingBlock) {

            ASSERTMSG ("insufficient resources", FALSE);

        } else {

            KIRQL oldIrql;

            trackingBlock->Tag = Tag;
            trackingBlock->File = File;
            trackingBlock->Line = Line;

            KeQueryTickCount(&trackingBlock->TimeLocked);

            KeAcquireSpinLock (&RemoveLock->Spin, &oldIrql);
            trackingBlock->Link = RemoveLock->Blocks.Link;
            RemoveLock->Blocks.Link = trackingBlock;
            KeReleaseSpinLock(&RemoveLock->Spin, oldIrql);
        }
#endif

        status = STATUS_SUCCESS;

    } else {

        if (0 == InterlockedDecrement (&RemoveLock->IoCount)) {
            KeSetEvent (&RemoveLock->RemoveEvent, 0, FALSE);
        }
        status = STATUS_DELETE_PENDING;
    }

    return status;
}


NTSYSAPI
VOID
NTAPI
RtlReleaseRemoveLock(
    IN PRTL_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag
    )

/*++

Routine Description:

    This routine is called to release the remove lock on the device object.  It
    must be called when finished using a previously locked reference to the
    device object.  If an Tag was specified when acquiring the lock then the
    same Tag must be specified when releasing the lock.

    When the lock count reduces to zero, this routine will signal the waiting
    event to release the waiting thread deleting the device object protected
    by this lock.

Arguments:

    DeviceObject - the device object to lock

    Tag - The tag (if any) specified when acquiring the lock.  This is used
          for lock tracking purposes

Return Value:

    none

--*/

{
    LONG            lockValue;

#if DBG
    KIRQL           oldIrql;
    LARGE_INTEGER   difference;
    BOOLEAN         found;
    LONGLONG        maxTime;

    PRTL_REMOVE_LOCK_TRACKING_BLOCK last;
    PRTL_REMOVE_LOCK_TRACKING_BLOCK current;

    //
    // Check the tick count and make sure this thing hasn't been locked
    // for more than MaxLockedMinutes.
    //

    found = FALSE;
    KeAcquireSpinLock(&RemoveLock->Spin, &oldIrql);
    last = (&RemoveLock->Blocks);
    current = last->Link;
    //
    // Note the first one is the sentinal
    //

    while (NULL != current) {

        KeQueryTickCount((&difference));
        difference.QuadPart -= current->TimeLocked.QuadPart;
        maxTime = MinutesToTicks (RemoveLock->MaxLockedMinutes);

        if (maxTime && (maxTime < difference.QuadPart)) {

            KdPrint(("RtlReleaseRemoveLock: Lock %#08lx (tag %#08lx) locked "
                     "for %I64d ticks - TOO LONG\n",
                     RemoveLock,
                     current->Tag,
                     difference.QuadPart));

            KdPrint(("RtlReleaseRemoveLock: Lock acquired in file "
                     "%s on line %d\n",
                     current->File,
                     current->Line));
            ASSERT(FALSE);
        }

        if ((!found) && (current->Tag == Tag)) {
            found = TRUE;
            last->Link = current->Link;
            ExFreePool (current);
                          current = last->Link;
            continue;
        }

        last = current;
        current = current->Link;
    }

    KeReleaseSpinLock(&RemoveLock->Spin, oldIrql);

    if (!found) {

        KdPrint (("RtlReleaseRemoveLock: Couldn't find Tag %#08lx "
                  "in the lock tracking list\n",
                  Tag));
        ASSERT(FALSE);
    }
#endif

    lockValue = InterlockedDecrement(&RemoveLock->IoCount);

    ASSERT(0 <= lockValue);

    if (0 == lockValue) {

        ASSERT (RemoveLock->Removed);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //

        KeSetEvent(&RemoveLock->RemoveEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    return;
}


NTSYSAPI
VOID
NTAPI
RtlReleaseRemoveLockAndWait (
    IN PRTL_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag
    )

/*++

Routine Description:

    This routine is called when the client would like to delete the remove-
    locked resource.
    This routine will block until all the remove locks have completed.

    This routine MUST be called after acquiring once more the lock.

Arguments:

    RemoveLock -

Return Value:

    none

--*/
{
    LONG    ioCount;

    PAGED_CODE ();

    RemoveLock->Removed = TRUE;

    ioCount = InterlockedDecrement (&RemoveLock->IoCount);
    ASSERT (0 < ioCount);

    if (0 < InterlockedDecrement (&RemoveLock->IoCount)) {
        KeWaitForSingleObject (&RemoveLock->RemoveEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
    }

#if DBG
    ASSERT (RemoveLock->Blocks.Link);
    if (Tag != RemoveLock->Blocks.Link->Tag) {
        KdPrint (("RtlRelaseRemoveLockAndWait last tag invalid %x %x\n",
                  Tag,
                  RemoveLock->Blocks.Link->Tag));

        ASSERT (Tag != RemoveLock->Blocks.Link->Tag);
    }

    ExFreePool (RemoveLock->Blocks.Link);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\rxact.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxact.c

Abstract:

    This Module implements a simple transaction mechanism for registry
    database operations which helps eliminate the possibility of partial
    updates being made.  The cases covered are specifically partial updates
    caused by system crashes or program aborts during multiple-write updates.


    WARNING:  This package does not yet deal with full-disk problems
              automatically.  If a full disk is encountered during
              transaction commit, then manual interaction may be required
              to free enough space to complete the commit.  There is
              no means provided for backing out the commit.

Author:

    Jim Kelly       (JimK)     15-May-1991
    Robert Reichel  (RobertRe) 15-July-1992

Environment:

    Pure Runtime Library Routine

Revision History:



--*/


/*
////////////////////////////////////////////////////////////////////////////

High Level Description:

    The simple transaction mechanism expects the following to be true:

       (1) A single server is responsible for operations on an entire
           sub-tree of the registry database.  For example, the security
           account manager server (SAM) is responsible for everything
           below \REGISTRY\LOCAL_MACHINE\SECURITY\SAM.

       (2) Transactions on the sub-tree are serialized by the server
           responsible for the sub-tree.  That is, the server will not
           start a second user request until all previous user requests
           have been completed.

    The simple transaction mechanism helps eliminate the problem of partial
    updates caused by system crash or program abort during multiple-write
    updates to the registry database.  This is achieved by:

       (1) Keeping all actions in-memory until instructed to commit.  The
           presence of in-memory data structures implicitly indicates
           that a transaction is in progress.

           The initial state is no transaction in progress.

       (2) Providing a service which allows a server to initiate a transaction.
           This allocates in-memory data structures, thereby changing the
           state to transaction in progress.

       (3) Keeping a log of all keys in the sub-tree that are to be
           updated in a single transaction.  Each record in this log
           contains the following information:

                   (a) The name of the sub-key effected

                   (b) The operation to be performed on the sub-key
                       either DELETE or SET_VALUE.  Note that these
                       operations are idempotent and may be applied
                       again in the event that the server aborts during
                       an initial commit.

                   (c) The new value of the sub-key (if applicable)

                   (d) (optionally) The attribute name of the subkey
                       to be operated on.

                    (note that SET_VALUE is used to create new sub-keys
                     as well as updated existing ones).

            The entire list of sub-keys to be modified must be entered
            into this log before ANY of the sub-keys is actually modified.

       (4)  Providing a commit service that applies all changes indicated
            in the change log.  This is done by first writing the contents
            of the in-memory structures to a single key value ("Log") in
            the registry and flushing the data to disk.  The presence of
            the "Log" value and data imply that a commit is in progress.

            All necessary changes are applied, the "Log" value and its
            data are deleted, and in-memory data structres are freed,
            thereby changing the state to no-transaction.


    The package also includes a service which must be called upon server
    startup.  This service checks to make sure the state of the sub-tree
    is NO_TRANSACTION.  If it is not, then one of the actions below is
    performed based upon the current state of the sub-tree:

        COMMITTING - This means the server was previously aborted while
            a transaction was being committed (applied to the registry).
            In this case, the commit is performed again from the beginning
            of the change log.  After the commit is completed, the state
            of the sub-tree is set to NO_TRANSACTION.

////////////////////////////////////////////////////////////////////////////
*/



/*
////////////////////////////////////////////////////////////////////////////

Detailed Description:

    Registry State
    --------------

    The registry state of a subtree is kept in a sub-key of that tree
    named:

            "RXACT"

    The value field of that registry key includes a revision field.


    RXact Context
    -------------

    A call to RtlInitializeRXact will return a pointer to an
    RTL_RXACT_CONTEXT structure.  This structure contains:

    (1) the passed RootRegistryKey (eg, key to "Sam"),

    (2) a handle to the top of the RXact subtree (eg, key to
        "Sam\RXACT"),

    (3) a flag indicating if handles stored in the log are
        valid,

    (4) a pointer to the current RXactLog.

    The subsystem calling RtlInitializeRXact must keep this returned
    pointer and pass it back to RXact in all subsequent calls.


    Operation Log
    -------------

    The operation log of a registry sub-tree transaction is kept as sequence
    of "operation log entries".

    An in-memory log is a block of heap memory allocted by RtlStartRXact.
    It has a header which contains:

    (1) The count of operations in the log.

    (2) The maximum size of the log.

    (3) The amount of the log currently in use.

    The log data itself follows the header directly.


    Operation Log Entries
    ---------------------

    An operation log entry is described by the following structure:

    typedef struct _RXACT_LOG_ENTRY {
        ULONG LogEntrySize;
        RTL_RXACT_OPERATION Operation;
        UNICODE_STRING SubKeyName;       // Self-relativized (Buffer is really offset)
        UNICODE_STRING AttributeName;    // Self-relativized (Buffer is really offset)
        HANDLE KeyHandle;                // optional, not valid if read from disk.
        ULONG NewKeyValueType;
        ULONG NewKeyValueLength;
        PVOID NewKeyValue;               // Contains offset to data from start of log
    } RXACT_LOG_ENTRY, *PRXACT_LOG_ENTRY;

    The log entry contains all of the information passed in during a call
    to RtlAddActionToRXact or RtlAddAttributeActionToRXact.

    The UNICODE_STRING structures contain an offset to the string data
    rather than a pointer.  These offsets are relative to the start of
    the log data, and are adjusted in place as each log entry is commited.

    The KeyHandle is valid if it is not equal to INVALID_HANDLE_VALUE and
    if the HandlesValid flag in the RXactContext structure is TRUE.  This
    is so that we do not attempt to use the handles if the log has been
    read from disk after a reboot.


////////////////////////////////////////////////////////////////////////////
*/


#include "ntrtlp.h"

//
// Cannot include <windows.h> from kernel code
//
#define INVALID_HANDLE_VALUE (HANDLE)-1





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Local Macros & Definitions                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Revision level of a registry transaction .
//

#define RTLP_RXACT_REVISION1          (1l)
#define RTLP_RXACT_CURRENT_REVISION   RTLP_RXACT_REVISION1


#define RTLP_RXACT_KEY_NAME           L"RXACT"

#define RTLP_RXACT_LOG_NAME           L"Log"

#define RTLP_INITIAL_LOG_SIZE         0x4000

//
//  Given a value return its longword aligned equivalent value
//

#define DwordAlign(Value) (                       \
    (ULONG)((((ULONG)(Value)) + 3) & 0xfffffffc)  \
    )

//
// The value field of the RXACT registry key is one of the following data
// structures.
//

//
// The state of a registry sub-tree is one of the following:
//
//         RtlpRXactStateNoTransaction - There is not a transaction in progress.
//
//         RtlpRXactStateCommitting    - The actions of a transaction are being
//                                       applied to the registry database.
//

typedef enum _RTLP_RXACT_STATE {
    RtlpRXactStateNoTransaction = 2,
    RtlpRXactStateCommitting
} RTLP_RXACT_STATE, *PRTLP_RXACT_STATE;


typedef struct _RTLP_RXACT {
    ULONG Revision;
    RTLP_RXACT_STATE State;   // no longer used
    ULONG OperationCount;     // no longer used
} RTLP_RXACT, *PRTLP_RXACT;


typedef struct _RXACT_LOG_ENTRY {
    ULONG LogEntrySize;
    RTL_RXACT_OPERATION Operation;
    UNICODE_STRING SubKeyName;       // Self-relativized (Buffer is really offset)
    UNICODE_STRING AttributeName;    // Self-relativized (Buffer is really offset)
    HANDLE KeyHandle;                // optional, not valid if read from disk.
    ULONG NewKeyValueType;
    ULONG NewKeyValueLength;
    PVOID NewKeyValue;               // Contains offset to data from start of log
} RXACT_LOG_ENTRY, *PRXACT_LOG_ENTRY;




////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                      Prototypes for local procedures                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////




NTSTATUS
RXactpCommit(
    IN PRTL_RXACT_CONTEXT RXactContext
    );

NTSTATUS
RXactpOpenTargetKey(
    IN HANDLE RootRegistryKey,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    OUT PHANDLE TargetKey
    );



VOID
RXactInitializeContext(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN HANDLE RootRegistryKey,
    IN HANDLE RXactKey
    );


#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RXactpCommit)
#pragma alloc_text(PAGE,RXactpOpenTargetKey)
#pragma alloc_text(PAGE,RXactInitializeContext)
#pragma alloc_text(PAGE,RtlInitializeRXact)
#pragma alloc_text(PAGE,RtlStartRXact)
#pragma alloc_text(PAGE,RtlAbortRXact)
#pragma alloc_text(PAGE,RtlAddAttributeActionToRXact)
#pragma alloc_text(PAGE,RtlAddActionToRXact)
#pragma alloc_text(PAGE,RtlApplyRXact)
#pragma alloc_text(PAGE,RtlApplyRXactNoFlush)
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures   (defined in ntrtl.h)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
RtlInitializeRXact(
    IN HANDLE RootRegistryKey,
    IN BOOLEAN CommitIfNecessary,
    OUT PRTL_RXACT_CONTEXT *RXactContext
    )

/*++

Routine Description:

    This routine should be called by a server exactly once when it starts.
    This routine will check to see that the registry transaction information
    exists for the specified registry sub-tree, and will create it if it
    doesn't exist.

Arguments:

    RootRegistryKey - A handle to the registry key within whose sub-tree
        a transaction is to be initialized.

    CommitIfNecessary - A BOOLEAN value indicating whether or not any
        previously aborted commit discovered should be commited at this
        time.  A value of TRUE indicates the commit should be applied
        if encountered.  A value of FALSE indicates a previously
        aborted COMMIT should not be committed at this time.

    RXactContext - Returns a pointer to an RTL_RXACT_CONTEXT structure
        allocated out of the local heap.  The caller must keep this
        pointer and pass it back in for all future RXact transactions
        for the passed RootRegistryKey.


Return Value:

    STATUS_SUCCESS - Indicates the transaction state already exists for the
        registry sub-tree and is already in the NO_TRANSACTION state.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state already
        exists for the specified sub-tree, but is a revision level that is
        unknown by this service.

    STATUS_RXACT_STATE_CREATED - This informational level status indicates
        that a specified registry sub-tree transaction state did not yet
        exist and had to be created.

    STATUS_RXACT_COMMIT_NECESSARY - This warning level status indicates that the
        transaction state already exists for the registry sub-tree, but that
        a transaction commit was previously aborted.  The commit has NOT been
        completed.  Another call to this service with a CommitIfNecessary value
        of TRUE may be used to commit the transaction.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.

--*/

{

    HANDLE RXactKey;
    LARGE_INTEGER LastWriteTime;
    NTSTATUS Status, TmpStatus;
    OBJECT_ATTRIBUTES RXactAttributes;
    PKEY_VALUE_FULL_INFORMATION FullInformation;
    RTLP_RXACT RXactKeyValue;
    UCHAR BasicInformation[128];      // Should be more than long enough
    ULONG Disposition;
    ULONG KeyValueLength;
    ULONG KeyValueType;
    ULONG ResultLength;
    UNICODE_STRING RXactKeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING NullName;

    RTL_PAGED_CODE();

    //
    // Initialize some stuff
    //

    KeyValueLength = (ULONG)sizeof( RTLP_RXACT );
    KeyValueType   = 0;         // Not used by RXact

    RtlInitUnicodeString( &NullName, NULL );

    //
    // Create or open the RXACT key.
    //

    RtlInitUnicodeString( &RXactKeyName, RTLP_RXACT_KEY_NAME);

    InitializeObjectAttributes(
        &RXactAttributes,
        &RXactKeyName,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
        RootRegistryKey,
        NULL);

//    Status = RtlpNtCreateKey(
//                 &RXactKey,
//                 (KEY_READ | KEY_WRITE | DELETE),
//                 &RXactAttributes,
//                 0,
//                 NULL,
//                 &Disposition
//                 );

    Status = NtCreateKey( &RXactKey,
                          (KEY_READ | KEY_WRITE | DELETE),
                          &RXactAttributes,
                          0,                          //TitleIndex
                          NULL,                       //Class OPTIONAL,
                          REG_OPTION_NON_VOLATILE,    //CreateOptions,
                          &Disposition
                          );

    if ( !NT_SUCCESS(Status) ) {
        return(Status);
    }

    //
    // Allocate the RXactContext block
    //

    *RXactContext = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( RTL_RXACT_CONTEXT ));

    if ( *RXactContext == NULL ) {

        //
        // Something prevented value assignment...
        // Get rid of the RXact key and return the error
        //

        TmpStatus = NtDeleteKey( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group

        return( STATUS_NO_MEMORY );
    }

    //
    // Initialize the newly created RXactContext structure.
    //

    RXactInitializeContext( *RXactContext, RootRegistryKey, RXactKey );

    //
    // If we created (as opposed to opened an existing) rxact key,
    // then we need to initialize it.
    //

    if ( Disposition == REG_CREATED_NEW_KEY ) {

        RXactKeyValue.Revision       = RTLP_RXACT_REVISION1;

        Status = NtSetValueKey( RXactKey,
                                &NullName,       // ValueName
                                0,               // TitleIndex
                                KeyValueType,
                                &RXactKeyValue,
                                KeyValueLength
                                );

        if ( !NT_SUCCESS(Status) ) {

            //
            // Something prevented value assignment...
            // Get rid of the RXact key and return the error
            //

            TmpStatus = NtDeleteKey( RXactKey );
            ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
            TmpStatus = NtClose( RXactKey );
            ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group

            RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );

            return( Status );
        }

        return( STATUS_RXACT_STATE_CREATED );
    }



    //
    // We have opened an existing RXACT key.
    // See if it is a revision level we know about.
    //

    Status = RtlpNtQueryValueKey(
                 RXactKey,              // KeyHandle
                 &KeyValueType,         // KeyValueType
                 &RXactKeyValue,        // KeyValue
                 &KeyValueLength,       // KeyValueLength
                 &LastWriteTime         // LastWriteTime
                 );


    if ( !NT_SUCCESS(Status) ) {

        //
        // Something prevented value query...
        //

        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
        return( Status );
    }


    if ( KeyValueLength != (ULONG)sizeof(RTLP_RXACT) ) {
        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
        return( STATUS_UNKNOWN_REVISION );
    }

    if (RXactKeyValue.Revision != RTLP_RXACT_REVISION1) {
        TmpStatus = NtClose( RXactKey );
        ASSERT(NT_SUCCESS(TmpStatus)); //Safe to ignore, notify security group
        RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
        return( STATUS_UNKNOWN_REVISION );
    }



    //
    // Right revision...
    // See if there is a transaction or commit in progress.  If not,
    // return success
    //

    //
    // If a log file exists, then we are committing.
    //

    RtlInitUnicodeString( &ValueName, RTLP_RXACT_LOG_NAME );

    Status = NtQueryValueKey(
                 RXactKey,
                 &ValueName,
                 KeyValueBasicInformation,
                 &BasicInformation,
                 128,
                 &ResultLength
                 );

    if ( NT_SUCCESS( Status )) {

        //
        // We found a value called 'Log'.  This means that a commit
        // was in progress.
        //

        if ( CommitIfNecessary ) {

            //
            // Query the full value of the log, then call a low level routine
            // to actually perform the commit.
            //

            Status = NtQueryValueKey(
                         RXactKey,
                         &ValueName,
                         KeyValueFullInformation,
                         NULL,
                         0,
                         &ResultLength
                         );

            if ( Status != STATUS_BUFFER_TOO_SMALL ) {
                return( Status );
            }

            FullInformation = RtlAllocateHeap( RtlProcessHeap(), 0, ResultLength );

            if ( FullInformation == NULL ) {
                return( STATUS_NO_MEMORY );
            }


            Status = NtQueryValueKey(
                         RXactKey,
                         &ValueName,
                         KeyValueFullInformation,
                         FullInformation,
                         ResultLength,
                         &ResultLength
                         );

            if ( !NT_SUCCESS( Status )) {

                RtlFreeHeap( RtlProcessHeap(), 0, FullInformation );
                RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
                return( Status );
            }

            //
            // The log information is buried in the returned FullInformation
            // buffer.  Dig it out and make the RXactLog in the RXactContext
            // structure point to it.  Then commit.
            //

            (*RXactContext)->RXactLog = (PRTL_RXACT_LOG)((PCHAR)FullInformation + FullInformation->DataOffset);

            //
            // Don't use any handles we may find in the log file
            //

            (*RXactContext)->HandlesValid = FALSE;

            Status = RXactpCommit( *RXactContext );

            if ( !NT_SUCCESS( Status )) {

                RtlFreeHeap( RtlProcessHeap(), 0, FullInformation );
                RtlFreeHeap( RtlProcessHeap(), 0, *RXactContext );
                return( Status );
            }


            //
            // The commit was successful.  Clean up.
            // Delete the log file value and data
            //

            Status = NtDeleteValueKey( RXactKey, &ValueName );

            //
            // This should never fail
            //

            ASSERT( NT_SUCCESS( Status ));

            //
            // Get rid of the in memory data structures.  Abort
            // will free the RXactLog, so put what we want
            // freed in there and it will go away.
            //

            (*RXactContext)->RXactLog = (PRTL_RXACT_LOG)FullInformation;

            Status = RtlAbortRXact( *RXactContext );

            //
            // This should never fail
            //

            ASSERT( NT_SUCCESS( Status ));
            return( Status );
        } else {

            return( STATUS_RXACT_COMMIT_NECESSARY );
        }

    } else {

        //
        // No log, so nothing to do here.
        //

        return( STATUS_SUCCESS );
    }

}



VOID
RXactInitializeContext(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN HANDLE RootRegistryKey,
    IN HANDLE RXactKey
    )

/*++

Routine Description:

    Initializes an in-memory RXactContext structure.

Arguments:

    RXactContext - Supplies a pointer to an RXact Context created
        by RtlInitializeRXact.

    RootRegistryKey - Supplies the RootRegistryKey for this component.

    RXactKey - Supplies the {RootRegistryKey}\RXactKey for this component


Return Value:

    None.

--*/

{
    //
    // Initialize the RXactContext for this client
    //

    RXactContext->RootRegistryKey      = RootRegistryKey;
    RXactContext->HandlesValid         = TRUE;
    RXactContext->RXactLog             = NULL;
    RXactContext->RXactKey             = RXactKey;

    return;
}



NTSTATUS
RtlStartRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to start a new transaction in a registry sub-tree.
    Transactions must be serialized by the server so that only one transaction
    is in progress at a time.

Arguments:

    RXactContext - Supplies a pointer to an RTL_RXACT_CONTEXT structure
        that is not currently in use.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was started.

    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.

--*/
{
    PRTL_RXACT_LOG RXactLogHeader;

    RTL_PAGED_CODE();

    //
    // Allocate in-memory log file and initialize.  This implicitly
    // sets the state to 'transaction in progress'.
    //

    if ( RXactContext->RXactLog != NULL ) {

        //
        // There is already a transaction in progress for this
        // context.  Return an error.
        //

        return( STATUS_RXACT_INVALID_STATE );
    }

    RXactLogHeader = RtlAllocateHeap( RtlProcessHeap(), 0, RTLP_INITIAL_LOG_SIZE );

    if ( RXactLogHeader == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    //
    // Fill in the log header information at the top of the
    // newly allocated buffer.
    //


    RXactLogHeader->OperationCount = 0;
    RXactLogHeader->LogSize        = RTLP_INITIAL_LOG_SIZE;
    RXactLogHeader->LogSizeInUse   = sizeof( RTL_RXACT_LOG );

    RXactContext->RXactLog = RXactLogHeader;

    return( STATUS_SUCCESS );

}


NTSTATUS
RtlAbortRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to abort a transaction in a registry sub-tree.

Arguments:

    RootRegistryKey - A handle to the registry key within whose sub-tree
        the transaction is to be aborted.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was aborted.


    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.

--*/

{
    RTL_PAGED_CODE();

    if ( RXactContext->RXactLog == NULL ) {

        //
        // There is no transaction in progress for this
        // context.  Return an error.
        //

        return( STATUS_RXACT_INVALID_STATE );
    }

    (VOID) RtlFreeHeap( RtlProcessHeap(), 0, RXactContext->RXactLog );

    //
    // Reinitialize the RXactContext structure with the same initial data.
    //

    RXactInitializeContext(
        RXactContext,
        RXactContext->RootRegistryKey,
        RXactContext->RXactKey
        );


    return( STATUS_SUCCESS );

}



NTSTATUS
RtlAddAttributeActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle OPTIONAL,
    IN PUNICODE_STRING AttributeName,
    IN ULONG NewValueType,
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )

/*++

Routine Description:

    This routine is used to add a new action to the transaction operation log.
    Upon commit, these operations are applied in the order they are added
    to the log.

    This routine differs from RtlAddActionToRXact in that it takes an Attribute
    Name parameter, rather than using the default ("NULL") Attribute of the
    specified key.


Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

    Operation - Indicates the type of operation to perform (e.g., delete
        a sub-key or set the value of a sub-key).  Sub-keys may be created
        by setting a value of a previously non-existent sub-key.  This will
        cause all sub-keys between the root and the specified sub-key to
        be created.

    SubKeyName - Specifies the name of the target registry key.  This name
        is relative to the Root of the Registry transaction sub-tree
        and must NOT start with a delimiter character ("\").

    KeyHandle - Optionally supplies a handle to the target key.  If
        not specified, the name passed for SubKeyName will determine
        the target key.

    AttributeName - Supplies the name of the key attribute to be
        modified.

    NewKeyValueType - (Optional) Contains the KeyValueType to assign
        to the target registry key.  This parameter is ignored if the
        Operation is not RtlRXactOperationSetValue.

    NewKeyValue -  (Optional) Points to a buffer containing the value
        to assign to the specified target registry key.  This parameter
        is ignored if the Operation is not RtlRXactOperationSetValue.

    NewKeyValueLength - Indicates the length (number of bytes) of the
        NewKeyValue buffer.  This parameter is ignored if the Operation
        is not RtlRXactOperationSetValue.


Return Value:

    STATUS_SUCCESS - Indicates the request completed successfully..

    STATUS_INVALID_PARAMETER - Indicates that an unknown Operation
        was requested.

    STATUS_NO_MEMORY - Insufficient memeory was available to complete
        this operation.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


--*/

{

    PRTL_RXACT_LOG   NewLog;
    PRXACT_LOG_ENTRY Base;

    ULONG End;
    ULONG LogEntrySize;
    ULONG NewLogSize;

    RTL_PAGED_CODE();

    //
    // Make sure we were passed a legitimate operation.
    //

    if (  (Operation != RtlRXactOperationDelete)  &&
          (Operation != RtlRXactOperationSetValue)   ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Compute the total size of the new data
    //

    LogEntrySize = sizeof( RXACT_LOG_ENTRY )               +
                   DwordAlign( SubKeyName->Length )        +
                   DwordAlign( AttributeName->Length )     +
                   DwordAlign( NewValueLength );

    LogEntrySize = ALIGN_UP( LogEntrySize, PVOID );

    //
    // Make sure there is enough space in the current
    // log file for this data.  If not, we must create
    // a larger log, copy all the old data, and then
    // append this to the end.
    //

    if ( RXactContext->RXactLog->LogSizeInUse + LogEntrySize >
                                   RXactContext->RXactLog->LogSize ) {

        //
        // We must allocate a bigger log file.
        //

        NewLogSize = RXactContext->RXactLog->LogSize;

        do {

            NewLogSize = NewLogSize * 2;

        } while ( NewLogSize <
            ( RXactContext->RXactLog->LogSizeInUse + LogEntrySize ) );

        NewLog = RtlAllocateHeap( RtlProcessHeap(), 0, NewLogSize );

        if ( NewLog == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        //
        // Copy over previous information
        //

        RtlCopyMemory( NewLog, RXactContext->RXactLog, RXactContext->RXactLog->LogSizeInUse );

        //
        // Free the old log file
        //

        RtlFreeHeap( RtlProcessHeap(), 0, RXactContext->RXactLog );

        //
        // Install the new log file and adjust its size in its header
        //

        RXactContext->RXactLog = NewLog;
        RXactContext->RXactLog->LogSize = NewLogSize;
    }

    //
    // The log file is big enough, append data to
    // the end.
    //

    Base = (PRXACT_LOG_ENTRY)((PCHAR)(RXactContext->RXactLog) +
                             (RXactContext->RXactLog->LogSizeInUse));


    //
    // Append each parameter to the end of the log.  Unicode string data
    // will be appended to the end of the entry.  The Buffer field in the
    // Unicode string structure will contain the offset to the Buffer,
    // relative to the beginning of the log file.
    //

    Base->LogEntrySize      = LogEntrySize;
    Base->Operation         = Operation;
    Base->SubKeyName        = *SubKeyName;
    Base->AttributeName     = *AttributeName;
    Base->NewKeyValueType   = NewValueType;
    Base->NewKeyValueLength = NewValueLength;
    Base->KeyHandle         = KeyHandle;

    //
    // Fill in the variable length data: SubKeyName, AttributeName,
    // and NewKeyValue
    //

    //
    // End is an offset relative to the beginning of the entire log
    // structure.  It is initialized to 'point' to the offset immediately
    // following the structure we just filled in above.
    //

    End = (ULONG)((RXactContext->RXactLog->LogSizeInUse) +
                 sizeof( *Base ));


    //
    // Append SubKeyName information to the log file
    //

    RtlMoveMemory (
        (PCHAR)(RXactContext->RXactLog) + End,
        SubKeyName->Buffer,
        SubKeyName->Length
        );

    Base->SubKeyName.Buffer = (PWSTR)ULongToPtr(End);
    End += DwordAlign( SubKeyName->Length );



    //
    // Append AttributeName information to the log file
    //


    RtlMoveMemory(
        (PCHAR)(RXactContext->RXactLog) + End,
        AttributeName->Buffer,
        AttributeName->Length
        );

    Base->AttributeName.Buffer = (PWSTR)ULongToPtr(End);
    End += DwordAlign( AttributeName->Length );



    //
    // Append NewKeyValue information (if present) to the log file
    //

    if ( Operation == RtlRXactOperationSetValue ) {

        RtlMoveMemory(
            (PCHAR)(RXactContext->RXactLog) + End,
            NewValue,
            NewValueLength
            );

        Base->NewKeyValue = (PVOID)ULongToPtr(End);
        End += DwordAlign( NewValueLength );
    }

    End = ALIGN_UP( End, PVOID );

    RXactContext->RXactLog->LogSizeInUse = End;
    RXactContext->RXactLog->OperationCount++;

    //
    // We're done
    //

    return(STATUS_SUCCESS);
}


NTSTATUS
RtlAddActionToRXact(
    IN PRTL_RXACT_CONTEXT RXactContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN ULONG NewKeyValueType,
    IN PVOID NewKeyValue OPTIONAL,
    IN ULONG NewKeyValueLength
    )

/*++

Routine Description:

    This routine is used to add a new action to the transaction operation log.
    Upon commit, these operations are applied in the order they are added
    to the log.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

    Operation - Indicates the type of operation to perform (e.g., delete
        a sub-key or set the value of a sub-key).  Sub-keys may be created
        by setting a value of a previously non-existent sub-key.  This will
        cause all sub-keys between the root and the specified sub-key to
        be created.

    SubKeyName - Specifies the name of the target registry key.  This name
        is relative to the Root of the Registry transaction sub-tree
        and must NOT start with a delimiter character ("\").

    NewKeyValueType - (Optional) Contains the KeyValueType to assign
        to the target registry key.  This parameter is ignored if the
        Operation is not RtlRXactOperationSetValue.

    NewKeyValue -  (Optional) Points to a buffer containing the value
        to assign to the specified target registry key.  This parameter
        is ignored if the Operation is not RtlRXactOperationSetValue.

    NewKeyValueLength - Indicates the length (number of bytes) of the
        NewKeyValue buffer.  This parameter is ignored if the Operation
        is not RtlRXactOperationSetValue.

Return Value:

    STATUS_SUCCESS - Indicates the request completed successfully..


    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.

    Others - Other status values that may be returned from registry key
        services (such as STATUS_ACCESS_DENIED).

--*/
{
    UNICODE_STRING AttributeName;
    NTSTATUS Status;

    RTL_PAGED_CODE();

    RtlInitUnicodeString( &AttributeName, NULL );

    Status = RtlAddAttributeActionToRXact(
                 RXactContext,
                 Operation,
                 SubKeyName,
                 INVALID_HANDLE_VALUE,
                 &AttributeName,
                 NewKeyValueType,
                 NewKeyValue,
                 NewKeyValueLength
                 );

    return( Status );


}



NTSTATUS
RtlApplyRXact(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to apply the changes of a registry sub-tree
    Transaction to that registry sub-tree.  This routine is meant to be
    called for the common case, where the hive is automatically
    lazy-flushed.  That means that this routine must write the change log
    to disk, then flush the hive (to ensure that pieces of changes aren't
    lazy-written to disk before this routine finishes an atomic operation),
    the apply the changes, then delete the change log.

    The actual changes will be lazy-written to disk, but the registry
    guarantees that none or all will make it.  If the machine goes down
    while this routine is executing, the flushed change log guarantees
    that the hive can be put into a consistent state.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was completed.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING LogName;
    HANDLE RXactKey;

    RTL_PAGED_CODE();

    //
    // Commit the contents of the current log to disk
    //

    RXactKey = RXactContext->RXactKey;

    RtlInitUnicodeString( &LogName, RTLP_RXACT_LOG_NAME );

    Status = NtSetValueKey( RXactKey,
                            &LogName,        // ValueName
                            0,               // TitleIndex
                            REG_BINARY,
                            RXactContext->RXactLog,
                            RXactContext->RXactLog->LogSizeInUse
                            );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = NtFlushKey( RXactKey );

    if ( !NT_SUCCESS( Status )) {

        //
        // If this fails, maintain the in-memory data,
        // but get rid of what we just tried to write
        // to disk.
        //
        // Ignore the error, since we're in a funky
        // state right now.
        //

        (VOID) NtDeleteValueKey( RXactKey, &LogName );

        return( Status );
    }

    //
    // The log is safe, now execute what is in it
    //

    Status = RXactpCommit( RXactContext );

    if ( !NT_SUCCESS( Status )) {

        //
        // As above, try to get rid of what's on
        // disk, leave the in-memory stuff alone,
        // so that the caller may try again.
        //

        (VOID) NtDeleteValueKey( RXactKey, &LogName );

        return( Status );
    }

    //
    // Delete the log file value and data
    //

    Status = NtDeleteValueKey( RXactKey, &LogName );

    //
    // This should never fail
    //

    ASSERT( NT_SUCCESS( Status ));

    //
    // Get rid of the in memory data structures.  Abort
    // does exactly what we want to do.
    //

    Status = RtlAbortRXact( RXactContext );

    //
    // This should never fail
    //

    ASSERT( NT_SUCCESS( Status ));

    return( STATUS_SUCCESS );

}



NTSTATUS
RtlApplyRXactNoFlush(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine is used to apply the changes of a registry sub-tree
    Transaction to that registry sub-tree.  This routine should only be
    called for special hives that do not have automatic lazy-flushing.
    The caller must decide when to flush the hive in order to guarantee
    a consistent hive.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was completed.

    STATUS_UNKNOWN_REVISION - Indicates that a transaction state
        exists for the specified sub-tree, but has a revision level that is
        unknown by this service.


    STATUS_RXACT_INVALID_STATE - Indicates that the transaction state
        of the registry sub-tree is incompatible with the requested operation.
        For example, a request to start a new transaction while one is already
        in progress, or a request to apply a transaction when one is not
        currently in progress.  This may also indicate that there is no
        transaction state at all for the specified registry sub-tree.


--*/
{
    NTSTATUS Status;

    RTL_PAGED_CODE();

    //
    // Execute the contents of the RXACT log.
    //

    Status = RXactpCommit( RXactContext );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Get rid of the in memory data structures.  Abort
        // does exactly what we want to do.
        //

        Status = RtlAbortRXact( RXactContext );

        //
        // This should never fail
        //

        ASSERT( NT_SUCCESS( Status ));
    }

    return( Status );

}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Internal Procedures   (defined in within this file)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





NTSTATUS
RXactpCommit(
    IN PRTL_RXACT_CONTEXT RXactContext
    )

/*++

Routine Description:

    This routine commits the operations in the operation log.

    When all changes have been applied, the transaction state
    is changed to NO_TRANSACTION.

Arguments:

    RXactContext - Supplies a pointer to the RXactContext structure for this
        subsystem's root registry key.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was completed.



--*/
{
    BOOLEAN HandlesValid;

    HANDLE TargetKey;
    HANDLE RXactKey;
    HANDLE RootRegistryKey;

    PRTL_RXACT_LOG      RXactLog;
    PRXACT_LOG_ENTRY    RXactLogEntry;
    RTL_RXACT_OPERATION Operation;

    ULONG OperationCount;
    ULONG i;

    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TmpStatus = STATUS_SUCCESS;
    BOOLEAN CloseTargetKey;

    //
    // Extract information from the RXactContext to simplify
    // the code that follows
    //

    RootRegistryKey = RXactContext->RootRegistryKey;
    RXactKey        = RXactContext->RXactKey;
    RXactLog        = RXactContext->RXactLog;

    OperationCount  = RXactLog->OperationCount;

    HandlesValid    = RXactContext->HandlesValid;


    //
    // Keep a pointer to the beginning of the current log entry.
    //

    RXactLogEntry = (PRXACT_LOG_ENTRY)((PCHAR)RXactLog + sizeof( RTL_RXACT_LOG ));


    //
    // Go through and perform each operation log.  Notice that some operation
    // logs may already have been deleted by a previous commit attempt.
    // So, don't get alarmed if we don't successfully open some operation
    // log entry keys.
    //

    for ( i=0 ; i<OperationCount ; i++ ) {

        //
        // Turn the self-relative offsets in the structure
        // back into real pointers.
        //

        RXactLogEntry->SubKeyName.Buffer = (PWSTR) ((PCHAR)RXactLogEntry->SubKeyName.Buffer +
                                                    (ULONG_PTR)RXactLog);

        RXactLogEntry->AttributeName.Buffer = (PWSTR) ((PCHAR)RXactLogEntry->AttributeName.Buffer +
                                                       (ULONG_PTR)RXactLog);

        RXactLogEntry->NewKeyValue = (PVOID)((PCHAR)RXactLogEntry->NewKeyValue + (ULONG_PTR)RXactLog);

        Operation = RXactLogEntry->Operation;

        //
        // Perform this operation
        //

        switch (Operation) {
            case RtlRXactOperationDelete:

                //
                // Open the target key and delete it.
                // The name is relative to the RootRegistryKey.
                //

                if ( ((RXactLogEntry->KeyHandle == INVALID_HANDLE_VALUE) || !HandlesValid) ) {

                    Status = RXactpOpenTargetKey(
                                 RootRegistryKey,
                                 RtlRXactOperationDelete,
                                 &RXactLogEntry->SubKeyName,
                                 &TargetKey
                                 );

                    if ( !NT_SUCCESS(Status)) {

                        //
                        // We must allow the object not to be found,
                        // because we may be replaying this log after
                        // it had been partially executed.
                        //

                        if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                            return( Status );

                        } else {

                            break;
                        }
                    }

                    CloseTargetKey = TRUE;

                } else {

                    TargetKey = RXactLogEntry->KeyHandle;
                    CloseTargetKey = FALSE;
                }


                //
                // If this fails, then it is an error
                // because the key should exist at
                // this point.
                //

                Status = NtDeleteKey( TargetKey );


                //
                // Only close the target key if we opened it
                //

                if ( CloseTargetKey ) {

                    TmpStatus = NtClose( TargetKey );

                    //
                    // If we opened this handle, then we should
                    // be able to close it, whether it has been
                    // deleted or not.
                    //

                    ASSERT(NT_SUCCESS(TmpStatus));        // safe to ignore, but curious...
                }


                if (!NT_SUCCESS(Status)) {
                    return(Status);
                }

                break;

            case RtlRXactOperationSetValue:

                //
                // Open the target key.
                // The name is relative to the RootRegistryKey.
                //

                if ( ((RXactLogEntry->KeyHandle == INVALID_HANDLE_VALUE) || !HandlesValid) ) {

                    Status = RXactpOpenTargetKey(
                                 RootRegistryKey,
                                 RtlRXactOperationSetValue,
                                 &RXactLogEntry->SubKeyName,
                                 &TargetKey
                                 );

                    if ( !NT_SUCCESS(Status) ) {
                        return(Status);
                    }

                    CloseTargetKey = TRUE;

                } else {

                    TargetKey = RXactLogEntry->KeyHandle;
                    CloseTargetKey = FALSE;
                }

                //
                // Assign to the target key's new value
                //

                Status = NtSetValueKey( TargetKey,
                                        &RXactLogEntry->AttributeName,
                                        0,               // TitleIndex
                                        RXactLogEntry->NewKeyValueType,
                                        RXactLogEntry->NewKeyValue,
                                        RXactLogEntry->NewKeyValueLength
                                        );

                //
                // Only close the target key if we opened it
                //

                if ( CloseTargetKey ) {

                    TmpStatus = NtClose( TargetKey );
                    ASSERT(NT_SUCCESS(TmpStatus));        // safe to ignore, but curious...

                }

                if ( !NT_SUCCESS(Status) ) {
                    return(Status);
                }

                break;



            default:

                //
                // Unknown operation type.  This should never happen.
                //

                ASSERT( FALSE );

                return(STATUS_INVALID_PARAMETER);

        }

        RXactLogEntry = (PRXACT_LOG_ENTRY)((PCHAR)RXactLogEntry + RXactLogEntry->LogEntrySize);

    }

    //
    // Commit complete
    //

    return( STATUS_SUCCESS );

}




NTSTATUS
RXactpOpenTargetKey(
    IN HANDLE RootRegistryKey,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    OUT PHANDLE TargetKey
    )

/*++

Routine Description:

    This routine opens the target registry key of an operation.

Arguments:

    RootRegistryKey - A handle to the registry key within whose sub-tree
        a transaction is to be initialized.

    Operation - Indicates what operation is to be performed on the target.
        This will effect how the target is opened.

    OperationNameKey - A handle to the operation log sub-key
        containing the name of the target registry key.

    TargetKey - Receives a handle to the target registry key.

Return Value:

    STATUS_SUCCESS - Indicates the operation log entry was opened.

    STATUS_NO_MEMORY - Ran out of heap.


--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES TargetKeyAttributes;
    ACCESS_MASK DesiredAccess;
    ULONG Disposition;


    if (Operation == RtlRXactOperationDelete) {

        DesiredAccess = DELETE;

        InitializeObjectAttributes(
            &TargetKeyAttributes,
            SubKeyName,
            OBJ_CASE_INSENSITIVE,
            RootRegistryKey,
            NULL);

//        Status = RtlpNtOpenKey(
//                     TargetKey,
//                     DesiredAccess,
//                     &TargetKeyAttributes,
//                     0);

        Status = NtOpenKey( TargetKey,
                            DesiredAccess,
                            &TargetKeyAttributes
                            );


    } else if (Operation == RtlRXactOperationSetValue) {

        DesiredAccess = KEY_WRITE;

        InitializeObjectAttributes(
            &TargetKeyAttributes,
            SubKeyName,
            OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
            RootRegistryKey,
            NULL);

        Status = NtCreateKey(
                     TargetKey,
                     DesiredAccess,
                     &TargetKeyAttributes,
                     0,
                     NULL,
                     REG_OPTION_NON_VOLATILE,
                     &Disposition
                     );

    } else {
        return STATUS_INVALID_PARAMETER;
    }



    return( Status );

}



//NTSTATUS
//RXactpAssignTargetValue(
//    IN PVOID NewKeyValue,
//    IN ULONG NewKeyValueLength,
//    IN ULONG NewKeyValueType,
//    IN HANDLE TargetKey,
//    IN PUNICODE_STRING AttributeName
//    );


//NTSTATUS
//RXactpAssignTargetValue(
//    IN PVOID NewKeyValue,
//    IN ULONG NewKeyValueLength,
//    IN ULONG NewKeyValueType,
//    IN HANDLE TargetKey,
//    IN PUNICODE_STRING AttributeName
//    )
//
///*++
//
//Routine Description:
//
//    This routine copies the value of an operation log entry to its
//    corresponding target key.  The target key must already be open.
//
//Arguments:
//
//    NewKeyValue - The new value for the key being modified.
//
//    NewKeyValueLength - The size in bytes of the new value information.
//
//    NewKeyValueType - The type of the data for the new key.
//
//    TargetKey - A handle to the target registry key.
//
//    AttributeName - Supplies the name of the key attribute being edited.
//
//Return Value:
//
//    STATUS_SUCCESS - Indicates the value was successfully applied to
//        the target registry key.
//
//    STATUS_NO_MEMORY - ran out of heap.
//
//
//--*/
//{
//    NTSTATUS Status;
//
//    //
//    // Now apply the value to the target key
//    //
//    // Even if there is no key value, we need to do the assign so that
//    // the key value type is assigned.
//    //
//
//    Status = NtSetValueKey( TargetKey,
//                            AttributeName,
//                            0,               // TitleIndex
//                            NewKeyValueType,
//                            NewKeyValue,
//                            NewKeyValueLength
//                            );
//
//
//    return( Status );
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\rtlassig.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rtlassig.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

Author:

    Jim Kelly       (JimK)     23-Mar-1990
    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine

Revision History:

--*/


#include "ntrtlp.h"
#include "seopaque.h"
#include "sertlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlSelfRelativeToAbsoluteSD)
#pragma alloc_text(PAGE,RtlMakeSelfRelativeSD)
#pragma alloc_text(PAGE,RtlpQuerySecurityDescriptor)
#pragma alloc_text(PAGE,RtlAbsoluteToSelfRelativeSD)
#pragma alloc_text(PAGE,RtlSelfRelativeToAbsoluteSD2)
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Exported Procedures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
RtlSelfRelativeToAbsoluteSD(
    IN OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PULONG AbsoluteSecurityDescriptorSize,
    IN OUT PACL Dacl,
    IN OUT PULONG DaclSize,
    IN OUT PACL Sacl,
    IN OUT PULONG SaclSize,
    IN OUT PSID Owner,
    IN OUT PULONG OwnerSize,
    IN OUT PSID PrimaryGroup,
    IN OUT PULONG PrimaryGroupSize
    )

/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format

Arguments:

    SecurityDescriptor - Supplies a pointer to a security descriptor in
        Self-Relative format

    AbsoluteSecurityDescriptor - A pointer to a buffer in which will be
        placed the main body of the Absolute format security descriptor.

    Dacl - Supplies a pointer to a buffer that will contain the Dacl of the
        output descriptor.  This pointer will be referenced by, not copied
        into, the output descriptor.

    DaclSize - Supplies the size of the buffer pointed to by Dacl.  In case
        of error, it will return the minimum size necessary to contain the
        Dacl.

    Sacl - Supplies a pointer to a buffer that will contain the Sacl of the
        output descriptor.  This pointer will be referenced by, not copied
        into, the output descriptor.

    SaclSize - Supplies the size of the buffer pointed to by Sacl.  In case
        of error, it will return the minimum size necessary to contain the
        Sacl.

    Owner - Supplies a pointer to a buffer that will contain the Owner of
        the output descriptor.  This pointer will be referenced by, not
        copied into, the output descriptor.

    OwnerSize - Supplies the size of the buffer pointed to by Owner.  In
        case of error, it will return the minimum size necessary to contain
        the Owner.

    PrimaryGroup - Supplies a pointer to a buffer that will contain the
        PrimaryGroup of the output descriptor.  This pointer will be
        referenced by, not copied into, the output descriptor.

    PrimaryGroupSize - Supplies the size of the buffer pointed to by
        PrimaryGroup.  In case of error, it will return the minimum size
        necessary to contain the PrimaryGroup.


Return Value:

    STATUS_SUCCESS - Success

    STATUS_BUFFER_TOO_SMALL - One of the buffers passed was too small.

    STATUS_INVALID_OWNER - There was not a valid owner in the passed
        security descriptor.

--*/

{
    ULONG NewDaclSize;
    ULONG NewSaclSize;
    ULONG NewBodySize;
    ULONG NewOwnerSize;
    ULONG NewGroupSize;

    PSID NewOwner;
    PSID NewGroup;
    PACL NewDacl;
    PACL NewSacl;

    //
    // typecast security descriptors so we don't have to cast all over the place.
    //

    PISECURITY_DESCRIPTOR OutSD =
        AbsoluteSecurityDescriptor;

    PISECURITY_DESCRIPTOR InSD =
            (PISECURITY_DESCRIPTOR)SelfRelativeSecurityDescriptor;


    RTL_PAGED_CODE();

    if ( !RtlpAreControlBitsSet( InSD, SE_SELF_RELATIVE) ) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }

    NewBodySize = sizeof(SECURITY_DESCRIPTOR);

    RtlpQuerySecurityDescriptor(
        InSD,
        &NewOwner,
        &NewOwnerSize,
        &NewGroup,
        &NewGroupSize,
        &NewDacl,
        &NewDaclSize,
        &NewSacl,
        &NewSaclSize
        );

    if ( (NewBodySize  > *AbsoluteSecurityDescriptorSize) ||
         (NewOwnerSize > *OwnerSize )                     ||
         (NewDaclSize  > *DaclSize )                      ||
         (NewSaclSize  > *SaclSize )                      ||
         (NewGroupSize > *PrimaryGroupSize ) ) {

         *AbsoluteSecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR);
         *PrimaryGroupSize               = NewGroupSize;
         *OwnerSize                      = NewOwnerSize;
         *SaclSize                       = NewSaclSize;
         *DaclSize                       = NewDaclSize;

         return( STATUS_BUFFER_TOO_SMALL );
    }


    RtlMoveMemory( OutSD,
                   InSD,
                   sizeof(SECURITY_DESCRIPTOR_RELATIVE) );

    OutSD->Owner = NULL;
    OutSD->Group = NULL;
    OutSD->Sacl  = NULL;
    OutSD->Dacl  = NULL;

    RtlpClearControlBits( OutSD, SE_SELF_RELATIVE );

    if (NewOwner != NULL) {
        RtlMoveMemory( Owner, NewOwner, SeLengthSid( NewOwner ));
        OutSD->Owner = Owner;
    }

    if (NewGroup != NULL) {
        RtlMoveMemory( PrimaryGroup, NewGroup, SeLengthSid( NewGroup ));
        OutSD->Group = PrimaryGroup;
    }

    if (NewSacl != NULL) {
        RtlMoveMemory( Sacl, NewSacl, NewSacl->AclSize );
        OutSD->Sacl  = Sacl;
    }

    if (NewDacl != NULL) {
        RtlMoveMemory( Dacl, NewDacl, NewDacl->AclSize );
        OutSD->Dacl  = Dacl;
    }

    return( STATUS_SUCCESS );
}




NTSTATUS
RtlMakeSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    Makes a copy of a security descriptor.  The produced copy will be in self-relative
    form.

    The security descriptor to be copied may be in either absolute or self-relative
    form.

Arguments:

    SecurityDescriptor - Pointer to a security descriptor.  This descriptor will not
        be modified.

    SelfRelativeSecurityDescriptor - Pointer to a buffer that will contain
        the returned self-relative security descriptor.

    BufferLength - Supplies the length of the buffer.  If the supplied
        buffer is not large enough to hold the self-relative security
        descriptor, an error will be returned, and this field will return
        the minimum size required.


Return Value:

    STATUS_BUFFER_TOO_SMALL - The supplied buffer was too small to contain
        the resultant security descriptor.


--*/

{
    ULONG NewDaclSize;
    ULONG NewSaclSize;
    ULONG NewOwnerSize;
    ULONG NewGroupSize;

    ULONG AllocationSize;

    PSID NewOwner;
    PSID NewGroup;
    PACL NewDacl;
    PACL NewSacl;

    PCHAR Field;
    PCHAR Base;


    //
    // Convert security descriptors to new data type so we don't
    // have to cast all over the place.
    //

    PISECURITY_DESCRIPTOR_RELATIVE IResultantDescriptor =
            (PISECURITY_DESCRIPTOR_RELATIVE)SelfRelativeSecurityDescriptor;

    PISECURITY_DESCRIPTOR IPassedSecurityDescriptor =
            (PISECURITY_DESCRIPTOR)SecurityDescriptor;


    RtlpQuerySecurityDescriptor(
        IPassedSecurityDescriptor,
        &NewOwner,
        &NewOwnerSize,
        &NewGroup,
        &NewGroupSize,
        &NewDacl,
        &NewDaclSize,
        &NewSacl,
        &NewSaclSize
        );

    RTL_PAGED_CODE();

    AllocationSize = sizeof(SECURITY_DESCRIPTOR_RELATIVE) +
                     NewOwnerSize +
                     NewGroupSize +
                     NewDaclSize  +
                     NewSaclSize  ;

    if (AllocationSize > *BufferLength) {
        *BufferLength = AllocationSize;
        return( STATUS_BUFFER_TOO_SMALL );
    }

    RtlZeroMemory( IResultantDescriptor, AllocationSize );

    RtlCopyMemory( IResultantDescriptor,
                   IPassedSecurityDescriptor,
                   FIELD_OFFSET( SECURITY_DESCRIPTOR_RELATIVE, Owner ));


    Base = (PCHAR)(IResultantDescriptor);
    Field =  Base + (ULONG)sizeof(SECURITY_DESCRIPTOR_RELATIVE);

    if (NewSaclSize > 0) {
        RtlCopyMemory( Field, NewSacl, NewSaclSize );
        IResultantDescriptor->Sacl = RtlPointerToOffset(Base,Field);
        Field += NewSaclSize;
    } else {
        IResultantDescriptor->Sacl = 0;
    }


    if (NewDaclSize > 0) {
        RtlCopyMemory( Field, NewDacl, NewDaclSize );
        IResultantDescriptor->Dacl = RtlPointerToOffset(Base,Field);
        Field += NewDaclSize;
    } else {
        IResultantDescriptor->Dacl = 0;
    }



    if (NewOwnerSize > 0) {
        RtlCopyMemory( Field, NewOwner, NewOwnerSize );
        IResultantDescriptor->Owner = RtlPointerToOffset(Base,Field);
        Field += NewOwnerSize;
    }


    if (NewGroupSize > 0) {
        RtlCopyMemory( Field, NewGroup, NewGroupSize );
        IResultantDescriptor->Group = RtlPointerToOffset(Base,Field);
    }

    RtlpSetControlBits( IResultantDescriptor, SE_SELF_RELATIVE );

    return( STATUS_SUCCESS );

}


NTSTATUS
RtlAbsoluteToSelfRelativeSD(
    IN PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    Converts a security descriptor in absolute form to one in self-relative
    form.

Arguments:

    AbsoluteSecurityDescriptor - Pointer to an absolute format security
        descriptor.  This descriptor will not be modified.

    SelfRelativeSecurityDescriptor - Pointer to a buffer that will contain
        the returned self-relative security descriptor.

    BufferLength - Supplies the length of the buffer.  If the supplied
        buffer is not large enough to hold the self-relative security
        descriptor, an error will be returned, and this field will return
        the minimum size required.


Return Value:

    STATUS_BUFFER_TOO_SMALL - The supplied buffer was too small to contain
        the resultant security descriptor.

    STATUS_BAD_DESCRIPTOR_FORMAT - The supplied security descriptor was not
        in absolute form.

--*/

{
    NTSTATUS NtStatus;

    PISECURITY_DESCRIPTOR IAbsoluteSecurityDescriptor =
            (PISECURITY_DESCRIPTOR)AbsoluteSecurityDescriptor;


    RTL_PAGED_CODE();

    //
    // Make sure the passed SD is absolute format, and then call
    // RtlMakeSelfRelativeSD() to do all the work.
    //

    if ( RtlpAreControlBitsSet( IAbsoluteSecurityDescriptor, SE_SELF_RELATIVE) ) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }

    NtStatus = RtlMakeSelfRelativeSD(
                   AbsoluteSecurityDescriptor,
                   SelfRelativeSecurityDescriptor,
                   BufferLength
                   );

    return( NtStatus );

}
VOID
RtlpQuerySecurityDescriptor(
    IN PISECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PULONG OwnerSize,
    OUT PSID *PrimaryGroup,
    OUT PULONG PrimaryGroupSize,
    OUT PACL *Dacl,
    OUT PULONG DaclSize,
    OUT PACL *Sacl,
    OUT PULONG SaclSize
    )
/*++

Routine Description:

    Returns the pieces of a security descriptor structure.

Arguments:


    SecurityDescriptor - Provides the security descriptor of interest.

    Owner - Returns a pointer to the owner information contained in the
        security descriptor.

    OwnerSize - Returns the size of the owner information.

    PrimaryGroup -  Returns a pointer to the primary group information.

    PrimaryGroupSize - Returns the size of the primary group information.

    Dacl - Returns a pointer to the Dacl.

    DaclSize - Returns the size of the Dacl.

    Sacl - Returns a pointer to the Sacl.

    SaclSize - Returns the size of the Sacl.

Return Value:

    None.

--*/
{

    RTL_PAGED_CODE();

    *Owner = RtlpOwnerAddrSecurityDescriptor( SecurityDescriptor );

    if (*Owner != NULL) {
        *OwnerSize = LongAlignSize(SeLengthSid(*Owner));
    } else {
        *OwnerSize = 0;
    }

    *Dacl = RtlpDaclAddrSecurityDescriptor ( SecurityDescriptor );

    if (*Dacl !=NULL) {
        *DaclSize = LongAlignSize((*Dacl)->AclSize);
    } else {
        *DaclSize = 0;
    }

    *PrimaryGroup = RtlpGroupAddrSecurityDescriptor( SecurityDescriptor );

    if (*PrimaryGroup != NULL) {
        *PrimaryGroupSize = LongAlignSize(SeLengthSid(*PrimaryGroup));
    } else {
         *PrimaryGroupSize = 0;
    }

    *Sacl = RtlpSaclAddrSecurityDescriptor( SecurityDescriptor );

    if (*Sacl != NULL) {
        *SaclSize = LongAlignSize((*Sacl)->AclSize);
    } else {
        *SaclSize = 0;
    }

}



NTSTATUS
RtlSelfRelativeToAbsoluteSD2(
    IN OUT PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    IN OUT PULONG               pBufferSize
    )

/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format using the memory allocated for the SelfRelativeSecurityDescriptor

Arguments:

    pSecurityDescriptor - Supplies a pointer to a security descriptor in
        Self-Relative format. If success, we return a absolute security
        descriptor where this pointer pointings.

    pBufferSize - Supplies a pointer to the size of the
        buffer.

Return Value:

    STATUS_SUCCESS - Success

    STATUS_BAD_DESCRIPTOR_FORMAT - The passed descriptor is not a self-relative
       security descriptor.

    STATUS_BUFFER_TOO_SMALL - The passed buffer is too small.

    STATUS_INVALID_OWNER - There was not a valid owner in the passed
        security descriptor.

Notes: Despite some attempts to make this code as portable as possible and the 
       utilization of C_ASSERT or ASSERT to detect the respect of these assumptions, 
       this code is still making several assumptions about the format of the absolute 
       and self-relative descriptors and their relationships: in terms of packing, 
       fields definitions and locations in their respective structures. 
       In particular, this code assumes that the only differences are due to differences 
       in the types of the structure members and in the behaviour of the security descriptor
       query API.
       At this time, the only structure members that get read/updated are Owner, Group,
       Dacl and Sacl. If more members are added or displaced in the definitions of these
       structures, this code may have to be modified.

--*/

{
    ULONG_PTR   ptr;
    PSID        owner;
    PSID        group;
    PACL        dacl;
    PACL        sacl;
    ULONG       daclSize;
    ULONG       saclSize;
    ULONG       newBodySize;
    ULONG       ownerSize;
    ULONG       groupSize;
    ULONG       newBufferSize;
    LONG        deltaSize;

//
// Typecast security descriptors so we don't have to cast all over the place.
//

    PISECURITY_DESCRIPTOR          psd  = (PISECURITY_DESCRIPTOR)         pSelfRelativeSecurityDescriptor;
    PISECURITY_DESCRIPTOR_RELATIVE psdr = (PISECURITY_DESCRIPTOR_RELATIVE)pSelfRelativeSecurityDescriptor;

//
// This code uses several assumptions about the absolute and self-relative formats of 
// security descriptors and the way they are packing in memory. 
// See Routine Description Notes.
//

    C_ASSERT( sizeof( SECURITY_DESCRIPTOR ) >= sizeof( SECURITY_DESCRIPTOR_RELATIVE ) ); 
    C_ASSERT( sizeof( psd->Control ) == sizeof( psdr->Control ) );
    C_ASSERT( FIELD_OFFSET( SECURITY_DESCRIPTOR, Control ) == FIELD_OFFSET( SECURITY_DESCRIPTOR_RELATIVE, Control ) );
    
    RTL_PAGED_CODE();

//
// Parameters check point
//

    if ( psd == (PISECURITY_DESCRIPTOR)0 ) {
        return( STATUS_INVALID_PARAMETER_1 );        
    }
    if ( pBufferSize == (PULONG)0 )   {
        return( STATUS_INVALID_PARAMETER_2 );       
    }

    //
    // If the passed security descriptor is not self-relative, we return
    // an format error.
    //

    if ( !RtlpAreControlBitsSet( psd, SE_SELF_RELATIVE) ) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }

//
// Update local variables by querying the self-relative descriptor.
//
// Note that the returned size values are long-aligned.
//

    RtlpQuerySecurityDescriptor(
        psd,
        &owner,
        &ownerSize,
        &group,
        &groupSize,
        &dacl,
        &daclSize,
        &sacl,
        &saclSize
        );

//
// Identical formats check:
//

    //
    // Determine the delta in size between the two formats of security descriptors
    //

    deltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE ); 

    //
    // If identical format: 
    //      - clear the SELF_RELATIVE flag
    //      - update absolute descriptor members
    //      - return SUCCESS.
    //

    if ( deltaSize == 0 )   {
       
        RtlpClearControlBits( psd, SE_SELF_RELATIVE );

        //
        // Only the following fields are updated.
        //

        ASSERT( sizeof( psd->Owner ) == sizeof( psdr->Owner ) );
        ASSERT( sizeof( psd->Group ) == sizeof( psdr->Group ) );
        ASSERT( sizeof( psd->Sacl  ) == sizeof( psdr->Sacl  ) );
        ASSERT( sizeof( psd->Dacl  ) == sizeof( psdr->Dacl  ) );

        psd->Owner = owner;
        psd->Group = group;
        psd->Sacl  = sacl;
        psd->Dacl  = dacl;
    
        return( STATUS_SUCCESS );

    }

//
// Determine the required size for the absolute format:
//

#define ULONG_PTR_SDEND( _Adr ) ( (ULONG_PTR)(_Adr) + (ULONG_PTR)(_Adr##Size) )

    ptr = owner > group ? ULONG_PTR_SDEND( owner ) : ULONG_PTR_SDEND( group );
    ptr = ptr > (ULONG_PTR)dacl ? ptr : ULONG_PTR_SDEND( dacl );
    ptr = ptr > (ULONG_PTR)sacl ? ptr : ULONG_PTR_SDEND( sacl );
   
    newBufferSize = sizeof( SECURITY_DESCRIPTOR );
    if ( ptr )   {

#define ULONG_ROUND_UP( x, y )   ((ULONG)(x) + ((y)-1) & ~((y)-1))

        newBufferSize += ULONG_ROUND_UP( (ULONG_PTR)ptr - (ULONG_PTR)(psdr + 1), sizeof(PVOID) );
    }

    //
    // If the specified buffer size is not big enough, let the caller know abour 
    // the minimum size and return STATUS_BUFFER_TOO_SMALL.
    //

    if ( newBufferSize > *pBufferSize )  {
        *pBufferSize = newBufferSize;
        return( STATUS_BUFFER_TOO_SMALL );
    }

//
// Update absolute security descriptor:
//

    //
    // Move the members of self-relative security descriptor in their 
    // absolute format locations.
    //

    if ( ptr )   {
       RtlMoveMemory( (PVOID)(psd + 1), (PVOID)(psdr + 1), newBufferSize - sizeof( SECURITY_DESCRIPTOR) );      
    }

    //
    // Clear the self-relative flag
    //

    RtlpClearControlBits( psd, SE_SELF_RELATIVE );

    //
    // Only the following fields are updated.
    //

    psd->Owner = (PSID)( owner ? (ULONG_PTR)owner + deltaSize : 0 );
    psd->Group = (PSID)( group ? (ULONG_PTR)group + deltaSize : 0 );
    psd->Sacl  = (PACL)( sacl  ? (ULONG_PTR)sacl  + deltaSize : 0 );
    psd->Dacl  = (PACL)( dacl  ? (ULONG_PTR)dacl  + deltaSize : 0 );
    
    return( STATUS_SUCCESS );

} // RtlSelfRelativeToAbsoluteSD2()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\rtldata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Rtldata.c

Abstract:

    This module contains static data used by RLT routines.

Author:

    Bryan Willman (bryanwi) 8-Nov-93

Environment:


Revision History:

--*/

#include <ntrtlp.h>

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

ULONG RtlpRandomConstantVector[128] = {
    0x4c8bc0aa, 0x4c022957, 0x2232827a, 0x2f1e7626, 0x7f8bdafb, 0x5c37d02a, 0x0ab48f72, 0x2f0c4ffa,
    0x290e1954, 0x6b635f23, 0x5d3885c0, 0x74b49ff8, 0x5155fa54, 0x6214ad3f, 0x111e9c29, 0x242a3a09,
    0x75932ae1, 0x40ac432e, 0x54f7ba7a, 0x585ccbd5, 0x6df5c727, 0x0374dad1, 0x7112b3f1, 0x735fc311,
    0x404331a9, 0x74d97781, 0x64495118, 0x323e04be, 0x5974b425, 0x4862e393, 0x62389c1d, 0x28a68b82,
    0x0f95da37, 0x7a50bbc6, 0x09b0091c, 0x22cdb7b4, 0x4faaed26, 0x66417ccd, 0x189e4bfa, 0x1ce4e8dd,
    0x5274c742, 0x3bdcf4dc, 0x2d94e907, 0x32eac016, 0x26d33ca3, 0x60415a8a, 0x31f57880, 0x68c8aa52,
    0x23eb16da, 0x6204f4a1, 0x373927c1, 0x0d24eb7c, 0x06dd7379, 0x2b3be507, 0x0f9c55b1, 0x2c7925eb,
    0x36d67c9a, 0x42f831d9, 0x5e3961cb, 0x65d637a8, 0x24bb3820, 0x4d08e33d, 0x2188754f, 0x147e409e,
    0x6a9620a0, 0x62e26657, 0x7bd8ce81, 0x11da0abb, 0x5f9e7b50, 0x23e444b6, 0x25920c78, 0x5fc894f0,
    0x5e338cbb, 0x404237fd, 0x1d60f80f, 0x320a1743, 0x76013d2b, 0x070294ee, 0x695e243b, 0x56b177fd,
    0x752492e1, 0x6decd52f, 0x125f5219, 0x139d2e78, 0x1898d11e, 0x2f7ee785, 0x4db405d8, 0x1a028a35,
    0x63f6f323, 0x1f6d0078, 0x307cfd67, 0x3f32a78a, 0x6980796c, 0x462b3d83, 0x34b639f2, 0x53fce379,
    0x74ba50f4, 0x1abc2c4b, 0x5eeaeb8d, 0x335a7a0d, 0x3973dd20, 0x0462d66b, 0x159813ff, 0x1e4643fd,
    0x06bc5c62, 0x3115e3fc, 0x09101613, 0x47af2515, 0x4f11ec54, 0x78b99911, 0x3db8dd44, 0x1ec10b9b,
    0x5b5506ca, 0x773ce092, 0x567be81a, 0x5475b975, 0x7a2cde1a, 0x494536f5, 0x34737bb4, 0x76d9750b,
    0x2a1f6232, 0x2e49644d, 0x7dddcbe7, 0x500cebdb, 0x619dab9e, 0x48c626fe, 0x1cda3193, 0x52dabe9d
    };

/*++

Table and auxiliary variable used by RtlRandomEx()
per Knuth (see comments for RtlRandomEx())

    Table is initialzed by generating the first 128 elements
    of the sequence UniformMacro() defined in random.c with
    seed and first element 0x4c8bc0aa.

    Auxiliary variable is initialized by the 129th. element
    of the same sequence.

--*/

ULONG RtlpRandomExAuxVarY = (ULONG)  0x7775fb16;

ULONG RtlpRandomExConstantVector[128] = {
    0x4c8bc0aa,  0x51a0b326,  0x7112b3f1,  0x1b9ca4e1,  0x735fc311,  0x6fe48580,  0x320a1743,  0x494045ca,
    0x103ad1c5,  0x4ba26e25,  0x62f1d304,  0x280d5677,  0x70294ee,   0x7acef21a,  0x62a407d5,  0x2dd36af5,
    0x194f0f95,  0x1f21d7b4,  0x307cfd67,  0x66b9311e,  0x60415a8a,  0x5b264785,  0x3c28b0e4,  0x8faded7,
    0x556175ce,  0x29c44179,  0x666f23c9,  0x65c057d8,  0x72b97abc,  0x7c3be3d0,  0x478e1753,  0x3074449b,
    0x675ee842,  0x53f4c2de,  0x44d58949,  0x6426cf59,  0x111e9c29,  0x3aba68b9,  0x242a3a09,  0x50ddb118,
    0x7f8bdafb,  0x89ebf23,   0x5c37d02a,  0x27db8ca6,  0xab48f72,   0x34995a4e,  0x189e4bfa,  0x2c405c36,
    0x373927c1,  0x66c20c71,  0x5f991360,  0x67a38fa3,  0x4edc56aa,  0x25a59126,  0x34b639f2,  0x1679b2ce,
    0x54f7ba7a,  0x319d28b5,  0x5155fa54,  0x769e6b87,  0x323e04be,  0x4565a5aa,  0x5974b425,  0x5c56a104,
    0x25920c78,  0x362912dc,  0x7af3996f,  0x5feb9c87,  0x618361bf,  0x433fbe97,  0x244da8e,   0x54e3c739,
    0x33183689,  0x3533f398,  0xd24eb7c,   0x6428590,   0x9101613,   0x53ce5c5a,  0x47af2515,  0x2e003f35,
    0x15fb4ed5,  0x5e5925f4,  0x7f622ea7,  0xbb6895f,   0x2173cdb6,  0x467bb41,   0x2c4d19f1,  0x364712e1,
    0x78b99911,  0xa39a380,   0x3db8dd44,  0x6b4793b8,  0x9b0091c,   0x47ef52b0,  0x293cdcb3,  0x707b9e7b,
    0x26d33ca3,  0x1e527faa,  0x3fe08625,  0x42560b04,  0x139d2e78,  0xb558cdb,   0x28a68b82,  0x7ba3a51d,
    0x52dabe9d,  0x59c3da1d,  0x5676cf9c,  0x152e972f,  0x6d8ac746,  0x5eb33591,  0x78b30601,  0xab68db0,
    0x34737bb4,  0x1b6dd168,  0x76d9750b,  0x2ddc4ff2,  0x18a610cd,  0x2bacc08c,  0x422db55f,  0x169b89b6,
    0x5274c742,  0x615535dd,  0x46ad005d,  0x4128f8dd,  0x29f5875c,  0x62c6f3ef,  0x2b3be507,  0x4a8e003f
};


const
PWSTR RtlpRegistryPaths[ RTL_REGISTRY_MAXIMUM ] = {
    NULL,
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services",
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control",
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion",
    L"\\Registry\\Machine\\Hardware\\DeviceMap",
    L"\\Registry\\User\\.Default"
};

const WCHAR szBias[] =          L"Bias";
const WCHAR szStandardName[] =  L"StandardName";
const WCHAR szStandardBias[] =  L"StandardBias";
const WCHAR szStandardStart[] = L"StandardStart";
const WCHAR szDaylightName[] =  L"DaylightName";
const WCHAR szDaylightBias[] =  L"DaylightBias";
const WCHAR szDaylightStart[] = L"DaylightStart";

const WCHAR GuidFormat[] = L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}";

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\secmem.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    secmem.c

Abstract:

    This module implements a user level callback for securing memory for SAN IOs.

Author:

    Nar Ganapathy (narg) 8-Feb-2000 

Revision History:

--*/

#include "ntrtlp.h"

ULONG_PTR   RtlSecureMemorySystemRangeStart;
PRTL_SECURE_MEMORY_CACHE_CALLBACK       RtlSecureMemoryCacheCallback = NULL;

NTSTATUS
RtlRegisterSecureMemoryCacheCallback(
    IN PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback
    )
/*++

Routine Description:

    This routine allows a library to register to be called back whenever
    memory is freed or its protections are changed. This is useful for 
    maintaining user level secure memory cache for SAN applications.
    Current customer is winsock DP. 

Arguments:

    CallBack - Supplies a pointer to the callback routine

Return Value:

    NTSTATUS code. Returns STATUS_SUCCESS if we could sucessfully register
    the callback.
--*/
{
    NTSTATUS status;

    status = NtQuerySystemInformation(SystemRangeStartInformation,
                                      &RtlSecureMemorySystemRangeStart,
                                      sizeof(RtlSecureMemorySystemRangeStart),
                                      NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!RtlSecureMemoryCacheCallback) {
        RtlSecureMemoryCacheCallback = Callback;
        return STATUS_SUCCESS;
    } else {
        return STATUS_NO_MORE_ENTRIES;
    }
}

BOOLEAN
RtlFlushSecureMemoryCache(
    IN PVOID   lpAddr,
    IN SIZE_T  size
    )
/*++

Routine Description:

    This routine is called from various Win32 and Heap APIs whenever memory is freed
    or its protections are changed. We call the callback routine that has been registered.
    Its possible that size is 0 which means that this routine has to figure out the region
    size. The NtQueryVirtualMemory API is used for this. Unfortunately this API does not 
    provide us the right boundary of the region. So we loop until the state changes to MEM_FREE.
    This will guarantee that a region boundary has been found. This implies that we might unlock
    more pages than we have to.

Arguments:

    lpAddr - Pointer to the address thats getting freed or its protections changed.
    size   - Size of the address range. Can be zero.

Return Value:

    Returns TRUE if the callback was successful.
    
--*/
{
    ULONG_PTR   addr; 
    SIZE_T  regionSize;
    ULONG   regType;
    ULONG   regState;
    MEMORY_BASIC_INFORMATION    memInfo;
    NTSTATUS   status;
    PRTL_SECURE_MEMORY_CACHE_CALLBACK Callback;


    Callback = RtlSecureMemoryCacheCallback;
    if (Callback) {

        if (!size) {
            //
            // Compute the real size of the region
            //

            addr = (ULONG_PTR)lpAddr;
            status = NtQueryVirtualMemory( NtCurrentProcess(),
                                           (PVOID)addr,
                                           MemoryBasicInformation,
                                           (PMEMORY_BASIC_INFORMATION)&memInfo,
                                           sizeof(memInfo),
                                           NULL
                                         );
            if (!NT_SUCCESS(status)) {
                return FALSE;
            }
            if (memInfo.State == MEM_FREE) {
                return FALSE;
            }
            while (1) {
                size += memInfo.RegionSize;
                regState = memInfo.State;
                addr = addr + memInfo.RegionSize;

                if (addr > RtlSecureMemorySystemRangeStart) {
                    break;
                }

                status = NtQueryVirtualMemory( NtCurrentProcess(),
                                               (PVOID)addr,
                                               MemoryBasicInformation,
                                               (PMEMORY_BASIC_INFORMATION)&memInfo,
                                               sizeof(memInfo),
                                               NULL
                                             );

                if (!NT_SUCCESS(status)) {
                    return FALSE;
                }

                if (memInfo.State == MEM_FREE) {
                    break;
                }

            }
        }

        status = Callback(lpAddr, size);

        return (NT_SUCCESS(status));
    }
    return FALSE;
}

NTSTATUS
RtlpSecMemFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
     )
/*++

Routine Description:

    This routine is called from the HEAP APIs to free virtual memory. In addition to calling
    NtFreeVirtualMemory it tries to flush the secure memory cache.

Arguments:

    The arguments are identical to NtFreeVirtualMemory. 
Return Value:

    Returns TRUE if the callback was successful.
    
--*/
{
    NTSTATUS    status;

    status = NtFreeVirtualMemory( ProcessHandle, 
                                  BaseAddress,
                                  RegionSize,
                                  FreeType
                                  );
    
    if (status == STATUS_INVALID_PAGE_PROTECTION) {

        if ((ProcessHandle == NtCurrentProcess()) && RtlFlushSecureMemoryCache(*BaseAddress, *RegionSize)) {
            status = NtFreeVirtualMemory( ProcessHandle, 
                                          BaseAddress,
                                          RegionSize,
                                          FreeType
                                          );
            return status;
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\rtlexec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rtlexec.c

Abstract:

    User Mode routines for creating user mode processes and threads.

Author:

    Steve Wood (stevewo) 18-Aug-1989

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include "ntrtlp.h"
#include <nturtl.h>
#include <string.h>
#include "init.h"
#include "ntos.h"
#define ROUND_UP( x, y )  ((ULONG)(x) + ((y)-1) & ~((y)-1))
#ifdef KERNEL
#define ISTERMINALSERVER() (SharedUserData->SuiteMask & (1 << TerminalServer))
#else
#define ISTERMINALSERVER() (USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))
#endif

VOID
RtlpCopyProcString(
    IN OUT PWSTR *pDst,
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN ULONG DstAlloc OPTIONAL
    );

NTSTATUS
RtlpOpenImageFile(
    IN PUNICODE_STRING ImagePathName,
    IN ULONG Attributes,
    OUT PHANDLE FileHandle,
    IN BOOLEAN ReportErrors
    );

NTSTATUS
RtlpFreeStack(
    IN HANDLE Process,
    IN PINITIAL_TEB InitialTeb
    );

NTSTATUS
RtlpCreateStack(
    IN HANDLE Process,
    IN SIZE_T MaximumStackSize OPTIONAL,
    IN SIZE_T CommittedStackSize OPTIONAL,
    IN ULONG ZeroBits OPTIONAL,
    OUT PINITIAL_TEB InitialTeb
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(INIT,RtlpCopyProcString          )
#pragma alloc_text(INIT,RtlCreateProcessParameters  )
#pragma alloc_text(INIT,RtlDestroyProcessParameters )
#pragma alloc_text(INIT,RtlNormalizeProcessParams   )
#pragma alloc_text(INIT,RtlDeNormalizeProcessParams )
#pragma alloc_text(INIT,RtlpOpenImageFile           )
#pragma alloc_text(PAGE,RtlpCreateStack             )
#pragma alloc_text(PAGE,RtlpFreeStack               )
#pragma alloc_text(INIT,RtlCreateUserProcess        )
#pragma alloc_text(PAGE,RtlCreateUserThread         )
#pragma alloc_text(INIT,RtlExitUserThread           )
#endif

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("INITCONST")
#endif
const UNICODE_STRING NullString = {0, 1, L""};

VOID
RtlpCopyProcString(
    IN OUT PWSTR *pDst,
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN ULONG DstAlloc OPTIONAL
    )
{
    if (!ARGUMENT_PRESENT( (ULONG_PTR)DstAlloc )) {
        DstAlloc = SourceString->MaximumLength;
        }

    ASSERT((SourceString->Length == 0) || (SourceString->Buffer != NULL));

    if (SourceString->Buffer != NULL && SourceString->Length != 0) {
        RtlMoveMemory( *pDst,
                       SourceString->Buffer,
                       SourceString->Length
                     );
        }

    DestString->Buffer = *pDst;
    DestString->Length = SourceString->Length;
    DestString->MaximumLength = (USHORT)DstAlloc;

    *pDst = (PWSTR)((PCHAR)(*pDst) + ROUND_UP( DstAlloc, sizeof( ULONG ) ) );
    return;
}

NTSTATUS
RtlCreateProcessParameters(
    OUT PRTL_USER_PROCESS_PARAMETERS *ProcessParameters,
    IN PUNICODE_STRING ImagePathName,
    IN PUNICODE_STRING DllPath OPTIONAL,
    IN PUNICODE_STRING CurrentDirectory OPTIONAL,
    IN PUNICODE_STRING CommandLine OPTIONAL,
    IN PVOID Environment OPTIONAL,
    IN PUNICODE_STRING WindowTitle OPTIONAL,
    IN PUNICODE_STRING DesktopInfo OPTIONAL,
    IN PUNICODE_STRING ShellInfo OPTIONAL,
    IN PUNICODE_STRING RuntimeData OPTIONAL
    )

/*++

Routine Description:

    This function formats NT style RTL_USER_PROCESS_PARAMETERS
    record.  The record is self-contained in a single block of memory
    allocated by this function.  The allocation method is opaque and
    thus the record must be freed by calling the
    RtlDestroyProcessParameters function.

    The process parameters record is created in a de-normalized form,
    thus making it suitable for passing to the RtlCreateUserProcess
    function.  It is expected that the caller will fill in additional
    fields in the process parameters record after this function returns,
    but prior to calling RtlCreateUserProcess.

Arguments:

    ProcessParameters - Pointer to a variable that will receive the address
        of the process parameter structure created by this routinue.  The
        memory for the structure is allocated in an opaque manner and must
        be freed by calling RtlDestroyProcessParameters.

    ImagePathName - Required parameter that is the fully qualified NT
        path name of the image file that will be used to create the process
        that will received these parameters.

    DllPath - An optional parameter that is an NT String variable pointing
        to the search path the NT Loader is to use in the target process
        when searching for Dll modules.  If not specified, then the Dll
        search path is filled in from the current process's Dll search
        path.

    CurrentDirectory - An optional parameter that is an NT String variable
        pointing to the default directory string for the target process.
        If not specified, then the current directory string is filled in
        from the current process's current directory string.

    CommandLine - An optional parameter that is an NT String variable that
        will be passed to the target process as its command line.  If not
        specified, then the command line passed to the target process will
        be a null string.

    Environment - An optional parameter that is an opaque pointer to an
        environment variable block of the type created by
        RtlCreateEnvironment routine.  If not specified, then the target
        process will receive a copy of the calling process's environment
        variable block.

    WindowTitle - An optional parameter that is an NT String variable that
        points to the title string the target process is to use for its
        main window.  If not specified, then a null string will be passed
        to the target process as its default window title.

    DesktopInfo - An optional parameter that is an NT String variable that
        contains uninterpreted data that is passed as is to the target
        process.  If not specified, the target process will receive a
        pointer to an empty string.

    ShellInfo - An optional parameter that is an NT String variable that
        contains uninterpreted data that is passed as is to the target
        process.  If not specified, the target process will receive a
        pointer to an empty string.

    RuntimeData - An optional parameter that is an NT String variable that
        contains uninterpreted data that is passed as is to the target
        process.  If not specified, the target process will receive a
        pointer to an empty string.

Return Value:

    STATUS_SUCCESS - The process parameters is De-Normalized and
        contains entries for each of the specified argument and variable
        strings.

    STATUS_BUFFER_TOO_SMALL - The specified process parameters buffer is
        too small to contain the argument and environment strings. The value
        of ProcessParameters->Length is modified to contain the buffer
        size needed to contain the argument and variable strings.

--*/

{
    PRTL_USER_PROCESS_PARAMETERS p;
    NTSTATUS Status;
    ULONG ByteCount;
    SIZE_T MaxByteCount;
    PWSTR pDst;
    PPEB Peb = NtCurrentPeb();
    HANDLE CurDirHandle;

    //
    // Acquire the Peb Lock for the duration while we copy information out
    // of it.
    //

    RtlAcquirePebLock();
    Status = STATUS_SUCCESS;
    p = NULL;
    CurDirHandle = NULL;
    try {
        //
        //  Validate input parameters
        //

#define VALIDATE_STRING_PARAMETER(_x) \
    do { \
        ASSERT(ARGUMENT_PRESENT((_x))); \
        if (!ARGUMENT_PRESENT((_x))) { \
            Status = STATUS_INVALID_PARAMETER; \
            leave; \
        } \
        if (ARGUMENT_PRESENT((_x))) { \
            ASSERT((_x)->MaximumLength >= (_x)->Length); \
            ASSERT(((_x)->Length == 0) || ((_x)->Buffer != NULL)); \
            if (((_x)->MaximumLength < (_x)->Length) || \
                (((_x)->Length != 0) && ((_x)->Buffer == NULL))) { \
                Status = STATUS_INVALID_PARAMETER; \
                leave; \
            } \
        } \
    } while (0)

#define VALIDATE_OPTIONAL_STRING_PARAMETER(_x) \
    do { \
        if (ARGUMENT_PRESENT((_x))) { \
            ASSERT((_x)->MaximumLength >= (_x)->Length); \
            ASSERT(((_x)->Length == 0) || ((_x)->Buffer != NULL)); \
            if (((_x)->MaximumLength < (_x)->Length) || \
                (((_x)->Length != 0) && ((_x)->Buffer == NULL))) { \
                Status = STATUS_INVALID_PARAMETER; \
                leave; \
            } \
        } \
    } while (0)

        VALIDATE_STRING_PARAMETER(ImagePathName);
        VALIDATE_OPTIONAL_STRING_PARAMETER(DllPath);
        VALIDATE_OPTIONAL_STRING_PARAMETER(CurrentDirectory);
        VALIDATE_OPTIONAL_STRING_PARAMETER(CommandLine);
        VALIDATE_OPTIONAL_STRING_PARAMETER(WindowTitle);
        VALIDATE_OPTIONAL_STRING_PARAMETER(DesktopInfo);
        VALIDATE_OPTIONAL_STRING_PARAMETER(ShellInfo);
        VALIDATE_OPTIONAL_STRING_PARAMETER(RuntimeData);

#undef VALIDATE_STRING_PARAMETER
#undef VALIDATE_OPTIONAL_STRING_PARAMETER

        //
        // For optional pointer parameters, default them to point to their
        // corresponding field in the current process's process parameter
        // structure or to a null string.
        //

        if (!ARGUMENT_PRESENT( DllPath )) {
            DllPath = &Peb->ProcessParameters->DllPath;
        }

        if (!ARGUMENT_PRESENT( CurrentDirectory )) {

            if ( Peb->ProcessParameters->CurrentDirectory.Handle ) {
                CurDirHandle = (HANDLE)((ULONG_PTR)Peb->ProcessParameters->CurrentDirectory.Handle & ~OBJ_HANDLE_TAGBITS);
                CurDirHandle = (HANDLE)((ULONG_PTR)CurDirHandle | RTL_USER_PROC_CURDIR_INHERIT);
                }
            CurrentDirectory = &Peb->ProcessParameters->CurrentDirectory.DosPath;
            }
        else {
            ASSERT(CurrentDirectory->MaximumLength >= CurrentDirectory->Length);
            ASSERT((CurrentDirectory->Length == 0) || (CurrentDirectory->Buffer != NULL));

            if ( Peb->ProcessParameters->CurrentDirectory.Handle ) {
                CurDirHandle = (HANDLE)((ULONG_PTR)Peb->ProcessParameters->CurrentDirectory.Handle & ~OBJ_HANDLE_TAGBITS);
                CurDirHandle = (HANDLE)((ULONG_PTR)CurDirHandle | RTL_USER_PROC_CURDIR_CLOSE);
                }
            }

        if (!ARGUMENT_PRESENT( CommandLine )) {
            CommandLine = ImagePathName;
            }

        if (!ARGUMENT_PRESENT( Environment )) {
            Environment = Peb->ProcessParameters->Environment;
            }

        if (!ARGUMENT_PRESENT( WindowTitle )) {
            WindowTitle = (PUNICODE_STRING)&NullString;
            }

        if (!ARGUMENT_PRESENT( DesktopInfo )) {
            DesktopInfo = (PUNICODE_STRING)&NullString;
            }

        if (!ARGUMENT_PRESENT( ShellInfo )) {
            ShellInfo = (PUNICODE_STRING)&NullString;
            }

        if (!ARGUMENT_PRESENT( RuntimeData )) {
            RuntimeData = (PUNICODE_STRING)&NullString;
            }

        //
        // Determine size need to contain the process parameter record
        // structure and all of the strings it will point to.  Each string
        // will be aligned on a ULONG byte boundary.
        //

        ByteCount = sizeof( **ProcessParameters );
        ByteCount += ROUND_UP( ImagePathName->Length + sizeof(UNICODE_NULL),    sizeof( ULONG ) );
        ByteCount += ROUND_UP( DllPath->MaximumLength,       sizeof( ULONG ) );
        ByteCount += ROUND_UP( DOS_MAX_PATH_LENGTH*2,        sizeof( ULONG ) );
        ByteCount += ROUND_UP( CommandLine->Length + sizeof(UNICODE_NULL),      sizeof( ULONG ) );
        ByteCount += ROUND_UP( WindowTitle->MaximumLength,   sizeof( ULONG ) );
        ByteCount += ROUND_UP( DesktopInfo->MaximumLength,   sizeof( ULONG ) );
        ByteCount += ROUND_UP( ShellInfo->MaximumLength,     sizeof( ULONG ) );
        ByteCount += ROUND_UP( RuntimeData->MaximumLength,   sizeof( ULONG ) );

        //
        // Allocate memory for the process parameter record.
        //

        MaxByteCount = ByteCount;
        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&p,
                                          0,
                                          &MaxByteCount,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }

        p->MaximumLength = (ULONG) MaxByteCount;
        p->Length = ByteCount;
        p->Flags = RTL_USER_PROC_PARAMS_NORMALIZED;
        p->Environment = Environment;
        p->CurrentDirectory.Handle = CurDirHandle;

        //
        // Inherits ^C inhibit information
        //

        p->ConsoleFlags = Peb->ProcessParameters->ConsoleFlags;

        pDst = (PWSTR)(p + 1);
        RtlpCopyProcString( &pDst,
                            &p->CurrentDirectory.DosPath,
                            CurrentDirectory,
                            DOS_MAX_PATH_LENGTH*2
                          );

        RtlpCopyProcString( &pDst, &p->DllPath, DllPath, 0 );
        RtlpCopyProcString( &pDst, &p->ImagePathName, ImagePathName, ImagePathName->Length + sizeof(UNICODE_NULL) );
        if (CommandLine->Length == CommandLine->MaximumLength) {
            RtlpCopyProcString( &pDst, &p->CommandLine, CommandLine, 0 );
            }
        else {
            RtlpCopyProcString( &pDst, &p->CommandLine, CommandLine, CommandLine->Length + sizeof(UNICODE_NULL) );
            }
        RtlpCopyProcString( &pDst, &p->WindowTitle, WindowTitle, 0 );
        RtlpCopyProcString( &pDst, &p->DesktopInfo, DesktopInfo, 0 );
        RtlpCopyProcString( &pDst, &p->ShellInfo,   ShellInfo, 0 );
        if (RuntimeData->Length != 0) {
            RtlpCopyProcString( &pDst, &p->RuntimeData, RuntimeData, 0 );
            }
        else {
            p->RuntimeData.Buffer = NULL;
            p->RuntimeData.Length = 0;
            p->RuntimeData.MaximumLength = 0;
            }
        *ProcessParameters = RtlDeNormalizeProcessParams( p );
        p = NULL;
        }
    finally {
        if (AbnormalTermination()) {
            Status = STATUS_ACCESS_VIOLATION;
            }

        if (p != NULL) {
            RtlDestroyProcessParameters( p );
            }

        RtlReleasePebLock();
        }

    return( Status );
}



NTSTATUS
RtlDestroyProcessParameters(
    IN PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    )
{
    NTSTATUS Status;
    SIZE_T RegionSize;

    RegionSize = 0;
    Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                  (PVOID *)&ProcessParameters,
                                  &RegionSize,
                                  MEM_RELEASE
                                );

    return( Status );
}


#define RtlpNormalizeProcessParam( Base, p )        \
    if ((p) != NULL) {                              \
        (p) = (PWSTR)((PCHAR)(p) + (ULONG_PTR)(Base));  \
        }                                           \

#define RtlpDeNormalizeProcessParam( Base, p )      \
    if ((p) != NULL) {                              \
        (p) = (PWSTR)((PCHAR)(p) - (ULONG_PTR)(Base));  \
        }                                           \


PRTL_USER_PROCESS_PARAMETERS
RtlNormalizeProcessParams(
    IN OUT PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    )
{
    if (!ARGUMENT_PRESENT( ProcessParameters )) {
        return( NULL );
        }

    if (ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED) {
        return( ProcessParameters );
        }

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->CurrentDirectory.DosPath.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->DllPath.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->ImagePathName.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->CommandLine.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->WindowTitle.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->DesktopInfo.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->ShellInfo.Buffer
                             );

    RtlpNormalizeProcessParam( ProcessParameters,
                               ProcessParameters->RuntimeData.Buffer
                             );
    ProcessParameters->Flags |= RTL_USER_PROC_PARAMS_NORMALIZED;

    return( ProcessParameters );
}

PRTL_USER_PROCESS_PARAMETERS
RtlDeNormalizeProcessParams(
    IN OUT PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    )
{
    if (!ARGUMENT_PRESENT( ProcessParameters )) {
        return( NULL );
        }

    if (!(ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
        return( ProcessParameters );
        }

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->CurrentDirectory.DosPath.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->DllPath.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->ImagePathName.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->CommandLine.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->WindowTitle.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->DesktopInfo.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->ShellInfo.Buffer
                               );

    RtlpDeNormalizeProcessParam( ProcessParameters,
                                 ProcessParameters->RuntimeData.Buffer
                               );

    ProcessParameters->Flags &= ~RTL_USER_PROC_PARAMS_NORMALIZED;
    return( ProcessParameters );
}

NTSTATUS
RtlpOpenImageFile(
    IN PUNICODE_STRING ImagePathName,
    IN ULONG Attributes,
    OUT PHANDLE FileHandle,
    IN BOOLEAN ReportErrors
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE File;
    IO_STATUS_BLOCK IoStatus;

    *FileHandle = NULL;

    InitializeObjectAttributes( &ObjectAttributes,
                                ImagePathName,
                                Attributes,
                                NULL,
                                NULL
                              );
    Status = ZwOpenFile( &File,
                         SYNCHRONIZE | FILE_EXECUTE,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_DELETE,
                         FILE_NON_DIRECTORY_FILE
                         );

    if (!NT_SUCCESS( Status )) {
#if DBG
        if (ReportErrors) {
            DbgPrint( "NTRTL: RtlpOpenImageFile - NtCreateFile( %wZ ) failed.  Status == %X\n",
                      ImagePathName,
                      Status
                    );
            }
#endif // DBG
        return( Status );
        }

    *FileHandle = File;
    return( STATUS_SUCCESS );
}


NTSTATUS
RtlpCreateStack(
    IN HANDLE Process,
    IN SIZE_T MaximumStackSize OPTIONAL,
    IN SIZE_T CommittedStackSize OPTIONAL,
    IN ULONG ZeroBits OPTIONAL,
    OUT PINITIAL_TEB InitialTeb
    )
{
    NTSTATUS Status;
    PCH Stack;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOLEAN GuardPage;
    SIZE_T RegionSize;
    ULONG OldProtect;
#if defined(_IA64_)
    PCH Bstore;
    SIZE_T CommittedBstoreSize;
    SIZE_T MaximumBstoreSize;
    SIZE_T MstackPlusBstoreSize;
#endif

    Status = ZwQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&SysInfo,
                                       sizeof( SysInfo ),
                                       NULL
                                     );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
        }

    //
    // if stack is in the current process, then default to
    // the parameters from the image
    //

    if ( Process == NtCurrentProcess() ) {
        PPEB Peb;
        PIMAGE_NT_HEADERS NtHeaders;


        Peb = NtCurrentPeb();
        NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);

        if (!NtHeaders) {
            return STATUS_INVALID_IMAGE_FORMAT;
        }


        if (!MaximumStackSize) {
            MaximumStackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
            }

        if (!CommittedStackSize) {
            CommittedStackSize = NtHeaders->OptionalHeader.SizeOfStackCommit;
            }

        }
    else {

        if (!CommittedStackSize) {
            CommittedStackSize = SysInfo.PageSize;
            }

        if (!MaximumStackSize) {
            MaximumStackSize = SysInfo.AllocationGranularity;
            }

        }

    //
    // Enforce a minimal stack commit if there is a PEB setting
    // for this.
    //

#if !defined(NTOS_KERNEL_RUNTIME)
    {
        SIZE_T MinimumStackCommit;

        MinimumStackCommit = NtCurrentPeb()->MinimumStackCommit;
        
        if (MinimumStackCommit != 0 && CommittedStackSize < MinimumStackCommit) {
            CommittedStackSize = MinimumStackCommit;
        }
    }
#endif

    if ( CommittedStackSize >= MaximumStackSize ) {
        MaximumStackSize = ROUND_UP(CommittedStackSize, (1024*1024));
        }


    CommittedStackSize = ROUND_UP( CommittedStackSize, SysInfo.PageSize );
    MaximumStackSize = ROUND_UP( MaximumStackSize,
                                 SysInfo.AllocationGranularity
                               );

    Stack = NULL;

#if defined(_IA64_)

    //
    // Piggyback the backing store with the memory stack
    //

    CommittedBstoreSize = CommittedStackSize;
    MaximumBstoreSize = MaximumStackSize;
    MstackPlusBstoreSize = MaximumBstoreSize + MaximumStackSize;

    Status = ZwAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      ZeroBits,
                                      &MstackPlusBstoreSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
#else

    Status = ZwAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      ZeroBits,
                                      &MaximumStackSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
#endif // defined(_IA64_)

    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "NTRTL: RtlpCreateStack( %lx ) failed.  Stack Reservation Status == %X\n",
                  Process,
                  Status
                );
#endif // DBG
        return( Status );
        }

#if defined(_IA64_)
    InitialTeb->OldInitialTeb.OldBStoreLimit = NULL;
#endif // defined(_IA64_)

    InitialTeb->OldInitialTeb.OldStackBase = NULL;
    InitialTeb->OldInitialTeb.OldStackLimit = NULL;
    InitialTeb->StackAllocationBase = Stack;
    InitialTeb->StackBase = Stack + MaximumStackSize;

    Stack += MaximumStackSize - CommittedStackSize;
    if (MaximumStackSize > CommittedStackSize) {
        Stack -= SysInfo.PageSize;
        CommittedStackSize += SysInfo.PageSize;
        GuardPage = TRUE;
        }
    else {
        GuardPage = FALSE;
        }
    Status = ZwAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &CommittedStackSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    InitialTeb->StackLimit = Stack;

    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "NTRTL: RtlpCreateStack( %lx ) failed.  Stack Commit Status == %X\n",
                  Process,
                  Status
                );
#endif // DBG
        return( Status );
        }

    //
    // if we have space, create a guard page.
    //

    if (GuardPage) {
        RegionSize =  SysInfo.PageSize;
        Status = ZwProtectVirtualMemory( Process,
                                         (PVOID *)&Stack,
                                         &RegionSize,
                                         PAGE_GUARD | PAGE_READWRITE,
                                         &OldProtect);


        if ( !NT_SUCCESS( Status ) ) {
#if DBG
            DbgPrint( "NTRTL: RtlpCreateStack( %lx ) failed.  Guard Page Creation Status == %X\n",
                      Process,
                      Status
                    );
#endif // DBG
            return( Status );
            }
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit + RegionSize);
        }

#if defined(_IA64_)

    //
    // Commit backing store pages and create guard pages if there is space
    //

    Bstore = InitialTeb->StackBase;
    if (MaximumBstoreSize > CommittedBstoreSize) {
        CommittedBstoreSize += SysInfo.PageSize;
        GuardPage = TRUE;
    } else {
        GuardPage = FALSE;
    }

    Status = ZwAllocateVirtualMemory( Process,
                                      (PVOID *)&Bstore,
                                      0,
                                      &CommittedBstoreSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );

    InitialTeb->BStoreLimit = Bstore + CommittedBstoreSize;

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        DbgPrint("NTRTL: RtlpCreateStack( %lx ) failed. Backing Store Commit Status == %X\n",
                 Process,
                 Status
                );
#endif // DBG
        return (Status);
    }

    if (GuardPage) {
        Bstore = (PCH)InitialTeb->BStoreLimit - SysInfo.PageSize;
        RegionSize = SysInfo.PageSize;
        Status = ZwProtectVirtualMemory(Process,
                                        (PVOID *)&Bstore,
                                        &RegionSize,
                                        PAGE_GUARD | PAGE_READWRITE,
                                        &OldProtect
                                       );
        if ( !NT_SUCCESS(Status) ) {
#if DBG
            DbgPrint("NTRTL: RtlpCreateStack( %lx ) failed.  Backing Store Guard Page Creation Status == %X\n",
                     Process,
                     Status
                    );
#endif // DBG
            return (Status);
        }
        InitialTeb->BStoreLimit = (PVOID)((PUCHAR)InitialTeb->BStoreLimit - RegionSize);
    }

#endif // defined(_IA64_)

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlpFreeStack(
    IN HANDLE Process,
    IN PINITIAL_TEB InitialTeb
    )
{
    NTSTATUS Status;
    SIZE_T Zero;

    Zero = 0;
    Status = ZwFreeVirtualMemory( Process,
                                  &InitialTeb->StackAllocationBase,
                                  &Zero,
                                  MEM_RELEASE
                                );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "NTRTL: RtlpFreeStack( %lx ) failed.  Stack DeCommit Status == %X\n",
                  Process,
                  Status
                );
#endif // DBG
        return( Status );
        }

    RtlZeroMemory( InitialTeb, sizeof( *InitialTeb ) );
    return( STATUS_SUCCESS );
}


NTSTATUS
RtlCreateUserProcess(
    IN PUNICODE_STRING NtImagePathName,
    IN ULONG Attributes,
    IN PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    IN PSECURITY_DESCRIPTOR ProcessSecurityDescriptor OPTIONAL,
    IN PSECURITY_DESCRIPTOR ThreadSecurityDescriptor OPTIONAL,
    IN HANDLE ParentProcess OPTIONAL,
    IN BOOLEAN InheritHandles,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL,
    OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation
    )

/*++

Routine Description:

    This function creates a user mode process with a single thread with
    a suspend count of one.  The address space of the new process is
    initialized with the contents of specified image file.  The caller
    can specify the Access Control List for the new process and thread.
    The caller can also specify the parent process to inherit process
    priority and processor affinity from.  The default is to inherit
    these from the current process.  Finally the caller can specify
    whether the new process is to inherit any of the object handles
    from the specified parent process or not.

    Information about the new process and thread is returned via
    the ProcessInformation parameter.

Arguments:

    NtImagePathName - A required pointer that points to the NT Path string
        that identifies the image file that is to be loaded into the
        child process.

    ProcessParameters - A required pointer that points to parameters that
        are to passed to the child process.

    ProcessSecurityDescriptor - An optional pointer to the Security Descriptor
        give to the new process.

    ThreadSecurityDescriptor - An optional pointer to the Security Descriptor
        give to the new thread.

    ParentProcess - An optional process handle that will used to inherit
        certain properties from.

    InheritHandles - A boolean value.  TRUE specifies that object handles
        associated with the specified parent process are to be inherited
        by the new process, provided they have the OBJ_INHERIT attribute.
        FALSE specifies that the new process is to inherit no handles.

    DebugPort - An optional handle to the debug port associated with this
        process.

    ExceptionPort - An optional handle to the exception port associated with this
        process.

    ProcessInformation - A pointer to a variable that receives information
        about the new process and thread.

Return Value:

    TBS.

--*/

{
    NTSTATUS Status;
    HANDLE Section, File;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PRTL_USER_PROCESS_PARAMETERS Parameters;
    SIZE_T ParameterLength;
    PVOID Environment;
    PWCHAR s;
    SIZE_T EnvironmentLength;
    SIZE_T RegionSize;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    PPEB Peb;
    UNICODE_STRING Unicode;

    //
    // Zero output parameter and probe the addresses at the same time
    //

    RtlZeroMemory( ProcessInformation, sizeof( *ProcessInformation ) );
    ProcessInformation->Length = sizeof( *ProcessInformation );

    //
    // Open the specified image file.
    //

    Status = RtlpOpenImageFile( NtImagePathName,
                                Attributes & (OBJ_INHERIT | OBJ_CASE_INSENSITIVE),
                                &File,
                                TRUE
                              );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }


    //
    // Create a memory section backed by the opened image file
    //

    Status = ZwCreateSection( &Section,
                              SECTION_ALL_ACCESS,
                              NULL,
                              NULL,
                              PAGE_EXECUTE,
                              SEC_IMAGE,
                              File
                            );
    ZwClose( File );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
        }


    //
    // Create the user mode process, defaulting the parent process to the
    // current process if one is not specified.  The new process will not
    // have a name nor will the handle be inherited by other processes.
    //

    if (!ARGUMENT_PRESENT( ParentProcess )) {
        ParentProcess = NtCurrentProcess();
        }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL,
                                ProcessSecurityDescriptor );
    if ( RtlGetNtGlobalFlags() & FLG_ENABLE_CSRDEBUG ) {
        if ( wcsstr(NtImagePathName->Buffer,L"csrss") ||
             wcsstr(NtImagePathName->Buffer,L"CSRSS")
           ) {

            //
            // For Hydra we don't name the CSRSS process to avoid name
            // collissions when multiple CSRSS's are started
            //
            if (ISTERMINALSERVER()) {

                InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL,
                                            ProcessSecurityDescriptor );
            } else {

                RtlInitUnicodeString(&Unicode,L"\\WindowsSS");
                InitializeObjectAttributes( &ObjectAttributes, &Unicode, 0, NULL,
                                            ProcessSecurityDescriptor );
            }

            }
        }

    if ( !InheritHandles ) {
        ProcessParameters->CurrentDirectory.Handle = NULL;
        }
    Status = ZwCreateProcess( &ProcessInformation->Process,
                              PROCESS_ALL_ACCESS,
                              &ObjectAttributes,
                              ParentProcess,
                              InheritHandles,
                              Section,
                              DebugPort,
                              ExceptionPort
                            );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( Section );
        return( Status );
        }


    //
    // Retreive the interesting information from the image header
    //

    Status = ZwQuerySection( Section,
                             SectionImageInformation,
                             &ProcessInformation->ImageInformation,
                             sizeof( ProcessInformation->ImageInformation ),
                             NULL
                           );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    Status = ZwQueryInformationProcess( ProcessInformation->Process,
                                        ProcessBasicInformation,
                                        &ProcessInfo,
                                        sizeof( ProcessInfo ),
                                        NULL
                                      );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    Peb = ProcessInfo.PebBaseAddress;

    //
    // Duplicate Native handles into new process if any specified.
    // Note that the duplicated handles will overlay the input values.
    //

    try {
        Status = STATUS_SUCCESS;

        if ( ProcessParameters->StandardInput ) {

            Status = ZwDuplicateObject(
                        ParentProcess,
                        ProcessParameters->StandardInput,
                        ProcessInformation->Process,
                        &ProcessParameters->StandardInput,
                        0L,
                        0L,
                        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
                        );
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }

        if ( ProcessParameters->StandardOutput ) {

            Status = ZwDuplicateObject(
                        ParentProcess,
                        ProcessParameters->StandardOutput,
                        ProcessInformation->Process,
                        &ProcessParameters->StandardOutput,
                        0L,
                        0L,
                        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
                        );
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }

        if ( ProcessParameters->StandardError ) {

            Status = ZwDuplicateObject(
                        ParentProcess,
                        ProcessParameters->StandardError,
                        ProcessInformation->Process,
                        &ProcessParameters->StandardError,
                        0L,
                        0L,
                        DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES
                        );
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }

    } finally {
        if ( !NT_SUCCESS(Status) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            }
        }

    //
    // Possibly reserve some address space in the new process
    //

    if (ProcessInformation->ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_NATIVE ) {
        if ( ProcessParameters->Flags & RTL_USER_PROC_RESERVE_1MB ) {

#if defined(_IA64_)
            Environment = (PVOID)(UADDRESS_BASE+4);
#else
            Environment = (PVOID)(4);
#endif
            RegionSize = (1024*1024)-(256);

            Status = ZwAllocateVirtualMemory( ProcessInformation->Process,
                                              (PVOID *)&Environment,
                                              0,
                                              &RegionSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE
                                            );
            if ( !NT_SUCCESS( Status ) ) {
                ZwClose( ProcessInformation->Process );
                ZwClose( Section );
                return( Status );
                }
            }
        }

    //
    // Allocate virtual memory in the new process and use NtWriteVirtualMemory
    // to write a copy of the process environment block into the address
    // space of the new process.  Save the address of the allocated block in
    // the process parameter block so the new process can access it.
    //

    if (s = (PWCHAR)ProcessParameters->Environment) {
        while (*s++) {
            while (*s++) {
                }
            }
        EnvironmentLength = (SIZE_T)(s - (PWCHAR)ProcessParameters->Environment) * sizeof(WCHAR);

        Environment = NULL;
        RegionSize = EnvironmentLength;
        Status = ZwAllocateVirtualMemory( ProcessInformation->Process,
                                          (PVOID *)&Environment,
                                          0,
                                          &RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if ( !NT_SUCCESS( Status ) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            return( Status );
            }

        Status = ZwWriteVirtualMemory( ProcessInformation->Process,
                                       Environment,
                                       ProcessParameters->Environment,
                                       EnvironmentLength,
                                       NULL
                                     );
        if ( !NT_SUCCESS( Status ) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            return( Status );
            }

        ProcessParameters->Environment = Environment;
        }

    //
    // Allocate virtual memory in the new process and use NtWriteVirtualMemory
    // to write a copy of the process parameters block into the address
    // space of the new process.  Set the initial parameter to the new thread
    // to be the address of the block in the new process's address space.
    //

    Parameters = NULL;
    ParameterLength = ProcessParameters->MaximumLength;
    Status = ZwAllocateVirtualMemory( ProcessInformation->Process,
                                      (PVOID *)&Parameters,
                                      0,
                                      &ParameterLength,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    Status = ZwWriteVirtualMemory( ProcessInformation->Process,
                                   Parameters,
                                   ProcessParameters,
                                   ProcessParameters->Length,
                                   NULL
                                 );
    if ( !NT_SUCCESS( Status ) ) {
            ZwClose( ProcessInformation->Process );
            ZwClose( Section );
            return( Status );
            }

    Status = ZwWriteVirtualMemory( ProcessInformation->Process,
                                   &Peb->ProcessParameters,
                                   &Parameters,
                                   sizeof( Parameters ),
                                   NULL
                                 );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    //
    // Create a suspended thread in the new process.  Specify the size and
    // position of the stack, along with the start address, initial parameter
    // and an SECURITY_DESCRIPTOR.  The new thread will not have a name and its handle will
    // not be inherited by other processes.
    //

    Status = RtlCreateUserThread(
                 ProcessInformation->Process,
                 ThreadSecurityDescriptor,
                 TRUE,
                 ProcessInformation->ImageInformation.ZeroBits,
                 ProcessInformation->ImageInformation.MaximumStackSize,
                 ProcessInformation->ImageInformation.CommittedStackSize,
                 (PUSER_THREAD_START_ROUTINE)
                     ProcessInformation->ImageInformation.TransferAddress,
                 (PVOID)Peb,
                 &ProcessInformation->Thread,
                 &ProcessInformation->ClientId
                 );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( ProcessInformation->Process );
        ZwClose( Section );
        return( Status );
        }

    //
    // Now close the section and file handles.  The objects they represent
    // will not actually go away until the process is destroyed.
    //

    ZwClose( Section );

    //
    // Return success status
    //

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlCreateUserThread(
    IN HANDLE Process,
    IN PSECURITY_DESCRIPTOR ThreadSecurityDescriptor OPTIONAL,
    IN BOOLEAN CreateSuspended,
    IN ULONG ZeroBits OPTIONAL,
    IN SIZE_T MaximumStackSize OPTIONAL,
    IN SIZE_T CommittedStackSize OPTIONAL,
    IN PUSER_THREAD_START_ROUTINE StartAddress,
    IN PVOID Parameter OPTIONAL,
    OUT PHANDLE Thread OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL
    )

/*++

Routine Description:

    This function creates a user mode thread in a user process.  The caller
    specifies the attributes of the new thread.  A handle to the thread, along
    with its Client Id are returned to the caller.

Arguments:

    Process - Handle to the target process in which to create the new thread.

    ThreadSecurityDescriptor - An optional pointer to the Security Descriptor
        give to the new thread.

    CreateSuspended - A boolean parameter that specifies whether or not the new
        thread is to be created suspended or not.  If TRUE, the new thread
        will be created with an initial suspend count of 1.  If FALSE then
        the new thread will be ready to run when this call returns.

    ZeroBits - This parameter is passed to the virtual memory manager
        when the stack is allocated.  Stacks are always allocated with the
        MEM_TOP_DOWN allocation attribute.

    MaximumStackSize - This is the maximum size of the stack.  This size
        will be rounded up to the next highest page boundary.  If zero is
        specified, then the default size will be 64K bytes.

    CommittedStackSize - This is the initial committed size of the stack.  This
        size is rounded up to the next highest page boundary and then an
        additional page is added for the guard page.  The resulting size
        will then be commited and the guard page protection initialized
        for the last committed page in the stack.

    StartAddress - The initial starting address of the thread.

    Parameter - An optional pointer to a 32-bit pointer parameter that is
        passed as a single argument to the procedure at the start address
        location.

    Thread - An optional pointer that, if specified, points to a variable that
        will receive the handle of the new thread.

    ClientId - An optional pointer that, if specified, points to a variable
        that will receive the Client Id of the new thread.

Return Value:

    TBS

--*/

{
    NTSTATUS Status;
    CONTEXT ThreadContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    INITIAL_TEB InitialTeb;
    HANDLE ThreadHandle;
    CLIENT_ID ThreadClientId;

    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //

    Status = RtlpCreateStack( Process,
                              MaximumStackSize,
                              CommittedStackSize,
                              ZeroBits,
                              &InitialTeb
                            );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    //
    // Create an initial context for the new thread.
    //


    try {
        RtlInitializeContext( Process,
                              &ThreadContext,
                              Parameter,
                              (PVOID)StartAddress,
                              InitialTeb.StackBase
                            );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        RtlpFreeStack( Process, &InitialTeb );
        return GetExceptionCode ();
    }

    //
    // Now create a thread in the target process.  The new thread will
    // not have a name and its handle will not be inherited by other
    // processes.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL,
                                ThreadSecurityDescriptor );
    Status = ZwCreateThread( &ThreadHandle,
                             THREAD_ALL_ACCESS,
                             &ObjectAttributes,
                             Process,
                             &ThreadClientId,
                             &ThreadContext,
                             &InitialTeb,
                             CreateSuspended
                           );
    if (!NT_SUCCESS( Status )) {
#if DBG
        DbgPrint( "NTRTL: RtlCreateUserThread Failed. NtCreateThread Status == %X\n",
                  Status );
#endif // DBG
        RtlpFreeStack( Process, &InitialTeb );
    } else {
        if (ARGUMENT_PRESENT( Thread )) {
            *Thread = ThreadHandle;
        } else {
            ZwClose (ThreadHandle);
        }

        if (ARGUMENT_PRESENT( ClientId )) {
            *ClientId = ThreadClientId;
        }

    }

    //
    // Return status
    //

    return( Status );
}

DECLSPEC_NORETURN
NTSYSAPI
VOID
NTAPI
RtlExitUserThread (
    IN NTSTATUS ExitStatus
    )
/*++

Routine Description:

    This function exits a thread created by RtlCreateUserThread in such a way as the stack is deallocated
    as well as the thread terminated.

Arguments:

    ExitStatus - Final exit status

Return Value:

    None

--*/
{
    NtCurrentTeb ()->FreeStackOnTermination = TRUE;
    NtTerminateThread (NtCurrentThread (), ExitStatus);
}

VOID
RtlFreeUserThreadStack(
    HANDLE hProcess,
    HANDLE hThread
    )
{
    NTSTATUS Status;
    PTEB Teb;
    THREAD_BASIC_INFORMATION ThreadInfo;
    PVOID StackDeallocationBase;
    SIZE_T Size;

    Status = NtQueryInformationThread( hThread,
                                       ThreadBasicInformation,
                                       &ThreadInfo,
                                       sizeof( ThreadInfo ),
                                       NULL
                                     );
    Teb = ThreadInfo.TebBaseAddress;
    if (!NT_SUCCESS( Status ) || !Teb) {
        return;
        }

    Status = NtReadVirtualMemory( hProcess,
                                  &Teb->DeallocationStack,
                                  &StackDeallocationBase,
                                  sizeof( StackDeallocationBase ),
                                  NULL
                                );
    if (!NT_SUCCESS( Status ) || !StackDeallocationBase) {
        return;
        }

    Size = 0;
    NtFreeVirtualMemory( hProcess, &StackDeallocationBase, &Size, MEM_RELEASE );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\slistfunc.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    slistfunc.c

Abstract:

    This module implements WIN64 SLIST functions.

Author:

    David N. Cutler (davec) 11-Feb-2001

Revision History:

--*/

#include "ntrtlp.h"

VOID
RtlpInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

{

    InitializeSListHead(SListHead);
    return;
}

USHORT
RtlpQueryDepthSList (
    IN PSLIST_HEADER SListHead
    )

/*++

Routine Description:

    This function queries the depth of the specified SLIST.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    The current depth of the specified SLIST is returned as the function
    value.

--*/

{
     return QueryDepthSList(SListHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\stdtimep.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stdtimep.h

Abstract:

    This module contains definitions and function prototypes which are local to
    stdime.c and fmttime.c.

Author:

    Rob McKaughan (t-robmc) 17-Jul-1991

Revision History:

--*/

#ifndef _STD_TIME_P_
#define _STD_TIME_P_

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

extern LARGE_INTEGER Magic10000;
#define SHIFT10000                       13

extern LARGE_INTEGER Magic10000000;
#define SHIFT10000000                    23

extern LARGE_INTEGER Magic86400000;
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000L )             \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros for Time Differentials and Time Revisions                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// The following define the minimum and maximum possible values for the Time
// Differential Factor as defined by ISO 4031-1978.
//

#define MAX_STDTIME_TDF (780)
#define MIN_STDTIME_TDF (-720)

//
// The revision of this design (will be inserted in the revision field of any
// STANDARD_TIMEs created by this revision).
//

#define STDTIME_REVISION (4)


//
// The number of bits we need to shift to get to and from a revision in a
// StdTime.TdfAndRevision field.
//

#define STDTIME_REVISION_SHIFT 12


//
// USHORT
// ShiftStandardTimeRevision(
//    IN USHORT Rev
//    )
// Description:
//    This routine shifts the given revision number to its proper place for
//    storing in a STANDARD_TIME.TdfAndRevision field.
//

#define ShiftStandardTimeRevision(Rev)                                        \
   ((USHORT) ((Rev) << STDTIME_REVISION_SHIFT))


//
// The pre-shifted value of the current revision
//

#define SHIFTED_STDTIME_REVISION (ShiftStandardTimeRevision(STDTIME_REVISION))


//
// The bit mask used to mask a STANDARD_TIME.TdfAndRevision field to retrieve
// the Tdf value.
//

#define TDF_MASK ((USHORT) 0x0fff)


//
// USHORT
// MaskStandardTimeTdf(
//    IN USHORT Tdf
//    )
// Description:
//    This routine masks the given tdf field with TDF_MASK and returns the
//    result.
//
// BUG: Byte order dependant
//

#define MaskStandardTimeTdf(Tdf) ((USHORT) ((Tdf) & TDF_MASK))


//
// SHORT
// GetStandardTimeTdf(
//    IN STANDARD_TIME
//    )
// Description:
//    This routine gets the Time Differential Factor from a tdf field and
//    makes any adjustments necessary to preserve the sign of the TDF.
//    The resulting TDF is returned.
//
//    Since the TDF is stored as a signed 12 bit int, it's sign bit is the
//    bit 0x0800.  To make it a 16 bit negative, we subtract 0x1000 from the
//    bottome 12 bits of the TdfAndRevision field.
//
// BUG: Byte order dependant
//

#define GetStandardTimeTdf(StdTime)                                           \
   ((SHORT)                                                                   \
     (((StdTime)->TdfAndRevision) & 0x0800)                                   \
        ? (MaskStandardTimeTdf((StdTime)->TdfAndRevision) - 0x1000)           \
        : MaskStandardTimeTdf((StdTime)->TdfAndRevision)                      \
   )


//
// USHORT
// GetStandardTimeRev(
//    IN USHORT Tdf
//    )
// Description:
//    This routine gets the revision number from a tdf field and returns it
//    shifted back down to its place as a SHORT.
//

#define GetStandardTimeRev(StdTime)                                           \
   ((USHORT) (((StdTime)->TdfAndRevision) >> STDTIME_REVISION_SHIFT))



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Tests for absolute and delta times                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// BOOLEAN
// IsPositive(
//    IN LARGE_INTEGER Time
//    )
// Returns:
//    TRUE - if the time in Time is positive.
//    FALSE - if Time is negative.
//

#define IsPositive(Time)                                                      \
   ( ((Time).HighPart > 0) || (((Time).HighPart = 0) & ((Time).LowPart > 0)) )

//
// BOOLEAN
// IsAbsoluteTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is an absolute time
//    FALSE - If the given time is not an absolute time
//

#define IsAbsoluteTime(Time)                                                  \
   ( IsPositive(Time->SimpleTime) )


//
// BOOLEAN
// IsDeltaTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is a delta time
//    FALSE - If the given time is not a delta time
//

#define IsDeltaTime(Time)                                                     \
   ( !IsAbsoluteTime(Time) )


//
// BOOLEAN
// GreaterThanTime(
//    IN PLARGE_INTEGER Time1,
//    IN PLARGE_INTEGER Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//
// BUG: Byte order dependant
// BUG: Only works on absolute times
//

#define GreaterThanTime(Time1, Time2)                                         \
   (                                                                          \
     ((Time1).HighPart > (Time2).HighPart)                                    \
     ||                                                                       \
     (                                                                        \
      ((Time1).HighPart == (Time2).HighPart)                                  \
      &&                                                                      \
      ((Time1).LowPart > (Time2).LowPart)                                     \
     )                                                                        \
   )


//
// BOOLEAN
// GreaterThanStandardTime(
//    IN PSTANDARD_TIME Time1,
//    IN PSTANDARD_TIME Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//

#define GreaterThanStdTime(Time1, Time2) \
   GreaterThanTime((Time1).SimpleTime, (Time2).SimpleTime)



//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//  The following definitions and declarations are some important constants  /
//  used in the time conversion routines                                     /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//
//  These are declared in time.c
//

extern const LARGE_INTEGER SecondsToStartOf1970;
extern const LARGE_INTEGER SecondsToStartOf1980;


//
//  ULONG
//  ElapsedDaysToYears (
//      IN ULONG ElapsedDays
//      );
//
//  To be completely true to the Gregorian calendar the equation to
//  go from days to years is really
//
//      ElapsedDays / 365.2425
//
//  But because we are doing the computation in ulong integer arithmetic
//  and the LARGE_INTEGER variable limits the number of expressible days to around
//  11,000,000 we use the following computation
//
//      (ElapsedDays * 128 + 127) / (365.2425 * 128)
//
//  which will be off from the Gregorian calendar in about 150,000 years
//  but that doesn't really matter because LARGE_INTEGER can only express around
//  30,000 years
//

#define ElapsedDaysToYears(DAYS) ( \
    ((DAYS) * 128 + 127) / 46751   \
    )

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )


//
// Local utlity function prototypes
//

VOID
RtlpConvert48To64(
   IN PSTDTIME_ERROR num48,
   OUT LARGE_INTEGER *num64
   );

NTSTATUS
RtlpConvert64To48(
   IN LARGE_INTEGER num64,
   OUT PSTDTIME_ERROR num48
   );

LARGE_INTEGER
RtlpTimeToLargeInt(
   IN LARGE_INTEGER Time
   );

LARGE_INTEGER
RtlpLargeIntToTime(
   IN LARGE_INTEGER Int
   );

NTSTATUS
RtlpAdd48Int(
   IN PSTDTIME_ERROR First48,
   IN PSTDTIME_ERROR Second48,
   IN PSTDTIME_ERROR Result48
   );

NTSTATUS
RtlpAddTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

NTSTATUS
RtlpSubtractTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

LARGE_INTEGER
RtlpAbsTime(
   IN LARGE_INTEGER Time
   );

#endif //_STD_TIME_P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\rtl\sertl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sertl.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

Author:

    Jim Kelly       (JimK)     23-Mar-1990
    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine

Revision History:


--*/


#include "ntrtlp.h"
#include <winerror.h>
#ifndef BLDR_KERNEL_RUNTIME
#include <stdio.h>
#include "seopaque.h"
#include "sertlp.h"
#ifdef NTOS_KERNEL_RUNTIME
#include <..\se\sep.h>
#else // NTOS_KERNEL_RUNTIME
#include <..\ntdll\ldrp.h>
#endif // NTOS_KERNEL_RUNTIME

#undef RtlEqualLuid

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualLuid (
    PLUID Luid1,
    PLUID Luid2
    );

NTSTATUS
RtlpConvertAclToAutoInherit (
    IN PACL ParentAcl OPTIONAL,
    IN PACL ChildAcl,
    IN GUID *ObjectType OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    );

BOOLEAN
RtlpCopyEffectiveAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN WillGenerateInheritAce,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN OUT PVOID *AcePosition,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited OPTIONAL,
    OUT PBOOLEAN EffectiveAceMapped,
    OUT PBOOLEAN AclOverflowed
    );

typedef enum {
     CopyInheritedAces,
     CopyNonInheritedAces,
     CopyAllAces } ACE_TYPE_TO_COPY;

NTSTATUS
RtlpCopyAces(
    IN PACL Acl,
    IN PGENERIC_MAPPING GenericMapping,
    IN ACE_TYPE_TO_COPY AceTypeToCopy,
    IN UCHAR AceFlagsToReset,
    IN BOOLEAN MapSids,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN RetainInheritedAceBit,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl
    );

NTSTATUS
RtlpGenerateInheritedAce (
    IN PACE_HEADER OldAce,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAceLength,
    OUT PACL NewAcl,
    OUT PULONG NewAceExtraLength,
    OUT PBOOLEAN ObjectAceInherited
    );

NTSTATUS
RtlpGenerateInheritAcl(
    IN PACL Acl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    OUT PULONG NewAclSizeParam,
    OUT PACL NewAcl,
    OUT PBOOLEAN ObjectAceInherited
    );

NTSTATUS
RtlpInheritAcl2 (
    IN PACL DirectoryAcl,
    IN PACL ChildAcl,
    IN ULONG ChildGenericControl,
    IN BOOLEAN IsDirectoryObject,
    IN BOOLEAN AutoInherit,
    IN BOOLEAN DefaultDescriptorForObject,
    IN PSID OwnerSid,
    IN PSID GroupSid,
    IN PSID ServerOwnerSid OPTIONAL,
    IN PSID ServerGroupSid OPTIONAL,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN GUID **pNewObjectType OPTIONAL,
    IN ULONG GuidCount,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PBOOLEAN NewAclExplicitlyAssigned,
    OUT PULONG NewGenericControl
    );

NTSTATUS
RtlpComputeMergedAcl (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    OUT PACL *NewAcl,
    OUT PULONG NewGenericControl
    );

NTSTATUS
RtlpComputeMergedAcl2 (
    IN PACL CurrentAcl,
    IN ULONG CurrentGenericControl,
    IN PACL ModificationAcl,
    IN ULONG ModificationGenericControl,
    IN PSID ClientOwnerSid,
    IN PSID ClientGroupSid,
    IN PGENERIC_MAPPING GenericMapping,
    IN BOOLEAN IsSacl,
    IN PULONG AclBufferSize,
    IN OUT PUCHAR AclBuffer,
    OUT PULONG NewGenericControl
    );

BOOLEAN
RtlpCompareAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid,
    IN PSID GroupSid
    );

BOOLEAN
RtlpCompareKnownObjectAces(
    IN PKNOWN_OBJECT_ACE InheritedAce,
    IN PKNOWN_OBJECT_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    );

BOOLEAN
RtlpCompareKnownAces(
    IN PKNOWN_ACE InheritedAce,
    IN PKNOWN_ACE ChildAce,
    IN PSID OwnerSid OPTIONAL,
    IN PSID GroupSid OPTIONAL
    );

BOOLEAN
RtlpIsDuplicateAce(
    IN PACL Acl,
    IN PKNOWN_ACE NewAce
    );

BOOLEAN
RtlpGuidPresentInGuidList(
    IN GUID *InheritedObjectType,
    IN GUID **pNewObjectType,
    IN ULONG GuidCount
    );

NTSTATUS
RtlpCreateServerAcl(
    IN PACL Acl,
    IN BOOLEAN AclUntrusted,
    IN PSID ServerSid,
    OUT PACL *ServerAcl,
    OUT BOOLEAN *ServerAclAllocated
    );

NTSTATUS
RtlpGetDefaultsSubjectContext(
    HANDLE ClientToken,
    OUT PTOKEN_OWNER *OwnerInfo,
    OUT PTOKEN_PRIMARY_GROUP *GroupInfo,
    OUT PTOKEN_DEFAULT_DACL *DefaultDaclInfo,
    OUT PTOKEN_OWNER *ServerOwner,
    OUT PTOKEN_PRIMARY_GROUP *ServerGroup
    );

BOOLEAN RtlpValidateSDOffsetAndSize (
    IN ULONG   Offset,
    IN ULONG   Length,
    IN ULONG   MinLength,
    OUT PULONG MaxLength
    );

BOOLEAN
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlRunEncodeUnicodeString)
#pragma alloc_text(PAGE,RtlRunDecodeUnicodeString)
#pragma alloc_text(PAGE,RtlEraseUnicodeString)
#pragma alloc_text(PAGE,RtlAdjustPrivilege)
#pragma alloc_text(PAGE,RtlValidSid)
#pragma alloc_text(PAGE,RtlEqualSid)
#pragma alloc_text(PAGE,RtlEqualPrefixSid)
#pragma alloc_text(PAGE,RtlLengthRequiredSid)
#pragma alloc_text(PAGE,RtlInitializeSid)
#pragma alloc_text(PAGE,RtlIdentifierAuthoritySid)
#pragma alloc_text(PAGE,RtlSubAuthoritySid)
#pragma alloc_text(PAGE,RtlSubAuthorityCountSid)
#pragma alloc_text(PAGE,RtlLengthSid)
#pragma alloc_text(PAGE,RtlCopySid)
#pragma alloc_text(PAGE,RtlCopySidAndAttributesArray)
#pragma alloc_text(PAGE,RtlLengthSidAsUnicodeString)
#pragma alloc_text(PAGE,RtlConvertSidToUnicodeString)
#pragma alloc_text(PAGE,RtlEqualLuid)
#pragma alloc_text(PAGE,RtlCopyLuid)
#pragma alloc_text(PAGE,RtlCopyLuidAndAttributesArray)
#pragma alloc_text(PAGE,RtlCreateSecurityDescriptor)
#pragma alloc_text(PAGE,RtlCreateSecurityDescriptorRelative)
#pragma alloc_text(PAGE,RtlValidSecurityDescriptor)
#pragma alloc_text(PAGE,RtlLengthSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetAttributesSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetControlSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetControlSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetDaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetDaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetSaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetSaclSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetOwnerSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetOwnerSecurityDescriptor)
#pragma alloc_text(PAGE,RtlSetGroupSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetGroupSecurityDescriptor)
#pragma alloc_text(PAGE,RtlAreAllAccessesGranted)
#pragma alloc_text(PAGE,RtlAreAnyAccessesGranted)
#pragma alloc_text(PAGE,RtlMapGenericMask)
#pragma alloc_text(PAGE,RtlImpersonateSelf)
#pragma alloc_text(PAGE,RtlpApplyAclToObject)
#pragma alloc_text(PAGE,RtlpCopyEffectiveAce)
#pragma alloc_text(PAGE,RtlpCopyAces)
#pragma alloc_text(PAGE,RtlpGuidPresentInGuidList)
#pragma alloc_text(PAGE,RtlpInheritAcl2)
#pragma alloc_text(PAGE,RtlpInheritAcl)
#pragma alloc_text(PAGE,RtlpGenerateInheritedAce)
#pragma alloc_text(PAGE,RtlpGenerateInheritAcl)
#pragma alloc_text(PAGE,RtlpComputeMergedAcl2)
#pragma alloc_text(PAGE,RtlpComputeMergedAcl)
#pragma alloc_text(PAGE,RtlpConvertToAutoInheritSecurityObject)
#pragma alloc_text(PAGE,RtlpCompareAces)
#pragma alloc_text(PAGE,RtlpCompareKnownAces)
#pragma alloc_text(PAGE,RtlpCompareKnownObjectAces)
#pragma alloc_text(PAGE,RtlpConvertAclToAutoInherit)
#pragma alloc_text(PAGE,RtlpIsDuplicateAce)
#pragma alloc_text(PAGE,RtlpCreateServerAcl)
#pragma alloc_text(PAGE,RtlpNewSecurityObject)
#pragma alloc_text(PAGE,RtlpSetSecurityObject)
#pragma alloc_text(PAGE,RtlpValidateSDOffsetAndSize)
#pragma alloc_text(PAGE,RtlValidRelativeSecurityDescriptor)
#pragma alloc_text(PAGE,RtlGetSecurityDescriptorRMControl)
#pragma alloc_text(PAGE,RtlSetSecurityDescriptorRMControl)
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//    Local Macros and Symbols                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define CREATOR_SID_SIZE 12

#define max(a,b)            (((a) > (b)) ? (a) : (b))

//
// Define an array mapping all ACE types to their base type.
//
// For instance, all allowed ACE types are similar.  As are all denied ACE types.
//

#if defined(ALLOC_DATA_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma const_seg("PAGECONST")
#endif

const UCHAR RtlBaseAceType[] = {
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_ACE_TYPE (0x0)
    ACCESS_DENIED_ACE_TYPE,     // ACCESS_DENIED_ACE_TYPE (0x1)
    SYSTEM_AUDIT_ACE_TYPE,      // SYSTEM_AUDIT_ACE_TYPE (0x2)
    SYSTEM_ALARM_ACE_TYPE,      // SYSTEM_ALARM_ACE_TYPE (0x3)
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
    ACCESS_ALLOWED_ACE_TYPE,    // ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
    ACCESS_DENIED_ACE_TYPE,     // ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
    SYSTEM_AUDIT_ACE_TYPE,      // SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
    SYSTEM_ALARM_ACE_TYPE       // SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
};

//
// Define an array defining whether an ACE is a system ACE
//

const UCHAR RtlIsSystemAceType[] = {
    FALSE,    // ACCESS_ALLOWED_ACE_TYPE (0x0)
    FALSE,    // ACCESS_DENIED_ACE_TYPE (0x1)
    TRUE,     // SYSTEM_AUDIT_ACE_TYPE (0x2)
    TRUE,     // SYSTEM_ALARM_ACE_TYPE (0x3)
    FALSE,    // ACCESS_ALLOWED_COMPOUND_ACE_TYPE (0x4)
    FALSE,    // ACCESS_ALLOWED_OBJECT_ACE_TYPE (0x5)
    FALSE,    // ACCESS_DENIED_OBJECT_ACE_TYPE (0x6)
    TRUE,     // SYSTEM_AUDIT_OBJECT_ACE_TYPE (0x7)
    TRUE      // SYSTEM_ALARM_OBJECT_ACE_TYPE (0x8)
};

#if DBG
BOOLEAN RtlpVerboseConvert = FALSE;
#endif // DBG

#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                   