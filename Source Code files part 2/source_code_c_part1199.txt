iskDesc && GetParentLogicalDiskDescription(diskDesc->LogicalDiskId)) {
        DeleteAncestors(diskInfo, partitionDiskId);
        diskDesc = NULL;
    }

    if (diskDesc) {
        if (diskDesc->DiskDescriptionSize != newDesc->DiskDescriptionSize ||
            diskDesc->LogicalDiskType != newDesc->LogicalDiskType ||
            diskDesc->u.Other.ThisMemberNumber !=
                    newDesc->u.Other.ThisMemberNumber ||
            diskDesc->u.Other.NumberOfMembers !=
                    newDesc->u.Other.NumberOfMembers ||
            diskDesc->u.Other.ByteOffsetToConfigurationInformation !=
                    newDesc->u.Other.ByteOffsetToConfigurationInformation ||
            diskDesc->u.Other.ByteOffsetToStateInformation !=
                    newDesc->u.Other.ByteOffsetToStateInformation) {

            DeleteAncestors(diskInfo, partitionDiskId);
            diskDesc = NULL;
        } else {
            diskDesc->DriveLetter = newDesc->DriveLetter;
        }
    }

    if (diskDesc && diskDesc->u.Other.ByteOffsetToConfigurationInformation) {
        if (diskDesc->u.Other.ByteOffsetToStateInformation) {
            length = diskDesc->u.Other.ByteOffsetToStateInformation -
                     diskDesc->u.Other.ByteOffsetToConfigurationInformation;
        } else {
            length = diskDesc->DiskDescriptionSize -
                     diskDesc->u.Other.ByteOffsetToConfigurationInformation;
        }

        config = (PCHAR) diskDesc +
                 diskDesc->u.Other.ByteOffsetToConfigurationInformation;
        newConfig = (PCHAR) newDesc +
                    newDesc->u.Other.ByteOffsetToConfigurationInformation;

        if (RtlCompareMemory(config, newConfig, length) != length) {
            DeleteAncestors(diskInfo, partitionDiskId);
            diskDesc = NULL;
        }
    }

    if (diskDesc && diskDesc->u.Other.ByteOffsetToStateInformation) {
        length = diskDesc->DiskDescriptionSize -
                 diskDesc->u.Other.ByteOffsetToStateInformation;
        state = (PCHAR) diskDesc +
                diskDesc->u.Other.ByteOffsetToStateInformation;
        newState = (PCHAR) newDesc +
                   newDesc->u.Other.ByteOffsetToStateInformation;

        RtlCopyMemory(state, newState, length);
    }

    if (!GetDiskDescription(registry, diskPartition, diskDesc, &otherDesc)) {
        otherDesc = NULL;
    }

    if (diskDesc) {
        diskDesc->DriveLetter = newDesc->DriveLetter;
    } else {
        diskDesc = diskInfo->AddLogicalDiskDescription(newDesc);
    }

    if (otherDesc &&
        !QueryMemberLogicalDiskId(otherDesc->LogicalDiskId,
                                  diskPartition->FtMember)) {

        diskDesc->LogicalDiskId = otherDesc->LogicalDiskId;
    }

    if (IsLogicalDiskComplete(diskDesc->LogicalDiskId)) {
        DeleteFtRegistryInformation(registry, diskPartition);
    }

    RecomputeArrayOfRootLogicalDiskIds();

    diskInfo->Write();
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, DISK_REGISTRY_KEY_W,
                          L"Information", REG_BINARY, registry,
                          registrySize);

    ExFreePool(newDesc);
    ExFreePool(registry);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_INFORMATION_SET::~FT_LOGICAL_DISK_INFORMATION_SET(
    )

{
    ULONG   i;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        delete _arrayOfLogicalDiskInformations[i];
    }
    if (_arrayOfLogicalDiskInformations) {
        ExFreePool(_arrayOfLogicalDiskInformations);
    }

    if (_arrayOfRootLogicalDiskIds) {
        ExFreePool(_arrayOfRootLogicalDiskIds);
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::ReallocRootLogicalDiskIds(
    IN  ULONG   NewNumberOfEntries
    )

/*++

Routine Description;

    This routine reallocs the root logical disk ids buffer to contain
    the given number of entries.  It does not change the number of
    disk ids private member, it just enlarges the buffer.

Arguments:

    NewNumberOfEntries  - Supplies the new size of the buffer.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

--*/

{
    PFT_LOGICAL_DISK_ID newLogicalDiskIdArray;

    if (NewNumberOfEntries <= _numberOfRootLogicalDisksIds) {
        return TRUE;
    }

    newLogicalDiskIdArray = (PFT_LOGICAL_DISK_ID)
                            ExAllocatePool(NonPagedPool, NewNumberOfEntries*
                                           sizeof(FT_LOGICAL_DISK_ID));
    if (!newLogicalDiskIdArray) {
        return FALSE;
    }

    if (_arrayOfRootLogicalDiskIds) {
        RtlMoveMemory(newLogicalDiskIdArray, _arrayOfRootLogicalDiskIds,
                      _numberOfRootLogicalDisksIds*sizeof(FT_LOGICAL_DISK_ID));
        ExFreePool(_arrayOfRootLogicalDiskIds);
    }

    _arrayOfRootLogicalDiskIds = newLogicalDiskIdArray;

    return TRUE;
}

VOID
FT_LOGICAL_DISK_INFORMATION_SET::RecomputeArrayOfRootLogicalDiskIds(
    )

/*++

Routine Description:

    This routine computes the array of root logical disk ids.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG                           i, j;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p, q;

    _numberOfRootLogicalDisksIds = 0;
    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {

        diskInfo = _arrayOfLogicalDiskInformations[i];

        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            for (q = diskInfo->GetFirstLogicalDiskDescription(); q;
                 q = diskInfo->GetNextLogicalDiskDescription(q)) {

                if (q->LogicalDiskType != FtPartition &&
                    q->u.Other.ThisMemberLogicalDiskId == p->LogicalDiskId) {

                    break;
                }
            }

            if (!q) {
                for (j = 0; j < _numberOfRootLogicalDisksIds; j++) {
                    if (_arrayOfRootLogicalDiskIds[j] == p->LogicalDiskId) {
                        break;
                    }
                }

                if (j == _numberOfRootLogicalDisksIds) {
                    _arrayOfRootLogicalDiskIds[j] = p->LogicalDiskId;
                    _numberOfRootLogicalDisksIds++;
                }
            }
        }
    }
}

BOOLEAN
FT_LOGICAL_DISK_INFORMATION_SET::ComputeNewParentLogicalDiskIds(
    IN  FT_LOGICAL_DISK_ID      LogicalDiskId,
    OUT PULONG                  NumLogicalDiskIds,
    OUT PFT_LOGICAL_DISK_ID*    OldLogicalDiskIds,
    OUT PFT_LOGICAL_DISK_ID*    NewLogicalDiskIds
    )

/*++

Routine Description:

    This routine finds all of the parents of the given logical disk id and
    computes replacement logical disk ids for them.

Arguments:

    LogicalDiskId       - Supplies the logical disk id.

    NumLogicalDiskIds   - Returns the number of parents.

    OldLogicalDiskIds   - Returns the existing geneology for the given
                            logical disk id.

    NewLogicalDiskIds   - Returns the new geneology for the given
                            logical disk id.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    p;
    ULONG                           n, i;

    n = 1;
    for (p = GetParentLogicalDiskDescription(LogicalDiskId); p;
         p = GetParentLogicalDiskDescription(p->LogicalDiskId)) {

        n++;
    }

    *NumLogicalDiskIds = n;
    *OldLogicalDiskIds = (PFT_LOGICAL_DISK_ID)
                         ExAllocatePool(PagedPool,
                                        n*sizeof(FT_LOGICAL_DISK_ID));
    if (!*OldLogicalDiskIds) {
        return FALSE;
    }

    *NewLogicalDiskIds = (PFT_LOGICAL_DISK_ID)
                         ExAllocatePool(PagedPool,
                                        n*sizeof(FT_LOGICAL_DISK_ID));
    if (!*NewLogicalDiskIds) {
        ExFreePool(*OldLogicalDiskIds);
        return FALSE;
    }

    (*OldLogicalDiskIds)[0] = LogicalDiskId;
    (*NewLogicalDiskIds)[0] = GenerateNewLogicalDiskId();

    i = 1;
    for (p = GetParentLogicalDiskDescription(LogicalDiskId); p;
         p = GetParentLogicalDiskDescription(p->LogicalDiskId)) {

        (*OldLogicalDiskIds)[i] = p->LogicalDiskId;
        (*NewLogicalDiskIds)[i] = GenerateNewLogicalDiskId();
        i++;
    }

    ASSERT(i == n);

    return TRUE;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION::GetNextLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    CurrentDiskDescription
    )

/*++

Routine Description:

    This routine returns the next logical disk description for a
    given logical disk description.

Arguments:

    CurrentDiskDescription  - Supplies the current disk description.

Return Value:

    The next disk description or NULL if no more disk descriptions
    are present.

--*/

{
    PFT_LOGICAL_DISK_DESCRIPTION    next;

    next = (PFT_LOGICAL_DISK_DESCRIPTION)
           ((PCHAR) CurrentDiskDescription +
            CurrentDiskDescription->DiskDescriptionSize);

    if ((ULONG) ((PCHAR) next - (PCHAR) _diskBuffer) >
        _length - sizeof(USHORT)) {

        return NULL;
    }

    if ((ULONG) ((PCHAR) next - (PCHAR) _diskBuffer +
                 next->DiskDescriptionSize) > _length) {

        return NULL;
    }

    if (next->DiskDescriptionSize < sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {
        return NULL;
    }

    return next;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION_SET::GetParentLogicalDiskDescription(
    IN  PFT_LOGICAL_DISK_DESCRIPTION    LogicalDiskDescription,
    IN  ULONG                           DiskInformationNumber
    )

/*++

Routine Description:

    This routine gets the parent logical disk description.

Arguments:

    LogicalDiskDescription  - Supplies the child logical disk description.

    DiskInformationNumber   - Supplies the disk information number.

Return Value:

    The parent logical disk description or NULL.

--*/

{
    FT_LOGICAL_DISK_ID              diskId;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    diskId = LogicalDiskDescription->LogicalDiskId;
    diskInfo = _arrayOfLogicalDiskInformations[DiskInformationNumber];
    for (p = diskInfo->GetNextLogicalDiskDescription(LogicalDiskDescription);
         p; p = diskInfo->GetNextLogicalDiskDescription(p)) {

        if (p->LogicalDiskType != FtPartition &&
            p->u.Other.ThisMemberLogicalDiskId == diskId) {

            return p;
        }
    }

    return NULL;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION_SET::GetParentLogicalDiskDescription(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId,
    OUT PULONG              DiskInformationNumber
    )

/*++

Routine Description:

    This routine gets the parent logical disk description for the
    given logical disk id.

Arguments:

    LogicalDiskId           - Supplies the logical disk id.

    DiskInformationNumber   - Returns the disk information number.

Return Value:

    The parent logical disk description or NULL.

--*/

{
    ULONG                           i;
    PFT_LOGICAL_DISK_INFORMATION    diskInfo;
    PFT_LOGICAL_DISK_DESCRIPTION    p;

    for (i = 0; i < _numberOfLogicalDiskInformations; i++) {
        diskInfo = _arrayOfLogicalDiskInformations[i];
        for (p = diskInfo->GetFirstLogicalDiskDescription(); p;
             p = diskInfo->GetNextLogicalDiskDescription(p)) {

            if (p->LogicalDiskType != FtPartition &&
                p->u.Other.ThisMemberLogicalDiskId == LogicalDiskId) {

                if (DiskInformationNumber) {
                    *DiskInformationNumber = i;
                }
                return p;
            }
        }
    }

    return NULL;
}

PFT_LOGICAL_DISK_DESCRIPTION
FT_LOGICAL_DISK_INFORMATION::GetFirstLogicalDiskDescription(
    )

/*++

Routine Description:

    This routine returns the first logical disk description in the
    list.

Arguments:

    None.

Return Value:

    A pointer inside the buffer for the first logical disk description or
    NULL if there are no logical disk descriptions.

--*/

{
    PFT_ON_DISK_PREAMBLE            preamble;
    PFT_LOGICAL_DISK_DESCRIPTION    diskDescription;

    if (!_length) {
        return NULL;
    }

    preamble = (PFT_ON_DISK_PREAMBLE) _diskBuffer;
    if (preamble->FtOnDiskSignature != FT_ON_DISK_SIGNATURE ||
        preamble->DiskDescriptionVersionNumber != FT_ON_DISK_DESCRIPTION_VERSION_NUMBER ||
        preamble->ByteOffsetToFirstFtLogicalDiskDescription <
        sizeof(FT_ON_DISK_PREAMBLE) ||
        preamble->ByteOffsetToFirstFtLogicalDiskDescription >
        _length - sizeof(ULONG)) {

        return NULL;
    }

    diskDescription = (PFT_LOGICAL_DISK_DESCRIPTION)
                      ((PCHAR) preamble +
                       preamble->ByteOffsetToFirstFtLogicalDiskDescription);

    if (diskDescription->DiskDescriptionSize <
        sizeof(FT_LOGICAL_DISK_DESCRIPTION)) {

        return NULL;
    }

    if ((ULONG) ((PCHAR) diskDescription - (PCHAR) _diskBuffer +
                 diskDescription->DiskDescriptionSize) > _length) {

        return NULL;
    }

    return diskDescription;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\packet.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    packet.cxx

Abstract:

    This module contains the code specific to all types of TRANSFER_PACKETS
    objects.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

static PNPAGED_LOOKASIDE_LIST   StripeLookasidePackets = NULL;
static PNPAGED_LOOKASIDE_LIST   MirrorLookasidePackets = NULL;


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

PVOID
TRANSFER_PACKET::operator new(
    IN  size_t    Size
    )

/*++

Routine Description:

    This routine is the memory allocator for all classes derived from
    FT_VOLUME.

Arguments:

    Size    - Supplies the number of bytes to allocate.

Return Value:

    A pointer to Size bytes of non-paged pool.

--*/

{
    PTRANSFER_PACKET    p;

    if (Size <= sizeof(STRIPE_TP)) {
        if (!StripeLookasidePackets) {
            StripeLookasidePackets = (PNPAGED_LOOKASIDE_LIST)
                    ExAllocatePool(NonPagedPool,
                                   sizeof(NPAGED_LOOKASIDE_LIST));
            if (!StripeLookasidePackets) {
                return NULL;
            }

            ExInitializeNPagedLookasideList(StripeLookasidePackets, NULL, NULL,
                                            0, sizeof(STRIPE_TP), 'sFcS', 32);
        }

        p = (PTRANSFER_PACKET)
            ExAllocateFromNPagedLookasideList(StripeLookasidePackets);
        if (p) {
            p->_allocationType = TP_ALLOCATION_STRIPE_POOL;
        }
        return p;
    }

    if (Size <= sizeof(MIRROR_TP)) {
        if (!MirrorLookasidePackets) {
            MirrorLookasidePackets = (PNPAGED_LOOKASIDE_LIST)
                    ExAllocatePool(NonPagedPool,
                                   sizeof(NPAGED_LOOKASIDE_LIST));
            if (!MirrorLookasidePackets) {
                return NULL;
            }

            ExInitializeNPagedLookasideList(MirrorLookasidePackets, NULL, NULL,
                                            0, sizeof(MIRROR_TP), 'mFcS', 32);
        }

        p = (PTRANSFER_PACKET)
            ExAllocateFromNPagedLookasideList(MirrorLookasidePackets);
        if (p) {
            p->_allocationType = TP_ALLOCATION_MIRROR_POOL;
        }
        return p;
    }

    p = (PTRANSFER_PACKET) ExAllocatePool(NonPagedPool, Size);
    if (p) {
        p->_allocationType = 0;
    }
    return p;
}

VOID
TRANSFER_PACKET::operator delete(
    IN  PVOID   MemPtr
    )

/*++

Routine Description:

    This routine frees memory allocated for all classes derived from
    FT_VOLUME.

Arguments:

    MemPtr  - Supplies a pointer to the memory to free.

Return Value:

    None.

--*/

{
    PTRANSFER_PACKET    p = (PTRANSFER_PACKET) MemPtr;

    if (!p) {
        return;
    }

    if (p->_allocationType == TP_ALLOCATION_STRIPE_POOL) {
        ExFreeToNPagedLookasideList(StripeLookasidePackets, MemPtr);
    } else if (p->_allocationType == TP_ALLOCATION_MIRROR_POOL) {
        ExFreeToNPagedLookasideList(MirrorLookasidePackets, MemPtr);
    } else {
        ExFreePool(MemPtr);
    }
}

TRANSFER_PACKET::~TRANSFER_PACKET(
    )

/*++

Routine Description:

    This is the destructor for a transfer packet.  It frees up any allocated
    MDL and buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    FreeMdl();
}

BOOLEAN
TRANSFER_PACKET::AllocateMdl(
    IN  PVOID   Buffer,
    IN  ULONG   Length
    )

/*++

Routine Description:

    This routine allocates an MDL and for this transfer packet.

Arguments:

    Buffer  - Supplies the buffer.

    Length  - Supplies the buffer length.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    FreeMdl();

    Mdl = IoAllocateMdl(Buffer, Length, FALSE, FALSE, NULL);
    if (!Mdl) {
        return FALSE;
    }
    _freeMdl = TRUE;

    return TRUE;
}

BOOLEAN
TRANSFER_PACKET::AllocateMdl(
    IN  ULONG   Length
    )

/*++

Routine Description:

    This routine allocates an MDL and buffer for this transfer packet.

Arguments:

    Length  - Supplies the buffer length.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    PVOID   buffer;

    FreeMdl();

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        return FALSE;
    }
    _freeBuffer = TRUE;

    Mdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!Mdl) {
        ExFreePool(buffer);
        _freeBuffer = FALSE;
        return FALSE;
    }
    _freeMdl = TRUE;
    MmBuildMdlForNonPagedPool(Mdl);

    return TRUE;
}

VOID
TRANSFER_PACKET::FreeMdl(
    )

/*++

Routine Description:

    It frees up any allocated MDL and buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_freeBuffer) {
        ExFreePool(MmGetMdlVirtualAddress(Mdl));
        _freeBuffer = FALSE;
    }
    if (_freeMdl) {
        IoFreeMdl(Mdl);
        _freeMdl = FALSE;
    }
}

OVERLAP_TP::~OVERLAP_TP(
    )

{
    if (InQueue) {
        OverlappedIoManager->ReleaseIoRegion(this);
    }
}

MIRROR_RECOVER_TP::~MIRROR_RECOVER_TP(
    )

{
    FreeMdls();
}

BOOLEAN
MIRROR_RECOVER_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    PartialMdl = IoAllocateMdl((PVOID) (PAGE_SIZE - 1), Length,
                               FALSE, FALSE, NULL);

    if (!PartialMdl) {
        FreeMdls();
        return FALSE;
    }

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    VerifyMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!VerifyMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(VerifyMdl);

    return TRUE;
}

VOID
MIRROR_RECOVER_TP::FreeMdls(
    )

{
    if (PartialMdl)  {
        IoFreeMdl(PartialMdl);
        PartialMdl = NULL;
    }
    if (VerifyMdl) {
        ExFreePool(MmGetMdlVirtualAddress(VerifyMdl));
        IoFreeMdl(VerifyMdl);
        VerifyMdl = NULL;
    }
}

SWP_RECOVER_TP::~SWP_RECOVER_TP(
    )

{
    FreeMdls();
}

BOOLEAN
SWP_RECOVER_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    PartialMdl = IoAllocateMdl((PVOID) (PAGE_SIZE - 1), Length,
                               FALSE, FALSE, NULL);

    if (!PartialMdl) {
        FreeMdls();
        return FALSE;
    }

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    VerifyMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!VerifyMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(VerifyMdl);

    return TRUE;
}

VOID
SWP_RECOVER_TP::FreeMdls(
    )

{
    if (PartialMdl)  {
        IoFreeMdl(PartialMdl);
        PartialMdl = NULL;
    }
    if (VerifyMdl) {
        ExFreePool(MmGetMdlVirtualAddress(VerifyMdl));
        IoFreeMdl(VerifyMdl);
        VerifyMdl = NULL;
    }
}

SWP_WRITE_TP::~SWP_WRITE_TP(
    )

{
    FreeMdls();
}

BOOLEAN
SWP_WRITE_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        return FALSE;
    }

    ReadAndParityMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!ReadAndParityMdl) {
        ExFreePool(buffer);
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(ReadAndParityMdl);

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    WriteMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!WriteMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(WriteMdl);

    return TRUE;
}

VOID
SWP_WRITE_TP::FreeMdls(
    )

{
    if (ReadAndParityMdl)  {
        ExFreePool(MmGetMdlVirtualAddress(ReadAndParityMdl));
        IoFreeMdl(ReadAndParityMdl);
        ReadAndParityMdl = NULL;
    }
    if (WriteMdl) {
        ExFreePool(MmGetMdlVirtualAddress(WriteMdl));
        IoFreeMdl(WriteMdl);
        WriteMdl = NULL;
    }
}

REDISTRIBUTION_CW_TP::~REDISTRIBUTION_CW_TP(
    )

{
    FreeMdls();
}

BOOLEAN
REDISTRIBUTION_CW_TP::AllocateMdls(
    IN  ULONG   Length
    )

{
    PVOID   buffer;

    FreeMdls();

    PartialMdl = IoAllocateMdl((PVOID) (PAGE_SIZE - 1), Length,
                               FALSE, FALSE, NULL);

    if (!PartialMdl) {
        FreeMdls();
        return FALSE;
    }

    buffer = ExAllocatePool(NonPagedPoolCacheAligned,
                            Length < PAGE_SIZE ? PAGE_SIZE : Length);
    if (!buffer) {
        FreeMdls();
        return FALSE;
    }

    VerifyMdl = IoAllocateMdl(buffer, Length, FALSE, FALSE, NULL);
    if (!VerifyMdl) {
        ExFreePool(buffer);
        FreeMdls();
        return FALSE;
    }
    MmBuildMdlForNonPagedPool(VerifyMdl);

    return TRUE;
}

VOID
REDISTRIBUTION_CW_TP::FreeMdls(
    )

{
    if (PartialMdl)  {
        IoFreeMdl(PartialMdl);
        PartialMdl = NULL;
    }
    if (VerifyMdl) {
        ExFreePool(MmGetMdlVirtualAddress(VerifyMdl));
        IoFreeMdl(VerifyMdl);
        VerifyMdl = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\ftwmireg.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    ftwmireg.cxx

Abstract:

    This file contains routines to register for and response to WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
    #include <mountmgr.h>
}

#include <ftdisk.h>

extern "C" {

#define INITGUID

#include "wmistr.h"
#include "wmiguid.h"
#include "ntdddisk.h"

NTSTATUS FtRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FtQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
FtQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
FtQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

WMIGUIDREGINFO DiskperfGuidList[] =
{
    { &DiskPerfGuid,
      1,
      0
    }
};

ULONG DiskperfGuidCount = (sizeof(DiskperfGuidList) / sizeof(WMIGUIDREGINFO));
}


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif



NTSTATUS
FtRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Routine to initialize a proper name for the device object, and
    register it with WMI

Arguments:

    DeviceObject - pointer to a device object to be initialized.

Return Value:

    Status of the initialization. NOTE: If the registration fails,
    the device name in the DeviceExtension will be left as empty.

--*/

{
    NTSTATUS                status;
    PVOLUME_EXTENSION       deviceExtension;
    KEVENT                  event;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;

    PAGED_CODE();

    deviceExtension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    status = IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);

    if (NT_SUCCESS(status) && (deviceExtension->Root->PmWmiCounterLibContext.PmWmiCounterEnable != NULL)) {
        deviceExtension->Root->PmWmiCounterLibContext.PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext);
        deviceExtension->Root->PmWmiCounterLibContext.PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,FALSE,FALSE);
    }

    return status;
}



NTSTATUS
FtQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
        The MOF file is assumed to be already included in wmicore.mof

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    NTSTATUS status;
    PVOLUME_EXTENSION  deviceExtension;

    deviceExtension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    PAGED_CODE();

    InstanceName->Buffer = (PWSTR) NULL;
    *RegistryPath = &deviceExtension->Root->DiskPerfRegistryPath;
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EXPENSIVE;
    *Pdo = DeviceObject;
    status = STATUS_SUCCESS;

    return(status);
}



NTSTATUS
FtQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PVOLUME_EXTENSION deviceExtension;
    ULONG sizeNeeded = 0;
    KIRQL        currentIrql;
    WCHAR stringBuffer[40];
    USHORT stringSize;
    PWCHAR diskNamePtr;

    PAGED_CODE();

    deviceExtension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        if (!(deviceExtension->CountersEnabled)) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            swprintf(stringBuffer, L"\\Device\\HarddiskVolume%d", 
                     deviceExtension->VolumeNumber);
            stringSize = (USHORT) (wcslen(stringBuffer) * sizeof(WCHAR));
        
            sizeNeeded = ((sizeof(DISK_PERFORMANCE) + 1) & ~1) 
                         + stringSize + sizeof(UNICODE_NULL);
            if (BufferAvail >= sizeNeeded) {
                deviceExtension->Root->PmWmiCounterLibContext.
                  PmWmiCounterQuery(deviceExtension->PmWmiCounterContext, 
                                    (PDISK_PERFORMANCE) Buffer, 
                                    L"FTDISK  ", 
                                    deviceExtension->VolumeNumber);
                diskNamePtr = (PWCHAR)(Buffer +
                              ((sizeof(DISK_PERFORMANCE) + 1) & ~1));
                *diskNamePtr++ = stringSize;
                RtlCopyMemory(diskNamePtr,
                              stringBuffer,
                              stringSize);
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, sizeNeeded,
                                 IO_NO_INCREMENT);
    return status;
}


BOOLEAN
FtQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS status;
    UNICODE_STRING uString;
    OBJECT_ATTRIBUTES objAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;
    ULONG Buffer[4];        // sizeof keyValue + ULONG
    ULONG enableAlways = 0;
    PVOLUME_EXTENSION extension = (PVOLUME_EXTENSION) DeviceObject->DeviceExtension;
    HANDLE keyHandle;
    ULONG returnLength;

    PAGED_CODE();

    RtlInitUnicodeString(&uString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Partmgr");
    InitializeObjectAttributes(
        &objAttributes,
        &uString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&keyHandle, KEY_READ, &objAttributes);
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&uString, L"EnableCounterForIoctl");
        status = ZwQueryValueKey(keyHandle, &uString,
                    KeyValuePartialInformation,
                    Buffer,
                    sizeof(Buffer),
                    &returnLength);
        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION) &Buffer[0];
        if (NT_SUCCESS(status) && (keyValue->DataLength == sizeof(ULONG))) {
            enableAlways = *((PULONG) keyValue->Data);
        }
        ZwClose(keyHandle);
    }

    if (enableAlways == 1) {
        if (InterlockedCompareExchange(&extension->EnableAlways, 1, 0) == 0) {
            status = extension->Root->PmWmiCounterLibContext.
                        PmWmiCounterEnable(&extension->PmWmiCounterContext);
            if (NT_SUCCESS(status)) {
                extension->CountersEnabled = TRUE;
                return TRUE;
            }
            else {
                InterlockedExchange(&extension->EnableAlways, 0);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\parity.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    parity.cxx

Abstract:

    This module contains code specific to the parity io manager.

    The purpose of this module is to help serialize parity updates that
    overlaps with each other.  This class is used by stripes with parity.

Author:

    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
PARITY_IO_MANAGER::Initialize(
    IN  ULONG   BucketSize,
    IN  ULONG   SectorSize
    )

/*++

Routine Description:

    This routine initializes a parity io manager.

Arguments:

    BucketSize  - Supplies the bucket size.  Any I/O to this class may
                    not span more than one bucket.  In the case of stripes
                    with parity, the bucket size is the stripe size.

    SectorSize  - Supplies the sector size.

Return Value:

    NTSTATUS

--*/

{
    ULONG   i;

    _numQueues = 256;
    _bucketSize = BucketSize;
    _sectorSize = SectorSize;
    _spinLock = (PKSPIN_LOCK)
                ExAllocatePool(NonPagedPool, _numQueues*sizeof(KSPIN_LOCK));
    if (!_spinLock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ioQueue = (PLIST_ENTRY)
               ExAllocatePool(NonPagedPool, _numQueues*sizeof(LIST_ENTRY));
    if (!_ioQueue) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < _numQueues; i++) {
        KeInitializeSpinLock(&_spinLock[i]);
        InitializeListHead(&_ioQueue[i]);
    }

    _ePacket = new PARITY_TP;
    if (_ePacket && !_ePacket->AllocateMdl(_bucketSize)) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (!_ePacket) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
        ExFreePool(_ioQueue);
        _ioQueue = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _ePacketInUse = FALSE;
    _ePacketQueueBeingServiced = FALSE;
    InitializeListHead(&_ePacketQueue);
    KeInitializeSpinLock(&_ePacketSpinLock);

    return STATUS_SUCCESS;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

VOID
UpdateParityCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion routine for the read request associated
    with an (or many) update parity request.  This routine gets the
    update parity requests in the queue that follow it and smash them into
    its buffer and then write the parity block out to disk.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_TP          transferPacket = (PPARITY_TP) TransferPacket;
    PPARITY_IO_MANAGER  t = transferPacket->ParityIoManager;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    ULONG               queueNumber;
    PLIST_ENTRY         q, qq;
    PKSPIN_LOCK         spin;
    KIRQL               irql, irql2;
    PLIST_ENTRY         l;
    PPARITY_TP          p, packet, ep;
    PCHAR               target;
    ULONG               bucketOffset;
    PVOID               source;
    BOOLEAN             tpRemoved;
    BOOLEAN             wasIdle, wasReadPacket;

    if (!transferPacket->ReadPacket) {

        if (!NT_SUCCESS(status) && !transferPacket->OneWriteFailed &&
            !FsRtlIsTotalDeviceFailure(status)) {

            transferPacket->OneWriteFailed = TRUE;
            t->CarefulWrite(transferPacket);
            return;
        }

        q = &transferPacket->UpdateQueue;
        while (!IsListEmpty(q)) {
            l = RemoveHeadList(q);
            p = CONTAINING_RECORD(l, PARITY_TP, UpdateQueue);

            p->IoStatus.Status = status;
            if (NT_SUCCESS(status)) {
                p->IoStatus.Information = p->Length;
            } else {
                p->IoStatus.Information = 0;
                p->ReadPacket = FALSE;  // Indicate a write failure.
            }

            p->CompletionRoutine(p);
        }
    }

    wasReadPacket = transferPacket->ReadPacket;
    transferPacket->ReadPacket = FALSE;

    queueNumber = (ULONG) (transferPacket->BucketNumber%t->_numQueues);
    q = &t->_ioQueue[queueNumber];
    spin = &t->_spinLock[queueNumber];

    KeAcquireSpinLock(spin, &irql);
    for (l = transferPacket->OverlapQueue.Flink; l != q; l = l->Flink) {

        p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

        if (p->BucketNumber == transferPacket->BucketNumber) {
            RemoveEntryList(&p->OverlapQueue);
            InsertTailList(&transferPacket->UpdateQueue, &p->UpdateQueue);

            if (p->Offset < transferPacket->Offset) {
                transferPacket->Length += (ULONG) (transferPacket->Offset - p->Offset);
                transferPacket->Offset = p->Offset;
                transferPacket->ReadPacket = TRUE;
            }

            if (p->Offset + p->Length >
                transferPacket->Offset + transferPacket->Length) {

                transferPacket->Length += (ULONG)
                        ((p->Offset + p->Length) -
                         (transferPacket->Offset + transferPacket->Length));
                transferPacket->ReadPacket = TRUE;
            }
        }
    }
    if (!NT_SUCCESS(status) || IsListEmpty(&transferPacket->UpdateQueue)) {
        if (wasReadPacket && IsListEmpty(&transferPacket->UpdateQueue)) {
            transferPacket->ReadPacket = TRUE;
            transferPacket->Idle = TRUE;
            KeReleaseSpinLock(spin, irql);
            return;
        }

        RemoveEntryList(&transferPacket->OverlapQueue);
        KeReleaseSpinLock(spin, irql);
        tpRemoved = TRUE;

    } else {
        KeReleaseSpinLock(spin, irql);
        tpRemoved = FALSE;
    }

    if (tpRemoved) {

        q = &transferPacket->UpdateQueue;
        while (!IsListEmpty(q)) {

            l = RemoveHeadList(q);
            p = CONTAINING_RECORD(l, PARITY_TP, UpdateQueue);

            p->IoStatus.Status = status;
            p->IoStatus.Information = 0;
            p->ReadPacket = wasReadPacket; // Indicate whether a read failure.

            p->CompletionRoutine(p);
        }

        if (transferPacket != t->_ePacket) {
            delete transferPacket;
        }

        KeAcquireSpinLock(&t->_ePacketSpinLock, &irql);
        if (t->_ePacketInUse && !t->_ePacketQueueBeingServiced) {
            t->_ePacketQueueBeingServiced = TRUE;
        } else {
            if (transferPacket == t->_ePacket) {
                t->_ePacketInUse = FALSE;
            }
            KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
            return;
        }
        KeReleaseSpinLock(&t->_ePacketSpinLock, irql);

        for (;;) {

            KeAcquireSpinLock(&t->_ePacketSpinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                if (transferPacket == t->_ePacket) {
                    t->_ePacketInUse = FALSE;
                }
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_ePacketSpinLock, irql);

            ep = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

            queueNumber = (ULONG) (ep->BucketNumber%t->_numQueues);
            q = &t->_ioQueue[queueNumber];
            spin = &t->_spinLock[queueNumber];

            KeAcquireSpinLock(spin, &irql);
            for (l = q->Blink; l != q; l = l->Blink) {

                p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

                if (p->BucketNumber == ep->BucketNumber) {
                    break;
                }
            }
            if (l != q) {
                InsertTailList(q, &ep->OverlapQueue);
                wasIdle = p->Idle;
                p->Idle =  FALSE;
                KeReleaseSpinLock(spin, irql);
                if (wasIdle) {
                    p->CompletionRoutine(p);
                }
                continue;
            }

            packet = new PARITY_TP;
            if (packet && !packet->AllocateMdl(t->_bucketSize)) {
                delete packet;
                packet = NULL;
            }
            if (!packet) {
                if (transferPacket != t->_ePacket) {
                    KeAcquireSpinLock(&t->_ePacketSpinLock, &irql2);
                    if (t->_ePacketInUse) {
                        InsertHeadList(&t->_ePacketQueue, &ep->OverlapQueue);
                        t->_ePacketQueueBeingServiced = FALSE;
                        KeReleaseSpinLock(&t->_ePacketSpinLock, irql2);
                        KeReleaseSpinLock(spin, irql);
                        break;
                    }
                    t->_ePacketInUse = TRUE;
                    KeReleaseSpinLock(&t->_ePacketSpinLock, irql2);
                }
                packet = t->_ePacket;
            }

            packet->Length = t->_bucketSize;
            packet->Offset = ep->BucketNumber*t->_bucketSize;
            packet->CompletionRoutine = UpdateParityCompletionRoutine;
            packet->TargetVolume = ep->TargetVolume;
            packet->Thread = ep->Thread;
            packet->IrpFlags = ep->IrpFlags;
            packet->ReadPacket = TRUE;
            packet->Idle = FALSE;
            packet->OneWriteFailed = FALSE;
            InitializeListHead(&packet->UpdateQueue);
            packet->ParityIoManager = t;
            packet->BucketNumber = ep->BucketNumber;

            InsertTailList(q, &packet->OverlapQueue);
            InsertTailList(q, &ep->OverlapQueue);

            KeAcquireSpinLock(&t->_ePacketSpinLock, &irql2);
            qq = &t->_ePacketQueue;
            for (l = qq->Flink; l != qq; ) {
                p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);
                l = l->Flink;
                if (p->BucketNumber == ep->BucketNumber) {
                    RemoveEntryList(&p->OverlapQueue);
                    InsertTailList(q, &p->OverlapQueue);
                }
            }
            KeReleaseSpinLock(&t->_ePacketSpinLock, irql2);
            KeReleaseSpinLock(spin, irql);

            TRANSFER(packet);

            if (packet == t->_ePacket) {
                KeAcquireSpinLock(&t->_ePacketSpinLock, &irql);
                if (!t->_ePacketInUse) {
                    KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
                    continue;
                }
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_ePacketSpinLock, irql);
                break;
            }
        }
        return;
    }

    if (!transferPacket->ReadPacket) {
        target = (PCHAR) MmGetSystemAddressForMdl(transferPacket->Mdl);
        q = &transferPacket->UpdateQueue;
        for (l = q->Flink; l != q; l = l->Flink) {

            p = CONTAINING_RECORD(l, PARITY_TP, UpdateQueue);

            bucketOffset = (ULONG) (p->Offset - transferPacket->Offset);
            source = MmGetSystemAddressForMdl(p->Mdl);
            FtpComputeParity(target + bucketOffset, source, p->Length);
        }
    }

    TRANSFER(transferPacket);
}

VOID
PARITY_IO_MANAGER::StartReadForUpdateParity(
    IN  LONGLONG    Offset,
    IN  ULONG       Length,
    IN  PFT_VOLUME  TargetVolume,
    IN  PETHREAD    Thread,
    IN  UCHAR       IrpFlags
    )

/*++

Routine Description:

    This routine lets the parity manager know that an update for the
    given offset and length will be coming so that the PARITY_IO_MANAGER
    can start the read ahead of the parity buffer.

Arguments:

    Offset          - Supplies the request offset.

    Length          - Supplies the request length.

    TargetVolume    - Supplies the target volume.

    Thread          - Supplies the thread context for this request.

    IrpFlags        - Supplies the irp flags for this request.

Return Value:

    None.

--*/

{
    KIRQL       irql;
    LONGLONG    bucketNumber;
    ULONG       queueNumber;
    PLIST_ENTRY q, l;
    PKSPIN_LOCK spin;
    PPARITY_TP  p;

    KeAcquireSpinLock(&_ePacketSpinLock, &irql);
    if (_ePacketInUse || _ePacketQueueBeingServiced) {
        KeReleaseSpinLock(&_ePacketSpinLock, irql);
        return;
    }
    KeReleaseSpinLock(&_ePacketSpinLock, irql);

    bucketNumber = Offset/_bucketSize;
    queueNumber = (ULONG) (bucketNumber%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];
    KeAcquireSpinLock(spin, &irql);
    for (l = q->Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

        if (bucketNumber == p->BucketNumber) {
            KeReleaseSpinLock(spin, irql);
            return;
        }
    }
    p = new PARITY_TP;
    if (p && !p->AllocateMdl(_bucketSize)) {
        delete p;
        p = NULL;
    }
    if (!p) {
        KeReleaseSpinLock(spin, irql);
        return;
    }
    p->Length = Length;
    p->Offset = Offset;
    p->CompletionRoutine = UpdateParityCompletionRoutine;
    p->TargetVolume = TargetVolume;
    p->Thread = Thread;
    p->IrpFlags = IrpFlags;
    p->ReadPacket = TRUE;
    p->Idle = FALSE;
    p->OneWriteFailed = FALSE;
    InitializeListHead(&p->UpdateQueue);
    p->ParityIoManager = this;
    p->BucketNumber = bucketNumber;
    InsertTailList(q, &p->OverlapQueue);
    KeReleaseSpinLock(spin, irql);

    TRANSFER(p);
}

VOID
PARITY_IO_MANAGER::UpdateParity(
    IN OUT  PPARITY_TP  TransferPacket
    )

/*++

Routine Description:

    This routine xors the given buffer with the corresponding
    parity on disk and then writes out the result.

Arguments:

    TransferPacket  - Supplies the transfer packet containing the parity update.

Return Value:

    None.

--*/

{
    KIRQL               irql, irql2;
    ULONG               queueNumber;
    PLIST_ENTRY         q;
    PKSPIN_LOCK         spin;
    BOOLEAN             wasIdle;
    PLIST_ENTRY         l;
    PPARITY_TP          p, packet;

    TransferPacket->ReadPacket = FALSE;
    TransferPacket->Idle = FALSE;
    TransferPacket->ParityIoManager = this;
    TransferPacket->BucketNumber = TransferPacket->Offset/_bucketSize;

    queueNumber = (ULONG) (TransferPacket->BucketNumber%_numQueues);
    q = &_ioQueue[queueNumber];
    spin = &_spinLock[queueNumber];

    //
    // First figure out if there's already a read in progress for
    // the given parity bucket.  If there is then there is no
    // reason to queue another.  In this way, we can increase the
    // throughput on the parity section by collapsing the parity
    // updates.
    //

    KeAcquireSpinLock(spin, &irql);
    for (l = q->Blink; l != q; l = l->Blink) {

        p = CONTAINING_RECORD(l, PARITY_TP, OverlapQueue);

        if (p->BucketNumber == TransferPacket->BucketNumber) {
            break;
        }
    }
    if (l == q) {

        KeAcquireSpinLock(&_ePacketSpinLock, &irql2);
        if (_ePacketInUse || _ePacketQueueBeingServiced) {
            InsertTailList(&_ePacketQueue, &TransferPacket->OverlapQueue);
            KeReleaseSpinLock(&_ePacketSpinLock, irql2);
            KeReleaseSpinLock(spin, irql);
            return;
        }
        KeReleaseSpinLock(&_ePacketSpinLock, irql2);

        packet = new PARITY_TP;
        if (packet && !packet->AllocateMdl(_bucketSize)) {
            delete packet;
            packet = NULL;
        }
        if (!packet) {
            KeAcquireSpinLock(&_ePacketSpinLock, &irql2);
            if (_ePacketInUse || _ePacketQueueBeingServiced) {
                InsertTailList(&_ePacketQueue, &TransferPacket->OverlapQueue);
                KeReleaseSpinLock(&_ePacketSpinLock, irql2);
                KeReleaseSpinLock(spin, irql);
                return;
            }
            _ePacketInUse = TRUE;
            KeReleaseSpinLock(&_ePacketSpinLock, irql2);
            packet = _ePacket;
        }

        packet->Length = TransferPacket->Length;
        packet->Offset = TransferPacket->Offset;
        packet->CompletionRoutine = UpdateParityCompletionRoutine;
        packet->TargetVolume = TransferPacket->TargetVolume;
        packet->Thread = TransferPacket->Thread;
        packet->IrpFlags = TransferPacket->IrpFlags;
        packet->ReadPacket = TRUE;
        packet->Idle = FALSE;
        packet->OneWriteFailed = FALSE;
        InitializeListHead(&packet->UpdateQueue);
        packet->ParityIoManager = this;
        packet->BucketNumber = TransferPacket->BucketNumber;

        InsertTailList(q, &packet->OverlapQueue);
        InsertTailList(q, &TransferPacket->OverlapQueue);
        KeReleaseSpinLock(spin, irql);

        TRANSFER(packet);

    } else {
        wasIdle = p->Idle;
        p->Idle = FALSE;
        InsertTailList(q, &TransferPacket->OverlapQueue);
        KeReleaseSpinLock(spin, irql);
        if (wasIdle) {
            p->CompletionRoutine(p);
        }
    }
}

PARITY_IO_MANAGER::~PARITY_IO_MANAGER(
    )

{
    if (_spinLock) {
        ExFreePool(_spinLock);
        _spinLock = NULL;
    }
    if (_ioQueue) {
        ExFreePool(_ioQueue);
        _ioQueue = NULL;
    }
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
}

VOID
ParityCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a sector replacement
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_RECOVER_TP  subPacket = (PPARITY_RECOVER_TP) TransferPacket;

    subPacket->CompletionRoutine = ParityCarefulWritePhase1;
    TRANSFER(subPacket);
}

VOID
ParityCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a first attempt of a single sector write
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_RECOVER_TP  subPacket = (PPARITY_RECOVER_TP) TransferPacket;
    NTSTATUS            status = subPacket->IoStatus.Status;
    PPARITY_TP          masterPacket = (PPARITY_TP) subPacket->MasterPacket;
    PPARITY_IO_MANAGER  t = masterPacket->ParityIoManager;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        delete subPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        if (!subPacket->OneWriteFailed) {
            subPacket->CompletionRoutine = ParityCarefulWritePhase2;
            subPacket->OneWriteFailed = TRUE;
            subPacket->TargetVolume->ReplaceBadSector(subPacket);
            return;
        }

        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        delete subPacket;
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);
    subPacket->OneWriteFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
PARITY_IO_MANAGER::CarefulWrite(
    IN OUT  PPARITY_TP  TransferPacket
    )

/*++

Routine Description:

    This routine writes out the given transfer packet one sector at a time.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_RECOVER_TP  subPacket;
    KIRQL               irql;

    ASSERT(!TransferPacket->ReadPacket);

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new PARITY_RECOVER_TP;
    if (subPacket &&
        !subPacket->AllocateMdl((PVOID) (PAGE_SIZE - 1), _sectorSize)) {

        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      _sectorSize);

    subPacket->Length = _sectorSize;
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = ParityCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->OneWriteFailed = FALSE;
    subPacket->MasterPacket = TransferPacket;

    TRANSFER(subPacket);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\stripe.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    stripe.cxx

Abstract:

    This module contains the code specific to volume sets for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
STRIPE::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type STRIPE.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN                                     oneGood;
    USHORT                                      i;
    NTSTATUS                                    status;
    PFT_STRIPE_SET_CONFIGURATION_INFORMATION    configInfo;
    LONGLONG                                    newSize;

    if (ArraySize < 2) {
        return STATUS_INVALID_PARAMETER;
    }
    
    oneGood = FALSE;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            oneGood = TRUE;
        }
    }

    if (!oneGood) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    configInfo = (PFT_STRIPE_SET_CONFIGURATION_INFORMATION) ConfigInfo;
    _stripeSize = configInfo->StripeSize;
    if (_stripeSize < QuerySectorSize()) {
        return STATUS_INVALID_PARAMETER;
    }
    for (i = 0; _stripeSize%2 == 0; i++) {
        _stripeSize /= 2;
    }
    if (_stripeSize != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    _stripeSize = configInfo->StripeSize;
    _stripeShift = i;
    _stripeMask = _stripeSize - 1;

    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            _memberSize = VolumeArray[i]->QueryVolumeSize();
            break;
        }
    }
    for (; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            newSize = VolumeArray[i]->QueryVolumeSize();
            if (_memberSize > newSize) {
                _memberSize = newSize;
            }
        }
    }

    _memberSize = _memberSize/_stripeSize*_stripeSize;
    _volumeSize = _memberSize*ArraySize;

    _ePacket = new STRIPE_TP;
    if (_ePacket && !_ePacket->AllocateMdl((PVOID) 1, _stripeSize)) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (!_ePacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    InitializeListHead(&_ePacketQueue);

    return status;
}

FT_LOGICAL_DISK_TYPE
STRIPE::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtStripeSet;
}

NTSTATUS
STRIPE::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    NTSTATUS    status;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMemberUnprotected(i);
        if (!vol) {
            *IsIoOk = FALSE;
            return STATUS_SUCCESS;
        }
        status = vol->CheckIo(IsIoOk);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!(*IsIoOk)) {
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
STRIPE::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, whichMember;
    LONGLONG    whichStripe, whichRow, logicalOffsetInMember;
    PFT_VOLUME  vol;

    if (LogicalOffset < 0 ||
        _volumeSize <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }    
    
    n = QueryNumMembers();
    ASSERT(n);
    ASSERT(_stripeSize);
    whichStripe = LogicalOffset/_stripeSize;
    whichMember = (USHORT) (whichStripe%n);

    vol = GetMember(whichMember);
    if (!vol) {
        return STATUS_INVALID_PARAMETER;
    }

    whichRow = whichStripe/n;
    logicalOffsetInMember = whichRow*_stripeSize + LogicalOffset%_stripeSize;
    
    return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
}

NTSTATUS
STRIPE::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i;
    LONGLONG    whichStripe, whichRow; 
    LONGLONG    logicalOffset, logicalOffsetInMember;
    NTSTATUS    status;
    PFT_VOLUME  vol;
    
    n = QueryNumMembers();
    ASSERT(_stripeSize);
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            whichRow = logicalOffsetInMember/_stripeSize;
            whichStripe = whichRow*n + i;
            
            logicalOffset = whichStripe*_stripeSize + logicalOffsetInMember%_stripeSize;
            if (_volumeSize <= logicalOffset) {
                return STATUS_INVALID_PARAMETER;
            }

            *LogicalOffset = logicalOffset;
            return status;
        }        
    }

  return STATUS_INVALID_PARAMETER;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

STRIPE::~STRIPE(
    )

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
}

VOID
STRIPE::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for STRIPE type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;

    if (!LaunchParallel(TransferPacket)) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        LaunchSequential(TransferPacket);
    }
}

VOID
StripeReplaceCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a replace request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSTRIPE_TP          transferPacket = (PSTRIPE_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
STRIPE::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by routing
    the request to the appropriate sub-volume.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    USHORT      n, whichMember;
    LONGLONG    whichStripe, whichRow;
    PSTRIPE_TP  p;

    n = QueryNumMembers();
    whichStripe = TransferPacket->Offset/_stripeSize;
    whichMember = (USHORT) (whichStripe%n);
    whichRow = whichStripe/n;

    p = new STRIPE_TP;
    if (!p) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    p->Length = TransferPacket->Length;
    p->Offset = whichRow*_stripeSize + TransferPacket->Offset%_stripeSize;
    p->CompletionRoutine = StripeReplaceCompletionRoutine;
    p->TargetVolume = GetMemberUnprotected(whichMember);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->MasterPacket = TransferPacket;
    p->Stripe = this;
    p->WhichMember = whichMember;

    p->TargetVolume->ReplaceBadSector(p);
}

LONGLONG
STRIPE::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
StripeTransferParallelCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSTRIPE_TP          transferPacket = (PSTRIPE_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;

    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
        KeReleaseSpinLock(&masterPacket->SpinLock, irql);
    }

    delete transferPacket;

    if (!InterlockedDecrement(&masterPacket->RefCount)) {
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
STRIPE::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (_memberSize > vol->QueryVolumeSize()) {
            _memberSize = vol->QueryVolumeSize()/_stripeSize*_stripeSize;
        }
    }
    _volumeSize = n*_memberSize;
}

BOOLEAN
STRIPE::LaunchParallel(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in parallel accross
    all members.  If memory cannot be allocated to launch this request
    in parallel then a return value of FALSE will be returned.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    LONGLONG    offset, whichStripe, whichRow, off;
    ULONG       length, stripeOffset, stripeRemainder, numRequests, len;
    USHORT      arraySize, whichMember;
    PSTRIPE_TP  p;
    ULONG       i;
    PCHAR       vp;
    LIST_ENTRY  q;
    PLIST_ENTRY l;

    offset = TransferPacket->Offset;
    length = TransferPacket->Length;

    stripeOffset = (ULONG) (offset&_stripeMask);
    stripeRemainder = _stripeSize - stripeOffset;
    if (length > stripeRemainder) {
        length -= stripeRemainder;
        numRequests = length>>_stripeShift;
        length -= numRequests<<_stripeShift;
        if (length) {
            numRequests += 2;
        } else {
            numRequests++;
        }
    } else {
        numRequests = 1;
    }

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;
    TransferPacket->RefCount = numRequests;

    length = TransferPacket->Length;
    if (TransferPacket->Mdl && numRequests > 1) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }
    whichStripe = offset>>_stripeShift;
    arraySize = QueryNumMembers();
    InitializeListHead(&q);
    for (i = 0; i < numRequests; i++, whichStripe++) {

        whichRow = whichStripe/arraySize;
        whichMember = (USHORT) (whichStripe%arraySize);
        if (i == 0) {
            off = (whichRow<<_stripeShift) + stripeOffset;
            len = stripeRemainder > length ? length : stripeRemainder;
        } else if (i == numRequests - 1) {
            off = whichRow<<_stripeShift;
            len = length;
        } else {
            off = whichRow<<_stripeShift;
            len = _stripeSize;
        }
        length -= len;

        p = new STRIPE_TP;
        if (p) {
            if (TransferPacket->Mdl && numRequests > 1) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    p = NULL;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
                p->OriginalIrp = TransferPacket->OriginalIrp;
            }
        }
        if (!p) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                p = CONTAINING_RECORD(l, STRIPE_TP, QueueEntry);
                delete p;
            }
            return FALSE;
        }

        p->Length = len;
        p->Offset = off;
        p->CompletionRoutine = StripeTransferParallelCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(whichMember);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->Stripe = this;
        p->WhichMember = whichMember;

        InsertTailList(&q, &p->QueueEntry);
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, STRIPE_TP, QueueEntry);
        TRANSFER(p);
    }

    return TRUE;
}

VOID
StripeSequentialTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSTRIPE_TP          transferPacket = (PSTRIPE_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PSTRIPE             t = transferPacket->Stripe;
    LONGLONG            rowNumber, stripeNumber, masterOffset;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    MmPrepareMdlForReuse(transferPacket->Mdl);

    rowNumber = transferPacket->Offset/t->_stripeSize;
    stripeNumber = rowNumber*t->QueryNumMembers() +
                   transferPacket->WhichMember;
    masterOffset = stripeNumber*t->_stripeSize +
                   transferPacket->Offset%t->_stripeSize;

    if (masterOffset + transferPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketInUse = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                t->LaunchSequential(p);
                break;
            }
        }
        return;
    }

    transferPacket->WhichMember++;
    if (transferPacket->WhichMember == t->QueryNumMembers()) {
        transferPacket->WhichMember = 0;
        rowNumber++;
    }
    masterOffset += transferPacket->Length;

    transferPacket->Offset = rowNumber*t->_stripeSize;
    transferPacket->Length = t->_stripeSize;

    if (masterOffset + transferPacket->Length >
        masterPacket->Offset + masterPacket->Length) {

        transferPacket->Length = (ULONG) (masterPacket->Offset +
                                          masterPacket->Length - masterOffset);
    }

    transferPacket->TargetVolume =
            t->GetMemberUnprotected(transferPacket->WhichMember);

    IoBuildPartialMdl(masterPacket->Mdl, transferPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (masterOffset - masterPacket->Offset),
                      transferPacket->Length);

    TRANSFER(transferPacket);
}

VOID
STRIPE::LaunchSequential(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in sequence accross
    all members using the emergency stripe transfer packet.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    PSTRIPE_TP  p;
    LONGLONG    offset, whichStripe, whichRow;
    USHORT      whichMember, arraySize;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;

    offset = TransferPacket->Offset;

    p = _ePacket;
    arraySize = QueryNumMembers();
    whichStripe = offset/_stripeSize;
    whichRow = whichStripe/arraySize;
    whichMember = (USHORT) (whichStripe%arraySize);
    p->Length = _stripeSize - (ULONG) (offset%_stripeSize);
    if (p->Length > TransferPacket->Length) {
        p->Length = TransferPacket->Length;
    }
    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl), p->Length);

    p->Offset = whichRow*_stripeSize + offset%_stripeSize;
    p->CompletionRoutine = StripeSequentialTransferCompletionRoutine;
    p->TargetVolume = GetMemberUnprotected(whichMember);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->SpecialRead = TransferPacket->SpecialRead;
    p->MasterPacket = TransferPacket;
    p->Stripe = this;
    p->WhichMember = whichMember;

    TRANSFER(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\stripewp.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    stripewp.cxx

Abstract:

    This module contains the code specific to stripes with parity for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
STRIPE_WP::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type STRIPE with PARITY.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    None.

--*/

{
    PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION    configInfo;
    NTSTATUS                                                status;
    USHORT                                                  i;

    if (ArraySize < 3) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    configInfo = (PFT_STRIPE_SET_WITH_PARITY_CONFIGURATION_INFORMATION) ConfigInfo;
    _stripeSize = configInfo->StripeSize;
    if (_stripeSize < QuerySectorSize()) {
        return STATUS_INVALID_PARAMETER;
    }
    for (i = 0; _stripeSize%2 == 0; i++) {
        _stripeSize /= 2;
    }
    if (_stripeSize != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    _stripeSize = configInfo->StripeSize;
    _memberSize = configInfo->MemberSize;

    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i] &&
            VolumeArray[i]->QueryVolumeSize() < _memberSize) {

            break;
        }
    }
    if (i < ArraySize) {
        return STATUS_INVALID_PARAMETER;
    }

    _memberSize = _memberSize/_stripeSize*_stripeSize;
    _volumeSize = _memberSize*(ArraySize - 1);

    RtlCopyMemory(&_state, StateInfo, sizeof(_state));
    _originalDirtyBit = _state.IsDirty;
    _orphanedBecauseOfMissingMember = FALSE;
    _syncOk = TRUE;
    _stopSyncs = FALSE;

    status = _overlappedIoManager.Initialize(_stripeSize);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = _parityIoManager.Initialize(_stripeSize, QuerySectorSize());
    if (!NT_SUCCESS(status)) {
        return status;
    }

    _ePacket = new SWP_WRITE_TP;
    if (!_ePacket ||
        !_ePacket->AllocateMdls(_stripeSize) ||
        !_ePacket->AllocateMdl((PVOID) 1, _stripeSize)) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    _ePacketQueueBeingServiced = FALSE;
    InitializeListHead(&_ePacketQueue);

    _eRegeneratePacket = new SWP_REGENERATE_TP;
    if (!_eRegeneratePacket ||
        !_eRegeneratePacket->AllocateMdl(_stripeSize)) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _eRegeneratePacketInUse = FALSE;
    InitializeListHead(&_eRegeneratePacketQueue);

    _eRecoverPacket = new SWP_RECOVER_TP;
    if (!_eRecoverPacket ||
        !_eRecoverPacket->AllocateMdls(QuerySectorSize())) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _eRecoverPacketInUse = FALSE;
    InitializeListHead(&_eRecoverPacketQueue);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_TYPE
STRIPE_WP::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtStripeSetWithParity;
}

NTSTATUS
STRIPE_WP::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, whichMember, parityStripe;
    LONGLONG    whichStripe, whichRow, logicalOffsetInMember;
    PFT_VOLUME  vol;

    if (LogicalOffset < 0 ||
        _volumeSize <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }    
    
    n = QueryNumMembers();
    ASSERT(n > 1);
    ASSERT(_stripeSize);
    whichStripe = LogicalOffset/_stripeSize;
    whichRow = whichStripe/(n - 1);
    whichMember = (USHORT) (whichStripe%(n - 1));
    parityStripe = (USHORT) (whichRow%n);
    if (whichMember >= parityStripe) {
        whichMember++;        
    }

    vol = GetMember(whichMember);
    if (!vol) {
        return STATUS_INVALID_PARAMETER;
    }

    logicalOffsetInMember = whichRow*_stripeSize + LogicalOffset%_stripeSize;
    
    return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
}

NTSTATUS
STRIPE_WP::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i, parityStripe;
    LONGLONG    whichStripe, whichRow;
    LONGLONG    logicalOffset, logicalOffsetInMember;
    NTSTATUS    status;
    PFT_VOLUME  vol;
    
    n = QueryNumMembers();
    ASSERT(_stripeSize);
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            whichRow = logicalOffsetInMember/_stripeSize;
            parityStripe = (USHORT) (whichRow%n);
            
            if (i == parityStripe) {
                return STATUS_INVALID_PARAMETER;
            }

            whichStripe = whichRow*(n-1) + i;
            if (parityStripe < i) {
                whichStripe--;
            }

            logicalOffset = whichStripe*_stripeSize + logicalOffsetInMember%_stripeSize;
            if (_volumeSize <= logicalOffset) {
                return STATUS_INVALID_PARAMETER;
            }

            *LogicalOffset = logicalOffset;
            return status;
        }        
    }

    return STATUS_INVALID_PARAMETER;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

NTSTATUS
STRIPE_WP::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk.
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber    - Supplies the member number to orphan.

Return Value:

    NTSTATUS

--*/

{
    KIRQL       irql;
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     b;

    if (MemberNumber >= QueryNumMembers()) {
        return STATUS_INVALID_PARAMETER;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    b = SetMemberState(MemberNumber, FtMemberOrphaned);
    KeReleaseSpinLock(&_spinLock, irql);

    if (b) {
        PropogateStateChanges(CompletionRoutine, Context);
        Notify();
        FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_ORPHANING,
                    STATUS_SUCCESS, 2);
    }

    return b ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
}

VOID
StripeWpCompositeVolumeCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;
    LONG                            count;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT) Context;

    KeAcquireSpinLock(&context->SpinLock, &irql);
    if (!NT_SUCCESS(Status) &&
        FtpIsWorseStatus(Status, context->Status)) {

        context->Status = Status;
    }

    count = --context->RefCount;
    KeReleaseSpinLock(&context->SpinLock, irql);

    if (!count) {
        context->CompletionRoutine(context->Context, STATUS_SUCCESS);
        ExFreePool(context);
    }
}

VOID
StripeWpSyncCleanup(
    IN  PSWP_REBUILD_TP TransferPacket
    )

/*++

Routine Description:

    This is the cleanup routine for the initialize check data process.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;

    context = TransferPacket->Context;
    delete TransferPacket;
    StripeWpCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
}

VOID
StripeWpSyncCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for an initialize check data request.
    This routine is called over and over again until the volume
    is completely initialized.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_REBUILD_TP transferPacket = (PSWP_REBUILD_TP) TransferPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;
    NTSTATUS        status = transferPacket->IoStatus.Status;
    KIRQL           irql;
    ULONG           parityMember;
    BOOLEAN         b;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->_stopSyncs ||
        t->QueryMemberState(transferPacket->WhichMember) == FtMemberOrphaned) {

        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        t->_overlappedIoManager.ReleaseIoRegion(transferPacket);
        StripeWpSyncCleanup(transferPacket);
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (!NT_SUCCESS(status)) {

        // We can't get a VERIFY_REQUIRED because we put IrpFlags equal
        // to SL_OVERRIDE_VERIFY_VOLUME.

        ASSERT(status != STATUS_VERIFY_REQUIRED);

        if (FsRtlIsTotalDeviceFailure(status)) {

            if (!transferPacket->ReadPacket) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 3);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }
            }

            // The initialize cannot continue.

            KeAcquireSpinLock(&t->_spinLock, &irql);
            t->_syncOk = TRUE;
            KeReleaseSpinLock(&t->_spinLock, irql);

            t->_overlappedIoManager.ReleaseIoRegion(transferPacket);
            StripeWpSyncCleanup(transferPacket);
            return;
        }

        // Transfer the maximum amount that we can.  This will always
        // complete successfully and log bad sector errors for
        // those sectors that it could not transfer.

        t->MaxTransfer(transferPacket);
        return;
    }

    transferPacket->Thread = PsGetCurrentThread();

    if (transferPacket->ReadPacket) {
        transferPacket->ReadPacket = FALSE;
        TRANSFER(transferPacket);
        return;
    }

    t->_overlappedIoManager.ReleaseIoRegion(transferPacket);

    transferPacket->ReadPacket = TRUE;
    transferPacket->Offset += t->_stripeSize;
    if (transferPacket->Initialize) {
        transferPacket->WhichMember = (transferPacket->WhichMember + 1)%
                                      t->QueryNumMembers();
        transferPacket->TargetVolume = t->GetMemberUnprotected(
                                       transferPacket->WhichMember);
    }

    if (transferPacket->Offset < t->_memberSize) {
        t->RegeneratePacket(transferPacket, TRUE);
        return;
    }

    if (transferPacket->Initialize) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_state.IsInitializing = FALSE;
        t->_syncOk = TRUE;
        t->_originalDirtyBit = FALSE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        t->PropogateStateChanges(NULL, NULL);
        t->Notify();
    } else {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        b = t->SetMemberState(transferPacket->WhichMember, FtMemberHealthy);
        t->_syncOk = TRUE;
        t->_originalDirtyBit = FALSE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (b) {
            t->PropogateStateChanges(NULL, NULL);
            t->Notify();
        }
    }

    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                FT_REGENERATION_ENDED, STATUS_SUCCESS, 0);

    StripeWpSyncCleanup(transferPacket);
}

NTSTATUS
STRIPE_WP::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber        - Supplies the member number to regenerate.

    NewMember           - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    KIRQL                           irql;
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    BOOLEAN                         b;
    PSWP_REBUILD_TP                 packet;
    USHORT                          i, n;
    NTSTATUS                        status;

    n = QueryNumMembers();
    if (MemberNumber >= n ||
        NewMember->QueryVolumeSize() < _memberSize) {

        return STATUS_INVALID_PARAMETER;
    }

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    packet = new SWP_REBUILD_TP;
    if (packet && !packet->AllocateMdl(_stripeSize)) {
        delete packet;
        packet = NULL;
    }
    if (!context || !packet) {
        if (context) {
            ExFreePool(context);
        }
        if (packet) {
            delete packet;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 1;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    packet->Length = _stripeSize;
    packet->Offset = 0;
    packet->CompletionRoutine = StripeWpSyncCompletionRoutine;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->StripeWithParity = this;
    packet->Context = context;
    packet->Initialize = FALSE;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        delete packet;
        ExFreePool(context);
        return STATUS_INVALID_PARAMETER;
    }

    status = STATUS_SUCCESS;
    if (_state.IsInitializing) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        if (_state.UnhealthyMemberState != FtMemberHealthy) {
            if (MemberNumber == _state.UnhealthyMemberNumber) {
                if (_state.UnhealthyMemberState == FtMemberRegenerating) {
                    status = STATUS_INVALID_PARAMETER;
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    if (!NT_SUCCESS(status)) {
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        ExFreePool(context);
        delete packet;
        return status;
    }

    packet->WhichMember = MemberNumber;
    packet->TargetVolume = NewMember;

    SetMemberUnprotected(MemberNumber, NewMember);
    b = SetMemberState(MemberNumber, FtMemberRegenerating);
    KeReleaseSpinLock(&_spinLock, irql);

    ASSERT(b);

    PropogateStateChanges(NULL, NULL);
    Notify();

    FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_REGENERATION_STARTED,
                STATUS_SUCCESS, 0);

    RegeneratePacket(packet, TRUE);

    return STATUS_SUCCESS;
}

VOID
STRIPE_WP::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for STRIPE_WP type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;

    if (TransferPacket->Offset + TransferPacket->Length > _volumeSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if ((_ePacketInUse  || _ePacketQueueBeingServiced) &&
        TransferPacket->Mdl) {

        InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
        KeReleaseSpinLock(&_spinLock, irql);
        return;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!TransferPacket->Mdl) {
        TransferPacket->ReadPacket = TRUE;
    }

    if (!LaunchParallel(TransferPacket)) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse || _ePacketQueueBeingServiced) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        LaunchSequential(TransferPacket);
    }
}

VOID
STRIPE_WP::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is a no-op since replacing bad sectors doesn't make sense
    on an FT component with redundancy built in to it.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    TransferPacket->IoStatus.Status = STATUS_UNSUCCESSFUL;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->CompletionRoutine(TransferPacket);
}

VOID
STRIPE_WP::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This aroutine restarts any regenerate or initialize requests that
    were suspended because of a reboot.  The volume examines the member
    state of all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    BOOLEAN                         dirty, regen, init;
    KIRQL                           irql;
    PFT_VOLUME                      vol;
    PSWP_REBUILD_TP                 packet;
    PVOID                           buffer;
    LONG                            regenMember;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!context) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 2;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    // Kick off the recursive initialize.

    COMPOSITE_FT_VOLUME::StartSyncOperations(RegenerateOrphans,
            StripeWpCompositeVolumeCompletionRoutine, context);

    if (_orphanedBecauseOfMissingMember) {
        RegenerateOrphans = TRUE;
        _orphanedBecauseOfMissingMember = FALSE;
    }

    // Make sure that all member are healthy.

    dirty = FALSE;
    regen = FALSE;
    init = FALSE;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        StripeWpCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    if (_state.UnhealthyMemberState == FtMemberOrphaned &&
        RegenerateOrphans &&
        GetMemberUnprotected(_state.UnhealthyMemberNumber)) {

        _state.UnhealthyMemberState = FtMemberRegenerating;
        PropogateStateChanges(NULL, NULL);
    }
    if (_state.IsInitializing) {
        regenMember = -1;
        init = TRUE;
    } else if (_state.UnhealthyMemberState == FtMemberRegenerating) {
        regenMember = _state.UnhealthyMemberNumber;
        regen = TRUE;
    } else if (_originalDirtyBit &&
               _state.UnhealthyMemberState == FtMemberHealthy) {

        regenMember = -1;
        dirty = TRUE;
    } else {
        regenMember = -2;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (dirty) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_DIRTY_SHUTDOWN, STATUS_SUCCESS, 0);
    }

    if (regen) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_REGENERATION_STARTED, STATUS_SUCCESS, 0);
        Notify();
    }

    if (init) {
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_PARITY_INITIALIZATION_STARTED, STATUS_SUCCESS, 0);
        Notify();
    }

    if (regenMember == -2) {
        KeAcquireSpinLock(&_spinLock, &irql);
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        StripeWpCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }

    packet = new SWP_REBUILD_TP;
    if (packet && !packet->AllocateMdl(_stripeSize)) {
        delete packet;
        packet = NULL;
    }
    if (!packet) {
        KeAcquireSpinLock(&_spinLock, &irql);
        _syncOk = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);
        StripeWpCompositeVolumeCompletionRoutine(context,
                                                 STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    packet->Length = _stripeSize;
    packet->Offset = 0;
    packet->CompletionRoutine = StripeWpSyncCompletionRoutine;
    packet->Thread = PsGetCurrentThread();
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->ReadPacket = TRUE;
    packet->MasterPacket = NULL;
    packet->StripeWithParity = this;
    packet->Context = context;
    if (regenMember >= 0) {
        packet->WhichMember = (USHORT) regenMember;
        packet->Initialize = FALSE;
    } else {
        packet->WhichMember = 0;
        packet->Initialize = TRUE;
    }
    packet->TargetVolume = GetMemberUnprotected(packet->WhichMember);

    RegeneratePacket(packet, TRUE);
}

VOID
STRIPE_WP::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    COMPOSITE_FT_VOLUME::StopSyncOperations();

    KeAcquireSpinLock(&_spinLock, &irql);
    if (!_syncOk) {
        _stopSyncs = TRUE;
    }
    KeReleaseSpinLock(&_spinLock, irql);
}

LONGLONG
STRIPE_WP::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
STRIPE_WP::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;

    if (CompletionRoutine) {

        context = (PFT_COMPLETION_ROUTINE_CONTEXT)
                  ExAllocatePool(NonPagedPool,
                                 sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
        if (!context) {
            CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
            return;
        }

        KeInitializeSpinLock(&context->SpinLock);
        context->Status = STATUS_SUCCESS;
        context->RefCount = 2;
        context->CompletionRoutine = CompletionRoutine;
        context->Context = Context;
        context->ParentVolume = this;

        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty,
                StripeWpCompositeVolumeCompletionRoutine, context);

    } else {
        COMPOSITE_FT_VOLUME::SetDirtyBit(IsDirty, NULL, NULL);
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (IsDirty || _syncOk) {
        if (!_stopSyncs) {
            _state.IsDirty = IsDirty;
        }
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (CompletionRoutine) {
        PropogateStateChanges(StripeWpCompositeVolumeCompletionRoutine, context);
    } else {
        PropogateStateChanges(NULL, NULL);
    }
}

BOOLEAN
STRIPE_WP::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    BOOLEAN     b;
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    b = COMPOSITE_FT_VOLUME::IsComplete(IoPending);
    if (b) {
        return TRUE;
    }

    if (!IoPending || _state.IsInitializing) {
        return FALSE;
    }

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            if (orphanMember < n) {
                return FALSE;
            }
            orphanMember = i;
        }
    }

    if (orphanMember < n) {
        if (_state.UnhealthyMemberState != FtMemberHealthy &&
            _state.UnhealthyMemberNumber != orphanMember) {

            return FALSE;
        }
    }

    return TRUE;
}

VOID
STRIPE_WP::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i, orphanMember;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    n = QueryNumMembers();
    orphanMember = n;
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol || !vol->IsComplete(IoPending)) {
            orphanMember = i;
            break;
        }
    }

    if (orphanMember < n) {
        if (SetMemberState(orphanMember, FtMemberOrphaned)) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 1);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            _orphanedBecauseOfMissingMember = TRUE;
        }
    }
}

NTSTATUS
STRIPE_WP::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;
    KIRQL       irql;
    USHORT      n, numOk, skipVol, i;
    PFT_VOLUME  vol;
    BOOLEAN     ok, b;

    n = QueryNumMembers();
    numOk = 0;
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        skipVol = n;
    } else {
        skipVol = _state.UnhealthyMemberNumber;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    for (i = 0; i < n; i++) {
        if (i == skipVol) {
            continue;
        }
        vol = GetMemberUnprotected(i);
        if (!vol) {
            continue;
        }

        status = vol->CheckIo(&ok);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (ok) {
            numOk++;
        }
    }

    if (numOk >= n - 1) {
        *IsIoOk = TRUE;
    } else {
        *IsIoOk = FALSE;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
STRIPE_WP::IsVolumeSuitableForRegenerate(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine computes whether or not the given volume is suitable
    for a regenerate operation.

Arguments:

    MemberNumber    - Supplies the member number.

    Volume          - Supplies the volume.

Return Value:

    FALSE   - The volume is not suitable.

    TRUE    - The volume is suitable.

--*/

{
    KIRQL   irql;

    if (Volume->QueryVolumeSize() < _memberSize) {
        return FALSE;
    }

    KeAcquireSpinLock(&_spinLock, &irql);
    if (!_syncOk ||
        _state.IsInitializing ||
        _state.UnhealthyMemberState != FtMemberOrphaned ||
        _state.UnhealthyMemberNumber != MemberNumber) {

        KeReleaseSpinLock(&_spinLock, irql);
        return FALSE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    return TRUE;
}

VOID
STRIPE_WP::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
    BOOLEAN                                 changed = FALSE;
    BOOLEAN                                 severeInconsistency = FALSE;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) NewStateInstance;
    if (state->IsDirty) {
        if (!_state.IsDirty) {
            _originalDirtyBit = _state.IsDirty = state->IsDirty;
            changed = TRUE;
        }
    }

    if (state->IsInitializing) {
        if (_state.UnhealthyMemberState == FtMemberHealthy) {
            if (!_state.IsInitializing) {
                _state.IsInitializing = TRUE;
                changed = TRUE;
            }
        } else {
            severeInconsistency = TRUE;
        }
    } else if (state->UnhealthyMemberState != FtMemberHealthy) {
        if (state->UnhealthyMemberNumber >= QueryNumMembers()) {
            severeInconsistency = TRUE;
        } else if (_state.IsInitializing) {
            severeInconsistency = TRUE;
        } else if (_state.UnhealthyMemberState == FtMemberHealthy) {
            _state.UnhealthyMemberState = state->UnhealthyMemberState;
            _state.UnhealthyMemberNumber = state->UnhealthyMemberNumber;
            changed = TRUE;
        } else if (_state.UnhealthyMemberNumber == state->UnhealthyMemberNumber) {
            if (state->UnhealthyMemberState == FtMemberOrphaned) {
                if (_state.UnhealthyMemberState != FtMemberOrphaned) {
                    _state.UnhealthyMemberState = FtMemberOrphaned;
                    changed = TRUE;
                }
            }
        } else {
            severeInconsistency = TRUE;
        }
    }

    if (severeInconsistency) {
        _state.IsInitializing = TRUE;
        _state.UnhealthyMemberState = FtMemberHealthy;
        changed = TRUE;
        FtpLogError(_rootExtension, QueryLogicalDiskId(),
                    FT_SWP_STATE_CORRUPTION, STATUS_SUCCESS,
                    0);
    }

    if (changed) {
        PropogateStateChanges(NULL, NULL);
    }
}

BOOLEAN
STRIPE_WP::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    USHORT          n, i;
    PFT_VOLUME      vol;
    KIRQL           irql;
    FT_MEMBER_STATE state;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }

        if (!vol->QueryVolumeState(Volume, State)) {
            continue;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        state = QueryMemberState(i);
        if (state != FtMemberHealthy) {
            if (*State != FtMemberOrphaned) {
                *State = state;
            }
        }
        KeReleaseSpinLock(&_spinLock, irql);

        return TRUE;
    }

    return FALSE;
}

STRIPE_WP::STRIPE_WP(
    )

/*++

Routine Description:

    Constructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _ePacket = NULL;
    _eRegeneratePacket = NULL;
    _eRecoverPacket = NULL;
}

STRIPE_WP::~STRIPE_WP(
    )

/*++

Routine Description:

    Routine called to cleanup resources being used by the object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (_eRegeneratePacket) {
        delete _eRegeneratePacket;
        _eRegeneratePacket = NULL;
    }
    if (_eRecoverPacket) {
        delete _eRecoverPacket;
        _eRecoverPacket = NULL;
    }
}

BOOLEAN
STRIPE_WP::SetMemberState(
    IN  USHORT          MemberNumber,
    IN  FT_MEMBER_STATE MemberState
    )

/*++

Routine Description:

    This routine sets the given member to the given state.

Arguments:

    MemberNumber    - Supplies the member number.

    MemberState     - Supplies the member state.

Return Value:

    FALSE   - There was no state change.

    TRUE    - A state change took place.

Notes:

    The caller must be holding the class spin lock.

--*/

{
    if (_state.IsInitializing) {
        return FALSE;
    }

    if (_state.UnhealthyMemberState == FtMemberHealthy) {
        if (MemberNumber >= QueryNumMembers()) {
            KeBugCheckEx(FTDISK_INTERNAL_ERROR, (ULONG_PTR) this,
                         MemberNumber, MemberState, 0);
        }
        _state.UnhealthyMemberNumber = MemberNumber;
        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    if (_state.UnhealthyMemberNumber == MemberNumber &&
        _state.UnhealthyMemberState != MemberState) {

        _state.UnhealthyMemberState = MemberState;
        return TRUE;
    }

    return FALSE;
}

VOID
StripeWpParallelTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE_WP::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = (PSTRIPE_WP) transferPacket->StripeWithParity;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;
    LONG                count;
    BOOLEAN             b, serviceQueue;
    PSWP_WRITE_TP       writePacket;

    if (NT_SUCCESS(status)) {

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

        if (transferPacket->OneReadFailed &&
            FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {

            masterPacket->IoStatus.Status = status;
        }

    } else {

        // Should we orphan the drive?

        if (transferPacket->ReadPacket &&
            !transferPacket->OneReadFailed &&
            status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 4);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                t->RegeneratePacket(transferPacket, TRUE);
                return;
            }

            // Is this something that we should retry for bad sectors?

            if (transferPacket->Mdl) {
                transferPacket->OneReadFailed = TRUE;
                t->Recover(transferPacket, TRUE);
                return;
            }
        }

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    count = --masterPacket->RefCount;

    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    serviceQueue = FALSE;
    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->_ePacketInUse && !t->_ePacketQueueBeingServiced) {
        t->_ePacketQueueBeingServiced = TRUE;
        serviceQueue = TRUE;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    delete transferPacket;

    if (!count) {
        masterPacket->CompletionRoutine(masterPacket);
    }

    if (serviceQueue) {

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                if (t->_ePacketInUse) {
                    InsertHeadList(&t->_ePacketQueue, l);
                    t->_ePacketQueueBeingServiced = FALSE;
                    KeReleaseSpinLock(&t->_spinLock, irql);
                } else {
                    t->_ePacketInUse = TRUE;
                    KeReleaseSpinLock(&t->_spinLock, irql);
                    t->LaunchSequential(p);
                    KeAcquireSpinLock(&t->_spinLock, &irql);
                    if (!t->_ePacketInUse) {
                        KeReleaseSpinLock(&t->_spinLock, irql);
                        continue;
                    }
                    t->_ePacketQueueBeingServiced = FALSE;
                    KeReleaseSpinLock(&t->_spinLock, irql);
                }
                break;
            }
        }
    }
}

BOOLEAN
STRIPE_WP::LaunchParallel(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches a transfer packet in parallel accross the
    stripe members.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    LONGLONG    offset, whichStripe, whichRow, off;
    ULONG       length, stripeRemainder, numRequests, arraySize;
    USHORT      whichMember, parityStripe;
    ULONG       len;
    PSWP_TP     p;
    ULONG       i;
    PCHAR       vp;
    LIST_ENTRY  q;
    PLIST_ENTRY l;

    // Compute the number of pieces for this transfer.

    offset = TransferPacket->Offset;
    length = TransferPacket->Length;

    stripeRemainder = _stripeSize - (ULONG) (offset%_stripeSize);
    if (length > stripeRemainder) {
        length -= stripeRemainder;
        numRequests = length/_stripeSize;
        length -= numRequests*_stripeSize;
        if (length) {
            numRequests += 2;
        } else {
            numRequests++;
        }
    } else {
        numRequests = 1;
    }

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;
    TransferPacket->RefCount = numRequests;

    length = TransferPacket->Length;
    if (TransferPacket->Mdl && numRequests > 1) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }
    whichStripe = offset/_stripeSize;
    arraySize = QueryNumMembers();
    InitializeListHead(&q);
    for (i = 0; i < numRequests; i++, whichStripe++) {

        whichRow = whichStripe/(arraySize - 1);
        whichMember = (USHORT) (whichStripe%(arraySize - 1));
        parityStripe = (USHORT) (whichRow%arraySize);
        if (whichMember >= parityStripe) {
            whichMember++;
        }
        if (i == 0) {
            off = whichRow*_stripeSize + offset%_stripeSize;
            len = stripeRemainder > length ? length : stripeRemainder;
        } else if (i == numRequests - 1) {
            off = whichRow*_stripeSize;
            len = length;
        } else {
            off = whichRow*_stripeSize;
            len = _stripeSize;
        }
        length -= len;

        if (TransferPacket->ReadPacket) {
            p = new SWP_TP;
        } else {
            p = new SWP_WRITE_TP;
            if (p && !((PSWP_WRITE_TP) p)->AllocateMdls(len)) {
                delete p;
                p = NULL;
            }
        }
        if (p) {
            if (TransferPacket->Mdl && numRequests > 1) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    p = NULL;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
            }
        }
        if (!p) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                p = CONTAINING_RECORD(l, SWP_TP, QueueEntry);
                delete p;
            }
            return FALSE;
        }

        p->Length = len;
        p->Offset = off;
        p->CompletionRoutine = StripeWpParallelTransferCompletionRoutine;
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->MasterPacket = TransferPacket;
        p->StripeWithParity = this;
        p->WhichMember = whichMember;
        p->SavedCompletionRoutine = StripeWpParallelTransferCompletionRoutine;
        p->OneReadFailed = FALSE;

        InsertTailList(&q, &p->QueueEntry);
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, SWP_TP, QueueEntry);
        ASSERT(p->ReadPacket == TransferPacket->ReadPacket);
        if (p->ReadPacket) {
            ReadPacket(p);
        } else {
            WritePacket((PSWP_WRITE_TP) p);
        }
    }

    return TRUE;
}

VOID
StripeWpSequentialTransferCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for STRIPE::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    LONGLONG            rowNumber, stripeNumber, masterOffset;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;
    USHORT              parityStripe;
    BOOLEAN             b;
    PSWP_WRITE_TP       writePacket;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

        if (transferPacket->OneReadFailed &&
            FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {

            masterPacket->IoStatus.Status = status;
        }

    } else {

        // Should we orphan the drive?

        if (transferPacket->ReadPacket &&
            !transferPacket->OneReadFailed &&
            status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {
                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(transferPacket->WhichMember,
                                      FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 5);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                t->RegeneratePacket(transferPacket, TRUE);
                return;

            }

            // Is this something that we should retry for bad sectors.

            if (transferPacket->Mdl) {
                transferPacket->OneReadFailed = TRUE;
                t->Recover(transferPacket, TRUE);
                return;
            }
        }

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    MmPrepareMdlForReuse(transferPacket->Mdl);

    t->_overlappedIoManager.ReleaseIoRegion(transferPacket);

    rowNumber = transferPacket->Offset/t->_stripeSize;
    parityStripe = (USHORT) rowNumber%t->QueryNumMembers();
    stripeNumber = rowNumber*(t->QueryNumMembers() - 1) +
                   transferPacket->WhichMember;
    if (transferPacket->WhichMember > parityStripe) {
        stripeNumber--;
    }

    masterOffset = stripeNumber*t->_stripeSize +
                   transferPacket->Offset%t->_stripeSize +
                   transferPacket->Length;

    if (masterOffset == masterPacket->Offset + masterPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);

        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_ePacketQueueBeingServiced) {
            t->_ePacketInUse = FALSE;
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_ePacketQueueBeingServiced = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketInUse = FALSE;
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                t->LaunchSequential(p);
                KeAcquireSpinLock(&t->_spinLock, &irql);
                if (!t->_ePacketInUse) {
                    KeReleaseSpinLock(&t->_spinLock, irql);
                    continue;
                }
                t->_ePacketQueueBeingServiced = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
        }
        return;
    }

    transferPacket->WhichMember++;
    if (transferPacket->WhichMember == t->QueryNumMembers()) {
        transferPacket->WhichMember = 0;
        rowNumber++;
    } else if (transferPacket->WhichMember == parityStripe) {
        transferPacket->WhichMember++;
        if (transferPacket->WhichMember == t->QueryNumMembers()) {
            transferPacket->WhichMember = 1;
            rowNumber++;
        }
    }

    transferPacket->Offset = rowNumber*t->_stripeSize;
    transferPacket->Length = t->_stripeSize;

    if (masterOffset + transferPacket->Length >
        masterPacket->Offset + masterPacket->Length) {

        transferPacket->Length = (ULONG) (masterPacket->Offset +
                                          masterPacket->Length - masterOffset);
    }

    IoBuildPartialMdl(masterPacket->Mdl, transferPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (masterOffset - masterPacket->Offset),
                      transferPacket->Length);

    if (transferPacket->ReadPacket) {
        t->ReadPacket(transferPacket);
    } else {
        t->WritePacket((PSWP_WRITE_TP) transferPacket);
    }
}

VOID
STRIPE_WP::LaunchSequential(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches a transfer packet sequentially accross the
    stripe members using the emergency packet.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    FALSE   - Insufficient resources.

    TRUE    - Success.

--*/

{
    PSWP_WRITE_TP   p;
    LONGLONG        offset, whichStripe, whichRow, o;
    USHORT          whichMember, arraySize, parityStripe;
    ULONG           l, stripeRemainder;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;

    offset = TransferPacket->Offset;

    p = _ePacket;
    arraySize = QueryNumMembers();
    stripeRemainder = _stripeSize - (ULONG) (offset%_stripeSize);
    whichStripe = offset/_stripeSize;
    whichRow = whichStripe/(arraySize - 1);
    whichMember = (USHORT) (whichStripe%(arraySize - 1));
    parityStripe = (USHORT) (whichRow%arraySize);
    if (whichMember >= parityStripe) {
        whichMember++;
    }
    o = whichRow*_stripeSize + offset%_stripeSize;
    l = stripeRemainder;
    if (l > TransferPacket->Length) {
        l = TransferPacket->Length;
    }
    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl), l);

    p->Length = l;
    p->Offset = o;
    p->CompletionRoutine = StripeWpSequentialTransferCompletionRoutine;
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->MasterPacket = TransferPacket;
    p->StripeWithParity = this;
    p->WhichMember = whichMember;
    p->SavedCompletionRoutine = StripeWpSequentialTransferCompletionRoutine;
    p->OneReadFailed = FALSE;

    if (p->ReadPacket) {
        ReadPacket(p);
    } else {
        WritePacket(p);
    }
}

VOID
STRIPE_WP::ReadPacket(
    IN OUT  PSWP_TP    TransferPacket
    )

/*++

Routine Description:

    This routine takes a packet that is restricted to a single
    stripe region and reads that data.

Arguments:

    TransferPacket  - Supplies the main read packet.

Return Value:

    None.

--*/

{
    PTRANSFER_PACKET    masterPacket = TransferPacket->MasterPacket;
    KIRQL               irql;

    TransferPacket->TargetVolume = GetMemberUnprotected(TransferPacket->WhichMember);
    KeAcquireSpinLock(&_spinLock, &irql);
    if (QueryMemberState(TransferPacket->WhichMember) != FtMemberHealthy ||
        masterPacket->SpecialRead == TP_SPECIAL_READ_SECONDARY) {

        KeReleaseSpinLock(&_spinLock, irql);
        RegeneratePacket(TransferPacket, TRUE);
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        TRANSFER(TransferPacket);
    }
}

VOID
StripeWpWritePhase31(
    IN OUT  PTRANSFER_PACKET    Packet
    )

/*++

Routine Description:

    This is the completion routine for the final data write and the
    final parity write of the write process.  This packet's master packet
    is the original write packet.  This write packet exists because the data
    has to be copied from the original write packet so that parity
    may be correctly computed.

Arguments:

    Packet  - Supplies the update parity packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP       masterPacket;
    PSTRIPE_WP          t;
    KIRQL               irql;
    LONG                count;

    masterPacket = CONTAINING_RECORD(Packet, SWP_WRITE_TP, ParityPacket);
    t = masterPacket->StripeWithParity;

    KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
    count = --masterPacket->RefCount;
    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (!count) {
        t->CompleteWrite(masterPacket);
    }
}

VOID
StripeWpWritePhase30(
    IN OUT  PTRANSFER_PACKET    Packet
    )

/*++

Routine Description:

    This is the completion routine for the final data write and the
    final parity write of the write process.  This packet's master packet
    is the original write packet.  This write packet exists because the data
    has to be copied from the original write packet so that parity
    may be correctly computed.

Arguments:

    Packet  - Supplies the write packet.

Return Value:

    None.

--*/

{
    PSWP_TP         writePacket = (PSWP_TP) Packet;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) writePacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    KIRQL           irql;
    LONG            count;
    BOOLEAN         b;
    PPARITY_TP      parityPacket;

    KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
    count = --masterPacket->RefCount;
    b = (masterPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) ? TRUE : FALSE;
    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (count) {
        if (b) {
            parityPacket = &masterPacket->ParityPacket;
            t->_parityIoManager.UpdateParity(parityPacket);
        }
    } else {
        t->CompleteWrite(masterPacket);
    }
}

VOID
StripeWpWriteRecover(
    IN OUT  PTRANSFER_PACKET    MasterPacket
    )

/*++

Routine Description:

    A bad sector on a read before write caused a promote to all members
    in preparation for a recover.

Arguments:

    TransferPacket  - Supplies the master write packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) MasterPacket;
    PSWP_TP         readPacket = &masterPacket->ReadWritePacket;
    PSTRIPE_WP      t = (PSTRIPE_WP) readPacket->StripeWithParity;

    masterPacket->CompletionRoutine = masterPacket->SavedCompletionRoutine;
    readPacket->CompletionRoutine = StripeWpWritePhase2;
    t->Recover(readPacket, FALSE);
}

VOID
StripeWpWritePhase2(
    IN OUT  PTRANSFER_PACKET    ReadPacket
    )

/*++

Routine Description:

    This routine describes phase 3 of the write process.  The region
    that we are about to write has been preread.  If the read was
    successful then queue write and parity requests.  If the read
    was not successful then propogate the error and cleanup.

Arguments:

    TransferPacket  - Supplies the read packet.

Return Value:

    None.

--*/

{
    PSWP_TP             readPacket = (PSWP_TP) ReadPacket;
    PSTRIPE_WP          t = readPacket->StripeWithParity;
    PSWP_WRITE_TP       masterPacket = (PSWP_WRITE_TP) readPacket->MasterPacket;
    PPARITY_TP          parityPacket = &masterPacket->ParityPacket;
    PSWP_TP             writePacket = &masterPacket->ReadWritePacket;
    NTSTATUS            status;
    KIRQL               irql;
    FT_PARTITION_STATE  state;
    BOOLEAN             b;

    status = readPacket->IoStatus.Status;
    if (!NT_SUCCESS(status)) {

        if (!readPacket->OneReadFailed && status != STATUS_VERIFY_REQUIRED) {

            if (FsRtlIsTotalDeviceFailure(status)) {

                // Orphan this unit and then try again with a regenerate.

                KeAcquireSpinLock(&t->_spinLock, &irql);
                b = t->SetMemberState(readPacket->WhichMember, FtMemberOrphaned);
                KeReleaseSpinLock(&t->_spinLock, irql);

                if (b) {
                    t->PropogateStateChanges(NULL, NULL);
                    t->Notify();
                    FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                                FT_ORPHANING, STATUS_SUCCESS, 6);
                    IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL,
                                                  NULL);
                }

                readPacket->OneReadFailed = TRUE;
                masterPacket->CompletionRoutine = StripeWpWritePhase1;
                t->_overlappedIoManager.PromoteToAllMembers(masterPacket);
                return;
            }

            // Bad sector case.

            readPacket->OneReadFailed = TRUE;
            masterPacket->SavedCompletionRoutine = masterPacket->CompletionRoutine;
            masterPacket->CompletionRoutine = StripeWpWriteRecover;
            t->_overlappedIoManager.PromoteToAllMembers(masterPacket);
            return;
        }

        masterPacket->IoStatus = readPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    KeInitializeSpinLock(&masterPacket->SpinLock);
    masterPacket->IoStatus.Status = STATUS_SUCCESS;
    masterPacket->IoStatus.Information = 0;

    writePacket->Mdl = masterPacket->WriteMdl;
    writePacket->CompletionRoutine = StripeWpWritePhase30;
    writePacket->ReadPacket = FALSE;

    parityPacket->Mdl = masterPacket->ReadAndParityMdl;
    parityPacket->CompletionRoutine = StripeWpWritePhase31;

    if (masterPacket->TargetState != FtMemberOrphaned) {

        RtlCopyMemory(MmGetSystemAddressForMdl(writePacket->Mdl),
                      MmGetSystemAddressForMdl(masterPacket->Mdl),
                      writePacket->Length);

        if (parityPacket->TargetVolume) {

            FtpComputeParity(MmGetSystemAddressForMdl(parityPacket->Mdl),
                             MmGetSystemAddressForMdl(writePacket->Mdl),
                             parityPacket->Length);

            masterPacket->RefCount = 2;

            if (!(masterPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE)) {
                t->_parityIoManager.UpdateParity(parityPacket);
            }

        } else {
            masterPacket->RefCount = 1;
            parityPacket->IoStatus.Status = STATUS_SUCCESS;
            parityPacket->IoStatus.Information = parityPacket->Length;
        }

        TRANSFER(writePacket);

    } else if (parityPacket->TargetVolume) {

        FtpComputeParity(MmGetSystemAddressForMdl(parityPacket->Mdl),
                         MmGetSystemAddressForMdl(masterPacket->Mdl),
                         readPacket->Length);

        masterPacket->RefCount = 1;
        writePacket->IoStatus.Status = STATUS_SUCCESS;
        writePacket->IoStatus.Information = writePacket->Length;

        t->_parityIoManager.UpdateParity(parityPacket);

    } else {

        masterPacket->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        masterPacket->IoStatus.Information = 0;
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
StripeWpWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine describes phase 2 of the write process.  This io
    region has been acquired.  We now send out the read packet and
    wait until it completes.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP   transferPacket = (PSWP_WRITE_TP) TransferPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;
    PSWP_TP         readPacket;
    PPARITY_TP      parityPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    parityPacket = &transferPacket->ParityPacket;
    if (parityPacket->TargetVolume) {
        t->_parityIoManager.StartReadForUpdateParity(
                parityPacket->Offset, parityPacket->Length,
                parityPacket->TargetVolume, parityPacket->Thread,
                parityPacket->IrpFlags);
    }

    readPacket = &transferPacket->ReadWritePacket;
    readPacket->CompletionRoutine = StripeWpWritePhase2;
    if (readPacket->OneReadFailed) {
        t->RegeneratePacket(readPacket, FALSE);
    } else {
        TRANSFER(readPacket);
    }
}

VOID
STRIPE_WP::WritePacket(
    IN OUT  PSWP_WRITE_TP   TransferPacket
    )

/*++

Routine Description:

    This routine takes a packet that is restricted to a single
    stripe region and writes out that data along with the parity.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    USHORT          parityMember;
    KIRQL           irql;
    FT_MEMBER_STATE state, parityState;
    PSWP_TP         readPacket;
    PPARITY_TP      parityPacket;

    parityMember = (USHORT) ((TransferPacket->Offset/_stripeSize)%
                             QueryNumMembers());

    TransferPacket->TargetVolume =
            GetMemberUnprotected(TransferPacket->WhichMember);

    KeAcquireSpinLock(&_spinLock, &irql);
    state = QueryMemberState(TransferPacket->WhichMember);
    parityState = QueryMemberState(parityMember);
    KeReleaseSpinLock(&_spinLock, irql);

    readPacket = &TransferPacket->ReadWritePacket;
    readPacket->Mdl = TransferPacket->ReadAndParityMdl;
    readPacket->Length = TransferPacket->Length;
    readPacket->Offset = TransferPacket->Offset;
    readPacket->TargetVolume = TransferPacket->TargetVolume;
    readPacket->Thread = TransferPacket->Thread;
    readPacket->IrpFlags = TransferPacket->IrpFlags;
    readPacket->ReadPacket = TRUE;
    readPacket->MasterPacket = TransferPacket;
    readPacket->StripeWithParity = this;
    readPacket->WhichMember = TransferPacket->WhichMember;
    readPacket->OneReadFailed = FALSE;

    parityPacket = &TransferPacket->ParityPacket;
    parityPacket->Length = TransferPacket->Length;
    parityPacket->Offset = TransferPacket->Offset;
    if (parityState != FtMemberOrphaned) {
        parityPacket->TargetVolume = GetMemberUnprotected(parityMember);
    } else {
        parityPacket->TargetVolume = NULL;
    }
    parityPacket->Thread = TransferPacket->Thread;
    parityPacket->IrpFlags = TransferPacket->IrpFlags;
    parityPacket->ReadPacket = FALSE;

    TransferPacket->CompletionRoutine = StripeWpWritePhase1;
    TransferPacket->TargetState = state;
    TransferPacket->ParityMember = parityMember;

    if (state == FtMemberHealthy) {
        if (TransferPacket->IrpFlags&SL_FT_SEQUENTIAL_WRITE) {
            _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
        } else {
            _overlappedIoManager.AcquireIoRegion(TransferPacket, FALSE);
        }
    } else {
        readPacket->OneReadFailed = TRUE;
        _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
    }
}

VOID
StripeWpSequentialRegenerateCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a regenerate operation where all of
    the reads are being performed sequentially.

Arguments:

    TransferPacket  - Supplies the completed transfer packet.

Return Value:

    None.

--*/

{
    PSWP_REGENERATE_TP  transferPacket = (PSWP_REGENERATE_TP) TransferPacket;
    PSWP_TP             masterPacket = transferPacket->MasterPacket;
    PSTRIPE_WP          t = masterPacket->StripeWithParity;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;
    ULONG               count;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    packet;
    USHORT              i, n;
    BOOLEAN             b;
    ULONG               parityMember;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = transferPacket->IoStatus;
        }

    } else {

        if (FsRtlIsTotalDeviceFailure(status) &&
            status != STATUS_VERIFY_REQUIRED) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember,
                                  FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 7);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }
        }

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    count = (ULONG) (--masterPacket->RefCount);

    if (masterPacket->Mdl) {
        FtpComputeParity(MmGetSystemAddressForMdl(masterPacket->Mdl),
                         MmGetSystemAddressForMdl(transferPacket->Mdl),
                         masterPacket->Length);
    }

    n = t->QueryNumMembers();

    if (count) {
        transferPacket->WhichMember++;
        if (transferPacket->WhichMember == masterPacket->WhichMember) {
            transferPacket->WhichMember++;
        }
        transferPacket->TargetVolume = t->GetMemberUnprotected(
                                       transferPacket->WhichMember);
        TRANSFER(transferPacket);
        return;
    }

    masterPacket->CompletionRoutine(masterPacket);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (IsListEmpty(&t->_eRegeneratePacketQueue)) {
        t->_eRegeneratePacketInUse = FALSE;
        packet = NULL;
    } else {
        l = RemoveHeadList(&t->_eRegeneratePacketQueue);
        packet = CONTAINING_RECORD(l, SWP_TP, QueueEntry);
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (packet) {
        packet->CompletionRoutine(packet);
    }
}

VOID
StripeWpSequentialEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine after waiting for an emergency
    regenerate buffer.

Arguments:

    TransferPacket  - Supplies the completed transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_REGENERATE_TP  p = t->_eRegeneratePacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    p->Length = transferPacket->Length;
    p->Offset = transferPacket->Offset;
    p->CompletionRoutine = StripeWpSequentialRegenerateCompletion;
    p->TargetVolume = t->GetMemberUnprotected(0);
    p->Thread = transferPacket->Thread;
    p->IrpFlags = transferPacket->IrpFlags;
    p->ReadPacket = TRUE;
    p->MasterPacket = transferPacket;
    p->WhichMember = 0;
    if (transferPacket->TargetVolume == p->TargetVolume) {
        p->WhichMember = 1;
        p->TargetVolume = t->GetMemberUnprotected(1);
    }

    TRANSFER(p);
}

VOID
StripeWpParallelRegenerateCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a regenerate operation where all of
    the reads are being performed in parallel.

Arguments:

    TransferPacket  - Supplies the completed transfer packet.

Return Value:

    None.

--*/

{
    PSWP_REGENERATE_TP  transferPacket = (PSWP_REGENERATE_TP) TransferPacket;
    PSWP_TP             masterPacket = transferPacket->MasterPacket;
    PSTRIPE_WP          t = masterPacket->StripeWithParity;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;
    LONG                count;
    PLIST_ENTRY         l, s;
    PTRANSFER_PACKET    packet;
    PVOID               target, source;
    BOOLEAN             b;
    USHORT              i, n;

    if (NT_SUCCESS(status)) {

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = transferPacket->IoStatus;
        }

    } else {

        if (FsRtlIsTotalDeviceFailure(status) &&
            status != STATUS_VERIFY_REQUIRED) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            b = t->SetMemberState(transferPacket->WhichMember,
                                  FtMemberOrphaned);
            KeReleaseSpinLock(&t->_spinLock, irql);

            if (b) {
                t->PropogateStateChanges(NULL, NULL);
                t->Notify();
                FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                            FT_ORPHANING, STATUS_SUCCESS, 8);
                IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
            }
        }

        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    count = --masterPacket->RefCount;

    KeReleaseSpinLock(&masterPacket->SpinLock, irql);

    if (count) {
        return;
    }

    s = &masterPacket->QueueEntry;
    l = RemoveHeadList(s);
    packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
    if (masterPacket->Mdl) {
        target = MmGetSystemAddressForMdl(masterPacket->Mdl);
        source = MmGetSystemAddressForMdl(packet->Mdl);
        RtlCopyMemory(target, source, masterPacket->Length);
    }
    for (;;) {

        delete packet;

        if (IsListEmpty(s)) {
            break;
        }

        l = RemoveHeadList(s);
        packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
        if (masterPacket->Mdl) {
            source = MmGetSystemAddressForMdl(packet->Mdl);
            FtpComputeParity(target, source, masterPacket->Length);
        }
    }

    masterPacket->CompletionRoutine(masterPacket);
}

VOID
StripeWpRegeneratePacketPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is called after the io regions necessary for a regenerate
    have been allocated.  This routine spawns the reads necessary for
    regeneration.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    USHORT              i, n;
    PSWP_REGENERATE_TP  packet;
    BOOLEAN             sequential;
    PLIST_ENTRY         l, s;
    ULONG               r;
    ULONG               parityMember;
    KIRQL               irql;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    // Determine whether we're going to do this in parallel or
    // sequentially by trying to allocate the memory.

    n = t->QueryNumMembers();
    InitializeListHead(&transferPacket->QueueEntry);
    for (i = 0; i < n; i++) {
        if (i == transferPacket->WhichMember) {
            continue;
        }
        packet = new SWP_REGENERATE_TP;
        if (packet && !packet->AllocateMdl(transferPacket->Length)) {
            delete packet;
            packet = NULL;
        }
        if (!packet) {
            break;
        }
        packet->Length = transferPacket->Length;
        packet->Offset = transferPacket->Offset;
        packet->CompletionRoutine = StripeWpParallelRegenerateCompletion;
        packet->TargetVolume = t->GetMemberUnprotected(i);
        packet->Thread = transferPacket->Thread;
        packet->IrpFlags = transferPacket->IrpFlags;
        packet->ReadPacket = TRUE;
        packet->MasterPacket = transferPacket;
        packet->WhichMember = i;

        InsertTailList(&transferPacket->QueueEntry, &packet->RegenPacketList);
    }
    if (i < n) {
        sequential = TRUE;
        s = &transferPacket->QueueEntry;
        while (!IsListEmpty(s)) {
            l = RemoveHeadList(s);
            packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
            delete packet;
        }
    } else {
        sequential = FALSE;
    }

    KeInitializeSpinLock(&transferPacket->SpinLock);
    transferPacket->IoStatus.Status = STATUS_SUCCESS;
    transferPacket->IoStatus.Information = 0;
    transferPacket->RefCount = n - 1;

    if (sequential) {

        transferPacket->CompletionRoutine = StripeWpSequentialEmergencyCompletion;

        RtlZeroMemory(MmGetSystemAddressForMdl(transferPacket->Mdl),
                      transferPacket->Length);

        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_eRegeneratePacketInUse) {
            InsertTailList(&t->_eRegeneratePacketQueue, &transferPacket->QueueEntry);
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_eRegeneratePacketInUse = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        transferPacket->CompletionRoutine(transferPacket);

    } else {

        s = &transferPacket->QueueEntry;
        l = s->Flink;
        for (;;) {
            packet = CONTAINING_RECORD(l, SWP_REGENERATE_TP, RegenPacketList);
            l = l->Flink;
            if (l == s) {
                TRANSFER(packet);
                break;
            }
            TRANSFER(packet);
        }
    }
}

VOID
STRIPE_WP::RegeneratePacket(
    IN OUT  PSWP_TP TransferPacket,
    IN      BOOLEAN AllocateRegion
    )

/*++

Routine Description:

    This routine regenerate the given transfer packet by reading
    from the other drives and performing the xor.  This routine first
    attempts to do all of the read concurently but if the memory is
    not available then the reads are done sequentially.

Arguments:

    TransferPacket  - Supplies the transfer packet to regenerate.

    AllocateRegion  - Supplies whether or not we need to acquire the
                        io region via the overlapped io manager before
                        starting the regenerate operation.  This should
                        usually be set to TRUE unless the region has
                        already been allocated.

Return Value:

    None.

--*/

{
    USHORT              i, n, parityMember;
    KIRQL               irql;
    PFT_VOLUME          vol;
    BOOLEAN             ok;

    TransferPacket->OneReadFailed = TRUE;

    // First make sure that all of the members are healthy.

    n = QueryNumMembers();
    parityMember = (USHORT) ((TransferPacket->Offset/_stripeSize)%n);
    KeAcquireSpinLock(&_spinLock, &irql);
    if (_state.IsInitializing) {
        if (parityMember == TransferPacket->WhichMember) {
            ok = TRUE;
        } else {
            ok = FALSE;
        }
    } else if (_state.UnhealthyMemberState == FtMemberHealthy ||
               _state.UnhealthyMemberNumber == TransferPacket->WhichMember) {

        ok = TRUE;
    } else {
        ok = FALSE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!ok) {
        TransferPacket->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = StripeWpRegeneratePacketPhase1;

    if (AllocateRegion) {
        _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
    } else {
        TransferPacket->CompletionRoutine(TransferPacket);
    }
}

VOID
StripeWpRecoverPhase8(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a write was done to check for
    data integrity.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    subPacket->ReadPacket = TRUE;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase7(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member after a replace sector was done.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->RecycleRecoverTp(subPacket);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = StripeWpRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = StripeWpRecoverPhase8;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase6(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector replace
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (!NT_SUCCESS(status)) {

        masterPacket->IoStatus.Status = STATUS_FT_READ_RECOVERY_FROM_BACKUP;

        FtpLogError(t->_rootExtension,
                    subPacket->TargetVolume->QueryLogicalDiskId(),
                    FT_SECTOR_FAILURE, status,
                    (ULONG) (subPacket->Offset/t->QuerySectorSize()));

        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->RecycleRecoverTp(subPacket);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->Offset += subPacket->Length;
        subPacket->CompletionRoutine = StripeWpRecoverPhase2;
        subPacket->ReadPacket = TRUE;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // We were able to relocate the bad sector so now do a write and
    // then read to make sure it's ok.

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->CompletionRoutine = StripeWpRecoverPhase7;
    subPacket->ReadPacket = FALSE;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the main member after a successful write to check and
    see if the write was successful.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status) ||
        RtlCompareMemory(MmGetSystemAddressForMdl(subPacket->PartialMdl),
                         MmGetSystemAddressForMdl(subPacket->VerifyMdl),
                         subPacket->Length) != subPacket->Length) {

        subPacket->Mdl = subPacket->PartialMdl;
        subPacket->CompletionRoutine = StripeWpRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector write
    of the main member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        subPacket->CompletionRoutine = StripeWpRecoverPhase6;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    // Write was successful so try a read and then compare.

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = StripeWpRecoverPhase5;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector read
    of the other member.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;
    KIRQL           irql;
    BOOLEAN         b;

    if (!NT_SUCCESS(status)) {
        if (status != STATUS_VERIFY_REQUIRED) {
            status = STATUS_DEVICE_DATA_ERROR;
            FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                        FT_DOUBLE_FAILURE, status,
                        (ULONG) (subPacket->Offset/t->QuerySectorSize()));
        }

        masterPacket->IoStatus.Status = status;
        masterPacket->IoStatus.Information = 0;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    // We have the data required in the subpacket partial mdl.
    // Try writting it back to where the read failed and see
    // if the sector just fixes itself.

    subPacket->CompletionRoutine = StripeWpRecoverPhase4;
    subPacket->ReadPacket = FALSE;
    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a single sector transfer
    that is part of a larger recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;
    KIRQL           irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->OneReadFailed = FALSE;
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (NT_SUCCESS(status)) {
        if (subPacket->Offset + subPacket->Length ==
            masterPacket->Offset + masterPacket->Length) {

            t->RecycleRecoverTp(subPacket);
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }

        subPacket->Offset += subPacket->Length;
        MmPrepareMdlForReuse(subPacket->Mdl);
        IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                          (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                          (ULONG) (subPacket->Offset - masterPacket->Offset),
                          subPacket->Length);

        TRANSFER(subPacket);
        return;
    }

    // This read sector failed from a bad sector error.  Try
    // regenerating the data from the other members.

    subPacket->CompletionRoutine = StripeWpRecoverPhase3;
    t->RegeneratePacket(subPacket, FALSE);
}

VOID
StripeWpRecoverEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP     subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
StripeWpRecoverPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for an acquire io region
    to a recover operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP     subPacket;
    KIRQL               irql;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;
    transferPacket->IoStatus.Status = STATUS_SUCCESS;
    transferPacket->IoStatus.Information = transferPacket->Length;

    subPacket = new SWP_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(t->QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        if (t->_eRecoverPacketInUse) {
            transferPacket->SavedCompletionRoutine =
                    transferPacket->CompletionRoutine;
            transferPacket->CompletionRoutine = StripeWpRecoverEmergencyCompletion;
            InsertTailList(&t->_eRecoverPacketQueue, &transferPacket->QueueEntry);
            KeReleaseSpinLock(&t->_spinLock, irql);
            return;
        }
        t->_eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);

        subPacket = t->_eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpRecoverPhase2;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = TRUE;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    TRANSFER(subPacket);
}

VOID
STRIPE_WP::Recover(
    IN OUT  PSWP_TP TransferPacket,
    IN      BOOLEAN NeedAcquire
    )

{
    ASSERT(TransferPacket->ReadPacket);
    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = StripeWpRecoverPhase1;

    if (NeedAcquire) {
        _overlappedIoManager.AcquireIoRegion(TransferPacket, TRUE);
    } else {
        TransferPacket->CompletionRoutine(TransferPacket);
    }
}

VOID
StripeWpMaxTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector transfer subordinate
    to a MAX transfer operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;
    PSWP_TP         masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    NTSTATUS        status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        t->RecycleRecoverTp(subPacket);
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    if (subPacket->ReadPacket) {
        t->RegeneratePacket(subPacket, FALSE);
    } else {
        TRANSFER(subPacket);
    }
}

VOID
StripeWpMaxTransferEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a max transfer operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP         transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpMaxTransferCompletionRoutine;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = transferPacket->ReadPacket;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;

    if (subPacket->ReadPacket) {
        t->RegeneratePacket(subPacket, FALSE);
    } else {
        TRANSFER(subPacket);
    }
}

VOID
STRIPE_WP::MaxTransfer(
    IN OUT  PSWP_TP TransferPacket
    )

/*++

Routine Description:

    This routine transfers the maximum possible subset of the given transfer
    by doing it one sector at a time.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket;
    KIRQL           irql;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new SWP_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = StripeWpMaxTransferEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpMaxTransferCompletionRoutine;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = TransferPacket->ReadPacket;
    subPacket->MasterPacket = TransferPacket;
    subPacket->StripeWithParity = this;
    subPacket->WhichMember = TransferPacket->WhichMember;

    if (subPacket->ReadPacket) {
        RegeneratePacket(subPacket, FALSE);
    } else {
        TRANSFER(subPacket);
    }
}

VOID
STRIPE_WP::RecycleRecoverTp(
    IN OUT  PSWP_RECOVER_TP TransferPacket
    )

/*++

Routine Description:

    This routine recycles the given recover transfer packet and services
    the emergency queue if need be.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;

    if (TransferPacket != _eRecoverPacket) {
        delete TransferPacket;
        return;
    }

    MmPrepareMdlForReuse(_eRecoverPacket->PartialMdl);
    KeAcquireSpinLock(&_spinLock, &irql);
    if (IsListEmpty(&_eRecoverPacketQueue)) {
        _eRecoverPacketInUse = FALSE;
        KeReleaseSpinLock(&_spinLock, irql);
        return;
    }
    l = RemoveHeadList(&_eRecoverPacketQueue);
    KeReleaseSpinLock(&_spinLock, irql);
    p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);
    p->CompletionRoutine(p);
    return;
}

class FTP_SWP_STATE_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        FT_COMPLETION_ROUTINE   CompletionRoutine;
        PVOID                   Context;
        PSTRIPE_WP              StripeWp;

};

typedef FTP_SWP_STATE_WORK_ITEM* PFTP_SWP_STATE_WORK_ITEM;

VOID
StripeWpPropogateStateChangesWorker(
    IN  PVOID   Context
    )

/*++

Routine Description:

    This routine is a worker thread routine for propogating state changes.

Arguments:

    Context  - Supplies the context of the worker item

Return Value:

    None.

--*/

{
    PFTP_SWP_STATE_WORK_ITEM            context = (PFTP_SWP_STATE_WORK_ITEM) Context;
    PSTRIPE_WP                          t = context->StripeWp;
    KIRQL                               irql;
    FT_MIRROR_AND_SWP_STATE_INFORMATION state;
    NTSTATUS                            status;

    FtpAcquire(t->_rootExtension);

    KeAcquireSpinLock(&t->_spinLock, &irql);
    RtlCopyMemory(&state, &t->_state, sizeof(state));
    KeReleaseSpinLock(&t->_spinLock, irql);

    status = t->_diskInfoSet->WriteStateInformation(t->QueryLogicalDiskId(),
                                                    &state, sizeof(state));

    FtpRelease(t->_rootExtension);

    if (context->CompletionRoutine) {
        context->CompletionRoutine(context->Context, status);
    }
}

VOID
STRIPE_WP::PropogateStateChanges(
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine propogates the changes in the local memory state to
    the on disk state.

Arguments:

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PFTP_SWP_STATE_WORK_ITEM    workItem;

    workItem = (PFTP_SWP_STATE_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(FTP_SWP_STATE_WORK_ITEM));
    if (!workItem) {
        return;
    }
    ExInitializeWorkItem(workItem, StripeWpPropogateStateChangesWorker,
                         workItem);

    workItem->CompletionRoutine = CompletionRoutine;
    workItem->Context = Context;
    workItem->StripeWp = this;

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
StripeWpCompleteWritePhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for a careful update of the parity block.

Arguments:

    TransferPacket  - Supplies the parity packet.

Return Value:

    None.

--*/

{
    PSWP_TP         transferPacket = (PSWP_TP) TransferPacket;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) transferPacket->MasterPacket;
    NTSTATUS        status = transferPacket->IoStatus.Status;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    KIRQL           irql;
    BOOLEAN         b;

    if (NT_SUCCESS(status)) {
        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = transferPacket->IoStatus;
        }
    } else if (status == STATUS_VERIFY_REQUIRED) {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }

    } else if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&t->_spinLock, &irql);
        b = t->SetMemberState(masterPacket->ParityMember, FtMemberOrphaned);
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (b) {
            t->PropogateStateChanges(NULL, NULL);
            t->Notify();
            FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 9);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

    } else {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    masterPacket->CompletionRoutine(masterPacket);
}

VOID
StripeWpCompleteWritePhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for a recover of the parity block.

Arguments:

    TransferPacket  - Supplies the recover packet.

Return Value:

    None.

--*/

{
    PSWP_TP         recoverPacket = (PSWP_TP) TransferPacket;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) recoverPacket->MasterPacket;
    NTSTATUS        status = recoverPacket->IoStatus.Status;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;
    KIRQL           irql;
    BOOLEAN         b;

    if (status == STATUS_VERIFY_REQUIRED) {
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }

        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&t->_spinLock, &irql);
        b = t->SetMemberState(recoverPacket->WhichMember, FtMemberOrphaned);
        KeReleaseSpinLock(&t->_spinLock, irql);

        if (b) {
            t->PropogateStateChanges(NULL, NULL);
            t->Notify();
            FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                        FT_ORPHANING, STATUS_SUCCESS, 10);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    recoverPacket->CompletionRoutine = StripeWpCompleteWritePhase4;
    t->CarefulUpdate(recoverPacket);
}

VOID
StripeWpCompleteWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for the careful write.

Arguments:

    TransferPacket  - Supplies the write packet.

Return Value:

    None.

--*/

{
    PSWP_TP         writePacket = (PSWP_TP) TransferPacket;
    PSWP_WRITE_TP   masterPacket = (PSWP_WRITE_TP) writePacket->MasterPacket;
    NTSTATUS        status = writePacket->IoStatus.Status;
    PPARITY_TP      parityPacket = &masterPacket->ParityPacket;
    PSTRIPE_WP      t = masterPacket->StripeWithParity;

    if (NT_SUCCESS(status)) {
        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus = writePacket->IoStatus;
        }
    } else {
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
            masterPacket->IoStatus.Information = 0;
        }
    }

    if (!NT_SUCCESS(parityPacket->IoStatus.Status)) {
        writePacket->Mdl = parityPacket->Mdl;
        writePacket->CompletionRoutine = StripeWpCompleteWritePhase3;
        writePacket->TargetVolume = parityPacket->TargetVolume;
        writePacket->ReadPacket = TRUE;
        writePacket->WhichMember = masterPacket->ParityMember;
        t->Recover(writePacket, FALSE);
        return;
    }

    masterPacket->CompletionRoutine(masterPacket);
}

VOID
StripeWpCompleteWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the first phase after a bad sector error during the write
    or update parity phase of a SWP write operation.

Arguments:

    TransferPacket  - Supplies the main write packet.

Return Value:

    None.

--*/

{
    PSWP_WRITE_TP   transferPacket = (PSWP_WRITE_TP) TransferPacket;
    PSWP_TP         writePacket = &transferPacket->ReadWritePacket;
    PPARITY_TP      parityPacket = &transferPacket->ParityPacket;
    PSTRIPE_WP      t = transferPacket->StripeWithParity;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    if (!NT_SUCCESS(writePacket->IoStatus.Status)) {
        writePacket->CompletionRoutine = StripeWpCompleteWritePhase2;
        t->CarefulWrite(writePacket);
        return;
    }

    ASSERT(!NT_SUCCESS(parityPacket->IoStatus.Status));

    writePacket->Mdl = parityPacket->Mdl;
    writePacket->CompletionRoutine = StripeWpCompleteWritePhase3;
    writePacket->TargetVolume = parityPacket->TargetVolume;
    writePacket->ReadPacket = TRUE;
    writePacket->WhichMember = transferPacket->ParityMember;
    t->Recover(writePacket, FALSE);
}

VOID
STRIPE_WP::CompleteWrite(
    IN OUT  PSWP_WRITE_TP   TransferPacket
    )

/*++

Routine Description:

    This routine completes the given write master packets after verifying
    the status of the block write and the parity update.

Arguments:

    TransferPacket  - Supplies a write master packet.

Return Value:

    None.

--*/

{
    PSWP_TP     writePacket = &TransferPacket->ReadWritePacket;
    PPARITY_TP  parityPacket = &TransferPacket->ParityPacket;
    BOOLEAN     doCarefulWrite = FALSE;
    BOOLEAN     doRecover = FALSE;
    NTSTATUS    status;
    KIRQL       irql;
    BOOLEAN     b;


    // Check on the write status.

    status = writePacket->IoStatus.Status;
    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus = writePacket->IoStatus;
        }

    } else if (status == STATUS_VERIFY_REQUIRED) {

        if (FtpIsWorseStatus(status, TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus.Status = status;
            TransferPacket->IoStatus.Information = 0;
        }

    } else if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&_spinLock, &irql);
        b = SetMemberState(writePacket->WhichMember, FtMemberOrphaned);
        KeReleaseSpinLock(&_spinLock, irql);

        if (b) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_ORPHANING,
                        STATUS_SUCCESS, 11);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

    } else {
        doCarefulWrite = TRUE;
    }


    // Check on the update parity status.

    status = parityPacket->IoStatus.Status;
    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus = parityPacket->IoStatus;
        }

    } else if (status == STATUS_VERIFY_REQUIRED) {

        if (FtpIsWorseStatus(status, TransferPacket->IoStatus.Status)) {
            TransferPacket->IoStatus.Status = status;
            TransferPacket->IoStatus.Information = 0;
        }

    } else if (FsRtlIsTotalDeviceFailure(status)) {

        KeAcquireSpinLock(&_spinLock, &irql);
        b = SetMemberState(TransferPacket->ParityMember, FtMemberOrphaned);
        KeReleaseSpinLock(&_spinLock, irql);

        if (b) {
            PropogateStateChanges(NULL, NULL);
            Notify();
            FtpLogError(_rootExtension, QueryLogicalDiskId(), FT_ORPHANING,
                        STATUS_SUCCESS, 12);
            IoRaiseInformationalHardError(STATUS_FT_ORPHANING, NULL, NULL);
        }

    } else {

        // Bad sector case.

        if (parityPacket->ReadPacket) { // Bad sector on read?
            doRecover = TRUE;
        } else {
            if (FtpIsWorseStatus(status, TransferPacket->IoStatus.Status)) {
                TransferPacket->IoStatus.Status = status;
                TransferPacket->IoStatus.Information = 0;
            }
        }
    }


    // Complete the request if no bad sector handling is required.

    if (!doCarefulWrite && !doRecover) {
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }


    // Handling for bad sectors is required.

    if (!doCarefulWrite) {
        writePacket->IoStatus.Status = STATUS_SUCCESS;
    }

    if (!doRecover) {
        parityPacket->IoStatus.Status = STATUS_SUCCESS;
    }

    TransferPacket->SavedCompletionRoutine = TransferPacket->CompletionRoutine;
    TransferPacket->CompletionRoutine = StripeWpCompleteWritePhase1;
    _overlappedIoManager.PromoteToAllMembers(TransferPacket);
}

VOID
StripeWpCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a sector replacement
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket = (PSWP_RECOVER_TP) TransferPacket;

    subPacket->CompletionRoutine = StripeWpCarefulWritePhase1;
    TRANSFER(subPacket);
}

VOID
StripeWpCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a first attempt of a single sector write
    for a careful write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP     subPacket = (PSWP_RECOVER_TP) TransferPacket;
    NTSTATUS            status = subPacket->IoStatus.Status;
    PSWP_TP             masterPacket = (PSWP_TP) subPacket->MasterPacket;
    PSTRIPE_WP          t = subPacket->StripeWithParity;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(subPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        if (!subPacket->OneReadFailed) {
            subPacket->CompletionRoutine = StripeWpCarefulWritePhase2;
            subPacket->OneReadFailed = TRUE;
            subPacket->TargetVolume->ReplaceBadSector(subPacket);
            return;
        }

        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(subPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
StripeWpCarefulWriteEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a careful write operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP             transferPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP          t = transferPacket->StripeWithParity;
    PSWP_RECOVER_TP     subPacket = t->_eRecoverPacket;

    transferPacket->CompletionRoutine = transferPacket->SavedCompletionRoutine;

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(transferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(transferPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = transferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulWritePhase1;
    subPacket->TargetVolume = transferPacket->TargetVolume;
    subPacket->Thread = transferPacket->Thread;
    subPacket->IrpFlags = transferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = transferPacket;
    subPacket->StripeWithParity = t;
    subPacket->WhichMember = transferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
STRIPE_WP::CarefulWrite(
    IN OUT  PSWP_TP TransferPacket
    )

/*++

Routine Description:

    This routine writes the given transfer packet one sector at a time.

Arguments:

    TransferPacket  - Supplies a write packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP subPacket;
    KIRQL           irql;

    ASSERT(!TransferPacket->ReadPacket);

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new SWP_RECOVER_TP;
    if (subPacket && !subPacket->AllocateMdls(QuerySectorSize())) {
        delete subPacket;
        subPacket = NULL;
    }
    if (!subPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            TransferPacket->SavedCompletionRoutine =
                    TransferPacket->CompletionRoutine;
            TransferPacket->CompletionRoutine = StripeWpCarefulWriteEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        subPacket = _eRecoverPacket;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = TransferPacket;
    subPacket->StripeWithParity = this;
    subPacket->WhichMember = TransferPacket->WhichMember;
    subPacket->OneReadFailed = FALSE;

    TRANSFER(subPacket);
}

VOID
StripeWpCarefulUpdateCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine a single sector update parity
    for a careful update operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PPARITY_TP      subPacket = (PPARITY_TP) TransferPacket;
    NTSTATUS        status = subPacket->IoStatus.Status;
    PSWP_RECOVER_TP rPacket;
    PSWP_TP         masterPacket;
    PSTRIPE_WP      t;

    rPacket = CONTAINING_RECORD(subPacket, SWP_RECOVER_TP, ParityPacket);
    masterPacket = (PSWP_TP) rPacket->MasterPacket;
    t = masterPacket->StripeWithParity;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(rPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
    }

    if (masterPacket->Offset + masterPacket->Length ==
        subPacket->Offset + subPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);
        t->RecycleRecoverTp(rPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    t->_parityIoManager.UpdateParity(subPacket);
}

VOID
StripeWpCarefulUpdateEmergencyCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion for use of the emergency recover packet
    in a careful udpate operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PSWP_TP         parityPacket = (PSWP_TP) TransferPacket;
    PSTRIPE_WP      t = parityPacket->StripeWithParity;
    PSWP_RECOVER_TP rPacket = t->_eRecoverPacket;
    PPARITY_TP      subPacket = &rPacket->ParityPacket;

    parityPacket->CompletionRoutine = parityPacket->SavedCompletionRoutine;

    rPacket->MasterPacket = parityPacket;
    rPacket->StripeWithParity = t;
    rPacket->WhichMember = parityPacket->WhichMember;

    subPacket = &rPacket->ParityPacket;

    subPacket->Mdl = rPacket->PartialMdl;
    IoBuildPartialMdl(parityPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(parityPacket->Mdl),
                      t->QuerySectorSize());

    subPacket->Length = t->QuerySectorSize();
    subPacket->Offset = parityPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulUpdateCompletion;
    subPacket->TargetVolume = parityPacket->TargetVolume;
    subPacket->Thread = parityPacket->Thread;
    subPacket->IrpFlags = parityPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;

    t->_parityIoManager.UpdateParity(subPacket);
}

VOID
STRIPE_WP::CarefulUpdate(
    IN OUT  PSWP_TP ParityPacket
    )

/*++

Routine Description:

    This routine updates the given parity block one sector at a time.

Arguments:

    ParityPacket    - Supplies an update parity packet.

Return Value:

    None.

--*/

{
    PSWP_RECOVER_TP rPacket;
    KIRQL           irql;
    PPARITY_TP      subPacket;

    ParityPacket->IoStatus.Status = STATUS_SUCCESS;
    ParityPacket->IoStatus.Information = ParityPacket->Length;

    rPacket = new SWP_RECOVER_TP;
    if (rPacket && !rPacket->AllocateMdls(QuerySectorSize())) {
        delete rPacket;
        rPacket = NULL;
    }
    if (!rPacket) {
        KeAcquireSpinLock(&_spinLock, &irql);
        if (_eRecoverPacketInUse) {
            ParityPacket->SavedCompletionRoutine =
                    ParityPacket->CompletionRoutine;
            ParityPacket->CompletionRoutine =
                    StripeWpCarefulUpdateEmergencyCompletion;
            InsertTailList(&_eRecoverPacketQueue, &ParityPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _eRecoverPacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        rPacket = _eRecoverPacket;
    }

    rPacket->MasterPacket = ParityPacket;
    rPacket->StripeWithParity = this;
    rPacket->WhichMember = ParityPacket->WhichMember;

    subPacket = &rPacket->ParityPacket;

    subPacket->Mdl = rPacket->PartialMdl;
    IoBuildPartialMdl(ParityPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(ParityPacket->Mdl),
                      QuerySectorSize());

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = ParityPacket->Offset;
    subPacket->CompletionRoutine = StripeWpCarefulUpdateCompletion;
    subPacket->TargetVolume = ParityPacket->TargetVolume;
    subPacket->Thread = ParityPacket->Thread;
    subPacket->IrpFlags = ParityPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;

    _parityIoManager.UpdateParity(subPacket);
}

VOID
STRIPE_WP::ModifyStateForUser(
    IN OUT  PVOID   State
    )

/*++

Routine Description:

    This routine modifies the state for the user to see, possibly adding
    non-persistant state different than what is stored on disk.

Arguments:

    State   - Supplies and returns the state for the logical disk.

Return Value:

    None.

--*/

{
    KIRQL                                   irql;
    BOOLEAN                                 isDirty;
    PFT_MIRROR_AND_SWP_STATE_INFORMATION    state;

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk && !_stopSyncs) {
        isDirty = FALSE;
    } else {
        isDirty = TRUE;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    if (!isDirty) {
        return;
    }

    state = (PFT_MIRROR_AND_SWP_STATE_INFORMATION) State;
    if (state->UnhealthyMemberState == FtMemberHealthy) {
        state->IsInitializing = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\redist.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    redist.cxx

Abstract:

    This module contains the code specific to redistributions for the fault
    tolerance driver.

Author:

    Norbert Kusters      6-Feb-1997

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

class PROPOGATE_CHANGES_WORK_ITEM : public WORK_QUEUE_ITEM {

    public:

        PREDISTRIBUTION         Redistribution;
        FT_COMPLETION_ROUTINE   CompletionRoutine;
        PVOID                   Context;

};

typedef PROPOGATE_CHANGES_WORK_ITEM *PPROPOGATE_CHANGES_WORK_ITEM;

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
REDISTRIBUTION::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type REDISTRIBUTION.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN                                         oneGood;
    USHORT                                          i;
    NTSTATUS                                        status;
    PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION    configInfo;
    LONGLONG                                        firstRowSize;
    LONGLONG                                        secondRowSize;
    LONGLONG                                        numRows;
    LONGLONG                                        tmpNumRows;

    if (ArraySize != 2) {
        return STATUS_INVALID_PARAMETER;
    }

    oneGood = FALSE;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            oneGood = TRUE;
        }
    }

    if (!oneGood) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    configInfo = (PFT_REDISTRIBUTION_CONFIGURATION_INFORMATION) ConfigInfo;
    _stripeSize = configInfo->StripeSize;
    if (_stripeSize < QuerySectorSize()) {
        return STATUS_INVALID_PARAMETER;
    }
    for (i = 0; _stripeSize%2 == 0; i++) {
        _stripeSize /= 2;
    }
    if (_stripeSize != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    _stripeSize = configInfo->StripeSize;    
    
    if( !configInfo->FirstMemberWidth || !configInfo->SecondMemberWidth) {
        return STATUS_INVALID_PARAMETER;
    }
    _firstWidth = configInfo->FirstMemberWidth;
    _totalWidth = _firstWidth + configInfo->SecondMemberWidth;
    
    if (VolumeArray[0]) {
        _firstSize = VolumeArray[0]->QueryVolumeSize();
    } else {
        _firstSize = 0;
    }

    if (_firstSize && VolumeArray[1]) {
        firstRowSize = _firstWidth*_stripeSize;
        numRows = _firstSize/firstRowSize;
        secondRowSize = configInfo->SecondMemberWidth*_stripeSize;
        tmpNumRows = VolumeArray[1]->QueryVolumeSize()/secondRowSize;
        if (tmpNumRows < numRows) {
            numRows = tmpNumRows;
        }
        _totalSize = numRows*_totalWidth*_stripeSize;
        if (_totalSize < _firstSize) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        _totalSize = 0;
    }
    _syncOk = TRUE;
    _stopSyncs = FALSE;

    RtlCopyMemory(&_state, StateInfo, sizeof(_state));

    if (_state.BytesRedistributed < _firstSize) {
        _redistributionComplete = FALSE;
    } else {
        _redistributionComplete = TRUE;
    }

    status = _overlappedIoManager.Initialize(0);

    return status;
}

FT_LOGICAL_DISK_TYPE
REDISTRIBUTION::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtRedistribution;
}

NTSTATUS
REDISTRIBUTION::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    NTSTATUS    status;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMemberUnprotected(i);
        if (!vol) {
            *IsIoOk = FALSE;
            return STATUS_SUCCESS;
        }
        status = vol->CheckIo(IsIoOk);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!(*IsIoOk)) {
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

REDISTRIBUTION::~REDISTRIBUTION(
    )

{
}

VOID
RedistributionTwoPartCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine is the completion of a two part operation.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      transferPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_LOCK_TP lockPacket = (PREDISTRIBUTION_LOCK_TP) transferPacket->MasterPacket;
    PTRANSFER_PACKET        masterPacket = lockPacket->MasterPacket;
    NTSTATUS                status = transferPacket->IoStatus.Status;
    KIRQL                   irql;
    LONG                    count;

    KeAcquireSpinLock(&lockPacket->SpinLock, &irql);

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(lockPacket->IoStatus.Status)) {
            lockPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (FtpIsWorseStatus(status, lockPacket->IoStatus.Status)) {
            lockPacket->IoStatus.Status = status;
        }
    }

    count = --lockPacket->RefCount;

    KeReleaseSpinLock(&lockPacket->SpinLock, irql);

    delete transferPacket;

    if (!count) {
        masterPacket->IoStatus = lockPacket->IoStatus;
        delete lockPacket;
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
RedistributionRegionLockCompletion(
    IN OUT  PTRANSFER_PACKET    LockPacket
    )

/*++

Routine Description:

    This routine is the completion of a region lock operation.

Arguments:

    LockPacket  - Supplies the lock packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP lockPacket = (PREDISTRIBUTION_LOCK_TP) LockPacket;
    PREDISTRIBUTION         t = lockPacket->Redistribution;
    PTRANSFER_PACKET        masterPacket = lockPacket->MasterPacket;
    KIRQL                   irql;
    LONGLONG                bytesRedistributed;
    LONGLONG                redistOffset, regularOffset;
    ULONG                   redistLength, regularLength;
    PREDISTRIBUTION_TP      redistPacket, regularPacket;
    PCHAR                   vp;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    bytesRedistributed = t->_state.BytesRedistributed;
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (lockPacket->Offset < bytesRedistributed) {
        redistOffset = lockPacket->Offset;
        redistLength = lockPacket->Length;
        if (redistOffset + redistLength > bytesRedistributed) {
            redistLength = (ULONG) (bytesRedistributed - redistOffset);
        }
    } else {
        redistLength = 0;
    }

    if (redistLength < lockPacket->Length) {
        regularLength = lockPacket->Length - redistLength;
        regularOffset = lockPacket->Offset + redistLength;
    } else {
        regularLength = 0;
    }

    KeInitializeSpinLock(&lockPacket->SpinLock);
    lockPacket->IoStatus.Status = STATUS_SUCCESS;
    lockPacket->IoStatus.Information = 0;
    lockPacket->RefCount = 0;

    if (lockPacket->Mdl && redistLength && regularLength) {
        vp = (PCHAR) MmGetMdlVirtualAddress(lockPacket->Mdl);
    }

    if (redistLength) {
        lockPacket->RefCount++;
        redistPacket = new REDISTRIBUTION_TP;
        if (!redistPacket) {
            delete lockPacket;
            masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            masterPacket->IoStatus.Information = 0;
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }
        if (regularLength) {
            if (lockPacket->Mdl) {
                if (redistPacket->AllocateMdl(vp, redistLength)) {
                    IoBuildPartialMdl(lockPacket->Mdl, redistPacket->Mdl,
                                      vp, redistLength);
                } else {
                    delete redistPacket;
                    delete lockPacket;
                    masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    masterPacket->IoStatus.Information = 0;
                    masterPacket->CompletionRoutine(masterPacket);
                    return;
                }
            } else {
                redistPacket->Mdl = lockPacket->Mdl;
            }
        } else {
            redistPacket->Mdl = lockPacket->Mdl;
        }
        redistPacket->Length = redistLength;
        redistPacket->Offset = redistOffset;
        redistPacket->CompletionRoutine = RedistributionTwoPartCompletionRoutine;
        redistPacket->TargetVolume = t;
        redistPacket->Thread = lockPacket->Thread;
        redistPacket->IrpFlags = lockPacket->IrpFlags;
        redistPacket->ReadPacket = lockPacket->ReadPacket;
        redistPacket->MasterPacket = lockPacket;
        redistPacket->Redistribution = t;
        redistPacket->WhichMember = 0;
    }

    if (regularLength) {
        lockPacket->RefCount++;
        regularPacket = new REDISTRIBUTION_TP;
        if (!regularPacket) {
            if (redistLength) {
                delete redistPacket;
            }
            delete lockPacket;
            masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            masterPacket->IoStatus.Information = 0;
            masterPacket->CompletionRoutine(masterPacket);
            return;
        }
        if (redistLength) {
            if (lockPacket->Mdl) {
                if (regularPacket->AllocateMdl(vp, regularLength)) {
                    IoBuildPartialMdl(lockPacket->Mdl, regularPacket->Mdl,
                                      vp, regularLength);
                } else {
                    if (redistLength) {
                        delete redistPacket;
                    }
                    delete regularPacket;
                    delete lockPacket;
                    masterPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    masterPacket->IoStatus.Information = 0;
                    masterPacket->CompletionRoutine(masterPacket);
                    return;
                }
            } else {
                regularPacket->Mdl = lockPacket->Mdl;
            }
        } else {
            regularPacket->Mdl = lockPacket->Mdl;
        }
        regularPacket->Length = regularLength;
        regularPacket->Offset = regularOffset;
        regularPacket->CompletionRoutine = RedistributionTwoPartCompletionRoutine;
        regularPacket->TargetVolume = t->GetMemberUnprotected(0);
        regularPacket->Thread = lockPacket->Thread;
        regularPacket->IrpFlags = lockPacket->IrpFlags;
        regularPacket->ReadPacket = lockPacket->ReadPacket;
        regularPacket->MasterPacket = lockPacket;
        regularPacket->Redistribution = t;
        regularPacket->WhichMember = 0;
    }

    if (redistLength) {
        t->RedistributeTransfer(redistPacket);
    }

    if (regularLength) {
        TRANSFER(regularPacket);
    }
}

VOID
REDISTRIBUTION::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for REDISTRIBUTION type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP lockPacket;

    if (!_redistributionComplete) {
        if (TransferPacket->Offset + TransferPacket->Length > _firstSize) {
            TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        lockPacket = new REDISTRIBUTION_LOCK_TP;
        if (!lockPacket) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }
        lockPacket->Mdl = TransferPacket->Mdl;
        lockPacket->Length = TransferPacket->Length;
        lockPacket->Offset = TransferPacket->Offset;
        lockPacket->CompletionRoutine = RedistributionRegionLockCompletion;
        lockPacket->TargetVolume = TransferPacket->TargetVolume;
        lockPacket->Thread = TransferPacket->Thread;
        lockPacket->IrpFlags = TransferPacket->IrpFlags;
        lockPacket->ReadPacket = TransferPacket->ReadPacket;
        lockPacket->MasterPacket = TransferPacket;
        lockPacket->Redistribution = this;

        _overlappedIoManager.AcquireIoRegion(lockPacket, TRUE);
        return;
    }

    if (TransferPacket->Offset + TransferPacket->Length > _totalSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    RedistributeTransfer(TransferPacket);
}

VOID
RedistributionReplaceCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a replace request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP transferPacket = (PREDISTRIBUTION_LOCK_TP) TransferPacket;
    PTRANSFER_PACKET        masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
RedistributionLockReplaceCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a lock request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP transferPacket = (PREDISTRIBUTION_LOCK_TP) TransferPacket;
    PREDISTRIBUTION         t = transferPacket->Redistribution;
    KIRQL                   irql;
    LONGLONG                bytesRedistributed;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    bytesRedistributed = t->_state.BytesRedistributed;
    KeReleaseSpinLock(&t->_spinLock, irql);

    transferPacket->CompletionRoutine = RedistributionReplaceCompletion;
    if (transferPacket->Offset < bytesRedistributed) {
        t->RedistributeReplaceBadSector(transferPacket);
    } else {
        transferPacket->TargetVolume = t->GetMemberUnprotected(0);
        transferPacket->TargetVolume->ReplaceBadSector(transferPacket);
    }
}

VOID
REDISTRIBUTION::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by routing
    the request to the appropriate sub-volume.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_LOCK_TP lockPacket;

    if (!_redistributionComplete) {
        if (TransferPacket->Offset + TransferPacket->Length > _firstSize) {
            TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        lockPacket = new REDISTRIBUTION_LOCK_TP;
        if (!lockPacket) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        lockPacket->Mdl = TransferPacket->Mdl;
        lockPacket->Length = TransferPacket->Length;
        lockPacket->Offset = TransferPacket->Offset;
        lockPacket->CompletionRoutine = RedistributionLockReplaceCompletion;
        lockPacket->TargetVolume = TransferPacket->TargetVolume;
        lockPacket->Thread = TransferPacket->Thread;
        lockPacket->IrpFlags = TransferPacket->IrpFlags;
        lockPacket->ReadPacket = TransferPacket->ReadPacket;
        lockPacket->MasterPacket = TransferPacket;
        lockPacket->Redistribution = this;

        _overlappedIoManager.AcquireIoRegion(lockPacket, TRUE);
        return;
    }

    if (TransferPacket->Offset + TransferPacket->Length > _totalSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    RedistributeReplaceBadSector(TransferPacket);
}

VOID
RedistributionCompositeVolumeCompletionRoutine(
    IN  PVOID       Context,
    IN  NTSTATUS    Status
    )

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    KIRQL                           irql;
    LONG                            count;

    context = (PFT_COMPLETION_ROUTINE_CONTEXT) Context;

    KeAcquireSpinLock(&context->SpinLock, &irql);
    if (!NT_SUCCESS(Status) && FtpIsWorseStatus(Status, context->Status)) {
        context->Status = Status;
    }
    count = --context->RefCount;
    KeReleaseSpinLock(&context->SpinLock, irql);

    if (!count) {
        context->CompletionRoutine(context->Context, STATUS_SUCCESS);
        ExFreePool(context);
    }
}

VOID
RedistributionSyncPhase6(
    IN OUT  PVOID       SyncPacket,
    IN      NTSTATUS    Status
    )

/*++

Routine Description:

    This is the completion routine for the update state part of a sync.

Arguments:

    SyncPacket  - Supplies the transfer packet.

    Status      - Supplies the status.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) SyncPacket;
    PREDISTRIBUTION_TP      ioPacket = &syncPacket->IoPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    KIRQL                   irql;
    BOOLEAN                 allDone;

    if (!NT_SUCCESS(Status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_state.BytesRedistributed -= ioPacket->Length;
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        t->_overlappedIoManager.ReleaseIoRegion(syncPacket);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       STATUS_SUCCESS);
        delete syncPacket;
        return;
    }

    if (t->_state.BytesRedistributed == t->_firstSize) {
        t->_redistributionComplete = TRUE;
        allDone = TRUE;
    } else {
        allDone = FALSE;
    }
    t->_overlappedIoManager.ReleaseIoRegion(syncPacket);

    if (allDone) {
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       STATUS_SUCCESS);
        delete syncPacket;
        return;
    }

    syncPacket->Offset = t->_state.BytesRedistributed;

    t->_overlappedIoManager.AcquireIoRegion(syncPacket, TRUE);
}

VOID
RedistributionSyncPhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the write verify part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    KIRQL                   irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context, status);
        delete syncPacket;
        FtpLogError(t->_rootExtension, t->QueryLogicalDiskId(),
                    FT_REDISTRIBUTION_ERROR, status, 0);
        return;
    }

    KeAcquireSpinLock(&t->_spinLock, &irql);
    t->_state.BytesRedistributed += ioPacket->Length;
    KeReleaseSpinLock(&t->_spinLock, irql);

    t->PropogateStateChanges(RedistributionSyncPhase6, syncPacket);
}

VOID
RedistributionSyncPhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the verify write part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    KIRQL                   irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        ioPacket->CompletionRoutine = RedistributionSyncPhase5;
        t->CarefulWrite(ioPacket);
        return;
    }

    KeAcquireSpinLock(&t->_spinLock, &irql);
    t->_state.BytesRedistributed += ioPacket->Length;
    KeReleaseSpinLock(&t->_spinLock, irql);

    t->PropogateStateChanges(RedistributionSyncPhase6, syncPacket);
}

VOID
RedistributionSyncPhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the initial write part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    KIRQL                   irql;

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        ioPacket->CompletionRoutine = RedistributionSyncPhase5;
        t->CarefulWrite(ioPacket);
        return;
    }

    ioPacket->CompletionRoutine = RedistributionSyncPhase4;
    t->VerifyWrite(ioPacket);
}

VOID
RedistributionSyncPhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the read part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP      ioPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) ioPacket->MasterPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    NTSTATUS                status = ioPacket->IoStatus.Status;
    LONGLONG                rowSize, rowNum, rowOffset, firstSize;
    KIRQL                   irql;

    KeAcquireSpinLock(&t->_spinLock, &irql);
    if (t->_stopSyncs) {
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       STATUS_SUCCESS);
        delete syncPacket;
        return;
    }
    KeReleaseSpinLock(&t->_spinLock, irql);

    if (FsRtlIsTotalDeviceFailure(status)) {
        KeAcquireSpinLock(&t->_spinLock, &irql);
        t->_syncOk = TRUE;
        KeReleaseSpinLock(&t->_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(syncPacket->Context,
                                                       status);
        delete syncPacket;
        return;
    }

    if (!NT_SUCCESS(status)) {
        t->MaxTransfer(ioPacket);
        return;
    }

    rowSize = t->_totalWidth*t->_stripeSize;
    rowNum = ioPacket->Offset/rowSize;
    rowOffset = ioPacket->Offset%rowSize;
    firstSize = t->_firstWidth*t->_stripeSize;

    ioPacket->CompletionRoutine = RedistributionSyncPhase3;
    ioPacket->ReadPacket = FALSE;

    if (rowOffset < firstSize) {
        ioPacket->Offset = rowNum*firstSize + rowOffset;
    } else {
        ioPacket->Offset = rowNum*(rowSize - firstSize) + rowOffset - firstSize;
        ioPacket->TargetVolume = t->GetMemberUnprotected(1);
        ioPacket->WhichMember = 1;
    }

    TRANSFER(ioPacket);
}

VOID
RedistributionSyncPhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for the lock part of a sync.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_SYNC_TP syncPacket = (PREDISTRIBUTION_SYNC_TP) TransferPacket;
    PREDISTRIBUTION         t = syncPacket->Redistribution;
    PREDISTRIBUTION_TP      packet = &syncPacket->IoPacket;

    packet->Offset = t->_state.BytesRedistributed;
    if (packet->Offset + packet->Length > t->_firstSize) {
        packet->Length = (ULONG) (t->_firstSize - packet->Offset);
    }

    packet->CompletionRoutine = RedistributionSyncPhase2;
    packet->TargetVolume = t->GetMemberUnprotected(0);
    packet->Thread = PsGetCurrentThread();
    packet->ReadPacket = TRUE;
    packet->WhichMember = 0;

    TRANSFER(packet);
}

VOID
REDISTRIBUTION::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine starts off the redistribution of the data.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  context;
    PREDISTRIBUTION_SYNC_TP         syncPacket;
    KIRQL                           irql;
    PREDISTRIBUTION_TP              packet;

    if (_redistributionComplete) {
        COMPOSITE_FT_VOLUME::StartSyncOperations(RegenerateOrphans,
                                                 CompletionRoutine, Context);
        return;
    }

    context = (PFT_COMPLETION_ROUTINE_CONTEXT)
              ExAllocatePool(NonPagedPool,
                             sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!context) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    syncPacket = new REDISTRIBUTION_SYNC_TP;
    if (!syncPacket) {
        ExFreePool(context);
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    if (!syncPacket->IoPacket.AllocateMdl(_stripeSize)) {
        delete syncPacket;
        ExFreePool(context);
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    KeInitializeSpinLock(&context->SpinLock);
    context->Status = STATUS_SUCCESS;
    context->RefCount = 2;
    context->CompletionRoutine = CompletionRoutine;
    context->Context = Context;
    context->ParentVolume = this;

    COMPOSITE_FT_VOLUME::StartSyncOperations(
            RegenerateOrphans, RedistributionCompositeVolumeCompletionRoutine,
            context);

    KeAcquireSpinLock(&_spinLock, &irql);
    if (_syncOk) {
        _syncOk = FALSE;
        _stopSyncs = FALSE;
    } else {
        KeReleaseSpinLock(&_spinLock, irql);
        RedistributionCompositeVolumeCompletionRoutine(context, STATUS_SUCCESS);
        return;
    }
    KeReleaseSpinLock(&_spinLock, irql);

    syncPacket->Mdl = NULL;
    syncPacket->Offset = _state.BytesRedistributed;
    syncPacket->Length = _stripeSize;
    syncPacket->CompletionRoutine = RedistributionSyncPhase1;
    syncPacket->TargetVolume = this;
    syncPacket->Thread = PsGetCurrentThread();
    syncPacket->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    syncPacket->ReadPacket = TRUE;
    syncPacket->Context = context;
    syncPacket->Redistribution = this;

    packet = &syncPacket->IoPacket;
    packet->Length = _stripeSize;
    packet->IrpFlags = SL_OVERRIDE_VERIFY_VOLUME;
    packet->MasterPacket = syncPacket;
    packet->Redistribution = this;

    _overlappedIoManager.AcquireIoRegion(syncPacket, TRUE);
}

VOID
REDISTRIBUTION::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL   irql;

    COMPOSITE_FT_VOLUME::StopSyncOperations();

    KeAcquireSpinLock(&_spinLock, &irql);
    _stopSyncs = TRUE;
    KeReleaseSpinLock(&_spinLock, irql);
}

LONGLONG
REDISTRIBUTION::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _redistributionComplete ? _totalSize : _firstSize;
}

VOID
REDISTRIBUTION::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    LONGLONG    firstRowSize, numRows, secondRowSize, tmpNumRows;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    _firstSize = GetMember(0)->QueryVolumeSize();
    firstRowSize = _firstWidth*_stripeSize;
    numRows = _firstSize/firstRowSize;
    secondRowSize = (_totalWidth - _firstWidth)*_stripeSize;
    tmpNumRows = GetMember(1)->QueryVolumeSize()/secondRowSize;
    if (tmpNumRows < numRows) {
        numRows = tmpNumRows;
    }
    _totalSize = numRows*_totalWidth*_stripeSize;

    if (_state.BytesRedistributed >= _firstSize) {
        _redistributionComplete = TRUE;
    }
}

VOID
REDISTRIBUTION::NewStateArrival(
    IN  PVOID   NewStateInstance
    )

/*++

Routine Description:

    This routine takes the new state instance arrival combined with its
    current state to come up with the new current state for the volume.
    If the two states cannot be reconciled then this routine returns FALSE
    indicating that the volume is invalid and should be broken into its
    constituant parts.

Arguments:

    NewStateInstance    - Supplies the new state instance.

Return Value:

    None.

--*/

{
    BOOLEAN                                 changed = FALSE;
    PFT_REDISTRIBUTION_STATE_INFORMATION    state;

    state = (PFT_REDISTRIBUTION_STATE_INFORMATION) NewStateInstance;
    if (state->BytesRedistributed > _state.BytesRedistributed) {
        _state.BytesRedistributed = state->BytesRedistributed;
        changed = TRUE;
    }

    if (changed) {
        PropogateStateChanges(NULL, NULL);
    }
}

VOID
RedistributionTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for REDISTRIBUTION::RedistributionDispatch.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  transferPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;


    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
        KeReleaseSpinLock(&masterPacket->SpinLock, irql);
    }

    delete transferPacket;

    if (!InterlockedDecrement(&masterPacket->RefCount)) {
        masterPacket->CompletionRoutine(masterPacket);
    }
}

VOID
REDISTRIBUTION::RedistributeTransfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches the given transfer packet using the new
    redistributed data allocation scheme.

Arguments:

    TransferPacket      - Supplies the transfer packet to launch.

Return Value:

    None.

--*/

{
    LONGLONG                begin, end;
    LONGLONG                rowSize, firstSize, rowBegin, rowOffsetBegin, rowEnd, rowOffsetEnd;
    ULONG                   numRequests, i, numRows;
    PCHAR                   vp;
    LIST_ENTRY              q;
    LONGLONG                off, off2;
    ULONG                   len, len2;
    USHORT                  whichMember;
    BOOLEAN                 two;
    PREDISTRIBUTION_TP      p;
    PLIST_ENTRY             l;

    begin = TransferPacket->Offset;
    end = TransferPacket->Offset + TransferPacket->Length;
    rowSize = _totalWidth*_stripeSize;
    rowBegin = begin/rowSize;
    rowOffsetBegin = begin%rowSize;
    rowEnd = end/rowSize;
    rowOffsetEnd = end%rowSize;
    firstSize = _firstWidth*_stripeSize;

    if (TransferPacket->Mdl) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }
    InitializeListHead(&q);
    numRows = (ULONG) (rowEnd - rowBegin + 1);
    numRequests = 0;
    for (i = 0; i < numRows; i++) {

        if (i == 0) {
            if (numRows == 1) {
                if (rowOffsetBegin < firstSize) {
                    if (rowOffsetEnd > firstSize) {
                        two = TRUE;
                        whichMember = 0;
                        off = rowBegin*firstSize + rowOffsetBegin;
                        len = (ULONG) (firstSize - rowOffsetBegin);
                        off2 = rowBegin*(rowSize - firstSize);
                        len2 = (ULONG) (rowOffsetEnd - firstSize);
                    } else {
                        two = FALSE;
                        whichMember = 0;
                        off = rowBegin*firstSize + rowOffsetBegin;
                        len = (ULONG) (rowOffsetEnd - rowOffsetBegin);
                    }
                } else {
                    two = FALSE;
                    whichMember = 1;
                    off = rowBegin*(rowSize - firstSize) + rowOffsetBegin -
                          firstSize;
                    len = (ULONG) (rowOffsetEnd - rowOffsetBegin);
                }
            } else {
                if (rowOffsetBegin < firstSize) {
                    two = TRUE;
                    whichMember = 0;
                    off = rowBegin*firstSize + rowOffsetBegin;
                    len = (ULONG) (firstSize - rowOffsetBegin);
                    off2 = rowBegin*(rowSize - firstSize);
                    len2 = (ULONG) (rowSize - firstSize);
                } else {
                    two = FALSE;
                    whichMember = 1;
                    off = rowBegin*(rowSize - firstSize) + rowOffsetBegin -
                          firstSize;
                    len = (ULONG) (rowSize - rowOffsetBegin);
                }
            }
        } else if (i == numRows - 1) {
            if (!rowOffsetEnd) {
                continue;
            }
            if (rowOffsetEnd > firstSize) {
                two = TRUE;
                whichMember = 0;
                off = rowEnd*firstSize;
                len = (ULONG) firstSize;
                off2 = rowEnd*(rowSize - firstSize);
                len2 = (ULONG) (rowOffsetEnd - firstSize);
            } else {
                two = FALSE;
                whichMember = 0;
                off = rowEnd*firstSize;
                len = (ULONG) rowOffsetEnd;
            }
        } else {
            two = TRUE;
            whichMember = 0;
            len = (ULONG) firstSize;
            len2 = (ULONG) (rowSize - firstSize);
            off = (rowBegin + i)*len;
            off2 = (rowBegin + i)*len2;
        }

        p = new REDISTRIBUTION_TP;
        if (!p) {
            break;
        }
        if (!two && numRows == 1) {
            p->Mdl = TransferPacket->Mdl;
        } else {
            if (TransferPacket->Mdl) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    break;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
            }
        }

        p->Length = len;
        p->Offset = off;
        p->CompletionRoutine = RedistributionTransferCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(whichMember);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->Redistribution = this;
        p->WhichMember = whichMember;

        InsertTailList(&q, &p->QueueEntry);
        numRequests++;

        if (!two) {
            continue;
        }

        p = new REDISTRIBUTION_TP;
        if (!p) {
            break;
        }
        if (TransferPacket->Mdl) {
            if (p->AllocateMdl(vp, len2)) {
                IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len2);
            } else {
                delete p;
                break;
            }
            vp += len2;
        } else {
            p->Mdl = TransferPacket->Mdl;
        }

        p->Length = len2;
        p->Offset = off2;
        p->CompletionRoutine = RedistributionTransferCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(1);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->Redistribution = this;
        p->WhichMember = 1;

        InsertTailList(&q, &p->QueueEntry);
        numRequests++;
    }

    if (i < numRows) {
        while (!IsListEmpty(&q)) {
            l = RemoveHeadList(&q);
            p = CONTAINING_RECORD(l, REDISTRIBUTION_TP, QueueEntry);
            delete p;
        }
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;
    TransferPacket->RefCount = numRequests;

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, REDISTRIBUTION_TP, QueueEntry);
        TRANSFER(p);
    }
}

VOID
RedistributeReplaceBadSectorCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for REDISTRIBUTION::RedistributionReplaceBadSector.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  transferPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
REDISTRIBUTION::RedistributeReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine launches the given transfer packet using the new
    redistributed data allocation scheme.

Arguments:

    TransferPacket      - Supplies the transfer packet to launch.

Return Value:

    None.

--*/

{
    LONGLONG            begin, rowSize, rowBegin, rowOffsetBegin, firstSize, offset;
    USHORT              whichMember;
    PREDISTRIBUTION_TP  p;

    begin = TransferPacket->Offset;
    rowSize = _totalWidth*_stripeSize;
    rowBegin = begin/rowSize;
    rowOffsetBegin = begin%rowSize;
    firstSize = _firstWidth*_stripeSize;

    if (rowOffsetBegin < firstSize) {
        offset = rowBegin*firstSize + rowOffsetBegin;
        whichMember = 0;
    } else {
        offset = rowBegin*(rowSize - firstSize) + rowOffsetBegin - firstSize;
        whichMember = 1;
    }

    p = new REDISTRIBUTION_TP;
    if (!p) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    p->Mdl = TransferPacket->Mdl;
    p->Length = TransferPacket->Length;
    p->Offset = offset;
    p->CompletionRoutine = RedistributeReplaceBadSectorCompletion;
    p->TargetVolume = GetMemberUnprotected(whichMember);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->SpecialRead = TransferPacket->SpecialRead;
    p->MasterPacket = TransferPacket;
    p->Redistribution = this;
    p->WhichMember = whichMember;

    p->TargetVolume->ReplaceBadSector(p);
}

VOID
RedistributionPropogateStateChangesWorker(
    IN  PVOID   WorkItem
    )

/*++

Routine Description:

    This routine is a worker thread routine for propogating state changes.

Arguments:

    Mirror  - Supplies a pointer to the mirror object.

Return Value:

    None.

--*/

{
    PPROPOGATE_CHANGES_WORK_ITEM        workItem = (PPROPOGATE_CHANGES_WORK_ITEM) WorkItem;
    PREDISTRIBUTION                     t = workItem->Redistribution;
    NTSTATUS                            status;
    KIRQL                               irql;
    FT_REDISTRIBUTION_STATE_INFORMATION state;

    status = FtpAcquireWithTimeout(t->_rootExtension);
    if (!NT_SUCCESS(status)) {
        if (workItem->CompletionRoutine) {
            workItem->CompletionRoutine(workItem->Context, status);
        }
        return;
    }

    KeAcquireSpinLock(&t->_spinLock, &irql);
    RtlCopyMemory(&state, &t->_state, sizeof(state));
    KeReleaseSpinLock(&t->_spinLock, irql);

    status = t->_diskInfoSet->WriteStateInformation(t->QueryLogicalDiskId(),
                                                    &state, sizeof(state));

    FtpRelease(t->_rootExtension);

    if (workItem->CompletionRoutine) {
        workItem->CompletionRoutine(workItem->Context, status);
    }
}

VOID
REDISTRIBUTION::PropogateStateChanges(
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine propogates the changes in the local memory state to
    the on disk state.

Arguments:

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context.

Return Value:

    None.

--*/

{
    PPROPOGATE_CHANGES_WORK_ITEM    workItem;

    workItem = (PPROPOGATE_CHANGES_WORK_ITEM)
               ExAllocatePool(NonPagedPool,
                              sizeof(PROPOGATE_CHANGES_WORK_ITEM));
    if (!workItem) {
        return;
    }
    workItem->Redistribution = this;
    workItem->CompletionRoutine = CompletionRoutine;
    workItem->Context = Context;

    ExInitializeWorkItem(workItem, RedistributionPropogateStateChangesWorker,
                         workItem);

    FtpQueueWorkItem(_rootExtension, workItem);
}

VOID
RedistributionMaxTransferCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector transfer subordinate
    to a MAX transfer operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  subPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_TP  masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS            status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
REDISTRIBUTION::MaxTransfer(
    IN OUT  PREDISTRIBUTION_TP  TransferPacket
    )

/*++

Routine Description:

    This routine propogates sector by sector the given transfer packet,
    ignoring errors.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  subPacket;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;

    subPacket = new REDISTRIBUTION_TP;
    if (!subPacket) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = RedistributionMaxTransferCompletionRoutine;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = TransferPacket->ReadPacket;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Redistribution = this;
    subPacket->WhichMember = TransferPacket->WhichMember;

    if (!subPacket->AllocateMdl((PVOID) (PAGE_SIZE - 1), subPacket->Length)) {
        delete subPacket;
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionVerifyWriteCompletion(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a verify write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  verifyPacket = (PREDISTRIBUTION_TP) TransferPacket;
    PREDISTRIBUTION_TP  masterPacket = (PREDISTRIBUTION_TP) verifyPacket->MasterPacket;
    NTSTATUS            status = verifyPacket->IoStatus.Status;
    PVOID               p, q;
    ULONG               l;

    if (!NT_SUCCESS(status)) {
        masterPacket->IoStatus = verifyPacket->IoStatus;
        delete verifyPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    p = MmGetSystemAddressForMdl(verifyPacket->Mdl);
    q = MmGetSystemAddressForMdl(masterPacket->Mdl);
    l = (ULONG)RtlCompareMemory(p, q, verifyPacket->Length);
    if (l != verifyPacket->Length) {
        masterPacket->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;
        masterPacket->IoStatus.Information = 0;
    }

    delete verifyPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
REDISTRIBUTION::VerifyWrite(
    IN OUT  PREDISTRIBUTION_TP  TransferPacket
    )

/*++

Routine Description:

    This routine verifies that the given write was success by reading
    and comparing.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_TP  verifyPacket;

    verifyPacket = new REDISTRIBUTION_TP;
    if (!verifyPacket) {
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    if (!verifyPacket->AllocateMdl(TransferPacket->Length)) {
        delete verifyPacket;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    verifyPacket->Length = TransferPacket->Length;
    verifyPacket->Offset = TransferPacket->Offset;
    verifyPacket->CompletionRoutine = RedistributionVerifyWriteCompletion;
    verifyPacket->TargetVolume = TransferPacket->TargetVolume;
    verifyPacket->Thread = TransferPacket->Thread;
    verifyPacket->IrpFlags = TransferPacket->IrpFlags;
    verifyPacket->ReadPacket = TRUE;
    verifyPacket->MasterPacket = TransferPacket;
    verifyPacket->Redistribution = this;
    verifyPacket->WhichMember = TransferPacket->WhichMember;

    TRANSFER(verifyPacket);
}

VOID
RedistributionCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    );

VOID
RedistributionCarefulWritePhase5(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector read subordinate
    to a carefule write operation after a replace bad sector.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;
    PVOID                   p, q;
    ULONG                   l;

    if (NT_SUCCESS(status)) {
        p = MmGetSystemAddressForMdl(subPacket->PartialMdl);
        q = MmGetSystemAddressForMdl(subPacket->VerifyMdl);
        l = (ULONG)RtlCompareMemory(p, q, subPacket->Length);
    } else {
        l = 0;
    }

    if (l != subPacket->Length) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        delete subPacket;
        masterPacket->IoStatus.Status = STATUS_SUCCESS;
        masterPacket->IoStatus.Information = masterPacket->Length;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase1;
    subPacket->ReadPacket = FALSE;

    subPacket->Mdl = subPacket->PartialMdl;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase4(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector write subordinate
    to a carefule write operation after a sector replace operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;

    if (!NT_SUCCESS(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase5;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase3(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector replace subordinate
    to a carefule write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;

    subPacket->CompletionRoutine = RedistributionCarefulWritePhase4;
    subPacket->ReadPacket = FALSE;

    subPacket->Mdl = subPacket->PartialMdl;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase2(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector read subordinate
    to a carefule write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;
    PVOID                   p, q;
    ULONG                   l;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (NT_SUCCESS(status)) {
        p = MmGetSystemAddressForMdl(subPacket->PartialMdl);
        q = MmGetSystemAddressForMdl(subPacket->VerifyMdl);
        l = (ULONG)RtlCompareMemory(p, q, subPacket->Length);
    } else {
        l = 0;
    }

    if (l != subPacket->Length) {
        subPacket->CompletionRoutine = RedistributionCarefulWritePhase3;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    if (subPacket->Offset + subPacket->Length ==
        masterPacket->Offset + masterPacket->Length) {

        delete subPacket;
        masterPacket->IoStatus.Status = STATUS_SUCCESS;
        masterPacket->IoStatus.Information = masterPacket->Length;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    subPacket->Offset += subPacket->Length;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase1;
    subPacket->ReadPacket = FALSE;

    subPacket->Mdl = subPacket->PartialMdl;
    MmPrepareMdlForReuse(subPacket->Mdl);
    IoBuildPartialMdl(masterPacket->Mdl, subPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (subPacket->Offset - masterPacket->Offset),
                      subPacket->Length);

    TRANSFER(subPacket);
}

VOID
RedistributionCarefulWritePhase1(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a sector write subordinate
    to a carefule write operation.

Arguments:

    TransferPacket  - Supplies the subordinate transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket = (PREDISTRIBUTION_CW_TP) TransferPacket;
    PREDISTRIBUTION_TP      masterPacket = (PREDISTRIBUTION_TP) subPacket->MasterPacket;
    NTSTATUS                status = subPacket->IoStatus.Status;

    if (FsRtlIsTotalDeviceFailure(status)) {
        masterPacket->IoStatus = subPacket->IoStatus;
        delete subPacket;
        masterPacket->CompletionRoutine(masterPacket);
        return;
    }

    if (!NT_SUCCESS(status)) {
        subPacket->CompletionRoutine = RedistributionCarefulWritePhase3;
        subPacket->TargetVolume->ReplaceBadSector(subPacket);
        return;
    }

    subPacket->Mdl = subPacket->VerifyMdl;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase2;
    subPacket->ReadPacket = TRUE;

    TRANSFER(subPacket);
}

VOID
REDISTRIBUTION::CarefulWrite(
    IN OUT  PREDISTRIBUTION_TP  TransferPacket
    )

/*++

Routine Description:

    This routine writes the given packet, sector by sector, replacing
    bad sectors if need be.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PREDISTRIBUTION_CW_TP   subPacket;

    ASSERT(!TransferPacket->ReadPacket);

    subPacket = new REDISTRIBUTION_CW_TP;
    if (!subPacket) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    subPacket->Length = QuerySectorSize();
    subPacket->Offset = TransferPacket->Offset;
    subPacket->CompletionRoutine = RedistributionCarefulWritePhase1;
    subPacket->TargetVolume = TransferPacket->TargetVolume;
    subPacket->Thread = TransferPacket->Thread;
    subPacket->IrpFlags = TransferPacket->IrpFlags;
    subPacket->ReadPacket = FALSE;
    subPacket->MasterPacket = TransferPacket;
    subPacket->Redistribution = TransferPacket->Redistribution;
    subPacket->WhichMember = TransferPacket->WhichMember;

    if (!subPacket->AllocateMdls(subPacket->Length)) {
        delete subPacket;
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    subPacket->Mdl = subPacket->PartialMdl;
    IoBuildPartialMdl(TransferPacket->Mdl, subPacket->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl),
                      subPacket->Length);

    TRANSFER(subPacket);
}

NTSTATUS
REDISTRIBUTION::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, whichMember, whichStripeInSet;
    LONGLONG    whichStripe, whichSet, whichRow; 
    LONGLONG    bytesRedistributed, logicalOffsetInMember;
    PFT_VOLUME  vol;
    KIRQL       irql;

    if (LogicalOffset < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    if (_redistributionComplete) {
        if (_totalSize <= LogicalOffset) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        KeAcquireSpinLock(&_spinLock, &irql);
        bytesRedistributed = _state.BytesRedistributed;
        KeReleaseSpinLock(&_spinLock, irql);
        if (bytesRedistributed <= LogicalOffset) {
            return STATUS_INVALID_PARAMETER;
        }
    }
       
    ASSERT(_stripeSize);
    ASSERT(_totalWidth);

    whichStripe = LogicalOffset/_stripeSize;
    whichSet = whichStripe/_totalWidth;
    whichStripeInSet = (USHORT) (whichStripe%_totalWidth);
    if (whichStripeInSet < _firstWidth) {
        whichMember = 0;
        whichRow = whichSet*_firstWidth + whichStripeInSet;
    } else {
        whichMember = 1;
        whichRow = whichSet*(_totalWidth-_firstWidth) + whichStripeInSet - _firstWidth;
    }

    vol = GetMember(whichMember);
    if (!vol) {
        return STATUS_INVALID_PARAMETER;
    }

    logicalOffsetInMember = whichRow*_stripeSize + LogicalOffset%_stripeSize;
    
    return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
}

NTSTATUS
REDISTRIBUTION::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i, whichStripeInSet;
    LONGLONG    whichStripe, whichSet, whichRow, bytesRedistributed; 
    LONGLONG    logicalOffset, logicalOffsetInMember;
    NTSTATUS    status;
    PFT_VOLUME  vol;
    KIRQL       irql;
    
    n = QueryNumMembers();
    
    ASSERT(n == 2);
    ASSERT(_stripeSize);
    ASSERT(_firstWidth);
    ASSERT(_totalWidth > _firstWidth);

    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            continue;
        }
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);
        if (NT_SUCCESS(status)) {
            whichRow = logicalOffsetInMember/_stripeSize;
            if (i == 0) {
                whichSet = whichRow/_firstWidth; 
                whichStripeInSet = (USHORT) (whichRow%_firstWidth); 
            } else {
                ASSERT(i == 1);
                whichSet = whichRow/(_totalWidth-_firstWidth);
                whichStripeInSet = (USHORT) (whichRow%(_totalWidth-_firstWidth)) + _firstWidth;
            }
            whichStripe = whichSet*_totalWidth + whichStripeInSet;
            logicalOffset = whichStripe*_stripeSize + logicalOffsetInMember%_stripeSize;
            
            if (_redistributionComplete) {
                if (_totalSize <= logicalOffset) {
                    return STATUS_INVALID_PARAMETER;
                }
            } else {
                KeAcquireSpinLock(&_spinLock, &irql);
                bytesRedistributed = _state.BytesRedistributed;
                KeReleaseSpinLock(&_spinLock, irql);
                if (bytesRedistributed <= logicalOffset) {
                    return STATUS_INVALID_PARAMETER;
                }
            }

            *LogicalOffset = logicalOffset;
            return status;
        }        
    }

  return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\volset.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    volset.cxx

Abstract:

    This module contains the code specific to volume sets for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
VOLUME_SET::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PFT_VOLUME*         VolumeArray,
    IN      USHORT              ArraySize,
    IN      PVOID               ConfigInfo,
    IN      PVOID               StateInfo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type VOLUME SET.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    VolumeArray     - Supplies the array of volumes for this volume set.

    ArraySize       - Supplies the number of volumes in the volume array.

    ConfigInfo      - Supplies the configuration information.

    StateInfo       - Supplies the state information.

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN     oneGood;
    USHORT      i;
    NTSTATUS    status;

    oneGood = FALSE;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            oneGood = TRUE;
        }
    }

    if (!oneGood) {
        return STATUS_INVALID_PARAMETER;
    }

    status = COMPOSITE_FT_VOLUME::Initialize(RootExtension, LogicalDiskId,
                                             VolumeArray, ArraySize,
                                             ConfigInfo, StateInfo);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    _volumeSize = 0;
    for (i = 0; i < ArraySize; i++) {
        if (VolumeArray[i]) {
            _volumeSize += VolumeArray[i]->QueryVolumeSize();
        }
    }

    _ePacket = new VOLSET_TP;
    if (_ePacket && !_ePacket->AllocateMdl((PVOID) 1, STRIPE_SIZE)) {
        delete _ePacket;
        _ePacket = NULL;
    }
    if (!_ePacket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    _ePacketInUse = FALSE;
    InitializeListHead(&_ePacketQueue);

    return status;
}

FT_LOGICAL_DISK_TYPE
VOLUME_SET::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtVolumeSet;
}

NTSTATUS
VOLUME_SET::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    logical disk.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;
    NTSTATUS    status;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMemberUnprotected(i);
        if (!vol) {
            *IsIoOk = FALSE;
            return STATUS_SUCCESS;
        }
        status = vol->CheckIo(IsIoOk);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        if (!(*IsIoOk)) {
            return STATUS_SUCCESS;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VOLUME_SET::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    USHORT      n, i;
    PFT_VOLUME  vol;
    LONGLONG    logicalOffsetInMember = LogicalOffset, volumeSize;
    
    if (LogicalOffset < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            return STATUS_INVALID_PARAMETER;
        }
        volumeSize = vol->QueryVolumeSize();
        if (logicalOffsetInMember < volumeSize) {
            return vol->QueryPhysicalOffsets(logicalOffsetInMember, PhysicalOffsets, NumberOfPhysicalOffsets);
        }
        logicalOffsetInMember -= volumeSize;
    }

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
VOLUME_SET::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{    
    USHORT      n, i;
    PFT_VOLUME  vol;
    LONGLONG    memberStartOffset = 0, logicalOffsetInMember;
    NTSTATUS    status;
    
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        if (!vol) {
            return STATUS_INVALID_PARAMETER;
        }
        
        status = vol->QueryLogicalOffset(PhysicalOffset, &logicalOffsetInMember);        
        if (NT_SUCCESS(status)) {
            *LogicalOffset = memberStartOffset + logicalOffsetInMember;
            return status;            
        }
        
        memberStartOffset += vol->QueryVolumeSize();
    }

    return STATUS_INVALID_PARAMETER;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

VOLUME_SET::~VOLUME_SET(
    )

{
    if (_ePacket) {
        delete _ePacket;
        _ePacket = NULL;
    }
}

VOID
VOLUME_SET::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for STRIPE type FT_VOLUME.  Figure out
    which volumes this request needs to be dispatched to.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL       irql;

    if (TransferPacket->Offset + TransferPacket->Length > _volumeSize) {
        TransferPacket->IoStatus.Status = STATUS_INVALID_PARAMETER;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    if (!LaunchParallel(TransferPacket)) {
        if (!TransferPacket->Mdl) {
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        KeAcquireSpinLock(&_spinLock, &irql);
        if (_ePacketInUse) {
            InsertTailList(&_ePacketQueue, &TransferPacket->QueueEntry);
            KeReleaseSpinLock(&_spinLock, irql);
            return;
        }
        _ePacketInUse = TRUE;
        KeReleaseSpinLock(&_spinLock, irql);

        LaunchSequential(TransferPacket);
    }
}

VOID
VolsetReplaceCompletionRoutine(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This is the completion routine for a replace request.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PVOLSET_TP          transferPacket = (PVOLSET_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;

    masterPacket->IoStatus = transferPacket->IoStatus;
    delete transferPacket;
    masterPacket->CompletionRoutine(masterPacket);
}

VOID
VOLUME_SET::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by routing
    the request to the appropriate sub-volume.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    LONGLONG    offset = TransferPacket->Offset;
    USHORT      n, i;
    PVOLSET_TP  p;
    LONGLONG    volumeSize;

    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        volumeSize = GetMemberUnprotected(i)->QueryVolumeSize();
        if (offset < volumeSize) {
            break;
        }
        offset -= volumeSize;
    }

    p = new VOLSET_TP;
    if (!p) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    p->Length = TransferPacket->Length;
    p->Offset = offset;
    p->CompletionRoutine = VolsetReplaceCompletionRoutine;
    p->TargetVolume = GetMemberUnprotected(i);
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->MasterPacket = TransferPacket;
    p->VolumeSet = this;
    p->WhichMember = i;

    p->TargetVolume->ReplaceBadSector(p);
}

LONGLONG
VOLUME_SET::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _volumeSize;
}

VOID
VOLUME_SET::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    USHORT      n, i;
    PFT_VOLUME  vol;

    COMPOSITE_FT_VOLUME::CompleteNotification(IoPending);

    _volumeSize = 0;
    n = QueryNumMembers();
    for (i = 0; i < n; i++) {
        vol = GetMember(i);
        _volumeSize += vol->QueryVolumeSize();
    }
}

VOID
VolsetTransferParallelCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for VOLUME_SET::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PVOLSET_TP          transferPacket = (PVOLSET_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    KIRQL               irql;

    if (!NT_SUCCESS(status)) {
        KeAcquireSpinLock(&masterPacket->SpinLock, &irql);
        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
        KeReleaseSpinLock(&masterPacket->SpinLock, irql);
    }

    delete transferPacket;

    if (!InterlockedDecrement(&masterPacket->RefCount)) {
        masterPacket->CompletionRoutine(masterPacket);
    }
}

BOOLEAN
VOLUME_SET::LaunchParallel(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in parallel accross
    all members.  If memory cannot be allocated to launch this request
    in parallel then a return value of FALSE will be returned.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    USHORT      arraySize, i;
    ULONG       length, len;
    LONGLONG    offset, volumeSize;
    BOOLEAN     multiple;
    PCHAR       vp;
    LIST_ENTRY  q;
    PVOLSET_TP  p;
    PLIST_ENTRY l;

    KeInitializeSpinLock(&TransferPacket->SpinLock);
    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = TransferPacket->Length;
    TransferPacket->RefCount = 0;

    arraySize = QueryNumMembers();
    offset = TransferPacket->Offset;
    length = TransferPacket->Length;
    for (i = 0; i < arraySize; i++) {
        volumeSize = GetMemberUnprotected(i)->QueryVolumeSize();
        if (offset < volumeSize) {
            if (offset + length <= volumeSize) {
                multiple = FALSE;
            } else {
                multiple = TRUE;
            }
            break;
        }
        offset -= volumeSize;
    }

    if (TransferPacket->Mdl && multiple) {
        vp = (PCHAR) MmGetMdlVirtualAddress(TransferPacket->Mdl);
    }

    InitializeListHead(&q);
    for (;;) {

        len = length;
        if (len > volumeSize - offset) {
            len = (ULONG) (volumeSize - offset);
        }

        p = new VOLSET_TP;
        if (p) {
            if (TransferPacket->Mdl && multiple) {
                if (p->AllocateMdl(vp, len)) {
                    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl, vp, len);
                } else {
                    delete p;
                    p = NULL;
                }
                vp += len;
            } else {
                p->Mdl = TransferPacket->Mdl;
                p->OriginalIrp = TransferPacket->OriginalIrp;
            }
        }
        if (!p) {
            while (!IsListEmpty(&q)) {
                l = RemoveHeadList(&q);
                p = CONTAINING_RECORD(l, VOLSET_TP, QueueEntry);
                delete p;
            }
            return FALSE;
        }

        p->Length = len;
        p->Offset = offset;
        p->CompletionRoutine = VolsetTransferParallelCompletionRoutine;
        p->TargetVolume = GetMemberUnprotected(i);
        p->Thread = TransferPacket->Thread;
        p->IrpFlags = TransferPacket->IrpFlags;
        p->ReadPacket = TransferPacket->ReadPacket;
        p->SpecialRead = TransferPacket->SpecialRead;
        p->MasterPacket = TransferPacket;
        p->VolumeSet = this;
        p->WhichMember = i;

        InsertTailList(&q, &p->QueueEntry);

        TransferPacket->RefCount++;

        if (len == length) {
            break;
        }

        offset = 0;
        length -= p->Length;
        volumeSize = GetMemberUnprotected(++i)->QueryVolumeSize();
    }

    while (!IsListEmpty(&q)) {
        l = RemoveHeadList(&q);
        p = CONTAINING_RECORD(l, VOLSET_TP, QueueEntry);
        TRANSFER(p);
    }

    return TRUE;
}

VOID
VolsetTransferSequentialCompletionRoutine(
    IN  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Completion routine for VOLUME_SET::Transfer function.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PVOLSET_TP          transferPacket = (PVOLSET_TP) TransferPacket;
    PTRANSFER_PACKET    masterPacket = transferPacket->MasterPacket;
    NTSTATUS            status = transferPacket->IoStatus.Status;
    PVOLUME_SET         t = transferPacket->VolumeSet;
    LONGLONG            masterOffset, volumeSize;
    USHORT              i;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PTRANSFER_PACKET    p;

    if (NT_SUCCESS(status)) {

        if (NT_SUCCESS(masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Information +=
                    transferPacket->IoStatus.Information;
        }

    } else {

        if (FtpIsWorseStatus(status, masterPacket->IoStatus.Status)) {
            masterPacket->IoStatus.Status = status;
        }
    }

    MmPrepareMdlForReuse(transferPacket->Mdl);

    masterOffset = 0;
    for (i = 0; i < transferPacket->WhichMember; i++) {
        masterOffset += t->GetMemberUnprotected(i)->QueryVolumeSize();
    }
    masterOffset += transferPacket->Offset;
    masterOffset += transferPacket->Length;

    if (masterOffset == masterPacket->Offset + masterPacket->Length) {

        masterPacket->CompletionRoutine(masterPacket);

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_ePacketQueue)) {
                t->_ePacketInUse = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }
            l = RemoveHeadList(&t->_ePacketQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);

            if (!t->LaunchParallel(p)) {
                t->LaunchSequential(p);
                break;
            }
        }
        return;
    }

    volumeSize = transferPacket->TargetVolume->QueryVolumeSize();
    transferPacket->Offset += transferPacket->Length;
    transferPacket->Length = STRIPE_SIZE;

    if (transferPacket->Offset >= volumeSize) {
        transferPacket->Offset -= volumeSize;
        transferPacket->WhichMember++;
        transferPacket->TargetVolume =
                t->GetMemberUnprotected(transferPacket->WhichMember);
        volumeSize = transferPacket->TargetVolume->QueryVolumeSize();
    }

    if (masterOffset + transferPacket->Length >
        masterPacket->Offset + masterPacket->Length) {

        transferPacket->Length = (ULONG) (masterPacket->Offset +
                                          masterPacket->Length - masterOffset);
    }

    if (transferPacket->Offset + transferPacket->Length > volumeSize) {
        transferPacket->Length = (ULONG) (volumeSize - transferPacket->Offset);
    }

    IoBuildPartialMdl(masterPacket->Mdl, transferPacket->Mdl,
                      (PCHAR) MmGetMdlVirtualAddress(masterPacket->Mdl) +
                      (ULONG) (masterOffset - masterPacket->Offset),
                      transferPacket->Length);

    TRANSFER(transferPacket);
}

VOID
VOLUME_SET::LaunchSequential(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine lauches the given transfer packet in sequence accross
    all members using the emergency stripe transfer packet.

Arguments:

    TransferPacket  - Supplies the transfer packet to launch.

Return Value:

    FALSE   - The packet was not launched because of insufficient resources.

    TRUE    - Success.

--*/

{
    USHORT      arraySize, i;
    ULONG       length;
    LONGLONG    offset, volumeSize;
    PVOLSET_TP  p;

    TransferPacket->IoStatus.Status = STATUS_SUCCESS;
    TransferPacket->IoStatus.Information = 0;

    arraySize = QueryNumMembers();
    offset = TransferPacket->Offset;
    length = TransferPacket->Length;
    for (i = 0; i < arraySize; i++) {
        volumeSize = GetMemberUnprotected(i)->QueryVolumeSize();
        if (offset < volumeSize) {
            break;
        }
        offset -= volumeSize;
    }

    p = _ePacket;
    p->Length = STRIPE_SIZE;
    p->Offset = offset;
    p->CompletionRoutine = VolsetTransferSequentialCompletionRoutine;
    p->Thread = TransferPacket->Thread;
    p->IrpFlags = TransferPacket->IrpFlags;
    p->ReadPacket = TransferPacket->ReadPacket;
    p->SpecialRead = TransferPacket->SpecialRead;
    p->MasterPacket = TransferPacket;
    p->VolumeSet = this;
    p->WhichMember = i;

    if (p->Length > TransferPacket->Length) {
        p->Length = TransferPacket->Length;
    }

    if (p->Offset + p->Length > volumeSize) {
        p->Length = (ULONG) (volumeSize - p->Offset);
    }

    IoBuildPartialMdl(TransferPacket->Mdl, p->Mdl,
                      MmGetMdlVirtualAddress(TransferPacket->Mdl), p->Length);

    TRANSFER(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\newft\partitio.cxx ===
/*++

Copyright (C) 1991-5  Microsoft Corporation

Module Name:

    partitio.cxx

Abstract:

    This module contains the code specific to partitions for the fault
    tolerance driver.

Author:

    Bob Rinne   (bobri)  2-Feb-1992
    Mike Glass  (mglass)
    Norbert Kusters      2-Feb-1995

Environment:

    kernel mode only

Notes:

Revision History:

--*/

extern "C" {
    #include <ntddk.h>
}

#include <ftdisk.h>

class REPLACE_BAD_SECTOR_CONTEXT : public WORK_QUEUE_ITEM {

    public:

        PDEVICE_OBJECT  TargetObject;
        PIRP            Irp;

};

typedef REPLACE_BAD_SECTOR_CONTEXT *PREPLACE_BAD_SECTOR_CONTEXT;

NTSTATUS
PartitionBroadcastIrpCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           CompletionContext
    );


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif

NTSTATUS
PARTITION::Initialize(
    IN OUT  PROOT_EXTENSION     RootExtension,
    IN      FT_LOGICAL_DISK_ID  LogicalDiskId,
    IN OUT  PDEVICE_OBJECT      TargetObject,
    IN OUT  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    Initialize routine for FT_VOLUME of type PARTITION.

Arguments:

    RootExtension   - Supplies the root device extension.

    LogicalDiskId   - Supplies the logical disk id for this volume.

    TargetObject    - Supplies the partition to which transfer requests are
                        forwarded to.

    WholeDiskPdo    - Supplies the whole disk for this partition.

Return Value:

    None.

--*/

{
    KEVENT          event;
    PIRP            irp;
    DISK_GEOMETRY   geometry;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;
    ULONG           diskNumber, otherDiskNumber;
    LONGLONG        offset, partitionSize;

    FT_VOLUME::Initialize(RootExtension, LogicalDiskId);

    _targetObject = TargetObject;
    _wholeDiskPdo = WholeDiskPdo;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        TargetObject, NULL, 0, &geometry,
                                        sizeof(geometry), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    _sectorSize = geometry.BytesPerSector;

    status = FtpQueryPartitionInformation(RootExtension, TargetObject,
                                          &diskNumber, &_partitionOffset,
                                          NULL, NULL, &_partitionLength,
                                          NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (!_diskInfoSet->QueryFtPartitionInformation(LogicalDiskId,
                                                   &offset, NULL,
                                                   &otherDiskNumber, NULL,
                                                   &partitionSize)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (partitionSize > 0 && partitionSize <= _partitionLength) {
        _partitionLength = partitionSize;
    }

    if (offset != _partitionOffset || diskNumber != otherDiskNumber) {
        return STATUS_INVALID_PARAMETER;
    }

    _emergencyIrp = IoAllocateIrp(_targetObject->StackSize, FALSE);
    if (!_emergencyIrp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _emergencyIrpInUse = FALSE;
    InitializeListHead(&_emergencyIrpQueue);

    return STATUS_SUCCESS;
}

FT_LOGICAL_DISK_TYPE
PARTITION::QueryLogicalDiskType(
    )

/*++

Routine Description:

    This routine returns the type of the logical disk.

Arguments:

    None.

Return Value:

    The type of the logical disk.

--*/

{
    return FtPartition;
}

NTSTATUS
PARTITION::OrphanMember(
    IN  USHORT                  MemberNumber,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine tries to orphan the given member of this logical disk.
    A completion routine will be called if and only if this attempt is successful.

Arguments:

    MemberNumber        - Supplies the member number to orphan.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
PARTITION::RegenerateMember(
    IN      USHORT                  MemberNumber,
    IN OUT  PFT_VOLUME              NewMember,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine regenerates the given member of this volume with
    the given volume.

Arguments:

    MemberNumber    - Supplies the member number to regenerate.

    NewMember       - Supplies the new member to regenerate to.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the completion routine context.

Return Value:

    NTSTATUS

--*/

{
    return STATUS_INVALID_PARAMETER;
}

VOID
PartitionReplaceBadSectorWorker(
    IN  PVOID   Context
    )

{
    PREPLACE_BAD_SECTOR_CONTEXT context = (PREPLACE_BAD_SECTOR_CONTEXT) Context;

    IoCallDriver(context->TargetObject, context->Irp);
}

VOID
PARTITION::StopSyncOperations(
    )

/*++

Routine Description:

    This routine stops all sync operations.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

VOID
PARTITION::BroadcastIrp(
    IN  PIRP                    Irp,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine broadcasts a copy of the given IRP to every partition that
    is a member of the logical disk.

Arguments:

    Irp                 - Supplies the I/O request packet.

    CompletionRoutine   - Supplies the routine to be called when the operation
                            completes.

    Context             - Supplies the completion routine context.

Return Value:

    None.

--*/

{
    PIRP                            irp;
    PIO_STACK_LOCATION              irpSp, sp;
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;

    irp = IoAllocateIrp(_targetObject->StackSize, FALSE);
    if (!irp) {
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT)
                        ExAllocatePool(NonPagedPool,
                                       sizeof(FT_COMPLETION_ROUTINE_CONTEXT));
    if (!completionContext) {
        IoFreeIrp(irp);
        CompletionRoutine(Context, STATUS_INSUFFICIENT_RESOURCES);
        return;
    }

    completionContext->CompletionRoutine = CompletionRoutine;
    completionContext->Context = Context;

    irpSp = IoGetNextIrpStackLocation(irp);
    sp = IoGetCurrentIrpStackLocation(Irp);
    *irpSp = *sp;

    IoSetCompletionRoutine(irp, PartitionBroadcastIrpCompletionRoutine,
                           completionContext, TRUE, TRUE, TRUE);

    IoCallDriver(_targetObject, irp);
}

PFT_VOLUME
PARTITION::GetParentLogicalDisk(
    IN  PFT_VOLUME  Volume
    )

/*++

Routine Description:

    This routine returns the parent of the given logical disk within
    this volume.

Arguments:

    Volume  - Supplies the sub-volume of which we are looking for the parent.

Return Value:

    The parent volume or NULL;

--*/

{
    return NULL;
}

VOID
PARTITION::SetDirtyBit(
    IN  BOOLEAN                 IsDirty,
    IN  FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine sets the dirty bit on the volume.  This bit is used at
    startup to determine whether or not there was a clean shutdown.

Arguments:

    IsDirty - Supplies the value of the dirty bit.

Return Value:

    None.

--*/

{
    if (CompletionRoutine) {
        CompletionRoutine(Context, STATUS_SUCCESS);
    }
}

NTSTATUS
PARTITION::CheckIo(
    OUT PBOOLEAN    IsIoOk
    )

/*++

Routine Description:

    This routine returns whether or not IO is possible on the given
    partition.

Arguments:

    IsIoOk  - Returns the state of IO.

Return Value:

    NTSTATUS

--*/

{
    PVOID               buffer;
    LARGE_INTEGER       offset;
    KEVENT              event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatus;
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp;

    buffer = ExAllocatePool(NonPagedPoolCacheAligned, PAGE_SIZE);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    offset.QuadPart = 0;
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, _targetObject,
                                       buffer, PAGE_SIZE, &offset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->Flags = SL_OVERRIDE_VERIFY_VOLUME;

    status = IoCallDriver(_targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (FsRtlIsTotalDeviceFailure(status)) {
        *IsIoOk = FALSE;
    } else {
        *IsIoOk = TRUE;
    }

    ExFreePool(buffer);

    return STATUS_SUCCESS;
}

NTSTATUS
PARTITION::SetPartitionType(
    IN  UCHAR   PartitionType
    )

/*++

Routine Description:

    This routine sets the partition type on all the members of the
    FT set.

Arguments:

    PartitionType   - Supplies the partition type.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                      event;
    SET_PARTITION_INFORMATION   partInfo;
    PIRP                        irp;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    partInfo.PartitionType = (PartitionType | 0x80);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_PARTITION_INFO,
                                        _targetObject, &partInfo,
                                        sizeof(partInfo), NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(_targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}

UCHAR
PARTITION::QueryPartitionType(
    )

/*++

Routine Description:

    This routine queries the partition type.

Arguments:

    None.

Return Value:

    The partition type.

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION       partInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        _targetObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return 0;
    }

    status = IoCallDriver(_targetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    return partInfo.PartitionType;
}

UCHAR
PARTITION::QueryStackSize(
    )

/*++

Routine Description:

    This routine queries IRP stack size.

Arguments:

    None.

Return Value:

    The IRP stack size.

--*/

{
    return _targetObject->StackSize;
}

VOID
PARTITION::CreateLegacyNameLinks(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine creates the \Device\HarddiskN\PartitionM links for
    this object to the given device name.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    None.

--*/

{
    NTSTATUS        status;
    ULONG           diskNumber, partitionNumber;
    WCHAR           buf[80];
    UNICODE_STRING  symName;

    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, &partitionNumber,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return;
    }

    swprintf(buf, L"\\Device\\Harddisk%d\\Partition%d", diskNumber,
             partitionNumber);
    RtlInitUnicodeString(&symName, buf);

    IoDeleteSymbolicLink(&symName);

    if (DeviceName) {
        IoCreateSymbolicLink(&symName, DeviceName);
    }
}

NTSTATUS
PARTITION::QueryPhysicalOffsets(
    IN  LONGLONG                    LogicalOffset,
    OUT PVOLUME_PHYSICAL_OFFSET*    PhysicalOffsets,
    OUT PULONG                      NumberOfPhysicalOffsets
    )
/*++

Routine Description:

    This routine returns physical disk and offset for a given volume
    logical offset.

Arguments:

    LogicalOffset           - Supplies the logical offset

    PhysicalOffsets         - Returns the physical offsets

    NumberOfPhysicalOffsets - Returns the number of physical offsets

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    ULONG                   diskNumber;
    PVOLUME_PHYSICAL_OFFSET physicalOffset;
    
    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (LogicalOffset < 0 ||
        _partitionLength <= LogicalOffset) {
        return STATUS_INVALID_PARAMETER;
    }

    physicalOffset = (PVOLUME_PHYSICAL_OFFSET) ExAllocatePool(PagedPool, sizeof(VOLUME_PHYSICAL_OFFSET));
    if (!physicalOffset) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    physicalOffset->DiskNumber = diskNumber;
    physicalOffset->Offset = _partitionOffset + LogicalOffset;
    
    *PhysicalOffsets = physicalOffset;
    *NumberOfPhysicalOffsets = 1;

    return status;
}

NTSTATUS
PARTITION::QueryLogicalOffset(
    IN  PVOLUME_PHYSICAL_OFFSET PhysicalOffset,
    OUT PLONGLONG               LogicalOffset
    )
/*++

Routine Description:

    This routine returns the volume logical offset for a given disk number
    and physical offset.

Arguments:

    PhysicalOffset          - Supplies the physical offset

    LogicalOffset           - Returns the logical offset

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                status;
    ULONG                   diskNumber;
    PVOLUME_PHYSICAL_OFFSET physicalOffset;
    
    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (PhysicalOffset->DiskNumber != diskNumber ||
        PhysicalOffset->Offset < _partitionOffset ||
        _partitionOffset + _partitionLength <= PhysicalOffset->Offset) {

            return STATUS_INVALID_PARAMETER;
    }
    
    *LogicalOffset = PhysicalOffset->Offset - _partitionOffset;

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGELK")
#endif

PARTITION::~PARTITION(
    )

{
    if (_emergencyIrp) {
        IoFreeIrp(_emergencyIrp);
        _emergencyIrp = NULL;
    }
}

USHORT
PARTITION::QueryNumberOfMembers(
    )

/*++

Routine Description:

    This routine returns the number of members in this volume.

Arguments:

    None.

Return Value:

    0   - A volume of type partition has no members.

--*/

{
    return 0;
}

PFT_VOLUME
PARTITION::GetMember(
    IN  USHORT  MemberNumber
    )

/*++

Routine Description:

    This routine returns the 'MemberNumber'th member of this volume.

Arguments:

    MemberNumber    - Supplies the zero based member number desired.

Return Value:

    A pointer to the 'MemberNumber'th member or NULL if no such member.

--*/

{
    ASSERT(FALSE);
    return NULL;
}

NTSTATUS
PartitionTransferCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           TransferPacket
    )

/*++

Routine Description:

    Completion routine for PARTITION::Transfer function.

Arguments:

    Irp             - Supplies the IRP.

    TransferPacket  - Supplies the transfer packet.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PTRANSFER_PACKET    transferPacket = (PTRANSFER_PACKET) TransferPacket;
    PPARTITION          t = (PPARTITION) transferPacket->TargetVolume;
    KIRQL               irql;
    PLIST_ENTRY         l;
    PIRP                irp;
    PTRANSFER_PACKET    p;
    PIO_STACK_LOCATION  irpSp;

    transferPacket->IoStatus = Irp->IoStatus;
    if (Irp == transferPacket->OriginalIrp) {
        transferPacket->CompletionRoutine(transferPacket);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (Irp->AssociatedIrp.SystemBuffer) {
        ExFreePool(Irp->AssociatedIrp.SystemBuffer);
    }

    if (Irp == t->_emergencyIrp) {

        for (;;) {

            KeAcquireSpinLock(&t->_spinLock, &irql);
            if (IsListEmpty(&t->_emergencyIrpQueue)) {
                t->_emergencyIrpInUse = FALSE;
                KeReleaseSpinLock(&t->_spinLock, irql);
                break;
            }

            l = RemoveHeadList(&t->_emergencyIrpQueue);
            KeReleaseSpinLock(&t->_spinLock, irql);

            irp = IoAllocateIrp(t->_targetObject->StackSize, FALSE);
            if (!irp) {
                irp = t->_emergencyIrp;
                IoReuseIrp(irp, STATUS_SUCCESS);
            }

            p = CONTAINING_RECORD(l, TRANSFER_PACKET, QueueEntry);
            irpSp = IoGetNextIrpStackLocation(irp);
            irp->MdlAddress = p->Mdl;
            irpSp->Parameters.Write.ByteOffset.QuadPart = p->Offset;
            irpSp->Parameters.Write.Length = p->Length;
            if (p->ReadPacket) {
                irpSp->MajorFunction = IRP_MJ_READ;
            } else {
                irpSp->MajorFunction = IRP_MJ_WRITE;
            }

            irpSp->DeviceObject = t->_targetObject;
            irp->Tail.Overlay.Thread = p->Thread;
            irpSp->Flags = p->IrpFlags;

            IoSetCompletionRoutine(irp, PartitionTransferCompletionRoutine,
                                   p, TRUE, TRUE, TRUE);

            if (irp == Irp) {
                IoCallDriver(t->_targetObject, irp);
                break;
            } else {
                IoCallDriver(t->_targetObject, irp);
            }
        }

    } else {
        IoFreeIrp(Irp);
    }

    transferPacket->CompletionRoutine(transferPacket);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
PARTITION::Transfer(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    Transfer routine for PARTITION type FT_VOLUME.  Basically,
    just pass the request down to the target object.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    KIRQL               irql;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    PVERIFY_INFORMATION verifyInfo;

    irp = TransferPacket->OriginalIrp;
    if (!irp) {
        irp = IoAllocateIrp(_targetObject->StackSize, FALSE);
        if (!irp) {
            if (!TransferPacket->Mdl) {
                TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                TransferPacket->IoStatus.Information = 0;
                TransferPacket->CompletionRoutine(TransferPacket);
                return;
            }
            KeAcquireSpinLock(&_spinLock, &irql);
            if (_emergencyIrpInUse) {
                InsertTailList(&_emergencyIrpQueue, &TransferPacket->QueueEntry);
                KeReleaseSpinLock(&_spinLock, irql);
                return;
            }
            _emergencyIrpInUse = TRUE;
            KeReleaseSpinLock(&_spinLock, irql);
            irp = _emergencyIrp;
            IoReuseIrp(irp, STATUS_SUCCESS);                            
        }
    }

    irpSp = IoGetNextIrpStackLocation(irp);
    if (TransferPacket->Mdl) {
        irp->MdlAddress = TransferPacket->Mdl;
        irpSp->Parameters.Write.ByteOffset.QuadPart = TransferPacket->Offset;
        irpSp->Parameters.Write.Length = TransferPacket->Length;
        if (TransferPacket->ReadPacket) {
            irpSp->MajorFunction = IRP_MJ_READ;
        } else {
            irpSp->MajorFunction = IRP_MJ_WRITE;
        }
    } else {

        // Since there is no MDL, this is a verify request.

        verifyInfo = (PVERIFY_INFORMATION)
                     ExAllocatePool(NonPagedPool, sizeof(VERIFY_INFORMATION));
        if (!verifyInfo) {
            IoFreeIrp(irp);
            TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            TransferPacket->IoStatus.Information = 0;
            TransferPacket->CompletionRoutine(TransferPacket);
            return;
        }

        verifyInfo->StartingOffset.QuadPart = TransferPacket->Offset;
        verifyInfo->Length = TransferPacket->Length;
        irp->AssociatedIrp.SystemBuffer = verifyInfo;

        irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(VERIFY_INFORMATION);
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_VERIFY;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    irpSp->DeviceObject = _targetObject;
    irp->Tail.Overlay.Thread = TransferPacket->Thread;
    irpSp->Flags = TransferPacket->IrpFlags;

    IoSetCompletionRoutine(irp, PartitionTransferCompletionRoutine,
                           TransferPacket, TRUE, TRUE, TRUE);

    IoCallDriver(_targetObject, irp);
}

VOID
PARTITION::ReplaceBadSector(
    IN OUT  PTRANSFER_PACKET    TransferPacket
    )

/*++

Routine Description:

    This routine attempts to fix the given bad sector by performing
    a reassign blocks ioctl.

Arguments:

    TransferPacket  - Supplies the transfer packet.

Return Value:

    None.

--*/

{
    PIRP                        irp;
    PIO_STACK_LOCATION          irpSp;
    PREASSIGN_BLOCKS            badBlock;
    ULONG                       n, size, first, i;
    PREPLACE_BAD_SECTOR_CONTEXT context;

    irp = IoAllocateIrp(_targetObject->StackSize, FALSE);
    if (!irp) {
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    n = TransferPacket->Length/_sectorSize;
    size = FIELD_OFFSET(REASSIGN_BLOCKS, BlockNumber) + n*sizeof(ULONG);
    badBlock = (PREASSIGN_BLOCKS) ExAllocatePool(NonPagedPool, size);
    if (!badBlock) {
        IoFreeIrp(irp);
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    badBlock->Reserved = 0;
    badBlock->Count = 1;
    first = (ULONG) ((TransferPacket->Offset + _partitionOffset)/_sectorSize);
    for (i = 0; i < n; i++) {
        badBlock->BlockNumber[i] = first + i;
    }

    irp->AssociatedIrp.SystemBuffer = badBlock;
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = size;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_REASSIGN_BLOCKS;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpSp->DeviceObject = _targetObject;
    irp->Tail.Overlay.Thread = TransferPacket->Thread;
    irpSp->Flags = TransferPacket->IrpFlags;

    IoSetCompletionRoutine(irp, PartitionTransferCompletionRoutine,
                           TransferPacket, TRUE, TRUE, TRUE);

    context = (PREPLACE_BAD_SECTOR_CONTEXT)
              ExAllocatePool(NonPagedPool, sizeof(REPLACE_BAD_SECTOR_CONTEXT));
    if (!context) {
        ExFreePool(badBlock);
        IoFreeIrp(irp);
        TransferPacket->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        TransferPacket->IoStatus.Information = 0;
        TransferPacket->CompletionRoutine(TransferPacket);
        return;
    }

    ExInitializeWorkItem(context, PartitionReplaceBadSectorWorker, context);
    context->TargetObject = _targetObject;
    context->Irp = irp;

    FtpQueueWorkItem(_rootExtension, context);
}

VOID
PARTITION::StartSyncOperations(
    IN      BOOLEAN                 RegenerateOrphans,
    IN      FT_COMPLETION_ROUTINE   CompletionRoutine,
    IN      PVOID                   Context
    )

/*++

Routine Description:

    This routine restarts any regenerate or initialize requests that
    were suspended because of a reboot.  The volume examines the member
    state of all of its constituents and restarts any regenerations pending.

Arguments:

    RegenerateOrphans   - Supplies whether or not to try and regenerate
                            orphaned members.

    CompletionRoutine   - Supplies the completion routine.

    Context             - Supplies the context for the completion routine.

Return Value:

    None.

--*/

{
    CompletionRoutine(Context, STATUS_SUCCESS);
}

NTSTATUS
PartitionBroadcastIrpCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           CompletionContext
    )

/*++

Routine Description:

    Completion routine for PARTITION::BroadcastIrp functions.

Arguments:

    Irp                 - Supplies the IRP.

    CompletionContext   - Supplies the completion context.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    PFT_COMPLETION_ROUTINE_CONTEXT  completionContext;

    completionContext = (PFT_COMPLETION_ROUTINE_CONTEXT) CompletionContext;

    completionContext->CompletionRoutine(completionContext->Context,
                                         Irp->IoStatus.Status);

    IoFreeIrp(Irp);
    ExFreePool(CompletionContext);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

ULONG
PARTITION::QuerySectorSize(
    )

/*++

Routine Description:

    Returns the sector size for the volume.

Arguments:

    None.

Return Value:

    The volume sector size in bytes.

--*/

{
    return _sectorSize;
}

LONGLONG
PARTITION::QueryVolumeSize(
    )

/*++

Routine Description:

    Returns the number of bytes on the entire volume.

Arguments:

    None.

Return Value:

    The volume size in bytes.

--*/

{
    return _partitionLength;
}

PFT_VOLUME
PARTITION::GetContainedLogicalDisk(
    IN  FT_LOGICAL_DISK_ID  LogicalDiskId
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    LogicalDiskId   - Supplies the logical disk id that we are searching for.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    if (LogicalDiskId == QueryLogicalDiskId()) {
        return this;
    }

    return NULL;
}

PFT_VOLUME
PARTITION::GetContainedLogicalDisk(
    IN  PDEVICE_OBJECT  TargetObject
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    TargetObject    - Supplies the target object.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    if (TargetObject == _targetObject) {
        return this;
    }

    return NULL;
}

PFT_VOLUME
PARTITION::GetContainedLogicalDisk(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

/*++

Routine Description:

    This routine returns TRUE if the given logical disk id
    represents this logical disk or if this logical disk contains
    the given logical disk id either directly or indirectly.

Arguments:

    Signature   - Supplies the signature.

    Offset      - Supplies the partition offset.

Return Value:

    FALSE   - The given logical disk id is not contained in this logical disk.

    TRUE    - The given logical disk id is contained in this logical disk.

--*/

{
    if (Offset != _partitionOffset) {
        return NULL;
    }

    if (Signature == FtpQueryDiskSignature(_wholeDiskPdo)) {
        return this;
    }

    return NULL;
}

VOID
PARTITION::SetMember(
    IN  USHORT      MemberNumber,
    IN  PFT_VOLUME  Member
    )

/*++

Routine Description:

    This routine sets the given member in this volume.

Arguments:

    MemberNumber    - Supplies the member number.

    Member          - Supplies the member.

Return Value:

    None.

--*/

{
    ASSERT(FALSE);
}

BOOLEAN
PARTITION::IsComplete(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine computes whether or not this volume has either all
    (if IoPending is FALSE) of its members or enough (if IoPending is TRUE) of
    its members.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
    return TRUE;
}

VOID
PARTITION::CompleteNotification(
    IN  BOOLEAN IoPending
    )

/*++

Routine Description:

    This routine is called to notify the volume that it is complete and
    to therefore prepare for incoming requests.

Arguments:

    IoPending   - Supplies whether or not there is IO pending.

Return Value:

    None.

--*/

{
}

ULONG
PARTITION::QueryNumberOfPartitions(
    )

/*++

Routine Description:

    This routine returns the number of partitions covered by this volume
    set.

Arguments:

    None.

Return Value:

    The number of partitions covered by this volume set.

--*/

{
    return 1;
}

PDEVICE_OBJECT
PARTITION::GetLeftmostPartitionObject(
    )

{
    return _targetObject;
}

NTSTATUS
PARTITION::QueryDiskExtents(
    OUT PDISK_EXTENT*   DiskExtents,
    OUT PULONG          NumberOfDiskExtents
    )

/*++

Routine Description:

    This routine returns an array of disk extents that describe the
    location of this volume.

Arguments:

    DiskExtents         - Returns the disk extents.

    NumberOfDiskExtents - Returns the number of disk extents.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status;
    ULONG           diskNumber;
    PDISK_EXTENT    diskExtent;

    status = FtpQueryPartitionInformation(_rootExtension, _targetObject,
                                          &diskNumber, NULL, NULL,
                                          NULL, NULL, NULL, NULL, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    diskExtent = (PDISK_EXTENT) ExAllocatePool(PagedPool, sizeof(DISK_EXTENT));
    if (!diskExtent) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    diskExtent->DiskNumber = diskNumber;
    diskExtent->StartingOffset.QuadPart = _partitionOffset;
    diskExtent->ExtentLength.QuadPart = _partitionLength;

    *DiskExtents = diskExtent;
    *NumberOfDiskExtents = 1;

    return status;
}

BOOLEAN
PARTITION::QueryVolumeState(
    IN  PFT_VOLUME          Volume,
    OUT PFT_MEMBER_STATE    State
    )

/*++

Routine Description:

    This routine returns the state of the given volume considered as a
    member of this volume.

Arguments:

    Volume  - Supplies the volume to query the state for.

    State   - Returns the state.

Return Value:

    FALSE   - The given Volume is not a member of this volume.

    TRUE    - The state was successfully computed.

--*/

{
    if (Volume != this) {
        return FALSE;
    }

    *State = FtMemberHealthy;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\partmgr\pmwmicnt.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmicnt.c

Abstract:

    This file contains the routines to manage and maintain the disk perf
    counters.  The counter structure is hidden from the various drivers.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define RTL_USE_AVL_TABLES 0

#include <ntosp.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <wmilib.h>
#include <partmgr.h>

typedef struct _PMWMICOUNTER_CONTEXT
{
  ULONG EnableCount;
  ULONG Processors;
  ULONG QueueDepth;
  PDISK_PERFORMANCE *DiskCounters;
  LARGE_INTEGER LastIdleClock;
} PMWMICOUNTER_CONTEXT, *PPMWMICOUNTER_CONTEXT;


NTSTATUS
PmWmiCounterEnable(
    IN OUT PPMWMICOUNTER_CONTEXT* CounterContext
    );

BOOLEAN
PmWmiCounterDisable(
    IN PPMWMICOUNTER_CONTEXT* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    );

VOID
PmWmiCounterIoStart(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterIoComplete(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterQuery(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN OUT PDISK_PERFORMANCE CounterBuffer,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmWmiCounterEnable)
#pragma alloc_text(PAGE, PmWmiCounterDisable)
#pragma alloc_text(PAGE, PmWmiCounterQuery)
#endif


NTSTATUS
PmWmiCounterEnable(
    IN OUT PPMWMICOUNTER_CONTEXT* CounterContext
    )
/*++

Routine Description:

    This routine will allocate and initialize a PMWMICOUNTER_CONTEXT structure
    for *CounterContext if it is NULL.  Otherwise, an enable count is
    incremented.
    Must be called at IRQ <= SYNCH_LEVEL (APC)

Arguments:

    CounterContext - Supplies a pointer to the PMWMICOUNTER_CONTEXT pointer

Return Value:

    status

--*/
{
    ULONG buffersize;
    ULONG processors;
    ULONG i = 0;
    PCHAR buffer;
    PPMWMICOUNTER_CONTEXT HoldContext;   // Holds context during initialization

    PAGED_CODE();

    if (CounterContext == NULL)
        return STATUS_INVALID_PARAMETER;

    if (*CounterContext != NULL) {
        if ((*CounterContext)->EnableCount == 0) {
            (*CounterContext)->QueueDepth = 0;
            PmWmiGetClock((*CounterContext)->LastIdleClock, NULL);
        }
        InterlockedIncrement(& (*CounterContext)->EnableCount);
        return STATUS_SUCCESS;
    }

    processors = KeNumberProcessors;

    buffersize= sizeof(PMWMICOUNTER_CONTEXT) +
                ((sizeof(PDISK_PERFORMANCE) + sizeof(DISK_PERFORMANCE))
                 * processors);
    buffer =  (PCHAR) ExAllocatePoolWithTag(NonPagedPool, buffersize,
                                            PARTMGR_TAG_PARTITION_ENTRY);

    if (buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(buffer, buffersize);
    HoldContext = (PPMWMICOUNTER_CONTEXT) buffer;
    buffer += sizeof(PMWMICOUNTER_CONTEXT);
    HoldContext->DiskCounters = (PDISK_PERFORMANCE*) buffer;
    buffer += sizeof(PDISK_PERFORMANCE) * processors;
    for (i=0; i<processors; i++) {
        HoldContext->DiskCounters[i] = (PDISK_PERFORMANCE) buffer;
        buffer += sizeof(DISK_PERFORMANCE);
    }

    HoldContext->EnableCount = 1;
    HoldContext->Processors = processors;
    PmWmiGetClock(HoldContext->LastIdleClock, NULL);

    *CounterContext = HoldContext;

    return STATUS_SUCCESS;
}



BOOLEAN               // Return value indicates if counters are still enabled
PmWmiCounterDisable(
    IN PPMWMICOUNTER_CONTEXT* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    )
/*++

Routine Description:

    This routine decrements the enable count and, if deallocation is requested,
    frees the *CounterContext PMWMICOUNTER_CONTEXT data structure when the
    enable count reaches zero.  The enable count may also be forced to zero,
    if explicitly requested.
    Must be called at IRQ <= SYNCH_LEVEL (APC)

Arguments:

    CounterContext - Supplies a pointer to the PMWMICOUNTER_CONTEXT pointer

    ForceDisable - If TRUE, force enable count to zero (rather than decrement)

    DeallocateOnZero - If TRUE, deallocate PMWMICOUNTER_CONTEXT when enable
       count reaches zero

Return Value:

    Boolean indicating if the enable count is still non-zero (i.e., counters
       are still enabled!)

--*/
{
    LONG enablecount = 0;

    PAGED_CODE();

    if (CounterContext == NULL)
        return FALSE;

    if (*CounterContext != NULL) {
        if (ForceDisable) {
            InterlockedExchange(& (*CounterContext)->EnableCount, enablecount);
            enablecount = 0;
        } else if ((enablecount =
                    InterlockedDecrement(&(*CounterContext)->EnableCount))!=0) {
            if (enablecount > 0) {
            return TRUE;
            }
            enablecount = InterlockedIncrement(&(*CounterContext)->EnableCount);
    }
    if (!enablecount && DeallocateOnZero) {
            ExFreePool(*CounterContext);
            *CounterContext = NULL;
        }
    }

    return FALSE;  // counters disabled
}



VOID
PmWmiCounterIoStart(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:

    This routine increments the queue counter in CounterContext and records
    the current time in TimeStamp.  If the queue was empty prior to this call,
    the idle time counter is also accumulated.
    Can be called at IRQ <= DISPATCH_LEVEL

Arguments:

    CounterContext - Supplies a pointer to a PMWMICOUNTER_CONTEXT structure.

    TimeStamp - Address at which to store the current time

Return Value:

    void

--*/
{
    ULONG              processor = (ULONG) KeGetCurrentProcessorNumber();
    ULONG              queueLen;

    //
    // Increment queue depth counter.
    //

    queueLen = InterlockedIncrement(&CounterContext->QueueDepth);

    //
    // Time stamp current request start.
    //

    PmWmiGetClock((*TimeStamp), NULL);

    if (queueLen == 1) {
        CounterContext->DiskCounters[processor]->IdleTime.QuadPart += 
	  TimeStamp->QuadPart - CounterContext->LastIdleClock.QuadPart;
    }

}



VOID
PmWmiCounterIoComplete(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:

    This routine decrements the queue counter in CounterContext and increments
    the split counter and read or write byte, time, and count counters with
    information from the Irp.  If the queue is now empty, the current
    time is stored for future use in accumulating the idle time counter.
    Can be called at IRQ <= DISPATCH_LEVEL

Arguments:

    CounterContext - Supplies a pointer to a PMWMICOUNTER_CONTEXT structure.

    Irp - relevant IRP

    TimeStamp - Time of the corresponding PmWmiCounterIoStart call

Return Value:

    void

--*/
{
    PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
    PDISK_PERFORMANCE  partitionCounters;
    LARGE_INTEGER      timeStampComplete;
    LONG               queueLen;

    partitionCounters
        = CounterContext->DiskCounters[(ULONG)KeGetCurrentProcessorNumber()];
    //
    // Time stamp current request complete.
    //

    PmWmiGetClock(timeStampComplete, NULL);
    TimeStamp->QuadPart = timeStampComplete.QuadPart - TimeStamp->QuadPart;

    //
    // Decrement the queue depth counters for the volume.  This is
    // done without the spinlock using the Interlocked functions.
    // This is the only
    // legal way to do this.
    //

    queueLen = InterlockedDecrement(&CounterContext->QueueDepth);

    if (queueLen < 0) {
        queueLen = InterlockedIncrement(&CounterContext->QueueDepth);
    }

    if (queueLen == 0) {
        CounterContext->LastIdleClock = timeStampComplete;
    }

    //
    // Update counters protection.
    //

    if (irpStack->MajorFunction == IRP_MJ_READ) {

        //
        // Add bytes in this request to bytes read counters.
        //

        partitionCounters->BytesRead.QuadPart += Irp->IoStatus.Information;

        //
        // Increment read requests processed counters.
        //

        partitionCounters->ReadCount++;

        //
        // Calculate request processing time.
        //

        partitionCounters->ReadTime.QuadPart += TimeStamp->QuadPart;
    }

    else {

        //
        // Add bytes in this request to bytes write counters.
        //

        partitionCounters->BytesWritten.QuadPart += Irp->IoStatus.Information;

        //
        // Increment write requests processed counters.
        //

        partitionCounters->WriteCount++;

        //
        // Calculate request processing time.
        //

        partitionCounters->WriteTime.QuadPart += TimeStamp->QuadPart;
    }

    if (Irp->Flags & IRP_ASSOCIATED_IRP) {
        partitionCounters->SplitCount++;
    }
}



VOID
PmWmiCounterQuery(
    IN PPMWMICOUNTER_CONTEXT CounterContext,
    IN OUT PDISK_PERFORMANCE TotalCounters,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    )
/*++

Routine Description:

    This routine combines all of the per-processor counters in CounterContext
    into TotalCounters.  The current time is also included.
    Must be called at IRQ <= SYNCH_LEVEL (APC)

Arguments:

    CounterContext - Supplies a pointer to a PMWMICOUNTER_CONTEXT structure.

    TotalCounters - Pointer to a DISK_PERFORMANCE structure to fill with the
       current counter status

    StorageManagerName - Supplies an 8-character storage manager unicode string

    StorageDeviceNumber - Supplies a storage device number (unique within
       the storage manager)

Return Value:

    void

--*/
{
    ULONG i;
    LARGE_INTEGER frequency;
#ifdef USE_PERF_CTR
    LARGE_INTEGER perfctr;
#endif

    PAGED_CODE();

    RtlZeroMemory(TotalCounters, sizeof(DISK_PERFORMANCE));

    KeQuerySystemTime(&TotalCounters->QueryTime);
    frequency.QuadPart = 0;

#ifdef USE_PERF_CTR
    perfctr = KeQueryPerformanceCounter(&frequency);
#endif

    TotalCounters->QueueDepth = CounterContext->QueueDepth;
    for (i = 0; i < CounterContext->Processors; i++) {
        PDISK_PERFORMANCE IndividualCounter = CounterContext->DiskCounters[i];
        TotalCounters->BytesRead.QuadPart
            += IndividualCounter->BytesRead.QuadPart;
        TotalCounters->BytesWritten.QuadPart
            += IndividualCounter->BytesWritten.QuadPart;
        TotalCounters->ReadCount   += IndividualCounter->ReadCount;
        TotalCounters->WriteCount  += IndividualCounter->WriteCount;
        TotalCounters->SplitCount  += IndividualCounter->SplitCount;
#ifdef USE_PERF_CTR
        if (frequency.QuadPart > 0) {
            TotalCounters->ReadTime.QuadPart    +=
                IndividualCounter->ReadTime.QuadPart * 10000000
                    / frequency.QuadPart;
            TotalCounters->WriteTime.QuadPart   +=
                IndividualCounter->WriteTime.QuadPart * 10000000
                    / frequency.QuadPart;
            TotalCounters->IdleTime.QuadPart    +=
                IndividualCounter->IdleTime.QuadPart * 10000000
                    / frequency.QuadPart;
        }
        else
#endif
        {
            TotalCounters->ReadTime.QuadPart
                += IndividualCounter->ReadTime.QuadPart;
            TotalCounters->WriteTime.QuadPart
                += IndividualCounter->WriteTime.QuadPart;
            TotalCounters->IdleTime.QuadPart
                += IndividualCounter->IdleTime.QuadPart;
        }
    }


    if (TotalCounters->QueueDepth == 0) {
        LARGE_INTEGER difference;

        difference.QuadPart
#ifdef USE_PERF_CTR
            = perfctr.QuadPart -
#else
            = TotalCounters->QueryTime.QuadPart -
#endif
                  CounterContext->LastIdleClock.QuadPart;

        if (frequency.QuadPart > 0) {
            TotalCounters->IdleTime.QuadPart +=
#ifdef USE_PERF_CTR
                10000000 * difference.QuadPart / frequency.QuadPart;
#else
                difference.QuadPart;
#endif
        }
    }

    TotalCounters->StorageDeviceNumber = StorageDeviceNumber;
    RtlCopyMemory(
        &TotalCounters->StorageManagerName[0],
        &StorageManagerName[0],
        sizeof(WCHAR) * 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\partmgr\partmgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    partmgr.h

Abstract:

    This file defines the internal data structure for the PARTMGR driver.

Author:

    norbertk

Revision History:

--*/

#include <partmgrp.h>

#define DEVICENAME_MAXSTR   64          // used to storage device name for WMI

#undef ExAllocatePool
#define ExAllocatePool #

#define PARTMGR_TAG_DEPENDANT_VOLUME_LIST       'vRcS'  // ScRv
#define PARTMGR_TAG_PARTITION_ENTRY             'pRcS'  // ScRp
#define PARTMGR_TAG_VOLUME_ENTRY                'VRcS'  // ScRV
#define PARTMGR_TAG_TABLE_ENTRY                 'tRcS'  // ScRt
#define PARTMGR_TAG_POWER_WORK_ITEM             'wRcS'  // ScRw
#define PARTMGR_TAG_IOCTL_BUFFER                'iRcS'  // ScRi

#define PARTMGR_TAG_REMOVE_LOCK                 'rRcS'  // ScRr

typedef struct _VOLMGR_LIST_ENTRY {
    LIST_ENTRY      ListEntry;
    UNICODE_STRING  VolumeManagerName;
    LONG            RefCount;
    PDEVICE_OBJECT  VolumeManager;
    PFILE_OBJECT    VolumeManagerFileObject;
} VOLMGR_LIST_ENTRY, *PVOLMGR_LIST_ENTRY;

typedef struct _PARTITION_LIST_ENTRY {
    LIST_ENTRY          ListEntry;
    PDEVICE_OBJECT      TargetObject;
    PDEVICE_OBJECT      WholeDiskPdo;
    PVOLMGR_LIST_ENTRY  VolumeManagerEntry;
} PARTITION_LIST_ENTRY, *PPARTITION_LIST_ENTRY;

//
// Allow usage of different clocks
//
#define USE_PERF_CTR                // default to KeQueryPerformanceCounter

#ifdef  USE_PERF_CTR
#define PmWmiGetClock(a, b) (a) = KeQueryPerformanceCounter((b))
#else
#define PmWmiGetClock(a, b) KeQuerySystemTime(&(a))
#endif

typedef
VOID
(*PPHYSICAL_DISK_IO_NOTIFY_ROUTINE)(     // callout for disk I/O tracing
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PDISK_PERFORMANCE PerfCounters
    );

typedef struct _DO_EXTENSION {

    //
    // A pointer to the driver object.
    //

    PDRIVER_OBJECT DriverObject;

    //
    // A list of volume managers to pass partitions to.  Protect with
    // 'Mutex'.
    //

    LIST_ENTRY VolumeManagerList;

    //
    // The list of device extensions.  Protect with 'Mutex'.
    //

    LIST_ENTRY DeviceExtensionList;

    //
    // The notification entry.
    //

    PVOID NotificationEntry;

    //
    // For synchronization.
    //

    KMUTEX Mutex;

    //
    // Am I past Driver Reinit?
    //

    LONG PastReinit;

    //
    // A table to keep track disk signatures which includes signatures
    // on MBR disks and squashed disk GUIDs on GPT disks.
    //

    RTL_GENERIC_TABLE SignatureTable;

    //
    // A table to keep track of GPT disk and partition GUIDs.
    //

    RTL_GENERIC_TABLE GuidTable;

    //
    // Registry Path.
    //
 
    UNICODE_STRING DiskPerfRegistryPath;        // for WMI QueryRegInfo

    //
    // BootDiskSig for OEM pre-install.
    //

    ULONG BootDiskSig;

} DO_EXTENSION, *PDO_EXTENSION;

typedef struct _DEVICE_EXTENSION {

    //
    // Indicates that a surprise remove has occurred.
    //

    BOOLEAN RemoveProcessed;

    //
    // Indicates that signatures have not yet been checked.
    //

    BOOLEAN SignaturesNotChecked;

    //
    // Indicates that this is a redundant path to a disk.
    //

    BOOLEAN IsRedundantPath;

    //
    // Indicates that the device is started.  Protect with 'Mutex'.
    //

    BOOLEAN IsStarted;

    //
    // A pointer to our own device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // A pointer to the driver extension.
    //

    PDO_EXTENSION DriverExtension;

    //
    // A pointer to the device object that we are layered above -- a whole
    // disk.
    //

    PDEVICE_OBJECT TargetObject;

    //
    // A pointer to the PDO.
    //

    PDEVICE_OBJECT Pdo;

    //
    // A list of partitions allocated from paged pool.  Protect with
    // 'Mutex'.
    //

    LIST_ENTRY PartitionList;

    //
    // A list entry for the device extension list in the driver extension.
    //

    LIST_ENTRY ListEntry;

    //
    // For paging notifications
    //

    ULONG PagingPathCount;
    KEVENT PagingPathCountEvent;

    //
    // Remember the disk signature so that you can write it out later.
    //

    ULONG DiskSignature;

    //
    // Keep a list of Signatures used on this disk.
    //

    LIST_ENTRY SignatureList;

    //
    // Keep a list of GUIDs used on this disk.
    //

    LIST_ENTRY GuidList;

    //
    // Whether or not the counters are running.
    //

    BOOLEAN CountersEnabled;

    //
    // Leave counters always enabled if we see IOCTL_DISK_PERFORMANCE
    //

    LONG EnableAlways;

    //
    // Disk Number.
    //

    ULONG DiskNumber;

    //
    // Counter structure.
    //

    PVOID PmWmiCounterContext;

    //
    // Device Name
    //

    UNICODE_STRING PhysicalDeviceName;
    WCHAR PhysicalDeviceNameBuffer[DEVICENAME_MAXSTR];

    //
    // Routine to notify on IO completion.
    //

    PPHYSICAL_DISK_IO_NOTIFY_ROUTINE PhysicalDiskIoNotifyRoutine;

    //
    // Table of WmiLib Functions.
    //

    PWMILIB_CONTEXT WmilibContext;

    //
    //  Work queue for power mgmt processing
    //  Protected by "SpinLock"
    //

    LIST_ENTRY PowerQueue;

    //
    // Spinlock used to protect the power mgmt work queue
    //

    KSPIN_LOCK  SpinLock;

    //
    // Lock structure used to block the device deletion
    // as a result of IRP_MN_REMOVE_DEVICE
    //
    
    IO_REMOVE_LOCK RemoveLock;


} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _SIGNATURE_TABLE_ENTRY {
    LIST_ENTRY          ListEntry;
    PDEVICE_EXTENSION   Extension;
    ULONG               Signature;
} SIGNATURE_TABLE_ENTRY, *PSIGNATURE_TABLE_ENTRY;

typedef struct _GUID_TABLE_ENTRY {
    LIST_ENTRY          ListEntry;
    PDEVICE_EXTENSION   Extension;
    GUID                Guid;
} GUID_TABLE_ENTRY, *PGUID_TABLE_ENTRY;

//
//  Work item for PmPowerNotify
//

typedef struct _PM_POWER_WORK_ITEM {
    LIST_ENTRY          ListEntry;
    DEVICE_POWER_STATE  DevicePowerState;    
} PM_POWER_WORK_ITEM, *PPM_POWER_WORK_ITEM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\partmgr\partmgr.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    partmgr.c

Abstract:

    This driver manages hides partitions from user mode, allowing access
    only from other device drivers.  This driver implements a notification
    protocol for other drivers that want to be alerted of changes to the
    partitions in the system.

Author:

    Norbert Kusters      18-Apr-1997

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define RTL_USE_AVL_TABLES 0

#include <ntosp.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <initguid.h>
#include <volmgr.h>
#include <wmikm.h>
#include <wmilib.h>
#include <pmwmireg.h>
#include <pmwmicnt.h>
#include <partmgr.h>
#include <ntiologc.h>
#include <ioevent.h>

NTSTATUS
PmReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTSTATUS
PmWritePartitionTableEx(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    DriveLayout
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PmTakePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    );

NTSTATUS
PmGivePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    );

NTSTATUS
PmFindPartition(
    IN  PDEVICE_EXTENSION       Extension,
    IN  ULONG                   PartitionNumber,
    OUT PPARTITION_LIST_ENTRY   *PartitionEntry
    );

NTSTATUS
PmQueryDeviceRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
PmRemoveDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
PmCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PmPowerNotify (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            WorkItem
    );

NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
PmVolumeManagerNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   DriverExtension
    );

NTSTATUS
PmNotifyPartitions(
    IN PDEVICE_EXTENSION DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PmBuildDependantVolumeRelations(
    IN PDEVICE_EXTENSION Extension,
    OUT PDEVICE_RELATIONS *Relations
    );

NTSTATUS
PmQueryDependantVolumeList(
    IN  PDEVICE_OBJECT VolumeManager,
    IN  PDEVICE_OBJECT Partition,
    IN  PDEVICE_OBJECT WholeDiskPdo,
    OUT PDEVICE_RELATIONS *DependantVolumes
    );

NTSTATUS
PmQueryRemovalRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    );

NTSTATUS
PmStartPartition(
    IN  PDEVICE_OBJECT  Partition
    );

NTSTATUS
PmRemovePartition(
    IN PPARTITION_LIST_ENTRY Partition
    );

NTSTATUS
PmDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmGetPartitionInformation(
    IN  PDEVICE_OBJECT  Partition,
    IN  PFILE_OBJECT    FileObject,
    OUT PLONGLONG       PartitionOffset,
    OUT PLONGLONG       PartitionLength
    );

NTSTATUS
PmDiskGrowPartition(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PmCheckForUnclaimedPartitions(
    IN  PDEVICE_OBJECT  DeviceObject
    );

NTSTATUS
PmChangePartitionIoctl(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PPARTITION_LIST_ENTRY   Partition,
    IN  ULONG                   IoctlCode
    );

NTSTATUS
PmEjectVolumeManagers(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PmAddSignatures(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    Layout
    );

RTL_GENERIC_COMPARE_RESULTS
PmTableSignatureCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    );

RTL_GENERIC_COMPARE_RESULTS
PmTableGuidCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    );

PVOID
PmTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    );

VOID
PmTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    );

NTSTATUS
PmQueryDiskSignature(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PmReadWrite(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PmIoCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS PmWmi(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
PmWmiFunctionControl(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN ULONG                    GuidIndex,
    IN WMIENABLEDISABLECONTROL  Function,
    IN BOOLEAN                  Enable
    );

VOID
PmDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           DriverExtension,
    IN  ULONG           Count
    );

BOOLEAN
PmIsRedundantPath(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  ULONG               Signature,
    IN  GUID*               Guid
    );

VOID
PmLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  NTSTATUS            SpecificIoStatus
    );

ULONG
PmQueryRegistrySignature(
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PmTakePartition)
#pragma alloc_text(PAGE, PmGivePartition)
#pragma alloc_text(PAGE, PmFindPartition)
#pragma alloc_text(PAGE, PmQueryDeviceRelations)
#pragma alloc_text(PAGE, PmRemoveDevice)
#pragma alloc_text(PAGE, PmCreateClose)
#pragma alloc_text(PAGE, PmPnp)
#pragma alloc_text(PAGE, PmAddDevice)
#pragma alloc_text(PAGE, PmVolumeManagerNotification)
#pragma alloc_text(PAGE, PmNotifyPartitions)
#pragma alloc_text(PAGE, PmBuildDependantVolumeRelations)
#pragma alloc_text(PAGE, PmQueryDependantVolumeList)
#pragma alloc_text(PAGE, PmQueryRemovalRelations)
#pragma alloc_text(PAGE, PmStartPartition)
#pragma alloc_text(PAGE, PmDeviceControl)
#pragma alloc_text(PAGE, PmGetPartitionInformation)
#pragma alloc_text(PAGE, PmDiskGrowPartition)
#pragma alloc_text(PAGE, PmCheckForUnclaimedPartitions)
#pragma alloc_text(PAGE, PmChangePartitionIoctl)
#pragma alloc_text(PAGE, PmEjectVolumeManagers)
#pragma alloc_text(PAGE, PmAddSignatures)
#pragma alloc_text(PAGE, PmTableSignatureCompareRoutine)
#pragma alloc_text(PAGE, PmTableGuidCompareRoutine)
#pragma alloc_text(PAGE, PmTableAllocateRoutine)
#pragma alloc_text(PAGE, PmTableFreeRoutine)
#pragma alloc_text(PAGE, PmQueryDiskSignature)
#pragma alloc_text(PAGE, PmWmi)
#pragma alloc_text(PAGE, PmWmiFunctionControl)
#pragma alloc_text(PAGE, PmReadPartitionTableEx)
#pragma alloc_text(PAGE, PmWritePartitionTableEx)
#pragma alloc_text(PAGE, PmDriverReinit)
#pragma alloc_text(PAGE, PmIsRedundantPath)
#pragma alloc_text(PAGE, PmLogError)
#pragma alloc_text(PAGE, PmQueryRegistrySignature)
#endif


NTSTATUS
PmPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   extension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(extension->TargetObject, Irp);
}

NTSTATUS
PmSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Event
    )

/*++

Routine Description:

    This routine will signal the event given as context.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

    Event           - Supplies the event to signal.

Return Value:

    NTSTATUS

--*/

{
    KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
PmTakePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine passes the given partition to the given volume manager
    and waits to see if the volume manager accepts the partition.  A success
    status indicates that the volume manager has accepted the partition.

Arguments:

    VolumeManager   - Supplies a volume manager.

    Partition       - Supplies a partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    KEVENT                          event;
    VOLMGR_PARTITION_INFORMATION    input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;

    if (!VolumeManagerEntry) {
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    input.PartitionDeviceObject = Partition;
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_VOLMGR_PARTITION_REMOVED,
                                        VolumeManagerEntry->VolumeManager,
                                        &input, sizeof(input), NULL, 0, TRUE,
                                        &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(VolumeManagerEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    VolumeManagerEntry->RefCount--;
    if (!VolumeManagerEntry->RefCount) {
        VolumeManagerEntry->VolumeManager = NULL;
        ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
        VolumeManagerEntry->VolumeManagerFileObject = NULL;
    }
}

NTSTATUS
PmGivePartition(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      Partition,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine passes the given partition to the given volume manager
    and waits to see if the volume manager accepts the partition.  A success
    status indicates that the volume manager has accepted the partition.

Arguments:

    VolumeManager   - Supplies a volume manager.

    Partition       - Supplies a partition.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    KEVENT                          event;
    VOLMGR_PARTITION_INFORMATION    input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    if (!VolumeManagerEntry->RefCount) {
        status = IoGetDeviceObjectPointer(
                 &VolumeManagerEntry->VolumeManagerName, FILE_READ_DATA,
                 &VolumeManagerEntry->VolumeManagerFileObject,
                 &VolumeManagerEntry->VolumeManager);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    input.PartitionDeviceObject = Partition;
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_VOLMGR_PARTITION_ARRIVED,
                                        VolumeManagerEntry->VolumeManager,
                                        &input, sizeof(input),
                                        NULL, 0, TRUE, &event, &ioStatus);
    if (!irp) {
        if (!VolumeManagerEntry->RefCount) {
            VolumeManagerEntry->VolumeManager = NULL;
            ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
            VolumeManagerEntry->VolumeManagerFileObject = NULL;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(VolumeManagerEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        VolumeManagerEntry->RefCount++;
    } else {
        if (!VolumeManagerEntry->RefCount) {
            VolumeManagerEntry->VolumeManager = NULL;
            ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
            VolumeManagerEntry->VolumeManagerFileObject = NULL;
        }
    }

    return status;
}

NTSTATUS
PmFindPartition(
    IN  PDEVICE_EXTENSION       Extension,
    IN  ULONG                   PartitionNumber,
    OUT PPARTITION_LIST_ENTRY*  Partition
    )

{
    PLIST_ENTRY             l;
    PPARTITION_LIST_ENTRY   partition;
    KEVENT                  event;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   deviceNumber;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;

    ASSERT(Partition);
    *Partition = NULL;

    for (l = Extension->PartitionList.Flink; l != &Extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                            partition->TargetObject, NULL, 0,
                                            &deviceNumber,
                                            sizeof(deviceNumber), FALSE,
                                            &event, &ioStatus);
        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(partition->TargetObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (NT_SUCCESS(status) &&
            PartitionNumber == deviceNumber.PartitionNumber) {

            *Partition = partition;
            return status;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
PmChangePartitionIoctl(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PPARTITION_LIST_ENTRY   Partition,
    IN  ULONG                   IoctlCode
    )

{
    PVOLMGR_LIST_ENTRY              volumeEntry;
    KEVENT                          event;
    VOLMGR_PARTITION_INFORMATION    input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;
    NTSTATUS                        status;

    volumeEntry = Partition->VolumeManagerEntry;
    if (!volumeEntry) {
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    input.PartitionDeviceObject = Partition->TargetObject;
    input.WholeDiskPdo = Partition->WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(
            IoctlCode, volumeEntry->VolumeManager, &input, sizeof(input),
            NULL, 0, TRUE, &event, &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(volumeEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}

NTSTATUS
PmStartPartition(
    IN  PDEVICE_OBJECT  Partition
    )

{
    PIRP                    irp;
    KEVENT                  event;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                status;

    irp = IoAllocateIrp(Partition->StackSize, FALSE);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_START_DEVICE;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IoSetCompletionRoutine(irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);

    IoCallDriver(Partition, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = irp->IoStatus.Status;

    IoFreeIrp(irp);

    return status;
}

NTSTATUS
PmQueryDeviceRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine processes the query device relations request.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    newLayout;
    KEVENT                          event;
    PDEVICE_RELATIONS               deviceRelations;
    PLIST_ENTRY                     l, b;
    PPARTITION_LIST_ENTRY           partition;
    ULONG                           i;
    PDO_EXTENSION                   driverExtension;
    PVOLMGR_LIST_ENTRY              volmgrEntry;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(Extension->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        return Irp->IoStatus.Status;
    }

    deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;

    if (Extension->SignaturesNotChecked) {

        status = PmReadPartitionTableEx(Extension->TargetObject,
                                        &newLayout);

        if (NT_SUCCESS(status)) {

            KeWaitForSingleObject(&Extension->DriverExtension->Mutex,
                                  Executive, KernelMode, FALSE, NULL);
            PmAddSignatures(Extension, newLayout);
            Extension->SignaturesNotChecked = FALSE;
            KeReleaseMutex(&Extension->DriverExtension->Mutex, FALSE);

            ExFreePool(newLayout);
        }
    }

    //
    // First notify clients of partitions that have gone away.
    //

    driverExtension = Extension->DriverExtension;

    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);


    for (l = Extension->PartitionList.Flink; l != &Extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        for (i = 0; i < deviceRelations->Count; i++) {
            if (partition->TargetObject == deviceRelations->Objects[i]) {
                break;
            }
        }

        if (i < deviceRelations->Count) {
            continue;
        }

        PmTakePartition(partition->VolumeManagerEntry,
                        partition->TargetObject, partition->WholeDiskPdo);

        //
        // We're pretending to be pnp.  Send a remove to the partition
        // object so it can delete it.
        //

        PmRemovePartition(partition);

        b = l->Blink;
        RemoveEntryList(l);
        l = b;

        ExFreePool(partition);
    }

    //
    // Then notify clients of new partitions.
    //

    for (i = 0; i < deviceRelations->Count; i++) {

        for (l = Extension->PartitionList.Flink;
             l != &Extension->PartitionList; l = l->Flink) {

            partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

            if (deviceRelations->Objects[i] == partition->TargetObject) {
                break;
            }
        }

        if (l != &Extension->PartitionList) {
            
            //
            // Must attempt to start the partition even if it is in our list
            // because it may be stopped and need restarting.
            //

            PmStartPartition(deviceRelations->Objects[i]);
            continue;
        }

        if (Extension->DriverExtension->PastReinit) {

            //
            // Now that this partition is owned by the partition manager
            // make sure that nobody can open it another way.
            //

            deviceRelations->Objects[i]->Flags |= DO_DEVICE_INITIALIZING;
        }

        status = PmStartPartition(deviceRelations->Objects[i]);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        partition = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(PARTITION_LIST_ENTRY),
                                          PARTMGR_TAG_PARTITION_ENTRY);
        if (!partition) {
            continue;
        }

        partition->TargetObject = deviceRelations->Objects[i];
        partition->WholeDiskPdo = Extension->Pdo;
        partition->VolumeManagerEntry = NULL;
        InsertHeadList(&Extension->PartitionList, &partition->ListEntry);

        if (Extension->IsRedundantPath) {
            continue;
        }

        for (l = driverExtension->VolumeManagerList.Flink;
             l != &driverExtension->VolumeManagerList; l = l->Flink) {

            volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);

            status = PmGivePartition(volmgrEntry,
                                     partition->TargetObject,
                                     partition->WholeDiskPdo);

            if (NT_SUCCESS(status)) {
                partition->VolumeManagerEntry = volmgrEntry;
                break;
            }
        }
    }

    KeReleaseMutex(&driverExtension->Mutex, FALSE);

    deviceRelations->Count = 0;

    return Irp->IoStatus.Status;
}

VOID
PmTakeWholeDisk(
    IN  PVOLMGR_LIST_ENTRY  VolumeManagerEntry,
    IN  PDEVICE_OBJECT      WholeDiskPdo
    )

/*++

Routine Description:

    This routine alerts the volume manager that the given PDO is going away.

Arguments:

    VolumeManager   - Supplies a volume manager.

    WholeDiskPdo    - Supplies the whole disk PDO.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                        status;
    KEVENT                          event;
    VOLMGR_WHOLE_DISK_INFORMATION   input;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    if (!VolumeManagerEntry) {
        return;
    }

    if (!VolumeManagerEntry->RefCount) {
        status = IoGetDeviceObjectPointer(
                 &VolumeManagerEntry->VolumeManagerName, FILE_READ_DATA,
                 &VolumeManagerEntry->VolumeManagerFileObject,
                 &VolumeManagerEntry->VolumeManager);
        if (!NT_SUCCESS(status)) {
            return;
        }
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_VOLMGR_WHOLE_DISK_REMOVED,
                                        VolumeManagerEntry->VolumeManager,
                                        &input, sizeof(input), NULL, 0, TRUE,
                                        &event, &ioStatus);
    if (!irp) {
        if (!VolumeManagerEntry->RefCount) {
            VolumeManagerEntry->VolumeManager = NULL;
            ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
            VolumeManagerEntry->VolumeManagerFileObject = NULL;
        }
        return;
    }

    status = IoCallDriver(VolumeManagerEntry->VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    if (!VolumeManagerEntry->RefCount) {
        VolumeManagerEntry->VolumeManager = NULL;
        ObDereferenceObject(VolumeManagerEntry->VolumeManagerFileObject);
        VolumeManagerEntry->VolumeManagerFileObject = NULL;
    }
}

NTSTATUS
PmNotifyPartitions(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              Irp
    )

/*++

Routine Description:

    This routine notifies each partition stolen by the partmgr that it is
    about to be removed.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    PLIST_ENTRY             l;
    PPARTITION_LIST_ENTRY   partition;
    NTSTATUS                status = STATUS_SUCCESS;
    KEVENT event;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    KeWaitForSingleObject(&Extension->DriverExtension->Mutex, Executive,
                          KernelMode, FALSE, NULL);

    for(l = Extension->PartitionList.Flink;
        l != &(Extension->PartitionList);
        l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               PmSignalCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        status = IoCallDriver(partition->TargetObject, Irp);

        if(status == STATUS_PENDING) {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = Irp->IoStatus.Status;
        }

        if(!NT_SUCCESS(status)) {
            break;
        }
    }

    KeReleaseMutex(&Extension->DriverExtension->Mutex, FALSE);

    return status;
}

NTSTATUS
PmRemoveDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine processes the query device relations request.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PDO_EXTENSION                   driverExtension = Extension->DriverExtension;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;
    PLIST_ENTRY                     l;
    PPARTITION_LIST_ENTRY           partition;
    PVOLMGR_LIST_ENTRY              volmgrEntry;

    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);

    if (Extension->RemoveProcessed) {
        KeReleaseMutex(&driverExtension->Mutex, FALSE);
        return STATUS_SUCCESS;
    }

    Extension->RemoveProcessed = TRUE;

    Extension->IsStarted = FALSE;

    PmAddSignatures(Extension, NULL);

    for (l = Extension->PartitionList.Flink;
         l != &Extension->PartitionList; l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        PmTakePartition(partition->VolumeManagerEntry,
                        partition->TargetObject, NULL);
    }

    status = PmNotifyPartitions(Extension, Irp);

    ASSERT(NT_SUCCESS(status));

    while (!IsListEmpty(&Extension->PartitionList)) {
        l = RemoveHeadList(&Extension->PartitionList);
        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        ExFreePool(partition);
    }

    for (l = driverExtension->VolumeManagerList.Flink;
         l != &driverExtension->VolumeManagerList; l = l->Flink) {

        volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
        PmTakeWholeDisk(volmgrEntry, Extension->Pdo);
    }

    RemoveEntryList(&Extension->ListEntry);

    if (Extension->WmilibContext != NULL) { // just to be safe
        IoWMIRegistrationControl(Extension->DeviceObject,
                                 WMIREG_ACTION_DEREGISTER);
        ExFreePool(Extension->WmilibContext);
        Extension->WmilibContext = NULL;
        PmWmiCounterDisable(&Extension->PmWmiCounterContext,
                            TRUE, TRUE);
        Extension->CountersEnabled = FALSE;
    }

    KeReleaseMutex(&driverExtension->Mutex, FALSE);

    return status;
}

VOID
PmPowerNotify (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            PublicWorkItem
    )

/*++

Routine Description:

    This routine notifies volume managers about changes in
    the power state of the given disk.

Arguments:

    DeviceObject    - Supplies the device object.

    PublicWorkItem  - Supplies the public work item

Return Value:

    None    

--*/

{
    PDEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PDO_EXTENSION           driverExtension = deviceExtension->DriverExtension;
    KEVENT                  event;
    KIRQL                   irql;
    LIST_ENTRY              q;
    PLIST_ENTRY             l;
    BOOLEAN                 empty;
    PPM_POWER_WORK_ITEM     privateWorkItem; 
    PPARTITION_LIST_ENTRY   partition;
    VOLMGR_POWER_STATE      input;
    PIRP                    irp;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
        
    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (IsListEmpty(&deviceExtension->PowerQueue)) {
        empty = TRUE;
    } else {
        empty = FALSE;
        q = deviceExtension->PowerQueue;
        InitializeListHead(&deviceExtension->PowerQueue);
    }
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    if (empty) {
        KeReleaseMutex(&driverExtension->Mutex, FALSE);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        IoFreeWorkItem((PIO_WORKITEM) PublicWorkItem);
        return;
    }

    q.Flink->Blink = &q;
    q.Blink->Flink = &q;
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    while (!IsListEmpty(&q)) {

        l = RemoveHeadList(&q);
        privateWorkItem = CONTAINING_RECORD(l, PM_POWER_WORK_ITEM, ListEntry);

        for (l = deviceExtension->PartitionList.Flink; 
             l != &deviceExtension->PartitionList; l = l->Flink) {

            partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
            if (!partition->VolumeManagerEntry) {
                continue;
            }
        
            input.PartitionDeviceObject = partition->TargetObject;
            input.WholeDiskPdo = partition->WholeDiskPdo;
            input.PowerState = privateWorkItem->DevicePowerState;

            irp = IoBuildDeviceIoControlRequest(
                                    IOCTL_INTERNAL_VOLMGR_SET_POWER_STATE,
                                    partition->VolumeManagerEntry->VolumeManager,
                                    &input, sizeof(input), NULL, 0, TRUE,
                                    &event, &ioStatus);
            if (!irp) {
                continue;
            }
            status = IoCallDriver(partition->VolumeManagerEntry->VolumeManager, 
                                  irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            }
            KeClearEvent(&event);
        }

        ExFreePool(privateWorkItem);        
    }
            
    KeReleaseMutex(&driverExtension->Mutex, FALSE);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
    IoFreeWorkItem((PIO_WORKITEM) PublicWorkItem);    
} 

NTSTATUS
PmPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )

/*++

Routine Description:

    This routine handles completion of an IRP_MN_SET_POWER irp.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

    Context         - Not used.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation(Irp);
    PIO_WORKITEM        publicWorkItem;
    PPM_POWER_WORK_ITEM privateWorkItem; 
    KIRQL               irql;

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER &&
           irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
    
    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        return STATUS_SUCCESS;
    }

    publicWorkItem = IoAllocateWorkItem(DeviceObject);
    if (!publicWorkItem) {
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        return STATUS_SUCCESS;
    }
    
    privateWorkItem = (PPM_POWER_WORK_ITEM) ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(PM_POWER_WORK_ITEM),
                                          PARTMGR_TAG_POWER_WORK_ITEM);
    if (!privateWorkItem) {
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
        IoFreeWorkItem(publicWorkItem);
        return STATUS_SUCCESS;
    }
    
    privateWorkItem->DevicePowerState = 
                        irpStack->Parameters.Power.State.DeviceState;
    
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    InsertTailList(&deviceExtension->PowerQueue, &privateWorkItem->ListEntry);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
    
    IoQueueWorkItem(publicWorkItem, PmPowerNotify, DelayedWorkQueue, 
                    publicWorkItem);
    
    PoStartNextPowerIrp(Irp);
    return STATUS_SUCCESS;        
}

NTSTATUS
PmPower(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION   deviceExtension = 
                        (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS            status;
       
    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, NULL);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
    
    if (irpSp->MinorFunction == IRP_MN_SET_POWER &&
        irpSp->Parameters.Power.Type == DevicePowerState) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, PmPowerCompletion, NULL, TRUE, 
                               TRUE, TRUE);
        IoMarkIrpPending(Irp);
        PoCallDriver(deviceExtension->TargetObject, Irp);
        return STATUS_PENDING;
    }   
    
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);    
    status = PoCallDriver(deviceExtension->TargetObject, Irp);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, NULL);
    return status;
}

NTSTATUS
PmQueryRemovalRelations(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP                Irp
    )

/*++

Routine Description:

    This routine processes the query removal relations request.

Arguments:

    Extension   - Supplies the device extension.

    Irp         - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS                status;
    KEVENT                  event;
    PDEVICE_RELATIONS       deviceRelations;
    PLIST_ENTRY             l, b;
    PPARTITION_LIST_ENTRY   partition;
    ULONG                   i;
    PDO_EXTENSION           driverExtension;
    PVOLMGR_LIST_ENTRY      volmgrEntry;

    status = Irp->IoStatus.Status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(Extension->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        Irp->IoStatus.Information = 0;
        if (status != Irp->IoStatus.Status) {
            return Irp->IoStatus.Status;
        }
    }

    return PmBuildDependantVolumeRelations(Extension,
           &((PDEVICE_RELATIONS) Irp->IoStatus.Information));
}

BOOLEAN
PmIsRedundantPath(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  ULONG               Signature,
    IN  GUID*               Guid
    )

{
    PDO_EXTENSION           driverExtension = Extension->DriverExtension;
    PDEVICE_EXTENSION       extension = WinningExtension;
    PGUID_TABLE_ENTRY       guidEntry;
    PSIGNATURE_TABLE_ENTRY  sigEntry;
    KEVENT                  event;
    PIRP                    irp;
    DISK_GEOMETRY           geometry, geometry2;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;
    ULONG                   bufferSize;
    ULONG                   readSize;
    PVOID                   buffer;
    LARGE_INTEGER           byteOffset;
    PULONG                  signature;
    BOOLEAN                 isRedundant;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        Extension->TargetObject, NULL, 0,
                                        &geometry, sizeof(geometry), FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return FALSE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        extension->TargetObject, NULL, 0,
                                        &geometry2, sizeof(geometry2), FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        return FALSE;
    }
    status = IoCallDriver(extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    if (geometry2.BytesPerSector > geometry.BytesPerSector) {
        geometry.BytesPerSector = geometry2.BytesPerSector;
    }

    byteOffset.QuadPart = 0;
    readSize = 512;
    if (readSize < geometry.BytesPerSector) {
        readSize = geometry.BytesPerSector;
    }

    bufferSize = 2*readSize;
    buffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize < PAGE_SIZE ?
                                   PAGE_SIZE : bufferSize,
                                   PARTMGR_TAG_IOCTL_BUFFER);
    if (!buffer) {
        return FALSE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, Extension->TargetObject,
                                       buffer, readSize, &byteOffset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return FALSE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return FALSE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, extension->TargetObject,
                                       (PCHAR) buffer + readSize, readSize,
                                       &byteOffset, &event, &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return FALSE;
    }
    status = IoCallDriver(extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return FALSE;
    }

    if (RtlCompareMemory(buffer, (PCHAR) buffer + readSize, readSize) !=
                         readSize) {

        ExFreePool(buffer);
        return FALSE;
    }

    signature = (PULONG) ((PCHAR) buffer + 0x1B8);
    (*signature)++;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, Extension->TargetObject,
                                       buffer, readSize, &byteOffset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return FALSE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return FALSE;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_READ, extension->TargetObject,
                                       (PCHAR) buffer + readSize, readSize,
                                       &byteOffset, &event, &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return FALSE;
    }
    status = IoCallDriver(extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return FALSE;
    }

    if (RtlCompareMemory(buffer, (PCHAR) buffer + readSize, readSize) !=
                         readSize) {

        ExFreePool(buffer);
        return FALSE;
    }

    (*signature)--;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_WRITE, Extension->TargetObject,
                                       buffer, readSize, &byteOffset, &event,
                                       &ioStatus);
    if (!irp) {
        ExFreePool(buffer);
        return TRUE;
    }
    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        return TRUE;
    }

    ExFreePool(buffer);

    return TRUE;
}

VOID
PmLogError(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PDEVICE_EXTENSION   WinningExtension,
    IN  NTSTATUS            SpecificIoStatus
    )

{
    KEVENT                                  event;
    PIRP                                    irp;
    STORAGE_DEVICE_NUMBER                   deviceNumber, winningDeviceNumber;
    IO_STATUS_BLOCK                         ioStatus;
    NTSTATUS                                status;
    WCHAR                                   buffer1[30], buffer2[30];
    UNICODE_STRING                          number, winningNumber;
    ULONG                                   extraSpace;
    PIO_ERROR_LOG_PACKET                    errorLogPacket;
    PWCHAR                                  p;
    GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION  diskCloneArrivalInfo;
    UCHAR                                   notificationBuffer[sizeof(TARGET_DEVICE_CUSTOM_NOTIFICATION) + sizeof(GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION)];
    PTARGET_DEVICE_CUSTOM_NOTIFICATION      notification = (PTARGET_DEVICE_CUSTOM_NOTIFICATION) notificationBuffer;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                        Extension->TargetObject, NULL, 0,
                                        &deviceNumber, sizeof(deviceNumber),
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(Extension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                        WinningExtension->TargetObject, NULL,
                                        0, &winningDeviceNumber,
                                        sizeof(winningDeviceNumber),
                                        FALSE, &event, &ioStatus);
    if (!irp) {
        return;
    }

    status = IoCallDriver(WinningExtension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return;
    }

    swprintf(buffer1, L"%d", deviceNumber.DeviceNumber);
    RtlInitUnicodeString(&number, buffer1);
    swprintf(buffer2, L"%d", winningDeviceNumber.DeviceNumber);
    RtlInitUnicodeString(&winningNumber, buffer2);
    extraSpace = number.Length + winningNumber.Length + 2*sizeof(WCHAR);
    extraSpace += sizeof(IO_ERROR_LOG_PACKET);
    if (extraSpace > 0xFF) {
        return;
    }

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(Extension->DeviceObject,
                                             (UCHAR) extraSpace);
    if (!errorLogPacket) {
        return;
    }

    errorLogPacket->ErrorCode = SpecificIoStatus;
    errorLogPacket->SequenceNumber = 0;
    errorLogPacket->FinalStatus = 0;
    errorLogPacket->UniqueErrorValue = 0;
    errorLogPacket->DumpDataSize = 0;
    errorLogPacket->RetryCount = 0;
    errorLogPacket->NumberOfStrings = 2;
    errorLogPacket->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET));
    RtlCopyMemory(p, number.Buffer, number.Length);
    p[number.Length/sizeof(WCHAR)] = 0;
    p = (PWCHAR) ((PCHAR) errorLogPacket + sizeof(IO_ERROR_LOG_PACKET) +
                  number.Length + sizeof(WCHAR));
    RtlCopyMemory(p, winningNumber.Buffer, winningNumber.Length);
    p[winningNumber.Length/sizeof(WCHAR)] = 0;

    IoWriteErrorLogEntry(errorLogPacket);

    if (SpecificIoStatus == IO_WARNING_DUPLICATE_SIGNATURE) {
        diskCloneArrivalInfo.DiskNumber = deviceNumber.DeviceNumber;
        notification->Version = 1;
        notification->Size = (USHORT)
                             (FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION,
                                           CustomDataBuffer) +
                              sizeof(diskCloneArrivalInfo));
        RtlCopyMemory(&notification->Event, &GUID_IO_DISK_CLONE_ARRIVAL,
                      sizeof(GUID_IO_DISK_CLONE_ARRIVAL));
        notification->FileObject = NULL;
        notification->NameBufferOffset = -1;
        RtlCopyMemory(notification->CustomDataBuffer, &diskCloneArrivalInfo,
                      sizeof(diskCloneArrivalInfo));

        IoReportTargetDeviceChangeAsynchronous(WinningExtension->Pdo,
                                               notification, NULL, NULL);
    }
}

ULONG
PmQueryRegistrySignature(
    )

/*++

Routine Description:

    This routine checks a registry value for an MBR signature to be used
    for the bad signature case.  This is to facilitate OEM pre-install.

Arguments:

    None.

Return Value:

    A valid signature or 0.

--*/

{
    ULONG                       zero, signature;
    RTL_QUERY_REGISTRY_TABLE    queryTable[2];
    NTSTATUS                    status;

    zero = 0;
    signature = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = L"BootDiskSig";
    queryTable[0].EntryContext = &signature;
    queryTable[0].DefaultType = REG_DWORD;
    queryTable[0].DefaultData = &zero;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\System\\Setup",
                                    queryTable, NULL, NULL);
    if (!NT_SUCCESS(status)) {
        signature = zero;
    }

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\Setup",
                           L"BootDiskSig");

    return signature;
}

VOID
PmAddSignatures(
    IN  PDEVICE_EXTENSION               Extension,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    Layout
    )

/*++

Routine Description:

    This routine adds the disk and partition signature to their
    respective tables.  If a collision is detected, the signatures are
    changed and written back out.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PDO_EXTENSION           driverExtension = Extension->DriverExtension;
    PLIST_ENTRY             l;
    PSIGNATURE_TABLE_ENTRY  s;
    PGUID_TABLE_ENTRY       g;
    SIGNATURE_TABLE_ENTRY   sigEntry;
    GUID_TABLE_ENTRY        guidEntry;
    NTSTATUS                status;
    PVOID                   nodeOrParent, nodeOrParent2;
    TABLE_SEARCH_RESULT     searchResult, searchResult2;
    UUID                    uuid;
    PULONG                  p;
    ULONG                   i;

    while (!IsListEmpty(&Extension->SignatureList)) {
        l = RemoveHeadList(&Extension->SignatureList);
        s = CONTAINING_RECORD(l, SIGNATURE_TABLE_ENTRY, ListEntry);
        RtlDeleteElementGenericTable(&driverExtension->SignatureTable, s);
    }

    while (!IsListEmpty(&Extension->GuidList)) {
        l = RemoveHeadList(&Extension->GuidList);
        g = CONTAINING_RECORD(l, GUID_TABLE_ENTRY, ListEntry);
        RtlDeleteElementGenericTable(&driverExtension->GuidTable, g);
    }

    if (!Layout) {
        return;
    }

    if (Layout->PartitionStyle == PARTITION_STYLE_MBR) {

        if (!Layout->PartitionCount && !Layout->Mbr.Signature) {
            // RAW disk.  No signature to validate.
            return;
        }

        if (Layout->PartitionCount > 0 &&
            Layout->PartitionEntry[0].PartitionLength.QuadPart > 0 &&
            Layout->PartitionEntry[0].StartingOffset.QuadPart == 0) {

            // Super floppy.  No signature to validate.
            return;
        }

        sigEntry.Signature = Layout->Mbr.Signature;
        s = RtlLookupElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                &nodeOrParent, &searchResult);
        if (s || !sigEntry.Signature ||
            Extension->DriverExtension->BootDiskSig) {

            if (s) {
                if (PmIsRedundantPath(Extension, s->Extension,
                                      sigEntry.Signature, NULL)) {

                    PmLogError(Extension, s->Extension,
                               IO_WARNING_DUPLICATE_PATH);

                    Extension->IsRedundantPath = TRUE;
                    return;
                }

                PmLogError(Extension, s->Extension,
                           IO_WARNING_DUPLICATE_SIGNATURE);
            }

            if (Extension->DriverExtension->BootDiskSig) {
                Layout->Mbr.Signature =
                        Extension->DriverExtension->BootDiskSig;
                Extension->DriverExtension->BootDiskSig = 0;
            } else {
                status = ExUuidCreate(&uuid);
                if (!NT_SUCCESS(status)) {
                    return;
                }

                p = (PULONG) &uuid;
                Layout->Mbr.Signature = p[0] ^ p[1] ^ p[2] ^ p[3];
            }
            sigEntry.Signature = Layout->Mbr.Signature;

            if (driverExtension->PastReinit) {
                status = PmWritePartitionTableEx(Extension->TargetObject,
                                                 Layout);
                if (!NT_SUCCESS(status)) {
                    return;
                }
            } else {
                Extension->DiskSignature = Layout->Mbr.Signature;
            }

            RtlLookupElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                &nodeOrParent, &searchResult);
        }

        s = RtlInsertElementGenericTableFull(&driverExtension->SignatureTable,
                                             &sigEntry, sizeof(sigEntry), NULL,
                                             nodeOrParent, searchResult);
        if (!s) {
            return;
        }

        InsertTailList(&Extension->SignatureList, &s->ListEntry);
        s->Extension = Extension;

        return;
    }

    ASSERT(Layout->PartitionStyle == PARTITION_STYLE_GPT);

    if (Layout->PartitionStyle != PARTITION_STYLE_GPT) {
        return;
    }

    if (Extension->DriverExtension->PastReinit) {

        p = (PULONG) &Layout->Gpt.DiskId;
        sigEntry.Signature = p[0] ^ p[1] ^ p[2] ^ p[3];
        guidEntry.Guid = Layout->Gpt.DiskId;

        s = RtlLookupElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                &nodeOrParent, &searchResult);
        g = RtlLookupElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                &nodeOrParent2, &searchResult2);
        if (s || g || !sigEntry.Signature) {

            if (g) {
                if (PmIsRedundantPath(Extension, g->Extension, 0,
                                      &guidEntry.Guid)) {

                    PmLogError(Extension, g->Extension,
                               IO_WARNING_DUPLICATE_PATH);

                    Extension->IsRedundantPath = TRUE;
                    return;
                }

                PmLogError(Extension, g->Extension,
                           IO_WARNING_DUPLICATE_SIGNATURE);
            }

            status = ExUuidCreate(&uuid);
            if (!NT_SUCCESS(status)) {
                return;
            }

            Layout->Gpt.DiskId = uuid;
            status = PmWritePartitionTableEx(Extension->TargetObject, Layout);
            if (!NT_SUCCESS(status)) {
                return;
            }

            p = (PULONG) &Layout->Gpt.DiskId;
            sigEntry.Signature = p[0] ^ p[1] ^ p[2] ^ p[3];
            guidEntry.Guid = Layout->Gpt.DiskId;

            RtlLookupElementGenericTableFull(
                    &driverExtension->SignatureTable, &sigEntry,
                    &nodeOrParent, &searchResult);
            RtlLookupElementGenericTableFull(
                    &driverExtension->GuidTable, &guidEntry,
                    &nodeOrParent2, &searchResult2);
        }

        s = RtlInsertElementGenericTableFull(
                &driverExtension->SignatureTable, &sigEntry,
                sizeof(sigEntry), NULL, nodeOrParent, searchResult);
        if (!s) {
            return;
        }

        InsertTailList(&Extension->SignatureList, &s->ListEntry);
        s->Extension = Extension;

        g = RtlInsertElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                sizeof(guidEntry), NULL, nodeOrParent2, searchResult2);
        if (!g) {
            return;
        }

        InsertTailList(&Extension->GuidList, &g->ListEntry);
        g->Extension = Extension;
    }

    for (i = 0; i < Layout->PartitionCount; i++) {

        p = (PULONG) &Layout->PartitionEntry[i].Gpt.PartitionId;
        sigEntry.Signature = p[0] | p[1] | p[2] | p[3];
        guidEntry.Guid = Layout->PartitionEntry[i].Gpt.PartitionId;

        g = RtlLookupElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                &nodeOrParent, &searchResult);
        if (g || !sigEntry.Signature) {

            status = ExUuidCreate(&uuid);
            if (!NT_SUCCESS(status)) {
                return;
            }

            Layout->PartitionEntry[i].Gpt.PartitionId = uuid;
            status = PmWritePartitionTableEx(Extension->TargetObject, Layout);
            if (!NT_SUCCESS(status)) {
                return;
            }

            guidEntry.Guid = Layout->PartitionEntry[i].Gpt.PartitionId;

            RtlLookupElementGenericTableFull(
                    &driverExtension->GuidTable, &guidEntry,
                    &nodeOrParent, &searchResult);
        }

        g = RtlInsertElementGenericTableFull(
                &driverExtension->GuidTable, &guidEntry,
                sizeof(guidEntry), NULL, nodeOrParent, searchResult);
        if (!g) {
            return;
        }

        InsertTailList(&Extension->GuidList, &g->ListEntry);
        g->Extension = Extension;
    }
}

NTSTATUS
PmPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT                          event;
    NTSTATUS                        status, status2;
    PDEVICE_OBJECT                  targetObject;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;

    if (irpSp->MinorFunction == IRP_MN_DEVICE_USAGE_NOTIFICATION &&
        irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

        ULONG count;
        BOOLEAN setPagable;

        //
        // synchronize these irps.
        //

        KeWaitForSingleObject(&extension->PagingPathCountEvent,
                              Executive, KernelMode, FALSE, NULL);

        //
        // if removing last paging device, need to set DO_POWER_PAGABLE
        // bit here, and possible re-set it below on failure.
        //

        setPagable = FALSE;
        if (!irpSp->Parameters.UsageNotification.InPath &&
            extension->PagingPathCount == 0 ) {

            //
            // removing a paging file. if last removal,
            // must have DO_POWER_PAGABLE bits set
            //

            if (extension->PagingPathCount == 0) {
                if (!(DeviceObject->Flags & DO_POWER_INRUSH)) {
                    DeviceObject->Flags |= DO_POWER_PAGABLE;
                    setPagable = TRUE;
                }
            }

        }

        //
        // send the irp synchronously
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
        status = IoCallDriver(extension->TargetObject, Irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;
        }

        //
        // now deal with the failure and success cases.
        // note that we are not allowed to fail the irp
        // once it is sent to the lower drivers.
        //

        if (NT_SUCCESS(status)) {

            IoAdjustPagingPathCount(
                &extension->PagingPathCount,
                irpSp->Parameters.UsageNotification.InPath);

            if (irpSp->Parameters.UsageNotification.InPath) {

                if (extension->PagingPathCount == 1) {
                    DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                }
            }

        } else {

            //
            // cleanup the changes done above
            //

            if (setPagable == TRUE) {
                DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                setPagable = FALSE;
            }

        }

        //
        // set the event so the next one can occur.
        //

        KeSetEvent(&extension->PagingPathCountEvent,
                   IO_NO_INCREMENT, FALSE);

        //
        // and complete the irp
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    if (extension->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(extension->TargetObject, Irp);
    }

    switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            switch (irpSp->Parameters.QueryDeviceRelations.Type) {
                case BusRelations:
                    status = PmQueryDeviceRelations(extension, Irp);
                    break;

                case RemovalRelations:
                    status = PmQueryRemovalRelations(extension, Irp);
                    break;

                default:
                    IoSkipCurrentIrpStackLocation(Irp);
                    return IoCallDriver(extension->TargetObject, Irp);

            }
            break;

        case IRP_MN_START_DEVICE:
            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, PmSignalCompletion, &event,
                                   TRUE, TRUE, TRUE);
            IoCallDriver(extension->TargetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = Irp->IoStatus.Status;

            if (!NT_SUCCESS(status)) {
                break;
            }

            if (extension->TargetObject->Characteristics&
                FILE_REMOVABLE_MEDIA) {

                break;
            }

            status2 = PmReadPartitionTableEx(extension->TargetObject,
                                             &layout);

            KeWaitForSingleObject(&extension->DriverExtension->Mutex,
                                  Executive, KernelMode, FALSE, NULL);
            extension->IsStarted = TRUE;
            if (NT_SUCCESS(status2)) {
                PmAddSignatures(extension, layout);
                ExFreePool(layout);
            } else {
                extension->SignaturesNotChecked = TRUE;
            }
            KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);

            //
            // Register its existence with WMI
            //
            PmRegisterDevice(DeviceObject);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            status = PmNotifyPartitions(extension, Irp);
            if (!NT_SUCCESS(status)) {
                break;
            }

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(extension->TargetObject, Irp);

        case IRP_MN_SURPRISE_REMOVAL:
        case IRP_MN_REMOVE_DEVICE:

            //
            // Notify all the children of their imminent removal.
            //

            PmRemoveDevice(extension, Irp);
            targetObject = extension->TargetObject;

            if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                status = IoAcquireRemoveLock (&extension->RemoveLock, Irp);
                ASSERT(NT_SUCCESS(status));
                IoReleaseRemoveLockAndWait(&extension->RemoveLock, Irp);
                IoDetachDevice(targetObject);
                IoDeleteDevice(extension->DeviceObject);
            }

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(targetObject, Irp);

        default:
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(extension->TargetObject, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine creates and initializes a new FDO for the corresponding
    PDO.

Arguments:

    DriverObject            - Supplies the FTDISK driver object.

    PhysicalDeviceObject    - Supplies the physical device object.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT      attachedDevice;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   extension;

    attachedDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);
    if (attachedDevice) {
        if (attachedDevice->Characteristics&FILE_REMOVABLE_MEDIA) {
            ObDereferenceObject(attachedDevice);
            return STATUS_SUCCESS;
        }
        ObDereferenceObject(attachedDevice);
    }

    status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                            NULL, FILE_DEVICE_DISK, 0, FALSE, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // the storage stack explicitly requires DO_POWER_PAGABLE to be
    // set in all filter drivers *unless* DO_POWER_INRUSH is set.
    // this is true even if the attached device doesn't set DO_POWER_PAGABLE
    //
    if (attachedDevice->Flags & DO_POWER_INRUSH) {
        deviceObject->Flags |= DO_POWER_INRUSH;
    } else {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));
    extension->DeviceObject = deviceObject;
    extension->DriverExtension = IoGetDriverObjectExtension(DriverObject,
                                                            PmAddDevice);
    extension->TargetObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    if (!extension->TargetObject) {
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
    extension->Pdo = PhysicalDeviceObject;
    InitializeListHead(&extension->PartitionList);
    KeInitializeEvent(&extension->PagingPathCountEvent,
                      SynchronizationEvent, TRUE);
    InitializeListHead(&extension->SignatureList);
    InitializeListHead(&extension->GuidList);

    KeWaitForSingleObject(&extension->DriverExtension->Mutex, Executive,
                          KernelMode, FALSE, NULL);
    InsertTailList(&extension->DriverExtension->DeviceExtensionList,
                   &extension->ListEntry);
    KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);

    deviceObject->AlignmentRequirement =
            extension->TargetObject->AlignmentRequirement;

    extension->PhysicalDeviceName.Buffer
            = extension->PhysicalDeviceNameBuffer;

    // Allocate WMI library context

    extension->WmilibContext =
        ExAllocatePoolWithTag(PagedPool, sizeof(WMILIB_CONTEXT),
                                          PARTMGR_TAG_PARTITION_ENTRY);
    if (extension->WmilibContext != NULL)
    {
        RtlZeroMemory(extension->WmilibContext, sizeof(WMILIB_CONTEXT));
        extension->WmilibContext->GuidCount          = DiskperfGuidCount;
        extension->WmilibContext->GuidList           = DiskperfGuidList;
        extension->WmilibContext->QueryWmiRegInfo    = PmQueryWmiRegInfo;
        extension->WmilibContext->QueryWmiDataBlock  = PmQueryWmiDataBlock;
        extension->WmilibContext->WmiFunctionControl = PmWmiFunctionControl;
    }

    KeInitializeSpinLock(&extension->SpinLock);
    InitializeListHead(&extension->PowerQueue);    

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    IoInitializeRemoveLock (&extension->RemoveLock, PARTMGR_TAG_REMOVE_LOCK,
                            2, 5); 

    return STATUS_SUCCESS;
}

VOID
PmUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine unloads.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    PDO_EXTENSION   driverExtension;
    PDEVICE_OBJECT  deviceObject;

    while (deviceObject = DriverObject->DeviceObject) {
        IoDeleteDevice(deviceObject);
    }

    driverExtension = IoGetDriverObjectExtension(DriverObject, PmAddDevice);
    if (driverExtension) {
        IoUnregisterPlugPlayNotification(driverExtension->NotificationEntry);
    }
}

NTSTATUS
PmVolumeManagerNotification(
    IN  PVOID   NotificationStructure,
    IN  PVOID   DriverExtension
    )

/*++

Routine Description:

    This routine is called whenever a volume comes or goes.

Arguments:

    NotificationStructure   - Supplies the notification structure.

    RootExtension           - Supplies the root extension.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION   notification = (PDEVICE_INTERFACE_CHANGE_NOTIFICATION) NotificationStructure;
    PDO_EXTENSION                           driverExtension = (PDO_EXTENSION) DriverExtension;
    PVOLMGR_LIST_ENTRY                      volmgrEntry;
    NTSTATUS                                status;
    PLIST_ENTRY                             l, ll;
    PDEVICE_EXTENSION                       extension;
    PPARTITION_LIST_ENTRY                   partition;
    PMWMICOUNTERLIB_CONTEXT                 input;
    PIRP                                    irp;
    KEVENT                                  event;
    IO_STATUS_BLOCK                         ioStatus;
    PFILE_OBJECT                            fileObject;
    PDEVICE_OBJECT                          deviceObject;

    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);

    if (IsEqualGUID(&notification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        for (l = driverExtension->VolumeManagerList.Flink;
             l != &driverExtension->VolumeManagerList; l = l->Flink) {

            volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
            if (RtlEqualUnicodeString(notification->SymbolicLinkName,
                                      &volmgrEntry->VolumeManagerName,
                                      TRUE)) {

                KeReleaseMutex(&driverExtension->Mutex, FALSE);
                return STATUS_SUCCESS;
            }
        }

        volmgrEntry = (PVOLMGR_LIST_ENTRY)
                      ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(VOLMGR_LIST_ENTRY),
                                            PARTMGR_TAG_VOLUME_ENTRY
                                            );
        if (!volmgrEntry) {
            KeReleaseMutex(&driverExtension->Mutex, FALSE);
            return STATUS_SUCCESS;
        }

        volmgrEntry->VolumeManagerName.Length =
                notification->SymbolicLinkName->Length;
        volmgrEntry->VolumeManagerName.MaximumLength =
                volmgrEntry->VolumeManagerName.Length + sizeof(WCHAR);
        volmgrEntry->VolumeManagerName.Buffer = ExAllocatePoolWithTag(
                PagedPool, volmgrEntry->VolumeManagerName.MaximumLength,
                PARTMGR_TAG_VOLUME_ENTRY);
        if (!volmgrEntry->VolumeManagerName.Buffer) {
            ExFreePool(volmgrEntry);
            KeReleaseMutex(&driverExtension->Mutex, FALSE);
            return STATUS_SUCCESS;
        }
        RtlCopyMemory(volmgrEntry->VolumeManagerName.Buffer,
                      notification->SymbolicLinkName->Buffer,
                      volmgrEntry->VolumeManagerName.Length);
        volmgrEntry->VolumeManagerName.Buffer[
                volmgrEntry->VolumeManagerName.Length/sizeof(WCHAR)] = 0;

        volmgrEntry->RefCount = 0;
        InsertTailList(&driverExtension->VolumeManagerList,
                       &volmgrEntry->ListEntry);
        volmgrEntry->VolumeManager = NULL;
        volmgrEntry->VolumeManagerFileObject = NULL;

        status = IoGetDeviceObjectPointer(&volmgrEntry->VolumeManagerName,
                                          FILE_READ_DATA, &fileObject,
                                          &deviceObject);

        if (NT_SUCCESS(status)) {
            input.PmWmiCounterEnable     = PmWmiCounterEnable;
            input.PmWmiCounterDisable    = PmWmiCounterDisable;
            input.PmWmiCounterIoStart    = PmWmiCounterIoStart;
            input.PmWmiCounterIoComplete = PmWmiCounterIoComplete;
            input.PmWmiCounterQuery      = PmWmiCounterQuery;

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_VOLMGR_PMWMICOUNTERLIB_CONTEXT,
                    deviceObject, &input, sizeof(input), NULL, 0, TRUE,
                    &event, &ioStatus);

            if (irp) {
                status = IoCallDriver(deviceObject, irp);
                if (status == STATUS_PENDING) {
                    KeWaitForSingleObject(&event, Executive, KernelMode,
                                          FALSE, NULL);
                }
            }

            ObDereferenceObject(fileObject);
        }

        for (l = driverExtension->DeviceExtensionList.Flink;
             l != &driverExtension->DeviceExtensionList; l = l->Flink) {

            extension = CONTAINING_RECORD(l, DEVICE_EXTENSION, ListEntry);

            if (extension->IsRedundantPath) {
                continue;
            }

            for (ll = extension->PartitionList.Flink;
                 ll != &extension->PartitionList; ll = ll->Flink) {

                partition = CONTAINING_RECORD(ll, PARTITION_LIST_ENTRY,
                                              ListEntry);

                if (!partition->VolumeManagerEntry) {
                    status = PmGivePartition(volmgrEntry,
                                             partition->TargetObject,
                                             partition->WholeDiskPdo);
                    if (NT_SUCCESS(status)) {
                        partition->VolumeManagerEntry = volmgrEntry;
                    }
                }
            }
        }

        status = STATUS_SUCCESS;

    } else if (IsEqualGUID(&notification->Event,
                           &GUID_DEVICE_INTERFACE_REMOVAL)) {

        for (l = driverExtension->VolumeManagerList.Flink;
             l != &driverExtension->VolumeManagerList; l = l->Flink) {

            volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
            if (RtlEqualUnicodeString(&volmgrEntry->VolumeManagerName,
                                      notification->SymbolicLinkName, TRUE)) {

                if (!volmgrEntry->RefCount) {
                    RemoveEntryList(l);
                    ExFreePool(volmgrEntry->VolumeManagerName.Buffer);
                    ExFreePool(volmgrEntry);
                }
                break;
            }
        }

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    KeReleaseMutex(&driverExtension->Mutex, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
PmGetPartitionInformation(
    IN  PDEVICE_OBJECT  Partition,
    IN  PFILE_OBJECT    FileObject,
    OUT PLONGLONG       PartitionOffset,
    OUT PLONGLONG       PartitionLength
    )

{
    KEVENT                  event;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PARTITION_INFORMATION   partInfo;
    IO_STATUS_BLOCK         ioStatus;
    NTSTATUS                status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                                        Partition, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = FileObject;

    status = IoCallDriver(Partition, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    *PartitionOffset = partInfo.StartingOffset.QuadPart;
    *PartitionLength = partInfo.PartitionLength.QuadPart;

    return status;
}

VOID
PmDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           DriverExtension,
    IN  ULONG           Count
    )

{
    PDO_EXTENSION                   driverExtension = DriverExtension;
    PLIST_ENTRY                     l, ll;
    PDEVICE_EXTENSION               extension;
    PPARTITION_LIST_ENTRY           partition;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;

    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);

    InterlockedExchange(&driverExtension->PastReinit, TRUE);

    for (l = driverExtension->DeviceExtensionList.Flink;
         l != &driverExtension->DeviceExtensionList; l = l->Flink) {

        extension = CONTAINING_RECORD(l, DEVICE_EXTENSION, ListEntry);

        if (extension->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
            continue;
        }

        if (!extension->IsStarted) {
            continue;
        }

        for (ll = extension->PartitionList.Flink;
             ll != &extension->PartitionList; ll = ll->Flink) {

            partition = CONTAINING_RECORD(ll, PARTITION_LIST_ENTRY,
                                          ListEntry);

            partition->TargetObject->Flags |= DO_DEVICE_INITIALIZING;
        }

        status = PmReadPartitionTableEx(extension->TargetObject, &layout);
        if (!NT_SUCCESS(status)) {
            continue;
        }

        if (extension->DiskSignature) {
            if (layout->PartitionStyle == PARTITION_STYLE_MBR) {
                layout->Mbr.Signature = extension->DiskSignature;
                PmWritePartitionTableEx(extension->TargetObject, layout);
            }
            extension->DiskSignature = 0;
        }

        if (layout->PartitionStyle == PARTITION_STYLE_GPT) {
            PmAddSignatures(extension, layout);
        }

        ExFreePool(layout);
    }

    KeReleaseMutex(&driverExtension->Mutex, FALSE);
}

VOID
PmBootDriverReinit(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PVOID           DriverExtension,
    IN  ULONG           Count
    )

{
    IoRegisterDriverReinitialization(DriverObject, PmDriverReinit,
                                     DriverExtension);    
}

NTSTATUS
PmCheckForUnclaimedPartitions(
    IN  PDEVICE_OBJECT  DeviceObject
    )

{
    PDEVICE_EXTENSION       extension = DeviceObject->DeviceExtension;
    PDO_EXTENSION           driverExtension = extension->DriverExtension;
    NTSTATUS                status = STATUS_SUCCESS;
    PLIST_ENTRY             l, ll;
    PPARTITION_LIST_ENTRY   partition;
    PVOLMGR_LIST_ENTRY      volmgrEntry;

    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);

    if (extension->IsRedundantPath) {
        KeReleaseMutex(&driverExtension->Mutex, FALSE);
        return STATUS_SUCCESS;
    }

    for (l = extension->PartitionList.Flink; l != &extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        if (partition->VolumeManagerEntry) {
            continue;
        }

        for (ll = driverExtension->VolumeManagerList.Flink;
             ll != &driverExtension->VolumeManagerList; ll = ll->Flink) {

            volmgrEntry = CONTAINING_RECORD(ll, VOLMGR_LIST_ENTRY, ListEntry);

            status = PmGivePartition(volmgrEntry,
                                     partition->TargetObject,
                                     partition->WholeDiskPdo);

            if (NT_SUCCESS(status)) {
                partition->VolumeManagerEntry = volmgrEntry;
                break;
            }
        }

        if (ll == &driverExtension->VolumeManagerList) {
            status = STATUS_UNSUCCESSFUL;
        }
    }

    KeReleaseMutex(&driverExtension->Mutex, FALSE);

    return status;
}

NTSTATUS
PmDiskGrowPartition(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

{
    PDEVICE_EXTENSION       extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDISK_GROW_PARTITION    input;
    NTSTATUS                status;
    PPARTITION_LIST_ENTRY   partition;
    KEVENT                  event;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DISK_GROW_PARTITION)) {

        return STATUS_INVALID_PARAMETER;
    }

    KeWaitForSingleObject(&extension->DriverExtension->Mutex, Executive,
                          KernelMode, FALSE, NULL);

    input = (PDISK_GROW_PARTITION) Irp->AssociatedIrp.SystemBuffer;

    status = PmFindPartition(extension, input->PartitionNumber, &partition);
    if (!NT_SUCCESS(status)) {
        KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);
        return status;
    }

    status = PmChangePartitionIoctl(extension, partition,
             IOCTL_INTERNAL_VOLMGR_QUERY_CHANGE_PARTITION);
    if (!NT_SUCCESS(status)) {
        KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE, TRUE, TRUE);
    IoCallDriver(extension->TargetObject, Irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = Irp->IoStatus.Status;

    if (NT_SUCCESS(status)) {
        PmChangePartitionIoctl(extension, partition,
                               IOCTL_INTERNAL_VOLMGR_PARTITION_CHANGED);
    } else {
        PmChangePartitionIoctl(extension, partition,
                               IOCTL_INTERNAL_VOLMGR_CANCEL_CHANGE_PARTITION);
    }

    KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);

    return status;
}

NTSTATUS
PmEjectVolumeManagers(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine goes through the list of partitions for the given disk
    and takes the partition away from the owning volume managers.  It then
    goes through initial arbitration for each partition on the volume.

    This has the effect that each volume manager forgets any cached disk
    information and then start fresh on the disk as it may have been changed
    by another cluster member.

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION       extension = DeviceObject->DeviceExtension;
    PDO_EXTENSION           driverExtension = extension->DriverExtension;
    PPARTITION_LIST_ENTRY   partition;
    PLIST_ENTRY             l;
    PVOLMGR_LIST_ENTRY      volmgrEntry;

    KeWaitForSingleObject(&driverExtension->Mutex, Executive, KernelMode,
                          FALSE, NULL);

    for (l = extension->PartitionList.Flink; l != &extension->PartitionList;
         l = l->Flink) {

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);
        if (!partition->VolumeManagerEntry) {
            continue;
        }

        PmTakePartition(partition->VolumeManagerEntry,
                        partition->TargetObject, NULL);

        partition->VolumeManagerEntry = NULL;
    }

    for (l = driverExtension->VolumeManagerList.Flink;
         l != &driverExtension->VolumeManagerList; l = l->Flink) {

        volmgrEntry = CONTAINING_RECORD(l, VOLMGR_LIST_ENTRY, ListEntry);
        PmTakeWholeDisk(volmgrEntry, extension->Pdo);
    }

    KeReleaseMutex(&driverExtension->Mutex, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
PmQueryDiskSignature(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine returns the disk signature for the disk.  If the
    volume is not an MBR disk then this call will fail.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    PPARTMGR_DISK_SIGNATURE         partSig = Irp->AssociatedIrp.SystemBuffer;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION_EX    layout;

    if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTMGR_DISK_SIGNATURE)) {

        return STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Information = sizeof(PARTMGR_DISK_SIGNATURE);

    if (extension->DiskSignature) {
        partSig->Signature = extension->DiskSignature;
        return STATUS_SUCCESS;
    }

    status = PmReadPartitionTableEx(extension->TargetObject, &layout);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        return status;
    }

    if (layout->PartitionStyle != PARTITION_STYLE_MBR) {
        ExFreePool(layout);
        Irp->IoStatus.Information = 0;
        return STATUS_INVALID_PARAMETER;
    }

    partSig->Signature = layout->Mbr.Signature;

    ExFreePool(layout);

    return status;
}

NTSTATUS
PmDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION               extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION              irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT                          event;
    NTSTATUS                        status;
    PDRIVE_LAYOUT_INFORMATION       layout;
    PDRIVE_LAYOUT_INFORMATION_EX    newLayout;

    if (extension->TargetObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(extension->TargetObject, Irp);
    }

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_DISK_SET_DRIVE_LAYOUT:
        case IOCTL_DISK_SET_DRIVE_LAYOUT_EX:
        case IOCTL_DISK_CREATE_DISK:
        case IOCTL_DISK_DELETE_DRIVE_LAYOUT:
            KeWaitForSingleObject(&extension->DriverExtension->Mutex,
                                  Executive, KernelMode, FALSE, NULL);
            extension->SignaturesNotChecked = TRUE;
            KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp, PmSignalCompletion, &event, TRUE,
                                   TRUE, TRUE);
            IoCallDriver(extension->TargetObject, Irp);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE,
                                  NULL);

            status = Irp->IoStatus.Status;
            if (!NT_SUCCESS(status)) {
                break;
            }

            status = PmReadPartitionTableEx(extension->TargetObject,
                                            &newLayout);
            if (!NT_SUCCESS(status)) {
                break;
            }

            KeWaitForSingleObject(&extension->DriverExtension->Mutex,
                                  Executive, KernelMode, FALSE, NULL);
            PmAddSignatures(extension, newLayout);
            extension->SignaturesNotChecked = FALSE;
            KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);

            ExFreePool(newLayout);
            break;

        case IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS:
            status = PmCheckForUnclaimedPartitions(DeviceObject);
            Irp->IoStatus.Information = 0;
            break;

        case IOCTL_DISK_GROW_PARTITION:
            status = PmDiskGrowPartition(DeviceObject, Irp);
            break;

        case IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS:
            status = PmEjectVolumeManagers(DeviceObject);
            break;

        case IOCTL_DISK_PERFORMANCE:
            //
            // Verify user buffer is large enough for the performance data.
            //

            status = STATUS_SUCCESS;
            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(DISK_PERFORMANCE)) {

                //
                // Indicate unsuccessful status and no data transferred.
                //

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = 0;
            }
            else if (!(extension->CountersEnabled)) {
                if (!PmQueryEnableAlways(DeviceObject)) {
                    status = STATUS_UNSUCCESSFUL;
                    Irp->IoStatus.Information = 0;
                }
            }
            if (status == STATUS_SUCCESS) {
                PmWmiCounterQuery(extension->PmWmiCounterContext,
                                  (PDISK_PERFORMANCE) Irp->AssociatedIrp.SystemBuffer,
                                  L"Partmgr ",
                                  extension->DiskNumber);
                Irp->IoStatus.Information = sizeof(DISK_PERFORMANCE);
            }
            break;

        case IOCTL_DISK_PERFORMANCE_OFF:
            //
            // Turns off counting
            //
            if (extension->CountersEnabled) {
                if (InterlockedCompareExchange(&extension->EnableAlways, 0, 1) == 1) {
                    if (!PmWmiCounterDisable(&extension->PmWmiCounterContext, FALSE, FALSE)) {
                        extension->CountersEnabled = FALSE;
                    }
                }
            }
            Irp->IoStatus.Information = 0;
            status = STATUS_SUCCESS;
            break;

        case IOCTL_PARTMGR_QUERY_DISK_SIGNATURE:
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
            if (extension->SignaturesNotChecked) {

                status = PmReadPartitionTableEx(extension->TargetObject,
                                                &newLayout);
                if (NT_SUCCESS(status)) {

                    KeWaitForSingleObject(&extension->DriverExtension->Mutex,
                                          Executive, KernelMode, FALSE, NULL);
                    PmAddSignatures(extension, newLayout);
                    extension->SignaturesNotChecked = FALSE;
                    KeReleaseMutex(&extension->DriverExtension->Mutex, FALSE);

                    ExFreePool(newLayout);
                }
            }

            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_PARTMGR_QUERY_DISK_SIGNATURE) {

                status = PmQueryDiskSignature(DeviceObject, Irp);
                break;
            }

            // Fall through.

        default:
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(extension->TargetObject, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

RTL_GENERIC_COMPARE_RESULTS
PmTableSignatureCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PSIGNATURE_TABLE_ENTRY  f = First;
    PSIGNATURE_TABLE_ENTRY  s = Second;

    if (f->Signature < s->Signature) {
        return GenericLessThan;
    }

    if (f->Signature > s->Signature) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
PmTableGuidCompareRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               First,
    IN  PVOID               Second
    )

{
    PGUID_TABLE_ENTRY   f = First;
    PGUID_TABLE_ENTRY   s = Second;
    PULONGLONG          p1, p2;

    p1 = (PULONGLONG) &f->Guid;
    p2 = (PULONGLONG) &s->Guid;

    if (p1[0] < p2[0]) {
        return GenericLessThan;
    }

    if (p1[0] > p2[0]) {
        return GenericGreaterThan;
    }

    if (p1[1] < p2[1]) {
        return GenericLessThan;
    }

    if (p1[1] > p2[1]) {
        return GenericGreaterThan;
    }

    return GenericEqual;
}

PVOID
PmTableAllocateRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  CLONG               Size
    )

{
    return ExAllocatePoolWithTag(PagedPool, Size, PARTMGR_TAG_TABLE_ENTRY);
}

VOID
PmTableFreeRoutine(
    IN  PRTL_GENERIC_TABLE  Table,
    IN  PVOID               Buffer
    )

{
    ExFreePool(Buffer);
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the entry point for the driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    NTSTATUS

--*/

{
    ULONG           i;
    NTSTATUS        status;
    PDO_EXTENSION   driverExtension;
    PDEVICE_OBJECT  deviceObject;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = PmPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PmDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = PmPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PmPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PmWmi;
    DriverObject->MajorFunction[IRP_MJ_READ] = PmReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = PmReadWrite;

    DriverObject->DriverExtension->AddDevice = PmAddDevice;
    DriverObject->DriverUnload = PmUnload;

    status = IoAllocateDriverObjectExtension(DriverObject, PmAddDevice,
                                             sizeof(DO_EXTENSION),
                                             &driverExtension);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    driverExtension->DiskPerfRegistryPath.MaximumLength =
        RegistryPath->Length + sizeof(UNICODE_NULL);
    driverExtension->DiskPerfRegistryPath.Buffer =
        ExAllocatePoolWithTag(
            PagedPool,
            driverExtension->DiskPerfRegistryPath.MaximumLength,
            PARTMGR_TAG_PARTITION_ENTRY);
    if (driverExtension->DiskPerfRegistryPath.Buffer != NULL)
    {
        RtlCopyUnicodeString(&driverExtension->DiskPerfRegistryPath,
                             RegistryPath);
    } else {
        driverExtension->DiskPerfRegistryPath.Length = 0;
        driverExtension->DiskPerfRegistryPath.MaximumLength = 0;
    }

    driverExtension->DriverObject = DriverObject;
    InitializeListHead(&driverExtension->VolumeManagerList);
    InitializeListHead(&driverExtension->DeviceExtensionList);
    KeInitializeMutex(&driverExtension->Mutex, 0);
    driverExtension->PastReinit = FALSE;

    RtlInitializeGenericTable(&driverExtension->SignatureTable,
                              PmTableSignatureCompareRoutine,
                              PmTableAllocateRoutine,
                              PmTableFreeRoutine, driverExtension);

    RtlInitializeGenericTable(&driverExtension->GuidTable,
                              PmTableGuidCompareRoutine,
                              PmTableAllocateRoutine,
                              PmTableFreeRoutine, driverExtension);    

    IoRegisterBootDriverReinitialization(DriverObject, PmBootDriverReinit,
                                         driverExtension);    

    status = IoRegisterPlugPlayNotification(
             EventCategoryDeviceInterfaceChange,
             PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
             (PVOID) &VOLMGR_VOLUME_MANAGER_GUID, DriverObject,
             PmVolumeManagerNotification, driverExtension,
             &driverExtension->NotificationEntry);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    driverExtension->BootDiskSig = PmQueryRegistrySignature();

    return STATUS_SUCCESS;
}

NTSTATUS
PmBuildDependantVolumeRelations(
    IN  PDEVICE_EXTENSION Extension,
    OUT PDEVICE_RELATIONS *Relations
    )
/*++

Routine Description:

    This routine builds a list of volumes which are dependant on a given
    physical disk.  This list can be used for reporting removal relations
    to the pnp system.

Arguments:

    Extension   - Supplies the device extension for the pm filter.

    Relations   - Supplies a location to store the relations list.

Return Value:

    NTSTATUS

--*/

{
    ULONG                   partitionCount;
    PIRP                    irp;
    PDEVICE_RELATIONS       relationsList;
    PDEVICE_RELATIONS       combinedList;

    ULONG                   dependantVolumeCount = 0;

    PLIST_ENTRY             l;
    PPARTITION_LIST_ENTRY   partition;
    NTSTATUS                status = STATUS_SUCCESS;
    ULONG i;

    KEVENT event;

    PAGED_CODE();

    KeWaitForSingleObject(&Extension->DriverExtension->Mutex, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Count the number of partitions we know about.  If there aren't any then
    // there aren't any relations either.
    //

    for(l = Extension->PartitionList.Flink, partitionCount = 0;
        l != &(Extension->PartitionList);
        l = l->Flink, partitionCount++);

    //
    // Allocate the relations list.
    //

    relationsList = ExAllocatePoolWithTag(
                        PagedPool,
                        (sizeof(DEVICE_RELATIONS) +
                        (sizeof(PDEVICE_RELATIONS) * partitionCount)),
                        PARTMGR_TAG_DEPENDANT_VOLUME_LIST);

    if(relationsList== NULL) {
        KeReleaseMutex(&Extension->DriverExtension->Mutex, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(relationsList, (sizeof(DEVICE_RELATIONS) +
                                  sizeof(PDEVICE_OBJECT) * partitionCount));

    if(partitionCount == 0) {
        *Relations = relationsList;
        KeReleaseMutex(&Extension->DriverExtension->Mutex, FALSE);
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    for(l = Extension->PartitionList.Flink, i = 0, dependantVolumeCount = 0;
        l != &(Extension->PartitionList);
        l = l->Flink, i++) {

        PDEVICE_RELATIONS dependantVolumes;

        partition = CONTAINING_RECORD(l, PARTITION_LIST_ENTRY, ListEntry);

        //
        // Check to make sure the volume has a volume manager.  If it doesn't
        // then just skip to the next one.
        //

        if(partition->VolumeManagerEntry == NULL) {
            continue;
        }

        status = PmQueryDependantVolumeList(
                    partition->VolumeManagerEntry->VolumeManager,
                    partition->TargetObject,
                    partition->WholeDiskPdo,
                    &dependantVolumes);

        if(!NT_SUCCESS(status)) {

            //
            // Error getting this list.  We'll need to release the lists from
            // the other partitions.
            //

            break;
        }

        dependantVolumeCount += dependantVolumes->Count;
        relationsList->Objects[i] = (PDEVICE_OBJECT) dependantVolumes;
    }

    KeReleaseMutex(&Extension->DriverExtension->Mutex, FALSE);

    relationsList->Count = i;

    if(NT_SUCCESS(status)) {

        //
        // Allocate a new device relations list which can hold all the dependant
        // volumes for all the partitions.
        //

        combinedList = ExAllocatePoolWithTag(
                            PagedPool,
                            (sizeof(DEVICE_RELATIONS) +
                            (sizeof(PDEVICE_OBJECT) * dependantVolumeCount)),
                            PARTMGR_TAG_DEPENDANT_VOLUME_LIST);
    } else {
        combinedList = NULL;
    }

    if(combinedList != NULL) {

        RtlZeroMemory(combinedList,
                      (sizeof(DEVICE_RELATIONS) +
                       (sizeof(PDEVICE_OBJECT) * dependantVolumeCount)));

        //
        // For each partition list ...
        //

        for(i = 0; i < relationsList->Count; i++) {

            PDEVICE_RELATIONS volumeList;
            ULONG j;

            volumeList = (PDEVICE_RELATIONS) relationsList->Objects[i];

            //
            // We might have skipped this volume above.  If we did the object
            // list should be NULL;
            //

            if(volumeList == NULL) {
                continue;
            }

            //
            // For each dependant volume in that list ...
            //

            for(j = 0; j < volumeList->Count; j++) {

                PDEVICE_OBJECT volume;
                ULONG k;

                volume = volumeList->Objects[j];

                //
                // Check to see if there's a duplicate in our combined list.
                //

                for(k = 0; k < combinedList->Count; k++) {
                    if(combinedList->Objects[k] == volume) {
                        break;
                    }
                }

                if(k == combinedList->Count) {

                    //
                    // We found no match - shove this object onto the end of
                    // the set.
                    //

                    combinedList->Objects[k] = volume;
                    combinedList->Count++;

                } else {

                    //
                    // We've got a spare reference to this device object.
                    // release it.
                    //

                    ObDereferenceObject(volume);
                }

            }

            //
            // Free the list.
            //

            ExFreePool(volumeList);
            relationsList->Objects[i] = NULL;
        }

        status = STATUS_SUCCESS;

    } else {


        //
        // For each partition list ...
        //

        for(i = 0; i < relationsList->Count; i++) {

            PDEVICE_RELATIONS volumeList;
            ULONG j;

            volumeList = (PDEVICE_RELATIONS) relationsList->Objects[i];

            //
            // For each dependant volume in that list ...
            //

            for(j = 0; j < volumeList->Count; j++) {

                PDEVICE_OBJECT volume;

                volume = volumeList->Objects[j];

                //
                // Dereference the volume.
                //

                ObDereferenceObject(volume);
            }

            //
            // Free the list.
            //

            ExFreePool(volumeList);
            relationsList->Objects[i] = NULL;
        }

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Free the list of lists.
    //

    ExFreePool(relationsList);

    *Relations = combinedList;

    return status;
}

NTSTATUS
PmQueryDependantVolumeList(
    IN  PDEVICE_OBJECT VolumeManager,
    IN  PDEVICE_OBJECT Partition,
    IN  PDEVICE_OBJECT WholeDiskPdo,
    OUT PDEVICE_RELATIONS *DependantVolumes
    )
{
    KEVENT                                  event;
    PIRP                                    irp;

    IO_STATUS_BLOCK                         ioStatus;
    NTSTATUS                                status;
    VOLMGR_PARTITION_INFORMATION            input;
    VOLMGR_DEPENDANT_VOLUMES_INFORMATION    output;

    PAGED_CODE();

    ASSERT(DependantVolumes != NULL);

    if (!VolumeManager) {
        *DependantVolumes = ExAllocatePoolWithTag(PagedPool,
                            sizeof(DEVICE_RELATIONS),
                            PARTMGR_TAG_DEPENDANT_VOLUME_LIST);
        if (*DependantVolumes == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        (*DependantVolumes)->Count = 0;

        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    input.PartitionDeviceObject = Partition;
    input.WholeDiskPdo = WholeDiskPdo;

    irp = IoBuildDeviceIoControlRequest(
            IOCTL_INTERNAL_VOLMGR_REFERENCE_DEPENDANT_VOLUMES, VolumeManager,
            &input, sizeof(input), &output, sizeof(output), TRUE, &event,
            &ioStatus);

    if (!irp) {
        *DependantVolumes = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(VolumeManager, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        *DependantVolumes = output.DependantVolumeReferences;
    }

    return status;
}


NTSTATUS
PmRemovePartition(
    IN PPARTITION_LIST_ENTRY Partition
    )
{
    PIRP irp;
    KEVENT event;

    PIO_STACK_LOCATION nextStack;

    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp(Partition->TargetObject->StackSize, FALSE);

    if(irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_PNP;
    nextStack->MinorFunction = IRP_MN_REMOVE_DEVICE;

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IoSetCompletionRoutine(irp,
                           PmSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(Partition->TargetObject, irp);

    KeWaitForSingleObject(&event,
                          KernelMode,
                          Executive,
                          FALSE,
                          NULL);

    status = irp->IoStatus.Status;

    IoFreeIrp(irp);

    return status;
}


NTSTATUS
PmReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for IRP_MJ_READ & _WRITE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   extension =
        (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (extension->CountersEnabled || extension->PhysicalDiskIoNotifyRoutine) {
        PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
        PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);

        *nextIrpStack = *currentIrpStack;

        if (extension->CountersEnabled) {
            PmWmiCounterIoStart(extension->PmWmiCounterContext,
                (PLARGE_INTEGER) &currentIrpStack->Parameters.Read);
        }
        else {      // need to calculate response time for tracing
            PmWmiGetClock(
                *((PLARGE_INTEGER)&currentIrpStack->Parameters.Read), NULL);
        }

        IoMarkIrpPending(Irp);
        IoSetCompletionRoutine(Irp, PmIoCompletion, DeviceObject,
                               TRUE, TRUE, TRUE);
        IoCallDriver(extension->TargetObject, Irp);
        return STATUS_PENDING;
    }

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(extension->TargetObject, Irp);
}



NTSTATUS
PmIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This routine will get control from the system at the completion of an IRP.

Arguments:

    DeviceObject - for the IRP.

    Irp          - The I/O request that just completed.

    Context      - Not used.

Return Value:

    The IRP status.

--*/

{
    PDEVICE_EXTENSION  deviceExtension   = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
    PPHYSICAL_DISK_IO_NOTIFY_ROUTINE notifyRoutine;

    UNREFERENCED_PARAMETER(Context);

    if (deviceExtension->CountersEnabled) {
        PmWmiCounterIoComplete(deviceExtension->PmWmiCounterContext, Irp,
                             (PLARGE_INTEGER) &irpStack->Parameters.Read);
    }

    notifyRoutine = deviceExtension->PhysicalDiskIoNotifyRoutine;
    if (notifyRoutine) {
#ifdef NTPERF
        //
        // For now, only NTPERF needs this for tracing. Remove ifdef if it
        // is required for tracing in retail build
        //
        if (deviceExtension->CountersEnabled) {
            DISK_PERFORMANCE   PerfCounters;
            PmWmiCounterQuery(deviceExtension->PmWmiCounterContext,
                              &PerfCounters,
                              L"Partmgr ",
                              deviceExtension->DiskNumber);
            (*notifyRoutine) (deviceExtension->DiskNumber, Irp, &PerfCounters);
        } else {
            (*notifyRoutine) (deviceExtension->DiskNumber, Irp, NULL);
        }
#else
        if (!deviceExtension->CountersEnabled) {
            LARGE_INTEGER completeTime;
            PLARGE_INTEGER response;
            response = (PLARGE_INTEGER) &irpStack->Parameters.Read;
            PmWmiGetClock(completeTime, NULL);
            response->QuadPart = completeTime.QuadPart - response->QuadPart;
        }
        (*notifyRoutine) (deviceExtension->DiskNumber, Irp, NULL);
#endif
    }

    return STATUS_SUCCESS;

}



NTSTATUS
PmWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles any WMI requests for information.

Arguments:

    DeviceObject - Context for the activity.

    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MinorFunction == IRP_MN_SET_TRACE_NOTIFY)
    {
        PVOID buffer = irpSp->Parameters.WMI.Buffer;
        ULONG bufferSize = irpSp->Parameters.WMI.BufferSize;

        if (bufferSize < sizeof(PPHYSICAL_DISK_IO_NOTIFY_ROUTINE))
        {
            status = STATUS_BUFFER_TOO_SMALL;
        } else {
#ifdef NTPERF
        //
        // For NTPERF Build, automatically turn on counters for tracing
        //
        if ((deviceExtension->PhysicalDiskIoNotifyRoutine == NULL) &&
            (*((PVOID *)buffer) != NULL)) {
            PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext);
            deviceExtension->CountersEnabled = TRUE;
        } else
        if ((deviceExtension->PhysicalDiskIoNotifyRoutine != NULL) &&
            (*((PVOID *)buffer) == NULL)) {
            deviceExtension->CountersEnabled =
                PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,
                                    FALSE, FALSE);
        }
#endif
            deviceExtension->PhysicalDiskIoNotifyRoutine
                = (PPHYSICAL_DISK_IO_NOTIFY_ROUTINE)
                    *((PVOID *)buffer);

            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    } else {
        if (deviceExtension->WmilibContext == NULL) {
            disposition = IrpForward;
            status = STATUS_SUCCESS;
        }
        else {
            status = WmiSystemControl(deviceExtension->WmilibContext,
                                      DeviceObject,
                                      Irp,
                                      &disposition);
        }
        switch (disposition)
        {
            case IrpProcessed:
            {
                break;
            }

            case IrpNotCompleted:
            {
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

            default:
            {
                IoSkipCurrentIrpStackLocation(Irp);

                status = IoCallDriver(deviceExtension->TargetObject, Irp);
                break;
            }
        }
    }
    return(status);

}

NTSTATUS
PmWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for enabling or
    disabling events and data collection.  When the driver has finished it
    must call WmiCompleteRequest to complete the irp. The driver can return
    STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose events or data collection are being
        enabled or disabled

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function differentiates between event and data collection operations

    Enable indicates whether to enable or disable


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        status = STATUS_SUCCESS;
        if (Function == WmiDataBlockControl) {
            if (!Enable) {
                deviceExtension->CountersEnabled =
                    PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,
                                        FALSE, FALSE);
            } else
            if (NT_SUCCESS(status =
                PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext))) {
                deviceExtension->CountersEnabled = TRUE;
            }
        }
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                 DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);
    return(status);
}

NTSTATUS
PmReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    )

/*++

Routine Description:

    This routine reads the partition table for the disk.

    The partition list is built in nonpaged pool that is allocated by this
    routine. It is the caller's responsability to free this memory when it
    is finished with the data.

Arguments:

    DeviceObject - Pointer for device object for this disk.

    DriveLayout - Pointer to the pointer that will return the patition list.
            This buffer is allocated in nonpaged pool by this routine. It is
            the responsability of the caller to free this memory if this
            routine is successful.

Return Values:

    Status.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    KEVENT Event;
    PVOID IoCtlBuffer;
    ULONG IoCtlBufferSize;
    ULONG NewAllocationSize;
    ULONG NumTries;

    //
    // Initialize locals.
    //

    NumTries = 0;
    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Initialize the IOCTL buffer.
    //

    IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool, 
                                        PAGE_SIZE,
                                        PARTMGR_TAG_IOCTL_BUFFER);
    
    if (!IoCtlBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    
    IoCtlBufferSize = PAGE_SIZE;

    //
    // First try to get the partition table by issuing an IOCTL.
    //
    
    do {

        //
        // Make sure the event is reset.
        //

        KeClearEvent(&Event);

        //
        // Build an IOCTL Irp.
        //

        Irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                            DeviceObject,
                                            NULL, 
                                            0, 
                                            IoCtlBuffer, 
                                            IoCtlBufferSize, 
                                            FALSE,
                                            &Event, 
                                            &IoStatus);
        if (!Irp) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // Call the driver.
        //

        Status = IoCallDriver(DeviceObject, Irp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // Update status.
            //
            
            Status = IoStatus.Status;
        }
    
        if (NT_SUCCESS(Status)) {
            
            //
            // We got it!
            //

            break;
        }

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            
            //
            // It is a real error.
            //

            goto cleanup;
        }

        //
        // Resize IOCTL buffer. We should not enter the loop with a
        // NULL buffer.
        //

        ASSERT(IoCtlBuffer && IoCtlBufferSize);

        NewAllocationSize = IoCtlBufferSize * 2;

        ExFreePool(IoCtlBuffer);
        IoCtlBufferSize = 0;
        
        IoCtlBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                            NewAllocationSize,
                                            PARTMGR_TAG_IOCTL_BUFFER);
        
        if (!IoCtlBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        
        IoCtlBufferSize = NewAllocationSize;

        //
        // Try again with the new buffer but do not loop forever.
        //

        NumTries++;

        if (NumTries > 32) {
            Status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

    } while (TRUE);

    //
    // If we came here we should have acquired the partition tables in
    // IoCtlBuffer.
    //
    
    ASSERT(NT_SUCCESS(Status));
    ASSERT(IoCtlBuffer && IoCtlBufferSize);
    
    //
    // Set the output parameter and clear IoCtlBuffer so we don't free
    // it when we are cleaning up.
    //

    (*DriveLayout) = (PDRIVE_LAYOUT_INFORMATION_EX) IoCtlBuffer;

    IoCtlBuffer = NULL;
    IoCtlBufferSize = 0;

    Status = STATUS_SUCCESS;

 cleanup:
    
    if (IoCtlBuffer) {
        ASSERT(IoCtlBufferSize);
        ExFreePool(IoCtlBuffer);
    }

    //
    // If we were not successful with the IOCTL, pass the request off
    // to IoReadPartitionTableEx.
    //

    if (!NT_SUCCESS(Status)) {
        
        Status = IoReadPartitionTableEx(DeviceObject,
                                        DriveLayout);

    }
    
    return Status;
}

NTSTATUS
PmWritePartitionTableEx(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PDRIVE_LAYOUT_INFORMATION_EX    DriveLayout
    )

{
    ULONG           layoutSize;
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                 DriveLayout->PartitionCount*sizeof(PARTITION_INFORMATION_EX);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                                        DeviceObject, DriveLayout,
                                        layoutSize, NULL, 0, FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(DeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\ext\kdext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"


//
// globals
//

WINDBG_EXTENSION_APIS  ExtensionApis;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}



extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(
    PULONG Version,
    PULONG Flags
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
//    g_ExcepCallbacks.Uninitialize();
//    g_FnProfCallbacks.Uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\ext\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <storport.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

//
// undef the wdbgexts
//
#undef DECLARE_API
#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define MINIPKD_PRINT_ERROR(r)\
    dprintf("minipkd error (%x): %s @ line %d\n", (r), __FILE__, __LINE__);

#define RECUR  DBG_DUMP_FIELD_RECUR_ON_THIS
#define F_ADDR DBG_DUMP_FIELD_RETURN_ADDRESS
#define COPY   DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_COPY_FIELD_DATA | DBG_DUMP_FIELD_RETURN_ADDRESS
#define ADDROF DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_FULL_NAME

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

extern WINDBG_EXTENSION_APIS64 ExtensionApis;

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PRINT_FLAGS(Flags,b)      if (Flags & b) {dprintf(#b", ");}

__inline 
VOID
xdindent(
    ULONG Depth
    )
{
    ULONG i;
    for (i=0; i<Depth; i++)
        dprintf("  ");
}

#define xdprintfEx(d, expr)\
    xdindent((d));\
    dprintf expr

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

extern FLAG_NAME SrbFlags[];

PUCHAR
DevicePowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
GetAddressAndDetailLevel(
    IN  PCSTR      Args,
    OUT PULONG64   Address,
    OUT PLONG      Detail
    );

VOID
GetAddress(
    IN  PCSTR      Args,
    OUT PULONG64   Address
    );

PUCHAR
SystemPowerStateToString(
    IN DEVICE_POWER_STATE State
    );

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PUCHAR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

BOOLEAN
GetAnsiString(
    IN ULONG_PTR Address,
    IN PUCHAR Buffer,
    IN OUT PULONG Length
    );

PCHAR
GuidToString(
    GUID* GUID
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\partmgr\pmwmireg.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmireg.c

Abstract:

    This file contains routines to register for and handle WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#define RTL_USE_AVL_TABLES 0

#include <ntosp.h>
#include <stdio.h>
#include <ntddvol.h>
#include <ntdddisk.h>
#include <wdmguid.h>
#include <volmgr.h>
#include <wmistr.h>
#include <wmikm.h>
#include <wmilib.h>
#include <partmgr.h>
#include <pmwmicnt.h>
#include <initguid.h>
#include <wmiguid.h>
#include <zwapi.h>

NTSTATUS PmRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PmQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
PmQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
PmQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

WMIGUIDREGINFO DiskperfGuidList[] =
{
    { &DiskPerfGuid,
      1,
      0
    }
};

ULONG DiskperfGuidCount = (sizeof(DiskperfGuidList) / sizeof(WMIGUIDREGINFO));

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, PmRegisterDevice)
#pragma alloc_text (PAGE, PmQueryWmiRegInfo)
#pragma alloc_text (PAGE, PmQueryWmiDataBlock)
#pragma alloc_text (PAGE, PmQueryEnableAlways)
#endif



NTSTATUS
PmRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Routine to initialize a proper name for the device object, and
    register it with WMI

Arguments:

    DeviceObject - pointer to a device object to be initialized.

Return Value:

    Status of the initialization. NOTE: If the registration fails,
    the device name in the DeviceExtension will be left as empty.

--*/

{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;
    KEVENT                  event;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   number;
    ULONG                   registrationFlag = 0;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Request for the device number
    //
    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_STORAGE_GET_DEVICE_NUMBER,
                    deviceExtension->TargetObject,
                    NULL,
                    0,
                    &number,
                    sizeof(number),
                    FALSE,
                    &event,
                    &ioStatus);
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceExtension->TargetObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Remember the disk number for use as parameter in 
    // PhysicalDiskIoNotifyRoutine
    //

    deviceExtension->DiskNumber = number.DeviceNumber;

    deviceExtension->PhysicalDeviceName.Length = 0;
    deviceExtension->PhysicalDeviceName.MaximumLength = DEVICENAME_MAXSTR;

    // Create device name for each partition

    swprintf(deviceExtension->PhysicalDeviceNameBuffer,
        L"\\Device\\Harddisk%d\\Partition%d",
        number.DeviceNumber, number.PartitionNumber);

    RtlInitUnicodeString(
        &deviceExtension->PhysicalDeviceName,
        &deviceExtension->PhysicalDeviceNameBuffer[0]);

    if (number.PartitionNumber == 0) {
        registrationFlag = WMIREG_FLAG_TRACE_PROVIDER | WMIREG_NOTIFY_DISK_IO;
    }

    status = IoWMIRegistrationControl(DeviceObject,
                 WMIREG_ACTION_REGISTER | registrationFlag );

    if (NT_SUCCESS(status)) {
        PmWmiCounterEnable(&deviceExtension->PmWmiCounterContext);
        PmWmiCounterDisable(&deviceExtension->PmWmiCounterContext,
                            FALSE, FALSE);
    }

    return status;
}



NTSTATUS
PmQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.
        The MOF file is assumed to be already included in wmicore.mof

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    InstanceName->Buffer = (PUSHORT) NULL;
    *RegistryPath = &deviceExtension->DriverExtension->DiskPerfRegistryPath;
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EXPENSIVE;
    *Pdo = deviceExtension->Pdo;
    status = STATUS_SUCCESS;

    return(status);
}



NTSTATUS
PmQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG sizeNeeded = 0;
    KIRQL        currentIrql;
    PWCHAR diskNamePtr;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        if (!(deviceExtension->CountersEnabled)) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            sizeNeeded = ((sizeof(DISK_PERFORMANCE) + 1) & ~1)
                         + deviceExtension->PhysicalDeviceName.Length 
                         + sizeof(UNICODE_NULL);
            if (BufferAvail >= sizeNeeded) {
                PmWmiCounterQuery(deviceExtension->PmWmiCounterContext, 
                                  (PDISK_PERFORMANCE) Buffer, L"Partmgr ", 
                                  deviceExtension->DiskNumber);
                diskNamePtr = (PWCHAR)(Buffer +
                              ((sizeof(DISK_PERFORMANCE) + 1) & ~1));
                *diskNamePtr++ = deviceExtension->PhysicalDeviceName.Length;
                RtlCopyMemory(diskNamePtr,
                              deviceExtension->PhysicalDeviceName.Buffer,
                              deviceExtension->PhysicalDeviceName.Length);
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }

    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, sizeNeeded,
                                 IO_NO_INCREMENT);
    return status;
}


BOOLEAN
PmQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS status;
    UNICODE_STRING uString;
    OBJECT_ATTRIBUTES objAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION keyValue;
    ULONG Buffer[4];            // sizeof keyValue + ULONG
    ULONG enableAlways = 0;
    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    HANDLE keyHandle;
    ULONG returnLength;

    PAGED_CODE();

    RtlInitUnicodeString(&uString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Partmgr");
    InitializeObjectAttributes(
        &objAttributes,
        &uString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&keyHandle, KEY_READ, &objAttributes);
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&uString, L"EnableCounterForIoctl");
        status = ZwQueryValueKey(keyHandle, &uString,
                    KeyValuePartialInformation,
                    Buffer,
                    sizeof(Buffer),
                    &returnLength);
        keyValue = (PKEY_VALUE_PARTIAL_INFORMATION) &Buffer[0];
        if (NT_SUCCESS(status) && (keyValue->DataLength == sizeof(ULONG))) {
            enableAlways = *((PULONG) keyValue->Data);
        }
        ZwClose(keyHandle);
    }

    if (enableAlways == 1) {
        if (InterlockedCompareExchange(&extension->EnableAlways, 1, 0) == 0) {
            status = PmWmiCounterEnable(&extension->PmWmiCounterContext);
            if (NT_SUCCESS(status)) {
                extension->CountersEnabled = TRUE;
                return TRUE;
            }
            else {
                InterlockedExchange(&extension->EnableAlways, 0);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\diskdump\diskdump.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    diskdump.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common SCSI boot port driver.

Author:

    Mike Glass (Ported from Jeff Havens and Mike Glass loader development.)

Revision History:

--*/

#include "ntddscsi.h"

#define INITIAL_MEMORY_BLOCK_SIZE 0x2000
#define MAXIMUM_TRANSFER_SIZE 0x10000
#define MINIMUM_TRANSFER_SIZE 0x8000

//
// SCSI Get Configuration Information
//
// LUN Information
//

typedef struct _LUNINFO {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    PVOID DeviceObject;
    struct _LUNINFO *NextLunInfo;
    UCHAR InquiryData[INQUIRYDATABUFFERSIZE];
} LUNINFO, *PLUNINFO;

typedef struct _SCSI_BUS_SCAN_DATA {
    USHORT Length;
    UCHAR InitiatorBusId;
    UCHAR NumberOfLogicalUnits;
    PLUNINFO LunInfoList;
} SCSI_BUS_SCAN_DATA, *PSCSI_BUS_SCAN_DATA;

typedef struct _SCSI_CONFIGURATION_INFO {
    UCHAR NumberOfBuses;
    PSCSI_BUS_SCAN_DATA BusScanData[1];
} SCSI_CONFIGURATION_INFO, *PSCSI_CONFIGURATION_INFO;

#define MAXIMUM_RETRIES 4

//
// System provided stall routine.
//

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

//
// Define memory block header -- ensure always quad-aligned (code assumes that
// it is always aligned)
//

typedef struct _MEMORY_HEADER {
    struct _MEMORY_HEADER *Next;
    PVOID Address;
    ULONG Length;
    ULONG Spare;
} MEMORY_HEADER, *PMEMORY_HEADER;

//
// SCSI device timeout values in seconds
//

#define SCSI_DISK_TIMEOUT   10

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    PSCSI_REQUEST_BLOCK Srb;
    PVOID LogicalAddress;
    ULONG Length;
} ADAPTER_TRANSFER, *PADAPTER_TRANSFER;


typedef struct _SRB_SCATTER_GATHER {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Length;
} SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

//
// Device extension
//

typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT DeviceObject;
    PSTALL_ROUTINE StallRoutine;
    PPORT_CONFIGURATION_INFORMATION ConfigurationInformation;

    //
    // Partition information
    //

    LARGE_INTEGER PartitionOffset;

    //
    // Memory management
    //
    //

    PMEMORY_HEADER FreeMemory;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PHYSICAL_ADDRESS LogicalAddress[2];

    //
    // SRBs
    //

    SCSI_REQUEST_BLOCK Srb;
    SCSI_REQUEST_BLOCK RequestSenseSrb;

    //
    // Current request
    //

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG LuFlags;
    PMDL Mdl;
    PVOID SpecificLuExtension;
    LONG RequestTimeoutCounter;
    ULONG RetryCount;
    ULONG ByteCount;
    SRB_SCATTER_GATHER ScatterGather[17];

    //
    // Noncached breakout.
    //

    PVOID NonCachedExtension;
    ULONG NonCachedExtensionSize;
    PSENSE_DATA RequestSenseBuffer;
    PVOID SrbExtension;

    //
    // Dma Adapter information.
    //

    PVOID MapRegisterBase[2];
    PADAPTER_OBJECT DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;
    ULONG NumberOfMapRegisters;

    //
    // Number of SCSI buses
    //

    UCHAR NumberOfBuses;

    //
    // Maximum targets per bus
    //

    UCHAR MaximumTargetIds;

    //
    // Disk block size
    //

    ULONG BytesPerSector;

    //
    // Sector shift count
    //

    ULONG SectorShift;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // SCSI configuration information from inquiries.
    //

    LUNINFO LunInfo;

    //
    // SCSI port driver flags
    //

    ULONG Flags;

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    KSPIN_LOCK SpinLock;

    //
    // Mapped address list
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // Miniport entry points
    //

    PHW_INITIALIZE HwInitialize;
    PHW_STARTIO HwStartIo;
    PHW_INTERRUPT HwInterrupt;
    PHW_RESET_BUS HwReset;
    PHW_DMA_STARTED HwDmaStarted;

    //
    // Buffers must be mapped into system space.
    //

    BOOLEAN MapBuffers;

    //
    // Is this device a bus master and does it require map registers.
    //

    BOOLEAN MasterWithAdapter;

    //
    // Indicates that adapter with boot device has been found.
    //

    BOOLEAN FoundBootDevice;

    //
    // Device extension for miniport routines.
    //

    PVOID HwDeviceExtension;

    //
    // Miniport request interrupt enabled/disable routine.
    //

    PHW_INTERRUPT HwRequestInterrupt;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Indicates request has been submitted to miniport and
    // has not yet been completed.
    //

    BOOLEAN RequestPending;

    //
    // Indicates that request has been completed.
    //

    BOOLEAN RequestComplete;

    //
    // Physical address of zone pool
    //

    ULONG PhysicalZoneBase;

    //
    // Logical Unit Extension
    //

    ULONG HwLogicalUnitExtensionSize;

    ULONG TimerValue;

    //
    // Value is set to true when the dump is done.  We use this so that
    // we don't do a request sense incase one of the shutdown operations
    // fail.
    //
    BOOLEAN FinishingUp;

    //
    // The common buffer size is saved during initialization
    //
    ULONG CommonBufferSize;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)

//
// Port driver extension flags.
//

#define PD_CURRENT_IRP_VALID         0X0001
#define PD_RESET_DETECTED            0X0002
#define PD_NOTIFICATION_IN_PROGRESS  0X0004
#define PD_READY_FOR_NEXT_REQUEST    0X0008
#define PD_FLUSH_ADAPTER_BUFFERS     0X0010
#define PD_MAP_TRANSFER              0X0020
#define PD_CALL_DMA_STARTED          0X01000
#define PD_DISABLE_CALL_REQUEST      0X02000
#define PD_DISABLE_INTERRUPTS        0X04000
#define PD_ENABLE_CALL_REQUEST       0X08000
#define PD_TIMER_CALL_REQUEST        0X10000

//
// Logical unit extension flags.
//

#define PD_QUEUE_FROZEN              0X0001
#define PD_LOGICAL_UNIT_IS_ACTIVE    0X0002
#define PD_CURRENT_REQUEST_COMPLETE  0X0004
#define PD_LOGICAL_UNIT_IS_BUSY      0X0008

//
// The timer interval for the miniport timer routine specified in
// units of 100 nanoseconds.
//
#define PD_TIMER_INTERVAL (250 * 1000 * 10)   // 250 ms

//
// The define the interloop stall.
//

#define PD_INTERLOOP_STALL 5

#define COMPLETION_DELAY 10

//
// Define global data structures
//

extern ULONG ScsiPortCount;

//
// Define HalFlushIoBuffers for i386 and AMD64.
//

#if defined(i386) || defined(_AMD64_)
#define HalFlushIoBuffers
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\diskdump\diskdump.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    diskdump.c

Abstract:

    This is a special SCSI driver that serves as a combined SCSI disk
    class driver and SCSI manager for SCSI miniport drivers. It's sole
    responsibility is to provide disk services to copy physical memory
    into a portion of the disk as a record of a system crash.

Author:

    Mike Glass

Notes:

    Ported from osloader SCSI modules which were originally developed by
    Jeff Havens and Mike Glass.

Revision History:

--*/

#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"
#include "scsi.h"
#include "ntdddisk.h"
#include "diskdump.h"

extern PBOOLEAN Mm64BitPhysicalAddress;

//
// The scsi dump driver needs to allocate memory out of it's own, private
// allocation pool. This necessary to prevent pool corruption from
// preventing a successful crashdump.
//

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#ifdef ExFreePool
#undef ExFreePool
#endif

#define ExAllocatePool C_ASSERT (FALSE)
#define ExFreePool     C_ASSERT (FALSE)

PDEVICE_EXTENSION DeviceExtension;

#define SECONDS         (1000 * 1000)
#define RESET_DELAY     (4 * SECONDS)

VOID
ExecuteSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
ResetBus(
    IN PDEVICE_EXTENSION pDevExt,
    IN ULONG PathId
    );


VOID
FreeScatterGatherList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );
    
//
// Routines start
//


VOID
FreePool(
    IN PVOID Ptr
    )

/*++

Routine Description:

    free block of memory.

Arguments:

    ptr - The memory to free.

Return Value:

    None.

--*/

{
    PMEMORY_HEADER freedBlock;

    //
    // Don't try to coalesce.  They will probably just ask for something
    // of just this size again.
    //

    freedBlock = (PMEMORY_HEADER)Ptr - 1;
    freedBlock->Next = DeviceExtension->FreeMemory;
    DeviceExtension->FreeMemory = freedBlock;

}


PVOID
AllocatePool(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocate block of memory. Uses first fit algorithm.
    The free memory pointer always points to the beginning of the zone.

Arguments:

    Size - size of memory to be allocated.

Return Value:

    Address of memory block.

--*/

{
    PMEMORY_HEADER descriptor = DeviceExtension->FreeMemory;
    PMEMORY_HEADER previous = NULL;
    ULONG length;

    //
    // Adjust size for memory header and round up memory to 16 bytes.
    //

    length = (Size + sizeof(MEMORY_HEADER) + 15) & ~15;

    //
    // Walk free list looking for first block of memory equal to
    // or greater than (adjusted) size requested.
    //

    while (descriptor) {
        if (descriptor->Length >= length) {

            //
            // Update free list eliminating as much of this block as necessary.
            //
            // Make sure if we don't have enough of the block left for a
            // memory header we just point to the next block (and adjust
            // length accordingly).
            //

            if (!previous) {

                if (descriptor->Length < (length+sizeof(MEMORY_HEADER))) {
                    DeviceExtension->FreeMemory = DeviceExtension->FreeMemory->Next;
                } else {
                    DeviceExtension->FreeMemory =
                        (PMEMORY_HEADER)((PUCHAR)descriptor + length);
                    previous = DeviceExtension->FreeMemory;
                    previous->Length = descriptor->Length - length;
                    previous->Next = descriptor->Next;
                    descriptor->Length = length;
                }
            } else {
                if (descriptor->Length < (length+sizeof(MEMORY_HEADER))) {
                    previous->Next = descriptor->Next;
                } else {
                    previous->Next =
                        (PMEMORY_HEADER)((PUCHAR)descriptor + length);
                    previous->Next->Length = descriptor->Length - length;
                    previous->Next->Next = descriptor->Next;
                    descriptor->Length = length;
                }
            }

            //
            // Update memory header for allocated block.
            //

            descriptor->Next = NULL;

            //
            // Adjust address past header.
            //

            (PUCHAR)descriptor += sizeof(MEMORY_HEADER);

            break;
        }

        previous = descriptor;
        descriptor = descriptor->Next;
    }

    return descriptor;
}

BOOLEAN
DiskDumpOpen(
    IN LARGE_INTEGER PartitionOffset
    )

/*++

Routine Description:

    This is the entry point for open requests to the diskdump driver.

Arguments:

    PartitionOffset - Byte offset of partition on disk.

Return Value:

    TRUE

--*/

{
    //
    // Update partition object in device extension for this partition.
    //

    DeviceExtension->PartitionOffset = PartitionOffset;

    return TRUE;

}


VOID
WorkHorseDpc(
    )

/*++

Routine Description:

    Handle miniport notification.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;

    //
    // Check for a flush DMA adapter object request.  Note that
    // on the finish up code this will have been already cleared.
    //
    if (DeviceExtension->InterruptFlags & PD_FLUSH_ADAPTER_BUFFERS) {

        //
        // Call IoFlushAdapterBuffers using the parameters saved from the last
        // IoMapTransfer call.
        //

        IoFlushAdapterBuffers(
            DeviceExtension->DmaAdapterObject,
            DeviceExtension->Mdl,
            DeviceExtension->MapRegisterBase[1],
            DeviceExtension->FlushAdapterParameters.LogicalAddress,
            DeviceExtension->FlushAdapterParameters.Length,
            (BOOLEAN)(DeviceExtension->FlushAdapterParameters.Srb->SrbFlags
                & SRB_FLAGS_DATA_OUT ? TRUE : FALSE));

        DeviceExtension->InterruptFlags &= ~PD_FLUSH_ADAPTER_BUFFERS;
    }

    //
    // Check for an IoMapTransfer DMA request.  Note that on the finish
    // up code, this will have been cleared.
    //

    if (DeviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // Call IoMapTransfer using the parameters saved from the
        // interrupt level.
        //

        IoMapTransfer(
            DeviceExtension->DmaAdapterObject,
            DeviceExtension->Mdl,
            DeviceExtension->MapRegisterBase[1],
            DeviceExtension->MapTransferParameters.LogicalAddress,
            &DeviceExtension->MapTransferParameters.Length,
            (BOOLEAN)(DeviceExtension->MapTransferParameters.Srb->SrbFlags
                      & SRB_FLAGS_DATA_OUT ? TRUE : FALSE));

        //
        // Save the paramters for IoFlushAdapterBuffers.
        //

        DeviceExtension->FlushAdapterParameters =
            DeviceExtension->MapTransferParameters;

        DeviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        DeviceExtension->Flags |= PD_CALL_DMA_STARTED;
    }

    //
    // Process any completed requests.
    //

    if (DeviceExtension->RequestComplete) {

        //
        // Reset request timeout counter.
        //

        DeviceExtension->RequestTimeoutCounter = -1;
        DeviceExtension->RequestComplete = FALSE;
        DeviceExtension->RequestPending = FALSE;

        //
        // Flush the adapter buffers if necessary.
        //

        if (DeviceExtension->MasterWithAdapter) {
            FreeScatterGatherList (DeviceExtension, srb);
        }

        if (srb->SrbStatus != SRB_STATUS_SUCCESS) {

            if (srb->ScsiStatus == SCSISTAT_BUSY &&
                (DeviceExtension->RetryCount++ < 20)) {

                //
                // If busy status is returned, then indicate that the logical
                // unit is busy.  The timeout code will restart the request
                // when it fires. Reset the status to pending.
                //

                srb->SrbStatus = SRB_STATUS_PENDING;
                DeviceExtension->Flags |= PD_LOGICAL_UNIT_IS_BUSY;

                //
                // Restore the data transfer length.
                //

                srb->DataTransferLength = DeviceExtension->ByteCount;
            }
        }

        //
        // Make MDL pointer NULL to show there is no outstanding request.
        //

        DeviceExtension->Mdl = NULL;
    }
}


VOID
RequestSenseCompletion(
    )

/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->RequestSenseSrb;
    PSCSI_REQUEST_BLOCK failingSrb = &DeviceExtension->Srb;
    PSENSE_DATA senseBuffer = DeviceExtension->RequestSenseBuffer;

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Check that request sense buffer is valid.
        //

        if (srb->DataTransferLength >= FIELD_OFFSET(SENSE_DATA, CommandSpecificInformation)) {

            DebugPrint((1,"RequestSenseCompletion: Error code is %x\n",
                        senseBuffer->ErrorCode));
            DebugPrint((1,"RequestSenseCompletion: Sense key is %x\n",
                        senseBuffer->SenseKey));
            DebugPrint((1, "RequestSenseCompletion: Additional sense code is %x\n",
                        senseBuffer->AdditionalSenseCode));
            DebugPrint((1, "RequestSenseCompletion: Additional sense code qualifier is %x\n",
                      senseBuffer->AdditionalSenseCodeQualifier));
        }
    }

    //
    // Complete original request.
    //

    DeviceExtension->RequestComplete = TRUE;
    WorkHorseDpc();

}


VOID
IssueRequestSense(
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and sends it to the miniport
    driver.
    The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->RequestSenseSrb;
    PCDB cdb = (PCDB)srb->Cdb;
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[ (sizeof(MDL)/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Build REQUEST SENSE SRB.
    //

    srb->TargetId = DeviceExtension->Srb.TargetId;
    srb->Lun = DeviceExtension->Srb.Lun;
    srb->PathId = DeviceExtension->Srb.PathId;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->DataBuffer = DeviceExtension->RequestSenseBuffer;
    srb->DataTransferLength = sizeof(SENSE_DATA);
    srb->ScsiStatus = srb->SrbStatus = 0;
    srb->NextSrb = 0;
    srb->CdbLength = 6;
    srb->TimeOutValue = 5;

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL) &localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MmGetMdlPfnArray ( DeviceExtension->Mdl );
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);

    //
    // Disable auto request sense.
    //

    srb->SenseInfoBufferLength = 0;
    srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_AUTOSENSE |
                    SRB_FLAGS_DISABLE_DISCONNECT;

    //
    // REQUEST SENSE cdb looks like INQUIRY cdb.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);
}



ULONG
StartDevice(
    IN UCHAR    TargetId,
    IN UCHAR    Lun
    )
/*++

Routine Description:

    Starts up the target device.

Arguments:

    TargetId - the id of the device

    Lun - The logical unit number

Return Value:

    SRB status

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->RequestSenseSrb;
    PCDB cdb = (PCDB)srb->Cdb;
    ULONG retry;

    retry  = 0;
    DebugPrint((1,"StartDevice: Attempt to start device\n"));

retry_start:

    //
    // Zero SRB.
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(cdb, sizeof(CDB));

    srb->TargetId               = TargetId;
    srb->Lun                    = Lun;
    srb->PathId                 = DeviceExtension->Srb.PathId;
    srb->Length                 = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function               = SRB_FUNCTION_EXECUTE_SCSI;

    srb->SrbFlags               = SRB_FLAGS_NO_DATA_TRANSFER |
                                    SRB_FLAGS_DISABLE_AUTOSENSE |
                                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                                    SRB_FLAGS_BYPASS_LOCKED_QUEUE;

    srb->CdbLength              = 6;

    srb->SrbStatus              = 0;
    srb->ScsiStatus             = 0;
    srb->NextSrb                = 0;
    srb->TimeOutValue           = 30;

    cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb->START_STOP.Start = 1;

    //
    // Send SRB to miniport driver.
    //
    ExecuteSrb(srb);

    if (srb->SrbStatus != SRB_STATUS_SUCCESS) {
        if (retry++ < 4) {
            DebugPrint((1,"StartDevice: Failed SRB STATUS: %x Retry #: %x\n",
                           srb->SrbStatus,retry));
            goto retry_start;
        }
    }

    return srb->SrbStatus;
}



VOID
AllocateScatterGatherList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Create a scatter/gather list for the specified IO.

Arguments:

    DeviceExtension - Device extension.

    Srb - Scsi Request block to create the scatter/gather list for.

Return Value:

    None.

--*/
{
    BOOLEAN succ;
    BOOLEAN writeToDevice;
    ULONG totalLength;
    PSRB_SCATTER_GATHER scatterList;

    //
    // Calculate the number of map registers needed for this transfer.
    //

    DeviceExtension->NumberOfMapRegisters =
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(Srb->DataBuffer,
                                       Srb->DataTransferLength);

    //
    // Build the scatter/gather list.
    //

    scatterList = DeviceExtension->ScatterGather;
    totalLength = 0;

    //
    // Build the scatter/gather list by looping through the transfer
    // calling I/O map transfer.
    //

    writeToDevice = Srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE;

    while (totalLength < Srb->DataTransferLength) {

        //
        // Request that the rest of the transfer be mapped.
        //

        scatterList->Length = Srb->DataTransferLength - totalLength;

        //
        // Io is always done through the second map register.
        //

        scatterList->PhysicalAddress =
            IoMapTransfer (
                DeviceExtension->DmaAdapterObject,
                DeviceExtension->Mdl,
                DeviceExtension->MapRegisterBase[1],
                (PCCHAR) Srb->DataBuffer + totalLength,
                &scatterList->Length,
                writeToDevice);

        totalLength += scatterList->Length;
        scatterList++;
    }

}


VOID
FreeScatterGatherList(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Free a scatter/gather list, freeing all resources associated with it.

Arguments:

    DeviceExtension - Device extension.

    Srb - Scsi Request block to free the scatter/gather list for.

Return Value:

    None.

--*/
{
    BOOLEAN succ;
    BOOLEAN writeToDevice;
    ULONG totalLength;
    PSRB_SCATTER_GATHER scatterList;

    if (DeviceExtension->Mdl == NULL) {
        return;
    }
    
    scatterList = DeviceExtension->ScatterGather;
    totalLength = 0;

    //
    // Loop through the list, call IoFlushAdapterBuffers for each entry in
    // the list.
    //

    writeToDevice = Srb->SrbFlags & SRB_FLAGS_DATA_OUT ? TRUE : FALSE;

    while (totalLength < Srb->DataTransferLength) {

        //
        // Io is always done through the second map register.
        //

        succ = IoFlushAdapterBuffers(
                    DeviceExtension->DmaAdapterObject,
                    DeviceExtension->Mdl,
                    DeviceExtension->MapRegisterBase[1],
                    (PCCHAR)Srb->DataBuffer + totalLength,
                    scatterList->Length,
                    writeToDevice);
        ASSERT (succ == TRUE);
                
        totalLength += scatterList->Length;
        scatterList++;
    }
}


    

VOID
StartIo(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

Arguments:

    Srb - Request to start.

Return Value:

    Nothing.

--*/

{
    PSRB_SCATTER_GATHER scatterList;
    ULONG totalLength;
    BOOLEAN writeToDevice;

    //
    // Set up SRB extension.
    //

    Srb->SrbExtension = DeviceExtension->SrbExtension;

    //
    // Flush the data buffer if necessary.
    //

    if (Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) {

        if (Srb->DataTransferLength > DeviceExtension->Capabilities.MaximumTransferLength) {

            DebugPrint((1,
                "StartIo: StartIo Length Exceeds limit (%x > %x)\n",
                Srb->DataTransferLength,
                DeviceExtension->Capabilities.MaximumTransferLength));
        }

        HalFlushIoBuffers(
            DeviceExtension->Mdl,
            (BOOLEAN) (Srb->SrbFlags & SRB_FLAGS_DATA_IN ? TRUE : FALSE),
            TRUE);

        //
        // Determine if this adapter needs map registers.
        //

        if (DeviceExtension->MasterWithAdapter) {
            AllocateScatterGatherList (DeviceExtension, Srb);
        }
    }

    //
    // Set request timeout value from Srb SCSI.
    //

    DeviceExtension->RequestTimeoutCounter = Srb->TimeOutValue;

    //
    // Send SRB to miniport driver. Miniport driver will notify when
    // it completes.
    //
    DeviceExtension->HwStartIo(DeviceExtension->HwDeviceExtension,
                               Srb);
    return;

}


VOID
TickHandler(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine simulates a 1-second tickhandler and is used to time
    requests.

Arguments:

    Srb - request being timed.

Return Value:

    None.

--*/

{
    if (DeviceExtension->RequestPending) {

        //
        // Check for busy requests.
        //

        if (DeviceExtension->Flags & PD_LOGICAL_UNIT_IS_BUSY) {

            DebugPrint((1,"TickHandler: Retrying busy status request\n"));

            //
            // Clear the busy flag and retry the request.
            //

            DeviceExtension->Flags &= ~PD_LOGICAL_UNIT_IS_BUSY;
            StartIo(Srb);

        } else if (DeviceExtension->RequestTimeoutCounter == 0) {

            ULONG i;

            //
            // Request timed out.
            //

            DebugPrint((1, "TickHandler: Request timed out\n"));
            DebugPrint((1,
                       "TickHandler: CDB operation code %x\n",
                       DeviceExtension->Srb.Cdb[0]));
            DebugPrint((1,
                       "TickHandler: Retry count %x\n",
                       DeviceExtension->RetryCount));

            //
            // Reset request timeout counter to unused state.
            //

            DeviceExtension->RequestTimeoutCounter = -1;

            if (!ResetBus(DeviceExtension, 0)) {

                DebugPrint((1,"Reset SCSI bus failed\n"));
            }

            //
            // Call the interupt handler for a few microseconds to clear any reset
            // interrupts.
            //

            for (i = 0; i < 1000 * 100; i++) {

                DeviceExtension->StallRoutine(10);

                if (DeviceExtension->HwInterrupt != NULL) {
                    DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
                }
            }

            //
            // Wait 2 seconds for the devices to recover after the reset.
            //

            DeviceExtension->StallRoutine(2 * SECONDS);

        } else if (DeviceExtension->RequestTimeoutCounter != -1) {

            DeviceExtension->RequestTimeoutCounter--;
        }
    }
}


VOID
ExecuteSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine calls the start I/O routine an waits for the request to
    complete.  During the wait for complete the interrupt routine is called,
    also the timer routines are called at the appropriate times.  After the
    request completes a check is made to determine if an request sense needs
    to be issued.

Arguments:

    Srb - Request to execute.

Return Value:

    Nothing.

--*/

{
    ULONG milliSecondTime;
    ULONG secondTime;
    ULONG completionDelay;

    //
    // Show request is pending.
    //

    DeviceExtension->RequestPending = TRUE;

    //
    // Start the request.
    //

    StartIo(Srb);

    //
    // The completion delay controls how long interrupts are serviced after
    // a request has been completed.  This allows interrupts which occur after
    // a completion to be serviced.
    //

    completionDelay = COMPLETION_DELAY;

    //
    // Wait for the SRB to complete.
    //

    while (DeviceExtension->RequestPending) {

        //
        // Wait 1 second then call the scsi port timer routine.
        //

        for (secondTime = 0; secondTime < 1000/ 250; secondTime++) {

            for (milliSecondTime = 0; milliSecondTime < (250 * 1000 / PD_INTERLOOP_STALL); milliSecondTime++) {

                if (!(DeviceExtension->Flags & PD_DISABLE_INTERRUPTS)) {

                    //
                    // Call miniport driver's interrupt routine.
                    //

                    if (DeviceExtension->HwInterrupt != NULL) {
                        DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
                    }
                }

                //
                // If the request is complete, call the interrupt routine
                // a few more times to clean up any extra interrupts.
                //

                if (!DeviceExtension->RequestPending) {
                    if (completionDelay-- == 0) {
                        goto done;
                    }
                }

                if (DeviceExtension->Flags & PD_ENABLE_CALL_REQUEST) {

                    //
                    // Call the miniport requested routine.
                    //

                    DeviceExtension->Flags &= ~PD_ENABLE_CALL_REQUEST;
                    DeviceExtension->HwRequestInterrupt(DeviceExtension->HwDeviceExtension);

                    if (DeviceExtension->Flags & PD_DISABLE_CALL_REQUEST) {

                        DeviceExtension->Flags &= ~(PD_DISABLE_INTERRUPTS | PD_DISABLE_CALL_REQUEST);
                        DeviceExtension->HwRequestInterrupt(DeviceExtension->HwDeviceExtension);
                    }
                }

                if (DeviceExtension->Flags & PD_CALL_DMA_STARTED) {

                    DeviceExtension->Flags &= ~PD_CALL_DMA_STARTED;

                    //
                    // Notify the miniport driver that the DMA has been
                    // started.
                    //

                    if (DeviceExtension->HwDmaStarted) {
                            DeviceExtension->HwDmaStarted(
                            DeviceExtension->HwDeviceExtension
                            );
                    }
                }

                //
                // This enforces the delay between calls to the interrupt routine.
                //
                
                DeviceExtension->StallRoutine(PD_INTERLOOP_STALL);

                //
                // Check the miniport timer.
                //

                if (DeviceExtension->TimerValue != 0) {

                    DeviceExtension->TimerValue--;

                    if (DeviceExtension->TimerValue == 0) {

                        //
                        // The timer timed out so called requested timer routine.
                        //

                        DeviceExtension->HwTimerRequest(DeviceExtension->HwDeviceExtension);
                    }
                }
            }
        }

        TickHandler(Srb);

        DebugPrint((1,"ExecuteSrb: Waiting for SRB request to complete (~3 sec)\n"));
    }

done:

    if (Srb == &DeviceExtension->Srb &&
        Srb->SrbStatus != SRB_STATUS_SUCCESS) {

        //
        // Determine if a REQUEST SENSE command needs to be done.
        //

        if ((Srb->ScsiStatus == SCSISTAT_CHECK_CONDITION) &&
            !DeviceExtension->FinishingUp) {

            //
            // Call IssueRequestSense and it will complete the request after
            // the REQUEST SENSE completes.
            //

            DebugPrint((1,
                       "ExecuteSrb: Issue request sense\n"));

            IssueRequestSense();
        }
    }
}


NTSTATUS
DiskDumpWrite(
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    )

/*++

Routine Description:

    This is the entry point for write requests to the diskdump driver.

Arguments:

    DiskByteOffset - Byte offset relative to beginning of partition.

    Mdl - Memory descriptor list that defines this request.

Return Value:

    Status of write operation.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG blockOffset;
    ULONG blockCount;
    ULONG retryCount = 0;

    //
    // ISSUE - 2000/02/29 - math:
    //
    // This is here until the StartVa is page aligned in the dump code
    // (MmMapPhysicalMdl).
    //
    
    Mdl->StartVa = PAGE_ALIGN( Mdl->StartVa );

    DebugPrint((2,
               "Write memory at %x for %x bytes\n",
               Mdl->StartVa,
               Mdl->ByteCount));


writeRetry:
    if (retryCount) {
        //
        // Remap the Mdl for dump data if IssueRequestSense() is called
        // in ExecuteSrb() due to a write error.
        //
        MmMapMemoryDumpMdl(Mdl);
    }

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Save MDL in device extension.
    //

    DeviceExtension->Mdl = Mdl;

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_OUT |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;
    srb->DataTransferLength = Mdl->ByteCount;

    //
    // See if adapter needs the memory mapped.
    //

    if (DeviceExtension->MapBuffers) {

        srb->DataBuffer = Mdl->MappedSystemVa;

        //
        // ISSUE - 2000/02/29 - math: Work-around bad callers.
        //
        // MapBuffers indicates the adapter expects srb->DataBuffer to be a valid VA reference
        // MmMapDumpMdl initializes MappedSystemVa to point to a pre-defined VA region
        // Make sure StartVa points to the same page, some callers do not initialize all mdl fields
        //
        
        Mdl->StartVa = PAGE_ALIGN( Mdl->MappedSystemVa );
        
    } else {
        srb->DataBuffer = (PVOID)((PCHAR)Mdl->StartVa + Mdl->ByteOffset);
    }

    //
    // Initialize CDB for write command.
    //

    cdb->CDB10.OperationCode = SCSIOP_WRITE;

    //
    // Convert disk byte offset to block offset.
    //

    blockOffset = (ULONG)((DeviceExtension->PartitionOffset.QuadPart +
                           (*DiskByteOffset).QuadPart) /
                          DeviceExtension->BytesPerSector);

    //
    // Fill in CDB block address.
    //

    cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&blockOffset)->Byte3;
    cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&blockOffset)->Byte2;
    cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&blockOffset)->Byte1;
    cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&blockOffset)->Byte0;

    blockCount = Mdl->ByteCount >> DeviceExtension->SectorShift;

    cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&blockCount)->Byte1;
    cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&blockCount)->Byte0;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    //
    // Retry SRBs returned with failing status.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        DebugPrint((0,
                   "Write request failed with SRB status %x\n",
                   srb->SrbStatus));

        //
        // If retries not exhausted then retry request.
        //

        if (retryCount < 2) {

            retryCount++;
            goto writeRetry;
        }

        return STATUS_UNSUCCESSFUL;

    } else {

        return STATUS_SUCCESS;
    }
}


VOID
DiskDumpFinish(
    VOID
    )

/*++

Routine Description:

    This routine sends ops that finish up the write

Arguments:

    None.

Return Value:

    Status of write operation.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG retryCount = 0;

    //
    // No data will be transfered with these two requests.  So set up
    // our extension so that we don't try to flush any buffers.
    //

    DeviceExtension->InterruptFlags &= ~PD_FLUSH_ADAPTER_BUFFERS;
    DeviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
    DeviceExtension->MapRegisterBase[1] = 0;
    DeviceExtension->FinishingUp = TRUE;

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;

    //
    // Initialize CDB for write command.
    //

    cdb->CDB10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    srb->CdbLength = 0;
    srb->Function = SRB_FUNCTION_SHUTDOWN;
    srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 0;

    ExecuteSrb(srb);


}


ULONG
GetDeviceTransferSize(
    PVOID   PortConfig
    )
{
    ULONG TransferLength;

    //
    // For all other bus types ISA, EISA, MicroChannel set to the minimum
    // known supported size (ex., 32kb)
    //

    TransferLength = MINIMUM_TRANSFER_SIZE;

    //
    // Return the maximum transfer size for the adapter.
    //
    
    if ( PortConfig ) {
    
        PPORT_CONFIGURATION_INFORMATION ConfigInfo = PortConfig;

        //
        // Init the transfer length if it exists in port config
        //
        
        if ( ConfigInfo->MaximumTransferLength ) {

            TransferLength = ConfigInfo->MaximumTransferLength;

        }

        //
        // If the bus is PCI then increase the maximum transfer size
        //
        
        if ( ConfigInfo->AdapterInterfaceType == PCIBus) {

            if ( TransferLength > MAXIMUM_TRANSFER_SIZE) {
                TransferLength = MAXIMUM_TRANSFER_SIZE;
            }

        } else {

            if (TransferLength > MINIMUM_TRANSFER_SIZE) {
                TransferLength = MINIMUM_TRANSFER_SIZE;
            }
        }
    }

    return TransferLength;
}



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the system's entry point into the diskdump driver.

Arguments:

    DriverObject - Not used.

    RegistryPath - Using this field to pass initialization parameters.

Return Value:

    STATUS_SUCCESS

--*/

{
    PDUMP_INITIALIZATION_CONTEXT context = (PDUMP_INITIALIZATION_CONTEXT)RegistryPath;
    PMEMORY_HEADER memoryHeader;
    ULONG i;
    PSCSI_ADDRESS TargetAddress;

    //
    // Zero the entire device extension and memory blocks.
    //
    RtlZeroMemory( context->MemoryBlock, 8*PAGE_SIZE );
    RtlZeroMemory( context->CommonBuffer[0], context->CommonBufferSize );
    RtlZeroMemory( context->CommonBuffer[1], context->CommonBufferSize );

    //
    // Allocate device extension from free memory block.
    //

    memoryHeader = (PMEMORY_HEADER)context->MemoryBlock;
    DeviceExtension =
        (PDEVICE_EXTENSION)((PUCHAR)memoryHeader + sizeof(MEMORY_HEADER));
    //
    // Initialize memory descriptor.
    //

    memoryHeader->Length =  sizeof(DEVICE_EXTENSION) + sizeof(MEMORY_HEADER);
    memoryHeader->Next = NULL;

    //
    // Fill in first free memory header.
    //

    DeviceExtension->FreeMemory =
        (PMEMORY_HEADER)((PUCHAR)memoryHeader + memoryHeader->Length);
    DeviceExtension->FreeMemory->Length =
        (8*PAGE_SIZE) - memoryHeader->Length;
    DeviceExtension->FreeMemory->Next = NULL;

    //
    // Store away init parameters.
    //

    DeviceExtension->StallRoutine = context->StallRoutine;
    DeviceExtension->CommonBufferSize = context->CommonBufferSize;
    TargetAddress = context->TargetAddress;
    
    //
    // Make sure that the common buffer size is backed by enough crash dump ptes
    // The size is defined by MAXIMUM_TRANSFER_SIZE
    //
    
    if (DeviceExtension->CommonBufferSize > MAXIMUM_TRANSFER_SIZE) {
        DeviceExtension->CommonBufferSize = MAXIMUM_TRANSFER_SIZE;
    }

    //
    // Formerly, we allowed NULL TargetAddresses. No more. We must have
    // a valid SCSI TargetAddress to create the dump. If not, just fail
    // here.
    //
    
    if ( TargetAddress == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }
    
    DeviceExtension->PathId    = TargetAddress->PathId;
    DeviceExtension->TargetId  = TargetAddress->TargetId;
    DeviceExtension->Lun       = TargetAddress->Lun;

    DebugPrint((1,"DiskDump[DriverEntry] ScsiAddress.Length     = %x\n",TargetAddress->Length));
    DebugPrint((1,"DiskDump[DriverEntry] ScsiAddress.PortNumber = %x\n",TargetAddress->PortNumber));
    DebugPrint((1,"DiskDump[DriverEntry] ScisAddress.PathId     = %x\n",TargetAddress->PathId));
    DebugPrint((1,"DiskDump[DriverEntry] ScisAddress.TargetId   = %x\n",TargetAddress->TargetId));
    DebugPrint((1,"DiskDump[DriverEntry] ScisAddress.Lun        = %x\n",TargetAddress->Lun));

    //
    // Save off common buffer's virtual and physical addresses.
    //

    for (i = 0; i < 2; i++) {
        DeviceExtension->CommonBuffer[i] = context->CommonBuffer[i];

        //
        // Convert the va of the buffer to obtain the PhysicalAddress
        //
        DeviceExtension->PhysicalAddress[i] =
            MmGetPhysicalAddress(context->CommonBuffer[i]);
    }

    //
    // Save driver parameters.
    //

    DeviceExtension->DmaAdapterObject = (PADAPTER_OBJECT)context->AdapterObject;
        *(PMAPPED_ADDRESS *) context->MappedRegisterBase;

    DeviceExtension->ConfigurationInformation =
        context->PortConfiguration;

    //
    // We need to fixup this field of the port configuration information.
    //
    
    if (*Mm64BitPhysicalAddress) {
        DeviceExtension->ConfigurationInformation->Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
    }

    DeviceExtension->MappedAddressList = NULL;

    if (context->MappedRegisterBase) {
        DeviceExtension->MappedAddressList =
            *(PMAPPED_ADDRESS *) context->MappedRegisterBase;
    }

    //
    // Initialize request tracking booleans.
    //

    DeviceExtension->RequestPending = FALSE;
    DeviceExtension->RequestComplete = FALSE;

    //
    // Return major entry points.
    //

    context->OpenRoutine = DiskDumpOpen;
    context->WriteRoutine = DiskDumpWrite;
    context->FinishRoutine = DiskDumpFinish;
    context->MaximumTransferSize = GetDeviceTransferSize(context->PortConfiguration);

    return STATUS_SUCCESS;
}



NTSTATUS
InitializeConfiguration(
    IN PHW_INITIALIZATION_DATA HwInitData,
    OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN BOOLEAN InitialCall
    )
/*++

Routine Description:

    This routine initializes the port configuration information structure.
    Any necessary information is extracted from the registery.

Arguments:

    DeviceExtension - Supplies the device extension.

    HwInitializationData - Supplies the initial miniport data.

    ConfigInfo - Supplies the configuration information to be
        initialized.

    InitialCall - Indicates that this is first call to this function.
        If InitialCall is FALSE, then the perivous configuration information
        is used to determine the new information.

Return Value:

    Returns a status indicating the success or fail of the initializaiton.

--*/

{
    ULONG i;

    //
    // If this is the initial call then zero the information and set
    // the structure to the uninitialized values.
    //

    if (InitialCall) {

        RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

        ConfigInfo->Length = sizeof(PORT_CONFIGURATION_INFORMATION);
        ConfigInfo->AdapterInterfaceType = HwInitData->AdapterInterfaceType;
        ConfigInfo->InterruptMode = Latched;
        ConfigInfo->MaximumTransferLength = 0xffffffff;
        ConfigInfo->NumberOfPhysicalBreaks = 0xffffffff;
        ConfigInfo->DmaChannel = 0xffffffff;
        ConfigInfo->NumberOfAccessRanges = HwInitData->NumberOfAccessRanges;
        ConfigInfo->MaximumNumberOfTargets = 8;

        for (i = 0; i < 8; i++) {
            ConfigInfo->InitiatorBusId[i] = ~0;
        }
    }

    return STATUS_SUCCESS;

}



PINQUIRYDATA
IssueInquiry(
    )

/*++

Routine Description:

    This routine prepares an INQUIRY command that is sent to the miniport driver.

Arguments:

    None.

Return Value:

    Address of INQUIRY data.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG retryCount = 0;
    PINQUIRYDATA inquiryData = DeviceExtension->CommonBuffer[1];
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

inquiryRetry:

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 5;
    srb->CdbLength = 6;
    srb->DataBuffer = inquiryData;
    srb->DataTransferLength = INQUIRYDATABUFFERSIZE;

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL)&localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MmGetMdlPfnArray ( DeviceExtension->Mdl );
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);

    //
    // Initialize CDB for INQUIRY command.
    //

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.Control = 0;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS &&
        SRB_STATUS(srb->SrbStatus) != SRB_STATUS_DATA_OVERRUN) {

        DebugPrint((2,
                   "IssueInquiry: Inquiry failed SRB status %x\n",
                   srb->SrbStatus));

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT &&
            retryCount < 2) {

            //
            // If the selection did not time out then retry the request.
            //

            retryCount++;
            goto inquiryRetry;

        } else {
            return NULL;
        }
    }

    return inquiryData;

}

VOID
IssueReadCapacity(
    )

/*++

Routine Description:

    This routine prepares a READ CAPACITY command that is sent to the
    miniport driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    PREAD_CAPACITY_DATA readCapacityData = DeviceExtension->CommonBuffer[1];
    ULONG retryCount = 0;
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

readCapacityRetry:

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_AUTOSENSE |
                    SRB_FLAGS_DISABLE_DISCONNECT;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 5;
    srb->CdbLength = 10;
    srb->DataBuffer = readCapacityData;
    srb->DataTransferLength = sizeof(READ_CAPACITY_DATA);

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL) &localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MmGetMdlPfnArray (DeviceExtension->Mdl);
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);

    //
    // Initialize CDB.
    //

    cdb->CDB6GENERIC.OperationCode = SCSIOP_READ_CAPACITY;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS &&
       (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_DATA_OVERRUN || srb->Cdb[0] == SCSIOP_READ_CAPACITY)) {

        DebugPrint((1,
                   "ReadCapacity failed SRB status %x\n",
                   srb->SrbStatus));

        if (retryCount < 2) {

            //
            // If the selection did not time out then retry the request.
            //

            retryCount++;
            goto readCapacityRetry;

        } else {

            //
            // Guess and hope that the block size is 512.
            //

            DeviceExtension->BytesPerSector = 512;
            DeviceExtension->SectorShift = 9;
        }

    } else {

        //
        // Assuming that the 2 lsb is the only non-zero byte, this puts it in
        // the right place.
        //

        DeviceExtension->BytesPerSector = readCapacityData->BytesPerBlock >> 8;
        WHICH_BIT(DeviceExtension->BytesPerSector, DeviceExtension->SectorShift);

        //
        // Check for return size of zero. Set to default size and pass the problem downstream
        //
        if (!DeviceExtension->BytesPerSector) {
            DeviceExtension->BytesPerSector = 512;
            DeviceExtension->SectorShift    = 9;
        }
    }
}


ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    )

/*++

Routine Description:

    This routine is called by miniport driver to complete initialization.
    Port configuration structure contains data from the miniport's previous
    initialization and all system resources should be assigned and valid.

Arguments:

    Argument1 - Not used.

    Argument2 - Not used.

    HwInitializationData - Miniport initialization structure

    HwContext - Value passed to miniport driver's config routine

Return Value:

    NT Status - STATUS_SUCCESS if boot device found.

--*/

{
    BOOLEAN succ;
    ULONG status;
    ULONG srbStatus;
    PPORT_CONFIGURATION_INFORMATION configInfo;
    PIO_SCSI_CAPABILITIES capabilities;
    ULONG length;
    BOOLEAN callAgain;
    UCHAR dumpString[] = "dump=1;";
    UCHAR crashDump[32];
    PINQUIRYDATA inquiryData;
    BOOLEAN allocatedConfigInfo;


    ASSERT ( DeviceExtension != NULL );

    //
    // Check if boot device has already been found.
    //

    if (DeviceExtension->FoundBootDevice) {
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    //
    // Initialization
    //

    DeviceExtension->HwDeviceExtension = NULL;
    DeviceExtension->SpecificLuExtension = NULL;
    configInfo = NULL;
    capabilities = NULL;
    inquiryData = NULL;
    allocatedConfigInfo = FALSE;
    
    
    RtlCopyMemory(crashDump,
                  dumpString,
                  strlen(dumpString) + 1);


    //
    // Check size of init data structure.
    //

    if (HwInitializationData->HwInitializationDataSize > sizeof(HW_INITIALIZATION_DATA)) {
        return (ULONG) STATUS_REVISION_MISMATCH;
    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwResetBus)) {

        DebugPrint((0,
                   "ScsiPortInitialize: Miniport driver missing required entry\n"));
        return (ULONG)STATUS_UNSUCCESSFUL;
    }


    //
    // Set timer to -1 to indicate no outstanding request.
    //
    
    DeviceExtension->RequestTimeoutCounter = -1;

    //
    // Allocate memory for the miniport driver's device extension.
    //

    DeviceExtension->HwDeviceExtension =
        AllocatePool(HwInitializationData->DeviceExtensionSize);

    if (!DeviceExtension->HwDeviceExtension) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    
    //
    // Allocate memory for the hardware logical unit extension and
    // zero it out.
    //

    if (HwInitializationData->SpecificLuExtensionSize) {

        DeviceExtension->HwLogicalUnitExtensionSize =
            HwInitializationData->SpecificLuExtensionSize;

        DeviceExtension->SpecificLuExtension =
            AllocatePool (HwInitializationData->SpecificLuExtensionSize);

        if ( !DeviceExtension->SpecificLuExtension ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }
        
        RtlZeroMemory (
            DeviceExtension->SpecificLuExtension,
            DeviceExtension->HwLogicalUnitExtensionSize);
    }

    //
    // Save the dependent driver routines in the device extension.
    //

    DeviceExtension->HwInitialize = HwInitializationData->HwInitialize;
    DeviceExtension->HwStartIo = HwInitializationData->HwStartIo;
    DeviceExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    DeviceExtension->HwReset = HwInitializationData->HwResetBus;
    DeviceExtension->HwDmaStarted = HwInitializationData->HwDmaStarted;
    DeviceExtension->HwLogicalUnitExtensionSize =
        HwInitializationData->SpecificLuExtensionSize;

                
    //
    // Get pointer to capabilities structure.
    //

    capabilities = &DeviceExtension->Capabilities;
    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    //
    // Check if port configuration information structure passed in from
    // the system is valid.
    //

    if (configInfo = DeviceExtension->ConfigurationInformation) {

        //
        // Check to see if this structure applies to this miniport
        // initialization.  As long as they ask for more access ranges
        // here than are required when they initialized with scsiport,
        // we should be fine.
        //

        if((configInfo->AdapterInterfaceType != HwInitializationData->AdapterInterfaceType) ||
           (HwInitializationData->NumberOfAccessRanges < configInfo->NumberOfAccessRanges)) {

            //
            // Don't initialize this time.
            //

            status = STATUS_NO_SUCH_DEVICE;
            goto done;
        }

    } else {

        //
        // Allocate a new configuration information structure.
        //

        configInfo = AllocatePool(sizeof(PORT_CONFIGURATION_INFORMATION));
        allocatedConfigInfo = TRUE;

        if ( !configInfo ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }

        configInfo->AccessRanges = NULL;

        //
        // Set up configuration information structure.
        //

        status = InitializeConfiguration(
                        HwInitializationData,
                        configInfo,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            status = STATUS_NO_SUCH_DEVICE;
            goto done;
        }

        //
        // Allocate memory for access ranges.
        //

        configInfo->NumberOfAccessRanges =
            HwInitializationData->NumberOfAccessRanges;
        configInfo->AccessRanges =
            AllocatePool(sizeof(ACCESS_RANGE) * HwInitializationData->NumberOfAccessRanges);

        if (configInfo->AccessRanges == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }

        //
        // Zero out access ranges.
        //

        RtlZeroMemory(configInfo->AccessRanges,
                      HwInitializationData->NumberOfAccessRanges
                      * sizeof(ACCESS_RANGE));
    }

    //
    // Determine the maximum transfer size for this adapter
    //
    
    capabilities->MaximumTransferLength = GetDeviceTransferSize(configInfo);
    
    DebugPrint ((1,
                "DiskDump: Port Capabilities MaxiumTransferLength = 0x%08x\n",
                 capabilities->MaximumTransferLength));
    //
    // Get address of SRB extension.
    //

    DeviceExtension->SrbExtension = DeviceExtension->CommonBuffer[0];

    length = HwInitializationData->SrbExtensionSize;
    length = (length + 7) &  ~7;

    //
    // Get address of request sense buffer.
    //

    DeviceExtension->RequestSenseBuffer = (PSENSE_DATA)
        ((PUCHAR)DeviceExtension->CommonBuffer[0] + length);

    length += sizeof(SENSE_DATA);
    length = (length + 7) &  ~7;

    //
    // Use the rest of the buffer for the noncached extension.
    //

    DeviceExtension->NonCachedExtension =
        (PUCHAR)DeviceExtension->CommonBuffer[0] + length;

    //
    // Save the maximum size noncached extension can be.
    //
    DeviceExtension->NonCachedExtensionSize = DeviceExtension->CommonBufferSize - length;

    //
    // If a map registers are required, then allocate them permanently
    // here using the adapter object passed in by the system.
    //
    
    if (DeviceExtension->DmaAdapterObject != NULL ) {
        LARGE_INTEGER pfn;
        PPFN_NUMBER page;
        PMDL mdl;
        ULONG numberOfPages;
        ULONG i;
        PFN_NUMBER localMdl[(sizeof( MDL )/sizeof (PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

        //
        // Determine how many map registers are needed by considering
        // the maximum transfer size and the size of the two common buffers.
        //

        numberOfPages = capabilities->MaximumTransferLength / PAGE_SIZE;

        DeviceExtension->MapRegisterBase[0] =
            HalAllocateCrashDumpRegisters(DeviceExtension->DmaAdapterObject,
                                          &numberOfPages);


        numberOfPages = capabilities->MaximumTransferLength / PAGE_SIZE;

        DeviceExtension->MapRegisterBase[1] =
            HalAllocateCrashDumpRegisters(DeviceExtension->DmaAdapterObject,
                                          &numberOfPages);

        //
        // ISSUE - 2000/02/29 - math: Review.
        //
        //  We assume this always succeeds for MAX TRANSFER SIZE as long
        //  as max transfer size is less than 64k
        //

        //
        // Determine if adapter is a busmaster or uses slave DMA.
        //

        if (HwInitializationData->NeedPhysicalAddresses &&
            configInfo->Master) {

            DeviceExtension->MasterWithAdapter = TRUE;

        } else {

            DeviceExtension->MasterWithAdapter = FALSE;
        }
        //
        // Build MDL to describe the first common buffer.
        //

        mdl = (PMDL)&localMdl[0];
        MmInitializeMdl(mdl,
                        DeviceExtension->CommonBuffer[0],
                        DeviceExtension->CommonBufferSize);

        //
        // Get base of page index array at end of MDL.
        //
        page = MmGetMdlPfnArray (mdl);

        //
        // Calculate number of pages per memory block.
        //

        numberOfPages = DeviceExtension->CommonBufferSize / PAGE_SIZE;

        //
        // Fill in MDL description of first memory block.
        //

        for (i = 0; i < numberOfPages; i++) {

            //
            // Calculate first page.
            //

            *page = (PFN_NUMBER)((DeviceExtension->PhysicalAddress[0].QuadPart +
                             (PAGE_SIZE * i)) >> PAGE_SHIFT);
            page++;
        }

        mdl->MdlFlags = MDL_PAGES_LOCKED;

        //
        // We need to Map the entire buffer.
        //

        length = DeviceExtension->CommonBufferSize;

        //
        // Convert physical buffer addresses to logical.
        //

        DeviceExtension->LogicalAddress[0] =
            IoMapTransfer(
                 DeviceExtension->DmaAdapterObject,
                 mdl,
                 DeviceExtension->MapRegisterBase[0],
                 DeviceExtension->CommonBuffer[0],
                 &length,
                 FALSE);

        //
        // Build MDL to describe the second common buffer.
        //

        mdl = (PMDL)&localMdl[0];
        MmInitializeMdl(mdl,
                        DeviceExtension->CommonBuffer[1],
                        DeviceExtension->CommonBufferSize);

        //
        // Get base of page index array at end of MDL.
        //

        page = MmGetMdlPfnArray ( mdl );

        //
        // Calculate number of pages per memory block.
        //

        numberOfPages = DeviceExtension->CommonBufferSize / PAGE_SIZE;

        //
        // Fill in MDL description of first memory block.
        //

        for (i = 0; i < numberOfPages; i++) {

            //
            // Calculate first page.
            //

            *page = (PFN_NUMBER)((DeviceExtension->PhysicalAddress[1].QuadPart +
                            (PAGE_SIZE * i)) >> PAGE_SHIFT);

            page++;
        }

        //
        // We need to map the entire buffer.
        //
        
        length = DeviceExtension->CommonBufferSize;

        //
        // Convert physical buffer addresses to logical.
        //

        DeviceExtension->LogicalAddress[1] =
            IoMapTransfer(
                 DeviceExtension->DmaAdapterObject,
                 mdl,
                 DeviceExtension->MapRegisterBase[1],
                 DeviceExtension->CommonBuffer[1],
                 &length,
                 FALSE);
    } else {

        DeviceExtension->MasterWithAdapter = FALSE;

        DeviceExtension->LogicalAddress[0] =
            DeviceExtension->PhysicalAddress[0];
        DeviceExtension->LogicalAddress[1] =
            DeviceExtension->PhysicalAddress[1];

    }

    //
    // Call miniport driver's find adapter routine.
    //

    if (HwInitializationData->HwFindAdapter(DeviceExtension->HwDeviceExtension,
                                            HwContext,
                                            NULL,
                                            (PCHAR)&crashDump,
                                            configInfo,
                                            &callAgain) != SP_RETURN_FOUND) {

        status = STATUS_NO_SUCH_DEVICE;
        goto done;
    }


    DebugPrint((1,
               "SCSI adapter IRQ is %d\n",
               configInfo->BusInterruptLevel));

    DebugPrint((1,
               "SCSI adapter ID is %d\n",
               configInfo->InitiatorBusId[0]));

    if (configInfo->NumberOfAccessRanges) {
        DebugPrint((1,
                   "SCSI IO address is %x\n",
                   ((*(configInfo->AccessRanges))[0]).RangeStart.LowPart));
    }

    //
    // Set indicater as to whether adapter needs mapped buffers.
    //

    DeviceExtension->MapBuffers = configInfo->MapBuffers;


    //
    // Set maximum number of page breaks.
    //

    capabilities->MaximumPhysicalPages = configInfo->NumberOfPhysicalBreaks;

    if (HwInitializationData->ReceiveEvent) {
        capabilities->SupportedAsynchronousEvents |=
            SRBEV_SCSI_ASYNC_NOTIFICATION;
    }

    capabilities->TaggedQueuing = HwInitializationData->TaggedQueuing;
    capabilities->AdapterScansDown = configInfo->AdapterScansDown;
    capabilities->AlignmentMask = configInfo->AlignmentMask;

    //
    // Make sure maximum nuber of pages is set to a reasonable value.
    // This occurs for miniports with no Dma adapter.
    //

    if (capabilities->MaximumPhysicalPages == 0) {

        capabilities->MaximumPhysicalPages =
            (ULONG)ROUND_TO_PAGES(capabilities->MaximumTransferLength) + 1;

        //
        // Honor any limit requested by the miniport.
        //

        if (configInfo->NumberOfPhysicalBreaks < capabilities->MaximumPhysicalPages) {

            capabilities->MaximumPhysicalPages =
                configInfo->NumberOfPhysicalBreaks;
        }
    }

    //
    // Get maximum target IDs.
    //

    if (configInfo->MaximumNumberOfTargets > SCSI_MAXIMUM_TARGETS_PER_BUS) {
        DeviceExtension->MaximumTargetIds = SCSI_MAXIMUM_TARGETS_PER_BUS;
    } else {
        DeviceExtension->MaximumTargetIds =
            configInfo->MaximumNumberOfTargets;
    }

    //
    // Get number of SCSI buses.
    //

    DeviceExtension->NumberOfBuses = configInfo->NumberOfBuses;

    //
    // Call the miniport driver to do its initialization.
    //

    if (!DeviceExtension->HwInitialize(DeviceExtension->HwDeviceExtension)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Issue the inquiry command.
    //

    inquiryData = IssueInquiry ();

    if (inquiryData == NULL) {
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    KdPrintEx ((
        DPFLTR_CRASHDUMP_ID,
        DPFLTR_TRACE_LEVEL,
        "DISKDUMP: Inquiry: Type %d Qual %d Mod %d %s\n",
        (LONG) inquiryData->DeviceType,
        (LONG) inquiryData->DeviceTypeQualifier,
        (LONG) inquiryData->DeviceTypeModifier,
        inquiryData->RemovableMedia ? "Removable" : "Non-Removable"));

    
    //
    // Reset the bus.
    //
    
    succ = ResetBus (DeviceExtension, DeviceExtension->PathId);

    if ( !succ ) {
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Start the device.
    //
    
    srbStatus = StartDevice (
                    DeviceExtension->TargetId,
                    DeviceExtension->Lun);

    if (srbStatus != SRB_STATUS_SUCCESS) {

        //
        // SCSIOP_START_STOP_DEVICE is allowed to fail. Some adapters (AMI MegaRAID)
        // fail this request.
        //
        
        DebugPrint ((0, "DISKDUMP: PathId=%x TargetId=%x Lun=%x failed to start srbStatus = %d\n",
                    DeviceExtension->PathId, DeviceExtension->TargetId,
                    DeviceExtension->Lun, (LONG) srbStatus));
    }

    //
    // Initialize the driver's capacity data (BytesPerSector, etc.)
    //
    
    IssueReadCapacity ();
    
    //
    // NOTE: We may want to go a sanity check that we have actually found
    // the correct drive. On MBR disks this can be accomplished by looking
    // at the NTFT disk signature. On GPT disks we can look at the DiskId.
    // This only makes a difference if the crashdump code gave us the
    // wrong TargetId, Lun, which it should never do.
    //

    DeviceExtension->FoundBootDevice = TRUE;
    status = STATUS_SUCCESS;

done:

    //
    // On failure, free all resources.
    //
    
    if ( !NT_SUCCESS (status) ) {

        //
        // The config info can either come from space we allocated or from
        // the DUMP_INITIALIZATION_CONTEXT. If it was allocated and we failed
        // we need to free it.
        //

        if (allocatedConfigInfo && configInfo != NULL) {
            if (configInfo->AccessRanges != NULL) {
                FreePool (configInfo->AccessRanges);
                configInfo->AccessRanges = NULL;
            }

            FreePool (configInfo);
            configInfo = NULL;
        }

        if (DeviceExtension->HwDeviceExtension) {
            FreePool (DeviceExtension->HwDeviceExtension);
            DeviceExtension->HwDeviceExtension = NULL;
        }

        if (DeviceExtension->SpecificLuExtension) {
            FreePool (DeviceExtension->SpecificLuExtension);
            DeviceExtension->SpecificLuExtension = NULL;
        }
    }

    return (ULONG) status;
}

//
// Routines providing service to hardware dependent driver.
//


SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine returns a 32-bit physical address to which a virtual address
    is mapped. There are 2 types addresses that can be translated via this call:

    - An address of memory from the two common buffers that the system provides
      for the crashdump disk drivers.

    - A data buffer address described in an MDL that the system provided with
      an IO request.

Arguments:

Return Value:

--*/

{
    PSRB_SCATTER_GATHER scatterList;
    PMDL mdl;
    ULONG byteOffset;
    ULONG whichPage;
    PPFN_NUMBER pages;
    PHYSICAL_ADDRESS address;

    //
    // There are two distinct types of memory addresses for which a
    // physical address must be calculated.
    //
    // The first is the data buffer passed in an SRB.
    //
    // The second is an address within the common buffer which is
    // the noncached extension or SRB extensions.
    //

    if (Srb) {

        //
        // There are two distinct types of adapters that require physical
        // addresses.
        //
        // The first is busmaster devices for which scatter/gather lists
        // have already been built.
        //
        // The second is slave or system DMA devices. As the diskdump driver
        // will program the system DMA hardware, the miniport driver will never
        // need to see the physical addresses, so I don't think it will ever
        // make this call.
        //

        if (DeviceExtension->MasterWithAdapter) {

            //
            // A scatter/gather list has already been allocated. Use it to determine
            // the physical address and length.  Get the scatter/gather list.
            //

            scatterList = DeviceExtension->ScatterGather;

            //
            // Calculate byte offset into the data buffer.
            //

            byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)Srb->DataBuffer);

            //
            // Find the appropriate entry in the scatter/gatter list.
            //

            while (byteOffset >= scatterList->Length) {

                byteOffset -= scatterList->Length;
                scatterList++;
            }

            //
            // Calculate the physical address and length to be returned.
            //

            *Length = scatterList->Length - byteOffset;
            address.QuadPart = scatterList->PhysicalAddress.QuadPart + byteOffset;

        } else {

            DebugPrint((0,
                       "DISKDUMP: Jeff led me to believe this code may never get executed.\n"));

            //
            // Get MDL.
            //

            mdl = DeviceExtension->Mdl;

            //
            // Calculate byte offset from
            // beginning of first physical page.
            //

            if (DeviceExtension->MapBuffers) {
                byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)mdl->MappedSystemVa);
            } else {
                byteOffset = (ULONG)((PCHAR)VirtualAddress - (PCHAR)mdl->StartVa);
            }

            //
            // Calculate which physical page.
            //

            whichPage = byteOffset >> PAGE_SHIFT;

            //
            // Calculate beginning of physical page array.
            //

            pages = MmGetMdlPfnArray ( mdl );

            //
            // Calculate physical address.
            //

            address.QuadPart = (pages[whichPage] << PAGE_SHIFT) +
                    BYTE_OFFSET(VirtualAddress);
        }

    } else {

        //
        // Miniport SRB extensions and noncached extensions come from
        // common buffer 0.
        //

        if (VirtualAddress >= DeviceExtension->CommonBuffer[0] &&
            VirtualAddress <
                (PVOID)((PUCHAR)DeviceExtension->CommonBuffer[0] + DeviceExtension->CommonBufferSize)) {

                address.QuadPart =
                    (ULONG_PTR)((PUCHAR)VirtualAddress -
                    (PUCHAR)DeviceExtension->CommonBuffer[0]) +
                    DeviceExtension->LogicalAddress[0].QuadPart;
                *Length = (ULONG)(DeviceExtension->CommonBufferSize -
                                  ((PUCHAR)VirtualAddress -
                                   (PUCHAR)DeviceExtension->CommonBuffer[0]));

        } else if (VirtualAddress >= DeviceExtension->CommonBuffer[1] &&
                   VirtualAddress <
                       (PVOID)((PUCHAR)DeviceExtension->CommonBuffer[1] + DeviceExtension->CommonBufferSize)) {

                address.QuadPart =
                    (ULONG_PTR)((PUCHAR)VirtualAddress -
                    (PUCHAR)DeviceExtension->CommonBuffer[1]) +
                    DeviceExtension->LogicalAddress[1].QuadPart;
                *Length = (ULONG)(DeviceExtension->CommonBufferSize - 
                                  ((PUCHAR)VirtualAddress -
                                   (PUCHAR)DeviceExtension->CommonBuffer[1]));
        } else {

            DbgPrint("Crashdump: miniport attempted to get physical address "
                     "for invalid VA %#p\n", VirtualAddress);
            DbgPrint("Crashdump: Valid range 1: %p through %p\n",
                     (PUCHAR) DeviceExtension->CommonBuffer[0],
                     ((PUCHAR) DeviceExtension->CommonBuffer[0]) + DeviceExtension->CommonBufferSize);
            DbgPrint("Crashdump: Valid ranges 2: %p through %p\n",
                     (PUCHAR) DeviceExtension->CommonBuffer[1],
                     ((PUCHAR) DeviceExtension->CommonBuffer[1]) + DeviceExtension->CommonBufferSize);

            KeBugCheckEx(PORT_DRIVER_INTERNAL,
                         0x80000001,
                         (ULONG_PTR) DeviceExtension,
                         (ULONG_PTR) VirtualAddress,
                         (ULONG_PTR) NULL);

            address.QuadPart = 0;
            *Length = 0;
        }
    }

    return address;
}


PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a
    physical address, if the physical address was obtained by a
    call to ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address if physical page hashed.
    NULL if physical page not found in hash.

--*/

{
    ULONG address = ScsiPortConvertPhysicalAddressToUlong(PhysicalAddress);
    ULONG offset;

    //
    // Check if address is in the range of the first common buffer.
    //

    if (address >= DeviceExtension->PhysicalAddress[0].LowPart &&
        address < (DeviceExtension->PhysicalAddress[0].LowPart +
            DeviceExtension->CommonBufferSize)) {

        offset = address - DeviceExtension->PhysicalAddress[0].LowPart;

        return ((PUCHAR)DeviceExtension->CommonBuffer[0] + offset);
    }

    //
    // Check if the address is in the range of the second common buffer.
    //

    if (address >= DeviceExtension->PhysicalAddress[1].LowPart &&
        address < (DeviceExtension->PhysicalAddress[1].LowPart +
            DeviceExtension->CommonBufferSize)) {

        offset = address - DeviceExtension->PhysicalAddress[1].LowPart;

        return ((PUCHAR)DeviceExtension->CommonBuffer[1] + offset);
    }

    return NULL;

}


PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )

/*++

Routine Description:

    Return miniport driver's logical unit extension.

Arguments:

    HwDeviceExtension - The port driver's device extension follows
        the miniport's device extension and contains a pointer to
        the logical device extension list.

    PathId, TargetId and Lun - identify which logical unit on the
        SCSI buses.

Return Value:

    Miniport driver's logical unit extension

--*/

{
    return DeviceExtension->SpecificLuExtension;

}

VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    PSCSI_REQUEST_BLOCK srb = NULL;

    va_list(ap);

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case NextLuRequest:
        case NextRequest:

            //
            // Start next packet on adapter's queue.
            //

            DeviceExtension->InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case RequestComplete:

            //
            // Record completed request.
            //

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            //
            // Check which SRB is completing.
            //

            if (srb == &DeviceExtension->Srb) {

                //
                // Complete this request.
                //

                DeviceExtension->RequestComplete = TRUE;

            } else if (srb == &DeviceExtension->RequestSenseSrb) {

                //
                // Process request sense.
                //

                RequestSenseCompletion();
            }

            break;

        case ResetDetected:

            //
            // Delay for 4 seconds.
            //

            DeviceExtension->StallRoutine ( RESET_DELAY );
            break;

        case CallDisableInterrupts:

            ASSERT(DeviceExtension->Flags & PD_DISABLE_INTERRUPTS);

            //
            // The miniport wants us to call the specified routine
            // with interrupts disabled.  This is done after the current
            // HwRequestInterrutp routine completes. Indicate the call is
            // needed and save the routine to be called.
            //

            DeviceExtension->Flags |= PD_DISABLE_CALL_REQUEST;

            DeviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case CallEnableInterrupts:

            ASSERT(!(DeviceExtension->Flags & PD_DISABLE_INTERRUPTS));

            //
            // The miniport wants us to call the specified routine
            // with interrupts enabled this is done from the DPC.
            // Disable calls to the interrupt routine, indicate the call is
            // needed and save the routine to be called.
            //

            DeviceExtension->Flags |= PD_DISABLE_INTERRUPTS | PD_ENABLE_CALL_REQUEST;

            DeviceExtension->HwRequestInterrupt = va_arg(ap, PHW_INTERRUPT);

            break;

        case RequestTimerCall:

            DeviceExtension->HwTimerRequest = va_arg(ap, PHW_INTERRUPT);
            DeviceExtension->TimerValue = va_arg(ap, ULONG);

            if (DeviceExtension->TimerValue) {

                //
                // Round up the timer value to the stall time.
                //

                DeviceExtension->TimerValue = (DeviceExtension->TimerValue
                  + PD_INTERLOOP_STALL - 1)/ PD_INTERLOOP_STALL;
            }

            break;
    }

    va_end(ap);

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    WorkHorseDpc();

}


VOID
ScsiPortFlushDma(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine checks to see if the previous IoMapTransfer has been done
    started.  If it has not, then the PD_MAP_TRANSER flag is cleared, and the
    routine returns; otherwise, this routine schedules a DPC which will call
    IoFlushAdapter buffers.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.


Return Value:

    None.

--*/

{
    if (DeviceExtension->InterruptFlags & PD_MAP_TRANSFER) {

        //
        // The transfer has not been started so just clear the map transfer
        // flag and return.
        //

        DeviceExtension->InterruptFlags &= ~PD_MAP_TRANSFER;
        return;
    }

    DeviceExtension->InterruptFlags |= PD_FLUSH_ADAPTER_BUFFERS;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    WorkHorseDpc();

    return;

}


VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    Saves the parameters for the call to IoMapTransfer and schedules the DPC
    if necessary.

Arguments:

    HwDeviceExtension - Supplies a the hardware device extension for the
        host bus adapter which will be doing the data transfer.

    Srb - Supplies the particular request that data transfer is for.

    LogicalAddress - Supplies the logical address where the transfer should
        begin.

    Length - Supplies the maximum length in bytes of the transfer.

Return Value:

   None.

--*/

{
    //
    // Make sure this host bus adapter has an Dma adapter object.
    //
    if (DeviceExtension->DmaAdapterObject == NULL) {
        //
        // No DMA adapter, no work.
        //
        return;
    }

    DeviceExtension->MapTransferParameters.Srb = Srb;
    DeviceExtension->MapTransferParameters.LogicalAddress = LogicalAddress;
    DeviceExtension->MapTransferParameters.Length = Length;

    DeviceExtension->InterruptFlags |= PD_MAP_TRANSFER;

    //
    // Check to see if the last DPC has been processed yet.  If so
    // queue another DPC.
    //

    WorkHorseDpc();

}


VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine does no more than put up a debug print message in a debug
    build.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    DebugPrint((0,"\n\nLogErrorEntry: Logging SCSI error packet. ErrorCode = %d.\n",
        ErrorCode));
    DebugPrint((0,
        "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n\n",
        PathId,
        TargetId,
        Lun,
        UniqueId));

    return;

}


VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PSCSI_REQUEST_BLOCK failingSrb;

    //
    // Check if a request is outstanding.
    //

    if (!DeviceExtension->Mdl) {
        return;
    }

    //
    // Just in case this is an abort request,
    // get pointer to failingSrb.
    //

    failingSrb = srb->NextSrb;

    //
    // Update SRB status and show no bytes transferred.
    //

    srb->SrbStatus = SrbStatus;
    srb->DataTransferLength = 0;

    //
    // Call notification routine.
    //

    ScsiPortNotification(RequestComplete,
                         HwDeviceExtension,
                         srb);

    //
    // Check if this was an ABORT SRB
    //

    if (failingSrb) {

        //
        // This was an abort request. The failing
        // SRB must also be completed.
        //

        failingSrb->SrbStatus = SrbStatus;
        failingSrb->DataTransferLength = 0;

        //
        // Call notification routine.
        //

        ScsiPortNotification(RequestComplete,
                             HwDeviceExtension,
                             failingSrb);
    }

    return;

}


VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source

    WriteBuffer - destination

    Length - number of bytes to copy

Return Value:

    None.

--*/

{
    RtlMoveMemory(WriteBuffer, ReadBuffer, Length);

}


VOID
ScsiPortStallExecution(
    ULONG Delay
    )
/*++

Routine Description:

    Wait number of microseconds in tight processor loop.

Arguments:

    Delay - number of microseconds to wait.

Return Value:

    None.

--*/

{
    DeviceExtension->StallRoutine(Delay);

}



VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
#if DBG

    va_list ap;
    ULONG DebugLevel;

    va_start( ap, DebugMessage );

    switch (DebugPrintLevel) {
        case 0:
            DebugLevel = DPFLTR_WARNING_LEVEL;
            break;

        case 1:
        case 2:
            DebugLevel = DPFLTR_TRACE_LEVEL;
            break;

        case 3:
            DebugLevel = DPFLTR_INFO_LEVEL;
            break;

        default:
            DebugLevel = DebugPrintLevel;
            break;

    }

    vDbgPrintExWithPrefix ("DISKDUMP: ",
                            DPFLTR_CRASHDUMP_ID,
                            DebugLevel,
                            DebugMessage,
                            ap);
    va_end(ap);

#endif

}


UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_UCHAR(Port));
}


USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_USHORT(Port));
}


ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{
    return(READ_PORT_ULONG(Port));
}


UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{
    return(READ_REGISTER_UCHAR(Register));
}


USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{
    return(READ_REGISTER_USHORT(Register));
}


ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{
    return(READ_REGISTER_ULONG(Register));
}


VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);
}


VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);
}


VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);
}


VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_PORT_UCHAR(Port, Value);
}


VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_PORT_USHORT(Port, Value);
}


VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_PORT_ULONG(Port, Value);
}


VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_REGISTER_UCHAR(Register, Value);
}


VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_REGISTER_USHORT(Register, Value);
}


VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{
    WRITE_REGISTER_ULONG(Register, Value);
}


VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);
}


VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);
}


VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);
}


SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    SCSI_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}

#undef ScsiPortConvertPhysicalAddressToUlong

ULONG
ScsiPortConvertPhysicalAddressToUlong(
    SCSI_PHYSICAL_ADDRESS Address
    )
{

    return(Address.LowPart);
}


PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    SCSI_PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    This was done during system initialization for the crash dump driver.

Arguments:

    HwDeviceExtension - used to find port device extension.

    BusType - what type of bus - eisa, mca, isa

    SystemIoBusNumber - which IO bus (for machines with multiple buses).

    IoAddress - base device address to be mapped.

    NumberOfBytes - number of bytes for which address is valid.

    InIoSpace - indicates an IO address.

Return Value:

    Mapped address

--*/

{
    PMAPPED_ADDRESS Addresses = DeviceExtension->MappedAddressList;
    PHYSICAL_ADDRESS CardAddress;
    ULONG AddressSpace = InIoSpace;
    PVOID MappedAddress = NULL;
    BOOLEAN b;

    b = HalTranslateBusAddress(
            BusType,            // AdapterInterfaceType
            SystemIoBusNumber,  // SystemIoBusNumber
            IoAddress,          // Bus Address
            &AddressSpace,      // AddressSpace
            &CardAddress
            );

    if ( !b ) {
        return NULL;
    }

    //
    // If the address space is not in I/O space, then it was mapped during
    // the original system initialization of the driver.  Therefore, it must
    // be in the list of mapped address ranges.  Look it up and return it.
    //

    if (!AddressSpace) {

        while (Addresses) {
            if (SystemIoBusNumber == Addresses->BusNumber &&
                NumberOfBytes == Addresses->NumberOfBytes &&
                IoAddress.QuadPart == Addresses->IoAddress.QuadPart) {
                MappedAddress = Addresses->MappedAddress;
                break;
            }
            Addresses = Addresses->NextMappedAddress;
        }

    } else {

        MappedAddress = (PVOID)(ULONG_PTR)CardAddress.QuadPart;
    }

    return MappedAddress;

}

VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.

    MappedAddress - address to unmap.

    NumberOfBytes - number of bytes mapped.

    InIoSpace - addresses in IO space don't get mapped.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);
    UNREFERENCED_PARAMETER(MappedAddress);

    return;

}


PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function returns the address of the noncached extension for the
    miniport driver.

Arguments:

    DeviceExtension - Supplies a pointer to the miniports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the noncached device extension or
    NULL if the requested extension size is larger than the extension
    that was previously allocated.

--*/

{
    if (DeviceExtension->NonCachedExtensionSize >= NumberOfBytes) {
        return DeviceExtension->NonCachedExtension;
    } else {
        DebugPrint((0,
                   "ScsiPortGetUncachedExtension: Request %x but only %x available\n",
                   NumberOfBytes,
                   DeviceExtension->NonCachedExtensionSize));
        return NULL;
    }
}


ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    ULONG ret;
    
    //
    // If the length is non-zero, the the requested data.
    //

    if (BusDataType == PCIConfiguration) {

        ret = HalGetBusDataByOffset(
                BusDataType,
                SystemIoBusNumber,
                SlotNumber,
                Buffer,
                0,
                Length);

    } else {
        ret = 0;
    }

    return ret;
}


PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension -
    
    PathId -

    TargetId -

    Lun - identify logical unit on SCSI bus.

    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB if outstanding request, otherwise NULL.

--*/

{
    PSCSI_REQUEST_BLOCK srb;
    
    if (DeviceExtension->RequestPending) {
        srb = &DeviceExtension->Srb;
    } else {
        srb = NULL;
    }

    return srb;
}


BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures

    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?

    SystemIoBusNumber - Which system bus?

    IoAddress - Start of range

    NumberOfBytes - Length of range

    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/

{
    //
    // This is not implemented in NT.
    //
    return TRUE;
}


VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);
}


VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);
}


VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);
}


VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);
}


VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);
}


VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Buffer - Supplies a pointer to the data buffer area.

    Count - The count of items to move.

Return Value:

    None

--*/

{
    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);
}


ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    DeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{
    return 0;
    return(HalSetBusDataByOffset(BusDataType,
                                 SystemIoBusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Offset,
                                 Length));

}

BOOLEAN
ResetBus(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    This function will call the miniport's reset routine, and stall for 4 seconds
    before continuing

Arguments:

    DeviceExtension - State information for a particular adapter.

    Pathid - Identifies the SCSI bus to reset

--*/
{
    BOOLEAN result;

    ASSERT ( DeviceExtension != NULL );
    ASSERT ( DeviceExtension->HwReset != NULL );

    
    result = DeviceExtension->HwReset ( DeviceExtension->HwDeviceExtension, PathId );

    //
    // Wait for 4 seconds
    //
    
    DeviceExtension->StallRoutine( RESET_DELAY );

    //
    // Poll the interrupt handler to clear any reset interrupts.
    //

    if (DeviceExtension->HwInterrupt != NULL) {
        DeviceExtension->HwInterrupt(DeviceExtension->HwDeviceExtension);
    }

    return result;
}


VOID
ScsiPortQuerySystemTime(
    OUT PLARGE_INTEGER Time
    )
{
    Time->QuadPart = 0;
}
    

#if 0

//
// The functions ReadSector() and IssueReadCapacity() are
// no longer necessary. They are left here for reference purposes
// only
//


VOID
ReadSector(
    PLARGE_INTEGER ByteOffset
    )

/*++

Routine Description:

    Read 1 sector into common buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb = &DeviceExtension->Srb;
    PCDB cdb = (PCDB)&srb->Cdb;
    ULONG startingSector;
    ULONG retryCount = 0;
    PPFN_NUMBER page;
    PFN_NUMBER localMdl[(sizeof( MDL )/sizeof(PFN_NUMBER)) + (MAXIMUM_TRANSFER_SIZE / PAGE_SIZE) + 2];

    //
    // Zero SRB.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

readSectorRetry:

    //
    // Initialize SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId = DeviceExtension->PathId;
    srb->TargetId = DeviceExtension->TargetId;
    srb->Lun = DeviceExtension->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_IN |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 5;
    srb->CdbLength = 10;
    srb->DataBuffer = DeviceExtension->CommonBuffer[1];
    srb->DataTransferLength = DeviceExtension->BytesPerSector;

    //
    // Build MDL and map it so that it can be used.
    //

    DeviceExtension->Mdl = (PMDL)&localMdl[0];
    MmInitializeMdl(DeviceExtension->Mdl,
                    srb->DataBuffer,
                    srb->DataTransferLength);

    page = MdlGetMdlPfnArray ( DeviceExtension->Mdl );
    *page = (PFN_NUMBER)(DeviceExtension->PhysicalAddress[1].QuadPart >> PAGE_SHIFT);
    MmMapMemoryDumpMdl(DeviceExtension->Mdl);


    //
    // Initialize CDB for READ command.
    //

    cdb->CDB10.OperationCode = SCSIOP_READ;

    //
    // Calculate starting sector.
    //

    startingSector = (ULONG)((*ByteOffset).QuadPart /
                             DeviceExtension->BytesPerSector);

    //
    // SCSI CDBs use big endian.
    //

    cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&startingSector)->Byte3;
    cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&startingSector)->Byte2;
    cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&startingSector)->Byte1;
    cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&startingSector)->Byte0;

    cdb->CDB10.TransferBlocksMsb = 0;
    cdb->CDB10.TransferBlocksLsb = 1;

    //
    // Send SRB to miniport driver.
    //

    ExecuteSrb(srb);


    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS &&
        SRB_STATUS(srb->SrbStatus) != SRB_STATUS_DATA_OVERRUN) {

        DebugPrint((1,
                   "ReadSector: Read sector failed SRB status %x\n",
                   srb->SrbStatus));

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SELECTION_TIMEOUT &&
            retryCount < 2) {

            //
            // If the selection did not time out then retry the request.
            //

            retryCount++;
            goto readSectorRetry;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\ext\ext.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	raid.c

Abstract:

	Extensions for RAID port driver.

Author:

	Matthew D Hendel (math) 14-June-2000

Revision History:


!raid.help

!raid.help

	adapter - Dump an adapter object.

	unit - Dump a unit object.

Type !raid.help "command" for more information about the command.
	


NAME:

	unit

USAGE:

	unit [UNIT-OBJECT [DETAIL]]

ARGUMENTS:

	UNIT-OBJECT - 

	DETAIL - 

----------------------------------------------------------------------------

!raid.adapter

RAID Adapters:

	Name		   DO		  Ext
	-------------------------------------
	dac960nt	84000000	84100000
	foobar		84000000	84100000
	ami95044	84000000	84100000
	XXAABB		84000000	84100000

RAID Units:

	Product         SCSI ID	      DO	      Ext		Reqs
	--------------------------------------------------------------------
	MYLEX DAC960    3   1	1	84000000	84100000	200
	AMI DDD5455	  200 200 200	84000000	84100000	  0

!raid.unit
	Dump a raid unit
	
!raid.adapter
	Dump a raid adapter


--*/

#include "pch.h"
#include "precomp.h"


//
// Prototypes
//

VOID
DumpUnit(
	IN ULONG64 Unit,
	IN ULONG Level
	);

VOID
DumpAdapter(
	IN ULONG64 Adapter,
	IN ULONG Level
	);

//
// Data
//

PCHAR StateTable [] = {
	"Removed",	// not present
	"Working",	// working
	"Stopped",	// stopped
	"P-Stop",	// pending stop
	"P-Remove",	// pending remove
	"Surprise",	// surprise remove
};


BOOLEAN Verbose = FALSE;

//
// Functions
//


BOOLEAN
CheckRaidObject(
	IN ULONG64 Object,
	IN RAID_OBJECT_TYPE ObjectType
	)
{

	ULONG Ret;

	if (Object == 0) {
		return FALSE;
	}
	
	Ret = GetFieldData (Object,
						"raidport!RAID_COMMON_EXTENSION",
						"ObjectType",
						sizeof (ObjectType),
						&ObjectType);
						  

	if (Ret != 0 || ObjectType != ObjectType) {
		return FALSE;
	}

	return TRUE;
}


ULONG64
GetListHead(
	IN ULONG64 Object,
	IN PSZ ObjectType,
	IN PSZ FieldName,
	OUT PULONG64 ListHead
	)
{
	ULONG64 NextEntry;
	ULONG Offset;
	ULONG Ret;

	Ret = GetFieldOffset (ObjectType, FieldName, &Offset);

	if (Ret != 0) {
		return 0;
	}

	*ListHead = (Object + Offset);
	ReadPointer (*ListHead, &NextEntry);

	return NextEntry;
}
	

ULONG64
GetNextListEntry(
	IN ULONG64 ListElement
	)
{
	ULONG64 NextEntry;
	ULONG Ret;
	
	Ret = GetFieldData (ListElement,
						"raidport!LIST_ENTRY",
						"Flink",
						sizeof (NextEntry),
						&NextEntry);

	if (Ret != 0) {
		dprintf ("ERROR: Couldn't get next list entry for element %08x\n", ListElement);
		return 0;
	}
	
	return NextEntry;
}

ULONG64
ContainingRecord(
	IN ULONG64 Object,
	IN PSZ ObjectType,
	IN PSZ FieldName
	)
{
	ULONG Offset;
	ULONG Ret;
	
	Ret = GetFieldOffset (ObjectType, FieldName, &Offset);

	if (Ret != 0) {
		return 0;
	}
	
	return (Object - Offset);
}

	

VOID
ListDriverAdapters(
	IN ULONG64 Driver,
	IN ULONG Level
	)
{
	ULONG64 ListHead;
	ULONG64 Adapter;
	ULONG64 NextEntry;
	
#if 0
	BOOLEAN Succ;
	
	Succ = GetDriverInformation (Driver,
								 DriverName,
								 &BaseAddress,
								 &CreationTime);

	if (!Succ) {
		return;
	}

	GetFieldOffset ("raidport!RAID_DRIVER_EXTENSION",
					"AdapterList.List",
					&Offset);

	ListHead = Driver + Offset;
#endif

	NextEntry = GetListHead (Driver,
							 "raidport!RAID_DRIVER_EXTENSION",
							 "AdapterList.List.Flink",
							 &ListHead);

	if (Verbose) {
		dprintf ("VERBOSE: ListHead = %08x, NextEntry = %08x\n",
				 (ULONG)ListHead, (ULONG)NextEntry);
	}
	for ( /* NOTHING */ ;
		 NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		if (Verbose) {
			dprintf ("VERBOSE: Adapter ListEntry %08x\n", NextEntry);
		}
		
		Adapter = ContainingRecord (NextEntry,
									"raidport!RAID_ADAPTER_EXTENSION",
									"NextAdapter");

		if (!CheckRaidObject (Adapter, RaidAdapterObject)) {
			dprintf ("ERROR: Object at %08x not an raid adapter\n", Adapter);
			return;
		}

		if (CheckControlC()) {
			return;
		}

		DumpAdapter (Adapter, Level);
	}
}

ULONG64
GetPortData(
	)
{	
	ULONG Ret;
	ULONG64 PortDataPtr;
	ULONG64 PortData;
	
	PortDataPtr = GetExpression ("raidport!RaidpPortData");
	if (PortDataPtr == 0) {
		dprintf ("ERROR: couldn't get raidport!RaidpPortData\n");
		return 0;
	}
	ReadPointer (PortDataPtr, &PortData);

	return PortData;
}


VOID
ListAllAdapters(
	IN ULONG Level
	)
{
	ULONG Ret;
	ULONG64 PortDataPtr;
	ULONG64 PortData;
	ULONG64 ListHead;
	ULONG64 NextEntry;
	ULONG64 Driver;
	ULONG Offset;

	
	PortDataPtr = GetExpression ("raidport!RaidpPortData");
	if (PortDataPtr == 0) {
		dprintf ("ERROR: couldn't get raidport!RaidpPortData\n");
		return;
	}
	ReadPointer (PortDataPtr, &PortData);
	Ret = GetFieldOffset ("raidport!RAID_PORT_DATA",
						  "DriverList.List",
						  &Offset);

	if (Ret != 0) {
		dprintf ("ERROR: Could lookup RAID_PORT_DATA structure\n");
		return ;
	}

	ListHead = PortData + Offset;

	if (Verbose) {
		dprintf ("VERBOSE: dumping adapter list at %I64x\n", ListHead);
	}

	dprintf ("Driver     Object     Ext     State\n");
	dprintf ("--------------------------------------------------------\n");

	for (GetFieldValue (ListHead, "raidport!LIST_ENTRY", "Flink", NextEntry);
		 NextEntry != 0 && NextEntry != ListHead;
		 GetFieldValue (NextEntry, "raidport!LIST_ENTRY", "Flink", NextEntry)) {

		GetFieldOffset ("raidport!RAID_DRIVER_EXTENSION", "DriverLink", &Offset);

		if (Verbose) {
			dprintf ("VERBOSE: ListEntry at %08x\n", NextEntry);
		}
			
		Driver = NextEntry - Offset;

		if (Verbose) {
			dprintf ("VERBOSE: Driver at %08x\n", Driver);
		}
		
		if (!CheckRaidObject (Driver, RaidDriverObject)) {
			dprintf ("ERROR: %08x is not a driver object\n", Driver);
			return;
		}

		if (CheckControlC()) {
			return;
		}
			
		if (Verbose) {
			dprintf ("VERBOSE: dumping driver at %I64x\n", Driver);
		}

		ListDriverAdapters (Driver, Level);
	}

	dprintf ("\n");
}

VOID
ListAdapterUnits(
	IN ULONG64 Adapter,
	IN ULONG Level
	)
{
	ULONG64 NextEntry;
	ULONG64 Unit;
	ULONG64 ListHead;
	
	NextEntry = GetListHead (Adapter,
							 "raidport!RAID_ADAPTER_EXTENSION",
							 "UnitList.List.Flink",
							 &ListHead);

	for ( ;
		 NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		Unit = ContainingRecord (NextEntry,
								 "raidport!RAID_UNIT_EXTENSION",
								 "NextUnit");

		if (!CheckRaidObject (Unit, RaidUnitObject)) {
			dprintf ("ERROR: Object at %08x is not a raid unit object\n", Unit);
			return;
		}

		if (CheckControlC()) {
			return;
		}

		DumpUnit (Unit, Level);
	}
}

VOID
ListDriverUnits(
	IN ULONG64 Driver,
	IN ULONG Level
	)
{
	ULONG64 ListHead;
	ULONG64 Adapter;
	ULONG64 NextEntry;
	
	NextEntry = GetListHead (Driver,
							 "raidport!RAID_DRIVER_EXTENSION",
							 "AdapterList.List.Flink",
							 &ListHead);

	if (Verbose) {
		dprintf ("VERBOSE: ListHead = %08x, NextEntry = %08x\n",
				 (ULONG)ListHead, (ULONG)NextEntry);
	}

	for ( ;
		 NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		if (Verbose) {
			dprintf ("VERBOSE: Adapter ListEntry %08x\n", NextEntry);
		}
		
		Adapter = ContainingRecord (NextEntry,
									"raidport!RAID_ADAPTER_EXTENSION",
									"NextAdapter");

		if (!CheckRaidObject (Adapter, RaidAdapterObject)) {
			dprintf ("ERROR: Object at %08x not an raid adapter\n", Adapter);
			return;
		}

		if (CheckControlC()) {
			return;
		}

		ListAdapterUnits (Adapter, Level);
	}
}

VOID
ListAllUnits(
	IN ULONG Level
	)
{
	ULONG64 PortData;
	ULONG64 NextEntry;
	ULONG64 Driver;
	ULONG64 ListHead;
	
	PortData = GetPortData ();

	NextEntry = GetListHead (PortData,
							 "raidport!RAID_PORT_DATA",
							 "DriverList.List.Flink",
							 &ListHead);

	dprintf ("Product           SCSI ID     OBJ        EXT       Reqs   State\n");
	dprintf ("--------------------------------------------------------------\n");

	for ( ;
	     NextEntry != 0 && NextEntry != ListHead;
		 NextEntry = GetNextListEntry (NextEntry)) {

		Driver = ContainingRecord (NextEntry,
								   "raidport!RAID_DRIVER_EXTENSION",
								   "DriverLink");

		if (Verbose) {
			dprintf ("VERBOSE: dumping driver %08x\n", Driver);
		}
								   
		if (!CheckRaidObject (Driver, RaidDriverObject)) {
			dprintf ("ERROR: Object at %08x not a raid driver\n", Driver);
			return;
		}
		
		if (CheckControlC()) {
			return;
		}

		ListDriverUnits (Driver, Level);
	}

	dprintf ("\n");
}



PCHAR
StateToString(
	IN ULONG State
	)
{
	if (State > 5) {
		return "invalid state";
	}
	return StateTable[State];
}


ULONG64
GetDriverObject(
	IN ULONG64 Driver
	)
{
	ULONG Ret;
	CSHORT Type;
	ULONG64 DriverObject;
	
	if (CheckRaidObject (Driver, RaidDriverObject)) {
		Ret = GetFieldData (Driver,
						    "raidport!RAID_DRIVER_EXTENSION",
						    "DriverObject",
						    sizeof (DriverObject),
							&DriverObject);

		if (Ret != 0) {
			DriverObject = 0;
		}
	} else {
		DriverObject = Driver;
	}

	Ret = GetFieldValue (DriverObject, "raidport!DRIVER_OBJECT", "Type", Type);

	if (Ret != 0 || Type != IO_TYPE_DRIVER) {
		DriverObject = 0;
		if (Verbose) {
			dprintf ("VERBOSE: %08x is not a RAID_DRIVER_EXTENSION or DRIVER_OBJECT\n");
		}
	}

	return DriverObject;
}


VOID
GetDriverName(
	IN ULONG64 Driver,
	IN PUCHAR Buffer
	)
{
	ULONG Count;
	ULONG Offset;
	WCHAR UnicodeBuffer[256];
	ULONG Ret;
	ULONG BytesRead;
	ULONG64 DriverObject;
	ULONG64 String;
	PWCHAR DriverName;

	DriverObject = GetDriverObject (Driver);

	if (DriverObject == 0) {
		dprintf ("ERROR: %08x is not a driver\n", DriverObject);
		return;
	}

	if (Verbose) {
		dprintf ("VERBOSE: Getting driver name for DRIVER_OBJECT %08x\n", DriverObject);
	}

	Ret = GetFieldData (DriverObject,
				        "raidport!DRIVER_OBJECT",
						"DriverName.Length",
						sizeof (Count),
						&Count);

	if (Ret != 0) {
		dprintf ("ERROR: couldn't get field of DRIVER_OBJECT. Symbols may be bad.\n");
		return;
	}

	Ret = GetFieldOffset("raidport!DRIVER_OBJECT",
						 "DriverName.Buffer",
						 &Offset);

	if (Ret != 0) {
		dprintf ("ERROR: couldn't get field of DRIVER_OBJECT. Symbols may be bad.\n");
		return;
	}
	
	if (Count > 0 && Count <= 256) {
		ReadPointer (DriverObject + Offset, &String);
		ReadMemory (String, UnicodeBuffer, Count, &BytesRead);
	}

	UnicodeBuffer[Count++] = '\000';
	DriverName = wcsrchr (UnicodeBuffer, L'\\');
	if (DriverName == NULL) {
		DriverName = UnicodeBuffer;
	} else {
		DriverName++;
	}

	sprintf (Buffer, "%ws", DriverName);
}
	

BOOLEAN
IsDeviceObject(
	IN ULONG64 DeviceObject
	)
{
	CSHORT Type;

	GetFieldValue (DeviceObject, "raidport!DEVICE_OBJECT", "Type", Type);

	return (Type == IO_TYPE_DEVICE);
}


ULONG64
GetDeviceExtension(
	IN ULONG64 DeviceObject
	)
{
	ULONG Ret;
	ULONG Offset;
	ULONG64 Extension = -1;

	Ret = GetFieldOffset ("raidport!DEVICE_OBJECT",
						  "DeviceExtension",
						  &Offset);

	if (Ret != 0) {
		if (Verbose) {
			dprintf ("VERBOSE: couldn't read DeviceExtension\n");
		}

		return 0;
	}

	ReadPointer (DeviceObject + Offset, &Extension);

	return Extension;
}

ULONG
GetEmbeddedRemlockCount(
	IN ULONG64 ObjectPtr,
	IN PSZ ObjectType,
	IN PSZ FieldName
	)
{
	ULONG Ret;
	ULONG Remlock_IoCount;
	ULONG Remlock_Offset;
	ULONG Remlock_Common_Offset;
	
	
	Remlock_IoCount = -1;
	Ret = GetFieldOffset (ObjectType,
						  FieldName,
						  &Remlock_Offset);
	if (Ret == STATUS_SUCCESS) {
		Ret = GetFieldOffset ("raidport!IO_REMOVE_LOCK",
							  "Common",
							  &Remlock_Common_Offset);
		if (Ret == STATUS_SUCCESS) {
			GetFieldData (ObjectPtr + Remlock_Offset + Remlock_Common_Offset,
						  "raidport!IO_REMOVE_LOCK_COMMON_BLOCK",
						  "IoCount",
						  sizeof (Remlock_IoCount),
						  &Remlock_IoCount);
		}
	}

	if (Ret != STATUS_SUCCESS) {
		printf ("WARN: couldn't get IO_REMOVE_LOCK status\n");
	}

	return Remlock_IoCount;
}

	

ULONG64
GetAdapterExtension(
	IN ULONG64 Adapter
	)
{
	ULONG64 Temp;
	ULONG64 AdapterExt;
	ULONG64 DeviceObject;

	
	if (CheckRaidObject (Adapter, RaidAdapterObject)) {
		AdapterExt = Adapter;
		InitTypeRead (AdapterExt, raidport!RAID_ADAPTER_EXTENSION);
		DeviceObject = ReadField (DeviceObject);
		if (Verbose) {
			dprintf ("VERBOSE: Checking if %08x is a device object\n", DeviceObject);
		}
		if (IsDeviceObject (DeviceObject)) {
			Temp = GetDeviceExtension (DeviceObject);
			if (Verbose) {
				dprintf ("VERBOSE: Ext = %08x, Computed Ext = %08x\n",
						 AdapterExt, Temp);
			}
			if (Temp == AdapterExt) {
				return AdapterExt;
			}
		} else {
			if (Verbose) {
				dprintf ("VERBOSE: %08x is not a device object\n", DeviceObject);
			}
		}
	} else {
		if (Verbose) {
			dprintf ("VERBOSE: %08x not a RaidAdapterObject\n");
		}
	}

	if (IsDeviceObject (Adapter)) {
		AdapterExt = GetDeviceExtension (Adapter);
		if (Verbose) {
			dprintf ("VERBOSE: Checking if %08x is an adapter extension\n", AdapterExt);
		}
		if (CheckRaidObject (AdapterExt, RaidAdapterObject)) {
			InitTypeRead (AdapterExt, raidport!RAID_ADAPTER_EXTENSION);
			DeviceObject = ReadField (DeviceObject);
			if (DeviceObject == Adapter) {
				return AdapterExt;
			} else if (Verbose) {
				dprintf ("VERBOSE: DO %I64x != Adapter %I64x\n",
						 (ULONG)DeviceObject,
						 (ULONG)Adapter);
			}
				
		} else if (Verbose) {
			dprintf ("VERBOSE: Ext %08x not RaidAdapterObject\n",
					 (ULONG)AdapterExt);
		}
	}


	return 0;
}

VOID
DumpMiniport(
	IN ULONG64 AdapterPtr
	)
{
	ULONG Ret;
	ULONG Offset;
	ULONG64 HwDeviceExt;
	ULONG64 DeviceExtPtr;
	ULONG64 MiniportPtr;
	ULONG64 HwInitData;

	//
	// PortConfig 80000000  HwInitData 77000000 HwDeviceExt a0000000 27 bytes
	// LuExt 32 bytes SrbExt 32 bytes
	//
	
	GetFieldOffset ("raidport!RAID_ADAPTER_EXTENSION",
					"Miniport",
					&Offset);
	MiniportPtr = AdapterPtr + Offset;

	InitTypeRead (MiniportPtr, raidport!RAID_MINIPORT);

	HwInitData = ReadField (HwInitializationData);

	GetFieldOffset ("raidport!RAID_MINIPORT",
					"PortConfiguration",
					&Offset);

	dprintf ("  PortConfig %08x HwInit %08x\n", (ULONG)(MiniportPtr + Offset),
			  (ULONG)HwInitData);
	
	DeviceExtPtr = ReadField (PrivateDeviceExt);

	if (DeviceExtPtr == 0) {
		HwDeviceExt = 0;
	} else {
		Ret = GetFieldOffset ("raidport!RAID_HW_DEVICE_EXT",
							  "HwDeviceExtension",
							  &Offset);
		if (Ret != 0) {
			HwDeviceExt = 0;
		} else {
			HwDeviceExt = DeviceExtPtr + Offset;
		}
	}

	InitTypeRead (HwInitData, raidport!HW_INITIALIZATION_DATA);

	dprintf ("  HwDeviceExt %08x %d bytes\n",
				(ULONG)HwDeviceExt, (ULONG)ReadField (DeviceExtensionSize));

	dprintf ("  LuExt %d bytes  SrbExt %d bytes\n",
				(ULONG)ReadField (SpecificLuExtensionSize),
				(ULONG)ReadField (SrbExtensionSize));
}
	
VOID
DumpAdapter(
	IN ULONG64 Adapter,
	IN ULONG Level
	)
/*++

ADAPTER f0345600
  Ext 8e000000 Driver 8000000 Next 8000000 Working
  LDO 80000000 PDO 00000000 HwExt 00000000 
  SlowLock Free  RemLock 10 Power D0 S0  Full Duplex
  Bus 08080808 Number 1 Slot 0 Dma 88888888 Interrupt 88888888
  AdQueue: Outstanding 200, Low 100, High 200 Busy
  ResourceList: Allocated 80808080 Translated 80808080

  MappedAddressList:

	Virtual  Physical         Size Bus
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1
	80808080 8000000000000000 1500  1

*/
	

  
 
{
	ULONG64 AdapterPtr;
	ULONG64 Driver;
	CHAR DriverName[100];

	if (Verbose) {
		dprintf ("VERBOSE: dumping adapter %08x\n", Adapter);
	}

	AdapterPtr = GetAdapterExtension (Adapter);

	if (AdapterPtr == 0) {
		dprintf ("ERROR: %08x is not a valid adapter object\n", Adapter);
		return;
	}
	
	if (Level == 0) {

		Driver = ReadField (Driver);
		GetDriverName (Driver, DriverName);
		dprintf ("%8.8s  %08x  %08x  %s\n",
				 DriverName,
				 (ULONG)ReadField (DeviceObject),
				 (ULONG)Adapter,
				 StateToString ((ULONG)ReadField (DeviceState))
				 );
	} else {
		PSZ Adapter_SlowLock;
		ULONG Remlock_IoCount;
		

		dprintf ("ADAPTER %08x\n", ReadField (DeviceObject));
		dprintf ("  Ext %08x  Driver %08x  Next %08x  %s\n",
					(ULONG)AdapterPtr,
					(ULONG)ReadField (Driver),
					(ULONG)0,
					StateToString ((ULONG)ReadField (DeviceState)));


		dprintf ("  LDO %08x  PDO %08x\n",
				  (ULONG)ReadField (LowerDeviceObject),
				  (ULONG)ReadField (PhysicalDeviceObject));

		if (ReadField ("SlowLock") == 0) {
			Adapter_SlowLock = "Free";
		} else {
			Adapter_SlowLock = "Held";
		}

		Remlock_IoCount = GetEmbeddedRemlockCount (AdapterPtr,
												   "raidport!RAID_ADAPTER_EXTENSION",
												   "RemoveLock");

		dprintf ("  SlowLock %s  RemLock %d  Power %s %s  %s\n",
				  Adapter_SlowLock,
				  Remlock_IoCount,
				  "S0", "D0",
				  (ReadField (Mode) == RaidSynchronizeFullDuplex ?
														"Full Duplex" : 
														"Half Duplex")
				  );
				  
		dprintf ("  Bus %08x Number %d Slot %d  Dma %08x  Interrupt %08x\n",
				  (ULONG)0,
				  (ULONG)ReadField (BusNumber),
				  (ULONG)ReadField (SlotNumber),
				  (ULONG)ReadField (Dma.DmaAdapter),
				  (ULONG)ReadField (Interrupt));

		dprintf ("  ResourceList: Allocated %08x Translated %08x\n",
				  (ULONG)ReadField (ResourceList.AllocatedResources),
				  (ULONG)ReadField (ResourceList.TranslatedResources));

		dprintf ("  Gateway: Outstanding %d Lower %d High %d\n",
					ReadField (AdapterQueue->Outstanding),
					ReadField (AdapterQueue->LowWaterMark),
					ReadField (AdapterQueue->HighWaterMark));

		DumpMiniport (AdapterPtr);
		
					
	}
}


VOID
FixPaddedString(
	PSZ String
	)
{
	ULONG Pos;
	
	Pos = strlen (String);
	if (Pos > 0) {
		Pos--;
	}
	
	while (Pos && String[Pos] == ' ') {
		String[Pos--] = '\000';
	}
}


VOID
GetUnitProductInfo(
	ULONG64 Unit,
	PSZ VendorId,
	PSZ ProductId,
	PSZ Revision
	)
{
	ULONG Offset;
	ULONG64 InquiryData;
	
	GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
					"InquiryData",
					&Offset);

	ReadPointer (Unit + Offset, &InquiryData);

	if (VendorId) {
		ZeroMemory (VendorId, 9);
		GetFieldData (InquiryData,
				  "raidport!INQUIRYDATA",
				  "VendorId",
				  8,
				  VendorId);
		FixPaddedString (VendorId);
	}

	if (ProductId) {
		ZeroMemory (ProductId, 17);
		GetFieldData (InquiryData,
				  "raidport!INQUIRYDATA",
				  "ProductId",
				  16,
				  ProductId);
		FixPaddedString (ProductId);
	}

	if (Revision) {
		ZeroMemory (Revision, 5);
		GetFieldData (InquiryData,
				  "raidport!INQUIRYDATA",
				  "ProductRevisionLevel",
				  4,
				  Revision);
		FixPaddedString (Revision);
	}
}


ULONG
GetUnitIoQueueRequests(
	IN ULONG64 UnitPtr
	)
{
	ULONG Ret;
	ULONG64 Unit_IoQueue;
	ULONG64 IoQueue_DeviceQueue;
	ULONG Offset;
	ULONG Requests;
	
	Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
						  "IoQueue",
						  &Offset);

	if (Ret != STATUS_SUCCESS) {
		dprintf ("WARN: failed to get IoQueue offset from unit.\n");
	}

	Unit_IoQueue = UnitPtr + Offset;

	Ret = GetFieldOffset ("raidport!IO_QUEUE",
						  "DeviceQueue",
						  &Offset);
	if (Ret != STATUS_SUCCESS) {
		dprintf ("WARN: failed to get DeviceQueue offset from unit(1).\n");
	}

	IoQueue_DeviceQueue = Unit_IoQueue + Offset;

	GetFieldData (IoQueue_DeviceQueue,
				  "raidport!EXTENDED_DEVICE_QUEUE",
				  "OutstandingRequests",
				  sizeof (Requests),
				  &Requests);

	return Requests;
}


VOID
DumpUnit(
	IN ULONG64 Unit,
	IN ULONG Level
	)
{
	ULONG64 UnitPtr;
	CSHORT DeviceObject_Type;
	
	GetFieldValue (Unit, "raidport!DEVICE_OBJECT", "Type", DeviceObject_Type);

	if (DeviceObject_Type == IO_TYPE_DEVICE) {
		GetFieldValue (Unit, "raidport!DEVICE_OBJECT", "DeviceExtension", UnitPtr);
		if (!CheckRaidObject (UnitPtr, RaidUnitObject)) {
			dprintf ("ERROR: DeviceObject %8.8x is not a raid unit\n", UnitPtr);
			return;
		}
	} else if (CheckRaidObject (Unit, RaidUnitObject)) {
		UnitPtr = Unit;
	} else {
		dprintf ("ERROR: Pointer %8.8x is not a device object or raid unit object\n",
				  Unit);
		return;
	}

	InitTypeRead (UnitPtr, raidport!RAID_UNIT_EXTENSION);

	if (Level == 0) {
		
		CHAR VendorId[9] = {0};
		CHAR ProductId[17] = {0};
		CHAR Product[25];

		GetUnitProductInfo (UnitPtr, VendorId, ProductId, NULL);

		sprintf (Product, "%s %s", VendorId, ProductId);
		
		
		dprintf ("%-15.15s %3d %3d %3d   %08x   %08x   %-3d   %-8.8s\n",
				 Product,
				 (ULONG)ReadField (PathId),
				 (ULONG)ReadField (TargetId),
				 (ULONG)ReadField (Lun),				 
				 (ULONG)ReadField (DeviceObject),
				 (ULONG)UnitPtr,
				 GetUnitIoQueueRequests (UnitPtr),
				 StateToString ((ULONG)ReadField (DeviceState)));
	} else {

		ULONG Ret;
		ULONG Remlock_IoCount;
		ULONG Remlock_Offset;
		ULONG Remlock_Common_Offset;
		PCHAR SlowLock;
		ULONG64 Unit_QueueFrozen;
		ULONG64 Unit_QueueLocked;
		ULONG64 Unit_TagList;
		ULONG64 Unit_IoQueue;
		ULONG64 IoQueue_DeviceQueue;
		ULONG Offset;
		ULONG Device_Offset;
		ULONG ByPass_Offset;
		ULONG64 Pointer;
		CHAR VendorId[9] = {0};
		CHAR ProductId[17] = {0};
		CHAR Revision[5] = {0};
		ULONG64 InquiryData;
		
		
		dprintf ("UNIT %08x\n", ReadField (DeviceObject));
		dprintf ("  Ext %08x  Adapter %08x  Next %08x %s\n",
				  (ULONG)UnitPtr,
				  (ULONG)ReadField(Adapter),
				  (ULONG) 0 /*BUGBUG: pull out NextField*/,
				  StateToString((ULONG)ReadField(DeviceState)));

		GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
					"InquiryData",
					&Offset);

		ReadPointer (UnitPtr + Offset, &InquiryData);
		
		GetUnitProductInfo (UnitPtr, VendorId, ProductId, Revision);

		dprintf ("  SCSI %d %d %d  %s %s %s  Inquiry %08x\n",
				  (ULONG)ReadField(PathId),
				  (ULONG)ReadField(TargetId),
				  (ULONG)ReadField(Lun),
				  VendorId,
				  ProductId,
				  Revision,
				  (ULONG)InquiryData);
				  
		Remlock_IoCount = -1;
		Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
							  "RemoveLock",
							  &Remlock_Offset);
		if (Ret == STATUS_SUCCESS) {
			Ret = GetFieldOffset ("raidport!IO_REMOVE_LOCK",
								  "Common",
								  &Remlock_Common_Offset);
			if (Ret == STATUS_SUCCESS) {
				GetFieldData (UnitPtr + Remlock_Offset + Remlock_Common_Offset,
							  "raidport!IO_REMOVE_LOCK_COMMON_BLOCK",
							  "IoCount",
							  sizeof (Remlock_IoCount),
							  &Remlock_IoCount);
			}
		}

		if (Ret != STATUS_SUCCESS) {
			printf ("WARN: couldn't get IO_REMOVE_LOCK status\n");
		}


		if (ReadField ("SlowLock") == 0) {
			SlowLock = "Free";
		} else {
			SlowLock = "Held";
		}
		
		dprintf ("  SlowLock %s  RemLock %d  PageCount %d\n",
				 SlowLock,
				 Remlock_IoCount,
				 (ULONG)ReadField (PagingPathCount));

		Pointer = ReadField (SrbExtensionRegion.VirtualBase);
		dprintf ("  SrbExtension Size %d  Start %08x  End %08x\n",
				 0, // BUGBUG: Get srb extension size from the miniport
				 (ULONG)Pointer,
				 (ULONG)Pointer + (ULONG)ReadField (SrbExtensionRegion.Length));

		Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
							  "TagList",
							  &Offset);

		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: Couldn't read TagList field\n");
		}

		Unit_QueueFrozen = ReadField (Flags.QueueFrozen);
		Unit_QueueLocked = ReadField (Flags.QueueLocked);
		
		Unit_TagList = UnitPtr + Offset;
		
		dprintf ("  TagList %08x (%d of %d used)\n",
				 (ULONG)(Unit_TagList),
				 (ULONG)ReadField(TagList.OutstandingTags),
				 (ULONG)ReadField(TagList.Count));

		Ret = GetFieldOffset ("raidport!RAID_UNIT_EXTENSION",
							  "IoQueue",
							  &Offset);

		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: failed to get IoQueue offset from unit.\n");
		}
		Unit_IoQueue = UnitPtr + Offset;

		Ret = GetFieldOffset ("raidport!IO_QUEUE",
							  "DeviceQueue",
							  &Offset);
		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: failed to get DeviceQueue offset from unit.\n");
		}

		IoQueue_DeviceQueue = Unit_IoQueue + Offset;
		InitTypeRead (IoQueue_DeviceQueue, raidport!EXTENDED_DEVICE_QUEUE);

		dprintf ("  IoQueue %s %s; Outstanding %d  Device %d  ByPass %d\n",
				  Unit_QueueFrozen ? "Frozen" : "Unfrozen",
				  Unit_QueueLocked ? "Locked" : "Unlocked",
				  (ULONG)ReadField(OutstandingRequests),
				  (ULONG)ReadField(DeviceRequests),
				  (ULONG)ReadField(ByPassRequests));

		Ret = GetFieldOffset ("raidport!EXTENDED_DEVICE_QUEUE",
							  "DeviceListHead",
							  &Device_Offset);

		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: offset of DeviceListHead within EXTENDED_DEVICE_QUEUE failed\n");
		}

		Ret = GetFieldOffset ("raidport!EXTENDED_DEVICE_QUEUE",
							  "ByPassListHead",
							  &ByPass_Offset);


		if (Ret != STATUS_SUCCESS) {
			dprintf ("WARN: offset of ByPassListHead within EXTENDED_DEVICE_QUEUE failed\n");
		}

		dprintf ("          Depth %d DeviceList %08x ByPassList %08x\n",
				 (ULONG)ReadField(Depth),
				 (ULONG)(IoQueue_DeviceQueue + Device_Offset),
				 (ULONG)(IoQueue_DeviceQueue + ByPass_Offset));
	}
				 
				 
/*

UNIT 8f888888
  Ext 8e000000 Adapter 8100000000  Next 8e888888 Working
  SCSI [3, 0, 0]  MYLEX DAC960 122222  InquiryData 08080808
  SlowLock Free  RemLock 10  PageCount 20
  SrbExtension Size 20  VA Start 90000000 End 20000000
  TagList 08080808 (20 of 256 used)
  IoQueue Unfrozen Unlocked; Outstanding 200, Device 200, ByPass 200
          Depth 254 DeviceListHead 00000000 ByPassListHead 88888888

  Outstanding IRPs:

	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function
	IRP 00000000 Scsi ExecuteScsi function

  Device IRPs:

	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss

  ByPass IRPs:

	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss
	IRP 00000000 ssssssssssssssssssssssss


*/
}


VOID
ParseArgs(
	IN PSZ Args,
	OUT PULONG64 UnitPtr,
	OUT PULONG Level
	)
{
	LONG Unit;
	
	*UnitPtr = -1;
	*Level = 0;

	if (Args[0] != '\000') {
		Unit = (LONG)strtoul (Args, &Args, 16);
		*UnitPtr = (ULONG64)(LONG64)Unit;
		
		if (Args[0] != '\000') {
			strtoul (Args, &Args, 10);
		}
	}
}

	

DECLARE_API ( unit )
{
	ULONG Level;
	ULONG64 Unit;

	Unit = -1;
	Level = -1;

	ParseArgs ( (PSZ)args, &Unit, &Level);

	if (Unit == -1) {
		if (Level == -1) {
			Level = 1;
		}
		ListAllUnits (Level);
	} else {
		if (Level == -1) {
			Level = 2;
		}
		DumpUnit (Unit, 2);
	}

	return S_OK;
}


DECLARE_API ( adapter )
{
	ULONG Level;
	ULONG64 Adapter;

	Adapter = -1;
	Level = -1;
	
	ParseArgs ( (PSZ)args, &Adapter, &Level);

	if (Adapter == -1) {
		if (Level == -1) {
			Level = 1;
		}
		ListAllAdapters (Level);
	} else {
		if (Level == -1) {
			Level = 2;
		}
		DumpAdapter (Adapter, 2);
	}

	return S_OK;
}


DECLARE_API ( verbose )
{
	ULONG NewValue;
	
	NewValue = strtoul (args, NULL, 16);
	dprintf ("Setting Verbose from %d to %d\n", (ULONG)Verbose, (ULONG)NewValue);
	Verbose = (BOOLEAN) NewValue;

	return S_OK;
}


	

	

DECLARE_API ( help )
{
		dprintf ("  !raid.help [command]             -  Get help.\n");
		dprintf ("  !raid.adapter [adapter [detail]] -  Get adapter information.\n");
		dprintf ("  !raid.unit [unit [detail]]       -  Get unit information.\n");

#if 0
	if (args != NULL && (_stricmp (args, "adapter") == 00)) {
		dprintf ("------------------------------------------------------------------------------\n");
		dprintf ("\n");
		dprintf ("NAME:\n");
		dprintf ("\n");
		dprintf ("    !raid.adapter\n");
		dprintf ("\n");
		dprintf ("USAGE:\n");
		dprintf ("\n");
		dprintf ("    adapter [ADAPTER-OBJECT [DETAIL-LEVEL]]\n");
		dprintf ("\n");
		dprintf ("ARGUMENTS:\n");
		dprintf ("\n");
		dprintf ("    ADAPTER-OBJECT - Pointer to a device object representing an adapter\n");
		dprintf ("    or pointer to an adapter extension. If ADAPTER is 0 or the\n");
		dprintf ("    argument is not present, the command will dump information about\n");
		dprintf ("    all adapters, not just the adapter specified.\n");
		dprintf ("\n");
		dprintf ("    DETAIL-LEVEL - Detail level for dump adapter structs.\n");
		dprintf ("\n");
		dprintf ("-----------------------------------------------------------------------------\n");
	} else if (args != NULL && (_stricmp (args, "unit") == 00)) {
		dprintf ("Unit help\n");
	} else {
		dprintf ("  !raid.help [command]             -  Get help.\n");
		dprintf ("  !raid.adapter [adapter [detail]] -  Get adapter information.\n");
		dprintf ("  !raid.unit [unit [detail]]       -  Get unit information.\n");
	}
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\partmgr\pmwmicnt.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmicnt.h

Abstract:

    This file contains the prototypes of the routines to manage and 
    maintain the disk perf counters.  

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include <ntddk.h>
#include <ntddvol.h>
#include <ntdddisk.h>

NTSTATUS
PmWmiCounterEnable(
    IN OUT PVOID* CounterContext
    );

BOOLEAN
PmWmiCounterDisable(
    IN PVOID* CounterContext,
    IN BOOLEAN ForceDisable,
    IN BOOLEAN DeallocateOnZero
    );

VOID
PmWmiCounterIoStart(
    IN PVOID CounterContext,
    OUT PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterIoComplete(
    IN PVOID CounterContext,
    IN PIRP Irp,
    IN PLARGE_INTEGER TimeStamp
    );

VOID
PmWmiCounterQuery(
    IN PVOID CounterContext,
    IN OUT PDISK_PERFORMANCE CounterBuffer,
    IN PWCHAR StorageManagerName,
    IN ULONG StorageDeviceNumber
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\inc\sldebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sldebug.h

Abstract:

    Debugging functions exported from the storlib library.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/

#pragma once

#undef ASSERT
#undef VERIFY
#undef ASSERTMSG
#undef KdBreakPoint
#undef DebugPrint

#if !DBG

#define DebugTrace(arg)
#define DebugPrint(arg)
#define DebugWarn(arg)
#define ASSERT(arg)
#define VERIFY(arg) (arg)
#define ASSERTMSG(arg)
#define KdBreakPoint()
#define StorSetDebugPrefixAndId(Prefix,ComponentId)

#define NYI()
#define REVIEW()

//
// DbgFillMemory does nothing
// in a free build.
//

#define DbgFillMemory(Ptr,Size,Fill)

#else // DBG


VOID
StorDebugTrace(
    IN PCSTR Format,
    ...
    );

VOID
StorDebugWarn(
    IN PCSTR Format,
    ...
    );

VOID
StorDebugPrint(
    IN PCSTR Format,
    ...
    );


VOID
StorSetDebugPrefixAndId(
    IN PCSTR Prefix,
    IN ULONG DebugId
    );
    
#define DebugTrace(arg) StorDebugTrace  arg
#define DebugWarn(arg)  StorDebugWarn   arg
#define DebugPrint(arg) StorDebugPrint  arg

//
// On X86 use _asm int 3 instead of DbgBreakPoint because
// it leaves us in same context frame as the break,
// instead of a frame up that we have to step out of.
//

#if defined (_X86_)
#define KdBreakPoint()  _asm { int 3 }
#else
#define KdBreakPoint()  DbgBreakPoint()
#endif


//++
//
// VOID
// DbgFillMemory(
//     PVOID Destination,
//     SIZE_T Length,
//     UCHAR Fill
//     );
//
// Routine Description:
//
// In a checked build, DbgFillMemory expands to RtlFillMemory. In a free
// build, it expands to nothing. Use DbgFillMemory to initialize structures
// to invalid bit patterns before deallocating them.
//
// Return Value:
//
// None.
//
//--

VOID
INLINE
DbgFillMemory(
    PVOID Destination,
    SIZE_T Length,
    UCHAR Fill
    )
{
    RtlFillMemory (Destination, Length, Fill);
}


//
// Use a different ASSERT macro than the vanilla DDK ASSERT. 
//

BOOLEAN
StorAssertHelper(
    PCHAR Expression,
    PCHAR File,
    ULONG Line,
    PBOOLEAN Ignore
    );

//++
//
// VOID
// ASSERT(
//     LOGICAL Expression
//     );
//
// Routine Description:
//
// The ASSERT improves upon the DDK's ASSERT macro in several ways.
// In source mode, it breaks directly on the line where the assert
// failed, instead of several frames up. Additionally, there is a
// way to repeatedly ignore the assert.
//
// Return Value:
//
// None.
//
//--

#define ASSERT(exp)\
    do {                                                                    \
        static BOOLEAN Ignore = FALSE;                                      \
                                                                            \
        if (!(exp)) {                                                       \
            BOOLEAN Break;                                                  \
            Break = StorAssertHelper (#exp, __FILE__, __LINE__, &Ignore);   \
            if (!Ignore && Break) {                                         \
                KdBreakPoint();                                             \
            }                                                               \
        }                                                                   \
    } while (0)

#define VERIFY(_x) ASSERT(_x)

#define NYI() ASSERT (!"NYI")
#define REVIEW()\
    {\
        DebugPrint (("***** REVIEW: This code needs to be reviewed."    \
                     "      Source File %s, line %ld\n",                \
                  __FILE__, __LINE__));                                 \
        KdBreakPoint();                                                 \
    }

#define DBG_DEALLOCATED_FILL    (0xDE)
#define DBG_UNINITIALIZED_FILL  (0xCE)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\partmgr\pmwmireg.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    pmwmireg.h

Abstract:

    This file contains the prototypes of the routines to register for 
    and handle WMI queries.

Author:

    Bruce Worthington      26-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include <ntddk.h>
#include <wdmguid.h>

NTSTATUS PmRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PmQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
PmQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

BOOLEAN
PmQueryEnableAlways(
    IN PDEVICE_OBJECT DeviceObject
    );

extern WMIGUIDREGINFO DiskperfGuidList[];

extern ULONG DiskperfGuidCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\inc\sldefs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sldefs.h

Abstract:

    Simple macro definitions exported by the storlib library.

Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/

#pragma once

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#define min(a,b) (((a) < (b)) ? (a) : (b))
#define max(a,b) (((a) > (b)) ? (a) : (b))

#define ARRAY_COUNT(Array) (sizeof(Array)/sizeof(Array[0]))
#define IN_RANGE(a,b,c) ((a) <= (b) && (b) < (c))

#define INLINE __inline

typedef const GUID *PCGUID;

//
// NT uses a system time measured in 100 nanosecond intervals.  define
// conveninent constants for setting the timer.
//

#define MICROSECONDS        10              // 10 nanoseconds
#define MILLISECONDS        (MICROSECONDS * 1000)
#define SECONDS             (MILLISECONDS * 1000)
#define MINUTES             (SECONDS * 60)

#define RELATIVE_TIMEOUT    (-1)


//
// The standard definition of RemoveListHead is not an expression, hence
// cannot be used in loops, etc.
//

PLIST_ENTRY
INLINE
_RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    return RemoveHeadList (ListHead);
}

#undef RemoveHeadList
#define RemoveHeadList _RemoveHeadList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\inc\storlib.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    storlib.h

Abstract:

    Root include file for the storlib library. This include file includes
    all other necessary to use the library.
    
Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/

#pragma once

#include "sldefs.h"
#include "sldebug.h"
#include "sldict.h"
#include "slgateway.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\bus.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	bus.h

Abstract:

	Declaration of a bus object that wraps the BUS_INTERFACE_STANDARD
	interface.

Author:

	Matthew D Hendel (math) 25-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_BUS_INTERFACE {

    //
    // Has the bus interface been initialized yet.
    //
    
    BOOLEAN Initialized;

    //
    // Standard bus interface. For translating bus addresses, getting
    // DMA adapters, getting and setting bus data.
    //

    BUS_INTERFACE_STANDARD Interface;
    
} RAID_BUS_INTERFACE, *PRAID_BUS_INTERFACE;


//
// Creation and destruction
//

VOID
RaCreateBus(
	IN PRAID_BUS_INTERFACE Bus
	);
	
NTSTATUS
RaInitializeBus(
	IN PRAID_BUS_INTERFACE Bus,
	IN PDEVICE_OBJECT LowerDeviceObject
	);

VOID
RaDeleteBus(
	IN PRAID_BUS_INTERFACE Bus
	);

//
// Operations
//

ULONG
RaGetBusData(
	IN PRAID_BUS_INTERFACE Bus,
	IN ULONG DataType,
	IN PVOID Buffer,
	IN ULONG Offset,
	IN ULONG Length
	);

ULONG
RaSetBusData(
	IN PRAID_BUS_INTERFACE Bus,
	IN ULONG DataType,
	IN PVOID Buffer,
	IN ULONG Offset,
	IN ULONG Length
	);

//
//NB: Add RaidBusTranslateAddress and RaidGetDmaAdapter
//if necessary.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\adapter.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    adapter.h
    
Abstract:

    This file contains the definitions and operations for the RAID_ADPATER
    object.
    
Author:

    Matthew D Hendel (math) 19-Apr-2000.

Revision History:

--*/

#pragma once



C_ASSERT (sizeof (LONG) == sizeof (DEVICE_STATE));


//
// The adapter extension contains everything necessary about
// a host adapter.
//

typedef struct _RAID_ADAPTER_EXTENSION {

    //
    // The device type for this device. Either RaidAdapterObject or
    // RaidControllerObject.
    //
    // Protected by: RemoveLock
    //
    
    RAID_OBJECT_TYPE ObjectType;

    //
    // Back pointer to the the DeviceObject this Extension is for.
    //
    // Protected by: RemoveLock
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    // Back pointer to the driver that owns this adapter.
    //
    // Protected by: RemoveLock
    //

    PRAID_DRIVER_EXTENSION Driver;

    //
    // Pointer to the lower level device object.
    //
    // Protected by: RemoveLock
    //
    
    PDEVICE_OBJECT LowerDeviceObject;

    //
    // The Physical Device Object associated with this FDO.
    //
    // Protected by: RemoveLock
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // The name of this device.
    //
    // Protected by: Read only.
    //
    
    UNICODE_STRING DeviceName;

    //
    // Doubly linked list of adapters owned by this driver.
    //
    // Protected by: Driver's AdapterList lock. Never
    // accessed by the adapter.
    //

    LIST_ENTRY NextAdapter;
    
    //
    // Slow lock for any data not protected by another
    // lock.
    //
    // NB: The slow lock should not be used to access
    // data on the common read/write io path. A separate
    // lock should be used for that.
    //
    
    KSPIN_LOCK SlowLock;

    //
    // The PnP Device State
    //
    // Protected by: Interlocked access
    //

    DEVICE_STATE DeviceState;

    //
    // Flags for the adapter.
    //

    struct {

        BOOLEAN DpcRequested : 1;

        BOOLEAN BusChanged : 1;

    } Flags;
    
    struct {
        
        //
        // Executive resource to protect the unit list.
        //
        // Protected by: RemoveLock
        //

        ERESOURCE Lock;

        //
        // List of logical units attached to this adapter.
        //
        // Protected by: UnitList.Lock AND AdapterIoCount.
        // The list can only be modified when the adapter
        // Outstanding Io count is at zero. This is 
        // necessary because the get logical unit function
        // which can be called from the ISR needs to be
        // able to walk this list.
        //
        // BUGUBG: At this time we are not explicitly
        // enforcing this. We need to fix this before PnP
        // works reliably.
        //

        LIST_ENTRY List;

        STOR_DICTIONARY Dictionary;

        //
        // Count of elements on the unit list.
        //
        // Protected by: UnitList.Lock

        ULONG Count;

    } UnitList;

    //
    // This is the list of XRBs that the miniport has completed, but that
    // have not yet had the dpc run for them.
    //
    // Protected by: Interlocked access.
    //
    
    SLIST_HEADER CompletedList;

    //
    // Fields specific to PnP Device Removal.
    //
    // Protected by: RemoveLock
    //

    IO_REMOVE_LOCK RemoveLock;

    //
    // Information about the current power state.
    //
    // BUGBUG: Protection?
    //
    
    RAID_POWER_STATE Power;

    //
    // PnP assigned resources.
    //
    // Protected by: RemoveLock
    //
    
    RAID_RESOURCE_LIST ResourceList;

    //
    // Miniport object
    //
    // Protected by: RemoveLock
    //
    
    RAID_MINIPORT Miniport;

    //
    // Object representing a bus interface.
    //
    // Protected by: RemoveLock
    //
    
    RAID_BUS_INTERFACE Bus;

    //
    // Interrupt object
    //
    // Protected by: RemoveLock
    //
    
    PKINTERRUPT Interrupt;

    //
    // Interrupt Level
    //
    // Protected by: RemoveLock
    //

    ULONG InterruptIrql;
    
    //
    // When we are operating in full duplex mode, we allow IO
    // to be initiated at the same time as we are receiving
    // interrupts that IO has completed. In half duplex mode,
    // requests to the miniport's StartIo routine are protected
    // by the Interrupt spinlock. In full duplex StartIo is
    // protected by the StartIoLock and interrupts are protected
    // by the interrupt lock. Note that in half duplex mode, the
    // StartIoLock is never used, although it is always
    // initialized.
    //
    // Protected by: RemoveLock
    //

    KSPIN_LOCK StartIoLock;

    //
    // See discussion of StartIoLock above.
    //
    // Protected by: RemoveLock
    
    STOR_SYNCHRONIZATION_MODEL IoModel;
    
    //
    // DMA Adapter for this Controller.
    //
    // BUGBUG: Synchronize access to this??
    //
    
    RAID_DMA_ADAPTER Dma;

    //
    // Uncached extension memory region.
    //
    // Protected by: BUGBUG
    
    RAID_MEMORY_REGION UncachedExtension;

    //
    // This is the real bus number for the device. This is necessary to
    // we can build the configuration information structure that gets
    // passed to crashdump and hiber.
    //
    // Protected by: Read only.
    
    ULONG BusNumber;

    //
    // This is the real slot number (see above discussion about bus number).
    //
    // Protected by: Read only.
    
    ULONG SlotNumber;


    //
    // List of mapped addresses used by the adapter. These are allocated
    // by calls to GetDeviceBase and freed by calls to FreeDeviceBase.
    //
    // Protected by: BUGBUG
    //
    // BUGBUG: If we can have several raidport adapters processing a start
    // device IRP at the same time, then this needs to be protected.
    // Otherwise, it is protected by the fact that multiple start device
    // irps will not be issued at the same time.
    //

    PMAPPED_ADDRESS MappedAddressList;


    //
    // The IO gateway manages the state between the differet per-unit
    // device queues.
    //
    // Protected by: Interlocked access.
    //
    
    STOR_IO_GATEWAY Gateway;

    //
    // DeferredQueue defers requests made at DPC level that can only be
    // executed at dispatch level for execution later. It is very similiar
    // to a DPC queue, but allows multiple entries.
    //
    // Protected by: Read only.
    //

    RAID_DEFERRED_QUEUE DeferredQueue;

    //
    // Timer DPC for miniport timer.
    //
    
    KDPC TimerDpc;

    //
    // Timer for miniport.
    //
    
    KTIMER Timer;

    //
    // Pause timer DPC routine.
    //

    KDPC PauseTimerDpc;

    //
    // Pause timer.
    //
    
    KTIMER PauseTimer;
    
    //
    // SCSI HW timer routine. Only one timer routine may be outstanding
    // at a time.
    //
    
    PHW_INTERRUPT HwTimerRoutine;

    //
    // DPC for completion requests.
    //
    
    KDPC CompletionDpc;

} RAID_ADAPTER_EXTENSION, *PRAID_ADAPTER_EXTENSION;



//
// Definition of adapter deferred queue elements.
//

typedef enum _RAID_DEFERRED_TYPE {
    RaidDeferredTimerRequest    = 0x01,
    RaidDeferredError           = 0x02,
    RaidDeferredPause           = 0x03,
    RaidDeferredResume          = 0x04,
    RaidDeferredPauseDevice     = 0x05,
    RaidDeferredResumeDevice    = 0x06,
    RaidDeferredBusy            = 0x07,
    RaidDeferredReady           = 0x08,
    RaidDeferredDeviceBusy      = 0x09,
    RaidDeferredDeviceReady     = 0x0A
} RAID_DEFERRED_TYPE;


typedef struct _RAID_DEFERRED_ELEMENT {

    RAID_DEFERRED_HEADER Header;
    RAID_DEFERRED_TYPE Type;

    //
    // SCSI Target address for this request. Will not be necessary for
    // all requests.
    //
    
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    
    union {
        struct {
            PHW_INTERRUPT HwTimerRoutine;
            ULONG Timeout;
        } Timer;

        struct {
            PSCSI_REQUEST_BLOCK Srb;
            ULONG ErrorCode;
            ULONG UniqueId;
        } Error;

        struct {
            ULONG Timeout;
        } Pause;

        //
        // Resume doesn't require any parameters.
        //

        struct {
            ULONG Timeout;
        } PauseDevice;

        //
        // ResumeDevice doesn't require any parameters.
        //

        struct {
            ULONG RequestsToComplete;
        } Busy;

        //
        // Ready doesn't require any parameteres.
        //

        struct {
            ULONG RequestsToComplete;
        } DeviceBusy;

        //
        // DeviceReady doesn't require any parameters.
        //
    };
} RAID_DEFERRED_ELEMENT, *PRAID_DEFERRED_ELEMENT;


//
// The deferred queue depth should be large enough to hold one of
// each type of deferred item. Since have per-unit items AND per adapter
// items in the queue, this should also be increased for each unit
// that is attached to the adapter.
//
// NB: It may be smarter to have per-unit deferred queues as well
// as per-adapter deferred queues.
//

#define ADAPTER_DEFERRED_QUEUE_DEPTH (10)


//
// Adapter operations
//

//
// Adapter creation and destruction functions
//


VOID
RaidCreateAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

VOID
RaidDeleteAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidInitializeAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING DeviceName
    );

//
// Adapter IRP handler functions
//


//
// Create, Close
//

NTSTATUS
RaidAdapterCreateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCloseIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

//
// Device Control
//

NTSTATUS
RaidAdapterDeviceControlIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterScsiIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );



//
// Adapter PnP Functions
//


NTSTATUS
RaidAdapterPnpIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryDeviceRelationsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterStartDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterConfigureResources(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    );

NTSTATUS
RaidAdapterStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterStartMiniport(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );
    
NTSTATUS
RaidAdapaterRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCompleteInitialization(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterQueryStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCancelStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterCancelRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSurpriseRemovalIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryIdIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryPnpDeviceStateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterFilterResourceRequirementsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );
    
NTSTATUS
RaidAdapterPnpUnknownIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );


//
// Ioctl handlers
//

NTSTATUS
RaidAdapterStorageQueryPropertyIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );
    

//
// Adapter Power Functions
//

NTSTATUS
RaidAdapterPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterQueryPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSetPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdatperUnknownPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

//
// Adapter WMI functions
//

NTSTATUS
RaidAdapterSystemControlIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );



//
// Other (non-IRP handler) functions
//

VOID
RaidAdapterRequestComplete(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidAdapterExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidGetStorageAdapterProperty(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PSIZE_T DescriptorLength
    );

ULONG
RaidGetMaximumLun(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

ULONG
RaidGetSrbExtensionSize(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

ULONG
RaidGetMaximumTargetId(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

typedef
NTSTATUS
(*PADAPTER_ENUMERATION_ROUTINE)(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    );

NTSTATUS
RaidAdapterEnumerateBus(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PADAPTER_ENUMERATION_ROUTINE EnumRoutine,
    IN PVOID Context
    );
//
// Private adapter operations
//

NTSTATUS
RaidAdapterUpdateDeviceTree(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );
    
NTSTATUS
RaidpBuildAdapterBusRelations(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PDEVICE_RELATIONS * DeviceRelationsPointer
    );

NTSTATUS
RaidAdapterCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN PINQUIRYDATA InquiryData,
    IN PVOID UnitExtension,
    OUT PRAID_UNIT_EXTENSION * UnitBuffer OPTIONAL
    );

VOID
RaidpAdapterDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
RaidPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );
    
VOID
RaidpAdapterTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );

PHW_INITIALIZATION_DATA
RaidpFindAdapterInitData(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidpCreateAdapterSymbolicLink(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidpRegisterAdaterDeviceInterface(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

BOOLEAN
RaidpAdapterInterruptRoutine(
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    );

ULONG
RaidpAdapterQueryBusNumber(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterDisable(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterEnable(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterSetSystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterSetDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

VOID
RaidpAdapterEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
RaidpAdapterRequestTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    );
    
VOID
RaidAdapterRestartQueues(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

PRAID_UNIT_EXTENSION
RaidAdapterFindUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    );

VOID
RaidAdapterDeferredRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_HEADER Item
    );

VOID
RaidAdapterRequestTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    );

VOID
RaidAdapterRequestTimerDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    );

VOID
RaidAdapterLogIoErrorDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    );

NTSTATUS
RaidAdapterScsiMiniportIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

NTSTATUS
RaidAdapterMapBuffers(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    );

VOID
RaidBackOffBusyGateway(
    IN PVOID Context,
    IN LONG OutstandingRequests,
    IN OUT PLONG HighWaterMark,
    IN OUT PLONG LowWaterMark
    );
VOID
RaidAdapterResumeGateway(
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

NTSTATUS
RaidAdapterRaiseIrqlAndExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );

NTSTATUS
RaidAdapterReset(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId
    );

VOID
RaidCompletionDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID
RaidAdapterInsertUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidAdapterAddUnitToTable(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\busenum.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    busenum.c

Abstract:

    Definition of the bus enumerator.

Algorithm:

Author:

    Matthew D Hendel (math) 21-Feb-2001

Revision History:

--*/

#include "precomp.h"


#define ENUM_TAG ('tEaR')
#define DATA_BUFFER_SIZE    (VPD_MAX_BUFFER_SIZE)

//
// Local types
//

typedef
NTSTATUS
(*BUS_ENUM_QUERY_PROCESS_ROUTINE)(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PBUS_ENUM_UNIT EnumUnit
    );

typedef struct _BUS_ENUM_QUERY_CALLBACK {
    ULONG BuildPageCode;
    BUS_ENUM_QUERY_PROCESS_ROUTINE ProcessRoutine;
} BUS_ENUM_QUERY_CALLBACK, *PBUS_ENUM_QUERY_CALLBACK;

typedef const BUS_ENUM_QUERY_CALLBACK* PCBUS_ENUM_QUERY_CALLBACK;

//
// Local functions
//

NTSTATUS
RaidBusEnumeratorProcessInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessSupportedPages(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessDeviceId(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessSerialNumber(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorProcessDeviceId(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorGenericInquiry(
    IN PCBUS_ENUM_QUERY_CALLBACK Callback,
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit
    );

VOID
RaidBusEnumeratorProcessBusUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    );

NTSTATUS
RaidBusEnumeratorAllocateUnitResources(
    IN PBUS_ENUMERATOR Enumerator,
    IN OUT PBUS_ENUM_RESOURCES Resources
    );

VOID
RaidBusEnumeratorBuildVitalProductInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_RESOURCES Resources,
    IN ULONG PageCode,
    OUT PSCSI_REQUEST_BLOCK* SrbBuffer
    );

NTSTATUS
RaidBusEnumeratorIssueSynchronousRequest(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
RaidBusEnumeratorGetUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    OUT PBUS_ENUM_UNIT EnumUnit
    );

VOID
RaidBusEnumeratorReleaseUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    );
    
VOID
RaidBusEnumeratorFreeUnitResources(
    IN PBUS_ENUMERATOR Enumerator
    );


//
// Globals
//

const BUS_ENUM_QUERY_CALLBACK RaidEnumInquiryCallback = {
    -1,
    RaidBusEnumeratorProcessInquiry
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumSupportedPagesCallback = {
    VPD_SUPPORTED_PAGES,
    RaidBusEnumeratorProcessSupportedPages
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumDeviceIdCallback = {
    VPD_DEVICE_IDENTIFIERS,
    RaidBusEnumeratorProcessDeviceId
};

const BUS_ENUM_QUERY_CALLBACK RaidEnumSerialNumber = {
    VPD_SERIAL_NUMBER,
    RaidBusEnumeratorProcessSerialNumber
};

const ANSI_STRING NullAnsiString = RTL_CONSTANT_STRING ("");


//
// Debug only functions
//

VOID
INLINE
ASSERT_ENUM(
    IN PBUS_ENUMERATOR Enumerator
    )
{
    //
    // Quick and dirty sanity check.
    //
    
    ASSERT (Enumerator->Adapter != NULL);
    ASSERT (Enumerator->Adapter->DeviceObject != NULL);
    ASSERT (Enumerator->Adapter->DeviceObject->DeviceExtension ==
            Enumerator->Adapter);
}

    
//
// Implementation
//

VOID
RaidCreateBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator
    )
{
    PAGED_CODE();
    RtlZeroMemory (Enumerator, sizeof (BUS_ENUMERATOR));
    InitializeListHead (&Enumerator->EnumList);
}


NTSTATUS
RaidInitializeBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    PAGED_CODE();
    Enumerator->Adapter = Adapter;
    return STATUS_SUCCESS;
}



VOID
RaidDeleteBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator
    )
{
    PLIST_ENTRY NextEntry;
    PBUS_ENUM_UNIT EnumUnit;
    PRAID_UNIT_EXTENSION Unit;

    PAGED_CODE();

    //
    // Free the temporary logical unit, if one was created.
    //
    // NB: It would be more elegant if we didn't have separate logical-unit
    // resources and a logical unit object to delete. Figure out a way to
    // achieve this.
    //

    Unit = Enumerator->Resources.Unit;

    if (Unit != NULL) {
        RaidDeleteUnit (Unit);
        Enumerator->Resources.Unit = NULL;
        Unit = NULL;
    }

    //
    // Free resources associated with the logical unit.
    //
    
    RaidBusEnumeratorFreeUnitResources (Enumerator);

    
    //
    // Free the list entries.
    //

    for (NextEntry = RemoveHeadList (&Enumerator->EnumList);
         !IsListEmpty (&Enumerator->EnumList);
         NextEntry = RemoveHeadList (&Enumerator->EnumList)) {

        EnumUnit = CONTAINING_RECORD (NextEntry,
                                      BUS_ENUM_UNIT,
                                      EnumLink);
//      RaidDereferenceObject (Unit);
        DbgFillMemory (EnumUnit, sizeof (*EnumUnit), DBG_DEALLOCATED_FILL);
        RaidFreePool (EnumUnit, ENUM_TAG);
    }

    
}


#if 0
VOID
RaidBusEnumeratorAddUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    PBUS_ENUM_UNIT EnumUnit;
    
    EnumUnit = RaidAllocatePool (PagedPool, //??
                                 sizeof (BUS_ENUM_UNIT),
                                 ENUM_TAG,
                                 Enumerator->Adapter->DeviceObject);

    RtlZeroMemory (EnumUnit, sizeof (*EnumUnit));

    //
    // BUGBUG: Take out a reference to the unit object so it can't
    // go away while we're using it.
    //
    
//  RaidRefernceObject (Unit);
    EnumUnit->Unit = Unit;
    EnumUnit->Address = RaidUnitGetAddress (Unit);
    EnumUnit->State = EnumUnmatchedUnit;

    //
    //NB: This is NOT duplicated. We do not need to free it, but if it
    //goes away while we're enumerating, we're in deep trouble.
    //
    
    EnumUnit->Identity.InquiryData = Unit->Identity.InquiryData;
    EnumUnit->Identity.SerialNumber = NullAnsiString;

#if DBG

    //
    // Verify that the unit doesn't already exist in the list
    //

#endif

    InsertHeadList (&Enumerator->EnumList, &EnumUnit->EnumLink);
}
#endif


NTSTATUS
RaidBusEnumeratorVisitUnit(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    The VisitUnit routine is invoked by the adapter bus-enumeration routine
    for each valid SCSI target address for the bus. It is the responsability
    of this routine to figure out whethre there is a logical unit at the
    target address, and to process the target unit.

Arguments:

    Context - Supplies the context passed into the AdapterEnumerateBus
        routine, which, in our case, is a pointer to a BUS_ENUMERATOR
        structure.

    Address - SCSI target address of logical unit to be enumerated.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUMERATOR Enumerator;
    BUS_ENUM_UNIT EnumUnit;

    PAGED_CODE(); // ??

    Enumerator = (PBUS_ENUMERATOR) Context;
    ASSERT_ENUM (Enumerator);
    RtlZeroMemory (&EnumUnit, sizeof (EnumUnit));

    Status = RaidBusEnumeratorGetUnit (Enumerator, Address, &EnumUnit);
    ASSERT (NT_SUCCESS (Status));

    Status = RaidBusEnumeratorGenericInquiry (&RaidEnumInquiryCallback,
                                              Enumerator,
                                              Address,
                                              &EnumUnit);
    //
    // If the inquiry succeeded, try to get the device ID and serial number
    // for the device.
    //

    if (NT_SUCCESS (Status)) {
        RaidBusEnumeratorGenericInquiry (&RaidEnumSupportedPagesCallback,
                                         Enumerator,
                                         Address,
                                         &EnumUnit);

        if (EnumUnit.SupportsDeviceId) {
            RaidBusEnumeratorGenericInquiry (&RaidEnumDeviceIdCallback,
                                             Enumerator,
                                             Address,
                                             &EnumUnit);
        }

        if (EnumUnit.SupportsSerialNumber) {
            RaidBusEnumeratorGenericInquiry (&RaidEnumSerialNumber,
                                             Enumerator,
                                             Address,
                                             &EnumUnit);
        }
    }

    RaidBusEnumeratorProcessBusUnit (Enumerator, &EnumUnit);

    RaidBusEnumeratorReleaseUnit (Enumerator, &EnumUnit);
    
    return STATUS_SUCCESS;
}
    

    
NTSTATUS
RaidBusEnumeratorGenericInquiry(
    IN PCBUS_ENUM_QUERY_CALLBACK Callback,
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Perform a generic inquiry query on the logical unit. This is used for the
    four types of queries issued to the bus: Inquiry, Vital Product Supported
    Pages, Vital Product Device Id, and Vital Product Serial Number.

Arguments:

    Callback - Callback information representing what vital product data
            we should obtain for this inquiry.

    Enum - Supplies the bus enumerator this call is being issued with.

    Address - Supplies the SCSI address of the logical unit to build
            this request for.

    EnumUnit - Supplies the unit object this inquiry if for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PBUS_ENUM_RESOURCES Resources;
    PSCSI_REQUEST_BLOCK Srb;
    
    Resources = &Enumerator->Resources;

    Status = RaidBusEnumeratorAllocateUnitResources (Enumerator, Resources);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    RaidBusEnumeratorBuildVitalProductInquiry (Enumerator,
                                               Address,
                                               Resources,
                                               Callback->BuildPageCode,
                                               &Srb);

    Status = RaidBusEnumeratorIssueSynchronousRequest (Enumerator,
                                                       EnumUnit,
                                                       Srb);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Status = Callback->ProcessRoutine (Enumerator, Srb, EnumUnit);

    return Status;
}



NTSTATUS
RaidBusEnumeratorAllocateUnitResources(
    IN PBUS_ENUMERATOR Enumerator,
    IN OUT PBUS_ENUM_RESOURCES Resources
    )
/*++

Routine Description:

    This routine allocates any resources necessary to perform a single inquiry
    command. Resource allocation and freeing is done in a lazy manner, so in
    the most common case, there will be no resources to allocate when we come
    through this loop. Generally, new resources will need to be allocated when
    we found an interesting logical unit the previous time through the
    exterior enumeration loop.

    It is important to remember to re-initialize any objects that do not
    need to be re-allocated.

Arguments:

    Enum - Supplies the bus enumerator this call is for.

    Resources - Supplies the resources to allocate.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG SpecificLuSize;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    PAGED_CODE();

    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    
    //
    // Allocate SRB if necessary; if one has already been allocated,
    // recycle it.
    //

    Status = STATUS_SUCCESS;
    
    if (Resources->Srb == NULL) {
        Resources->Srb = RaidAllocateSrb (Adapter->DeviceObject);
        if (Resources->Srb == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        RaidPrepareSrbForReuse (Resources->Srb);
    }

    if (Resources->SenseInfo == NULL) {
        Resources->SenseInfo = RaidAllocatePool (NonPagedPool,
                                                 SENSE_BUFFER_SIZE,
                                                 SENSE_TAG,
                                                 Adapter->DeviceObject);
        if (Resources->SenseInfo == NULL) {
            return STATUS_NO_MEMORY;
        }
    }

    if (Resources->Irp == NULL) {
        Resources->Irp = IoAllocateIrp (1, FALSE);
        if (Resources->Irp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        IoReuseIrp (Resources->Irp, STATUS_UNSUCCESSFUL);
    }

    if (Resources->DataBuffer == NULL) {
        Resources->DataBuffer = RaidAllocatePool (NonPagedPool,
                                                  DATA_BUFFER_SIZE,
                                                  INQUIRY_TAG,
                                                  Adapter->DeviceObject);

        if (Resources->DataBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        Resources->DataBufferLength = DATA_BUFFER_SIZE;
    }

    if (Resources->Mdl == NULL) {
        Resources->Mdl = IoAllocateMdl (Resources->DataBuffer,
                                        Resources->DataBufferLength,
                                        FALSE,
                                        FALSE,
                                        NULL);
        MmPrepareMdlForReuse (Resources->Mdl);
    } else {
        MmPrepareMdlForReuse (Resources->Mdl);
    }

#if 0
    if (Resources->Unit == NULL) {
        Status = RaidCreateUnit (Adapter, &Resources->Unit);
    } else {
        Status = STATUS_SUCCESS;
    }
#endif

#if 0
    if (Resources->EnumUnit == NULL) {
        Resources->EnumUnit = RaidAllocatePool (PagedPool, //??
                                                sizeof (BUS_ENUM_UNIT),
                                                ENUM_TAG,
                                                Enumerator->Adapter->DeviceObject);
        if (Resources->EnumUnit == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (Resources->EnumUnit, sizeof (BUS_ENUM_UNIT));
    } else {
        RtlZeroMemory (Resources->EnumUnit, sizeof (BUS_ENUM_UNIT));
    }
#endif

    return Status;
}



VOID
RaidBusEnumeratorFreeUnitResources(
    IN PBUS_ENUMERATOR Enumerator
    )
/*++

Routine Description:

    Free any resources that were allocated by the AllocateUnitResources
    routine. This is called only at the end of the enumeration since we
    do lazy recovery of resources.

Arguments:

    Enum - Supplies the enumerator to free resources from.

Return Value:

    None.

--*/
{
    PBUS_ENUM_RESOURCES Resources;
    PRAID_ADAPTER_EXTENSION Adapter;

    Resources = &Enumerator->Resources;
    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    
    if (Resources->Irp != NULL) {
        IoFreeIrp (Resources->Irp);
        Resources->Irp = NULL;
    }

    if (Resources->Srb != NULL) {
        Resources->Srb->OriginalRequest = NULL;
        Resources->Srb->SenseInfoBuffer = NULL;
        RaidFreeSrb (Resources->Srb);
        Resources->Srb = NULL;
    }

    if (Resources->SenseInfo != NULL) {
        RaidFreePool (Resources->SenseInfo, SENSE_TAG);
        Resources->SenseInfo = NULL;
    }

    if (Resources->DataBuffer) {
        RaidFreePool (Resources->DataBuffer, INQUIRY_TAG);
        Resources->DataBuffer = NULL;
        Resources->DataBufferLength = 0;
    }

#if 0
    if (Resources->Unit) {
        RaidDeleteUnit (Resources->Unit);
        Resources->Unit = NULL;
        
    }
#endif

#if 0
    if (Resources->EnumUnit) {
        RaidFreePool (Resources->EnumUnit, ENUM_TAG);
        Resources->EnumUnit = NULL;
    }
#endif
}



VOID
RaidBusEnumeratorBuildVitalProductInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    IN PBUS_ENUM_RESOURCES Resources,
    IN ULONG PageCode,
    OUT PSCSI_REQUEST_BLOCK* SrbBuffer
    )
/*++

Routine Description:

    Build a INQUIRY command, with an optional vital product inquiry
    page set.

Arguments:

    Enumerator -

    Address - SCSI Address the inquiry is for.

    Resources - Resources to use for the inquiry command.

    PageCode - Specifies what vital product page this inquriy is for,
            or -1 for none.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    struct _CDB6INQUIRY3* Inquiry;
    PINQUIRYDATA InquiryData;
    ULONG Size;

    ASSERT (SrbBuffer != NULL);
    
    Srb = Resources->Srb;
    InquiryData = (PINQUIRYDATA)Resources->DataBuffer;
    Inquiry = NULL;
    Size = 0;

    ASSERT (Srb != NULL);
    ASSERT (InquiryData != NULL);
    
    switch (PageCode) {
        case -1:
            Size = INQUIRYDATABUFFERSIZE;
            break;

        case VPD_SUPPORTED_PAGES:
        case VPD_SERIAL_NUMBER:
        case VPD_DEVICE_IDENTIFIERS:

            //
            // All of the vital product data pages contain variable
            // length structures. Use a maximum length so we don't
            // need to know the length a priori.
            //
            
            Size = VPD_MAX_BUFFER_SIZE; 
            break;

        default:
            Size = VPD_MAX_BUFFER_SIZE;
    }
            
    RtlZeroMemory (InquiryData, DATA_BUFFER_SIZE);

    RaidInitializeInquirySrb (Srb,
                              Address.PathId,
                              Address.TargetId,
                              Address.Lun,
                              InquiryData,
                              Size);

    Inquiry = (struct _CDB6INQUIRY3*) &Srb->Cdb;

    if (PageCode == -1) {
        Inquiry->EnableVitalProductData = 0;
        Inquiry->PageCode = 0;
    } else {
        Inquiry->EnableVitalProductData = 1;
        Inquiry->PageCode = (UCHAR)PageCode;
    }
    
    Srb->SrbExtension = NULL;

    //
    // Initialize the sense info buffer.
    //

    Srb->SenseInfoBuffer = Resources->SenseInfo;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    Srb->DataBuffer = Resources->DataBuffer;
    Srb->DataTransferLength = Size;

    Srb->SrbFlags |= SRB_FLAGS_NO_QUEUE_FREEZE;
    Srb->SrbFlags |= (SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                      SRB_FLAGS_BYPASS_LOCKED_QUEUE);
    
    *SrbBuffer = Srb;
}


NTSTATUS
RaidBuildScsiIrp(
    IN OUT PIRP Irp,
    IN PMDL Mdl,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    PIO_STACK_LOCATION IrpStack;
    
    //
    // Initialize the IRP
    //

    MmInitializeMdl (Mdl, Srb->DataBuffer, Srb->DataTransferLength);
    MmBuildMdlForNonPagedPool (Mdl);

    Irp->MdlAddress = Mdl;

    IrpStack = IoGetNextIrpStackLocation (Irp);
    IrpStack->MajorFunction = IRP_MJ_SCSI;
    IrpStack->MinorFunction = 1;
    IrpStack->Parameters.Scsi.Srb = Srb;

    return STATUS_SUCCESS;
}


NTSTATUS
RaidBusEnumeratorGetUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN RAID_ADDRESS Address,
    OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Get a logical unit to use for enumeration. If there is not an existing
    logical unit, create a fake logical unit. A fake logical unit is necessary
    because other algorithms, e.g., timing-out requests, require a logical
    unit to be present.

Arguments:

    Enumerator - Supplies the enumerator including resources that this
            request is for.

    EnumUnit

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    PBUS_ENUM_RESOURCES Resources;
    
    ASSERT (Enumerator != NULL);

    PAGED_CODE();
    ASSERT (EnumUnit != NULL);
    
    Resources = &Enumerator->Resources;
    Status = RaidBusEnumeratorAllocateUnitResources (Enumerator, Resources);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
        
    //
    // First, try to find the unit in the adapter's unit list.
    //

    Unit = RaidAdapterFindUnit (Enumerator->Adapter, Address);

    //
    // If we didn't find a logical unit in the adapter's list, this
    // means we are querying a unit that we have not found before.
    // Use the temporary unit that is a part of the enumerations
    // resources data structure to perform I/O on.
    //
    
    if (Unit == NULL) {
        Adapter = Enumerator->Adapter;
        if (Resources->Unit == NULL) {
            Status = RaidCreateUnit (Adapter, &Unit);
            if (!NT_SUCCESS (Status)) {
                return Status;
            }
            Resources->Unit = Unit;
            Unit->Flags.Temporary = TRUE;

            //
            // When the unit is created, the queue is locked. Unlock it.
            //
            RaidUnlockUnitQueue (Unit);

        } else {
            Unit = Resources->Unit;
        }
        
        RaidUnitAssignAddress (Unit, Address);
        RaidAdapterInsertUnit (Adapter, Unit);

        //
        // Signal that this logical unit was created for the purposes of
        // enumerating the bus.
        //
        
        EnumUnit->NewUnit = TRUE;

    } else {
        ASSERT (EnumUnit->NewUnit == FALSE);
    }
    
    ASSERT (Unit != NULL);
    EnumUnit->Unit = Unit;
    EnumUnit->Address = RaidUnitGetAddress (Unit);
    EnumUnit->State = EnumUnmatchedUnit;

    return STATUS_SUCCESS;
}



VOID
RaidBusEnumeratorReleaseUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Release the logical unit obtained through RaidBusEnumeratorGetUnit.
    If it was necessary to create a fake logical unit, this function will
    release the unit the Resources list.

Arguments:

    Enumerator - Enumerator containing resources, etc.

    Unit - Logical unit to release.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;

    PAGED_CODE();

    Unit = EnumUnit->Unit;
    Adapter = Enumerator->Adapter;

    if (EnumUnit->NewUnit) {
        RaidAdapterRemoveUnit (Adapter, Unit);
        RaidUnitAssignAddress (Unit, RaidNullAddress);
    }
}



NTSTATUS
RaidBusEnumeratorIssueSynchronousRequest(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Issue the SRB synchronously to it's specified unit.

Arguments:

    Enumerator - Specifies the enumerator this request is associated with.

    Srb - Specifies the SRB to issue.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PBUS_ENUM_RESOURCES Resources;
    PRAID_UNIT_EXTENSION Unit;

    Resources = &Enumerator->Resources;
    Irp = Resources->Irp;
    Unit = EnumUnit->Unit;
    
    Status = RaidBuildScsiIrp (Irp, Resources->Mdl, Srb);
    if (NT_SUCCESS (Status)) {
        Status = RaSendIrpSynchronous (Unit->DeviceObject, Irp);
    }

    return Status;
}



NTSTATUS
RaidBusEnumeratorProcessInquiry(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine processes an Inquiry command by storing the relevant Inquiry
    data in the EnumUnit for later use.

Arguments:

    Enumerator - Supplies the enumerator the inquiry command is for.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    PINQUIRYDATA InquiryData;
    PBUS_ENUM_RESOURCES Resources;

    if (Srb->SrbStatus != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    Resources = &Enumerator->Resources;
    InquiryData = (PINQUIRYDATA)Resources->DataBuffer;

    //
    // Ignore inactive devices.
    //
    
    if (InquiryData->DeviceTypeQualifier != DEVICE_QUALIFIER_ACTIVE) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // The inquiry data is now owned by the identification packet, so
    // NULL it out in the Resources structure.
    //
    
    EnumUnit->Identity.InquiryData = InquiryData;
    EnumUnit->Found = TRUE;
    
    Resources->DataBuffer = NULL;
    Resources->DataBufferLength = 0;

    return STATUS_SUCCESS;
}



NTSTATUS
RaidBusEnumeratorProcessSupportedPages(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine processes an Inquiry, VPD_SUPPORTED_PAGES command by
    storing the relevant inquiry data in the EnumUnit.

Arguments:

    Enumerator - Supplies the enumerator the supported pages command was
        issued to.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies the per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    PVPD_SUPPORTED_PAGES_PAGE SupportedPages;


    if (Srb->SrbStatus != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    SupportedPages = Enumerator->Resources.DataBuffer;

    for (i = 0; i < SupportedPages->PageLength; i++) {
        switch (SupportedPages->SupportedPageList[i]) {
            case VPD_SERIAL_NUMBER:
                EnumUnit->SupportsSerialNumber = TRUE;
                break;

            case VPD_DEVICE_IDENTIFIERS:
                EnumUnit->SupportsDeviceId = TRUE;
                break;
        }
    }

    return STATUS_SUCCESS;
}



NTSTATUS
RaidBusEnumeratorProcessDeviceId(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process an Inquiry, VPD_DEVICE_IDENTIFIERS command by storing the
    relevant inquiry data to the EnumUnit.

Arguments:

    Enumerator - Supplies the enumerator this command was issued as a part of.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies the per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code

--*/
{
    PVPD_SUPPORTED_PAGES_PAGE SupportedPages;

    if (Srb->SrbStatus != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }

    REVIEW();
    
    //
    // The DeviceId data is now owned by the enum unit, so NULL it out
    // in the resources structure so it doesn't get double freed.
    //

    //
    // BUGBUG: Add device id
    //
    
#if 0
    EnumUnit->Identity.DeviceId = Enumerator->Resources.DataBuffer;
    Enumerator->Resources.DataBuffer = NULL;
#endif

    return STATUS_SUCCESS;
}



NTSTATUS
RaidBusEnumeratorProcessSerialNumber(
    IN PBUS_ENUMERATOR Enumerator,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process an Inquiry, VPD_SERIAL_NUMBER command by storing the relevant
    inquiry data to the EnumUnit.

Arguments:

    Enumerator - Supplies the enumerator this command was issued as a part of.

    Srb - Supples the completed SCSI request block for this inquiry.

    EnumUnit - Supplies the per-unit enumeration data that is modified by this
        routine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PVPD_SERIAL_NUMBER_PAGE SerialNumberPage;

    if (Srb->SrbStatus != SRB_STATUS_SUCCESS) {
        return RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }
    
    SerialNumberPage = Srb->DataBuffer;

    REVIEW();
    
    Status = StorCreateAnsiString (&EnumUnit->Identity.SerialNumber,
                                   SerialNumberPage->SerialNumber,
                                   SerialNumberPage->PageLength,
                                   NonPagedPool,
                                   Enumerator->Adapter->DeviceObject);

    return Status;
}


PBUS_ENUM_UNIT
RaidBusEnumeratorFindUnitByAddress(
    IN PBUS_ENUMERATOR Enumerator,
    IN STOR_SCSI_ADDRESS Address
    )
/*++

Routine Description:

    Search for a unit in the unit list via the SCSI address.

Arguments:

    Enum - Supplies the enumerator that is currently enumerating. The
        enumerator contains resources for the enumeration that may be
        necessary in the processing of the unit.

    NewEnumUnit - Supplies the enumerated unit.

Return Value:

    Non-NULL - Represents the found enumerated unit.

    NULL - If a matching unit was not found.

--*/
{
    PLIST_ENTRY NextEntry;
    PBUS_ENUM_UNIT EnumUnit;
    LONG Comparison;

    for (NextEntry = Enumerator->EnumList.Flink;
         NextEntry != &Enumerator->EnumList;
         NextEntry = NextEntry->Flink) {
        
        EnumUnit = CONTAINING_RECORD (NextEntry,
                                      BUS_ENUM_UNIT,
                                      EnumLink);
        
        Comparison = StorCompareScsiAddress (Address, EnumUnit->Address);

        //
        // Found a matching unit: mark it as found.
        //

        if (Comparison == 0) {
            return EnumUnit;
        }
    }

    return NULL;
}



VOID
RaidBusEnumeratorProcessBusUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    This routine is called for each unit attached to the bus. It is the
    responsability of this routine to do whatever is necessary to process
    the unit.

Arguments:

    Enumerator - Supplies the enumerator that is currently enumerating. The
        enumerator contains resources for the enumeration that may be
        necessary in the processing of the unit.

    EnumUnit - Supplies the enumerated unit.

Return Value:

    None.

--*/
{
    LONG Comparison;
    LOGICAL Modified;
    PRAID_UNIT_EXTENSION Unit;
    PBUS_ENUM_RESOURCES Resources;

    
    Unit = EnumUnit->Unit;
    Resources = &Enumerator->Resources;
    Modified = FALSE;

    if (!EnumUnit->NewUnit && !EnumUnit->Found) {

        //
        // There was a logical unit at this address, but upon reenumeration,
        // we didn't find one. Mark it for deletion.
        //

        Modified = TRUE;
        ASSERT (EnumUnit->State == EnumUnmatchedUnit);
        
    } else if (!EnumUnit->NewUnit && EnumUnit->Found) {

        //
        // There was a logical unit at this address and there still is. If
        // it turns out to be the SAME logical unit, do nothing. Otherwise,
        // mark it for creation.
        //

        ASSERT (!Unit->Flags.Temporary);
        Comparison = StorCompareScsiIdentity (&EnumUnit->Identity,
                                              &Unit->Identity);

        if (Comparison == 0) {

            //
            // The new unit matches the unit we had previously enumerated.
            // Update the state and return.
            //

            ASSERT (EnumUnit->State == EnumUnmatchedUnit);
            EnumUnit->State = EnumMatchedUnit;
            Modified = FALSE;

        } else {
        
            //
            // There was a unit at this SCSI address, but this unit
            // does not match it. Mark the previous unit for deletion
            // by leaving it as unmatched and fall through to the new
            // creation code below.
            //

            ASSERT (EnumUnit->State == EnumUnmatchedUnit);
            Modified = TRUE;
        }

    } else if (EnumUnit->NewUnit && EnumUnit->Found) {

        //
        // We found a new unit.
        //

        EnumUnit->State = EnumNewUnit;
        Modified = TRUE;
    }

    //
    // If the logical unit at this address is new, has gone away or is
    // somehow different than the logical unit previously at this SCSI
    // address, put it on the modified list.
    //
    
    if (Modified) {
        PBUS_ENUM_UNIT NewEnumUnit;

        NewEnumUnit = RaidAllocatePool (PagedPool,
                                        sizeof (BUS_ENUM_UNIT),
                                        ENUM_TAG,
                                        Enumerator->Adapter->DeviceObject);
        *NewEnumUnit = *EnumUnit;

        Resources->Unit = NULL;
        InsertHeadList (&Enumerator->EnumList, &NewEnumUnit->EnumLink);
    }
}



VOID
RaidBusEnumeratorProcessNewUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process a unit that was newly discovered as a part of the enumeration.

Arguments:

    Enumerator - Supplies the enumerator that this unit was discovered as a
        part of.

    EnumUnit - Supplies the data necessary to create the logical unit.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_UNIT_EXTENSION Unit;

    PAGED_CODE();

    Unit = EnumUnit->Unit;

    RaidUnitAssignAddress (Unit, EnumUnit->Address);
    RaidUnitAssignIdentity (Unit, &EnumUnit->Identity);
    Unit->Flags.Temporary = FALSE;
    Unit->Flags.Present = TRUE;
    Unit->DeviceState = DeviceStateStopped;
    RaidLockUnitQueue (Unit);
    RaidAdapterInsertUnit (Unit->Adapter, Unit);
    RaidStartUnit (Unit);
}



LOGICAL
RaidBusEnumeratorProcessDeletedUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    Process a unit that was not found as a part of this enumeration.

Arguments:

    Enumerator - Supplies the enumerator that this unit was discovered as a
        part of.

    EnumUnit - Supplies the data necessary to delete the unit.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitNotifyHardwareGone (EnumUnit->Unit);
}



VOID
RaidBusEnumeratorProcessMatchedUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PBUS_ENUM_UNIT EnumUnit
    )
/*++

Routine Description:

    The process routine is called for each unit on the bus that matched
    an old unit on the bus. Verify that the parameters are all still
    the same.

    NB: We assume that during a bus enumeration, the SCSI target address
    of a logical unit will not change. If it does, we will have to do
    real processing below to delete and re-create the unit.
    
Arguments:

    Enumerator - Supplies enumeration data.

    EnumUnit - Supplies information about the logical unit.

Return Value:

    None.

--*/
{
    LONG Comparison;
    ASSERT (EnumUnit->Unit != NULL);

    //
    // When the SCSI target IDs change, we treat it as a separate
    // delete and create operation.
    //

    Comparison = StorCompareScsiAddress (EnumUnit->Unit->Address,
                                         EnumUnit->Address);
    ASSERT (Comparison == 0);
}



LOGICAL
RaidBusEnumeratorProcessModifiedNodes(
    IN PBUS_ENUMERATOR Enumerator
    )
/*++

Routine Description:

    Process any units that were modified by the enumeration. Modified units
    are those that were created, deleted or changed.

Arguments:

    Enumerator - Supplies the enumerator that includes the list of all found
        units and their states.

Return Value:

    A boolean specifying whether the bus had changed (TRUE) or not (FALSE)
    from what was initialized in the enumerator. If the bus had changed, the
    caller of this routine may have invalidate the bus relations for this bus.

--*/
{
    PLIST_ENTRY NextEntry;
    PBUS_ENUM_UNIT EnumUnit;
    LOGICAL ChangeDetected;
    PRAID_ADAPTER_EXTENSION Adapter;
    

    ChangeDetected = FALSE;
    Adapter = Enumerator->Adapter;
    ASSERT_ADAPTER (Adapter);
    

    for (NextEntry = Enumerator->EnumList.Flink;
         NextEntry != &Enumerator->EnumList;
         NextEntry = NextEntry->Flink) {

        EnumUnit = CONTAINING_RECORD (NextEntry,
                                      BUS_ENUM_UNIT,
                                      EnumLink);
        
        switch (EnumUnit->State) {

            case EnumUnmatchedUnit:
                ChangeDetected =
                    RaidBusEnumeratorProcessDeletedUnit (Enumerator, EnumUnit);
                break;

            case EnumNewUnit:
                RaidBusEnumeratorProcessNewUnit (Enumerator, EnumUnit);
                ChangeDetected = TRUE;
                break;
            
            case EnumMatchedUnit:
                RaidBusEnumeratorProcessMatchedUnit (Enumerator, EnumUnit);
                break;

            default:
                ASSERT (FALSE);
        }
    }

    //
    // Return a status value to tell if the bus has changed since last time
    // we enumerated.
    //
    
    return ChangeDetected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\inc\slgateway.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	slgateway.h

Abstract:

	Declaration of a gateway class that manages multiple interrelated
	sub-devices on a device.

	See gateway.c for more information.
	
Author:

	Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#pragma once

typedef
VOID
(*PSTOR_IO_GATEWAY_BUSY_ROUTINE)(
	IN PVOID Context,
	IN LONG OutstandingRequests,
	OUT PLONG HighWaterMark,
	OUT PLONG LowWaterMark
	);

typedef struct _STOR_IO_GATEWAY {

    //
    // Spinlock that protects the data in the adapter queue.
    //
    // PERF NOTE: This lock is the only adapter-wide lock
    // acquired in the IO path. Therefore, it is probably
    // the hottest lock in raidport. We should investigate
    // to accomplish this functionality without locking or
    // using only interlocked operations.
    //
    
    KSPIN_LOCK Lock;

    //
    // At the high water mark we should stop submitting requests to
    // the adapter.
    //
    // Protected by: Lock
    //
    
    LONG HighWaterMark;

    //
    // If we are busy and have dropped below the low water mark, we
    // can continue submitting requests to the unit queue.
    //
    // Protected by: Lock
    //
    
    LONG LowWaterMark;

    //
    // The number of outstanding requests the adapter is currently
    // processing.
    //
    // Protected by: Lock
    //
    
    LONG Outstanding;

    //
	// Count of how many times the gateway has been busied.
    //
    // Protected by: Lock
    //
    
	LONG BusyCount;

	//
	// Count of how many time the gateway has been paused.
	//

	LONG PauseCount;

    //
    // Information about how elements are queued to the device when it's
    // busy.
    //

	PSTOR_IO_GATEWAY_BUSY_ROUTINE BusyRoutine;

	//
	// Context information for the busy routine.
	//
	
	PVOID BusyContext;

} STOR_IO_GATEWAY, *PSTOR_IO_GATEWAY;



VOID
StorCreateIoGateway(
	IN PSTOR_IO_GATEWAY Gateway,
	IN PSTOR_IO_GATEWAY_BUSY_ROUTINE BusyRoutine,
	IN PVOID BusyContext
    );

BOOLEAN
StorSubmitIoGatewayItem(
    IN PSTOR_IO_GATEWAY Gateway
    );

BOOLEAN
StorRemoveIoGatewayItem(
    IN PSTOR_IO_GATEWAY Gateway
    );

//
// Busy processing on the gateway.
//

VOID
StorBusyIoGateway(
    IN PSTOR_IO_GATEWAY Gateway
    );

VOID
StorBusyIoGatewayEx(
	IN PSTOR_IO_GATEWAY Gateway,
	IN ULONG RequestsToComplete
	);

BOOLEAN
StorIsIoGatewayBusy(
    IN PSTOR_IO_GATEWAY Queue
    );

VOID
StorReadyIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	);


//
// Pause status on the gateway.
//


VOID
StorPauseIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	);

BOOLEAN
StorIsIoGatewayPaused(
	IN PSTOR_IO_GATEWAY Gateway
	);

VOID
StorResumeIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\inc\sldict.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	dict.h

Abstract:

	Simple dictionary data structure based on a hash table. The hash
	table gives constant time performance if the number of elements in
	the table is close to the number of bins allocated for the table.

	The dictionary does not provide automatic synchronization.

Author:

	Matthew D Hendel (math) 8-Feb-2001

Revision History:

--*/

#pragma once

//
// Dictionary entry. Use this the same way the LIST_ENTRY
// structure is used; i.e., by embedding it into the structure you
// will be adding to the list. By doing this we avoid a per-element
// memory allocation.
//

typedef LIST_ENTRY STOR_DICTIONARY_ENTRY, *PSTOR_DICTIONARY_ENTRY;


//
// User-supplied GetKey routine.
//

typedef PVOID
(*STOR_DICTIONARY_GET_KEY_ROUTINE)(
	IN PSTOR_DICTIONARY_ENTRY Entry
	);

//
// User-supplied compare key routine.
//

typedef LONG
(*STOR_DICTIONARY_COMPARE_KEY_ROUTINE)(
	IN PVOID Key1,
	IN PVOID Key2
	);

//
// User-supplied hash routine.
//

typedef ULONG
(*STOR_DICTIONARY_HASH_KEY_ROUTINE)(
	IN PVOID Key
	);

//
// Dictionary sstructure.
//

typedef struct _STOR_DICTIONARY {
	ULONG EntryCount;
	ULONG MaxEntryCount;
	POOL_TYPE PoolType;
	PSTOR_DICTIONARY_ENTRY Entries;
	STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine;
	STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareKeyRoutine;
	STOR_DICTIONARY_HASH_KEY_ROUTINE HashKeyRoutine;
} STOR_DICTIONARY, *PSTOR_DICTIONARY;


//
// Enumerator structure used for enumerating the elements in the dictionary.
//

typedef
BOOLEAN
(*STOR_ENUMERATE_ROUTINE)(
	IN struct _STOR_DICTIONARY_ENUMERATOR* Enumerator,
	IN PLIST_ENTRY Entry
	);
	
typedef struct _STOR_DICTIONARY_ENUMERATOR {
	PVOID Context;
	STOR_ENUMERATE_ROUTINE EnumerateEntry;
} STOR_DICTIONARY_ENUMERATOR, *PSTOR_DICTIONARY_ENUMERATOR;


//
// Default compare-key routine when the keys are ULONGs.
//

LONG
StorCompareUlongKey(
	IN PVOID Key1,
	IN PVOID Key2
	);

//
// Default hash-key routine when the keys are ULONGs.
//

ULONG
StorHashUlongKey(
	IN PVOID Key
	);

NTSTATUS
StorCreateDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN ULONG EntryCount,
	IN POOL_TYPE PoolType,
	IN STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine,
	IN STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareKeyRoutine, OPTIONAL
	IN STOR_DICTIONARY_HASH_KEY_ROUTINE HashKeyRoutine OPTIONAL
	);

NTSTATUS
StorInsertDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN PSTOR_DICTIONARY_ENTRY Entry
	);
		
NTSTATUS
StorRemoveDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN PVOID Key,
	OUT PSTOR_DICTIONARY_ENTRY* Entry OPTIONAL
	);

NTSTATUS
StorFindDictionary(
	IN PSTOR_DICTIONARY Dictionary,
	IN PVOID Key,
	OUT PSTOR_DICTIONARY_ENTRY* Entry OPTIONAL
	);

VOID
StorEnumerateDictionary(
	IN PSTOR_DICTIONARY Dict,
	IN PSTOR_DICTIONARY_ENUMERATOR Enumerator
	);

ULONG
INLINE
StorGetDictionaryCount(
	IN PSTOR_DICTIONARY Dictionary
	)
{
	return Dictionary->EntryCount;
}

ULONG
INLINE
StorGetDictionaryMaxCount(
	IN PSTOR_DICTIONARY Dictionary
	)
{
	return Dictionary->MaxEntryCount;
}

ULONG
INLINE
StorGetDictionaryFullness( // shitty name
	IN PSTOR_DICTIONARY Dictionary
	)
/*++

Routine Description:

	Return the 'fullness' of the dictionary. As a general rule, when the
	dictionary reaches XXX % full, it should be expanded to 

Arguments:

	Dictionary - 

Return Value:

	This is returned as a percentage, e.g., 50 = 50% full, 100 = 100%
	full, 200 = 200% full, etc.

--*/
{
	return ((Dictionary->MaxEntryCount * 100) / Dictionary->EntryCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\adapter.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adapter.c

Abstract:

    This module implements the adapter routines for the raidport device
    driver.

Author:

    Matthew D. Hendel (math) 06-April-2000

Environment:

    Kernel mode.

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidInitializeAdapter)
#pragma alloc_text(PAGE, RaidpFindAdapterInitData)
#pragma alloc_text(PAGE, RaidpAdapterQueryBusNumber)
#pragma alloc_text(PAGE, RaidAdapterCreateIrp)
#pragma alloc_text(PAGE, RaidAdapterCloseIrp)
#pragma alloc_text(PAGE, RaidAdapterDeviceControlIrp)
#pragma alloc_text(PAGE, RaidAdapterPnpIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaidAdapterStartDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterStopDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaidAdapterSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaidAdapterQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaidAdapterScsiIrp)
#pragma alloc_text(PAGE, RaidAdapterSystemControlIrp)
#pragma alloc_text(PAGE, RaidAdapterStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaidpBuildAdapterBusRelations)
#pragma alloc_text(PAGE, RaidGetStorageAdapterProperty)
#endif // ALLOC_PRAGMA

VOID
RaidCreateAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Initialize the adapter object to a known state.

Arguments:

    Adapter - The adapter to create.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    
    Adapter->ObjectType = RaidAdapterObject;

    Adapter->DeviceObject = NULL;
    Adapter->Driver = NULL;
    Adapter->LowerDeviceObject = NULL;
    Adapter->PhysicalDeviceObject = NULL;

    InitializeListHead (&Adapter->UnitList.List);
    InitializeSListHead (&Adapter->CompletedList);

    Status = StorCreateDictionary (&Adapter->UnitList.Dictionary,
                                   20,
                                   NonPagedPool,
                                   RaidGetKeyFromUnit,
                                   NULL,
                                   NULL);
                             
    if (!NT_SUCCESS (Status)) {
        return;
    }
                
    Adapter->UnitList.Count = 0;
    ExInitializeResourceLite (&Adapter->UnitList.Lock);
    IoInitializeRemoveLock (&Adapter->RemoveLock,
                            REMLOCK_TAG,
                            REMLOCK_MAX_WAIT,
                            REMLOCK_HIGH_MARK);
    
    Adapter->DeviceState = DeviceStateNotPresent;

    RaCreateMiniport (&Adapter->Miniport);
    RaidCreateDma (&Adapter->Dma);
    RaCreatePower (&Adapter->Power);
    RaidCreateResourceList (&Adapter->ResourceList);
    RaCreateBus (&Adapter->Bus);
    RaidCreateRegion (&Adapter->UncachedExtension);
    Adapter->Interrupt = NULL;
    Adapter->MappedAddressList = NULL;

    StorCreateIoGateway (&Adapter->Gateway,
                         RaidBackOffBusyGateway,
                         NULL);
                         
    RaidCreateDeferredQueue (&Adapter->DeferredQueue);
}


VOID
RaidDeleteAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Destroy the adapter object and deallocate any resources associated
    with the adapter.

Arguments:

    Adapter - The adapter to destroy.

Return Value:

    None.

--*/
{
    //
    // BUGBUG: Shouldn't this be paged?
    //

    //
    // All logical units should have been removed from the adapter's unit
    // list before the adapter's delete routine is called. Verify this
    // for checked builds.
    //
      

    ASSERT (IsListEmpty (&Adapter->UnitList.List));
    ASSERT (Adapter->UnitList.Count == 0);


    ExDeleteResourceLite (&Adapter->UnitList.Lock);

    //
    // These resources are owned by somebody else, so do not delete them.
    // Just NULL them out.
    //

    Adapter->DeviceObject = NULL;
    Adapter->Driver = NULL;
    Adapter->LowerDeviceObject = NULL;
    Adapter->PhysicalDeviceObject = NULL;

    //
    // Delete all resources we actually own.
    //
    
    RaidDeleteResourceList (&Adapter->ResourceList);
    RaDeleteMiniport (&Adapter->Miniport);
    IoDisconnectInterrupt (Adapter->Interrupt);
    RaidDeleteDma (&Adapter->Dma);
    RaDeletePower (&Adapter->Power);
    RaDeleteBus (&Adapter->Bus);
    RaidDeleteRegion (&Adapter->UncachedExtension);

    RaidDeleteDeferredQueue (&Adapter->DeferredQueue);

    Adapter->ObjectType = RaidUnknownObject;
}


NTSTATUS
RaidInitializeAdapter(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    Initialize the adapter.

Arguments:

    Adapter - The adapter to initialize.

    DeviceObject - The device object who owns this
        Adapter Extension.

    Driver - The parent DriverObject for this Adapter.

    LowerDeviceObject -

    PhysicalDeviceObject -

    DeviceName - 

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (IsAdapter (DeviceObject));

    ASSERT_ADAPTER (Adapter);
    ASSERT (DeviceObject != NULL);
    ASSERT (Driver != NULL);
    ASSERT (LowerDeviceObject != NULL);
    ASSERT (PhysicalDeviceObject != NULL);
    
    ASSERT (Adapter->DeviceObject == NULL);
    ASSERT (Adapter->Driver == NULL);
    ASSERT (Adapter->PhysicalDeviceObject == NULL);
    ASSERT (Adapter->LowerDeviceObject == NULL);
    ASSERT (DeviceObject->DeviceExtension == Adapter);

    Adapter->DeviceObject = DeviceObject;
    Adapter->Driver = Driver;
    Adapter->PhysicalDeviceObject = PhysicalDeviceObject;
    Adapter->LowerDeviceObject = LowerDeviceObject;
    Adapter->DeviceName = *DeviceName;

    return STATUS_SUCCESS;
}


PHW_INITIALIZATION_DATA
RaidpFindAdapterInitData(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Find the HW_INITIALIZATION_DATA associated with this
    adapter.

Arguments:

    Adapter - The adapter whose HwInitData needs to be found.

Return Value:

    A pointer to the HW_INITIALIZATION_DATA for this adapter
    on success.

    NULL on failure.

--*/
{
    INTERFACE_TYPE BusInterface;
    PHW_INITIALIZATION_DATA HwInitializationData;
    
    PAGED_CODE ();

    HwInitializationData = NULL;
    BusInterface = RaGetBusInterface (Adapter->LowerDeviceObject);

    if (BusInterface == InterfaceTypeUndefined) {
        DebugPrint (("Couldn't find interface for adapter %p\n", Adapter));
        return NULL;
    }

    HwInitializationData =
        RaFindDriverInitData (Adapter->Driver, BusInterface);

    return HwInitializationData;
}


NTSTATUS
RaidpCreateAdapterSymbolicLink(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    PAGED_CODE();
    return StorCreateScsiSymbolicLink (&Adapter->DeviceName, NULL);
}


NTSTATUS
RaidpRegisterAdapterDeviceInterface(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    //
    // Is this necessary?
    //
    
    return STATUS_UNSUCCESSFUL;
}


BOOLEAN
RaidpAdapterInterruptRoutine(
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )
/*++

Routine Description:

    Interrupt routine for IO requests sent to the miniport.

Arguments:

    Interrupt - Supplies interrupt object this interrupt is for.

    ServiceContext - Supplies service context representing a RAID
            adapter extension.

Return Value:

    TRUE - to signal the interrupt has been handled.

    FALSE - to signal the interrupt has not been handled.

--*/
{
    BOOLEAN Handled;
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Get the adapter from the Interrupt's ServiceContext.
    //
    
    Adapter = (PRAID_ADAPTER_EXTENSION) ServiceContext;
    ASSERT (Adapter->ObjectType == RaidAdapterObject);

    //
    // Call into the Miniport to see if this is it's interrupt.
    // If so, we be notified via ScsiPortNotify() that the Srb
    // has completed, which will in turn queue a DPC. Thus, by
    // the time we get back here, we only need to return.
    //
    
    Handled = RaCallMiniportInterrupt (&Adapter->Miniport);

    return Handled;
}


VOID
RaidpAdapterDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    DPC routine for the Adapter. This routine is called in the context of
    an arbitrary thread to complete an io request.

    The DPC routine is only called once even if there are multiple calls
    to IoRequestDpc(). Therefore, we need to queue completion requests
    onto the adapter, and we should not inspect the Dpc, Irp and Context
    parameters.
    

Arguments:

    Dpc - Unreference parameter, do not use.

    DeviceObject - Adapter this DPC is for.

    Irp - Unreferenced parameter, do not use.

    Context - Unreferenced parameter, do not use.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PSINGLE_LIST_ENTRY Entry;
    PEXTENDED_REQUEST_BLOCK Xrb;
    
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (Irp);
    UNREFERENCED_PARAMETER (Context);

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT (IsAdapter (DeviceObject));

    
    //
    // Dequeue items from the adapter's completion queue and call the
    // item's completion routine.
    //

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;


#if 0
    RaidAdapterUnMarkDpcPending (Adatper, KeGetCurrentProcessor();
#endif

    for (Entry = InterlockedPopEntrySList (&Adapter->CompletedList);
         Entry != NULL;
         Entry = InterlockedPopEntrySList (&Adapter->CompletedList)) {
         
        Xrb = CONTAINING_RECORD (Entry,
                                 EXTENDED_REQUEST_BLOCK,
                                 CompletedLink);
        Xrb->CompletionRoutine (Xrb);
    }
}



ULONG
RaidpAdapterQueryBusNumber(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    NTSTATUS Status;
    ULONG BusNumber;
    ULONG Size;

    PAGED_CODE ();
    
    Status = IoGetDeviceProperty (Adapter->PhysicalDeviceObject,
                                  DevicePropertyBusNumber,
                                  sizeof (ULONG),
                                  &BusNumber,
                                  &Size);

    if (!NT_SUCCESS (Status)) {
        BusNumber = -1;
    }

    return BusNumber;
}


//
// IRP Handler functions
//

NTSTATUS
RaidAdapterCreateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the create device irp.

Arguments:

    Adapter - Adapter to create.

    Irp - Create device irp.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (&Adapter->RemoveLock, Irp);
}


NTSTATUS
RaidAdapterCloseIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the close device irp.

Arguments:

    Adapter - Adapter to close.

    Irp - Close device irp.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (&Adapter->RemoveLock, Irp);
}


ULONG
INLINE
DbgFunctionFromIoctl(
    IN ULONG Ioctl
    )
{
    return ((Ioctl & 0x3FFC) >> 2);
}

ULONG
INLINE
DbgDeviceFromIoctl(
    IN ULONG Ioctl
    )
{
    return DEVICE_TYPE_FROM_CTL_CODE (Ioctl);
}

NTSTATUS
RaidAdapterDeviceControlIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the handler routine for the adapter's ioctl irps.

Arguments:

    Adapter - The adapter device extension associated with the
            device object this irp is for.

    Irp - The irp to process.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Ioctl;

    PAGED_CODE ();

    Status = IoAcquireRemoveLock (&Adapter->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    Ioctl = RaidIoctlFromIrp (Irp);

    DebugTrace (("Adapter %p Irp %p Ioctl (Dev, Fn) (%x, %x)\n",
                  Adapter, Irp, DbgDeviceFromIoctl (Ioctl),
                  DbgFunctionFromIoctl (Ioctl)));
    
    switch (Ioctl) {

        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaidAdapterStorageQueryPropertyIoctl (Adapter, Irp);
            break;

        case IOCTL_SCSI_MINIPORT:
            Status = RaidAdapterScsiMiniportIoctl (Adapter, Irp);
            break;

        case IOCTL_STORAGE_RESET_BUS:
        case IOCTL_SCSI_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
        case IOCTL_SCSI_RESCAN_BUS:
        case IOCTL_SCSI_GET_INQUIRY_DATA:
        case IOCTL_SCSI_GET_DUMP_POINTERS:
        case IOCTL_SCSI_GET_CAPABILITIES:
            NYI();
        default:
            Status = RaidCompleteRequest (Irp,
                                          IO_NO_INCREMENT,
                                          STATUS_NOT_SUPPORTED);
    }

    IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);

    DebugTrace (("Adapter %p Irp %p Ioctl %x, ret = %08x\n",
                  Adapter, Irp, Ioctl, Status));
                  
    return Status;
}


//
// Second level dispatch functions.
//

NTSTATUS
RaidAdapterPnpIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles all PnP irps for the adapter by forwarding them
    on to routines based on the irps's minor code.

Arguments:

    Adapter - The adapter object this irp is for.

    Irp - The irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;

    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = IoAcquireRemoveLock (&Adapter->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);
    DebugTrace (("Adapter %p, Irp %p, Pnp\n",
                 Adapter,
                 Irp));

    //
    // Dispatch the IRP to one of our handlers.
    //
    
    switch (Minor) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaidAdapterQueryDeviceRelationsIrp (Adapter, Irp);
            break;

        case IRP_MN_START_DEVICE:
            Status = RaidAdapterStartDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_STOP_DEVICE:
            Status = RaidAdapterStopDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            RemlockHeld = FALSE;
            Status = RaidAdapterRemoveDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaidAdapterSurpriseRemovalIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaidAdapterQueryStopDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaidAdapterCancelStopDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaidAdapterQueryRemoveDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaidAdapterCancelRemoveDeviceIrp (Adapter, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            Status = RaidAdapterFilterResourceRequirementsIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaidAdapterQueryIdIrp (Adapter, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaidAdapterQueryPnpDeviceStateIrp (Adapter, Irp);
            break;

        default:
            IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);
            RemlockHeld = FALSE;
            Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    }

    DebugTrace (("Adapter %p, Irp %p, Pnp, ret = %x\n",
                  Adapter,
                  Irp,
                  Status));

    //
    // If the remove lock has not already been released, release it now.
    //
    
    if (RemlockHeld) {
        IoReleaseRemoveLock (&Adapter->RemoveLock, Irp);
    }
    
    return Status;
}



NTSTATUS
RaidAdapterQueryDeviceRelationsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    The is the handler routine for the (PNP, QUERY_DEVICE_RELATION) irp
    on the Adapter object.

Arguments:

    Adapter - The adapter that is receiving the irp.
    
    Irp - The IRP to handle, which must be a pnp, query device relations
          irp.  The adapter only handles BusRelations, so this must be a
          device relations irp with subcode BusRelations. Otherwise, we
          fail the call.

Return Value:

    NTSTATUS code.

Bugs:

    We do the bus enumeration synchronously; SCSIPORT does this async.
    
--*/
{
    NTSTATUS Status;
    DEVICE_RELATION_TYPE RelationType;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_RELATIONS DeviceRelations;


    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);


    DebugTrace (("Adapter %p, Irp %p, Pnp DeviceRelations\n",
                 Adapter,
                 Irp));
                 
    DeviceRelations = NULL;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    RelationType = IrpStack->Parameters.QueryDeviceRelations.Type;

    //
    // BusRelations is the only type of device relations we support on
    // the adapter object.
    //
    
    if (RelationType != BusRelations) {
        return RaidCompleteRequest (Irp,
                                    IO_NO_INCREMENT,
                                    STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // First step is to enumerate the logical units on the adapter.
    //

    Status = RaidAdapterUpdateDeviceTree (Adapter);

    //
    // If enumeration was successful, build the device relations
    // list.
    //

    if (NT_SUCCESS (Status)) {
        Status = RaidpBuildAdapterBusRelations (Adapter, &DeviceRelations);
    }

    Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
    Irp->IoStatus.Status = Status;

    //
    // If successful, call next lower driver, otherwise, fail.
    //
    
    if (NT_SUCCESS (Status)) {
        IoCopyCurrentIrpStackLocationToNext (Irp);
        Status = IoCallDriver (Adapter->LowerDeviceObject, Irp);
    } else {
        Status = RaidCompleteRequest (Irp,
                                      IO_NO_INCREMENT,
                                      Irp->IoStatus.Status);
    }

    DebugTrace (("Adapter: %p Irp: %p, Pnp DeviceRelations, ret = %08x\n",
                 Adapter,
                 Irp,
                 Status));
                 
    return Status;
}

NTSTATUS
RaidAdapterRaiseIrqlAndExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Raise the IRQL to dispatch levela nd call the execute XRB routine.

Arguments:

    Adapter - Adapter to execute the XRB on.

    Xrb - Xrb to execute.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    KIRQL OldIrql;

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    Status = RaidAdapterExecuteXrb (Adapter, Xrb);
    KeLowerIrql (OldIrql);

    return Status;
}

BOOLEAN
RaidpAdapterCallHwInitializeAtDirql(
    IN PVOID Context
    )
/*++

Routine Description:

    In the standard init path, the HW initialize routine is called
    synchronously with the interrupt. This routine is the synchronization
    routine.

Arguments:

    Context - Context tuple.

Return Value:

    BOOLEAN - TRUE for success, FALSE for failure.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PCONTEXT_STATUS_TUPLE Tuple;

    Tuple = (PCONTEXT_STATUS_TUPLE) Context;
    ASSERT (Tuple != NULL);
    Adapter = (PRAID_ADAPTER_EXTENSION)Tuple->Context;
    ASSERT_ADAPTER (Adapter);

    Tuple->Status = RaCallMiniportHwInitialize (&Adapter->Miniport);

    return TRUE;
}


NTSTATUS
RaidAdapterStartDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called in response to the PnP manager's StartDevice
    call. It needs to complete any initialization of the adapter that had
    been postponed until now, the call the required miniport routines to
    initialize the HBA. This includes calling at least the miniport's
    HwFindAdapter() and HwInitialize() routines.

Arguments:

    Adapter - The adapter that needs to be started.

    Irp - The PnP start IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PCM_RESOURCE_LIST AllocatedResources;
    PCM_RESOURCE_LIST TranslatedResources;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    ASSERT_ADAPTER (Adapter);

    DebugTrace (("Adapter %p, Irp %p, Pnp StartDevice\n", Adapter, Irp));

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    AllocatedResources = IrpStack->Parameters.StartDevice.AllocatedResources;
    TranslatedResources = IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

    //
    // Forward the irp to the lower level device to start and wait for
    // completion.
    //
    
    Status = RaForwardIrpSynchronous (Adapter->LowerDeviceObject, Irp);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    //
    // Completes the initialization of the device, assigns resources,
    // connects up the resources, etc.
    // The miniport has not been started at this point.
    //
    
    Status = RaidAdapterConfigureResources (Adapter,
                                            AllocatedResources,
                                            TranslatedResources);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    Status = RaidAdapterStartMiniport (Adapter);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    Status = RaidAdapterCompleteInitialization (Adapter);

done:

    //
    // If everything was successful, transition into the working state.
    //
    
    if (NT_SUCCESS (Status)) {
        PriorState = InterlockedExchange ((PULONG)&Adapter->DeviceState,
                                          DeviceStateWorking);
        ASSERT (PriorState == DeviceStateNotPresent);
    }

    DebugTrace (("Adapter %p, Irp %p, Pnp StartDevice, ret = %08x\n",
                 Adapter,
                 Irp));

    return Status;
}


NTSTATUS
RaidAdapterConfigureResources(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    )
/*++

Routine Description:

    Assign and configure resources for an HBA.

Arguments:

    Adapter - Supplies adapter the resources are for.

    AllocatedResources - Supplies the raw resources for this adapter.

    TranslatedResources - Supplies the translated resources for this
            adapter.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    KIRQL InterruptIrql;
    ULONG InterruptVector;
    KAFFINITY InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;
    BOOLEAN InterruptSharable;

    PAGED_CODE();
    
    //
    // Save off the resources we were assigned.
    //

    Status = RaidInitializeResourceList (&Adapter->ResourceList,
                                         AllocatedResources,
                                         TranslatedResources);
    
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize the bus object.
    //
    
    Status = RaInitializeBus (&Adapter->Bus,
                              Adapter->LowerDeviceObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    
    //
    // Initialize deferred work queues and related timer objects. This must
    // be done before we call find adapter.
    //

    RaidInitializeDeferredQueue (&Adapter->DeferredQueue,
                                 Adapter->DeviceObject,
                                 ADAPTER_DEFERRED_QUEUE_DEPTH,
                                 sizeof (RAID_DEFERRED_ELEMENT),
                                 RaidAdapterDeferredRoutine);

    KeInitializeDpc (&Adapter->TimerDpc,
                     RaidpAdapterTimerDpcRoutine,
                     Adapter->DeviceObject);
                     

    KeInitializeTimer (&Adapter->Timer);
    

    KeInitializeDpc (&Adapter->PauseTimerDpc,
                     RaidPauseTimerDpcRoutine,
                     Adapter->DeviceObject);

    KeInitializeTimer (&Adapter->PauseTimer);

    KeInitializeDpc (&Adapter->CompletionDpc,
                     RaidCompletionDpcRoutine,
                     Adapter->DeviceObject);

    //
    // Initialize the system DpcForIsr routine.
    //
    
    IoInitializeDpcRequest (Adapter->DeviceObject, RaidpAdapterDpcRoutine);

    //
    // Initialize the interrupt.
    //

    Status = RaidGetResourceListInterrupt (&Adapter->ResourceList,
                                           &InterruptVector,
                                           &InterruptIrql,
                                           &InterruptMode,
                                           &InterruptSharable,
                                           &InterruptAffinity);
                                           
    if (!NT_SUCCESS (Status)) {
        DebugPrint (("ERROR: Couldn't find interrupt in resource list!\n"));
        return Status;
    }

    Status = IoConnectInterrupt (&Adapter->Interrupt,
                                 RaidpAdapterInterruptRoutine,
                                 Adapter,
                                 NULL,
                                 InterruptVector,
                                 InterruptIrql,
                                 InterruptIrql,
                                 InterruptMode,
                                 InterruptSharable,
                                 InterruptAffinity,
                                 FALSE);

    if (!NT_SUCCESS (Status)) {
        DebugPrint (("ERROR: Couldn't connect to interrupt!\n"));
        return Status;
    }

    //
    // NB: Fetching the interrupt IRQL from the interrupt object is
    // looked down upon, so save it off here.
    //
    
    Adapter->InterruptIrql = InterruptIrql;


    return STATUS_SUCCESS;
}


NTSTATUS
RaidAdapterStartMiniport(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    NTSTATUS Status;
    CONTEXT_STATUS_TUPLE Tuple;
    PHW_INITIALIZATION_DATA HwInitializationData;

    PAGED_CODE();
    
    //
    // Find the HwInitializationData associated with this adapter. This
    // requires a search through the driver's extension.
    //
    
    HwInitializationData = RaidpFindAdapterInitData (Adapter);

    if (HwInitializationData == NULL) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize the Port->Miniport interface.
    //
    
    Status = RaInitializeMiniport (&Adapter->Miniport,
                                   HwInitializationData,
                                   Adapter,
                                   &Adapter->ResourceList,
                                   RaidpAdapterQueryBusNumber (Adapter));

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // At this point, the miniport has been initialized, but we have not made
    // any calls on the miniport. Call HwFindAdapter to find this adapter.
    //
    
    Status = RaCallMiniportFindAdapter (&Adapter->Miniport);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }


    //
    // Initialize the IO Mode and StartIo lock, if necessary.
    //

    Adapter->IoModel = Adapter->Miniport.PortConfiguration.SynchronizationModel;
    
    if (Adapter->IoModel == StorSynchronizeFullDuplex) {
        KeInitializeSpinLock (&Adapter->StartIoLock);
        
    }

    //
    // Call the miniport's HwInitialize routine. This will set the device
    // to start receiving interrupts. For compatability, we always do this
    // synchronized with the adapters ISR. In the future, when we fix
    // SCSIPORT's brain-dead initialization, this will NOT be
    // done synchronized with the ISR.
    //

    Tuple.Status = STATUS_UNSUCCESSFUL;
    Tuple.Context = Adapter;
    KeSynchronizeExecution (Adapter->Interrupt,
                            RaidpAdapterCallHwInitializeAtDirql,
                            &Tuple);
                            
    Status = Tuple.Status;
    

    return Status;
}

NTSTATUS
RaidAdapterCompleteInitialization(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Perform the final steps in initializing the adapter. This routine is
    called only have HwFindAdapter and HwInitialize have both been called.

Arguments:

    Adapter - HBA object to complete initialization for.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    //
    // Initialize the DMA Adapter. This will ususally be done in the
    // GetUncachedExtension routine, before we get here. If by the time
    // we get here it hasn't been initialized, initialize it now.
    //

    if (!RaidIsDmaInitialized (&Adapter->Dma)) {
        
        Status = RaidInitializeDma (&Adapter->Dma,
                                    Adapter->LowerDeviceObject,
                                    &Adapter->Miniport.PortConfiguration);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    //
    // Set maximum transfer length
    //
    
    //
    // Set alignment requirements for adapter's IO.
    //
    
    if (Adapter->Miniport.PortConfiguration.AlignmentMask >
        Adapter->DeviceObject->AlignmentRequirement) {

        Adapter->DeviceObject->AlignmentRequirement =
            Adapter->Miniport.PortConfiguration.AlignmentMask;
    }
    
    Status = RaidpCreateAdapterSymbolicLink (Adapter);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

#if 0
    //
    // Start WMI support.
    //

    Status = RaInitializeWmi (&Adapter->Wmi);

    //
    // Create a well-known name
    //

    
    Status = RaidAdapterRegisterDeviceInterface (Adapter);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

#endif

    //
    // NB: should these be before the HwInitialize call?
    //
    
    //
    // Setup the Adapter's power state.
    //

    RaInitializePower (&Adapter->Power);
    RaSetSystemPowerState (&Adapter->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Adapter->Power, PowerDeviceD0);

    return STATUS_SUCCESS;
}


NTSTATUS
RaidAdapterStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Stop the device.

Arguments:

    Adapter - The adapter to stop.

    Irp - Stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();
    ASSERT (Irp != NULL);

    //
    // BUGBUG: This routine needs work.
    //
    
    NYI ();
    
    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);
    
    //
    // Forward the irp to the lower level device to handle.
    //
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    
    return Status;
}

NTSTATUS
RaidAdapterRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Remove the device.

Arguments:

    Adapter - Adapter to remove.

    Irp - Remove device Irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();
    ASSERT (Irp != NULL);

    //
    // Forward the remove to lower level drivers first.
    //
    
    Status = RaForwardIrpSynchronous (Adapter->LowerDeviceObject, Irp);
    ASSERT (NT_SUCCESS (Status));

//    IoSetDeviceInterfaceState (Adapter->InterfaceName, FALSE);

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateRemoved);

    ASSERT (PriorState == DeviceStateSurpriseRemoval ||
            PriorState == DeviceStatePendingRemove);
    

    //
    // Allow any pending i/o to complete, and
    // prevent any new io from coming in.
    //
    
    IoReleaseRemoveLockAndWait (&Adapter->RemoveLock, Irp);

    //
    // Detach and delete the device.
    //
    
    IoDetachDevice (Adapter->LowerDeviceObject);
    IoDeleteDevice (Adapter->DeviceObject);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaidAdapterQueryStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Query if we can stop the device.

Arguments:

    Adapter - Adapter we are looking to stop.

    Irp - Query stop irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterCancelStopDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Cancel a stop request on the adapter.

Arguments:

    Adapter - Adapter that was previously querried for stop.

    Irp - Cancel stop irp.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterQueryRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Query if the adapter can be removed.

Arguments:

    Adapter - Adapter to query for remove.

    Irp - Remove device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStatePendingRemove);
    ASSERT (PriorState == DeviceStateWorking);
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}



NTSTATUS
RaidAdapterCancelRemoveDeviceIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Cancel a pending remove request on the adapter.

Arguments:

    Adapter - Adapter that is in pending remove state.

    Irp - Cancel remove irp.
    
Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Adapter->DeviceState,
                                      DeviceStateWorking);

    ASSERT (PriorState == DeviceStateWorking ||
            PriorState == DeviceStatePendingRemove);
            
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterSurpriseRemovalIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Remove the adapter without asking if it can be removed.

Arguments:

    Adapter - Adapter to remove.

    Irp - Surprise removal irp.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    PAGED_CODE ();

    InterlockedExchange ((PLONG)&Adapter->DeviceState, DeviceStateNotPresent);
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    return Status;
}

NTSTATUS
RaidAdapterFilterResourceRequirementsIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    We handle the IRP_MN_FILTER_RESOURCE_REQUIREMENTS irp only so we
    can pull out some useful information from the irp.

Arguments:

    Adapter - Adapter this irp is for.

    Irp - FilterResourceRequirements IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Requirements = IrpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

    if (Requirements) {
        Adapter->BusNumber = Requirements->BusNumber;
        Adapter->SlotNumber = Requirements->SlotNumber;
    }
    
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    return Status;
}

NTSTATUS
RaidAdapterQueryIdIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    NTSTATUS Status;

    //
    // NB: SCSIPORT fills in some compatible IDs here. We will probably
    // need to as well.
    //
    
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    return Status;
}

NTSTATUS
RaidAdapterQueryPnpDeviceStateIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();

    DeviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
    //
    // BUGBUG: Update the state here.
    //
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterScsiIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    PAGED_CODE ();
    ASSERT (Irp != NULL);

    //
    // SCSI requests are handled by the logical unit, not the adapter.
    // Give a warning to this effect.
    //
    
    DebugWarn (("Adapter (%p) failing SCSI Irp %p\n", Adapter, Irp));

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_UNSUCCESSFUL);
}

NTSTATUS
RaidAdapterPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch power irps to function specific handlers.

Arguments:

    Adapter - Adapter the irp is for.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    Minor = RaidMinorFunctionFromIrp (Irp);

    switch (Minor) {

        case IRP_MN_QUERY_POWER:
            Status = RaidAdapterQueryPowerIrp (Adapter, Irp);
            break;

        case IRP_MN_SET_POWER:
            Status = RaidAdapterSetPowerIrp (Adapter, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}


NTSTATUS
RaidAdapterQueryPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the query power irp.
    
Arguments:

    Adapter - Adapter to query for power.

    Irp - Query power irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    IoCopyCurrentIrpStackLocationToNext (Irp);
    PoStartNextPowerIrp (Irp);
    Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

    return Status;
}


NTSTATUS
RaidAdapterSetPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for the adapter set power irp.

Arguments:

    Adapter - Adapter that will handle this irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    POWER_STATE_TYPE PowerType;
    POWER_STATE PowerState;
    
    //
    // Ignore shutdown irps.
    //

    PowerState = RaidPowerStateFromIrp (Irp);

    if (PowerState.SystemState >= PowerSystemShutdown) {

        IoCopyCurrentIrpStackLocationToNext (Irp);
        PoStartNextPowerIrp (Irp);
        Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);

        return Status;
    }
        
    PowerType = RaidPowerTypeFromIrp (Irp);

    switch (PowerType) {

        case SystemPowerState:
            Status = RaidAdapterSetSystemPowerIrp (Adapter, Irp);
            break;

        case DevicePowerState:
            Status = RaidAdapterSetDevicePowerIrp (Adapter, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
RaidAdapterSetDevicePowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the set power irp for a device state on the adapter.

Arguments:

    Adapter - Adapter that will handle this irp.

    Irp -  Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE CurrentState;
    DEVICE_POWER_STATE RequestedState;  
    
    ASSERT_ADAPTER (Adapter);
    ASSERT (RaidPowerTypeFromIrp (Irp) == DevicePowerState);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Adapter->Power.DeviceState;
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;

    //
    // BUGBUG: Need to disable the adapter here.
    //

    NYI();
    
    Adapter->Power.DeviceState = RequestedState;

    //
    // REVIEW: Do we need to set the IRP status before we call
    // PoStartNextPowerIrp?
    //
    
    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);

    return Status;
}


NTSTATUS
RaidAdapterSetSystemPowerIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a IRP_MN_POWER, IRP_MN_SET_POWER of type SystemPowerState irp
    for the adapter object.

Arguments:

    Adapter - Adapter the power irp is for.

    Irp - Set power irp to be processed.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BOOLEAN RequestHandled;
    POWER_STATE PowerState;
    PIO_STACK_LOCATION IrpStack;
    SYSTEM_POWER_STATE CurrentState;
    SYSTEM_POWER_STATE RequestedState;

    ASSERT_ADAPTER (Adapter);
    ASSERT (RaidPowerTypeFromIrp (Irp) == SystemPowerState);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Adapter->Power.SystemState;
    RequestedState = IrpStack->Parameters.Power.State.SystemState;

    //
    // If the request has been handled then we do not call pass the
    // request on to the lower driver. Otherwise, we do.
    //
    
    RequestHandled = FALSE;

    //
    // Is this either a power up or power down event?
    //
    
    if (CurrentState == PowerSystemWorking &&
        RequestedState != PowerSystemWorking) {

        //
        // Requested a transition from a non-working power state to a
        // working power state: we are powering down. Request to put the
        // device in D3 state.
        //

        //
        // REVIEW: it is correct system power irp pending at this point,
        // right? Not all examples I have seen do this.
        //
        
        IoMarkIrpPending (Irp);
        
        PowerState.SystemState = PowerSystemUnspecified;
        PowerState.DeviceState = PowerDeviceD3;

        Status = PoRequestPowerIrp (Adapter->DeviceObject,
                                    IRP_MN_SET_POWER,
                                    PowerState,
                                    RaidpAdapterEnterD3Completion,
                                    Irp,
                                    NULL);

        //
        // The completion function will pass the request on to the lower
        // driver.
        //

        RequestHandled = TRUE;
        

    } else if (CurrentState != PowerSystemWorking &&
               RequestedState == PowerSystemWorking) {

        //
        // Request to transition the system state from a non-working to
        // a working state: we are powering up. Reenable the adapter.
        //

        NYI();

    } else {

        REVIEW();
    }

    //
    // If the Irp was not handled, pass it on to the lower level driver.
    //
    
    if (!RequestHandled) {
        PoStartNextPowerIrp (Irp);
        IoSkipCurrentIrpStackLocation (Irp);
        Status = PoCallDriver (Adapter->LowerDeviceObject, Irp);
    }
        
    return Status;
}


VOID
RaidpAdapterEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This completion function is invoked when the adapter has entered
    the PowerDeviceD3 power state.

Arguments:

    DeviceObject - Device object representing an adapter object.

    MinorFunction - Minor function this irp is for; must be IRP_MN_SET_POWER.

    PowerState - Power state we are entering; must be PowerDeviceD3.

    SystemPowerIrp - Pointer to the system power irp that generated the
            device power irp we are completing.

    IoStatus - IoStatus for the device irp.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PIO_STACK_LOCATION IrpStack;

    ASSERT (IsAdapter (DeviceObject));
    Adapter = (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;
    IrpStack = IoGetCurrentIrpStackLocation (SystemPowerIrp);

    //
    // On failure, complete the system irp and continue.
    //
    
    if (!NT_SUCCESS (IoStatus->Status)) {

        SystemPowerIrp->IoStatus.Status = IoStatus->Status;
        PoStartNextPowerIrp (SystemPowerIrp);
        RaidCompleteRequest (SystemPowerIrp,
                             IO_NO_INCREMENT,
                             SystemPowerIrp->IoStatus.Status);

        return;
    }

    //
    // Call into the miniport to disable the adapter.
    //
    
    RaidAdapterDisable (Adapter);
    
    PoStartNextPowerIrp (SystemPowerIrp);
    IoCopyCurrentIrpStackLocationToNext (SystemPowerIrp);
    PoCallDriver (Adapter->LowerDeviceObject, SystemPowerIrp);
}
    
NTSTATUS
RaidAdapterSystemControlIrp(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle WMI requests by forwarding them to the next lower device.

Arguments:

    Adapter - The adapter this irp is for.

    Irp - WMI irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    PAGED_CODE ();
    Status = RaForwardIrp (Adapter->LowerDeviceObject, Irp);
    
    return Status;
}

NTSTATUS
RaidAdapterStorageQueryPropertyIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    SIZE_T BufferSize;
    PVOID Buffer;

    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (Query->PropertyId != StorageAdapterProperty) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    IO_NO_INCREMENT,
                                    STATUS_INVALID_DEVICE_REQUEST);
    }

    if (Query->QueryType == PropertyStandardQuery) {
        Status = RaidGetStorageAdapterProperty (Adapter,
                                              Buffer,
                                              &BufferSize);
        Irp->IoStatus.Information = BufferSize;
    } else {
        ASSERT (Query->QueryType == PropertyExistsQuery);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaidAdapterMapBuffers(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Some adapters require data buffers to be mapped to addressable VA
    before they can be executed. Traditionally, this was for Programmed
    IO, but raid adapters also require this because the card firmware may
    not completely implement the full SCSI command set and may require
    some commands to be simulated in software.

    Mapping requests is problematic for two reasons. First, it requires
    an aquisition of the PFN database lock, which is one of the hottest
    locks in the system. This is especially annoying on RAID cards read
    and write requests almost never need to be mapped. Rather, it's IOCTLs
    and infrequently issued SCSI commands that need to be mapped. Second,
    this is the only aquisition of resources in the IO path that can fail,
    which makes our error handling more complicated.

    The trade-off we make is as follows: we define another bit in the
    port configuration that specifies buffers need to be mapped for non-IO
    (read, write) requests.

Arguments:

    Adapter - 
    
    Irp - Supplies irp to map.

Return Value:

    NTSTATUS code.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    MM_PAGE_PRIORITY Priority;
    PVOID SystemAddress;
    SIZE_T DataOffset;

    //
    // No MDL means nothing to map.
    //
    
    if (Irp->MdlAddress == NULL) {
        return STATUS_SUCCESS;
    }

    Srb = RaidSrbFromIrp (Irp);

    //
    // REVIEW:
    //
    // For now, we interpret the MappedBuffers flag to mean that you
    // need buffer mappings for NON-IO requests. If you need mapped
    // buffers for IO requests, you have a brain-dead adapter. Fix
    // this when we add another bit for mapped buffers that are not
    // read and write requests.
    //
    
    if (IsMappedSrb (Srb) ||
        (RaidAdapterRequiresMappedBuffers (Adapter) &&
         !IsExcludedFromMapping (Srb))) {

        if (Irp->RequestorMode == KernelMode) {
            Priority = HighPagePriority;
        } else {
            Priority = NormalPagePriority;
        }

        SystemAddress = RaidGetSystemAddressForMdl (Irp->MdlAddress,
                                                    Priority,
                                                    Adapter->DeviceObject);

        //
        // The assumption here (same as with scsiport) is that the data
        // buffer is at some offset from the MDL address specified in
        // the IRP.
        //
        
        DataOffset = (ULONG_PTR)Srb->DataBuffer -
                     (ULONG_PTR)MmGetMdlVirtualAddress (Irp->MdlAddress);

        ASSERT (DataOffset < MmGetMdlByteCount (Irp->MdlAddress));
        
        Srb->DataBuffer = (PUCHAR)SystemAddress + DataOffset;
    }

    return STATUS_SUCCESS;
}
        

NTSTATUS
RaidGetSrbIoctlFromIrp(
    IN PIRP Irp,
    OUT PSRB_IO_CONTROL* SrbIoctlBuffer,
    OUT ULONG* InputLength,
    OUT ULONG* OutputLength
    )
{
    NTSTATUS Status;
    ULONGLONG LongLength;
    ULONG Length;
    PIO_STACK_LOCATION IrpStack;
    PIRP_STACK_DEVICE_IO_CONTROL Ioctl;
    PSRB_IO_CONTROL SrbIoctl;

    PAGED_CODE();
    
    //
    // First, validate the IRP
    //

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    SrbIoctl = Irp->AssociatedIrp.SystemBuffer;
    Ioctl = (PIRP_STACK_DEVICE_IO_CONTROL)&IrpStack->Parameters.DeviceIoControl;

    if (Ioctl->InputBufferLength < sizeof (SRB_IO_CONTROL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (SrbIoctl->HeaderLength != sizeof (SRB_IO_CONTROL)) {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Make certian the total length doesn't overflow a ULONG
    //
    
    LongLength = SrbIoctl->HeaderLength;
    LongLength += SrbIoctl->Length;
    
    if (LongLength > ULONG_MAX) {
        return STATUS_INVALID_PARAMETER;
    }

    Length = (ULONG)LongLength;

    if (Ioctl->OutputBufferLength < Length || Ioctl->InputBufferLength < Length) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (SrbIoctlBuffer) {
        *SrbIoctlBuffer = SrbIoctl;
    }

    if (InputLength) {
        *InputLength = Length;
    }

    if (OutputLength) {
        *OutputLength = Ioctl->OutputBufferLength;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RaidAdapterScsiMiniportIoctl(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle an IOCTL_SCSI_MINIPORT ioctl for this adapter.

Arguments:

    Adapter - The adapter that should handle this IOCTL.

    Irp - Irp representing a SRB IOCTL.

Algorithm:

    Unlike scsiport, which translates the IOCTL into a IRP_MJ_SCSI
    request, then executes the request on the first logical unit in the
    unit list -- we execute the IOCTL "directly" on the adapter. We will
    be able to execute even when the adapter has detected no devices, if
    this matters.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    RAID_MEMORY_REGION SrbExtensionRegion;
    PSRB_IO_CONTROL SrbIoctl;
    ULONG InputLength;
    ULONG OutputLength;

    ASSERT_ADAPTER (Adapter);
    ASSERT (Irp != NULL);
    
    PAGED_CODE();

    Srb = NULL;
    Xrb = NULL;
    RaidCreateRegion (&SrbExtensionRegion);

    Status = RaidGetSrbIoctlFromIrp (Irp, &SrbIoctl, &InputLength, &OutputLength);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Begin allocation chain
    //
    
    Srb = RaidAllocateSrb (Adapter->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Xrb = RaidAllocateXrb (NULL, Adapter->DeviceObject);

    if (Xrb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Srb->OriginalRequest = Xrb;
    Xrb->Srb = Srb;

    RaidBuildMdlForXrb (Xrb, SrbIoctl, InputLength);

    //
    // Build the srb
    //

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_IO_CONTROL;
    Srb->PathId = 0;
    Srb->TargetId = 0;
    Srb->Lun = 0;
    Srb->SrbFlags = SRB_FLAGS_DATA_IN ;
    Srb->DataBuffer = SrbIoctl;
    Srb->DataTransferLength = InputLength;
    Srb->TimeOutValue = SrbIoctl->Timeout;

    //
    // Srb extension
    //


    Status = RaidDmaAllocateCommonBuffer (&Adapter->Dma,
                                          RaGetSrbExtensionSize (Adapter),
                                          FALSE,
                                          &SrbExtensionRegion);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Get the VA for the SRB's extension
    //
    
    Srb->SrbExtension = RaidRegionGetVirtualBase (&SrbExtensionRegion);


    //
    // Map buffers, if necessary.
    //
    
    RaidAdapterMapBuffers (Adapter, Irp);


    //
    // Initialize the Xrb's completion event and
    // completion routine.
    //

    KeInitializeEvent (&Xrb->u.CompletionEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Set the completion routine for the Xrb. This effectivly makes the
    // XRB synchronous.
    //
    
    RaidXrbSetCompletionRoutine (Xrb,
                                 RaidXrbSignalCompletion);

    //
    // And execute the Xrb.
    //
    
    Status = RaidAdapterRaiseIrqlAndExecuteXrb (Adapter, Xrb);

    if (NT_SUCCESS (Status)) {
        KeWaitForSingleObject (&Xrb->u.CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);
    }


done:

    //
    // Set the information length to the min of the output buffer length
    // and the length of the data returned by the SRB.
    //
        
    if (NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = min (OutputLength,
                                         Srb->DataTransferLength);
    } else {
        Irp->IoStatus.Information = 0;
    }

    //
    // Deallocate everything
    //

    if (RaidIsRegionInitialized (&SrbExtensionRegion)) {
        RaidDmaFreeCommonBuffer (&Adapter->Dma,
                                 &SrbExtensionRegion,
                                 FALSE);
        RaidDeleteRegion (&SrbExtensionRegion);
        Srb->SrbExtension = NULL;
    }


    if (Xrb != NULL) {
        RaidFreeXrb (Xrb);
        Srb->OriginalRequest = NULL;
    }


    //
    // The SRB extension and XRB must be released before the
    // SRB is freed.
    //

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

VOID
RaidAdapterRequestComplete(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine is called when an IO request to the adapter has been
    completed. It needs to put the IO on the completed queue and request
    a DPC.

Arguments:

    Adapter - Adapter on which the IO has completed.

    Xrb - Completed IO.

Return Value:

    None.

--*/
{
    LOGICAL Pending;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Next;

    //
    // At this point, the only errors that are handled synchronously
    // are busy errors.

    Srb = Xrb->Srb;
//
//BUGBUG: Test Code
//

//Begin{Test}

    //
    // Busy is handled in two separate parts. The first part, here, marks the
    // gateway as busy. The second part, done later at dispatch level, is 
    //
    
    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY) {
        StorBusyIoGateway (&Adapter->Gateway);
    }
    
//End{Test}
    
    //
    // Mark the irp as awaiting completion.
    //

    if (Xrb->Irp) {
        ASSERT (RaidGetIrpState (Xrb->Irp) == RaidMiniportProcessingIrp);
        RaidSetIrpState (Xrb->Irp, RaidPendingCompletionIrp);
    }
    

    InterlockedPushEntrySList (&Adapter->CompletedList,
                               &Xrb->CompletedLink);

#if 0
    Pending = RaidAdapterMarkDpcPending (Adapter, KeGetCurrentProcessor());
#else
    Pending = FALSE;
#endif

    if (!Pending) {
        IoRequestDpc (Adapter->DeviceObject, NULL, NULL);
    }
}


BOOLEAN
RaidpAdapterExecuteXrbAtDirql(
    IN PVOID Context
    )
/*++

Routine Description:

    Routine is called from KeSynchronizeExecution, synchronized
    with the device's interrupt.

Arguments:

    Context - Xrb to execute.

Return Value:

    TRUE - Success

    FALSE - Failure

Environment:

    Routine must be called with the interrupt spinlock held.

--*/
{
    BOOLEAN Succ;
    NTSTATUS Status;
    PCONTEXT_STATUS_TUPLE Tuple;
    PRAID_ADAPTER_EXTENSION Adapter;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCSI_REQUEST_BLOCK Srb;

    Tuple = (PCONTEXT_STATUS_TUPLE) Context;
    Xrb = (PEXTENDED_REQUEST_BLOCK) Tuple->Context;
    ASSERT_XRB (Xrb);
    Adapter = Xrb->Adapter;
    ASSERT_ADAPTER (Adapter);
    Srb = Xrb->Srb;

    //
    // Mark the irp as being processed by the miniport.x
    //

    if (Xrb->Irp) {
        RaidSetIrpState (Xrb->Irp, RaidMiniportProcessingIrp);
    }

    Succ = RaCallMiniportStartIo (&Xrb->Adapter->Miniport, Xrb->Srb);

    //
    // NB: This would fail if you error'd the srb and returned false.
    //
    
    if (!Succ) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_SUCCESS;
    }
    
    Tuple->Status = Status;

    return TRUE;
}


VOID
RaidAdapterPostScatterGatherExecute(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PCONTEXT_STATUS_TUPLE Tuple
    )
/*++

Routine Description:

    This routine executes the SRB by calling the adapter's BuildIo (if
    present) and StartIo routine, taking into account the different locking
    schemes associated with the two different IoModels.

Arguments:

    Adapter - Supplies the XRB is executed on.

    Tuple - Supplies a tuple with a XRB as the first parameter and a
        return buffer for a status as the second parameter.

Return Value:

    NTSTATUS code.

--*/
{
    BOOLEAN Succ;
    NTSTATUS Status;
    PEXTENDED_REQUEST_BLOCK Xrb;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    ASSERT_ADAPTER (Adapter);
    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    Xrb = (PEXTENDED_REQUEST_BLOCK)Tuple->Context;
    ASSERT_XRB (Xrb);
    
    Xrb->Adapter = Adapter;

    //
    // First, execute the miniport's HwBuildIo routine, if one is present.
    //
    
    Succ = RaCallMiniportBuildIo (&Xrb->Adapter->Miniport, Xrb->Srb);
    if (!Succ) {
        Tuple->Status = STATUS_UNSUCCESSFUL;
        return;
    }

    if (Adapter->IoModel == StorSynchronizeHalfDuplex) {

        //
        // In half-duplex mode, we synchronize all access to the
        // hardware with the interrupt.
        //

        KeSynchronizeExecution (Adapter->Interrupt,
                                RaidpAdapterExecuteXrbAtDirql,
                                Tuple);

    } else {

        //
        // In full-duplex mode, we sending requests down to the adapter
        // (StartIo) does not need to be synchronized with completing
        // io (Interrupt). We desynchronize these by synchronizing
        // access to the StartIo function with the StartIoLock and
        // access to the Interrupt with the interrupt SpinLock.
        //

        KeAcquireInStackQueuedSpinLockAtDpcLevel (&Adapter->StartIoLock,
                                                  &LockHandle);
        RaidpAdapterExecuteXrbAtDirql (Tuple);
        KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);
    }
}



VOID
RaidpAdapterContinueScatterGather(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCATTER_GATHER_LIST ScatterGatherList,
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called when the scatter/gather list has been successfully
    allocated. The function associates the scatter/gather list with the XRB parameter
    then calls a lower-level routine to send the XRB to the miniport.

Arguments:

    DeviceObject - DeviceObject representing an adapter that this IO is
        associated with.

    Irp - Irp representing the IO to execute.

    ScatterGatherList - Allocated scatter/gather list for this IO.

    Context - Context parameter.

Return Value:

    None.

--*/
{
    PCONTEXT_STATUS_TUPLE Tuple;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    KLOCK_QUEUE_HANDLE LockHandle;

    Adapter = DeviceObject->DeviceExtension;
    Tuple = Context;
    Xrb = (PEXTENDED_REQUEST_BLOCK)Tuple->Context;
    ASSERT_XRB (Xrb);
    
    //
    // Assoicate the allocated scatter gather list with our SRB, then
    // execute the XRB.
    //

    RaidXrbSetSgList (Xrb, Adapter, ScatterGatherList);
    RaidAdapterPostScatterGatherExecute (Adapter, Tuple);

    if (Adapter->Flags.BusChanged) {
        REVIEW();
        Adapter->Flags.BusChanged = FALSE;
        IoInvalidateDeviceRelations (Adapter->LowerDeviceObject, BusRelations);
    }
}



VOID
RaidAdapterScatterGatherExecute(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PCONTEXT_STATUS_TUPLE Tuple
    )
/*++

Routine Description:

    Allocate a scatter gather list then execute the XRB.

Arguments:

    Adapter - Supplies adapter this IO is to be executed on.

    Tuple -

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    BOOLEAN ReadData;
    BOOLEAN WriteData;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    
    Xrb = (PEXTENDED_REQUEST_BLOCK)Tuple->Context;
    ASSERT_XRB (Xrb);

    Srb = Xrb->Srb;
    ReadData = TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_IN);
    WriteData = TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
    Status = STATUS_UNSUCCESSFUL;

    KeFlushIoBuffers (Xrb->Mdl, ReadData, TRUE);

    //
    // BuildScatterGatherList is like GetScatterGatherList except
    // that it uses our private SG buffer to allocate the SG list.
    // Therefore we do not take a pool allocation hit each time
    // we call BuildScatterGatherList like we do each time we call
    // GetScatterGatherList. If our pre-allocated SG list is too
    // small for the run, the function will return STATUS_BUFFER_TOO_SMALL
    // and we retry it allowing the DMA functions to do the
    // allocation.
    //

    //
    // BUGBUG: The handling of the tuple (below) implies this
    // is a synchronous call. If we are allocating map registers
    // and the system is running low on map registers, the function
    // WILL NOT BE EXECUTED SYNCHRONOUSLY. This is important because
    // it won't happen very often, and we'll need to explicitly
    // generate test cases for it. This code is currently broken
    // for this case anyway.
    //

    //
    // REVIEW: The fourth parameter to the DMA Scatter/Gather functions
    // is the original VA, not the mapped system VA, right?
    //
    
    Status = RaidDmaBuildScatterGatherList (
                                &Adapter->Dma,
                                Adapter->DeviceObject,
                                Xrb->Mdl,
                                MmGetMdlVirtualAddress (Xrb->Mdl),
                                Srb->DataTransferLength,
                                RaidpAdapterContinueScatterGather,
                                Tuple,
                                WriteData,
                                Xrb->ScatterGatherBuffer,
                                sizeof (Xrb->ScatterGatherBuffer));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        //
        // The SG list is larger than we support internally. Fall back
        // on GetScatterGatherList which uses pool allocations to
        // satisify the SG list.
        //

        Status = RaidDmaGetScatterGatherList (
                                        &Adapter->Dma,
                                        Adapter->DeviceObject,
                                        Xrb->Mdl,
                                        MmGetMdlVirtualAddress (Xrb->Mdl),
                                        Srb->DataTransferLength,
                                        RaidpAdapterContinueScatterGather,
                                        Tuple,
                                        WriteData);
    }
    
    if (!NT_SUCCESS (Status)) {
        Tuple->Status = Status;
    }
}


ULONG DropRequest = 0;
PEXTENDED_REQUEST_BLOCK DroppedRequest = NULL;

NTSTATUS
RaidAdapterExecuteXrb(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Execute the Xrb on the specified adapter.

Arguments:

    Adapter - Adapter object that the xrb will be executed on.

    Xrb - Xrb to be executed.

Return Value:

    STATUS_SUCCESS - The IO operation has successfully started. Any IO
            errors will be asynchronously signaled. The Xrb should
            not be accessed by the caller.

    Otherwise - There was an error processing the request. The Status value
            signals what type of error. The Xrb is still valid, and needs
            to be completed by the caller.
--*/
{
    NTSTATUS Status;
    CONTEXT_STATUS_TUPLE Tuple;
    VERIFY_DISPATCH_LEVEL ();
    
    ASSERT_ADAPTER (Adapter);

    if (DropRequest) {
        DropRequest--;
        DebugTrace (("Dropping Xrb %p\n", Xrb));
        DroppedRequest = Xrb;
        return STATUS_SUCCESS;
    }

    Tuple.Context = Xrb;
    Tuple.Status = STATUS_UNSUCCESSFUL;
    
    if (TEST_FLAG (Xrb->Srb->SrbFlags, SRB_FLAGS_DATA_IN) ||
        TEST_FLAG (Xrb->Srb->SrbFlags, SRB_FLAGS_DATA_OUT)) {
        RaidAdapterScatterGatherExecute (Adapter, &Tuple);
    } else {
        RaidAdapterPostScatterGatherExecute (Adapter, &Tuple);
    }

    return Tuple.Status;
}



NTSTATUS
RaidAdapterEnumerateBus(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PADAPTER_ENUMERATION_ROUTINE EnumRoutine,
    IN PVOID Context
    )
/*++

Routine Description:

    Enumerate the adapter's bus, calling the specified callback routine
    for each valid (path, target, lun) triple on the SCSI bus.

Arguments:

    Adapter - Adapter object that is to be enumerated.

    EnumRoutine - Enumeration routine used for each valid target on the
        bus.

    Context - Context data for the enumeration routine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    RAID_ADDRESS Address;
    ULONG Path;
    ULONG Target;
    ULONG Lun;
    ULONG MaxBuses;
    ULONG MaxTargets;
    ULONG MaxLuns;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    
    MaxBuses = RiGetNumberOfBuses (Adapter);
    MaxTargets = RiGetMaximumTargetId (Adapter);
    MaxLuns = RiGetMaximumLun (Adapter);
    
    for (Path = 0; Path < MaxBuses; Path++) {
        for (Target = 0; Target < MaxTargets; Target++) {
            for (Lun = 0; Lun < MaxLuns; Lun++) {

                Address.PathId = (UCHAR)Path;
                Address.TargetId = (UCHAR)Target;
                Address.Lun = (UCHAR)Lun;
                Address.Reserved = 0;

                Status = EnumRoutine (Context, Address);
                if (!NT_SUCCESS (Status)) {
                    return Status;
                }
            }
        }
    }

    return Status;
}



VOID
RaidAdapterBusChangedDetected(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Notify the adpater (and PnP) that the bus has changed. This will
    eventually trigger a re-enumeration of the bus, when PnP queries the bus
    relations.

Arguments:

    Adapter - Supplies the adapter object to mark for re-enumeration.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE();
    IoInvalidateDeviceRelations (Adapter->LowerDeviceObject, BusRelations);
}



NTSTATUS
RaidAdapterUpdateDeviceTree(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
/*++

Routine Description:

    Re-enumerate the bus and do any processing for changed devices. This
    includes creating device objects for created logical units and destroying
    device objects for deleted logical units.

Arguments:

    Adapter - Supplies the adapter object to be re-enumerated.

Return Value:

    NTSTATUS code.

Notes:

    Re-enumeration of the bus is expensive.
    
--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    BUS_ENUMERATOR Enumerator;
    PLIST_ENTRY NextEntry;

    RaidCreateBusEnumerator (&Enumerator);

    Status = RaidInitializeBusEnumerator (&Enumerator, Adapter);

#if 0
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite (&Adapter->UnitList.Lock, FALSE);
    
    for (NextEntry = Adapter->UnitList.List.Flink;
         NextEntry != &Adapter->UnitList.List;
         NextEntry = NextEntry->Flink) {

        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        ASSERT_UNIT (Unit);
        
        RaidBusEnumeratorAddUnit (&Enumerator, Unit);
    }

    ExReleaseResourceLite (&Adapter->UnitList.Lock);
    KeLeaveCriticalRegion ();
#endif

    Status = RaidAdapterEnumerateBus (Adapter,
                                      RaidBusEnumeratorVisitUnit,
                                      &Enumerator);

    if (NT_SUCCESS (Status)) {
        RaidBusEnumeratorProcessModifiedNodes (&Enumerator);
    }

    RaidDeleteBusEnumerator (&Enumerator);
    
    return Status;
}

#if 0
NTSTATUS
RaidAdapterCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_ADDRESS Address,
    OUT PRAID_UNIT_EXTENSION * UnitBuffer OPTIONAL
    )
/*++

Routine Description:

    Create and initailzie a logical unit and add it to the adapter's unit
    list.

Arguments:

    Adapter - Adpater who will own the created unit.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT DeviceObject;
    PRAID_UNIT_EXTENSION Unit;
    
    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);

    //
    // Create the unit.
    //


    //
    // Initialize a new logical unit object.
    //
    
    RaCreateUnit (Adapter, &Unit);
    Status = RaInitializeUnit (Unit,
                               DeviceObject,
                               Adapter,
                               PathId,
                               TargetId,
                               Lun,
                               InquiryData,
                               UnitExtension);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Insert the unit into the adapter's unit list.
    //
    
    RaidAdapterInsertUnit (Adapter, Unit);

    //
    // Clear the initializing flag.
    //

    CLEAR_FLAG (DeviceObject->Flags, DO_DEVICE_INITIALIZING);

    //
    // If the caller requested a unit object on return, fill it in now.
    //

    if (UnitBuffer) {
        *UnitBuffer = Unit;
    }
        
    return Status;
}
#endif


NTSTATUS
RaidpBuildAdapterBusRelations(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PDEVICE_RELATIONS * DeviceRelationsBuffer
    )
/*++

Routine Description:

    Build a device relations list representing the adapter's bus
    relations.  This routine will not enumerate the adapter. Rather, it
    will build a list from the logical units that are current in the
    adpater's logical unit list.

Arguments:

    Adapter - The adapter to build the BusRelations list for.

    DeviceRelationsBuffer - Pointer to a buffer to recieve the bus
            relations.  This memory must be freed by the caller.
    
Return Value:

    NTSTATUS code.

--*/
{
    ULONG Count;
    SIZE_T RelationsSize;
    PDEVICE_RELATIONS DeviceRelations;
    PLIST_ENTRY NextEntry;
    PRAID_UNIT_EXTENSION Unit;
    
    
    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    ASSERT (DeviceRelationsBuffer != NULL);

    //
    // Acquire the unit list lock in shared mode. This lock protects both
    // the list and the list count, so it must be acquired before we inspect
    // the number of elements in the unit list.
    //
    
    ExAcquireResourceSharedLite (&Adapter->UnitList.Lock, TRUE);
    
    RelationsSize = sizeof (DEVICE_RELATIONS) +
                    (Adapter->UnitList.Count * sizeof (PDEVICE_OBJECT));

    DeviceRelations = RaidAllocatePool (PagedPool,
                                        RelationsSize,
                                        DEVICE_RELATIONS_TAG,
                                        Adapter->DeviceObject);

    if (DeviceRelations == NULL) {
        ExReleaseResourceLite (&Adapter->UnitList.Lock);
        return STATUS_NO_MEMORY;
    }


    //
    // Walk the adapter's list of units, adding an entry for each unit on
    // the adapter's unit list.
    //

    Count = 0;
    for ( NextEntry = Adapter->UnitList.List.Flink;
          NextEntry != &Adapter->UnitList.List;
          NextEntry = NextEntry->Flink ) {

        
        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        //
        // If the device state is Removed, we DO NOT want to return a
        // reference to the unit. Actually, the better algorithm is to
        // delete the unit if it is in the PnP delete state here.
        //
        
        if (InterlockedQuery ((PULONG)&Unit->DeviceState) == DeviceStateRemoved ||
            !Unit->Flags.Present) {
            RaidUnitSetEnumerated (Unit, FALSE);
        } else {

            //
            // Take a reference to the object that PnP will release.
            //

            RaidUnitSetEnumerated (Unit, TRUE);
            ObReferenceObject (Unit->DeviceObject);
            DeviceRelations->Objects[Count++] = Unit->DeviceObject;
        }
        
    }

    ExReleaseResourceLite (&Adapter->UnitList.Lock);

    //
    // Fill in the remaining fields of the DeviceRelations structure.
    //
    
    DeviceRelations->Count = Count;
    *DeviceRelationsBuffer = DeviceRelations;
    
    return STATUS_SUCCESS;
}
                                   

NTSTATUS
RaidGetStorageAdapterProperty(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PSTORAGE_ADAPTER_DESCRIPTOR Descriptor,
    IN OUT PSIZE_T DescriptorLength
    )
{
    PPORT_CONFIGURATION_INFORMATION PortConfig;
    
    PAGED_CODE ();
    ASSERT_ADAPTER (Adapter);
    ASSERT (Descriptor != NULL);

    if (*DescriptorLength < sizeof (STORAGE_DESCRIPTOR_HEADER)) {
        *DescriptorLength = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
        return STATUS_BUFFER_TOO_SMALL;
    } else if (*DescriptorLength >= sizeof (STORAGE_DESCRIPTOR_HEADER) &&
               *DescriptorLength < sizeof (STORAGE_ADAPTER_DESCRIPTOR)) {

        Descriptor->Version = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
        Descriptor->Size = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
        *DescriptorLength = sizeof (STORAGE_DESCRIPTOR_HEADER);
        return STATUS_SUCCESS;
    }

    PortConfig = &Adapter->Miniport.PortConfiguration;
    
    Descriptor->Version = sizeof (Descriptor);
    Descriptor->Size = sizeof (Descriptor);

    Descriptor->MaximumPhysicalPages = min (PortConfig->NumberOfPhysicalBreaks,
                                            Adapter->Dma.NumberOfMapRegisters);
    Descriptor->MaximumTransferLength = PortConfig->MaximumTransferLength;
    Descriptor->AlignmentMask = PortConfig->AlignmentMask;
    Descriptor->AdapterUsesPio = PortConfig->MapBuffers;
    Descriptor->AdapterScansDown = PortConfig->AdapterScansDown;
    Descriptor->CommandQueueing = PortConfig->TaggedQueuing; // FALSE
    Descriptor->AcceleratedTransfer = TRUE;

    Descriptor->BusType = Adapter->Driver->BusType;
    Descriptor->BusMajorVersion = 2;
    Descriptor->BusMinorVersion = 0;

    *DescriptorLength = sizeof (*Descriptor);

    return STATUS_SUCCESS;
}


NTSTATUS
RaidAdapterDisable(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{

    NTSTATUS Status;
    
    //
    // REVIEW: do we need to call ScsiSetBootConfig? None of the adapters
    // in our source base use it.
    //

    Status = RaCallMiniportStopAdapter (&Adapter->Miniport);

    return Status;
}

NTSTATUS
RaidAdapterEnable(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    NYI ();

    return STATUS_UNSUCCESSFUL;
}
    
    
VOID
RaidAdapterRestartQueues(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    PLIST_ENTRY NextEntry;
    PRAID_UNIT_EXTENSION Unit;

    //
    // BUGBUG: This is broken. We need to acquire a lock to walk the
    // queue. We cannot do this at this point, though, becuase we
    // are within a DPC. Instead, for now, take advantage of the
    // fact that we do not remove things from the queue.
    //
    
//    ExAcquireResourceSharedLite (&Adapter->UnitList.Lock, TRUE);

    for ( NextEntry = Adapter->UnitList.List.Flink;
          NextEntry != &Adapter->UnitList.List;
          NextEntry = NextEntry->Flink ) {

        
        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        //
        // Take a reference to the object that PnP will release.
        //

        RaidUnitRestartQueue (Unit);
    }

//    ExReleaseResourceLite (&Adapter->UnitList.Lock);
}



VOID
RaidAdapterInsertUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    NTSTATUS Status;
    
    //
    // Acquire the Unit list lock in exclusive mode. This can only be
    // done when APCs are disabled, hence the call to KeEnterCriticalRegion.
    //
    
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite (&Adapter->UnitList.Lock, TRUE);


#if DBG

    //
    // In checked build, check that we are not adding the same unit to the
    // list a second time.
    //

    {
        LONG Comparison;
        PLIST_ENTRY NextEntry;
        PRAID_UNIT_EXTENSION TempUnit;
        
        for ( NextEntry = Adapter->UnitList.List.Flink;
              NextEntry != &Adapter->UnitList.List;
              NextEntry = NextEntry->Flink ) {
        
            TempUnit = CONTAINING_RECORD (NextEntry,
                                          RAID_UNIT_EXTENSION,
                                          NextUnit);

            Comparison = StorCompareScsiAddress (TempUnit->Address,
                                                 Unit->Address);
            ASSERT (Comparison != 0);
        }

    }
#endif  // DBG

    //
    // Insert the element.
    //
    
    InsertTailList (&Adapter->UnitList.List, &Unit->NextUnit);
    Adapter->UnitList.Count++;

    Status = RaidAdapterAddUnitToTable (Adapter, Unit);

    //
    // The only failure case is duplicate unit, which is a programming
    // error.
    //
    
    ASSERT (NT_SUCCESS (Status));

    //
    // Release the unit list lock.
    //
    
    ExReleaseResourceLite (&Adapter->UnitList.Lock);
    KeLeaveCriticalRegion ();
}



NTSTATUS
RaidAdapterAddUnitToTable(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KIRQL Irql;
    NTSTATUS Status;
    
    Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    Status = StorInsertDictionary (&Adapter->UnitList.Dictionary,
                                   &Unit->UnitTableLink);
    ASSERT (NT_SUCCESS (Status));
    KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);

    return Status;
}



VOID
RaidAdapterRemoveUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Remove the specified unit from the adapter's unit list.

Arguments:

    Adapter - Supplies the adapter whose unit needs to be removed.

    Unit - Supplies the unit object to remove.

Return Value:

    None.

--*/
{
    KIRQL Irql;
    NTSTATUS Status;
    
    PAGED_CODE ();

    //
    // Remove it from the table first.
    //
    
    Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);

    //
    // NB: Add function to remove from dictionary using the actual
    // STOR_DICTIONARY_ENTRY. This will improve speed (no need to
    // look up to remove).
    //
    
    Status = StorRemoveDictionary (&Adapter->UnitList.Dictionary,
                                   RaidAddressToKey (Unit->Address),
                                   NULL);
    ASSERT (NT_SUCCESS (Status));
    //
    // NB: ASSERT that returned entry is one we actually were trying to
    // remove.
    //

    KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);

    //
    // Next remove it from the list.
    //
    
    ExAcquireResourceExclusiveLite (&Adapter->UnitList.Lock, TRUE);
    RemoveEntryList (&Unit->NextUnit);
    Adapter->UnitList.Count--;
    ExReleaseResourceLite (&Adapter->UnitList.Lock);
}



PRAID_UNIT_EXTENSION
RaidAdapterFindUnitAtDirql(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Find the logical unit described by Address at a raised IRQL.

Arguments:

    Adapter - Adapter to search on.

    Address - Address to search for.

Return Value:

    Non-NULL - The logical unit identified by PathId, TargetId, Lun.

    NULL - If the logical unit was not found.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PSTOR_DICTIONARY_ENTRY Entry;

    ASSERT (KeGetCurrentIrql() == Adapter->InterruptIrql);

    Status = StorFindDictionary (&Adapter->UnitList.Dictionary,
                                 RaidAddressToKey (Address),
                                 &Entry);

    if (NT_SUCCESS (Status)) {
        Unit = CONTAINING_RECORD (Entry,
                                  RAID_UNIT_EXTENSION,
                                  UnitTableLink);
        ASSERT_UNIT (Unit);

    } else {
        Unit = NULL;
    }

    return Unit;
}



PRAID_UNIT_EXTENSION
RaidAdapterFindUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Find a specific logical unit from a given target address.

Arguments:

    Adapter - Adapter extension to search on.

    Address - RAID address of the logical unit we're searching for.

Return Value:

    Non-NULL - Address of logical unit with matching address.

    NULL - If no matching unit was found.

--*/
{
    BOOLEAN Acquired;
    KIRQL Irql;
    PRAID_UNIT_EXTENSION Unit;
    
    ASSERT_ADAPTER (Adapter);

    //
    // It is important to realize that in full duplex mode, we can be
    // called from the miniport with the Adapter's StartIo lock held.
    // Since we acquire the Interrupt lock after the StartIo lock,
    // we enforce the following lock heirarchy:
    //
    //      Adapter::StartIoLock < Adapter::Interrupt::SpinLock
    //
    // where the '<' operator should be read as preceeds.
    //

    if (KeGetCurrentIrql() < Adapter->InterruptIrql) {
        Acquired = TRUE;
        Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);
    }

    Unit = RaidAdapterFindUnitAtDirql (Adapter, Address);

    if (Acquired) {
        KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);
    }

    return Unit;
}

    
VOID
RaidpAdapterTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    This DPC routine is called when the timer expires. It notifies the
    miniport that the timer has expired.

Arguments:

    Dpc -

    DeviceObject -

    Context1 -

    Context2 -

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PHW_INTERRUPT HwTimerRequest;

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    HwTimerRequest = (PHW_INTERRUPT)InterlockedExchangePointer (
                                                (PVOID*)&Adapter->HwTimerRoutine,
                                                NULL);

    //
    // What should timer callbacks be synchronized on? We can synchronize
    // either on the interrupt (below) or the StartIo lock. The StartIo
    // lock probably makes a bit more sense.
    //
    
    if (HwTimerRequest) {
        KeSynchronizeExecution (Adapter->Interrupt,
                                HwTimerRequest,
                                &Adapter->Miniport.PrivateDeviceExt->HwDeviceExtension);

        if (Adapter->Flags.BusChanged) {
            Adapter->Flags.BusChanged = FALSE;
            IoInvalidateDeviceRelations (Adapter->LowerDeviceObject, BusRelations);
        }
    }
}

VOID
RaidPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;

    VERIFY_DISPATCH_LEVEL();

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    //
    // Timeout has expired: resume the gateway.
    //
    
    RaidAdapterResumeGateway (Adapter);

}


VOID
RaidAdapterLogIoError(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    Log an IO error to the system event log.

Arguments:

    Adapter - Adapter the error is for.

    PathId - PathId the error is for.

    TargetId - TargetId the error is for.

    ErrorCode - Specific error code representing this error.

    UniqueId - UniqueId of the error.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PRAID_IO_ERROR Error;
    
    VERIFY_DISPATCH_LEVEL();

    Error = IoAllocateErrorLogEntry (Adapter->DeviceObject,
                                     sizeof (RAID_IO_ERROR));

    if (Error == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return ;
    }
        
    Error->Packet.DumpDataSize = sizeof (RAID_IO_ERROR) -
        sizeof (IO_ERROR_LOG_PACKET);
    Error->Packet.SequenceNumber = 0;
//  Error->Packet.SequenceNumber = InterlockedIncrement (&Adapter->ErrorSequenceNumber);
    Error->Packet.MajorFunctionCode = IRP_MJ_SCSI;
    Error->Packet.RetryCount = 0;
    Error->Packet.UniqueErrorValue = UniqueId;
    Error->Packet.FinalStatus = STATUS_SUCCESS;
    Error->PathId = PathId;
    Error->TargetId = TargetId;
    Error->Lun = Lun;
    Error->ErrorCode = RaidScsiErrorToIoError (ErrorCode);

    IoWriteErrorLogEntry (&Error->Packet);
}


VOID
RaidAdapterLogIoErrorDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    Asychronously log an event to the system event log.

Arguments:

    Adapter - Adapter the error is for.

    PathId - PathId the error is for.

    TargetId - TargetId the error is for.

    ErrorCode - Specific error code representing this error.

    UniqueId - UniqueId of the error.

Return Value:

    None.

Environment:

    May be called from DIRQL. For IRQL < DIRQL use the synchronous
    RaidAdapterLogIoError call.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    //
    // It is unlikely that we will not be able to allocate a deferred
    // item, but if so, there's not much we can do.
    //
    
    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return ;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);
    Item->Type = RaidDeferredError;
    Item->PathId = PathId;
    Item->TargetId = TargetId;
    Item->Lun = Lun;
    Item->Error.ErrorCode = ErrorCode;
    Item->Error.UniqueId = UniqueId;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);
}
    

VOID
RaidAdapterRequestTimer(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Synchronously request a timer callback.

Arguments:

    Adapter - Supplies the adapter the timer callback is for.

    HwTimerRoutine - Supplies the miniport callback routine to
            be called when the timer expires.

    Timeout - Supplies the timeout IN SECONDS.
    
Return Value:

    None.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    LARGE_INTEGER LargeTimeout;

    VERIFY_DISPATCH_LEVEL();
    
    LargeTimeout.QuadPart = Timeout;
    LargeTimeout.QuadPart *= -10;
    Adapter->HwTimerRoutine = HwTimerRoutine;
    KeSetTimer (&Adapter->Timer,
                LargeTimeout,
                &Adapter->TimerDpc);
}


VOID
RaidAdapterRequestTimerDeferred(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PHW_INTERRUPT HwTimerRoutine,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Asynchronously request a timer callback.

Arguments:

    Adapter - Supplies the adapter the timer callback is for.

    HwTimerRoutine - Supplies the miniport callback routine to
            be called when the timer expires.

    Timeout - Supplies the timeout IN SECONDS.
    
Return Value:

    None.

Environment:

    May be called from DIRQL. For IRQL <= DISPATCH_LEVEL, use
    RaidAdapterRequestTimer instead.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    //
    // It is unlikely that the Item will be NULL, but can happen if we
    // generate too many deferred requests before the DPC routine is run. 
    //
    
    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return ;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);
    Item->Type = RaidDeferredTimerRequest;
    Item->Timer.HwTimerRoutine = HwTimerRoutine;
    Item->Timer.Timeout = Timeout;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);
}


VOID
RaidAdapterPauseGateway(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN ULONG Timeout
    )
{
    BOOLEAN Reset;
    LARGE_INTEGER LargeTimeout;
    
    VERIFY_DISPATCH_LEVEL();

    //
    // Convert the timeout to relative seconds.
    //
    
    LargeTimeout.QuadPart = (LONGLONG)Timeout * RELATIVE_TIMEOUT * SECONDS;

    Reset = KeSetTimer (&Adapter->PauseTimer,
                        LargeTimeout,
                        &Adapter->PauseTimerDpc);

    //
    // Only increment the pause count if it was not reset.
    //
    
    if (!Reset) {
        StorPauseIoGateway (&Adapter->Gateway);
    }

}

VOID
RaidAdapterResumeGateway(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    //
    // Cancel the timer.
    //
    
    KeCancelTimer (&Adapter->PauseTimer);

    //
    // Resume the gateway.
    //
    
    StorResumeIoGateway (&Adapter->Gateway);

    //
    // And restart all the IO queues.
    //
    
    RaidAdapterRestartQueues (Adapter);
}


VOID
RaidAdapterDeferredRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_HEADER Entry
    )
/*++

Routine Description:

    Deferred routine for the adapter deferred queue.

Arguments:

    DeviceObject - DeviceObject representing the the RAID adapter.

    Item -  Deferred item to process.

Return Value:

    None.

--*/
{
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;

    VERIFY_DISPATCH_LEVEL();
    ASSERT (Entry != NULL);
    ASSERT (IsAdapter (DeviceObject));

    Adapter = (PRAID_ADAPTER_EXTENSION) DeviceObject->DeviceExtension;
    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    switch (Item->Type) {

        case RaidDeferredTimerRequest:
            RaidAdapterRequestTimer (Adapter,
                                     Item->Timer.HwTimerRoutine,
                                     Item->Timer.Timeout);
            break;

        case RaidDeferredError:
            RaidAdapterLogIoError (Adapter,
//                                 Item->Error.Srb,
                                   Item->PathId,
                                   Item->TargetId,
                                   Item->Lun,
                                   Item->Error.ErrorCode,
                                   Item->Error.UniqueId);
            break;

        case RaidDeferredPause:
            RaidAdapterPauseGateway (Adapter, Item->Pause.Timeout);
            break;

        case RaidDeferredResume:
            RaidAdapterResumeGateway (Adapter);
            break;

#if 0
        case RaidDeferredPauseDevice:
            RaidAdapterPauseUnit (Adapter,
                                   Item->PauseDevice.Timeout,
                                   Item->PathId,
                                   Item->TargetId,
                                   Item->Lun);
            break;

        case RaidDeferredResumeDevice:
            RaidAdapterResumeUnit (Adapter,
                                   Item->PathId,
                                   Item->TargetId,
                                   Item->Lun);
            break;          
#endif            
        default:
            ASSERT (FALSE);
    }

    RaidFreeDeferredItem (&Adapter->DeferredQueue, &Item->Header);
}


VOID
RaidBackOffBusyGateway(
    IN PVOID Context,
    IN LONG OutstandingRequests,
    IN OUT PLONG HighWaterMark,
    IN OUT PLONG LowWaterMark
    )
{
    //
    // We do not enforce a high water mark. Instead, we fill the queue
    // until the adapter is busy, then drain to a low water mark.
    //
    
    *HighWaterMark = max ((6 * OutstandingRequests)/5, 10);
    *LowWaterMark = max ((2 * OutstandingRequests)/5, 5);
}



PSCSI_PASS_THROUGH
RaidValidatePassThroughRequest(
    IN PIRP Irp
    )
{
    PAGED_CODE();
    
    //
    // NYI: Implement the pass-through routine.
    //

    return (PSCSI_PASS_THROUGH)Irp->AssociatedIrp.SystemBuffer;
}



NTSTATUS
RaidBuildPassThroughSrb(
    PSCSI_PASS_THROUGH PassThrough,
    OUT PSCSI_REQUEST_BLOCK Srb
    )
{
    PVOID Buffer;
    ULONG SrbFlags;

    PAGED_CODE();

    if (PassThrough->DataTransferLength == 0) {
        Buffer = NULL;
        SrbFlags = 0;
    } else if (PassThrough->DataIn == SCSI_IOCTL_DATA_IN) {
        SrbFlags = SRB_FLAGS_DATA_IN;
        Buffer = ((PUCHAR)PassThrough + PassThrough->DataBufferOffset);
    } else if (PassThrough->DataIn == SCSI_IOCTL_DATA_OUT) {
        SrbFlags = SRB_FLAGS_DATA_OUT;
        Buffer = ((PUCHAR)PassThrough + PassThrough->DataBufferOffset);
    } else {
        SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
        Buffer = ((PUCHAR)PassThrough + PassThrough->DataBufferOffset);
    }
        
    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    Srb->SrbStatus = SRB_STATUS_PENDING;
    Srb->PathId = PassThrough->PathId;
    Srb->TargetId = PassThrough->TargetId;
    Srb->Lun = PassThrough->Lun;
    Srb->CdbLength = PassThrough->CdbLength;
    Srb->DataTransferLength =
    Srb->TimeOutValue = PassThrough->TimeOutValue;
    Srb->DataBuffer = Buffer;
    Srb->DataTransferLength = PassThrough->DataTransferLength;
    Srb->SrbFlags = SrbFlags | SRB_FLAGS_NO_QUEUE_FREEZE;

    //NYI: Sense info

    Srb->SenseInfoBuffer = NULL;
    Srb->SenseInfoBufferLength = 0;
    
    RtlCopyMemory (&Srb->Cdb, &PassThrough->Cdb, PassThrough->CdbLength);


    return STATUS_SUCCESS;
}



NTSTATUS
RaidAdapterPassThrough(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PIRP PassThroughIrp
    )
/*++

Routine Description:

    Handle an SCSI Pass through IOCTL.

Arguments:

    Adapter - Supplies the adapter the IRP was issued to.

    PassThroughIrp - Supplies the irp to process.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_PASS_THROUGH PassThrough;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    SCSI_REQUEST_BLOCK Srb;
    RAID_ADDRESS Address;

    PAGED_CODE();

REVIEW();

    Irp = NULL;
    
    PassThrough = RaidValidatePassThroughRequest (PassThroughIrp);
    if (PassThrough == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto done;
    }

    Status = RaidBuildPassThroughSrb (PassThrough, &Srb);
    if (NT_SUCCESS (Status)) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Address.PathId = PassThrough->PathId;
    Address.TargetId = PassThrough->TargetId;
    Address.Lun = PassThrough->Lun;
    
    Unit = RaidAdapterFindUnit (Adapter, Address);

    if (Unit == NULL) {
        Status = STATUS_NO_SUCH_DEVICE;
        goto done;
    }

    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           &Srb,
                                           &Event,
                                           &IoStatus);

    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }
    
    Status = RaidUnitSubmitRequest (Unit, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }


    //
    // NYI: Marshal back data
    //

done:

    if (Irp) {
        IoFreeIrp (Irp);
        Irp = NULL;
    }
    
    return RaidCompleteRequest (PassThroughIrp, IO_NO_INCREMENT, Status);
}




PVOID
INLINE
RaidAdapterGetHwDeviceExtension(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    return &Adapter->Miniport.PrivateDeviceExt->HwDeviceExtension;
}



NTSTATUS
RaidAdapterReset(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN UCHAR PathId
    )
{
    ULONG BusCount;
    KIRQL Irql;

    //
    // For reset, we acquire the interrupt spinlock, not just the StartIo
    // lock.
    //

    Irql = KeAcquireInterruptSpinLock (Adapter->Interrupt);

    BusCount = RiGetNumberOfBuses (Adapter);
    RaCallMiniportResetBus (&Adapter->Miniport, PathId);

    KeReleaseInterruptSpinLock (Adapter->Interrupt, Irql);

    //
    // Pause the device for RESET_TIME.
    //
    
    StorPortPause (RaidAdapterGetHwDeviceExtension (Adapter),
                   RAID_BUS_RESET_TIME);
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\bus.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    Wrapper for BUS_INTERFACE_STANDARD bus interface.

Author:

    Matthew D Hendel (math) 25-Apr-2000

Revision History:

--*/



#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateBus)
#pragma alloc_text(PAGE, RaDeleteBus)
#pragma alloc_text(PAGE, RaInitializeBus)
#pragma alloc_text(PAGE, RaGetBusData)
#pragma alloc_text(PAGE, RaSetBusData)
#endif// ALLOC_PRAGMA


//
// Creation and Destruction
//

VOID
RaCreateBus(
    IN PRAID_BUS_INTERFACE Bus
    )
{
    PAGED_CODE ();
    Bus->Initialized = FALSE;
    RtlZeroMemory (&Bus->Interface, sizeof (Bus->Interface));
}


VOID
RaDeleteBus(
    IN PRAID_BUS_INTERFACE Bus
    )
{
    PAGED_CODE ();
    if (Bus->Initialized) {
        Bus->Interface.InterfaceDereference (Bus->Interface.Context);
        Bus->Initialized = FALSE;
        RtlZeroMemory (&Bus->Interface, sizeof (Bus->Interface));
    }
}
    

NTSTATUS
RaInitializeBus(
    IN PRAID_BUS_INTERFACE Bus,
    IN PDEVICE_OBJECT LowerDeviceObject
    )
{
    NTSTATUS Status;
    ASSERT (Bus != NULL);
    ASSERT (LowerDeviceObject != NULL);
    PAGED_CODE ();
 
    Status = RaQueryInterface (LowerDeviceObject,
                               &GUID_BUS_INTERFACE_STANDARD,
                               sizeof (Bus->Interface),
                               1,
                               (PINTERFACE) &Bus->Interface,
                               NULL);

    if (!NT_SUCCESS (Status)) {
        ASSERT (FALSE);
        Bus->Initialized = FALSE;
    } else {
        Bus->Initialized = TRUE;
    }

    return Status;
}

//
// Other operations
//

ULONG
RaGetBusData(
    IN PRAID_BUS_INTERFACE Bus,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    NTSTATUS Status;

    PAGED_CODE ();
    ASSERT (Bus->Initialized);
    
    Status = Bus->Interface.GetBusData (
                    Bus->Interface.Context,
                    DataType,
                    Buffer,
                    Offset,
                    Length
                    );

    return Status;
}


ULONG
RaSetBusData(
    IN PRAID_BUS_INTERFACE Bus,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    NTSTATUS Status;

    PAGED_CODE ();
    ASSERT (Bus->Initialized);
    
    Status = Bus->Interface.SetBusData (
                    Bus->Interface.Context,
                    DataType,
                    Buffer,
                    Offset,
                    Length
                    );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\common.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    common.h
    
Abstract:

    Common definitions for both Adapter (FDO) and Unit (PDO) objects.
Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef enum _RAID_OBJECT_TYPE {
    RaidUnknownObject   = -1,
    RaidAdapterObject   = 0,
    RaidUnitObject      = 1,
    RaidDriverObject    = 2
} RAID_OBJECT_TYPE;

typedef enum _DEVICE_STATE {
    DeviceStateNotPresent       = 0,
    DeviceStateWorking          = 1,
    DeviceStateStopped          = 2,
    DeviceStatePendingStop      = 3,
    DeviceStatePendingRemove    = 4,
    DeviceStateSurpriseRemoval  = 5,
    DeviceStateRemoved          = 6
} DEVICE_STATE;

//
// The common extension is the portion of the extension that is common to
// the RAID_DRIVER_EXTENSION, RAID_ADAPTER_EXTENSION and RAID_UNIT_EXTENSION.
//

typedef struct _RAID_COMMON_EXTENSION {
    RAID_OBJECT_TYPE ObjectType;
} RAID_COMMON_EXTENSION, *PRAID_COMMON_EXTENSION;


RAID_OBJECT_TYPE
RaGetObjectType(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
IsAdapter(
    IN PVOID Extension
    );

BOOLEAN
IsDriver(
    IN PVOID Extension
    );
    
BOOLEAN
IsUnit(
    IN PVOID Extension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\busenum.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    BusEnum.h

Abstract:

    Declaration of bus enumerator class.

Author:

    Matthew D Hendel (math) 21-Feb-2001

Revision History:

--*/


#pragma once


//
// Resources maintained while enumerating the bus. We carry resources
// through the enumeration to avoid repeadedly allocating then freeing
// the same resources over and over again.
//

typedef struct _BUS_ENUM_RESOURCES {
    PIRP Irp;
    PMDL Mdl;
    PSCSI_REQUEST_BLOCK Srb;
    PVOID SenseInfo;
    PVOID DataBuffer;
    ULONG DataBufferLength;
    PRAID_UNIT_EXTENSION Unit;
} BUS_ENUM_RESOURCES, *PBUS_ENUM_RESOURCES;



typedef enum _BUS_ENUM_UNIT_STATE {
    EnumUnmatchedUnit,          // Not yet matched
    EnumNewUnit,                // No matching entry in the enum list
    EnumMatchedUnit             // Found matching entry in enum list
} BUS_ENUM_UNIT_STATE;


//
// State information for the enumerator itself.
//

typedef struct _BUS_ENUMERATOR {

    //
    // Pointer to the adapter extension this
    
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Resources used for enumeration. These change over time.
    //
    
    BUS_ENUM_RESOURCES Resources;

    //
    // List of new adapters found during this enumeration. These are
    // adapters that have no matching entries on any other per-adapter list.
    //

    LIST_ENTRY EnumList;

} BUS_ENUMERATOR, *PBUS_ENUMERATOR;



//
// The RAID_BC_UNIT contains the per-unit state we need to maintain while
// eunmerating the bus.
//

typedef struct _BUS_ENUM_UNIT {

    //
    // Whether the device supports device Ids.
    //
    
    BOOLEAN SupportsDeviceId;

    //
    // Whether the device supports serial numbers.
    //
    
    BOOLEAN SupportsSerialNumber;

    //
    // SCSI/RAID address for the device.
    //
    
    RAID_ADDRESS Address;

    //
    // If this unit cooresponds ot an already enumerated unit, this 
    // this field points to the already existing unit. Otherwise, it's
    // NULL.
    //

    PRAID_UNIT_EXTENSION Unit;

    //
    // Link to next entry in the entry list.
    //
    
    LIST_ENTRY EnumLink;

    //
    // Identity of this unit.
    //
    
    STOR_SCSI_IDENTITY Identity;

    //
    // DeviceId page for the unit.
    // NB: We can probably remove this.
    //
    
    PVPD_IDENTIFICATION_PAGE DeviceId;

    //
    // Current state for this unit.
    //
    
    BUS_ENUM_UNIT_STATE State;

    //
    // Whether this is a new unit or not.
    //
    
    BOOLEAN NewUnit;

    //
    // Whether any data was found at the unit or not.
    //
    
    BOOLEAN Found;
    
} BUS_ENUM_UNIT, *PBUS_ENUM_UNIT;



VOID
RaidCreateBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator
    );

NTSTATUS
RaidInitializeBusEnumerator(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_ADAPTER_EXTENSION Adapter
    );

VOID
RaidDeleteBusEnumerator(
    IN PBUS_ENUMERATOR Enum
    );

VOID
RaidBusEnumeratorAddUnit(
    IN PBUS_ENUMERATOR Enumerator,
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidBusEnumeratorVisitUnit(
    IN PVOID Context,
    IN RAID_ADDRESS Address
    );

LOGICAL
RaidBusEnumeratorProcessModifiedNodes(
    IN PBUS_ENUMERATOR Enumerator
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debuging functions for RAIDPORT driver.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/

#pragma once

#if !DBG

#define ASSERT_PDO(Pdo)
#define ASSERT_UNIT(Unit)
#define ASSERT_ADAPTER(Adapter)
#define ASSERT_XRB(Xrb)

#else // DBG

#define VERIFY(_x) ASSERT(_x)

#define ASSERT_PDO(DeviceObject)\
    ASSERT((DeviceObject)->DeviceObjectExtension->DeviceNode == NULL)

#define ASSERT_UNIT(Unit)\
    ASSERT(Unit->ObjectType == RaidUnitObject)

#define ASSERT_ADAPTER(Adapter)\
    ASSERT(Adapter->ObjectType == RaidAdapterObject)

#define ASSERT_XRB(Xrb)\
    ASSERT ((((PEXTENDED_REQUEST_BLOCK)Xrb)->Signature == XRB_SIGNATURE));
    
VOID
DebugPrintInquiry(
    IN PINQUIRYDATA InquiryData,
    IN SIZE_T InquiryDataSize
    );

VOID
DebugPrintSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    );

#endif // DBG

//
// Allocation tags for checked build.
//

#define INQUIRY_TAG             ('21aR')    // Ra12
#define MAPPED_ADDRESS_TAG      ('MAaR')    // RaAM
#define CRASHDUMP_TAG           ('DCaR')    // RaCD
#define ID_TAG                  ('IDaR')    // RaDI
#define DEFERRED_ITEM_TAG       ('fDaR')    // RaDf
#define STRING_TAG              ('SDaR')    // RaDS
#define DEVICE_RELATIONS_TAG    ('RDaR')    // RaDR
#define HWINIT_TAG              ('IHaR')    // RaHI
#define MINIPORT_EXT_TAG        ('EMaR')    // RaME
#define PORTCFG_TAG             ('CPaR')    // RaPC
#define PORT_DATA_TAG           ('DPaR')    // RaPD
#define PENDING_LIST_TAG        ('LPaR')    // RaPL
#define QUERY_TEXT_TAG          ('TQaR')    // RaQT
#define REMLOCK_TAG             ('mRaR')    // RaRm
#define RESOURCE_LIST_TAG       ('LRaR')    // RaRL
#define SRB_TAG                 ('rSaR')    // RaSr
#define SRB_EXTENSION_TAG       ('ESaR')    // RaSE
#define TAG_MAP_TAG             ('MTaR')    // RaTM
#define XRB_TAG                 ('rXaR')    // RaXr
#define UNIT_EXT_TAG            ('EUaR')    // RaUE
#define SENSE_TAG               ('NSaR')    // RaSN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\deferred.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    deferred.h

Abstract:

    Definition of the RAID deferred queue class.

Author:

    Matthew D Hendel (math) 26-Oct-2000

Revision History:

--*/

#pragma once

struct _PRAID_DEFERRED_HEADER;

typedef
VOID
(*PRAID_PROCESS_DEFERRED_ITEM_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _RAID_DEFERRED_HEADER* Item
    );

typedef struct _RAID_DEFERRED_QUEUE {
    KDPC Dpc;
    ULONG Depth;
    ULONG ItemSize;
    SLIST_HEADER FreeList;
    SLIST_HEADER RunningList;
    PRAID_PROCESS_DEFERRED_ITEM_ROUTINE ProcessDeferredItem;
} RAID_DEFERRED_QUEUE, *PRAID_DEFERRED_QUEUE;


typedef struct _RAID_DEFERRED_HEADER {
    SINGLE_LIST_ENTRY Link;
} RAID_DEFERRED_HEADER, *PRAID_DEFERRED_HEADER;


VOID
RaidCreateDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    );

NTSTATUS
RaidInitializeDeferredQueue(
    IN OUT PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Depth,
    IN ULONG ItemSize,
    IN PRAID_PROCESS_DEFERRED_ITEM_ROUTINE ProcessDeferredItem
    );

VOID
RaidDeleteDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    );
    
NTSTATUS
RAidAdjustDeferredQueueDepth(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN ULONG Depth
    );
    
PVOID
RaidAllocateDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue
    );
    
VOID
RaidFreeDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    );
    
VOID
RaidQueueDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    );
    
VOID
RaidDeferredQueueDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PVOID Context2
    );

VOID
RaidDeferredQueueDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PVOID Context2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	debug.c

Abstract:

	Debugging routines for RAIDPORT driver.

Author:

	Matthew D Hendel (math) 29-Apr-2000

Revision History:

--*/

#include "precomp.h"

#if DBG

VOID
DebugPrintInquiry(
	IN PINQUIRYDATA InquiryData,
	IN SIZE_T InquiryDataSize
	)
{

	PCHAR DeviceType;
	PCHAR Qualifier;

	switch (InquiryData->DeviceType) {
		case DIRECT_ACCESS_DEVICE: DeviceType = "disk"; break;
		case SEQUENTIAL_ACCESS_DEVICE: DeviceType = "tape"; break;
		case PRINTER_DEVICE: DeviceType = "printer"; break;
		case PROCESSOR_DEVICE: DeviceType = "processor"; break;
		case WRITE_ONCE_READ_MULTIPLE_DEVICE: DeviceType = "worm"; break;
		case READ_ONLY_DIRECT_ACCESS_DEVICE: DeviceType = "cdrom"; break;
		case SCANNER_DEVICE: DeviceType = "scanner"; break;
		case OPTICAL_DEVICE: DeviceType = "optical disk"; break;
		case MEDIUM_CHANGER: DeviceType = "jukebox"; break;
		case COMMUNICATION_DEVICE: DeviceType = "network"; break;
		case LOGICAL_UNIT_NOT_PRESENT_DEVICE: DeviceType = "lux"; break;
		default: DeviceType = "unknown";
	}

	switch (InquiryData->DeviceTypeQualifier) {
		case DEVICE_QUALIFIER_ACTIVE: Qualifier = "active"; break;
		case DEVICE_QUALIFIER_NOT_ACTIVE: Qualifier = "not active"; break;
		case DEVICE_QUALIFIER_NOT_SUPPORTED: Qualifier = "not supported"; break;
		default: Qualifier = "unknown";
	}

	DebugTrace (("%8.8s %16.16s %4.4s; %s %s\n",
				  InquiryData->VendorId,
				  InquiryData->ProductId,
				  InquiryData->ProductRevisionLevel,
				  DeviceType,
				  Qualifier));
}


PCSTR SrbFunctionName [] = {
	"EXECUTE_SCSI",
	"CLAIM_DEVICE",
	"IO_CONTROL",
	"RECEIVE_EVENT",
	"RELEASE_QUEUE",
	"ATTACH_DEVICE",
	"RELEASE_DEVICE",
	"SHUTDOWN",
	"FLUSH",
	"ABORT_COMMAND",
	"RELEASE_RECOVER",
	"RESET_BUS",
	"RESET_DEVICE",
	"TERMINATE_IO",
	"FLUSH_QUEUE",
	"REMOVE_DEVICE",
	"WMI",
	"LOCK_QUEUE",
	"UNLOCK_QUEUE"
};

PCSTR
DebugSrbFunction(
	IN UCHAR Function
	)
{
	if (Function < ARRAY_COUNT (SrbFunctionName)) {
		return SrbFunctionName [Function];
	} else {
		return "Unknown Srb Function";
	}
}


VOID
DebugPrintSrb(
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	DebugTrace (("SRB %p %s\n",
					Srb,
					DebugSrbFunction (Srb->Function)));
	DebugTrace (("SRB: Target %2.2x %2.2x %2.2x, Q %2.2x\n",
					(LONG)Srb->PathId,
				    (LONG)Srb->TargetId,
					(LONG)Srb->Lun,
					(LONG)Srb->QueueTag));
	DebugTrace (("SRB: Data %p Len %d\n",
					Srb->DataBuffer,
					Srb->DataTransferLength));
	DebugTrace (("SRB: Sense %p Len %d\n",
					Srb->SenseInfoBuffer,
					Srb->SenseInfoBufferLength));
	DebugTrace (("SRB: Ext %p\n",Srb->SrbExtension));

	if (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI &&
		Srb->CdbLength >= 1) {
		DebugTrace (("SRB: ScsiOp %2.2x\n", (LONG)Srb->Cdb[0]));
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\dma.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	dma.c

Abstract:

	Implementation of RAIDPORT's idea of a DMA object.

Author:

	Matthew D Hendel (math) 01-May-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidCreateDma)
#pragma alloc_text(PAGE, RaidInitializeDma)
#pragma alloc_text(PAGE, RaidIsDmaInitialized)
#pragma alloc_text(PAGE, RaidDeleteDma)
#endif // ALLOC_PRAGMA


VOID
RaidCreateDma(
	OUT PRAID_DMA_ADAPTER Dma
	)
/*++

Routine Description:

	Create an object representing a dma adapter and initialize it to a
	null state.

Arguments:

	Dma - Pointer to the dma object to initialize.

Return Value:

	None.

--*/
{
	PAGED_CODE ();
	RtlZeroMemory (Dma, sizeof (*Dma));
}


NTSTATUS
RaidInitializeDma(
	IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
    )
/*++

Routine Description:

	Initialize a dma object from information in the port configuration.x

Arguments:

	Dma - Pointer to the dma object to initialize.

	LowerDeviceObject - The lower device object in the stack.

	PortConfiguration - Pointer to a port configuration object that will
			be used to initialize the dma adapter.
	
Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_DESCRIPTION DeviceDescription;

    PAGED_CODE ();
	ASSERT (LowerDeviceObject != NULL);
    ASSERT (PortConfiguration != NULL);
	
	ASSERT (Dma->DmaAdapter == NULL);
	
    RtlZeroMemory (&DeviceDescription, sizeof (DeviceDescription));
    DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    DeviceDescription.DmaChannel = PortConfiguration->DmaChannel;
    DeviceDescription.InterfaceType = PortConfiguration->AdapterInterfaceType;
    DeviceDescription.BusNumber = PortConfiguration->SystemIoBusNumber;
    DeviceDescription.DmaWidth = PortConfiguration->DmaWidth;
    DeviceDescription.DmaSpeed = PortConfiguration->DmaSpeed;
    DeviceDescription.ScatterGather = PortConfiguration->ScatterGather;
    DeviceDescription.Master = PortConfiguration->Master;
    DeviceDescription.DmaPort = PortConfiguration->DmaPort;
    DeviceDescription.Dma32BitAddresses = PortConfiguration->Dma32BitAddresses;
    DeviceDescription.AutoInitialize = FALSE;
    DeviceDescription.DemandMode = PortConfiguration->DemandMode;
    DeviceDescription.MaximumLength = PortConfiguration->MaximumTransferLength;

    Dma->DmaAdapter = IoGetDmaAdapter (LowerDeviceObject,
									   &DeviceDescription,
									   &Dma->NumberOfMapRegisters);

    if (Dma->DmaAdapter == NULL) {
        ASSERT (FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


BOOLEAN
RaidIsDmaInitialized(
	IN PRAID_DMA_ADAPTER Dma
	)
/*++

Routine Description:

	Test whether the dma adapter object has been initialized.

Arguments:

	Dma - Pointer to the dma object to test.

Return Value:

	TRUE - If the dma adapter has been initialized

	FALSE - If it has not.

--*/
{
	PAGED_CODE ();
	ASSERT (Dma != NULL);

	return (Dma->DmaAdapter != NULL);
}



VOID
RaidDeleteDma(
	IN PRAID_DMA_ADAPTER Dma
    )
/*++

Routine Description:

	Delete a dma adapter object and deallocate any resources associated
	with it.

Arguments:

	Dma - Pointer to the dma adapter to delete.

Return Value:

	None.

--*/
{
    PAGED_CODE ();
    
	if (Dma->DmaAdapter) {
		Dma->DmaAdapter->DmaOperations->PutDmaAdapter (Dma->DmaAdapter);
		RtlZeroMemory (Dma, sizeof (*Dma));
	}
}


NTSTATUS
RaidDmaAllocateCommonBuffer(
	IN PRAID_DMA_ADAPTER Dma,
	IN ULONG NumberOfBytes,
	IN BOOLEAN CacheEnabled,
	OUT PRAID_MEMORY_REGION Region
	)
/*++

Routine Description:

	Allocate a common buffer to be shared between the processor and
	the device.

Arguments:

	Dma - Dma adapter that will share the allocated common memory.

	NumberOfBytes - Number of bytes to allocate.

	CacheEnabled - Whether caching will be enabled for this memory.

	Region - Pointer to an initialized RAID_REGION object where the
			memory region will be stored.
	
Return Value:

    NTSTATUS code.

--*/
{
	NTSTATUS Status;
	PVOID Buffer;
	PHYSICAL_ADDRESS PhysicalAddress;
	PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;

	ASSERT (Dma != NULL);
	ASSERT (Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer != NULL);
	
	Buffer = Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer(
					Dma->DmaAdapter,
					NumberOfBytes,
					&PhysicalAddress,
					CacheEnabled);

	if (Buffer == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
	} else {

		//
		// Initialize the region with the proper information.
		//
		
		RaidInitializeRegion (Region,
							  Buffer,
							  PhysicalAddress,
							  NumberOfBytes);
		Status = STATUS_SUCCESS;
	}

	return Status;
}

VOID
RaidDmaFreeCommonBuffer(
	IN PRAID_DMA_ADAPTER Dma,
	IN PRAID_MEMORY_REGION Region,
	IN BOOLEAN CacheEnabled
	)
{
	ASSERT (Dma != NULL);
	ASSERT (Dma->DmaAdapter->DmaOperations->FreeCommonBuffer != NULL);

	Dma->DmaAdapter->DmaOperations->FreeCommonBuffer (
			Dma->DmaAdapter,
			RaidRegionGetSize (Region),
			RaidRegionGetPhysicalBase (Region),
			RaidRegionGetVirtualBase (Region),
			CacheEnabled);
}


NTSTATUS
RaidDmaBuildScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
	IN PDEVICE_OBJECT DeviceObject,
	IN PMDL Mdl,
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN PDRIVER_LIST_CONTROL ExecutionRoutine,
	IN PVOID Context,
	IN BOOLEAN WriteToDevice,
	IN PVOID ScatterGatherBuffer,
	IN ULONG ScatterGatherBufferLength
	)
/*++

Routine Description:

	This routine should be used instead of GetScatterGatherList.
	GetScatterGatherList does a pool allocation to allocate the SG list.
	This routine, in contrast, takes a buffer parameter which is to be used
	for the SG list.

Arguments:

	See BuildScatterGatherList in the DDK (when available) or
	HalBuildScatterGatherList.

Return Value:

    NTSTATUS code.

--*/
{
	NTSTATUS Status;

	ASSERT (Dma != NULL);
	ASSERT (Dma->DmaAdapter->DmaOperations->BuildScatterGatherList != NULL);

	Status = Dma->DmaAdapter->DmaOperations->BuildScatterGatherList(
					Dma->DmaAdapter,
					DeviceObject,
					Mdl,
					CurrentVa,
					Length,
					ExecutionRoutine,
					Context,
					WriteToDevice,
					ScatterGatherBuffer,
					ScatterGatherBufferLength);

	return Status;
}


NTSTATUS
RaidDmaGetScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT DeviceObject,
	IN PMDL Mdl,
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN PDRIVER_LIST_CONTROL ExecutionRoutine,
	IN PVOID Context,
	IN BOOLEAN WriteToDevice
	)
{
	NTSTATUS Status;

	ASSERT (Dma != NULL);
	ASSERT (Dma->DmaAdapter->DmaOperations->GetScatterGatherList != NULL);

	Status = Dma->DmaAdapter->DmaOperations->GetScatterGatherList(
					Dma->DmaAdapter,
					DeviceObject,
					Mdl,
					CurrentVa,
					Length,
					ExecutionRoutine,
					Context,
					WriteToDevice);

	return Status;
}


VOID
RaidDmaPutScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
	IN PSCATTER_GATHER_LIST ScatterGatherList,
	IN BOOLEAN WriteToDevice
	)
{
	ASSERT (Dma != NULL);
	ASSERT (Dma->DmaAdapter->DmaOperations->PutScatterGatherList != NULL);

	Dma->DmaAdapter->DmaOperations->PutScatterGatherList(
			Dma->DmaAdapter,
			ScatterGatherList,
			WriteToDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\deferred.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    deferred.c

Abstract:

    Implementation of the RAID deferred queue class.

Author:

    Matthew D Hendel (math) 26-Oct-2000

Revision History:

--*/

#include "precomp.h"

//
// The deferred queue is used to queue non-IO related events.
//

VOID
RaidCreateDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    )
/*++

Routine Description:

    Create an empty deferred queue. After a deferred queue has been created
    it can be delete by calling RaidDeleteDeferedQueue.

Arguments:

    Queue - Deferred queue to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    RtlZeroMemory (Queue, sizeof (RAID_DEFERRED_QUEUE));
    InitializeSListHead (&Queue->FreeList);
    InitializeSListHead (&Queue->RunningList);
}


NTSTATUS
RaidInitializeDeferredQueue(
    IN OUT PRAID_DEFERRED_QUEUE Queue,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Depth,
    IN ULONG ItemSize,
    IN PRAID_PROCESS_DEFERRED_ITEM_ROUTINE ProcessDeferredItem
    )

/*++

Routine Description:

    Initialize a deferred queue.

Arguments:

    Queue - Supplies the deferred queue to initialize.

    DeviceObject - Supplies the device object the deferred queue is
            created on. Since the deferred queue is created using a
            device queue, the supplied device object is also the
            device object we will create the DPC on.

    Depth - Supplies the depth of the deferred queue.

    ItemSize - Supplies the size of each element on the deferred queue.

    ProcessDeferredItem - Supplies the routine that will be called when
            a deferred item is ready to be handled.

Return Value:

    NTSTATUS code.

--*/

{
    ULONG i;
    PRAID_DEFERRED_HEADER Item;
    
    PAGED_CODE();

    if (ItemSize < sizeof (RAID_DEFERRED_HEADER)) {
        return STATUS_INVALID_PARAMETER_4;
    }
        
    //
    // Initialize the queue.
    //
    
    Queue->Depth = Depth;
    Queue->ProcessDeferredItem = ProcessDeferredItem;
    Queue->ItemSize = ItemSize;
    KeInitializeDpc (&Queue->Dpc, RaidDeferredQueueDpcRoutine, DeviceObject);

    //
    // And allocated entries.
    //
    
    for (i = 0; i < Depth; i++) {
        Item = RaidAllocatePool (NonPagedPool,
                                 Queue->ItemSize,
                                 DEFERRED_ITEM_TAG,
                                 DeviceObject);

        if (Item == NULL) {
            break;
        }
        
        InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);
    }

    return STATUS_SUCCESS;
}


VOID
RaidDeleteDeferredQueue(
    IN PRAID_DEFERRED_QUEUE Queue
    )
/*++

Routine Description:

    Delete the deferred queue.

Arguments:

    Queue - Deferred queue to delete.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY Entry;
    PRAID_DEFERRED_HEADER Item;
    
    PAGED_CODE();

#if DBG
    
    Entry = InterlockedPopEntrySList (&Queue->RunningList);
    ASSERT (Entry == NULL);

#endif

    for (Entry = InterlockedPopEntrySList (&Queue->FreeList);
         Entry != NULL;
         Entry = InterlockedPopEntrySList (&Queue->FreeList)) {

        Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_HEADER, Link);
        RaidFreePool (Item, DEFERRED_ITEM_TAG);
    }

    DbgFillMemory (Queue,
                   sizeof (RAID_DEFERRED_QUEUE),
                   DBG_DEALLOCATED_FILL);
}
    

NTSTATUS
RaidAdjustDeferredQueueDepth(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN ULONG Depth
    )
/*++

Routine Description:

    Grow or shrink the depth of the deferred queue.

Arguments:

    Queue - Supplies the queue whose depth should be changed.

    Depth - Supplies the new depth.

Return Value:

    NTSTATUS code.

Bugs:

    We ignore shrink requests for now.

--*/
{
    ULONG i;
    PRAID_DEFERRED_HEADER Item;

    PAGED_CODE ();

    if (Depth > Queue->Depth) {

        for (i = 0; i < Depth - Queue->Depth; i++) {
            Item = RaidAllocatePool (NonPagedPool,
                                     Queue->ItemSize,
                                     DEFERRED_ITEM_TAG,
                                     (PDEVICE_OBJECT)Queue->Dpc.DeferredContext);

            InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);

            if (Item == NULL) {
                return STATUS_NO_MEMORY;
            }
        }
        
    } else {
        //
        // Reduction of the Queue depth is NYI.
        //
    }

    return STATUS_SUCCESS;
}
        
    
PVOID
RaidAllocateDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue
    )
/*++

Routine Description:

    Allocate a deferred item.

Arguments:

    Queue - Supplies the deferred queue to allocate from.

Return Value:

    If the return value is non-NULL, it represents a pointer a deferred
    item buffer.

    If the return value is NULL, we couldn't allocate a deferred item.

--*/
{
    PSINGLE_LIST_ENTRY Entry;
    PRAID_DEFERRED_HEADER Item;

    Entry = InterlockedPopEntrySList (&Queue->FreeList);
    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_HEADER, Link);

    return Item;
}

VOID
RaidFreeDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    )
/*++

Routine Description:

    Free a deferred queue item previously allocated by
    RaidAllocateDeferredItem.

Arguments:

    Queue - Supplies the deferred queue to free to.

    Item - Supplies the item to free.

Return Value:

    None.

--*/
{
    InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);
}
    

VOID
RaidQueueDeferredItem(
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PRAID_DEFERRED_HEADER Item
    )
/*++

Routine Description:

    Queue a deferred item to the deferred queue.

Arguments:

    Queue - Supplies the deferred queue to enqueue the item to.

    Item - Supplies the item to be enqueued.

Return Value:

    None.

--*/
{
    InterlockedPushEntrySList (&Queue->RunningList, &Item->Link);
    KeInsertQueueDpc (&Queue->Dpc, Queue, NULL);
}


VOID
RaidDeferredQueueDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PRAID_DEFERRED_QUEUE Queue,
    IN PVOID Context2
    )
/*++

Routine Description:

    Deferred queue DPC routine.

Arguments:

    Dpc - Dpc that is executing.

    DeviceObject - DeviceObject that the DPC is for.

    Queue - Deferred queue this DPC is for.

    Context2 - Not used.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY Entry;
    PRAID_DEFERRED_HEADER Item;

    UNREFERENCED_PARAMETER (Dpc);

    VERIFY_DISPATCH_LEVEL();
    ASSERT (Queue != NULL);
    ASSERT (Context2 == NULL);
    
    while (Entry = InterlockedPopEntrySList (&Queue->RunningList)) {

        Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_HEADER, Link);
        Queue->ProcessDeferredItem (DeviceObject, Item);
        InterlockedPushEntrySList (&Queue->FreeList, &Item->Link);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\dma.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	dma.h

Abstract:

	Declaration of raidport's notion of a DMA object.

Author:

	Matthew D Hendel (math) 01-May-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_DMA_ADAPTER {
	PDMA_ADAPTER DmaAdapter;
	ULONG NumberOfMapRegisters;
	PVOID MapRegisterBase;
} RAID_DMA_ADAPTER, *PRAID_DMA_ADAPTER;


//
// Initialization and destruction.
//

VOID
RaidCreateDma(
	OUT PRAID_DMA_ADAPTER Dma
	);

NTSTATUS
RaidInitializeDma(
	IN PRAID_DMA_ADAPTER Dma,
	IN PDEVICE_OBJECT LowerDeviceObject,
	IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
	);

VOID
RaidDeleteDma(
	IN PRAID_DMA_ADAPTER Dma
	);

//
// Operations on the DMA object.
//

BOOLEAN
RaidIsDmaInitialized(
	IN PRAID_DMA_ADAPTER Dma
	);

NTSTATUS
RaidDmaAllocateCommonBuffer(
	IN PRAID_DMA_ADAPTER Dma,
	IN ULONG NumberOfBytes,
	IN BOOLEAN Cached,
	OUT PRAID_MEMORY_REGION Region
	);

VOID
RaidDmaFreeCommonBuffer(
	IN PRAID_DMA_ADAPTER Dma,
	IN PRAID_MEMORY_REGION Region,
	IN BOOLEAN CacheEnabled
	);

	
NTSTATUS
RaidDmaGetScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
    IN PDEVICE_OBJECT DeviceObject,
	IN PMDL Mdl,
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN PDRIVER_LIST_CONTROL ExecutionRoutine,
	IN PVOID Context,
	IN BOOLEAN WriteToDevice
	);
				  
NTSTATUS
RaidDmaBuildScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
	IN PDEVICE_OBJECT DeviceObject,
	IN PMDL Mdl,
	IN PVOID CurrentVa,
	IN ULONG Length,
	IN PDRIVER_LIST_CONTROL ExecutionRoutine,
	IN PVOID Context,
	IN BOOLEAN WriteToDevice,
	IN PVOID ScatterGatherBuffer,
	IN ULONG ScatterGatherBufferLength
	);

VOID
RaidDmaPutScatterGatherList(
	IN PRAID_DMA_ADAPTER Dma,
	IN PSCATTER_GATHER_LIST ScatterGatherList,
	IN BOOLEAN WriteToDevice
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\driver.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    driver.h

Abstract:

    Definition of the RAID_DRIVER_EXTENSION object and related functions.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/

#pragma once


typedef struct _RAID_HW_INIT_DATA {
    HW_INITIALIZATION_DATA Data;
    LIST_ENTRY ListEntry;
} RAID_HW_INIT_DATA, *PRAID_HW_INIT_DATA;


//
// The RAID_DRIVER_EXTENSION is the extension for the driver.
//

typedef struct _RAID_DRIVER_EXTENSION {

    //
    // The object type for this extension. This must be RaidDriverObject.
    //
    
    RAID_OBJECT_TYPE ObjectType;

    //
    // Back pointer to the object containing this driver.
    //
    
    PDRIVER_OBJECT DriverObject;

    //
    // Back pointer to the PORT_DATA object that owns this driver object.
    //

    PRAID_PORT_DATA PortData;
    
    //
    // This is the list of drivers currently loaded.
    //
    
    LIST_ENTRY DriverLink;

    //
    // The Registry path passed into the miniport's DriverEntry.
    //

    UNICODE_STRING RegistryPath;

    //
    // List of adapters owned by this driver.
    //
    
    struct {

        //
        // List head.
        //
        
        LIST_ENTRY List;

        //
        // Count of entries.
        //
        
        ULONG Count;

        //
        // Spinlock protecting access to the list and count.
        //
        
        KSPIN_LOCK Lock;

    } AdapterList;
        
    //
    // Number of adapters that are attached to this driver.
    //
    
    ULONG AdapterCount;

    //
    // List of hardware initialization structures, passed in to
    // ScsiPortInitialize. These are necessary to process our AddDevice
    // call.
    //
    
    LIST_ENTRY HwInitList;
    
    //
    // The bus type for this driver.
    //
    
    STORAGE_BUS_TYPE BusType;

} RAID_DRIVER_EXTENSION, *PRAID_DRIVER_EXTENSION;


//
// Operations on the RAID_DRIVER_EXTENSION object.
//

//
// Creation and destruction.
//

VOID
RaCreateDriver(
    OUT PRAID_DRIVER_EXTENSION Driver
    );

NTSTATUS
RaInitializeDriver(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDRIVER_OBJECT DriverObject,
    IN PRAID_PORT_DATA PortData,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RaDeleteDriver(
    IN PRAID_DRIVER_EXTENSION Driver
    );

//
// Driver operations
//

NTSTATUS
RaDriverAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

PHW_INITIALIZATION_DATA
RaFindDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN INTERFACE_TYPE InterfaceType
    );

NTSTATUS
RaSaveDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    PHW_INITIALIZATION_DATA HwInitializationData
    );
//
// Handler functions
//

NTSTATUS
RaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
RaDriverCreateIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverCloseIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverDeviceControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverScsiIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
RaDriverPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaDriverSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Misc functions
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


ULONG
RaidPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\eventq.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	eventq.c

Abstract:

	Implementation of an event queue class used for timing out events issued
	to a hardware device.

	The event queue class implements the same algorithm as SCSIPORT to time
	events. The timeout is not strictly followed, but is used in conjunction
	with adding and removing items from the queue to time-out requests.

	For example, if three requests are issued to the queue, we would see the
	following:

	Before, no requests are pending.

	Issue:

	Request 1, Timeout = 4 seconds		Queue Timeout = -1, set to 4
	Request 2, Timeout = 2 seconds		Queue Timeout = 4, leave
	Request 3, Timeout = 4 seconds		Queue Timeout = 4, leave


	Complete:

	Request 1. Since Request 1 was at the head of the list, reset the timeout
	to the timeout for the next item in the queue, i.e., set Queue Timeout
	to 2 (#2's timeout)
	
	Request 3, Since Request 3 was not at the head of the list, do not
	reset the timeout.

	(wait 2 seconds)

	Time request 2 out.

Notes:

	There are better alorithms for timing out. Since we do not retry requests,
	but rather reset the entire bus, this is a sufficient algorithm.

Author:

	Matthew D Hendel (math) 28-Mar-2001


Revision History:

--*/


#include "precomp.h"
#include "eventq.h"

//
// Implementation
//

VOID
INLINE
ASSERT_QUEUE(
	IN PSTOR_EVENT_QUEUE Queue
	)
{
	//
	// Quick sanity check of the event queue object.
	//

	KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
	ASSERT (Queue->List.Flink->Blink == Queue->List.Blink->Flink);
	KeReleaseSpinLockFromDpcLevel (&Queue->Lock);
}


VOID
StorCreateEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	)
/*++

Routine Description:

	Create an empty event queue.

Arguments:

	Queue - Supplies the buffer where the event queue should be created.

Return Value:

	None.

--*/
{
	PAGED_CODE();
	ASSERT (Queue != NULL);
	InitializeListHead (&Queue->List);
	KeInitializeSpinLock (&Queue->Lock);
	Queue->Timeout = -1;
}



VOID
StorInitializeEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	)
{
	PAGED_CODE();
	ASSERT (Queue != NULL);
}


VOID
StorDeleteEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	)
/*++

Routine Description:

	Delete an event queue. The event queue must be empty to be deleted.

Arguments:

	Queue - Supplies the event queue to delete.

Return Value:

	None.

--*/
{
	ASSERT (IsListEmpty (&Queue->List));
	DbgFillMemory (Queue, sizeof (STOR_EVENT_QUEUE), DBG_DEALLOCATED_FILL);
}



VOID
StorInsertEventQueue(
	IN PSTOR_EVENT_QUEUE Queue,
	IN PSTOR_EVENT_QUEUE_ENTRY QueueEntry,
	IN ULONG Timeout
	)
/*++

Routine Description:

	Insert an item into a timed event queue.

Arguments:

	Queue - Supplies the event queue to insert the element into.

	Entry - Supplies the element to be inserted.

	Timeout - Supplies the timeout for the request.

Return Value:

	None.

--*/
{
	ASSERT_QUEUE (Queue);

	QueueEntry->Timeout = Timeout;

	KeAcquireSpinLockAtDpcLevel (&Queue->Lock);
	InsertTailList (&Queue->List, &QueueEntry->NextLink);
	KeReleaseSpinLockFromDpcLevel (&Queue->Lock);

	InterlockedCompareExchange (&Queue->Timeout, Timeout, -1);
}



VOID
StorRemoveEventQueue(
	IN PSTOR_EVENT_QUEUE Queue,
	IN PSTOR_EVENT_QUEUE_ENTRY QueueEntry
	)
/*++

Routine Description:

	Remove a specific item from the event queue.

Arguments:

	Queue - Event queue to remove the item from.

	Entry - Event to remove.


Return Value:

    NTSTATUS code

--*/
{
	LOGICAL Timed;
	PLIST_ENTRY Entry;

	ASSERT_QUEUE (Queue);

	//
	// It is possible for the entry to have already been removed. In this
	// case just return.
	//
	
	if (QueueEntry->NextLink.Flink == NULL) {
		ASSERT (QueueEntry->NextLink.Blink == NULL);
		return ;
	}
	
	KeAcquireSpinLockAtDpcLevel (&Queue->Lock);

	//
	// If Entry is at the head of the queue.
	//
	
	if (Queue->List.Flink == &QueueEntry->NextLink) {
		Timed = TRUE;
	} else {
		Timed = FALSE;
	}

	RemoveEntryList (&QueueEntry->NextLink);

	if (Timed) {
		if (IsListEmpty (&Queue->List)) {
			InterlockedAssign (&Queue->Timeout, -1);
		} else {

			//
			// Start timer from element at the head of the list.
			//

			Entry = Queue->List.Flink;
			QueueEntry = CONTAINING_RECORD (Entry,
											STOR_EVENT_QUEUE_ENTRY,
											NextLink);
			InterlockedAssign (&Queue->Timeout, QueueEntry->Timeout);
		}
	}

	KeReleaseSpinLockFromDpcLevel (&Queue->Lock);
}



NTSTATUS
StorTickEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	)
/*++

Routine Description:

	Reduce the event queue timeout by one tick.

Arguments:

	Queue - Supplies the queue to decrement the timeout for.

Return Value:

	STATUS_SUCCESS - If the timer expiration has not expired.

	STATUS_IO_TIMEOUT - If the timer expiration has expired.

--*/
{
	if (InterlockedQuery (&Queue->Timeout) == -1) {
		return STATUS_SUCCESS;
	}
	
	if (InterlockedDecrement (&Queue->Timeout) != 0) {
		return STATUS_SUCCESS;
	}

	return STATUS_IO_TIMEOUT;
}


VOID
StorPurgeEventQueue(
	IN PSTOR_EVENT_QUEUE Queue,
	IN STOR_EVENT_QUEUE_PURGE_ROUTINE PurgeRoutine,
	IN PVOID Context
	)
{
	PLIST_ENTRY NextEntry;
	PSTOR_EVENT_QUEUE_ENTRY QueueEntry;

	ASSERT (PurgeRoutine != NULL);

	while ((NextEntry = ExInterlockedRemoveHeadList (&Queue->List,
			&Queue->Lock)) != NULL) {
	
		QueueEntry = CONTAINING_RECORD (NextEntry,
									    STOR_EVENT_QUEUE_ENTRY,
										NextLink);

		//
		// NULL out the Flink and Blink so we know not to double remove
		// this element from the list.
		//
		
		QueueEntry->NextLink.Flink = NULL;
		QueueEntry->NextLink.Blink = NULL;

		PurgeRoutine (Queue, Context, QueueEntry);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\eventq.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	eventq.h

Abstract:

	Declaration of a timed event queue class.

Author:

	Matthew D Hendel (math) 28-Mar-2001

Revision History:

--*/

#pragma once


//
// Event queue entry
//

typedef
VOID
(*STOR_EVENT_QUEUE_PURGE_ROUTINE)(
	IN struct _STOR_EVENT_QUEUE* Queue,
	IN PVOID Context,
	IN struct _STOR_EVENT_QUEUE_ENTRY* Entry
	);

typedef struct _STOR_EVENT_QUEUE_ENTRY {
	LIST_ENTRY NextLink;
	ULONG Timeout;
} STOR_EVENT_QUEUE_ENTRY, *PSTOR_EVENT_QUEUE_ENTRY;

//
// Event queue class
//

typedef struct _STOR_EVENT_QUEUE {
	LIST_ENTRY List;
	KSPIN_LOCK Lock;
	ULONG Timeout;
} STOR_EVENT_QUEUE, *PSTOR_EVENT_QUEUE;


//
// Functions
//

VOID
StorCreateEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	);

VOID
StorInitializeEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	);

VOID
StorDeleteEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	);

VOID
StorPurgeEventQueue(
	IN PSTOR_EVENT_QUEUE Queue,
	IN STOR_EVENT_QUEUE_PURGE_ROUTINE PurgeRoutine,
	IN PVOID Context
	);

VOID
StorInsertEventQueue(
	IN PSTOR_EVENT_QUEUE Queue,
	IN PSTOR_EVENT_QUEUE_ENTRY Entry,
	IN ULONG Timeout
	);

VOID
StorRemoveEventQueue(
	IN PSTOR_EVENT_QUEUE Queue,
	IN PSTOR_EVENT_QUEUE_ENTRY Entry
	);

NTSTATUS
StorTickEventQueue(
	IN PSTOR_EVENT_QUEUE Queue
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\exqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exqueue.h

Abstract:

    This module implements an extended device queue. See exqueue.c for
    more details.

Author:

    Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#pragma once

//
// PERF NOTE: The device queue is implemented as a doubly linked list.
// While this works great for a FIFO device queue, for a CSCAN device
// queue we end up walking the list to insert the item in correct order.
// If the device queue gets very deep, there are a number of data
// structures that are better suited adding and removing elements in a
// CSCAN queue (priority queue, RB tree).
//

typedef enum _SCHEDULING_ALGORITHM {
    FifoScheduling =  0x01,
    CScanScheduling = 0x02
} SCHEDULING_ALGORITHM;

typedef struct _EXTENDED_DEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    PLIST_ENTRY DeviceListCurrent;
    LIST_ENTRY ByPassListHead;
    KSPIN_LOCK Lock;
    ULONG Depth;    
    ULONG OutstandingRequests;
    ULONG DeviceRequests;
    ULONG ByPassRequests;
    PSTOR_IO_GATEWAY Gateway;
    BOOLEAN Frozen;
    SCHEDULING_ALGORITHM SchedulingAlgorithm;
} EXTENDED_DEVICE_QUEUE, *PEXTENDED_DEVICE_QUEUE;

typedef struct _EXTENDED_DEVICE_QUEUE_PROPERTIES {
    ULONG Depth;
    BOOLEAN Frozen;
    BOOLEAN Busy;
    ULONG OutstandingRequests;
    ULONG DeviceRequests;
    ULONG ByPassRequests;
    SCHEDULING_ALGORITHM SchedulingAlgorithm;
} EXTENDED_DEVICE_QUEUE_PROPERTIES, *PEXTENDED_DEVICE_QUEUE_PROPERTIES;


VOID
RaidInitializeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PSTOR_IO_GATEWAY Gateway, OPTIONAL
    IN ULONG Depth,
    IN SCHEDULING_ALGORITHM SchedulingAlgorithm
    );

BOOLEAN
RaidInsertExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry,
    IN BOOLEAN ByPassRequest,
    IN ULONG SortQueueKey
    );

PKDEVICE_QUEUE_ENTRY
RaidNormalizeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );
    
PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PBOOLEAN RestartQueue
    );

PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueueByKey(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PBOOLEAN RestartQueue,
    IN ULONG SortQueueKey
    );
    
PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueueIfPending(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

VOID
RaidFreezeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

VOID
RaidResumeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    );

VOID
RaidReturnExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry
    );

VOID
RaidAcquireExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PKLOCK_QUEUE_HANDLE LockHandle
    );

VOID
RaidReleaseExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    );

VOID
RaidGetExDeviceQueueProperties(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PEXTENDED_DEVICE_QUEUE_PROPERTIES Properties
    );

VOID
RaidSetExDeviceQueueDepth(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN ULONG NewDepth
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\exqueue.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exqueue.c

Abstract:

    This module implements an extended device queue. The extended device
    queue extendes the traditional NT DEVICE_QUEUE object by adding
    several properties and operations to it to support a wider variety of
    devices.

Properties:

        Depth - Specifies the number of outstanding requests that can be
                pending on this device at a time. Any requests over Depth
                will put the queue in the busy state. Queue depth is set
                during object creation and can by dynamically adjusted at
                any time using RaidSetExDeviceQueueDepth.

Operations:

        RaidFreezeExDeviceQueue - Prevent incoming entries from executing
                by holding them in device queue. When the device queue is
                frozen, only entries that specify the ByPassQueue flag
                will not be queued.

        RaidResumeExDeviceQueue - Reverses calling RaidFreezeExDeviceQueue
                by allowing entries to leave the device queue.

        RaidNormalizeExDeviceQueue - After freezing and resuming the
                device queue or after adjusting the device queue depth,
                the device queue can have multiple entries in it's device
                queue but not be busy. This function "reinserts" elements
                into the queue until either the queue is busy again or
                the queue is empty.
Author:

    Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#include "precomp.h"


#if DBG
VOID
ASSERT_EXQ(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    ASSERT (DeviceQueue->Size == sizeof (EXTENDED_DEVICE_QUEUE));
    ASSERT (((LONG)DeviceQueue->DeviceRequests) >= 0);
    ASSERT (((LONG)DeviceQueue->ByPassRequests) >= 0);
    ASSERT (((LONG)DeviceQueue->OutstandingRequests) >= 0);

}
#else
#define ASSERT_EXQ(DeviceQueue)
#endif


VOID
INLINE
RaidpExQueueInsertItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry,
    IN ULONG SortKey
    )
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PKDEVICE_QUEUE_ENTRY QueueEntry;

    ListHead = &DeviceQueue->DeviceListHead;
    switch (DeviceQueue->SchedulingAlgorithm) {

        case CScanScheduling:
            for (ListEntry = ListHead->Blink;
                 ListEntry != ListHead;
                 ListEntry = ListEntry->Blink) {

                 QueueEntry = CONTAINING_RECORD(ListEntry,
                                                KDEVICE_QUEUE_ENTRY,
                                                DeviceListEntry);

                if (SortKey >= QueueEntry->SortKey) {
                    break;
                }
            }
            Entry->SortKey = SortKey;
            InsertHeadList (ListEntry, &Entry->DeviceListEntry);
            break;

        case FifoScheduling:
        default:
            InsertTailList (ListHead, &Entry->DeviceListEntry);
    }
        
}

PKDEVICE_QUEUE_ENTRY
INLINE
RaidpExQueueRemoveItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    PLIST_ENTRY Entry;
    PLIST_ENTRY Current;
    PKDEVICE_QUEUE_ENTRY DeviceEntry;

    //
    // Must have elements on the list if we're removing one of them.
    //
    
    ASSERT (!IsListEmpty (&DeviceQueue->DeviceListHead));

    switch (DeviceQueue->SchedulingAlgorithm) {

        case CScanScheduling:

            if (DeviceQueue->DeviceListCurrent) {
                Entry = DeviceQueue->DeviceListCurrent;
            } else {
                Entry = DeviceQueue->DeviceListHead.Flink;
            }

            Current = Entry->Flink;
            RemoveEntryList (Entry);

            if (Current == &DeviceQueue->DeviceListHead) {
                DeviceQueue->DeviceListCurrent = NULL;
            } else {
                DeviceQueue->DeviceListCurrent = Current;
            }
            break;

        case FifoScheduling:
        default:
            Entry = RemoveHeadList (&DeviceQueue->DeviceListHead);
    }

    
    DeviceEntry = CONTAINING_RECORD (Entry,
                                     KDEVICE_QUEUE_ENTRY,
                                     DeviceListEntry);

    return DeviceEntry;
}

BOOLEAN
INLINE
IsDeviceQueueBusy(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Check if a device queue is busy. A device queue is busy when it's
    currently processing as many requests as it can handle, otherwise it
    is not busy. The Depth field of the device queue holds the number of
    requests a device 

Arguments:

    DeviceQueue - Supplies device queue to check for busy condition.

Return Value:

    TRUE - If the device queue is busy.

    FALSE - If the device queue is not busy.

--*/
{
    ASSERT_EXQ (DeviceQueue);

    //
    // The conditional is actually testing if it is not busy.
    //
    
    if (DeviceQueue->OutstandingRequests < DeviceQueue->Depth) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOLEAN
INLINE
QuerySubmitItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    if (DeviceQueue->Gateway != NULL) {
        return StorSubmitIoGatewayItem (DeviceQueue->Gateway);
    }

    return TRUE;
}

BOOLEAN
INLINE
NotifyCompleteItem(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
{
    if (DeviceQueue->Gateway != NULL) {
        return StorRemoveIoGatewayItem (DeviceQueue->Gateway);
    }

    return FALSE;
}
    
VOID
RaidInitializeExDeviceQueue(
    OUT PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PSTOR_IO_GATEWAY Gateway, OPTIONAL
    IN ULONG Depth,
    IN SCHEDULING_ALGORITHM SchedulingAlgorithm
    )
/*++

Routine Description:

    Initialize an extended device queue object.

Arguments:

    DeviceQueue - Returns a pointer to the initialized device queue.

    Gateway - Supplies an optional pointer to a gateway object used
            to monitor and control several device queues that queue
            items to a single piece of hardware.
            

    Depth - Supplies the starting depth of the device queue.

    SchedulingAlgorithm - 

Return Value:

    None.

--*/
{
    InitializeListHead (&DeviceQueue->DeviceListHead);
    InitializeListHead (&DeviceQueue->ByPassListHead);
    DeviceQueue->DeviceListCurrent = NULL;
    KeInitializeSpinLock (&DeviceQueue->Lock);
    DeviceQueue->Depth = Depth;
    DeviceQueue->OutstandingRequests = 0;
    DeviceQueue->DeviceRequests = 0;
    DeviceQueue->ByPassRequests = 0;
    DeviceQueue->Type = 0;      // Probably not necessary
    DeviceQueue->Size = sizeof (EXTENDED_DEVICE_QUEUE);
    DeviceQueue->Gateway = Gateway;
    DeviceQueue->Frozen = FALSE;
    DeviceQueue->SchedulingAlgorithm = SchedulingAlgorithm;
}



BOOLEAN
RaidInsertExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry,
    IN BOOLEAN ByPass,
    IN ULONG SortKey
    )
/*++

Routine Description:

    Insert an element into the the device queue. The eight separate cases
    depending on the status of the device queue (busy/ready, frozen/not
    frozen, bypass/not bypass) are listed below. Making an entry
    outstanding means incrementing the count of outstanding requests and
    returning TRUE, to allow the request to execute immediately. Adding
    to the device queue means placing the entry at the end of the device
    queue and returning FALSE to signify that the request will be
    executed later. Adding to the bypass queue means adding the entry to
    the end of the bypass queue and returning FALSE to signify that the
    request will be executed later.

        Frozen  ByPass  Busy        Action
        --------------------------------------------------
          N       N       N         Make outstanding
          N       N       Y         Add to device queue
          N       Y       N         Make outstanding
          N       Y       Y         Add to bypass queue
          Y       N       N         Add to device queue
          Y       N       Y         Add to device queue
          Y       Y       N         Make outstanding
          Y       Y       Y         Add to bypass queue

Arguments:

    DeviceQueue - Supplies the extended device queue.

    Entry - Supplies pointer to the device queue entry to queue.

    ByPass - Supplies a flag specifying whether this is a bypass
            request (if TRUE) or not (if FALSE).

    SortKey - Sort key for implementation of C-SCAN algorithm.

Return Value:

    TRUE - If the queue is not busy and the request should be started
            immediately.

    FALSE - If the queue is busy, and the request should be executed
            later.

--*/
{
    BOOLEAN Inserted;
    BOOLEAN Frozen;
    BOOLEAN Busy;
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    Frozen = DeviceQueue->Frozen;
    Busy = IsDeviceQueueBusy (DeviceQueue);


    if ( (!Frozen && !ByPass && !Busy) ||
         (!Frozen &&  ByPass && !Busy) ||
         ( Frozen &&  ByPass && !Busy) ) {

        //
        // If the adapter is not busy, the request can be handled
        // immediately, so put it on the outstanding list. Otherwise,
        // it must be queued for processing later.
        //

        if (QuerySubmitItem (DeviceQueue)) {
            Inserted = FALSE;
            DeviceQueue->OutstandingRequests++;
        } else {
            Inserted = TRUE;
            RaidpExQueueInsertItem (DeviceQueue, Entry, SortKey);
            DeviceQueue->DeviceRequests++;
        }
        
    } else if ( (!Frozen && !ByPass &&  Busy) ||
                ( Frozen && !ByPass && !Busy) ||
                ( Frozen && !ByPass &&  Busy) ) {

        //
        // The non-bypass request cannot be handled at this time.
        // Place the request on the device queue.
        //

        Inserted = TRUE;
        RaidpExQueueInsertItem (DeviceQueue, Entry, SortKey);
        DeviceQueue->DeviceRequests++;

    } else {

        ASSERT ( (!Frozen && ByPass && Busy) ||
                 ( Frozen && ByPass && Busy) );

        //
        // The bypass request cannot be hanled at this time.
        // Place thre request on the bypass queue.
        //

        Inserted = TRUE;
        InsertTailList (&DeviceQueue->ByPassListHead,
                        &Entry->DeviceListEntry);
        DeviceQueue->ByPassRequests++;

    }

    Entry->Inserted = Inserted;
    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return Inserted;
}


PKDEVICE_QUEUE_ENTRY
RaidNormalizeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Normalize a device queue after a frozen queue has been resumed or the
    depth of the device queue has been increased.

    After a frozen queue has been resumed or the depth of a device queue
    has been increased, the device queue can have elements queued to it,
    but the queue itself is not busy or frozen. This function
    "normalizes" the device queue by removing "extra" items from the
    queue until it becomes busy or empty.

    If the queue is busy at the time of normalization, the function will
    queue the entry to be handled later.  Otherwise, the function will
    return the entry to be executed immediately.

        BusyFrozen    ByPass      Device        Action
        ---------------------------------------------------------
            N           N           N           Nothing
            N           N           Y           Requeue device entry
            N           Y           N           Requeue bypass entry
            N           Y           Y           Requeue bypass entry
            Y           N           N           Nothing
            Y           N           Y           Nothing
            Y           Y           N           Nothing
            Y           Y           Y           Nothing

Arguments:

    DeviceQueue - Supplies the device queue to remove the element from.

Return Value:

    A NULL pointer is returned if the entry if the device queue is
    currently busy. Otherwise, a pointer to the entry that was reinserted
    is returned.  The equivelent of StartPacket should be called when
    a non-NULL value is returned.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY DeviceEntry;
    BOOLEAN BusyFrozen;
    BOOLEAN Device;
    BOOLEAN ByPass;
    
    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // Set BusyFrozen if the queue is either busy or frozen.
    //
    
    BusyFrozen = (IsDeviceQueueBusy (DeviceQueue) || DeviceQueue->Frozen);
    Device = !IsListEmpty (&DeviceQueue->DeviceListHead);
    ByPass = !IsListEmpty (&DeviceQueue->ByPassListHead);


    if (!BusyFrozen && !ByPass && Device) {

        //
        // There is an extra entry on the device queue. If the
        // adapter is free, remove the item from the device queue
        // and put it on the outstanding list. Otherwise, leave
        // it on the queue.
        //

        if (QuerySubmitItem (DeviceQueue)) {

            DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
            DeviceQueue->DeviceRequests--;
            DeviceQueue->OutstandingRequests++;
            DeviceEntry->Inserted = FALSE;

        } else {
            DeviceEntry = NULL;
        }

    } else if ( (!BusyFrozen && ByPass && !Device) ||
                (!BusyFrozen && ByPass && Device ) ) {

        //
        // There is an extra entry on the bypass queue. If the
        // adapter is free, remove the item from the bypass queue
        // and put it on the outstanding list. Otherwise, leave
        // it on the bypass queue.
        //

        if (QuerySubmitItem (DeviceQueue)) {
            NextEntry = RemoveHeadList (&DeviceQueue->ByPassListHead);
            DeviceQueue->ByPassRequests--;
            DeviceQueue->OutstandingRequests++;
            DeviceEntry = CONTAINING_RECORD (NextEntry,
                                             KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);
            DeviceEntry->Inserted = FALSE;

        } else {
            DeviceEntry = NULL;
        }

    } else {

        //
        // There are no extra entries.
        //

        ASSERT ((!BusyFrozen && !ByPass && !Device) || BusyFrozen);
        DeviceEntry = NULL;
    }

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return DeviceEntry;
}
    

PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PBOOLEAN RestartQueue
    )
/*++

Routine Description:

    This routine removes an entry from the head of the device queue, if
    there is one available. If the device queue is frozen, only bypass
    entries are canidates for removal. The following table gives the actions
    for the eight separate cases depending on whether there are entries
    in the bypass queue (ByPass), device queue (Device) and whether the
    queue is frozen (Frozen):

          Frozen  ByPass  Device    Action
          ---------------------------------------------------------
            N       N       N       Remove outstanding
            N       N       Y       Remove device
            N       Y       N       Remove bypass
            N       Y       Y       Remove bypass
            Y       N       N       Remove outstanding
            Y       N       Y       Remove outstanding
            Y       Y       N       Remove bypass
            Y       Y       Y       Remove bypass

Arguments:

    DeviceQueue - Supplies a pointer to the device queue.

Return Value:

    If the device queue is empty, NULL is returned. Otherwise, a pointer
    to a device queue entry to be executed is returned.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY DeviceEntry;
    BOOLEAN Frozen;
    BOOLEAN ByPass;
    BOOLEAN Device;

    ASSERT (RestartQueue);

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
    
    Frozen = DeviceQueue->Frozen;
    ByPass = !IsListEmpty (&DeviceQueue->ByPassListHead);
    Device = !IsListEmpty (&DeviceQueue->DeviceListHead);
    

    if ( (!Frozen && !ByPass && !Device) ||
         ( Frozen && !ByPass && !Device) ||
         ( Frozen && !ByPass &&  Device) ) {

        //
        // There are no available entries on the bypass or device queues.
        // Remove the entry from the outstanding requests.
        //

        DeviceQueue->OutstandingRequests--;
        DeviceEntry = NULL;

        *RestartQueue = NotifyCompleteItem (DeviceQueue);

    } else if ( (!Frozen && !ByPass && Device) ) {

        //
        // There is an available entry on the device queue and the
        // queue is not frozen. If the gateway is not frozen, submit
        // the item. Otherwise, wait until the queue has drained to
        // sumit it.
        //

        if (!StorIsIoGatewayBusy (DeviceQueue->Gateway)) {
            DeviceQueue->OutstandingRequests--;
            *RestartQueue = NotifyCompleteItem (DeviceQueue);
            DeviceEntry = NULL;
        } else {
            DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
            DeviceEntry->Inserted = FALSE;
            DeviceQueue->DeviceRequests--;
            *RestartQueue = FALSE;
        }

    } else {

        //
        // There is an available entry on the bypass queue.
        //

        ASSERT (ByPass);
        
        NextEntry = RemoveHeadList (&DeviceQueue->ByPassListHead);
        DeviceEntry = CONTAINING_RECORD (NextEntry,
                                         KDEVICE_QUEUE_ENTRY,
                                         DeviceListEntry);
        DeviceEntry->Inserted = FALSE;
        DeviceQueue->ByPassRequests--;
        *RestartQueue = FALSE;
    }

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return DeviceEntry;
}

PKDEVICE_QUEUE_ENTRY
RaidRemoveExDeviceQueueIfPending(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Remove the next pending entry from the non-bypass list, if one
    is available. If not, return NULL. Pending entries are entries
    that have been physically queued to the device queue (as opposed
    to outstanding requests, which are not inserted in the queue).

    NB: This function works properly on both a frozen and unfrozen
        device queue.

Arguments:

    DeviceQueue - Supplies a device queue that the pending entry should
            be removed from.

Return Value:

    NULL - If there are no pending entries on the queue.

    Non-NULL - Pointer to a pending queue entry that has been
            removed from the queue.

--*/
{
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY DeviceEntry;
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // If the device list is not empty, remove the head and
    // return the entry. Otherwise, return NULL.
    //
    
    if (!IsListEmpty (&DeviceQueue->DeviceListHead)) {
        DeviceEntry = RaidpExQueueRemoveItem (DeviceQueue);
        DeviceEntry->Inserted = FALSE;
        DeviceQueue->DeviceRequests--;
    } else {
        DeviceEntry = NULL;
    }

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    return DeviceEntry;
}

VOID
RaidFreezeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Freeze the device queue, disallowing further requests from leaving
    the queue. When the queue is frozen, only bypass requests are allowed
    to leave the queue.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to freeze.

Return Value:

    None.

Notes:

    Calling RaidFreezeExDeviceQueue on a frozen queue is not supported.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // We do not maintain a freeze count, so freezing the queue multiple
    // times is not allowed.
    //
    
    ASSERT (!DeviceQueue->Frozen);
    DeviceQueue->Frozen = TRUE;

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}


VOID
RaidResumeExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue
    )
/*++

Routine Description:

    Resume a frozen queue.

    NB: Unless all of the elements of the queue are flushed, sometime
    after resuming the queue, the function RaidReinsertExDeviceQueue
    should be called to remove frozen entries from the queue.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to resume.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    //
    // The queue must be frozen for resume to make sense.
    //
    
    ASSERT (DeviceQueue->Frozen);
    DeviceQueue->Frozen = FALSE;

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}


VOID
RaidReturnExDeviceQueue(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY Entry
    )
/*++

Routine Description:

    Return the IO packet to the head of the queue. Presumably this is
    because the IO packet failed to complete properly and needs to
    be retried.

    NB: The item is queued to the FRONT of the queue, not the BACK.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue the item
        is to be returned to.

    Entry - Supplies pointer ot the device queue entry to return to
        the queue.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT_EXQ (DeviceQueue);
    
    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    DeviceQueue->OutstandingRequests--;
    InsertHeadList (&DeviceQueue->DeviceListHead, &Entry->DeviceListEntry);
    DeviceQueue->DeviceRequests++;

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}
    

VOID
RaidSetExDeviceQueueDepth(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN ULONG Depth
    )
/*++

Routine Description:

    Adjust the depth of the device queue.

    NB: If the depth is adjusted upwards, after adjusting the queue depth
    the function RaidReinsertExDeviceQueue should be called to remove
    extra items from the queue.

Arguments:

    DeviceQueue - Supplies a pointer to a device queue to adjust.

    Depth - Supplies the new depth of the device queue.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    DeviceQueue->Depth = Depth;

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}

VOID
RaidGetExDeviceQueueProperties(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PEXTENDED_DEVICE_QUEUE_PROPERTIES Properties
    )
/*++

Routine Description:

    Get properties for the device queue.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to get
            properties for.

    Properties - Returns properties for the device queue.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;

    RaidAcquireExDeviceQueueSpinLock (DeviceQueue, &LockHandle);

    Properties->Frozen = DeviceQueue->Frozen;
    Properties->Busy = IsDeviceQueueBusy (DeviceQueue);
    Properties->Depth = DeviceQueue->Depth;
    Properties->OutstandingRequests = DeviceQueue->OutstandingRequests;
    Properties->DeviceRequests = DeviceQueue->DeviceRequests;
    Properties->ByPassRequests = DeviceQueue->ByPassRequests;

    RaidReleaseExDeviceQueueSpinLock (DeviceQueue, &LockHandle);
}



VOID
RaidAcquireExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    OUT PKLOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    Acquire the device queue spinlock.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to acquire the
            spinlock for.

    LockHandle - Returns a pointer to the lock handle for this spinlock.

Return Value:

    None.

--*/
{
    KeAcquireInStackQueuedSpinLockAtDpcLevel (&DeviceQueue->Lock, LockHandle);
    ASSERT_EXQ (DeviceQueue);
}

VOID
RaidReleaseExDeviceQueueSpinLock(
    IN PEXTENDED_DEVICE_QUEUE DeviceQueue,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    Release the device queue spinlock.

Arguments:

    DeviceQueue - Supplies a pointer to the device queue to release the
            spinlock to.

    LockHandle - Supplies a pointer to the lock handle returned when
            the spinlock was acquired.

Return Value:

    None.

--*/
{
    ASSERT_EXQ (DeviceQueue);
    KeReleaseInStackQueuedSpinLockFromDpcLevel (LockHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\driver.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    Implements the driver object for the raid port driver.

Author:

    Matthew D Hendel (math) 04-Apr-2000

Environment:

    Kernel mode only.

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateDriver)
#pragma alloc_text(PAGE, RaDeleteDriver)
#pragma alloc_text(PAGE, RaInitializeDriver)
#pragma alloc_text(PAGE, RaDriverAddDevice)
#pragma alloc_text(PAGE, RaDriverCreateIrp)
#pragma alloc_text(PAGE, RaDriverCloseIrp)
#pragma alloc_text(PAGE, RaDriverDeviceControlIrp)
#pragma alloc_text(PAGE, RaDriverPnpIrp)
#pragma alloc_text(PAGE, RaDriverSystemControlIrp)
#pragma alloc_text(PAGE, RaSaveDriverInitData)
#pragma alloc_text(PAGE, RaFindDriverInitData)
#endif // ALLOC_PRAGMA


VOID
RaCreateDriver(
    OUT PRAID_DRIVER_EXTENSION Driver
    )
/*++

Routine Description:

    Create a driver extension object and initialize to a null state.

Arguments:

    Driver - The driver extension obejct to create.

Return Value:

    None.

--*/
{
    PAGED_CODE ();

    RtlZeroMemory (Driver, sizeof (*Driver));
    Driver->ObjectType = RaidDriverObject;
    InitializeListHead (&Driver->HwInitList);
    InitializeListHead (&Driver->AdapterList.List);
    KeInitializeSpinLock (&Driver->AdapterList.Lock);
}

NTSTATUS
RaInitializeDriver(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN PDRIVER_OBJECT DriverObject,
    IN PRAID_PORT_DATA PortData,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS Status;
    
    PAGED_CODE ();

    //
    // Initialize the Driver object.
    //
    
    DriverObject->MajorFunction[ IRP_MJ_CREATE ] = RaDriverCreateIrp;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE ]  = RaDriverCloseIrp;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = RaDriverDeviceControlIrp;
    DriverObject->MajorFunction[ IRP_MJ_SCSI ] = RaDriverScsiIrp;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = RaDriverPnpIrp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = RaDriverPowerIrp;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = RaDriverSystemControlIrp;

    DriverObject->DriverExtension->AddDevice = RaDriverAddDevice;

    DriverObject->DriverStartIo = NULL;
    DriverObject->DriverUnload = RaDriverUnload;

    //
    // Initialize our extension and port data.
    //
    
    Driver->DriverObject = DriverObject;
    Driver->PortData = PortData;

    Status = RaDuplicateUnicodeString (&Driver->RegistryPath,
                                       RegistryPath,
                                       NonPagedPool,
                                       DriverObject);

    //
    // Attach this driver to the port's driver list.
    //
    
    RaidAddPortDriver (PortData, Driver);
    return Status;
}

VOID
RaDeleteDriver(
    IN PRAID_DRIVER_EXTENSION Driver
    )
/*++

Routine Description:

    Delete a driver extension object and deallocate any resources
    associated with it.

Arguments:

    Driver - The driver extension object to delete.

Return Value:

    None.

--*/
{
    PAGED_CODE ();

    ASSERT (Driver->AdapterCount == 0);
    ASSERT (Driver->ObjectType == RaidDriverObject);

    Driver->ObjectType = -1;
    RtlFreeUnicodeString (&Driver->RegistryPath);

    //
    // Remove the driver from the port's list.
    //
    
    if (Driver->DriverLink.Flink) {
        ASSERT (Driver->PortData);
        RaidRemovePortDriver (Driver->PortData, Driver);
    }

    //
    // Release the reference to the port data object.
    //

    if (Driver->PortData) {
        RaidReleasePortData (Driver->PortData);
    }
}



NTSTATUS
RaDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    NTSTATUS Status;
    PRAID_DRIVER_EXTENSION Driver;
    
    //
    // Deallocate driver extension.
    //
    
    NYI ();
    Driver = IoGetDriverObjectExtension (DriverObject, DriverEntry);
    ASSERT (Driver != NULL);
    RaDeleteDriver (Driver);
    
    return STATUS_SUCCESS;
}


NTSTATUS
RaDriverAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    Add a new adapter.

Arguments:

    DriverObject - Driver object that owns the adapter.

    PhysicalDeviceObject - PDO associated with the adapter.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DRIVER_EXTENSION Driver;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT LowerDeviceObject;
    KLOCK_QUEUE_HANDLE LockHandle;
    UNICODE_STRING DeviceName;

    PAGED_CODE ();

    ASSERT (DriverObject != NULL);
    ASSERT (PhysicalDeviceObject != NULL);


    DebugTrace (("AddDevice: DriverObject %p, PhysicalDeviceObject %p\n",
                 DriverObject,
                 PhysicalDeviceObject));


    Adapter = NULL;
    DeviceObject = NULL;
    LowerDeviceObject = NULL;
    RtlInitEmptyUnicodeString (&DeviceName, NULL, 0);

    RaidCreateDeviceName (PhysicalDeviceObject, &DeviceName);
    
    //
    // Create the FDO for this PDO.
    //

    Status = IoCreateDevice (DriverObject,
                             sizeof (RAID_ADAPTER_EXTENSION),
                             &DeviceName,
                             FILE_DEVICE_CONTROLLER,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }


    //
    // Create the adapter.
    //
    
    Adapter = DeviceObject->DeviceExtension;
    RaidCreateAdapter (Adapter);

    //
    // Get the driver object's extension.
    //
    
    Driver = IoGetDriverObjectExtension (DriverObject, DriverEntry);

    //
    // Attach ourselves to the device stack.
    //
    
    LowerDeviceObject = IoAttachDeviceToDeviceStack (DeviceObject,
                                                     PhysicalDeviceObject);
                                
    if (LowerDeviceObject == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Initialize the Adapter's extension.
    // 

    Status = RaidInitializeAdapter (Adapter,
                                    DeviceObject,
                                    Driver,
                                    LowerDeviceObject,
                                    PhysicalDeviceObject,
                                    &DeviceName);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Add the adapter to the driver's adapter list.
    //

    KeAcquireInStackQueuedSpinLock (&Driver->AdapterList.Lock, &LockHandle);
    InsertHeadList (&Driver->AdapterList.List, &Adapter->NextAdapter);
    Driver->AdapterList.Count++;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    //
    // Start the driver.
    //

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    CLEAR_FLAG (DeviceObject->Flags, DO_DEVICE_INITIALIZING);

done:

    if (!NT_SUCCESS (Status) && Adapter != NULL) {
        RaidDeleteAdapter (Adapter);
        IoDeleteDevice (DeviceObject);
    }

    return Status;
}

//
// First level dispatch routines.
//

NTSTATUS
RaDriverCreateIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the top level dispatch handler for the create irp.

Arguments:

    DeviceObject - The device object that is receiving the irp.

    Irp - The irp to process.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);

    DebugTrace (("DeviceObject %p, Irp %p Create\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterCreateIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitCreateIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Create, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverCloseIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Top level handler function for the close irp. Forward the irp to the
    adapter or unit specific handler.
    
Arguments:

    DeviceObject - The device object the irp is for.

    Irp - The close irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);

    DebugTrace (("DeviceObject %p, Irp %p, Close\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterCloseIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitCloseIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Close, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverDeviceControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch function for the device control irp. Dispatch the irp to an
    adapter or unit specific handler function.

Arguments:

    DeviceObject - DeviceObject this irp is for.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{    
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);

    DebugTrace (("DeviceObject %p, Irp %p, DeviceControl\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterDeviceControlIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitDeviceControlIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, DeviceControl, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}

NTSTATUS
RaDriverScsiIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for scsi irps.

Arguments:

    DeviceObject - DeviceObject the irp is for.

    Irp - The irp to handle.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    ULONG Type;
    NTSTATUS Status;

    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);


    DebugTrace (("DeviceObject %p, Irp %p, Scsi\n",
                 DeviceObject,
                 Irp));

    //
    // Forward the IRP to the adapter or Unit handler
    // function.
    //
    
    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {

        case RaidAdapterObject:
            Status = RaidAdapterScsiIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitScsiIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Scsi, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function dispatches IRP_MJ_PNP IRPs to the Adapter Object or
    Logical Unit Object handlers.

Arguments:

    DeviceObject - DeviceObject to handle this irp.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    
    DebugTrace (("DeviceObject %p, Irp %p PnP, Minor %x\n",
                 DeviceObject,
                 Irp,
                 RaidMinorFunctionFromIrp (Irp)));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);

    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterPnpIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitPnpIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;

    }

    DebugTrace (("DeviceObject %p, Irp %p PnP, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for power irps. The irps are dispatched to adapter
    or unit specific handler functions.

Arguments:

    DeviceObject - DeviceObject this irp is for.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    
    DebugTrace (("DeviceObject %p, Irp %p, Power\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);
    
    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterPowerIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitPowerIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, Power, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}


NTSTATUS
RaDriverSystemControlIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for WMI irps.

Arguments:

    DeviceObject - DeviceObject the irp is for.

    Irp - WMI irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Type;

    PAGED_CODE ();
    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    
    DebugTrace (("DeviceObject %p, Irp %p, WMI\n",
                 DeviceObject,
                 Irp));

    RaidSetIrpState (Irp, RaidPortProcessingIrp);
    Type = RaGetObjectType (DeviceObject);
    
    switch (Type) {
    
        case RaidAdapterObject:
            Status = RaidAdapterSystemControlIrp (DeviceObject->DeviceExtension, Irp);
            break;

        case RaidUnitObject:
            Status = RaUnitSystemControlIrp (DeviceObject->DeviceExtension, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    DebugTrace (("DeviceObject %p, Irp %p, WMI, ret = %08x\n",
                 DeviceObject,
                 Irp,
                 Status));

    return Status;
}

NTSTATUS
RaSaveDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    PHW_INITIALIZATION_DATA HwInitializationData
    )
{
    NTSTATUS Status;
    PRAID_HW_INIT_DATA HwInitData;
    
    PAGED_CODE ();
    ASSERT (HwInitializationData != NULL);


    HwInitData = ExAllocatePoolWithTag (NonPagedPool,
                                        sizeof (*HwInitData),
                                        HWINIT_TAG);

    if (HwInitData == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    RtlCopyMemory (&HwInitData->Data,
                   HwInitializationData,
                   sizeof (*HwInitializationData));

    //
    // NB: In a checked build we should check that an entry with this
    // BusInterface is not already on the list.
    //
    
    InsertHeadList (&Driver->HwInitList, &HwInitData->ListEntry);

    return STATUS_SUCCESS;
}
    
    

PHW_INITIALIZATION_DATA
RaFindDriverInitData(
    IN PRAID_DRIVER_EXTENSION Driver,
    IN INTERFACE_TYPE InterfaceType
    )
{
    PLIST_ENTRY NextEntry;
    PRAID_HW_INIT_DATA HwInitData;

    PAGED_CODE ();

    //
    // Search the driver's HwInitList for this.
    //

    for ( NextEntry = Driver->HwInitList.Flink;
          NextEntry != &Driver->HwInitList;
          NextEntry = NextEntry->Flink ) {
         
        HwInitData = CONTAINING_RECORD (NextEntry,
                                        RAID_HW_INIT_DATA,
                                        ListEntry);

        if (HwInitData->Data.AdapterInterfaceType == InterfaceType) {

            //
            // NB: Should this be removed??
            //
            
//            RemoveEntryList (&HwInit->ListEntry);
            return &HwInitData->Data;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\ext.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	ext.h

Abstract:

	Extended typedef's that should be rolled back into wdm.h and
	ntddk.h.

Author:

	Matthew D Hendel (math) 21-Feb-2001

Revision History:

--*/
#pragma once

#define ULONG_MAX	(0xFFFFFFFFUL)

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif


//
// Create parameter
//

typedef struct _IRP_STACK_CREATE {
	PIO_SECURITY_CONTEXT SecurityContext;
	ULONG Options;
	USHORT POINTER_ALIGNMENT FileAttributes;
	USHORT ShareAccess;
	ULONG POINTER_ALIGNMENT EaLength;
} IRP_STACK_CREATE, *PIRP_STACK_CREATE;


//
// Read parameter
//

typedef struct _IRP_STACK_READ {
	ULONG Length;
	ULONG POINTER_ALIGNMENT Key;
	LARGE_INTEGER ByteOffset;
} IRP_STACK_READ, *PIRP_STACK_READ;


//
// Write parameter
//

typedef struct _IRP_STACK_WRITE {
	ULONG Length;
	ULONG POINTER_ALIGNMENT Key;
	LARGE_INTEGER ByteOffset;
} IRP_STACK_WRITE, *PIRP_STACK_WRITE;


//
// QueryFile parameter
//

typedef struct _IRP_STACK_QUERY_FILE {
	ULONG Length;
	FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClas;
} IRP_STACK_QUERY_FILE, *PIRP_STACK_QUERY_FILE;


//
// SetFile parameter
//

typedef struct _IRP_STACK_SET_FILE {
	ULONG Length;
	FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
	PFILE_OBJECT FileObject;
	union {
		struct {
			BOOLEAN ReplaceIfExists;
			BOOLEAN AdvanceOnly;
		};
		ULONG ClusterCount;
		HANDLE DeleteHandle;
	};
} IRP_STACK_SET_FILE, *PIRP_STACK_SET_FILE;


//
// QueryVolume parameter
//

typedef struct _IRP_STACK_QUERY_VOLUME {
	ULONG Length;
	FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
} IRP_STACK_QUERY_VOLUME, *PIRP_STACK_QUERY_VOLUME;


//
// DeviceIoControl parameter
//

typedef struct _IRP_STACK_DEVICE_IO_CONTROL {
	ULONG OutputBufferLength;
	ULONG POINTER_ALIGNMENT InputBufferLength;
	ULONG POINTER_ALIGNMENT IoControlCode;
	PVOID Type3InputBuffer;
} IRP_STACK_DEVICE_IO_CONTROL, *PIRP_STACK_DEVICE_IO_CONTROL;


//
// MountVolume parameter
//

typedef struct _IRP_STACK_MOUNT_VOLUME {
	PVOID DoNotUse1;
	PDEVICE_OBJECT DeviceObject;
} IRP_STACK_MOUNT_VOLUME, *PIRP_STACK_MOUNT_VOLUME;


//
// VerifyVolume parameter
//

typedef struct _IRP_STACK_VERIFY_VOLUME {
	PVOID DoNotUse1;
	PDEVICE_OBJECT DeviceObject;
} IRP_STACK_VERIFY_VOLUME, *PIRP_STACK_VERIFY_VOLUME;


//
// Scsi Parameter
//

typedef struct _IRP_STACK_SCSI {
	struct _SCSI_REQUEST_BLOCK *Srb;
} IRP_STACK_SCSI, *PIRP_STACK_SCSI;


//
// QueryDeviceRelations parameter
//

typedef struct _IRP_STACK_QUERY_DEVICE_RELATIONS {
	DEVICE_RELATION_TYPE Type;
} IRP_STACK_QUERY_DEVICE_RELATIONS, *PIRP_STACK_QUERY_DEVICE_RELATIONS;


//
// QueryInterface parameter
//

typedef struct _IRP_STACK_QUERY_INTERFACE {
	CONST GUID *InterfaceType;
	USHORT Size;
	USHORT Version;
	PINTERFACE Interface;
	PVOID InterfaceSpecificData;
} IRP_STACK_QUERY_INTERFACE, *PIRP_STACK_QUERY_INTERFACE;


//
// DeviceCapabilities parameter
//

typedef struct _IRP_STACK_DEVICE_CAPABILITIES {
	PDEVICE_CAPABILITIES Capabilities;
} IRP_STACK_DEVICE_CAPABILITIES, *PIRP_STACK_DEVICE_CAPABILITIES;


//
// FilterResourceRequirements parameter
//

typedef struct _IRP_STACK_FILTER_RESOURCE_REQUIREMENTS {
	PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
} IRP_STACK_FILTER_RESOURCE_REQUIREMENTS, *PIRP_STACK_FILTER_RESOURCE_REQUIREMENTS;


//
// ReadWriteConfig parameter
//

typedef struct _IRP_STACK_READ_WRITE_CONFIG {
	ULONG WhichSpace;
	PVOID Buffer;
	ULONG Offset;
	ULONG POINTER_ALIGNMENT Length;
} IRP_STACK_READ_WRITE_CONFIG, *PIRP_STACK_READ_WRITE_CONFIG;


//
// SetLock parameter
//

typedef struct _IRP_STACK_SET_LOCK {
	BOOLEAN Lock;
} IRP_STACK_SET_LOCK, *PIRP_STACK_SET_LOCK;


//
// QueryId parameter
//

typedef struct _IRP_STACK_QUERY_ID {
	BUS_QUERY_ID_TYPE IdType;
} IRP_STACK_QUERY_ID, *PIRP_STACK_QUERY_ID;


//
// QueryDeviceText parameter
//

typedef struct _IRP_STACK_QUERY_DEVICE_TEXT {
	DEVICE_TEXT_TYPE DeviceTextType;
	LCID POINTER_ALIGNMENT LocaleId;
} IRP_STACK_QUERY_DEVICE_TEXT, *PIRP_STACK_QUERY_DEVICE_TEXT;


//
// UsageNotification parameter
//

typedef struct _IRP_STACK_USAGE_NOTIFICATION {
	BOOLEAN InPath;
	BOOLEAN Reserved[3];
	DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
} IRP_STACK_USAGE_NOTIFICATION, *PIRP_STACK_USAGE_NOTIFICATION;

//
// WaitWake parameter
//

typedef struct _IRP_STACK_WAIT_WAKE {
	SYSTEM_POWER_STATE PowerState;
} IRP_STACK_WAIT_WAKE, *PIRP_STACK_WAIT_WAKE;


//
// PowerSequence parameter
//

typedef struct _IRP_STACK_POWER_SEQUENCE {
	PPOWER_SEQUENCE PowerSequence;
} IRP_STACK_POWER_SEQUENCE, *PIRP_STACK_POWER_SEQUENCE;


//
// Power parameter
//

typedef struct _IRP_STACK_POWER {
	ULONG SystemContext;
	POWER_STATE_TYPE POINTER_ALIGNMENT Type;
	POWER_STATE POINTER_ALIGNMENT State;
	POWER_ACTION POINTER_ALIGNMENT ShutdownType;
} IRP_STACK_POWER, *PIRP_STACK_POWER;


//
// StartDevice parameter
//

typedef struct _IRP_STACK_START_DEVICE {
	PCM_RESOURCE_LIST AllocatedResources;
	PCM_RESOURCE_LIST AllocatedResourcesTranslated;
} IRP_STACK_START_DEVICE, *PIRP_STACK_START_DEVICE;


//
// WMI parameter
//

typedef struct _IRP_STACK_WMI {
	ULONG_PTR ProviderId;
	PVOID DataPath;
	ULONG BufferSize;
	PVOID Buffer;
} IRP_STACK_WMI, *PIRP_STACK_WMI;


//
// Others parameter
//

typedef struct _IRP_STACK_OTHERS {
	PVOID Argument1;
	PVOID Argument2;
	PVOID Argument3;
	PVOID Argument4;
} IRP_STACK_OTHERS, *PIRP_STACK_OTHERS;



//
// The following macro verifies that a defined type is the same size
// as the on embedded in the IRP_STACK_LOCATION. This ensures that if
// somebody changes one, they have to change the other.
//

#define VERIFY_IRP_STACK_PARAMETER(TYPE, FIELD)\
	C_ASSERT (sizeof(TYPE) ==											\
			  sizeof (((PIO_STACK_LOCATION)NULL)->Parameters.FIELD))


//
// Verify all structures are proper size.
//

VERIFY_IRP_STACK_PARAMETER (IRP_STACK_CREATE, Create);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_READ, Read);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_FILE, QueryFile);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_SET_FILE, SetFile);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_VOLUME, QueryVolume);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_DEVICE_IO_CONTROL, DeviceIoControl);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_MOUNT_VOLUME, MountVolume);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_VERIFY_VOLUME, VerifyVolume);VERIFY_IRP_STACK_PARAMETER (IRP_STACK_SCSI, Scsi);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_DEVICE_RELATIONS, QueryDeviceRelations);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_INTERFACE, QueryInterface);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_DEVICE_CAPABILITIES, DeviceCapabilities);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_FILTER_RESOURCE_REQUIREMENTS, FilterResourceRequirements);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_READ_WRITE_CONFIG, ReadWriteConfig);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_ID, QueryId);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_QUERY_DEVICE_TEXT, QueryDeviceText);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_USAGE_NOTIFICATION, UsageNotification);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_WAIT_WAKE, WaitWake);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_POWER_SEQUENCE, PowerSequence);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_POWER, Power);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_START_DEVICE, StartDevice);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_WMI, WMI);
VERIFY_IRP_STACK_PARAMETER (IRP_STACK_OTHERS, Others);

#undef VERIFY_IRP_STACK_PARAMETER

#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\global.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    global.c

Abstract:

    Global data and functions to operate on global data for the raid port
    driver.

Author:

    Matthew D Hendel (math) 07-Apri-2000

Revision History:

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif // ALLOC_PRAGMA

//
// Global data
//

PRAID_PORT_DATA RaidpPortData = NULL;

ULONG TestRaidPort = TRUE;

//
// In low resource conditions, it's possible to generate errors that cannot
// be successfully logged. In these cases, increment a counter of errors
// that we've dropped.
//

LONG RaidUnloggedErrors = 0;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return STATUS_SUCCESS;
}


ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext OPTIONAL
    )
/*++

Routine Description:

    This routine initializes the raid port driver.

Arguments:

    Argument1 - DriverObject passed into the Miniport's DriverEntry
            routine.

    Argument2 - RegistryPath parameters passed into the Miniport's
            DriverEntry routine.

    HwInitializationData - Miniport initialization structure.

    HwContext -
    
Return Value:

    NTSTATUS code.

--*/
{
    ULONG Status;
    PDRIVER_OBJECT DriverObject;
    PUNICODE_STRING RegistryPath;
    PRAID_DRIVER_EXTENSION Driver;
    PRAID_PORT_DATA PortData;

    PAGED_CODE ();

    Driver = NULL;


#if 1
    if (TestRaidPort == 0) {
        TestRaidPort = -1;
        KdBreakPoint();
    }
#endif

    //
    // BUGBUG: Remove this.
    //
    
    if (TestRaidPort != 1) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize the DPFLTR stuff.
    //
    
    StorSetDebugPrefixAndId ("STOR: ", DPFLTR_STORPORT_ID);
    
    DebugTrace (("RaidPortInitialize: %p %p %p %p\n",
                  Argument1,
                  Argument2,
                  HwInitializationData,
                  HwContext));


    DriverObject = Argument1;
    RegistryPath = Argument2;

    //
    // We require Argument1, Argument2 and HwInitializeData to be correct.
    //
    
    if (DriverObject == NULL ||
        RegistryPath == NULL ||
        HwInitializationData == NULL) {
        
        return STATUS_INVALID_PARAMETER;
    }

    if (HwInitializationData->HwInitializationDataSize > sizeof (HW_INITIALIZATION_DATA)) {
        return STATUS_REVISION_MISMATCH;
    }

    if (HwInitializationData->HwInitialize == NULL ||
        HwInitializationData->HwFindAdapter == NULL ||
        HwInitializationData->HwStartIo == NULL ||
        HwInitializationData->HwResetBus == NULL) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // Do driver global initialization.
    //
    
    PortData = RaidGetPortData ();

    if (PortData == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Allocate the Driver Extension, if necessary.
    //

    Driver = IoGetDriverObjectExtension (DriverObject, DriverEntry);

    if (Driver == NULL) {

        Status = IoAllocateDriverObjectExtension (DriverObject,
                                                  DriverEntry,
                                                  sizeof (*Driver),
                                                  &Driver);
        if (!NT_SUCCESS (Status)) {
            goto done;
        }

        RaCreateDriver (Driver);
        Status = RaInitializeDriver (Driver,
                                     DriverObject,
                                     PortData,
                                     RegistryPath);

        if (!NT_SUCCESS (Status)) {
            goto done;
        }

    } else {

        //
        // In a checked build, sanity check that we actually got the correct
        // driver.
        //
        
        ASSERT (Driver->ObjectType == RaidDriverObject);
        ASSERT (Driver->DriverObject == DriverObject);
        Status = STATUS_SUCCESS;
    }
    
    //
    // We need the HwInitializationData for the IRP_MJ_PNP routines. Store
    // it for later use.
    //

    Status = RaSaveDriverInitData (Driver, HwInitializationData);

done:

    if (!NT_SUCCESS (Status)) {

        //
        // Delete any resources associated with the driver.
        //

        if (Driver != NULL) {
            RaDeleteDriver (Driver);
        }

        //
        // There is no need (or way) to delete the memory consumed by
        // the driver extension. This will be done for us by IO manager
        // when the driver is unloaded.
        //

        Driver = NULL;
    }

    return Status;
}

//
// Functions on raid global data structurs.
//

PRAID_PORT_DATA
RaidGetPortData(
    )
/*++

Routine Description:

    Create a RAID_PORT_DATA object if one has not already been created,
    and return a referenced pointer to the port data object.

Arguments:

    None.

Return Value:

    Pointer to a referenced RAID_PORT_DATA structure on success, NULL on
    failure.

--*/

{
    NTSTATUS Status;
    PRAID_PORT_DATA PortData;
    
    PAGED_CODE ();

    if (RaidpPortData == NULL) {
        PortData = ExAllocatePoolWithTag (NonPagedPool,
                                          sizeof (RAID_PORT_DATA),
                                          PORT_DATA_TAG);
        if (PortData == NULL) {
            return NULL;
        }
        
        //
        // Initilize the adapter list, the adapter list spinlock
        // and the adapter list count.
        //

        InitializeListHead (&PortData->DriverList.List);
        KeInitializeSpinLock (&PortData->DriverList.Lock);
        PortData->DriverList.Count = 0;
        PortData->ReferenceCount = 1;

        ASSERT (RaidpPortData == NULL);
        RaidpPortData = PortData;
    }

    return RaidpPortData;
}

VOID
RaidReleasePortData(
    IN PRAID_PORT_DATA PortData
    )
{
    LONG Count;
    
    Count = InterlockedDecrement (&PortData->ReferenceCount);
    ASSERT (Count >= 0);

    ASSERT (RaidpPortData == PortData);
    
    if (Count == 0) {

        RaidpPortData = NULL;
        
        //
        // Refcount is zero: delete the port data object.
        //

        //
        // All driver's should have been removed from the driver
        // list before deleting the port data.
        //
        
        ASSERT (PortData->DriverList.Count == 0);
        ASSERT (IsListEmpty (&PortData->DriverList.List));

        DbgFillMemory (PortData, sizeof (*PortData), DBG_DEALLOCATED_FILL);
        ExFreePoolWithTag (PortData, PORT_DATA_TAG);
    }
}

NTSTATUS
RaidAddPortDriver(
    IN PRAID_PORT_DATA PortData,
    IN PRAID_DRIVER_EXTENSION Driver
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&PortData->DriverList.Lock, &LockHandle);

#if DBG

    //
    // Check that this driver isn't already on the driver list.
    //

    {
        PLIST_ENTRY NextEntry;
        PRAID_DRIVER_EXTENSION TempDriver;

        for ( NextEntry = PortData->DriverList.List.Flink;
              NextEntry != &PortData->DriverList.List;
              NextEntry = NextEntry->Flink ) {

            TempDriver = CONTAINING_RECORD (NextEntry,
                                            RAID_DRIVER_EXTENSION,
                                            DriverLink);

            ASSERT (TempDriver != Driver);
        }
    }
#endif

    InsertHeadList (&PortData->DriverList.List, &Driver->DriverLink);
    PortData->DriverList.Count++;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return STATUS_SUCCESS;
}

NTSTATUS
RaidRemovePortDriver(
    IN PRAID_PORT_DATA PortData,
    IN PRAID_DRIVER_EXTENSION Driver
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&PortData->DriverList.Lock, &LockHandle);
    RemoveEntryList (&Driver->DriverLink);
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\global.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

	global.h

Abstract:

	Definitions and prototypes for the RAID_GLOBAL object.

Author:

	Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/

#pragma once


typedef struct _RAID_PORT_DATA {

	//
	// Refernece count for the global data object.
	//
	
	ULONG ReferenceCount;

	//
	// List of all drivers using raid port driver.
	//

	struct {
	
		LIST_ENTRY List;

		//
		// Spinlock for the driver list.
		//
	
		KSPIN_LOCK Lock;

		//
		// Count of items on the driver list.
		//
	
		ULONG Count;

	} DriverList;

} RAID_PORT_DATA, *PRAID_PORT_DATA;
    
    

//
// Public Functions
//

PRAID_PORT_DATA
RaidGetPortData(
	);

VOID
RaidReleasePortData(
	IN OUT PRAID_PORT_DATA PortData
	);

NTSTATUS
RaidAddPortDriver(
	IN PRAID_PORT_DATA PortData,
	IN PRAID_DRIVER_EXTENSION Driver
	);

NTSTATUS
RaidRemovePortDriver(
	IN PRAID_PORT_DATA PortData,
	IN PRAID_DRIVER_EXTENSION Driver
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\id.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    Id.h

Abstract:

    Data structures and functions related to STOR identification.

Author:

    Matthew D Hendel (math) 11-May-2001

Revision History:

--*/

#pragma once

typedef struct _STOR_SCSI_ADDRESS {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR Reserved;
} STOR_SCSI_ADDRESS, *PSTOR_SCSI_ADDRESS;

//
// Typedef's for older implementations
//

typedef STOR_SCSI_ADDRESS RAID_ADDRESS;
typedef PSTOR_SCSI_ADDRESS PRAID_ADDRESS;

extern const RAID_ADDRESS RaidNullAddress;

LONG
INLINE
StorScsiAddressToLong(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return (Address.PathId << 16 | Address.TargetId << 8 | Address.Lun);
}

LONG
INLINE
StorScsiAddressToLong2(
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    return ((PathId << 16) | (TargetId << 8) | Lun);
}

PVOID
INLINE
RaidAddressToKey(
    IN RAID_ADDRESS Address
    )
{
    return (PVOID) (LONG_PTR)(StorScsiAddressToLong (Address));
}



LONG
INLINE
StorCompareScsiAddress(
    IN STOR_SCSI_ADDRESS Address1,
    IN STOR_SCSI_ADDRESS Address2
    )
{
    LONG Key1;
    LONG Key2;

    Key1 = StorScsiAddressToLong (Address1);
    Key2 = StorScsiAddressToLong (Address2);

    return (Key1 - Key2);
}


UCHAR
INLINE
StorGetAddressPathId(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return Address.PathId;
}

UCHAR
INLINE
StorGetAddressTargetId(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return Address.TargetId;
}

UCHAR
INLINE
StorGetAddressLun(
    IN STOR_SCSI_ADDRESS Address
    )
{
    return Address.Lun;
}



//
// Device Identity
//

typedef struct _STOR_SCSI_IDENTITY {
    PINQUIRYDATA InquiryData;
    ANSI_STRING SerialNumber;
    PVPD_IDENTIFICATION_PAGE DeviceId;
} STOR_SCSI_IDENTITY, *PSTOR_SCSI_IDENTITY;



NTSTATUS
INLINE
StorCreateScsiIdentity(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN POOL_TYPE PoolType,
    IN PINQUIRYDATA InquiryData,
    IN PVPD_IDENTIFICATION_PAGE DeviceId,
    IN PVPD_SERIAL_NUMBER_PAGE SerialNumber,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS Status;
    
    ASSERT (Identity != NULL);

    RtlZeroMemory (Identity, sizeof (STOR_SCSI_IDENTITY));
    
    if (InquiryData != NULL) {
        Identity->InquiryData = RaidAllocatePool (PoolType,
                                                  INQUIRYDATABUFFERSIZE,
                                                  INQUIRY_TAG,
                                                  DeviceObject);
        RtlCopyMemory (Identity->InquiryData,
                       InquiryData,
                       INQUIRYDATABUFFERSIZE);
    }

    if (DeviceId != NULL) {
        Identity->DeviceId = RaidAllocatePool (PoolType,
                                               DeviceId->PageLength,
                                               INQUIRY_TAG,
                                               DeviceObject);
        RtlCopyMemory (Identity->DeviceId,
                       DeviceId,
                       DeviceId->PageLength);
    }

    if (SerialNumber != NULL) {
        Status = StorCreateAnsiString (&Identity->SerialNumber,
                                       SerialNumber->SerialNumber,
                                       SerialNumber->PageLength,
                                       NonPagedPool,            //??
                                       DeviceObject);
        if (!NT_SUCCESS (Status)) {
            return Status;
        }
    }

    return STATUS_SUCCESS;
}



VOID
INLINE
StorDeleteScsiIdentity(
    IN PSTOR_SCSI_IDENTITY Identity
    )
{
    if (Identity->InquiryData != NULL) {
        DbgFillMemory (Identity->InquiryData,
                       DBG_DEALLOCATED_FILL,
                       INQUIRYDATABUFFERSIZE);
        RaidFreePool (Identity->InquiryData, INQUIRY_TAG);
    }

    StorFreeAnsiString (&Identity->SerialNumber);

    if (Identity->DeviceId) {
        DbgFillMemory (Identity->DeviceId,
                       DBG_DEALLOCATED_FILL,
                       sizeof (*Identity->DeviceId));
        RaidFreePool (Identity->DeviceId, INQUIRY_TAG);
    }
}


LONG
INLINE
StorCompareScsiDeviceId(
    IN PVPD_IDENTIFICATION_PAGE DeviceId1,
    IN PVPD_IDENTIFICATION_PAGE DeviceId2
    )
/*++

Routine Description:

    If DeviceId1 < DeviceId2, return < 0
    If DeviceId1 > DeviceId2, return > 0
    If DeviceId2 == DeviceId2, return 0

    Note: this is a dictionary ordering. Therefore, if the device IDs
    match up to the length of the smaller (shorter) device ID, the
    larger (longer) device ID is considered larger. See below.

    (empty)
    "foo"
    "foolish"
    "foolishness"

Arguments:

    DeviceId1 - First device ID for comparison.

    DeviceId2 - Second device ID for comparison.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG Length;
    LONG Comparison;

    PAGED_CODE();

    //
    // Preserve dictionary order in the presence of NULL device IDs.
    //
    
    if (DeviceId1 == NULL && DeviceId2 == NULL) {
        return 0;
    } else if (DeviceId1 == NULL) {
        return -1;
    } else if (DeviceId2 == NULL) {
        return 1;
    }
    
    ASSERT (DeviceId1->PageCode == 0x83);
    ASSERT (DeviceId2->PageCode == 0x83);

    //
    // NB: This comparison tacitly assumes that the device IDs will not
    // for a specific device will not change at all over time, including
    // changes in the ordering that multiple device IDs are returned.
    // Presumably, there is some device that will not follow this model.
    //

    Length = min (DeviceId1->PageLength, DeviceId1->PageLength);

    Comparison = memcmp (DeviceId1, DeviceId2, Length);

    //
    // If they were equal, then the longer one is by definition "greater".
    //
    
    if (Comparison == 0) {
        if (DeviceId1->PageLength > DeviceId2->PageLength) {
            Comparison = 1;
        } else if (DeviceId1->PageLength < DeviceId2->PageLength) {
            Comparison = -1;
        }
    }

    return Comparison;
}


LONG
INLINE
StorCompareScsiIdentity(
    IN PSTOR_SCSI_IDENTITY Identity1,
    IN PSTOR_SCSI_IDENTITY Identity2
    )
{
    LONG Comparison;

    //
    // The peripherial qualifier can change without the device changing,
    // so don't include it in the comparison. This is why we do this clumsy
    // two part comparison below.
    //
    
    Comparison = memcmp (((PUCHAR)Identity1->InquiryData) + 1,
                         ((PUCHAR)Identity2->InquiryData) + 1,
                         INQUIRYDATABUFFERSIZE-1);

    if (Comparison != 0) {
        return Comparison;
    }
    
    Comparison = Identity1->InquiryData->DeviceType -
                 Identity2->InquiryData->DeviceType;
                 
    if (Comparison != 0) {
        return Comparison;
    }
    
    Comparison = RtlCompareString (&Identity1->SerialNumber,
                                   &Identity2->SerialNumber,
                                   FALSE);
    if (Comparison != 0) {
        return Comparison;
    }

    Comparison = StorCompareScsiDeviceId (Identity1->DeviceId,
                                          Identity2->DeviceId);

    return Comparison;
}


CONST PSCSI_DEVICE_TYPE
INLINE
StorGetIdentityDeviceType(
    IN PSTOR_SCSI_IDENTITY Identity
    )
{
    PINQUIRYDATA InquiryData;
    
    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    return RaGetDeviceType (InquiryData->DeviceType);
}



NTSTATUS
INLINE
StorGetIdentityVendorId(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN OUT PCHAR VendorId,
    IN ULONG VendorIdLength,
    IN LOGICAL TruncatePadding
    )
{
    ULONG Length;
    PINQUIRYDATA InquiryData;

    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    
    Length = min (VendorIdLength, sizeof (InquiryData->VendorId));

    if (TruncatePadding) {
        RaCopyPaddedString (VendorId,
                            VendorIdLength,
                            InquiryData->VendorId,
                            sizeof (InquiryData->VendorId));
    } else {

        RtlCopyMemory (VendorId,
                       InquiryData->VendorId,
                       Length);
    }

    return STATUS_SUCCESS;
}

    
NTSTATUS
INLINE
StorGetIdentityProductId(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN OUT PCHAR ProductId,
    IN ULONG ProductIdLength,
    IN LOGICAL TruncatePadding
    )
{
    ULONG Length;
    PINQUIRYDATA InquiryData;

    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    
    Length = min (ProductIdLength, sizeof (InquiryData->ProductId));

    if (TruncatePadding) {
        RaCopyPaddedString (ProductId,
                            ProductIdLength,
                            InquiryData->ProductId,
                            sizeof (InquiryData->ProductId));
    } else {

        RtlCopyMemory (ProductId,
                       InquiryData->ProductId,
                       Length);
    }

    return STATUS_SUCCESS;
}

    
NTSTATUS
INLINE
StorGetIdentityRevision(
    IN PSTOR_SCSI_IDENTITY Identity,
    IN OUT PCHAR Revision,
    IN ULONG RevisionLength,
    IN LOGICAL TruncatePadding
    )
{
    ULONG Length;
    PINQUIRYDATA InquiryData;

    InquiryData = Identity->InquiryData;
    ASSERT (InquiryData != NULL);
    
    Length = min (RevisionLength, sizeof (InquiryData->ProductRevisionLevel));

    if (TruncatePadding) {
        RaCopyPaddedString (Revision,
                            RevisionLength,
                            InquiryData->ProductRevisionLevel,
                            sizeof (InquiryData->ProductRevisionLevel));
    } else {

        RtlCopyMemory (Revision,
                       InquiryData->ProductRevisionLevel,
                       Length);
    }

    return STATUS_SUCCESS;
}

PINQUIRYDATA
INLINE
StorGetIdentityInquiryData(
    IN PSTOR_SCSI_IDENTITY Identity
    )
{
    ASSERT (Identity->InquiryData != NULL);
    return Identity->InquiryData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\ioqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioqueue.h

Abstract:

    Declaration of the raid IO_QUEUE object. This object serves much the
    same function as the standard NT IO queue associated with a driver.
    The difference is this ioqueue is built upon the EXTENDED_DEVICE_QUEUE
    object that adds support for queuing multiple entries to a device at
    the same time and for freezing and resuming the device queue.

Author:

    Matthew D Hendel (math) 22-June-2000

Revision History:

--*/

#pragma once

typedef
VOID
(*PRAID_DRIVER_STARTIO)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

typedef struct _IO_QUEUE {

    //
    // Device object this ioqueue is for.
    //
    // Protected by: read-only.
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    // StartIo routine for this ioqueue.
    //
    // Protected by: read-only.
    //
    
    
    PRAID_DRIVER_STARTIO StartIo;

    //
    // Extended device queue that implements this ioqueue.
    //
    // Protected by: DeviceQueue.
    //
    
    EXTENDED_DEVICE_QUEUE DeviceQueue;

    //
    // Flag specifying that the queue has changed in some fundamental
    // manner, like the depth has changed or the queue has been
    // resumed after a freeze.
    //
    // Protected by: interlocked access.
    //
    
    ULONG QueueChanged;
    
} IO_QUEUE, *PIO_QUEUE;


typedef
VOID
(*PIO_QUEUE_PURGE_ROUTINE)(
    IN PIO_QUEUE IoQueue,
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RaidInitializeIoQueue(
    OUT PIO_QUEUE IoQueue,
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTOR_IO_GATEWAY Gateway,
    IN PRAID_DRIVER_STARTIO StartIo,
    IN ULONG QueueDepth
    );
    
VOID
RaidStartIoPacket(
    IN PIO_QUEUE IoQueue,
    IN PIRP Irp,
    IN BOOLEAN ByPassRequest,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );

LOGICAL
RaidStartNextIoPacket(
    IN PIO_QUEUE IoQueue,
    IN BOOLEAN Cancleable,
    IN PVOID Context,
    OUT PBOOLEAN RestartQueues
    );

VOID
RaidFreezeIoQueue(
    IN PIO_QUEUE IoQueue
    );

VOID
RaidResumeIoQueue(
    IN PIO_QUEUE IoQueue
    );

PIRP
RaidRemoveIoQueue(
    IN PIO_QUEUE IoQueue
    );

VOID
RaidRestartIoQueue(
    IN PIO_QUEUE IoQueue
    );

VOID
RaidPurgeIoQueue(
    IN PIO_QUEUE IoQueue,
    IN PIO_QUEUE_PURGE_ROUTINE PurgeRoutine,
    IN PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\ioqueue.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ioqueue.c

Abstract:

    Implementation of the raid IO_QUEUE object.

Author:

    Matthew D Hendel (math) 22-June-2000

Revision History:

Comments:

    The IoQueue class serves basically the same function as the NT I/O
    queue that is a part of the driver's device object. We use a
    different queue because SCSI has different serialization requirements
    than the standard NT driver model supports. (See the
    EXTENDED_DEVICE_QUEUE object for more information on these differences.)

Future:

    We may want to consider is integrating the EXTENDED_DEVICE_QUEUE
    class and the IO_QUEUE class into the same class. Though logically,
    these can be implemented separately (as they are done in the kernel)
    we may be able to get performance enhancements and code quality
    improvements by putting these in the same class. The only interface
    the port driver is concerned with is the IO_QUEUE interface.

    It would be nice if resource allocation (of queue tags) and the IO
    queue were more closely integrated. As it is, the tag allocation and
    the IO queue both primarily track the number of outstanding requests
    and there is some danger that these numbers could get out of sync.

--*/



#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidInitializeIoQueue)
#pragma alloc_text(PAGE, RaidRemoveIoQueue)
#endif // ALLOC_PRAGMA



#if DBG
VOID
ASSERT_IO_QUEUE(
    PIO_QUEUE IoQueue
    )
{
    ASSERT (IoQueue->DeviceObject != NULL);
    ASSERT (IoQueue->StartIo != NULL);
    ASSERT (IoQueue->QueueChanged == TRUE ||
            IoQueue->QueueChanged == FALSE);
}
#else
#define ASSERT_IO_QUEUE(IoQueue)
#endif

VOID
RaidInitializeIoQueue(
    OUT PIO_QUEUE IoQueue,
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTOR_IO_GATEWAY Gateway,
    IN PRAID_DRIVER_STARTIO StartIo,
    IN ULONG QueueDepth
    )
/*++

Routine Description:

    Initialize an IO_QUEUE object.

Arguments:

    IoQueue - Supplies a pointer to the IO_QUEUE object to initialize.

    DeviceObject - Supplies a pointer to a device object that this
            IoQueue is for.

    Gateway - Supplies the IO Gateway to manage the interaction between
            the different device queues.

    StartIo - Supplies a pointer to a StartIo function that will be
            called when there are irps that need to be handled.

    QueueDepth - Supplies the initial queue depth for the IoQueue. This
            value can by dynamically changed at a later time.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();
    
    IoQueue->DeviceObject = DeviceObject;
    IoQueue->StartIo = StartIo;
    IoQueue->QueueChanged = FALSE;

    RaidInitializeExDeviceQueue (&IoQueue->DeviceQueue,
                                 Gateway,
                                 QueueDepth,
                                 CScanScheduling);
}

    
VOID
RaidStartIoPacket(
    IN PIO_QUEUE IoQueue,
    IN PIRP Irp,
    IN BOOLEAN ByPassRequest,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    )
/*++

Routine Description:

    Attempt to start an IO Request for this driver. If resources are
    available, the IoQueue's StartIo routine will be executed
    synchronously before RaidStartIoPacket returns. Otherwise the request
    will be queued until resources are available.

Arguments:

    IoQueue - IoQueue this IO is for.

    Irp - Irp to execute.

    ByPassRequest - TRUE if this request is a bypass request, FALSE
            if this request is a normal request.

    CancelFunction - Pointer to a cancelation function for the associated
            IRP.

Return Value:

    NTSTATUS code.

--*/
{
    KIRQL OldIrql;
    KIRQL CancelIrql;
    BOOLEAN Inserted;
    PSCSI_REQUEST_BLOCK Srb;
    
    //
    // NB: Cancelation is NYI
    //
    
    ASSERT_IO_QUEUE (IoQueue);
    ASSERT (CancelFunction == NULL);

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);
    
    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);

    //
    // Mark the irp as awaiting resources until we can execute
    // the startio routine.
    //
    
    RaidSetIrpState (Irp, RaidPendingResourcesIrp);
    
    Inserted = RaidInsertExDeviceQueue (&IoQueue->DeviceQueue,
                                        &Irp->Tail.Overlay.DeviceQueueEntry,
                                        ByPassRequest,
                                        Srb->QueueSortKey);

    if (!Inserted) {

        //
        // Mark it as not having waited on resources. This makes it
        // possible to figure out whether we waited in the IO queue or
        // not.
        //
        
        RaidSetIrpState (Irp, RaidPortProcessingIrp);
        IoQueue->StartIo (IoQueue->DeviceObject, Irp, NULL);

    } else {

        //
        // BUGBUG: Cancel logic here.
        //
    }

    KeLowerIrql (OldIrql);
}

    
LOGICAL
RaidStartNextIoPacket(
    IN PIO_QUEUE IoQueue,
    IN BOOLEAN Cancelable,
    IN PVOID Context,
    OUT PBOOLEAN RestartQueue
    )
/*++

Routine Description:

    StartNextPacket dequeues the next IRP on the IoQueue (if any), and
    calls the IoQueue's StartIo routine for that IRP.

    In addition, if the IoQueue has changed, this routine will remove any
    "extra" items from the device queue and call the IoQueue's StartIo
    routine for those extra items. In this sense, "extra" items on the io
    queue are items on the queue when the queue is not busy. This happens
    when the io queue is increased in size while it's busy, or when the
    queue is frozen and items get queued to it, and then it's resumed.
    
Arguments:

    IoQueue -

    Cancelable -

    Context -

Return Value:

    TRUE - If we started the next io operation.

    FALSE - Otherwise.

--*/
{
    PIRP Irp;
    KIRQL CancelIrql;
    PKDEVICE_QUEUE_ENTRY Packet;
    LOGICAL Started;
    
    //
    // NB: Cancelation is NYI
    //

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);
    ASSERT (Cancelable == FALSE);

    Started = FALSE;
    
    //
    // If the queue has changed, remove any extra elements on the queue.
    // Extra queue elements can exist on a queue that has been frozen and
    // resumed or when the queue depth increased. In either of these
    // cases, the queue can be in the ready state, but have elements on
    // either the device or bypass queue. In either of these cases, we
    // need to do the same thing: pull elements off of the queue until
    // there are no more elements in the queue or until we have saturated
    // the device (are in the busy state).
    //
    
    if (InterlockedExchange (&IoQueue->QueueChanged, FALSE)) {

        for (Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue);
             Packet != NULL;
             Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue)) {

            REVIEW();

            Irp = CONTAINING_RECORD (Packet,
                                     IRP,
                                     Tail.Overlay.DeviceQueueEntry);

            IoQueue->StartIo (IoQueue->DeviceObject, Irp, NULL);
        }
    }

    //
    // Remove the next entry from the device queue, and call StartIo
    // with that entry.
    //
    
    Packet = RaidRemoveExDeviceQueue (&IoQueue->DeviceQueue, RestartQueue);

    if (Packet) {
        Irp = CONTAINING_RECORD (Packet,
                                 IRP,
                                 Tail.Overlay.DeviceQueueEntry);

        ASSERT (Irp->Type == IO_TYPE_IRP);
        IoQueue->StartIo (IoQueue->DeviceObject, Irp, Context);
        Started = TRUE;
    }

    return Started;
}

VOID
RaidFreezeIoQueue(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    Freeze the IoQueue. After the IoQueue has been frozen, only bypass
    requests will be executed.

Arguments:

    IoQueue - IoQueue to freeze.

Return Value:

    None.

--*/
{
    //
    // Freeze the underlying device queue object.
    //
    
    RaidFreezeExDeviceQueue (&IoQueue->DeviceQueue);
}


VOID
RaidResumeIoQueue(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    Resume a frozen IoQueue.

Arguments:

    IoQueue - IoQueue to resume.

Return Value:

    None.

--*/
{
    RaidResumeExDeviceQueue (&IoQueue->DeviceQueue);
    InterlockedExchange (&IoQueue->QueueChanged, TRUE);
}


PIRP
RaidRemoveIoQueue(
    IN PIO_QUEUE IoQueue
    )
/*++

Routine Description:

    If there is a non-bypass element on the device queue, remove and
    return it, otherwise, return NULL.

Arguments:

    IoQueue - Supplies the IoQueue to remove the entry from.

Return Value:

    NULL - If there are no more entries in the non-bypass queue.

    Non-NULL - Supplies a pointer to an IRP removed from the device
            queue.

--*/
{
    PKDEVICE_QUEUE_ENTRY Packet;
    PIRP Irp;

    Packet = RaidRemoveExDeviceQueueIfPending (&IoQueue->DeviceQueue);

    if (Packet) {
        Irp = CONTAINING_RECORD (Packet,
                                 IRP,
                                 Tail.Overlay.DeviceQueueEntry);
    } else {
        Irp = NULL;
    }

    return Irp;
}



VOID
RaidRestartIoQueue(
    IN PIO_QUEUE IoQueue
    )
{
    PKDEVICE_QUEUE_ENTRY Packet;
    PIRP Irp;
    
    //
    // NOTE: As an optimization, we should have ReinsertExDeviceQueue
    // return a boolean telling whether we did not normalize because
    // (1) there were no elements or (2) the adapter was busy. Returning
    // this boolean to the caller will give it the ability to stop
    // restarting queues in the unit list if the adapter can accept
    // no more requests.
    //
    
    Packet = RaidNormalizeExDeviceQueue (&IoQueue->DeviceQueue);

    if (Packet) {
        Irp = CONTAINING_RECORD (Packet,
                                 IRP,
                                 Tail.Overlay.DeviceQueueEntry);

        IoQueue->StartIo (IoQueue->DeviceObject, Irp, NULL);
    }
}

    
VOID
RaidPurgeIoQueue(
    IN PIO_QUEUE IoQueue,
    IN PIO_QUEUE_PURGE_ROUTINE PurgeRoutine,
    IN PVOID Context
    )
{
    PIRP Irp;
    
    ASSERT (PurgeRoutine != NULL);
    
    for (Irp = RaidRemoveIoQueue (IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (IoQueue)) {

         PurgeRoutine (IoQueue, Context, Irp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\inline.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	inline.h

Abstract:

	Implementations of inline functions for RAID port driver.

Author:

	Matthew D Hendel (math) 08-June-2000

Revision History:

--*/

#pragma once


//
// Functions for the RAID_FIXED_POOL object.
// 

//
// NB: We should modify the fixed pool to detect overruns and underruns
// in checked builds.
//

VOID
INLINE
RaidInitializeFixedPool(
	OUT PRAID_FIXED_POOL Pool,
	IN PVOID Buffer,
	IN ULONG NumberOfElements,
	IN SIZE_T SizeOfElement
	)
{
	PAGED_CODE ();

	ASSERT (Buffer != NULL);
	
	DbgFillMemory (Buffer,
				   SizeOfElement * NumberOfElements,
				   DBG_DEALLOCATED_FILL);
	Pool->Buffer = Buffer;
	Pool->NumberOfElements = NumberOfElements;
	Pool->SizeOfElement = SizeOfElement;
}

VOID
INLINE
RaidDeleteFixedPool(
	IN PRAID_FIXED_POOL Pool
	)
{
	//
	// The caller is responsible for deleting the memory in the pool, hence
	// this routine is a noop.
	//
}


PVOID
INLINE
RaidGetFixedPoolElement(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG Index
	)
{
	PVOID Element;

	ASSERT (Index < Pool->NumberOfElements);
	Element = (((PUCHAR)Pool->Buffer) + Index * Pool->SizeOfElement);

	return Element;
}


PVOID
INLINE
RaidAllocateFixedPoolElement(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG Index
	)
{
	PVOID Element;

	Element = RaidGetFixedPoolElement (Pool, Index);
	ASSERT (*(PUCHAR)Element == DBG_DEALLOCATED_FILL);
	DbgFillMemory (Element,
				   Pool->SizeOfElement,
				   DBG_UNINITIALIZED_FILL);

	return Element;
}

VOID
INLINE
RaidFreeFixedPoolElement(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG Index
	)
{
	PUCHAR Element;
	
	Element = (((PUCHAR)Pool->Buffer) + Index * Pool->SizeOfElement);
	
	DbgFillMemory (Element,
				   Pool->SizeOfElement,
				   DBG_DEALLOCATED_FILL);
}



//
// Operations for the adapter object.
//

ULONG
INLINE
RiGetNumberOfBuses(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);
    return Adapter->Miniport.PortConfiguration.NumberOfBuses;
}

ULONG
INLINE
RaGetSrbExtensionSize(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);

	//
	// Force Srb extension alignment to 64KB boundaries.
	//
	
    return ALIGN_UP (Adapter->Miniport.PortConfiguration.SrbExtensionSize,
					 LONGLONG);
}

ULONG
INLINE
RiGetMaximumTargetId(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);
    return Adapter->Miniport.PortConfiguration.MaximumNumberOfTargets;
}

ULONG
INLINE
RiGetMaximumLun(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    ASSERT (Adapter != NULL);
    return Adapter->Miniport.PortConfiguration.MaximumNumberOfLogicalUnits;
}
    



//
// Inline functions for the RAID_MINIPORT object.
//


PRAID_ADAPTER_EXTENSION
INLINE
RaMiniportGetAdapter(
    IN PRAID_MINIPORT Miniport
    )
{
    ASSERT (Miniport != NULL);
    return Miniport->Adapter;
}


BOOLEAN
INLINE
RaCallMiniportStartIo(
    IN PRAID_MINIPORT Miniport,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
	BOOLEAN Succ;
	
    ASSERT (Miniport != NULL);
    ASSERT (Srb != NULL);
    ASSERT (Miniport->HwInitializationData->HwStartIo != NULL);

	ASSERT_XRB (Srb->OriginalRequest);

	Succ = Miniport->HwInitializationData->HwStartIo(
				&Miniport->PrivateDeviceExt->HwDeviceExtension,
				Srb);

	return Succ;
}

BOOLEAN
INLINE
RaCallMiniportBuildIo(
	IN PRAID_MINIPORT Miniport,
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	BOOLEAN Succ;
	
	ASSERT_XRB (Srb->OriginalRequest);

	//
	// If a HwBuildIo routine is present, call into it, otherwise,
	// vacuously return success.
	//
	
	if (Miniport->HwInitializationData->HwBuildIo) {
		Succ = Miniport->HwInitializationData->HwBuildIo (
					&Miniport->PrivateDeviceExt->HwDeviceExtension,
					Srb);
	} else {
		Succ = TRUE;
	}

	return Succ;
}
				

BOOLEAN
INLINE
RaCallMiniportInterrupt(
    IN PRAID_MINIPORT Miniport
    )
{
	BOOLEAN Succ;
	
	ASSERT (Miniport != NULL);
	ASSERT (Miniport->HwInitializationData->HwInterrupt != NULL);
	
	Succ = Miniport->HwInitializationData->HwInterrupt (
				&Miniport->PrivateDeviceExt->HwDeviceExtension);

	return Succ;

}

NTSTATUS
INLINE
RaCallMiniportHwInitialize(
    IN PRAID_MINIPORT Miniport
    )
{
    BOOLEAN Succ;
    PHW_INITIALIZE HwInitialize;

    ASSERT (Miniport != NULL);
    
    HwInitialize = Miniport->HwInitializationData->HwInitialize;
    ASSERT (HwInitialize != NULL);

    Succ = HwInitialize (&Miniport->PrivateDeviceExt->HwDeviceExtension);

    return RaidNtStatusFromBoolean (Succ);
}

NTSTATUS
INLINE
RaCallMiniportStopAdapter(
	IN PRAID_MINIPORT Miniport
	)
{
	SCSI_ADAPTER_CONTROL_STATUS ControlStatus;
	ASSERT (Miniport != NULL);

	ASSERT (Miniport->HwInitializationData->HwAdapterControl != NULL);

	ControlStatus = Miniport->HwInitializationData->HwAdapterControl(
						&Miniport->PrivateDeviceExt->HwDeviceExtension,
						ScsiStopAdapter,
						NULL);

	return (ControlStatus == ScsiAdapterControlSuccess ? STATUS_SUCCESS :
							                             STATUS_UNSUCCESSFUL);
}

NTSTATUS
INLINE
RaCallMiniportResetBus(
	IN PRAID_MINIPORT Miniport,
	IN UCHAR PathId
	)
{
	BOOLEAN Succ;
	
	ASSERT (Miniport != NULL);

	ASSERT (Miniport->HwInitializationData->HwResetBus != NULL);

	Succ = Miniport->HwInitializationData->HwResetBus(
						&Miniport->PrivateDeviceExt->HwDeviceExtension,
						PathId);

	return (Succ ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


//
// Misc inline functions
//


PRAID_MINIPORT
INLINE
RaHwDeviceExtensionGetMiniport(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

	Get the miniport associated with a specific HwDeviceExtension.

Arguments:

	HwDeviceExtension - Device extension to get the miniport for.

Return Value:

	Pointer to a RAID miniport object on success.

	NULL on failure.

--*/
{
    PRAID_HW_DEVICE_EXT PrivateDeviceExt;

    ASSERT (HwDeviceExtension != NULL);

	PrivateDeviceExt = CONTAINING_RECORD (HwDeviceExtension,
                                          RAID_HW_DEVICE_EXT,
                                          HwDeviceExtension);
    ASSERT (PrivateDeviceExt->Miniport != NULL);
    return PrivateDeviceExt->Miniport;
}




VOID
INLINE
RaidSrbMarkPending(
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	Srb->SrbStatus = SRB_STATUS_PENDING;
}

ULONG
INLINE
RaidMinorFunctionFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT (Irp != NULL);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->MinorFunction;
}

ULONG
INLINE
RaidMajorFunctionFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT (Irp != NULL);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->MajorFunction;
}

ULONG
INLINE
RaidIoctlFromIrp(
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpStack;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_DEVICE_CONTROL);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    return IrpStack->Parameters.DeviceIoControl.IoControlCode;
}


PEXTENDED_REQUEST_BLOCK
INLINE
RaidXrbFromIrp(
	IN PIRP Irp
	)
{
	return (RaidGetAssociatedXrb (RaidSrbFromIrp (Irp)));
}


PSCSI_REQUEST_BLOCK
INLINE
RaidSrbFromIrp(
	IN PIRP Irp
	)
{
	PIO_STACK_LOCATION IrpStack;

	ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

	IrpStack = IoGetCurrentIrpStackLocation (Irp);
	return IrpStack->Parameters.Scsi.Srb;
}

UCHAR
INLINE
RaidSrbFunctionFromIrp(
    IN PIRP Irp
    )
{
	return RaidSrbFromIrp (Irp)->Function;
}

UCHAR
INLINE
RaidScsiOpFromIrp(
	IN PIRP Irp
	)
{
	PCDB Cdb;
	PSCSI_REQUEST_BLOCK Srb;

	Srb = RaidSrbFromIrp (Irp);
	Cdb = (PCDB) &Srb->Cdb;

	return Cdb->CDB6GENERIC.OperationCode;
}
	

NTSTATUS
INLINE
RaidNtStatusFromScsiStatus(
    IN ULONG ScsiStatus
    )
{
    switch (ScsiStatus) {
        case SRB_STATUS_PENDING: return STATUS_PENDING;
        case SRB_STATUS_SUCCESS: return STATUS_SUCCESS;
        default:                 return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
INLINE
RaidNtStatusFromBoolean(
    IN BOOLEAN Succ
    )
{
    return (Succ ?  STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


//
// From common.h
//

INLINE
RAID_OBJECT_TYPE
RaGetObjectType(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PRAID_COMMON_EXTENSION Common;

    ASSERT (DeviceObject != NULL);
    Common = (PRAID_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (Common->ObjectType == RaidAdapterObject ||
            Common->ObjectType == RaidUnitObject ||
            Common->ObjectType == RaidDriverObject);

    return Common->ObjectType;
}

INLINE
BOOLEAN
IsAdapter(
    IN PVOID Extension
    )
{
    return (RaGetObjectType (Extension) == RaidAdapterObject);
}

    
INLINE
BOOLEAN
IsDriver(
    IN PVOID Extension
    )
{
    return (RaGetObjectType (Extension) == RaidDriverObject);
}

    
INLINE
BOOLEAN
IsUnit(
    IN PVOID Extension
    )
{
    return (RaGetObjectType (Extension) == RaidUnitObject);
}

    

//
// From power.h
//

VOID
INLINE
RaInitializePower(
    IN PRAID_POWER_STATE Power
    )
{
}

VOID
INLINE
RaSetDevicePowerState(
    IN PRAID_POWER_STATE Power,
    IN DEVICE_POWER_STATE DeviceState
    )
{
    ASSERT (Power != NULL);
    Power->SystemState = DeviceState;
}

VOID
INLINE
RaSetSystemPowerState(
    IN PRAID_POWER_STATE Power,
    IN SYSTEM_POWER_STATE SystemState
    )
{
    ASSERT (Power != NULL);
    Power->SystemState = SystemState;
}

POWER_STATE_TYPE
INLINE
RaidPowerTypeFromIrp(
	IN PIRP Irp
	)
{
	PIO_STACK_LOCATION IrpStack;
	
	ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
	ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_QUERY_POWER ||
			RaidMinorFunctionFromIrp (Irp) == IRP_MN_SET_POWER);

	IrpStack = IoGetCurrentIrpStackLocation (Irp);

	return IrpStack->Parameters.Power.Type;
}

POWER_STATE
INLINE
RaidPowerStateFromIrp(
	IN PIRP Irp
	)
{
	PIO_STACK_LOCATION IrpStack;
	
	ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
	ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_QUERY_POWER ||
			RaidMinorFunctionFromIrp (Irp) == IRP_MN_SET_POWER);

	IrpStack = IoGetCurrentIrpStackLocation (Irp);

	return IrpStack->Parameters.Power.State;
}

//
// From srb.h
//

PEXTENDED_REQUEST_BLOCK
INLINE
RaidGetAssociatedXrb(
	IN PSCSI_REQUEST_BLOCK Srb
	)
/*++

Routine Description:

	Get the XRB associated with the SRB parameter.

Arguments:

	Srb - Srb whose associated XRB is to be returned.

Return Value:

	The XRB associated with this SRB, or NULL if there is none.

--*/
{
	ASSERT_XRB (Srb->OriginalRequest);
	return (PEXTENDED_REQUEST_BLOCK) Srb->OriginalRequest;
}

VOID
INLINE
RaSetAssociatedXrb(
	IN PSCSI_REQUEST_BLOCK Srb,
	IN PEXTENDED_REQUEST_BLOCK Xrb
	)
{
	Srb->OriginalRequest = Xrb;
}
	


//
// From resource.h
//


ULONG
INLINE
RaidGetResourceListCount(
    IN PRAID_RESOURCE_LIST ResourceList
    )
{
	//
	// NB: We only support CM_RESOURCE_LIST's with one element.
	//
	
	ASSERT (ResourceList->AllocatedResources->Count == 1);
    return ResourceList->AllocatedResources->List[0].PartialResourceList.Count;
}


VOID
INLINE
RaidpGetResourceListIndex(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG Index,
    OUT PULONG ListNumber,
    OUT PULONG NewIndex
    )
{

	//
	// NB: We only support CM_RESOURCE_LIST's with one element.
	//

	ASSERT (ResourceList->AllocatedResources->Count == 1);
	
    *ListNumber = 0;
    *NewIndex = Index;
}

LOGICAL
INLINE
IsMappedSrb(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (Srb->Function == SRB_FUNCTION_IO_CONTROL);
}

LOGICAL
INLINE
IsExcludedFromMapping(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    //
    // We never map system VA to back read and write requests. If you need
    // this functionality, get a better adapter.
    //
    
    if (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI &&
        (Srb->Cdb[0] == SCSIOP_READ || Srb->Cdb[0] == SCSIOP_WRITE)) {
        return TRUE;
    } else {
        return FALSE;
    }
}


LOGICAL
INLINE
RaidAdapterRequiresMappedBuffers(
    IN PRAID_ADAPTER_EXTENSION Adapter
    )
{
    return (Adapter->Miniport.PortConfiguration.MapBuffers);
}


VOID
INLINE
InterlockedAssign(
	IN PLONG Destination,
	IN LONG Value
	)
/*++

Routine Description:

	Interlocked assignment routine. This routine doesn't add anything
	over doing straight assignment, but it highlights that this variable
	is accessed through interlocked operations.

	In retail, this will compile to nothing.

Arguments:

	Destination - Pointer of interlocked variable to is to be assigned to.

	Value - Value to assign.

Return Value:

	None.

--*/
{
	*Destination = Value;
}

LONG
INLINE
InterlockedQuery(
	IN PULONG Destination
	)
/*++

Routine Description:

	Interlocked query routine. This routine doesn't add anything over
	doing stright query, but it highlights that this variable is accessed
	through interlocked operations.

	In retail, this will compile to nothing.

Arguments:

	Destination - Pointer to interlocked variable that is to be returned.

Return Value:

	Value of interlocked variable.

--*/
{
	return *Destination;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\miniport.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    Implementation of the RAID_MINIPORT object.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateMiniport)
#pragma alloc_text(PAGE, RaDeleteMiniport)
#pragma alloc_text(PAGE, RaInitializeMiniport)
#pragma alloc_text(PAGE, RaInitializeMiniport)
#pragma alloc_text(PAGE, RiAllocateMiniportDeviceExtension)
#endif // ALLOC_PRAGMA


VOID
RaCreateMiniport(
    OUT PRAID_MINIPORT Miniport
    )
/*++

Routine Description:

    Create a miniport object and initialize it to a null state.

Arguments:

    Miniport - Pointer to the miniport to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (Miniport != NULL);

    RaCreateConfiguration (&Miniport->PortConfiguration);
    Miniport->HwInitializationData = NULL;
    Miniport->PrivateDeviceExt = NULL;
    Miniport->Adapter = NULL;
}


VOID
RaDeleteMiniport(
    IN PRAID_MINIPORT Miniport
    )

/*++

Routine Description:

    Delete and deallocate any resources associated with teh
    miniport object.

Arguments:

    Miniport - Pointer to the miniport to delete.

Return Value:

    None.

--*/

{
    PAGED_CODE ();
    ASSERT (Miniport != NULL);
    
    RaDeleteConfiguration (&Miniport->PortConfiguration);
    Miniport->HwInitializationData = NULL;
    Miniport->Adapter = NULL;

    if (Miniport->PrivateDeviceExt != NULL) {
        ExFreePoolWithTag (Miniport->PrivateDeviceExt,
                           MINIPORT_EXT_TAG);
        Miniport->PrivateDeviceExt = NULL;
    }
}


NTSTATUS
RaInitializeMiniport(
    IN OUT PRAID_MINIPORT Miniport,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN PRAID_ADAPTER_EXTENSION Adapter,
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG BusNumber
    )
/*++

Routine Description:

    Initialize a miniport object.

Arguments:

    Miniport - Pointer to the miniport to initialize.

    HwInitializationData - The hardware initialization data
            passed in when this device called ScsiPortInitialize.

    Adapter - Pointer to the parent adapter that owns this
            miniport.

    ResourceList - The resources assigned to this device.

    BusNumber - The bus this device is on.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    SIZE_T ExtensionSize;
    
    PAGED_CODE ();
    ASSERT (Miniport != NULL);
    ASSERT (HwInitializationData != NULL);
    ASSERT (Adapter != NULL);
    ASSERT (ResourceList != NULL);
    ASSERT (BusNumber != -1);

    PAGED_CODE ();

    Miniport->Adapter = Adapter;
    Miniport->HwInitializationData = HwInitializationData;

    Status = RiAllocateMiniportDeviceExtension (Miniport);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize a port configuration object for the adapter
    // This will need to be in a RW buffer, because the miniport
    // may modify it.
    //

    Status = RaInitializeConfiguration (&Miniport->PortConfiguration,
                                        HwInitializationData,
                                        BusNumber);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    
    Status = RaAssignConfigurationResources (&Miniport->PortConfiguration,
                                             ResourceList->AllocatedResources,
                                             HwInitializationData->NumberOfAccessRanges);
    
    return Status;
}

NTSTATUS
RiAllocateMiniportDeviceExtension(
    IN PRAID_MINIPORT Miniport
    )
/*++

Routine Description:

    Allocate a miniport device extension.

Arguments:

    Miniport - Pointer to the miniport to allocate the device
            extension for.

Return Value:

    NTSTATUS code

--*/
{
    SIZE_T ExtensionSize;

    PAGED_CODE ();
    ASSERT (Miniport != NULL);

    ASSERT (Miniport->PrivateDeviceExt == NULL);
    
    ExtensionSize = FIELD_OFFSET (RAID_HW_DEVICE_EXT, HwDeviceExtension) +
                    Miniport->HwInitializationData->DeviceExtensionSize;

    Miniport->PrivateDeviceExt = ExAllocatePoolWithTag (NonPagedPool,
                                                         ExtensionSize,
                                                         MINIPORT_EXT_TAG );

    if (Miniport->PrivateDeviceExt == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (Miniport->PrivateDeviceExt, ExtensionSize);
    Miniport->PrivateDeviceExt->Miniport = Miniport;

    return STATUS_SUCCESS;
}


NTSTATUS
RaCallMiniportFindAdapter(
    IN PRAID_MINIPORT Miniport
    )
/*++

Routine Description:

    Call the miniport's FindAdapter routine.

Arguments:

    Miniport - Miniport to call FindAdapter on.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS NtStatus;
    ULONG Status;
    BOOLEAN CallAgain;
    PPORT_CONFIGURATION_INFORMATION PortConfig;

    ASSERT (Miniport != NULL);
    ASSERT (Miniport->HwInitializationData->HwFindAdapter != NULL);
    
    PortConfig = &Miniport->PortConfiguration;
    CallAgain = FALSE;
    Status = Miniport->HwInitializationData->HwFindAdapter(
                    &Miniport->PrivateDeviceExt->HwDeviceExtension,
                    NULL,
                    NULL,
                    "", // BUGBUG: Use saved parameter string.
                    PortConfig,
                    &CallAgain);


    //
    // Only support adapters that do bus mastering DMA and have
    // reasonable scatter/gather support.
    //
    
    if (!PortConfig->NeedPhysicalAddresses ||
        !PortConfig->TaggedQueuing ||
        !PortConfig->ScatterGather ||
        !PortConfig->Master) {

        DebugPrint (("Legacy Device is not supported:\n"));
        DebugPrint (("Device does not support Bus Master DMA or Scatter/Gather\n"));
        NtStatus = STATUS_NOT_SUPPORTED;
    } else {
        NtStatus = RaidNtStatusFromScsiStatus (Status);
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\port.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This module defines the miniport -> port interface the
    StorPort minidriver uses to communicate with the driver.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/


#include "precomp.h"




//
// Globals
//

//
// StorMiniportQuiet specifies whether we ignore print out miniport debug
// prints (FALSE) or not (TRUE). This is important for miniports that
// print out excessive debugging information.
//

#if DBG
LOGICAL StorMiniportQuiet = FALSE;
#endif


//
// Private functions
//

PRAID_ADAPTER_EXTENSION
RaidpPortGetAdapter(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Get the adapter from the HW Device extension.

Arguments:

    HwDeviceExtension - HW Device extension.

Return Value:

    Non-NULL - Adapter object.

    NULL - If the associated adapter extension could not be found.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_MINIPORT Miniport;
    
    Miniport = RaHwDeviceExtensionGetMiniport(HwDeviceExtension);
    Adapter = RaMiniportGetAdapter (Miniport);

    return Adapter;
}


//
// Public functions
//


BOOLEAN
StorPortPause(
    IN PVOID HwDeviceExtension,
    IN ULONG Timeout
    )
/*++

Routine Description:

    Pause an adapter for some period of time. All requests to the adapter
    will be held until the timeout expires or the device resumes.  All
    requests to all targets attached to the HBA will be held until the
    target is resumed or the timeout expires.

    Since the pause and resume functions have to wait until the processor
    has returned to DISPATCH_LEVEL to execute, they are not particularly
    fast.

Arguments:

    HwDeviceExtension - Device extension of the Adapter to pause.

    Timeout - Time out in (Seconds?) when the device should be resumed.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);
    Item->Type = RaidDeferredPause;
    Item->Pause.Timeout = Timeout;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}



BOOLEAN
StorPortResume(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Resume a paused adapter.

Arguments:

    HwDeviceExtension - Device extension of the adapter to pause.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredResume;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

BOOLEAN
StorPortPauseDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Timeout
    )
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredResume;
    Item->PathId = PathId;
    Item->TargetId = TargetId;
    Item->Lun = Lun;
    Item->Pause.Timeout = Timeout;
    
    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

BOOLEAN
StorPortResumeDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredResume;
    Item->PathId = PathId;
    Item->TargetId = TargetId;
    Item->Lun = Lun;
    
    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

    
BOOLEAN
StorPortDeviceBusy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG RequestsToComplete
    )
/*++

Routine Description:

    Notify the port driver that the specified target is currently busy
    handling outstanding requests. The port driver will not issue any new
    requests to the logical unit until the logical unit's queue has been
    drained to a sufficient level where processing may continue.

    This is not considered an erroneous condition; no error log is
    generated.
    
Arguments:

    HwDeviceExtension -
    
    PathId -
    
    TargetId -
    
    Lun -
    
    ReqsToComplete - 

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }
    
    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredDeviceBusy;
    Item->PathId = PathId;
    Item->TargetId = TargetId;
    Item->Lun = Lun;
    Item->DeviceBusy.RequestsToComplete = RequestsToComplete;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


BOOLEAN
StorPortDeviceReady(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
/*++

Routine Description:

    Notify the port driver that the device is again ready to handle new
    requests. It is not generally necessary to notify the target
    that new request are desired.

Arguments:

    HwDeviceExtension -

    PathId - 

    TargetId -

    Lun -

Return Value:

    TRUE on success, FALSE on failure.
    
--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }
    

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredDeviceReady;
    Item->PathId = PathId;
    Item->TargetId = TargetId;
    Item->Lun = Lun;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


BOOLEAN
StorPortBusy(
    IN PVOID HwDeviceExtension,
    IN ULONG RequestsToComplete
    )
/*++

Routine Description:

    Notify the port driver thet the HBA is currenlty busy handling
    outstanding requests. The port driver will hold any requests until
    the HBA has completed enough outstanding requests so that it may
    continue processing requests.

Arguments:

    HwDeviceExtension -

    ReqsToComplete -

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredBusy;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}

BOOLEAN
StorPortReady(
    IN PVOID HwDeviceExtension
    )
/*++

Routine Description:

    Notify the port driver that the HBA is no longer busy.

Arguments:

    HwDeviceExtension - 
    
Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PRAID_DEFERRED_HEADER Entry;
    PRAID_DEFERRED_ELEMENT Item;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    Entry = RaidAllocateDeferredItem (&Adapter->DeferredQueue);

    if (Entry == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
        return FALSE;
    }

    Item = CONTAINING_RECORD (Entry, RAID_DEFERRED_ELEMENT, Header);

    Item->Type = RaidDeferredReady;

    RaidQueueDeferredItem (&Adapter->DeferredQueue, &Item->Header);

    return TRUE;
}


typedef struct _SYNCHRONIZED_ACCESS_PARAMETERS {
    IN PVOID HwDeviceExtension;
    IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine;
    IN PVOID Context;
} SYNCHRONIZED_ACCESS_PARAMETERS, *PSYNCHRONIZED_ACCESS_PARAMETERS;



BOOLEAN
PortSynchronizeForMiniport(
    IN PVOID Context
    )
{
    PSYNCHRONIZED_ACCESS_PARAMETERS Parameters;

    Parameters = (PSYNCHRONIZED_ACCESS_PARAMETERS)Context;

    return Parameters->SynchronizedAccessRoutine (
                &Parameters->HwDeviceExtension,
                Parameters->Context);
}
                                
BOOLEAN
StorPortSynchronizeAccess(
    IN PVOID HwDeviceExtension,
    IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine,
    IN PVOID Context
    )
{
    BOOLEAN Succ;
    PRAID_ADAPTER_EXTENSION Adapter;
    SYNCHRONIZED_ACCESS_PARAMETERS Parameters;

    //
    // BUGBUG: At this time we should not call this routine from
    // the HwBuildIo routine.
    // 

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return FALSE;
    }

    if (Adapter->IoModel == StorSynchronizeHalfDuplex) {

        Succ = SynchronizedAccessRoutine (HwDeviceExtension, Context);

    } else {

        ASSERT (Adapter->IoModel == StorSynchronizeFullDuplex);

        //
        // In full duplex mode, we have to explicitly synchronize access
        // with the interrupt. Note that in this case the StartIo lock
        // is already being held, so we we've defined a lock heirarchy
        // were start-IO lock proceeds interrupt spinlock.
        //
        
        Parameters.HwDeviceExtension = HwDeviceExtension;
        Parameters.SynchronizedAccessRoutine = SynchronizedAccessRoutine;
        Parameters.Context = Context;
    
        Succ = KeSynchronizeExecution (Adapter->Interrupt,
                                       PortSynchronizeForMiniport,
                                       &Parameters);
    }
        
    return Succ;
}



PSTOR_SCATTER_GATHER_LIST
StorPortGetScatterGatherList(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Return the SG list associated with the specified SRB.

Arguments:

    HwDeviceExtension - Supplies the HW device extension this SRB is
        assoicated with.

    Srb - Supplies the SRB to return the SG list for.
    
Return Value:

    If non-NULL, the scatter-gather list assoicated with this SRB.

    If NULL, failure.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    ASSERT (HwDeviceExtension != NULL);
    //
    // NB: Put in a DBG check that the HwDeviceExtension matches the
    // HwDeviceExtension assoicated with the SRB.
    //
    Xrb = RaidGetAssociatedXrb (Srb);
    ASSERT (Xrb != NULL);

    return (PSTOR_SCATTER_GATHER_LIST)Xrb->SgList;
}
    

PVOID
StorPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    )
/*++

Routine Description:

    Given a PathId, Targetid and Lun, get the Logical Unit extension
    associated with that triplet.

    NB: To improve speed, we could add StorPortGetLogicalUnitBySrb which
    gets the logical unit from a given SRB. The latter function is much
    easier to implement (no walking of lists).

Arguments:

    HwDeviceExtension -

    PathId - SCSI PathId.

    TargetId - SCSI TargetId.

    Lun - SCSI Logical Unit number.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return NULL;
    }

    Address.PathId = PathId;
    Address.TargetId = TargetId;
    Address.Lun = Lun;
    Unit = RaidAdapterFindUnit (Adapter, Address);
    
    return Unit->UnitExtension;
}

VOID
StorPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PHW_INTERRUPT HwTimerRoutine;
    ULONG Timeout;
    va_list ap;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);
    
    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case RequestComplete:
            Srb = va_arg (ap, PSCSI_REQUEST_BLOCK);
            RaidAdapterRequestComplete (Adapter, RaidGetAssociatedXrb (Srb));
            break;

        case ResetDetected:
            //
            // Pause the adapter for four seconds.
            //
            StorPortPause (HwDeviceExtension, 4);
            break;

        case BusChangeDetected:
            Adapter->Flags.BusChanged = TRUE;
            break;

        case NextRequest:
            //
            // One of the requirements for StorPort that the miniport
            // can handle the next request by the time it returns
            // from StartIo. Therefore, this notification is irrelevent.
            // Maybe use it for debugging purposes (can a specific
            // MINIPORT easily be converted to a StorPort miniport).
            //
            break;

        case NextLuRequest:
            //
            // See above comment.
            //
            break;


        case RequestTimerCall:
            HwTimerRoutine = va_arg (ap, PHW_INTERRUPT);
            Timeout = va_arg (ap, ULONG);
            RaidAdapterRequestTimerDeferred (Adapter,
                                             HwTimerRoutine,
                                             Timeout);
            break;
            
        case WMIEvent:
            NYI ();
            break;


        case WMIReregister:
            NYI ();
            break;

        default:
            NYI();

    }

    va_end(ap);

}

VOID
StorPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if
    necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data
            storage.

    Srb - Supplies an optional pointer to srb if there is one.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/
{
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Check out the reason for the error.
    //
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return ;
    }   

    RaidAdapterLogIoErrorDeferred (Adapter,
                                   PathId,
                                   TargetId,
                                   Lun,
                                   ErrorCode,
                                   UniqueId);
}


VOID
StorPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Check out the reason for the error.
    //
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return;
    }   

    KeInsertQueueDpc (&Adapter->CompletionDpc,
                      (PVOID)(ULONG_PTR)StorScsiAddressToLong2 (PathId, TargetId, Lun),
                      (PVOID)(ULONG_PTR)SrbStatus);

}



VOID
RaidCompleteRequestCallback(
    IN PSTOR_EVENT_QUEUE Queue,
    IN PVOID Context,
    IN PSTOR_EVENT_QUEUE_ENTRY Entry
    )
{
    UCHAR SrbStatus;
    PEXTENDED_REQUEST_BLOCK Xrb;

    SrbStatus = (UCHAR)Context;
    
    Xrb = CONTAINING_RECORD (Entry,
                             EXTENDED_REQUEST_BLOCK,
                             PendingLink);

    //
    // If this entry has not been completed by the miniport.
    //
    
    if (Xrb->CompletedLink.Next == NULL) {
        ASSERT (Xrb->Srb != NULL);
        Xrb->Srb->SrbStatus = SrbStatus;
        Xrb->CompletionRoutine (Xrb);
    }
}



VOID
RaidCancelIrp(
    IN PIO_QUEUE IoQueue,
    IN PVOID Context,
    IN PIRP Irp
    )
{
    UCHAR SrbStatus;
    PSCSI_REQUEST_BLOCK Srb;
    
    SrbStatus = (UCHAR)Context;
    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);
    Srb->SrbStatus = SrbStatus;
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (SrbStatus);
    Irp->IoStatus.Information = 0;

    RaidCompleteRequest (Irp, IO_NO_INCREMENT, Irp->IoStatus.Status);
}



VOID
RaidCompletionDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
{
    PLIST_ENTRY NextEntry;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_UNIT_EXTENSION Unit;
    RAID_ADDRESS Address;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;

    VERIFY_DISPATCH_LEVEL();

    Adapter = (PRAID_ADAPTER_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_ADAPTER (Adapter);

    PathId = ((PRAID_ADDRESS)&Context1)->PathId;
    TargetId = ((PRAID_ADDRESS)&Context1)->TargetId;
    Lun = ((PRAID_ADDRESS)&Context1)->Lun;

    // Acquire Unit list lock():
    
    for (NextEntry = Adapter->UnitList.List.Flink;
         NextEntry != &Adapter->UnitList.List;
         NextEntry = NextEntry->Flink) {

        Unit = CONTAINING_RECORD (NextEntry,
                                  RAID_UNIT_EXTENSION,
                                  NextUnit);

        ASSERT_UNIT (Unit);

        if ((PathId == SP_UNTAGGED   || PathId == Unit->Address.PathId) &&
            (TargetId == SP_UNTAGGED || TargetId == Unit->Address.TargetId) &&
            (Lun == SP_UNTAGGED || Lun == Unit->Address.Lun)) {

            //
            // Purge all events on the unit queue.
            //
            
            StorPurgeEventQueue (&Unit->PendingQueue,
                                 RaidCompleteRequestCallback,
                                 Context2);
            RaidPurgeIoQueue (&Unit->IoQueue,
                              RaidCancelIrp,
                              Context2);
        }
    }

    // Release Unit list lock();
}


VOID
StorPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    Copy from one buffer into another.

Arguments:

    ReadBuffer - source

    WriteBuffer - destination

    Length - number of bytes to copy

Return Value:

    None.

--*/

{
    RtlMoveMemory (WriteBuffer, ReadBuffer, Length);
}



//
// BUGBUG: Figure out how to pull in NTRTL.
//

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );
                        

VOID
StorPortDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR Format,
    ...
    )
{
    va_list arglist;

#if DBG
    if (StorMiniportQuiet) {
        return;
    }
#endif
    
    va_start (arglist, Format);
    vDbgPrintExWithPrefix ("STORMINI: ",
                           DPFLTR_STORMINIPORT_ID,
                           DebugPrintLevel,
                           Format,
                           arglist);
    va_end (arglist);
}


PSCSI_REQUEST_BLOCK
StorPortGetSrb(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    )

/*++

Routine Description:

    This routine retrieves an active SRB for a particuliar logical unit.

Arguments:

    HwDeviceExtension -

    PathId, TargetId, Lun - identify logical unit on SCSI bus.

    QueueTag - -1 indicates request is not tagged.

Return Value:

    SRB, if one exists. Otherwise, NULL.

--*/

{

#if 1

    NYI();
    return NULL;

#else
    PADAPTER_EXTENSION deviceExtension = GET_FDO_EXTENSION(HwDeviceExtension);
    PSRB_DATA srbData;
    PSCSI_REQUEST_BLOCK srb;
    UCHAR pathId;
    UCHAR targetId;
    UCHAR lun;

    srbData = SpGetSrbData(deviceExtension,
                           PathId,
                           TargetId,
                           Lun,
                           (UCHAR)QueueTag,
                           FALSE);

    if (srbData == NULL || srbData->CurrentSrb == NULL) {
        return(NULL);
    }

    srb = srbData->CurrentSrb;

    //
    // If the srb is not active then return NULL;
    //

    if (!(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return(NULL);
    }

    return (srb);
#endif
}


STOR_PHYSICAL_ADDRESS
StorPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    )

/*++

Routine Description:

    Convert virtual address to physical address for DMA.

Arguments:

    HwDeviceExtension -

    Srb -

    VirtualAddress -

    Length -

Return Value:

Bugs:

    Obtaining the address of the Srb's physical extension is a problem.

--*/

{
    PHYSICAL_ADDRESS Physical;
    PRAID_ADAPTER_EXTENSION Adapter;
    ULONG i;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCATTER_GATHER_LIST ScatterList;
    BOOLEAN InRange;
    SIZE_T Offset;

    //
    // The only things we are allowed to get a physical address for are
    // the Srb->DataBuffer, the adapter UncachedExtension and the
    // Srb->SenseInfoBuffer, Srb->SenseInfoBufferLength
    //

    if (Srb == NULL || Srb->SenseInfoBuffer == VirtualAddress) {

        //
        // This case is NYI
        //
        if (Srb && Srb->SenseInfoBuffer == VirtualAddress) {
            NYI ();
        }

        Adapter = RaidpPortGetAdapter (HwDeviceExtension);

        InRange = RaidRegionGetPhysicalAddress (&Adapter->UncachedExtension,
                                          VirtualAddress,
                                          &Physical,
                                          Length);

        if (!InRange) {
                            
            //
            // BUGBUG
            //
            // The miniport will ask us for the physical address of the
            // srb extension. Unfortunately, when doing this it will pass
            // in NULL as the Srb. Without the Srb (and with only the
            // HwDeviceExtension) it is difficult to get back to the
            // Srb that owns the extension, and hence verify that it is
            // correct. For now, we cheat by using MmGetPhysicalAddress()
            // to obtain the physical address for us.
            //
            // NB: If tagged entries were tagged based on the ADAPTER,
            // instead of the UNIT, then this would be cake. In that
            // case The HwDeviceExtension identifies the adapter and
            // the SrbExtension is allocated out of a fixed pool that
            // is associated with the adapter. StorPort's implementation,
            // in contrast, allocates the SrbExtensions from a fixed
            // pool buffer that it part of the UNIT. Since there's no
            // easy way to get from the ADAPTER (and an address) to
            // the unit, we just punt by assuming the MINIPORT didn't
            // give us a bad address and by hoping that the miniport
            // doesn't min getting back a length larger than necessary.
            // Note that if I'm misreading the SCSI spec and QueueTags
            // are allocated per-unit (instead of per-adapter), there is
            // not a problem.
            //
            
            Physical = MmGetPhysicalAddress (VirtualAddress);
            *Length = RaGetSrbExtensionSize (Adapter);
        }

    } else {

        ASSERT ((ULONG_PTR)Srb->DataBuffer <= (ULONG_PTR) VirtualAddress &&
                (ULONG_PTR)VirtualAddress < (ULONG_PTR)Srb->DataBuffer + Srb->DataTransferLength);
        
        Xrb = RaidGetAssociatedXrb (Srb);

        ScatterList = Xrb->SgList;
        Offset = (SIZE_T) ((ULONG_PTR)VirtualAddress - (ULONG_PTR)Srb->DataBuffer);
        i = 0;
        while (Offset >= ScatterList->Elements[i].Length) {
            ASSERT (i < ScatterList->NumberOfElements);
            Offset -= ScatterList->Elements[i].Length;
            i++;
        }

        *Length = ScatterList->Elements[i].Length;
        Physical.QuadPart = ScatterList->Elements[i].Address.QuadPart + Offset;
    }

    return Physical;
}


PVOID
StorPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN STOR_PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

Routine Description:

    This routine is returns a virtual address associated with a physical
    address, if the physical address was obtained by a call to
    ScsiPortGetPhysicalAddress.

Arguments:

    PhysicalAddress

Return Value:

    Virtual address

--*/

{
    //
    // NB: This is not as safe as the way SCSIPORT does this.
    //
    
    return MmGetVirtualForPhysical (PhysicalAddress);
}


BOOLEAN
StorPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN STOR_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )
/*++

Routine Description:

    This routine should take an IO range and make sure that it is not already
    in use by another adapter. This allows miniport drivers to probe IO where
    an adapter could be, without worrying about messing up another card.

Arguments:

    HwDeviceExtension - Used to find scsi managers internal structures

    BusType - EISA, PCI, PC/MCIA, MCA, ISA, what?

    SystemIoBusNumber - Which system bus?

    IoAddress - Start of range

    NumberOfBytes - Length of range

    InIoSpace - Is range in IO space?

Return Value:

    TRUE if range not claimed by another driver.

--*/
{
    //
    // This is for Win9x compatability.
    //
    
    return TRUE;
}


STOR_PHYSICAL_ADDRESS
StorPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    )

{
    STOR_PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = UlongAddress;
    return(physicalAddress);
}


//
// Leave these routines at the end of the file.
//

PVOID
StorPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN STOR_PHYSICAL_ADDRESS Address,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.
    Use ScsiPortFreeDeviceBase to unmap address.

Arguments:

    HwDeviceExtension - used to find port device extension.

    BusType - what type of bus - eisa, mca, isa

    SystemIoBusNumber - which IO bus (for machines with multiple buses).

    Address - base device address to be mapped.

    NumberOfBytes - number of bytes for which address is valid.

    IoSpace - indicates an IO address.

Return Value:

    Mapped address.

--*/

{
    NTSTATUS Status;
    PVOID MappedAddress;
    PRAID_ADAPTER_EXTENSION Adapter;
    PHYSICAL_ADDRESS CardAddress;

    //
    // REVIEW: Since we are a PnP driver, we do not have to deal with
    // miniport's who ask for addresses they are not assigned, right?
    //

    //
    // REVIEW: SCSIPORT takes a different path for reinitialization.
    //
    
    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    //
    // Translate the address.
    //
    
    Status = RaidTranslateResourceListAddress (
                    &Adapter->ResourceList,
                    BusType,
                    SystemIoBusNumber,
                    Address,
                    NumberOfBytes,
                    InIoSpace,
                    &CardAddress
                    );

    if (!NT_SUCCESS (Status)) {
        DebugPrint (("GetDeviceBase failed addr = %I64x, %s Space\n",
                     Address.QuadPart,
                     InIoSpace ? "Io" : "Memory"));
        return NULL;
    }

    //
    // If this is a CmResourceTypeMemory resource, we need to map it into
    // memory.
    //
    
    if (!InIoSpace) {
        MappedAddress = MmMapIoSpace (CardAddress, NumberOfBytes, FALSE);

        Status = RaidAllocateAddressMapping (&Adapter->MappedAddressList,
                                             Address,
                                             MappedAddress,
                                             NumberOfBytes,
                                             SystemIoBusNumber,
                                             Adapter->DeviceObject);
        if (!NT_SUCCESS (Status)) {

            //
            // BUGBUG: we need to log an error to the event log saying
            // we didn't have enough resources. 
            //
            
            NYI();
            return NULL;
        }
    } else {
        MappedAddress = (PVOID)(ULONG_PTR)CardAddress.QuadPart;
    }

    return MappedAddress;
}
                

VOID
StorPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
/*++

Routine Description:

    This routine unmaps an IO address that has been previously mapped
    to system address space using ScsiPortGetDeviceBase().

Arguments:

    HwDeviceExtension - used to find port device extension.

    MappedAddress - address to unmap.

    NumberOfBytes - number of bytes mapped.

    InIoSpace - address is in IO space.

Return Value:

    None

--*/
{

#if 1

    NYI ();

#else
    PADAPTER_EXTENSION adapter;
    ULONG i;
    PMAPPED_ADDRESS nextMappedAddress;
    PMAPPED_ADDRESS lastMappedAddress;

    adapter = GET_FDO_EXTENSION(HwDeviceExtension);

    for(i = 0; i < adapter->MappedAddressCount; i++) {
        PMAPPED_ADDRESS address;

        address = &(adapter->MappedAddressList[i]);

        if((address->NumberOfBytes == 0) &&
           (address->MappedAddress == 0)) {

            //
            // This range has already been released - skip to the next one.
            //

            continue;
        }

        if(address->MappedAddress == MappedAddress) {

            //
            // Unmap address.
            //

            MmUnmapIoSpace(address->MappedAddress,
                           address->NumberOfBytes);

            //
            // Remove mapped address from list.  The space will be reclaimed
            // when the mapped address list is shrunk.
            //

            RtlZeroMemory(address, sizeof(MAPPED_ADDRESS));
        }
    }

#endif

}


PVOID
StorPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    )
/*++

Routine Description:

    This function allocates a common buffer to be used as the uncached device
    extension for the miniport driver. 

Arguments:

    DeviceExtension - Supplies a pointer to the miniports device extension.

    ConfigInfo - Supplies a pointer to the partially initialized configuraiton
        information.  This is used to get an DMA adapter object.

    NumberOfBytes - Supplies the size of the extension which needs to be
        allocated

Return Value:

    A pointer to the uncached device extension or NULL if the extension could
    not be allocated or was previously allocated.

--*/

{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // SCSIPORT also allocates the SRB extension from here. Wonder if
    // that's necessary at this point.
    //

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);

    if (Adapter == NULL) {
        return NULL;
    }

    //
    // The noncached extension has not been allocated. Allocate it.
    //

    if (!RaidIsRegionInitialized (&Adapter->UncachedExtension)) {

        //
        // The DMA Adapter may not have been initialized at this point. If
        // not, initialize it.
        //

        if (!RaidIsDmaInitialized (&Adapter->Dma)) {

            Status = RaidInitializeDma (&Adapter->Dma,
                                        Adapter->LowerDeviceObject,
                                        &Adapter->Miniport.PortConfiguration);

            if (!NT_SUCCESS (Status)) {
                return NULL;
            }
        }
    
        Status = RaidDmaAllocateCommonBuffer (&Adapter->Dma,
                                              NumberOfBytes,
                                              FALSE,
                                              &Adapter->UncachedExtension);
    }

    //
    // Return the base virtual address of the region.
    //
    
    return RaidRegionGetVirtualBase (&Adapter->UncachedExtension);
}


ULONG
StorPortGetBusData(
    IN PVOID HwDeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the bus data for an adapter slot or CMOS address.

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    ULONG Bytes;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);
    Bytes = RaGetBusData (&Adapter->Bus,
                          BusDataType,
                          Buffer,
                          0,
                          Length);

    return Bytes;
}


ULONG
StorPortSetBusDataByOffset(
    IN PVOID HwDeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns writes bus data to a specific offset within a slot.

Arguments:

    HwDeviceExtension - State information for a particular adapter.

    BusDataType - Supplies the type of bus.

    SystemIoBusNumber - Indicates which system IO bus.

    SlotNumber - Indicates which slot.

    Buffer - Supplies the data to write.

    Offset - Byte offset to begin the write.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Number of bytes written.

--*/

{
    ULONG Ret;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = RaidpPortGetAdapter (HwDeviceExtension);
    Ret = RaSetBusData (&Adapter->Bus,
                        BusDataType,
                        Buffer,
                        Offset,
                        Length);

    return Ret;
}
                          

//
// The below I/O access routines are forwarded to the HAL or NTOSKRNL on
// Alpha and Intel platforms.
//
#if !defined(_ALPHA_) && !defined(_X86_)

UCHAR
StorPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_UCHAR(Port));

}

USHORT
StorPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_USHORT(Port));

}

ULONG
StorPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    Read from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.

Return Value:

    Returns the value read from the specified port address.

--*/

{

    return(READ_PORT_ULONG(Port));

}

VOID
StorPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
StorPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
StorPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

UCHAR
StorPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    Read from the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_UCHAR(Register));

}

USHORT
StorPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_USHORT(Register));

}

ULONG
StorPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    Read from the specified register address.

Arguments:

    Register - Supplies a pointer to the register address.

Return Value:

    Returns the value read from the specified register address.

--*/

{

    return(READ_REGISTER_ULONG(Register));

}

VOID
StorPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
StorPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
StorPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
StorPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_UCHAR(Port, Value);

}

VOID
StorPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_USHORT(Port, Value);

}

VOID
StorPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed port address.

Arguments:

    Port - Supplies a pointer to the port address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_PORT_ULONG(Port, Value);


}

VOID
StorPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

}

VOID
StorPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

}

VOID
StorPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified port address.

Arguments:

    Port - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

}

VOID
StorPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_UCHAR(Register, Value);

}

VOID
StorPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_USHORT(Register, Value);
}

VOID
StorPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

VOID
StorPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    Write to the specificed register address.

Arguments:

    Register - Supplies a pointer to the register address.

    Value - Supplies the value to be written.

Return Value:

    None

--*/

{

    WRITE_REGISTER_ULONG(Register, Value);
}
#endif  // !defined(_ALPHA_) && !defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\power.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    power.c
    
Abstract:

    Power management for the RAID port driver.x
    
Author:

    Matthew D Hendel (math) 21-Apr-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#endif // ALLOC_PRAGMA


//
// Creation and destruction.
//

VOID
RaCreatePower(
    IN OUT PRAID_POWER_STATE Power
    )
{
    ASSERT (Power != NULL);

    Power->SystemState = PowerSystemUnspecified;
    Power->DeviceState = PowerDeviceUnspecified;
    Power->CurrentPowerIrp = NULL;
//  KeInitializeEvent (&Power->PowerDownEvent, );
}

VOID
RaDeletePower(
    IN OUT PRAID_POWER_STATE Power
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\miniport.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

	miniport.h

Abstract:

	Definition of RAID_MINIPORT object and it's operations.

Author:

	Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_HW_DEVICE_EXT {

	//
	// Back pointer to the containing miniport.
	//
	
	struct _RAID_MINIPORT* Miniport;

	//
	// Variable length array containing the device extension proper.
	//

	UCHAR HwDeviceExtension[0];

} RAID_HW_DEVICE_EXT, *PRAID_HW_DEVICE_EXT;


typedef struct _RAID_MINIPORT {

	//
	// Back pointer to the containing adapter object.
	//

	PRAID_ADAPTER_EXTENSION Adapter;
	

	//
    // Saved copy of the port configuration information we sent down
    // to the driver.
    //

    PORT_CONFIGURATION_INFORMATION PortConfiguration;

    //
    // Saved copy of the HwInitializationData passed in to 
    // ScsiPortInitialize.
    //

    PHW_INITIALIZATION_DATA HwInitializationData;

	//
	// The miniport's Hw Device Extension and a back-pointer to the miniport.
	//
	
	PRAID_HW_DEVICE_EXT PrivateDeviceExt;

} RAID_MINIPORT, *PRAID_MINIPORT;



//
// Creation and destruction
//

VOID
RaCreateMiniport(
	OUT PRAID_MINIPORT Miniport
	);

NTSTATUS
RaInitializeMiniport(
	IN OUT PRAID_MINIPORT Miniport,
	IN PHW_INITIALIZATION_DATA HwInitializationData,
	IN PRAID_ADAPTER_EXTENSION Adapter,
	IN PRAID_RESOURCE_LIST ResourceList,
	IN ULONG BusNumber
	);

VOID
RaDeleteMiniport(
	IN PRAID_MINIPORT Miniport
	);

//
// Operations on the miniport object
//

NTSTATUS
RaCallMiniportFindAdapter(
	IN PRAID_MINIPORT Miniport
	);

NTSTATUS
RaCallMiniportHwInitialize(
	IN PRAID_MINIPORT Miniport
	);

BOOLEAN
RaCallMiniportStartIo(
	IN PRAID_MINIPORT Miniport,
	IN PSCSI_REQUEST_BLOCK Srb
	);

BOOLEAN
RaCallMiniportInterrupt(
	IN PRAID_MINIPORT Miniport
	);


NTSTATUS
RaCallMiniportStopAdapter(
	IN PRAID_MINIPORT Miniport
	);
	
NTSTATUS
RaCallMiniportAdapterControl(
	IN PRAID_MINIPORT Miniport,
	IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
	IN PVOID Parameters
	);
	
PRAID_ADAPTER_EXTENSION
RaGetMiniportAdapter(
	IN PRAID_MINIPORT Miniport
	);

PRAID_MINIPORT
RaGetHwDeviceExtensionMiniport(
	IN PVOID HwDeviceExtension
	);


//
// Private operations on the miniport.
//

NTSTATUS
RiAllocateMiniportDeviceExtension(
	IN PRAID_MINIPORT Miniport
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\portcfg.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    portcfg.h

Abstract:

    Implementation of operations on the PORT_CONFIGURATION object.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/



#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaCreateConfiguration)
#pragma alloc_text(PAGE, RaDeleteConfiguration)
#pragma alloc_text(PAGE, RaInitializeConfiguration)
#pragma alloc_text(PAGE, RaAssignConfigurationResources)
#endif // ALLOC_PRAGMA



VOID
RaCreateConfiguration(
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
    )
/*++

Routine Description:

    Create a port configuration object and initialize it to a null state.

Arguments:

    PortConfiguration - Pointer to the the port configuration object to
            create.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (PortConfiguration != NULL);

    RtlZeroMemory (PortConfiguration, sizeof (PortConfiguration));
}


VOID
RaDeleteConfiguration(
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
    )
/*++

Routine Description:

    Deallocate all resources associated with a port configuration object.x

Arguments:

    PortConfiguration - Pointer to the port configuration objectx to
            delete.

Return Value:

    NTSTATUS code

--*/
{
    PAGED_CODE ();
    ASSERT (PortConfiguration != NULL);
    ASSERT (PortConfiguration->Length == sizeof (PORT_CONFIGURATION_INFORMATION));

    if (PortConfiguration->AccessRanges != NULL) {
        ExFreePoolWithTag (PortConfiguration->AccessRanges, PORTCFG_TAG);
        PortConfiguration->AccessRanges = NULL;
    }

    PortConfiguration->Length = 0;
}


NTSTATUS
RaInitializeConfiguration(
    IN PPORT_CONFIGURATION_INFORMATION PortConfiguration,
    IN PHW_INITIALIZATION_DATA HwInitializationData,
    IN ULONG BusNumber
    )
/*++

Routine Description:

    Initialize a port configuration object from a hardware initialization
    data object.
    
Arguments:

    PortConfiguration - Pointer to the port configuration to be
            initialized.

    HwInitializationData - Pointer to a hardware initialization data that
            will be used to initialize the port configuration.

    BusNumber - The bus number this configuration is for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG j;
    PCONFIGURATION_INFORMATION Config;
    
    PAGED_CODE ();
    ASSERT (PortConfiguration != NULL);
    ASSERT (HwInitializationData != NULL);

    RtlZeroMemory (PortConfiguration, sizeof (*PortConfiguration));
    PortConfiguration->Length = sizeof(PORT_CONFIGURATION_INFORMATION);
    PortConfiguration->AdapterInterfaceType = HwInitializationData->AdapterInterfaceType;
    PortConfiguration->InterruptMode = Latched;
    PortConfiguration->MaximumTransferLength = SP_UNINITIALIZED_VALUE;
    PortConfiguration->DmaChannel = SP_UNINITIALIZED_VALUE;
    PortConfiguration->DmaPort = SP_UNINITIALIZED_VALUE;
    PortConfiguration->MaximumNumberOfTargets = SCSI_MAXIMUM_TARGETS_PER_BUS;
    PortConfiguration->MaximumNumberOfLogicalUnits = SCSI_MAXIMUM_LOGICAL_UNITS;
    PortConfiguration->WmiDataProvider = FALSE;

    //
    // If the system indicates it can do 64-bit physical addressing then tell
    // the miniport it's an option.
    //

#if 1
    PortConfiguration->Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
#else
    if (Sp64BitPhysicalAddresses == TRUE) {
        PortConfiguration->Dma64BitAddresses = SCSI_DMA64_SYSTEM_SUPPORTED;
    } else {
        PortConfiguration->Dma64BitAddresses = 0;
    }
#endif

    //
    // Save away the some of the attributes.
    //

    PortConfiguration->NeedPhysicalAddresses = HwInitializationData->NeedPhysicalAddresses;
    PortConfiguration->MapBuffers = HwInitializationData->MapBuffers;
    PortConfiguration->AutoRequestSense = HwInitializationData->AutoRequestSense;
    PortConfiguration->ReceiveEvent = HwInitializationData->ReceiveEvent;
    PortConfiguration->TaggedQueuing = HwInitializationData->TaggedQueuing;
    PortConfiguration->MultipleRequestPerLu = HwInitializationData->MultipleRequestPerLu;
    PortConfiguration->SrbExtensionSize = HwInitializationData->SrbExtensionSize;
    PortConfiguration->SpecificLuExtensionSize = HwInitializationData->SpecificLuExtensionSize;

    //
    // The port configuration should add these:
    //
    //      MaximumNumberOfTargets
    //      NumberOfBuses
    //      CachesData
    //      ReceiveEvent
    //      WmiDataProvider
    //
    // Which should then be accessed ONLY through the port configuration
    // not, and never the HwInitializationData.
    //
    

    //
    // Allocate the access ranges.
    //
    
    PortConfiguration->NumberOfAccessRanges = HwInitializationData->NumberOfAccessRanges;

    PortConfiguration->AccessRanges =
            ExAllocatePoolWithTag (NonPagedPool,
                                   PortConfiguration->NumberOfAccessRanges * sizeof (ACCESS_RANGE),
                                   PORTCFG_TAG);

    if (PortConfiguration->AccessRanges == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (PortConfiguration->AccessRanges,
                   PortConfiguration->NumberOfAccessRanges * sizeof (ACCESS_RANGE));

    //
    // Indicate the current AT disk usage.
    //

    Config = IoGetConfigurationInformation();

    PortConfiguration->AtdiskPrimaryClaimed = Config->AtDiskPrimaryAddressClaimed;
    PortConfiguration->AtdiskSecondaryClaimed = Config->AtDiskSecondaryAddressClaimed;

    for (j = 0; j < 8; j++) {
        PortConfiguration->InitiatorBusId[j] = (CCHAR)SP_UNINITIALIZED_VALUE;
    }

    PortConfiguration->NumberOfPhysicalBreaks = 17; // SP_DEFAULT_PHYSICAL_BREAK_VALUE;

    //
    // Record the system bus number.
    //

    //
    // BUGBUG: For a non-legacy adapter, is the bus number
    // actually relevant?
    //
    
    PortConfiguration->SystemIoBusNumber = BusNumber;
    PortConfiguration->SlotNumber = 0;
    
    return STATUS_SUCCESS;
}


NTSTATUS
RaAssignConfigurationResources(
    IN OUT PPORT_CONFIGURATION_INFORMATION PortConfiguration,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN ULONG NumberOfAccessRanges
    )
/*++

Routine Description:

    Assign resources to a port configuration object.

Arguments:

    PortConfiguration - Pointer to the port configuration we are
            assigning resources to.

    AllocaedResources - The resources to assign.

    NumberOfAccessRanges - The number of access ranges.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG RangeNumber;
    ULONG i;
    PACCESS_RANGE AccessRange;
    PCM_FULL_RESOURCE_DESCRIPTOR ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialData;

    PAGED_CODE();

    RangeNumber = 0;
    ResourceList = AllocatedResources->List;
    
    for (i = 0; i < ResourceList->PartialResourceList.Count; i++) {
    
        PartialData = &ResourceList->PartialResourceList.PartialDescriptors[ i ];

        switch (PartialData->Type) {
        
            case CmResourceTypePort:

                //
                // Verify range count does not exceed what the
                // miniport indicated.
                //

                if (NumberOfAccessRanges > RangeNumber) {

                    //
                    // Get next access range.
                    //

                    AccessRange = &((*(PortConfiguration->AccessRanges))[RangeNumber]);

                    AccessRange->RangeStart = PartialData->u.Port.Start;
                    AccessRange->RangeLength = PartialData->u.Port.Length;
                    AccessRange->RangeInMemory = FALSE;

                    RangeNumber++;
                }
            break;

        case CmResourceTypeInterrupt:
        
            PortConfiguration->BusInterruptLevel = PartialData->u.Interrupt.Level;
            PortConfiguration->BusInterruptVector = PartialData->u.Interrupt.Vector;

            //
            // Check interrupt mode.
            //

            if (PartialData->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                PortConfiguration->InterruptMode = Latched;
            } else if (PartialData->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                PortConfiguration->InterruptMode = LevelSensitive;
            }
            break;

        case CmResourceTypeMemory:

            //
            // Verify range count does not exceed what the
            // miniport indicated.
            //

            if (NumberOfAccessRanges > RangeNumber) {

                 //
                 // Get next access range.
                 //

                 AccessRange = &((*(PortConfiguration->AccessRanges))[RangeNumber]);

                 AccessRange->RangeStart = PartialData->u.Memory.Start;
                 AccessRange->RangeLength = PartialData->u.Memory.Length;
                 AccessRange->RangeInMemory = TRUE;
                 RangeNumber++;
            }
            break;

        case CmResourceTypeDma:
            PortConfiguration->DmaChannel = PartialData->u.Dma.Channel;
            PortConfiguration->DmaPort = PartialData->u.Dma.Port;
            break;

        case CmResourceTypeDeviceSpecific: {

            PCM_SCSI_DEVICE_DATA ScsiData;
            
            if (PartialData->u.DeviceSpecificData.DataSize <
                sizeof (CM_SCSI_DEVICE_DATA)) {

                ASSERT (FALSE);
                break;
            }

            ScsiData = (PCM_SCSI_DEVICE_DATA)(PartialData + 1);
            PortConfiguration->InitiatorBusId[0] = ScsiData->HostIdentifier;
            break;
            }
        }
    }

    return STATUS_SUCCESS;
}
    




//
// After calling HwFindAdapter, we need to check the following
// fields from the PortConfig:
//
//      SrbExtensionSize
//      SpecificLuExtensionSize
//      MaximumNumberOfTargets
//      NumberOfBuses
//      CachesData
//      ReceiveEvent
//      TaggedQueuing
//      MultipleRequestsPerLu
//      WmiDataProvider
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\power.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    power.h

Abstract:

    Power management objects and declarations for the RAID port driver.

Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_POWER_STATE {

    //
    // The system power state.
    //
    
    SYSTEM_POWER_STATE SystemState;

    //
    // The device power state.
    //
    
    DEVICE_POWER_STATE DeviceState;

    //
    // Current Power Irp  . . . NB: What is this for?
    //
    
    PIRP CurrentPowerIrp;

} RAID_POWER_STATE, *PRAID_POWER_STATE;



//
// Creation and destruction.
//

VOID
RaCreatePower(
    OUT PRAID_POWER_STATE Power
    );

VOID
RaDeletePower(
    IN PRAID_POWER_STATE Power
    );


VOID
RaInitializePower(
    IN PRAID_POWER_STATE Power
    );
    
//
// Operations
//

VOID
RaSetDevicePowerState(
    IN PRAID_POWER_STATE Power,
    IN DEVICE_POWER_STATE DeviceState
    );

VOID
RaSetSystemPowerState(
    IN PRAID_POWER_STATE Power,
    IN SYSTEM_POWER_STATE SystemState
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\portcfg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	portcfg.h

Abstract:

	Declaration of operations on the PORT_CONFIGURATION_INFORMATION object.

Author:

	Matthew D Hendel (math) 20-Apr-2000b

Revision History:

--*/

#pragma once


//
// Creation and destruction of the configuration object.
//

VOID
RaCreateConfiguration(
	IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
	);

NTSTATUS
RaInitializeConfiguration(
	OUT PPORT_CONFIGURATION_INFORMATION PortConfiguration,
	IN PHW_INITIALIZATION_DATA HwInitializationData,
	IN ULONG BusNumber
	);

VOID
RaDeleteConfiguration(
	IN PPORT_CONFIGURATION_INFORMATION PortConfiguration
	);

//
// Operations
//

NTSTATUS
RaAssignConfigurationResources(
	IN OUT PPORT_CONFIGURATION_INFORMATION PortConfiguration,
	IN PCM_RESOURCE_LIST AllocatedResources,
	IN ULONG NumberOfAccessRanges
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for RAID port driver.

Author:

    Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/


#pragma once

#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>

#include <storport.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddstor.h>

#include <wmistr.h>

#include <wdmguid.h>
#include <devguid.h>
#include <storlib.h>

typedef struct _RAID_ADAPTER_EXTENSION RAID_ADAPTER_EXTENSION, *PRAID_ADAPTER_EXTENSION;
typedef struct _RAID_UNIT_EXTENSION RAID_UNIT_EXTENSION, *PRAID_UNIT_EXTENSION;
typedef struct _RAID_DRIVER_EXTENSION RAID_DRIVER_EXTENSION, *PRAID_DRIVER_EXTENSION;
typedef struct _EXTENDED_REQUEST_BLOCK EXTENDED_REQUEST_BLOCK, *PEXTENDED_REQUEST_BLOCK;


#include "debug.h"
#include "util.h"
#include "id.h"

#include "exqueue.h"
#include "ioqueue.h"
#include "deferred.h"
#include "eventq.h"

#include "common.h"
#include "global.h"
#include "dma.h"
#include "srb.h"
#include "resource.h"
#include "power.h"
#include "miniport.h"
#include "wmi.h"
#include "portcfg.h"
#include "driver.h"
#include "bus.h"
#include "adapter.h"
#include "unit.h"
#include "BusEnum.h"

#include "ext.h"

#include "inline.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\resource.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Implementation of the RAIDPORT RAID_RESOURCE_LIST object.

Author:

    Matthew D Hendel (math) 24-Apr-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidCreateResourceList)
#pragma alloc_text(PAGE, RaidInitializeResourceList)
#pragma alloc_text(PAGE, RaidDeleteResourceList)
#pragma alloc_text(PAGE, RaidTranslateResourceListAddress)
#pragma alloc_text(PAGE, RaidGetResourceListElement)
#endif // ALLOC_PRAGMA



VOID
RaidCreateResourceList(
    OUT PRAID_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Initialize a raid resource list object to a null state.
    
Arguments:

    ResourceList - Pointer to the resource list to initialize.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (ResourceList != NULL);

    ResourceList->AllocatedResources = NULL;
    ResourceList->TranslatedResources = NULL;
}

NTSTATUS
RaidInitializeResourceList(
    IN OUT PRAID_RESOURCE_LIST ResourceList,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    )
/*++

Routine Description:

    Initialize the allocated and translated resources for a raid resource
    list.

Arguments:

    ResourcList - Pointer to the resource list to initialize.

    AllocatedResources - Pointer to the allocated resources that will be
            copied to the resource lists private buffer.

    TranslatedResources - Pointer to the tranlsated resources that will
            be copied to the resoure lists private buffer.

Return Value:

    NTSTATUS code.

--*/
{

    PAGED_CODE ();
    ASSERT (ResourceList != NULL);
    ASSERT (AllocatedResources != NULL);
    ASSERT (TranslatedResources != NULL);

    ASSERT (AllocatedResources->Count == 1);
    ASSERT (AllocatedResources->List[0].PartialResourceList.Count ==
            TranslatedResources->List[0].PartialResourceList.Count);

    ResourceList->AllocatedResources =
            RaDuplicateCmResourceList (NonPagedPool,
                                        AllocatedResources,
                                        RESOURCE_LIST_TAG);

    ResourceList->TranslatedResources =
            RaDuplicateCmResourceList (NonPagedPool,
                                        TranslatedResources,
                                        RESOURCE_LIST_TAG);

    if (!ResourceList->AllocatedResources ||
        !ResourceList->TranslatedResources) {
        
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}

VOID
RaidDeleteResourceList(
    IN PRAID_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Delete any resources allocate by the resource list.

Arguments:

    ResourceList - Pointer to the resource list to delete.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    ASSERT (ResourceList != NULL);

    if (ResourceList->AllocatedResources) {
        ExFreePoolWithTag (ResourceList->AllocatedResources, RESOURCE_LIST_TAG);
        ResourceList->AllocatedResources = NULL;
    }

    if (ResourceList->TranslatedResources) {
        ExFreePoolWithTag (ResourceList->TranslatedResources, RESOURCE_LIST_TAG);
        ResourceList->TranslatedResources = NULL;
    }
}

NTSTATUS
RaidTranslateResourceListAddress(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN INTERFACE_TYPE RequestedBusType,
    IN ULONG RequestedBusNumber,
    IN PHYSICAL_ADDRESS RangeStart,
    IN ULONG RangeLength,
    IN BOOLEAN IoSpace,
    OUT PPHYSICAL_ADDRESS Address
    )
/*++

Routine Description:

    Translate an address.

Arguments:

    ResourceList - The resource list to use for the translation.

    BusType - The type of bus this address is on.

    BusNumber - The bus number of the bus.

    RangeStart - The starting address.

    RangeLength - The length of the range to translate.

    IoSpace - Boolean indicating this is in IO space (TRUE) or
            memory space (FALSE).

    Address - Buffer to hold the resultant, translated address.
    
Return Value:

    NTSTATUS code.

--*/
{
    ULONG Count;
    ULONG i;
    INTERFACE_TYPE BusType;
    ULONG BusNumber;
    ULONGLONG AddrLow;
    ULONGLONG AddrHigh;
    ULONGLONG TestLow;
    ULONGLONG TestHigh;
    UCHAR ResourceType;
    BOOLEAN Found;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Allocated;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    
    PAGED_CODE ();

    Allocated = NULL;
    Translated = NULL;
    
    if (IoSpace) {
        ResourceType = CmResourceTypePort;
    } else {
        ResourceType = CmResourceTypeMemory;
    }
    
    //
    // Search through the allocated resource list trying to match the
    // requested resource.
    //

    Found = FALSE;
    Address->QuadPart = 0;
    Count =  RaidGetResourceListCount (ResourceList);

    for (i = 0; i < Count; i++) {

        RaidGetResourceListElement (ResourceList,
                                             i,
                                             &BusType,
                                             &BusNumber,
                                             &Allocated,
                                             &Translated);

        //
        // We had to have found the address on the correct bus.
        //
        
        if (BusType != RequestedBusType ||
            BusNumber != RequestedBusNumber) {

            continue;
        }

        AddrLow = RangeStart.QuadPart;
        AddrHigh = AddrLow + RangeLength;
        TestLow = Allocated->u.Generic.Start.QuadPart;
        TestHigh = TestLow + Allocated->u.Generic.Length;

        //
        // Test if the address is within range.
        //
        
        if (TestLow < AddrLow && AddrHigh < TestHigh) {
            continue;
        }

        //
        // Translate the address
        //
        
        Found = TRUE;
        Address->QuadPart = Translated->u.Generic.Start.QuadPart + (AddrLow - TestLow);
        break;
    }

    return (Found ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


VOID
RaidGetResourceListElement(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG Index,
    OUT PINTERFACE_TYPE InterfaceType,
    OUT PULONG BusNumber,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* AllocatedResource, OPTIONAL
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* TranslatedResource OPTIONAL
    )
/*++

Routine Description:

    Get the nth resource element from the resource list.

Arguments:

    ResourceList - Pointer to the resource list to retrieve the element from.

    Index - Index of the element to retrieve.

    InterfaceType - Bus interface type of the resource.

    BusNumber - Bus number of the bus.

    AllocatedResource - Supplies a pointer to where we can copy
            the allocate resource element reference, if non-null.

    TranslatedResource - Supplies a pointer to where we can copy
            the translated resource element reference, if
            non-null.

Return Value:

    None.

--*/
{
    ULONG ListNumber;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;

    PAGED_CODE ();

    ASSERT (Index < RaidGetResourceListCount (ResourceList));

    RaidpGetResourceListIndex (ResourceList, Index, &ListNumber, &Index);
    
    *InterfaceType = ResourceList->AllocatedResources->List[ListNumber].InterfaceType;
    *BusNumber = ResourceList->AllocatedResources->List[ListNumber].BusNumber;
    
    if (AllocatedResource) {
        Descriptor = &ResourceList->AllocatedResources->List[ListNumber];
        *InterfaceType = Descriptor->InterfaceType;
        *BusNumber = Descriptor->BusNumber;
        *AllocatedResource = &Descriptor->PartialResourceList.PartialDescriptors[Index];
    }

    if (TranslatedResource) {
        Descriptor = &ResourceList->TranslatedResources->List[ListNumber];
        *InterfaceType = Descriptor->InterfaceType;
        *BusNumber = Descriptor->BusNumber;
        *TranslatedResource = &Descriptor->PartialResourceList.PartialDescriptors[Index];    
    }
}

        
NTSTATUS
RaidGetResourceListInterrupt(
    IN PRAID_RESOURCE_LIST ResourceList,
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    OUT KINTERRUPT_MODE* InterruptMode,
    OUT PBOOLEAN Shared,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Get the translated interrupt resource from the resource list. We
    assume there is exactly one interrupt resource in the resource list.

    If there is more than one interrupt in the list, this function will
    ASSERT.  If there are no interrupts in the resource list, the
    function will return STATUS_NOT_FOUND.

Arguments:

    ResourceList - Supplies pointer to the resource list we will search
            for the interrupt resource in.

    Vector - Returns the interrupt vector for the interrupt.

    Irql - Returns the IRQL for the interrupt.

    InterruptMode - Returns the mode for the interrupt (Latched or
            LevelSensitive).

    Shared - Returns whether the interrupt is sharable (TRUE) or not (FALSE).

    Affinity - Returns the processor affinity of the interrupt.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    ULONG Count;
    INTERFACE_TYPE BusType;
    ULONG BusNumber;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated;
    
    PAGED_CODE();

    Count = RaidGetResourceListCount (ResourceList);

#if DBG

    //
    // In a checked build, verify that we were only assigned
    // a single interrupt.
    //
    
    {
        CM_PARTIAL_RESOURCE_DESCRIPTOR TranslatedSav;
        BOOLEAN Found;

        Found = FALSE;
        for (i = 0; i < Count; i++) {

            RaidGetResourceListElement (ResourceList,
                                        i,
                                        &BusType,
                                        &BusNumber,
                                        NULL,
                                        &Translated);

            if (Translated->Type == CmResourceTypeInterrupt) {

                if (!Found) {
                    RtlCopyMemory (&TranslatedSav, Translated,
                                   sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR));
                } else {

                    DebugPrint (("**** Found multiple interrupts in assigned resources!\n"));
                    DebugPrint (("**** Level = %x, Vector = %x, Affinity = %x\n",
                                 Translated->u.Interrupt.Level,
                                 Translated->u.Interrupt.Vector,
                                 Translated->u.Interrupt.Affinity));
                    DebugPrint (("**** Level = %x, Vector = %x, Affinity = %x\n",
                                 TranslatedSav.u.Interrupt.Level,
                                 TranslatedSav.u.Interrupt.Vector,
                                 TranslatedSav.u.Interrupt.Affinity));
                    KdBreakPoint();
                }
            }
        }
    }

#endif // DBG
                                   

    for (i = 0; i < Count; i++) {

        RaidGetResourceListElement (ResourceList,
                                    i,
                                    &BusType,
                                    &BusNumber,
                                    NULL,
                                    &Translated);

        if (Translated->Type == CmResourceTypeInterrupt) {

            ASSERT (Translated->u.Interrupt.Level < 256);
            *Irql = (KIRQL)Translated->u.Interrupt.Level;
            *Vector = Translated->u.Interrupt.Vector;
            *Affinity = Translated->u.Interrupt.Affinity;

            if (Translated->ShareDisposition == CmResourceShareShared) {
                *Shared = TRUE;
            } else {
                *Shared = FALSE;
            }

            if (Translated->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                *InterruptMode = Latched;
            } else {
                ASSERT (Translated->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE);
                *InterruptMode = LevelSensitive;
            }

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\resource.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

	resource.h

Abstract:

	The RAID_RESOURCE_LIST class wraps allocated and translated
	CM_RESOURCE_LIST structures passed into the driver during it's
	StartDevice routine.

Author:

	Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_RESOURCE_LIST {

    //
    // Raw resource list
    //
    
    PCM_RESOURCE_LIST AllocatedResources;

    //
    // Translated resource list.
    //
    
    PCM_RESOURCE_LIST TranslatedResources;

} RAID_RESOURCE_LIST, *PRAID_RESOURCE_LIST;



//
// Creation and destruction
//

VOID
RaidCreateResourceList(
	OUT PRAID_RESOURCE_LIST ResourceList
	);

NTSTATUS
RaidInitializeResourceList(
    IN OUT PRAID_RESOURCE_LIST ResourceList,
    IN PCM_RESOURCE_LIST AllocatedResources,
    IN PCM_RESOURCE_LIST TranslatedResources
    );

VOID
RaidDeleteResourceList(
	IN PRAID_RESOURCE_LIST ResourceList
	);


//
// Operations on the RAID_RESOURCE_LIST object.
//

ULONG
RaidGetResourceListCount(
	IN PRAID_RESOURCE_LIST ResourceList
	);

VOID
RaidGetResourceListElement(
	IN PRAID_RESOURCE_LIST ResourceList,
	IN ULONG Index,
	OUT PINTERFACE_TYPE InterfaceType,
	OUT PULONG BusNumber,
	OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* AllocatedResource,
	OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR* TranslatedResource
	);

NTSTATUS
RaidTranslateResourceListAddress(
	IN PRAID_RESOURCE_LIST ResourceList,
	IN INTERFACE_TYPE InterfaceType,
	IN ULONG BusNumber,
	IN PHYSICAL_ADDRESS RangeStart,
	IN ULONG RangeLength,
	IN BOOLEAN IoSpace,
	OUT PPHYSICAL_ADDRESS Address
	);

NTSTATUS
RaidGetResourceListInterrupt(
	IN PRAID_RESOURCE_LIST ResourceList,
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    OUT KINTERRUPT_MODE* InterruptMode,
    OUT PBOOLEAN Shared,
    OUT PKAFFINITY Affinity
	);

ULONG
RaidGetResourceListCount(
	IN PRAID_RESOURCE_LIST ResourceList
	);

//
// Private resource list operations
//

VOID
RaidpGetResourceListIndex(
    IN PRAID_RESOURCE_LIST ResourceList,
    IN ULONG Index,
    OUT PULONG ListNumber,
    OUT PULONG NewIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\srb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	srb.c

Abstract:

	Implementation of SRB object.

Author:

	Matthew D Hendel (math) 04-May-2000

Revision History:

--*/

#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaidBuildMdlForXrb)
#pragma alloc_text(PAGE, RaidAllocateSrb)
#pragma alloc_text(PAGE, RaidFreeSrb)
#pragma alloc_text(PAGE, RaidPrepareSrbForReuse)
#pragma alloc_text(PAGE, RaidInitializeInquirySrb)
#endif // ALLOC_PRAGMA



PEXTENDED_REQUEST_BLOCK
RaidAllocateXrb(
	IN PNPAGED_LOOKASIDE_LIST XrbList,
	IN PDEVICE_OBJECT DeviceObject
	)
/*++

Routine Description:

	Allocate and initialize a SCSI EXTENDED_REQUEST_BLOCK.

Arguments:

	XrbList - If non-NULL, Pointer to the nonpaged lookaside list
			the XRB should be allocated from. If NULL, signifies
			that the XRB should be allocated from nonpaged Pool.

	DeviceObject - Supplies a device object used to log memory
			allocation failures.

Return Value:

	If the function is successful, an initialized Xrb is returned.
	Otherwise NULL.

Environment:

	DISPATCH_LEVEL or below.

--*/
{
	PEXTENDED_REQUEST_BLOCK Xrb;

	ASSERT (DeviceObject != NULL);
	
	if (XrbList) {
		Xrb = ExAllocateFromNPagedLookasideList (XrbList);

		if (Xrb == NULL) {
			NYI();
			//
			// NB: Must log a memory error here.
			//
		}
	} else {
		Xrb = RaidAllocatePool (NonPagedPool,
								sizeof (EXTENDED_REQUEST_BLOCK),
								XRB_TAG,
								DeviceObject);
	}

	if (Xrb == NULL) {
		return NULL;
	}
	
	RtlZeroMemory (Xrb, sizeof (EXTENDED_REQUEST_BLOCK));
	Xrb->Signature = XRB_SIGNATURE;
	Xrb->Pool = XrbList;

	return Xrb;
}

VOID
RaidXrbDeallocateResources(
	IN PEXTENDED_REQUEST_BLOCK Xrb
	)
/*++

Routine Description:

	Private helper function that deallocates all resources associated
	with an Xrb. This function is used by RaFreeXrb() and
	RaPrepareXrbForReuse() to deallocate any resources the Xrb is
	holding.

Arguments:

	Xrb - Xrb to deallocate resources for.

Return Value:

	None.

--*/
{
	BOOLEAN WriteRequest;
	PNPAGED_LOOKASIDE_LIST Pool;
	
	if (Xrb->Mdl && Xrb->OwnedMdl) {
		IoFreeMdl (Xrb->Mdl);
		Xrb->Mdl = NULL;
		Xrb->OwnedMdl = FALSE;
	}

	if (Xrb->SgList != NULL) {
		ASSERT (Xrb->Adapter != NULL);
		WriteRequest = TEST_FLAG (Xrb->Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
		RaidDmaPutScatterGatherList (&Xrb->Adapter->Dma,
							         Xrb->SgList,
									 WriteRequest);
	}

#if 0
	//
	// This is done by the higher-level functions
	//
	Pool = Xrb->Pool;
	RtlZeroMemory (Xrb, sizeof (EXTENDED_REQUEST_BLOCK));
	Xrb->Signature = XRB_SIGNATURE;
	Xrb->Pool = Pool;
#endif
}

	

VOID
RaidFreeXrb(
	IN PEXTENDED_REQUEST_BLOCK Xrb
	)
/*++

Routine Description:

	Free the Xrb and deallocate any resources associated with it.

Arguments:

	Xrb - Xrb to deallocate.

Return Value:

	None.

--*/
{
	PNPAGED_LOOKASIDE_LIST Pool;

	RaidXrbDeallocateResources (Xrb);
	Pool = Xrb->Pool;
	DbgFillMemory (Xrb,
				   sizeof (EXTENDED_REQUEST_BLOCK),
				   DBG_DEALLOCATED_FILL);

	if (Pool) {
		ExFreeToNPagedLookasideList (Pool, Xrb);
	} else {
		RaidFreePool (Xrb, XRB_TAG);
	}
}


NTSTATUS
RaidBuildMdlForXrb(
	IN PEXTENDED_REQUEST_BLOCK Xrb,
	IN PVOID Buffer,
	IN SIZE_T BufferSize
	)
/*++

Routine Description:

	Build an MDL for the XRB describing the buffer region passed in. An
	XRB can have only one MDL per XRB.

Arguments:

	Xrb - XRB that will own the MDL.

	Buffer - Virtual Address of the buffer to build the MDL for.

	BufferSize - Size of the buffer to build the MDL for.

Return Value:

    NTSTATUS code.

--*/
{
	PAGED_CODE ();

	//
	// The MDL field of the XRB should be NULL before we allocate a new MDL.
	// Otherwise, we are likely to leak a MDL that the XRB already
	// has created.
	//
	
	ASSERT (Xrb->Mdl == NULL);
	
	Xrb->Mdl = IoAllocateMdl (Buffer, (ULONG)BufferSize, FALSE, FALSE, NULL);
	if (Xrb->Mdl == NULL) {
		return STATUS_NO_MEMORY;
	}

	//
	// By specifying that we own the MDL, we force it to be deleted
	// when we delete the XRB.
	//
	
	Xrb->OwnedMdl = TRUE;
	MmBuildMdlForNonPagedPool (Xrb->Mdl);

	return STATUS_SUCCESS;
}


VOID
RaidXrbSetSgList(
	IN PEXTENDED_REQUEST_BLOCK Xrb,
	IN PRAID_ADAPTER_EXTENSION Adapter,
	IN PSCATTER_GATHER_LIST SgList
	)
{
	ASSERT (Xrb->Adapter == NULL || Xrb->Adapter == Adapter);
	ASSERT (Xrb->SgList == NULL);

	Xrb->Adapter = Adapter;
	Xrb->SgList = SgList;
}
	

VOID
RaidPrepareXrbForReuse(
	IN PEXTENDED_REQUEST_BLOCK Xrb
	)
/*++

Routine Description:

	Prepare the Xrb to be reused.

Arguments:

	Xrb - Pointer to Xrb that will be reused.

Return Value:

	None.

Environment:

	Kernel Mode, DISPATCH_LEVEL or below.

--*/
{
	PNPAGED_LOOKASIDE_LIST Pool;

	RaidXrbDeallocateResources (Xrb);
	Pool = Xrb->Pool;
	RtlZeroMemory (Xrb, sizeof (EXTENDED_REQUEST_BLOCK));
	Xrb->Signature = XRB_SIGNATURE;
	Xrb->Pool = Pool;
}


VOID
RaidXrbSetCompletionRoutine(
	IN PEXTENDED_REQUEST_BLOCK Xrb,
	IN XRB_COMPLETION_ROUTINE XrbCompletion
	)
{
	ASSERT (Xrb->CompletionRoutine == NULL);
	Xrb->CompletionRoutine = XrbCompletion;
}


//
// Operations for SRBs
//


PSCSI_REQUEST_BLOCK
RaidAllocateSrb(
	IN PVOID IoObject
	)
/*++

Routine Description:

	Allocate and initialize a srb to a NULL state.
	
Arguments:

	DeviceObject - Supplies a device object for logging memory allocation
			errors.

Return Value:

	If successful, a poiter to an allocated SRB initialize to a null
	state.  Otherwise, NULL.

--*/
{
	PSCSI_REQUEST_BLOCK Srb;

	PAGED_CODE ();

	//
	// Allocate the srb from nonpaged pool.
	//
	
	Srb = RaidAllocatePool (NonPagedPool,
							sizeof (SCSI_REQUEST_BLOCK),
							SRB_TAG,
							IoObject);
	if (Srb == NULL) {
		return NULL;
	}

	RtlZeroMemory (Srb, sizeof (SCSI_REQUEST_BLOCK));

	return Srb;
}

VOID
RaidFreeSrb(
	IN PSCSI_REQUEST_BLOCK Srb
	)
/*++

Routine Description:

	Free a Srb back to pool.

Arguments:

	Srb - Srb to free.

Return Value:

    NTSTATUS code

--*/

{
	PAGED_CODE ();

	ASSERT (Srb != NULL);
	ASSERT (Srb->SrbExtension == NULL);
	ASSERT (Srb->OriginalRequest == NULL);
	ASSERT (Srb->SenseInfoBuffer == NULL);

	DbgFillMemory (Srb,
				   sizeof (SCSI_REQUEST_BLOCK),
				   DBG_DEALLOCATED_FILL);
	RaidFreePool (Srb, SRB_TAG);
}

VOID
RaidPrepareSrbForReuse(
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	PVOID SrbExtension;
	PVOID SenseInfo;

	PAGED_CODE ();

	SenseInfo = Srb->SenseInfoBuffer;
	SrbExtension = Srb->SrbExtension;
	RtlZeroMemory (Srb, sizeof (*Srb));
	Srb->SenseInfoBuffer = SenseInfo;
	Srb->SrbExtension = SrbExtension;
}


NTSTATUS
RaidInitializeInquirySrb(
	IN PSCSI_REQUEST_BLOCK Srb,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN PVOID Buffer,
	IN SIZE_T BufferSize
	)
/*++

Routine Description:

	Initialize a scsi inquiry srb.

Arguments:

	Srb - Pointer to the srb to initialize.

	PathId - Identifies the scsi path id for this srb.

	TargetId - Identifies the scsi target id for this srb.

	Lun - Identifies the scsi logical unit this srb is for.

	Buffer - The buffer the INQUIRY data will be read into.

	BufferSize - The size of the INQUIRY buffer. This should be
			at least INQUIRYDATABUFFERSIZE, but can be larger if
			more data is required.

Return Value:

    NTSTATUS code.

--*/
{
	struct _CDB6INQUIRY* Cdb;
	
	
	PAGED_CODE ();
	ASSERT (Srb != NULL);
	ASSERT (Buffer != NULL);
	ASSERT (BufferSize != 0);

	//  
	// NB: Should be be using the SCSI-2 or SCSI-3 INQUIRY?  This is
	// implemented using SCSI-2.
	//
	
	//
	// The buffer should be at least the size of the minimum
	// INQUIRY buffer size. It can be larger if we are requesting
	// extra data.
	//
	
	if (BufferSize < INQUIRYDATABUFFERSIZE) {
		ASSERT (FALSE);
		return STATUS_INVALID_PARAMETER_6;
	}
	
	//
	// The caller must have either just allocated this srb or
	// called RaPrepareSrbForReuse() on the srb. In either of
	// these cases, the Function and CdbLength should be zero.
	//

	ASSERT (Srb->Function == 0);
	ASSERT (Srb->CdbLength == 0);

	Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
	Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
	Srb->PathId = PathId;
	Srb->TargetId = TargetId;
	Srb->Lun = Lun;
	Srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
	Srb->TimeOutValue = 4; // Seconds
	Srb->DataBuffer = Buffer;
	Srb->DataTransferLength = (ULONG)BufferSize;

	ASSERT (Srb->SrbStatus == 0);
	ASSERT (Srb->ScsiStatus == 0);
	
	Srb->CdbLength = 6;
	Cdb = (struct _CDB6INQUIRY*)Srb->Cdb;

	Cdb->OperationCode = SCSIOP_INQUIRY;
	Cdb->AllocationLength = (UCHAR)BufferSize;
	Cdb->LogicalUnitNumber = Lun;

	//
	// These fields should have been zero'd out by the srb allocation
	// routine or the RaPrepareSrbForReuse routine.
	//
	
	ASSERT (Cdb->PageCode == 0);
	ASSERT (Cdb->Reserved1 == 0);
	ASSERT (Cdb->IReserved == 0);
	ASSERT (Cdb->Control == 0);

	return STATUS_SUCCESS;
}



//
// Routines for SRB extensions
//

PVOID
RaidAllocateSrbExtension(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG QueueTag
	)
/*++

Routine Description:

	Allocate a srb extension and initialize it to NULL.

Arguments:

	Pool - Fixed pool to allocate the srb extension from.

	QueueTag - Index into the extenion pool that should be allocated.

Return Value:

	Pointer to an initialized SRB Extension if the function was
	successful.

	NULL otherwise.

Environment:

	DISPATCH_LEVEL or below.

--*/
{
	PVOID Extension;

	Extension = RaidAllocateFixedPoolElement (Pool, QueueTag);
	RtlZeroMemory (Extension, Pool->SizeOfElement);

	return Extension;
}

VOID
RaidFreeSrbExtension(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG QueueTag
	)
/*++

Routine Description:

	Free a Srb extension.

Arguments:

	Pool - Fixed pool to free the srb extension to.

	QueueTag - Index into the extension pool that should be freed.

Return Value:

	None.

--*/
{
	RaidFreeFixedPoolElement (Pool, QueueTag);
}

VOID
RaidXrbSignalCompletion(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

	Callback routine that signals that a synchronous XRB has been completed.

Arguments:

	Xrb - Xrb to signal completion for.

Return Value:

	None.

--*/
{
    ASSERT_XRB (Xrb);
    KeSetEvent (&Xrb->u.CompletionEvent, IO_NO_INCREMENT, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\unit.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    unit.c

Abstract:

    Implementation of the operations on the logical unit for the RAIDPORT
    driver.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaUnitSystemControlIrp)
#pragma alloc_text(PAGE, RaUnitPnpIrp)
#pragma alloc_text(PAGE, RaUnitStartDeviceIrp)
#pragma alloc_text(PAGE, RaUnitStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaUnitQueryCapabilitiesIrp)
#pragma alloc_text(PAGE, RaUnitQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaUnitDeviceUsageNotificationIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaUnitQueryIdIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceTextIrp)
#pragma alloc_text(PAGE, RaUnitIgnorePnpIrp)
#pragma alloc_text(PAGE, RaUnitSucceedPnpIrp)
#pragma alloc_text(PAGE, RaUnitUnknownSrb)
#pragma alloc_text(PAGE, RaUnitDeviceControlIrp)
#pragma alloc_text(PAGE, RaUnitScsiGetAddressIoctl)
#pragma alloc_text(PAGE, RaUnitStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaUnitUnknownIoctl)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceProperty)
#endif // ALLOC_PRAGMA


//
// Globals
//

//
// Chained IO consolidates the free cycle of IO Request N with the allocation
// cycle of IO Request N+1, thus reducing back-to-back free and allocate
// requests.
//

LOGICAL RaidChainedIo = TRUE;


NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* UnitBuffer
    )
/*++

Routine Description:

    Create a null raid unit object.

Arguments:

    Adapter -

    UnitBuffer -
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PDEVICE_OBJECT DeviceObject;

    ASSERT_ADAPTER (Adapter);
    ASSERT (UnitBuffer != NULL);
    
    PAGED_CODE ();


    Status = IoCreateDevice (Adapter->DeviceObject->DriverObject,
                             sizeof (RAID_UNIT_EXTENSION),
                             NULL, // DeviceName,
                             FILE_DEVICE_MASS_STORAGE,
                             (FILE_AUTOGENERATED_DEVICE_NAME |
                              FILE_DEVICE_SECURE_OPEN),
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

DebugPrint (("Created Unit %p\n", DeviceObject));

    Unit = DeviceObject->DeviceExtension;
    RaidZeroUnit (Unit);
    Unit->Adapter = Adapter;
    Unit->DeviceObject = DeviceObject;

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    SET_FLAG (DeviceObject->Flags, DO_BUS_ENUMERATED_DEVICE);

    Unit->DeviceObject->AlignmentRequirement =
            Adapter->DeviceObject->AlignmentRequirement;


    //
    // Since the Unit is the child PDO from the adapter, we never
    // get an AddDevice call. Hence, we start in the stopped state.
    //
    
    Unit->DeviceState = DeviceStateNotPresent;

    //
    // Allocate all resources associated with the logical unit.
    //

    Status = RaidUnitAllocateResources (Unit);

    if (!NT_SUCCESS (Status)) {

        //
        // NB: Need to delete the unit,
        //
        
        NYI();
        return Status;
    }

    //
    // The unit queue is locked until we start the device.
    //
    
    RaidLockUnitQueue (Unit);

    *UnitBuffer = Unit;
    
    return STATUS_SUCCESS;
}


VOID
RaidZeroUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Return a logical unit to a NULL status.

Arguments:

    Unit - Logical unit to NULL.

Return Value:

    None.

--*/
{
    RtlZeroMemory (Unit, sizeof (RAID_UNIT_EXTENSION));
    Unit->ObjectType = RaidUnitObject;
    RaCreateTagList (&Unit->TagList);
    RaidCreateRegion (&Unit->SrbExtensionRegion);
    RaCreatePower (&Unit->Power);
    RaSetSystemPowerState (&Unit->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Unit->Power, PowerDeviceD0);
    StorCreateEventQueue (&Unit->PendingQueue);
    Unit->Address = RaidNullAddress;
}



VOID
RaidStartUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    PAGED_CODE();

    ASSERT_UNIT (Unit);
    ASSERT (Unit->DeviceObject != NULL);

    //
    // NB: Add assert to validate unit is on adapter list.
    //
    
    ASSERT (memcmp (&Unit->Address, &RaidNullAddress, sizeof (RaidNullAddress)) != 0);

    CLEAR_FLAG (Unit->DeviceObject->Flags, DO_DEVICE_INITIALIZING);
}



VOID
RaidDeleteUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine deallocates any resources associated with a RAID Unit
    object, preparing the buffer for reuse. This routine must be called
    for every unit before the unit's memory is deallocated.

Arguments:

    Unit - Unit to be deleted.

Return Value:

    NTSTATUS code

--*/
{
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    Status = RaidUnitFreeResources (Unit);
    ASSERT (NT_SUCCESS (Status));

    //
    // When we call IoDeleteDevice, the memory for the unit object is
    // deallocated. So save the memory for the unit object before 
    //
    
    DeviceObject = Unit->DeviceObject;
    DbgFillMemory (Unit,
                   sizeof (RAID_UNIT_EXTENSION),
                   DBG_DEALLOCATED_FILL);
    IoDeleteDevice (DeviceObject);
    
}



VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Assign a logical unit's RAID (SCSI) Address. Addresses CAN be modified
    dynamically, although the user should be careful that all outstanding
    requests are completed before any attempt is made to modify the
    Address.

Arguments:

    Unit - Supplies the logical unit to assign the SCSI address to.

    Address - Supplies the SCSI address to assign.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    Unit->Address = Address;
}

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    )
/*++

Routine Description:

    Assign a logical unit's identity. The identity includes the SCSI
    INQUIRY data, plus pages 80 and 80 of the Vital Product Data.

Arguments:

    Unit - Supplies the logical unit whose identity is to be assigned.

    Identity - Supplies a pointer to the identity to be assigned. By
            calling this call, the caller grants ownership of the
            identity data to the logical unit. It must not access this
            buffer after calling this function.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    RtlCopyMemory (&Unit->Identity, Identity, sizeof (Unit->Identity));
    RtlZeroMemory (Identity, sizeof (*Identity));
}



NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Allocate all resources necessary for a logical unit to function.

Arguments:

    Unit - Supplies the logical unit to allocate resources for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG NumberOfElements;
    ULONG SrbExtensionSize;
    PVOID SrbExtensionBuffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    LARGE_INTEGER LargeTimeout;
    PRAID_ADAPTER_EXTENSION Adapter;

    Adapter = Unit->Adapter;
    
    IoInitializeRemoveLock (&Unit->RemoveLock,
                            REMLOCK_TAG,
                            REMLOCK_MAX_WAIT,
                            REMLOCK_HIGH_MARK);


    //
    // Create two pools of shared dma memory, one for srb extensions
    // and one for sense info buffers.
    //

    NumberOfElements = TAG_QUEUE_COUNT;
    SrbExtensionSize = RaGetSrbExtensionSize (Unit->Adapter);


    //
    // Srb extension pool.
    //

    Status = RaidDmaAllocateCommonBuffer (&Unit->Adapter->Dma,
                                          NumberOfElements * SrbExtensionSize,
                                          FALSE,
                                          &Unit->SrbExtensionRegion);

    if (!NT_SUCCESS (Status)) {
        return STATUS_NO_MEMORY;
    }
    
    RaidInitializeFixedPool (&Unit->SrbExtensionPool,
                             RaidRegionGetVirtualBase (&Unit->SrbExtensionRegion),
                             NumberOfElements,
                             SrbExtensionSize);

    //
    // Xrb lookaside list.
    //

    ExInitializeNPagedLookasideList (&Unit->XrbList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (EXTENDED_REQUEST_BLOCK),
                                     XRB_TAG,
                                     0);

    RaInitializeTagList (&Unit->TagList,
                         TAG_QUEUE_COUNT,
                         Unit->DeviceObject);

    //
    // Initialize the pending queue.
    //
    
    StorInitializeEventQueue (&Unit->PendingQueue);

    KeInitializeDpc (&Unit->PendingDpc,
                     RaidUnitPendingDpcRoutine,
                     Unit->DeviceObject);

    KeInitializeTimer (&Unit->PendingTimer);

    //
    // Set timer to fire once per second.
    //

    LargeTimeout.QuadPart = 1;
    LargeTimeout.QuadPart *= SECONDS;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    
    KeSetTimerEx (&Unit->PendingTimer,
                  LargeTimeout,
                  1 * 1000,             // milli
                  &Unit->PendingDpc);
    
    KeInitializeSpinLock (&Unit->SlowLock);

    //
    // Initialize an IO_QUEUE for the unit object.
    //
    
    RaidInitializeIoQueue (&Unit->IoQueue,
                           Unit->DeviceObject,
                           &Unit->Adapter->Gateway,
                           RaUnitStartIo,
                           TAG_QUEUE_COUNT);


    //
    // Create logical unit extension, if necessary.
    //

    if (Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize) {
        Unit->UnitExtension = RaidAllocatePool (NonPagedPool,
                                                Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize,
                                                UNIT_EXT_TAG,
                                                Unit->DeviceObject);
                                                
        if (Unit->UnitExtension == NULL) {
            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;
}



NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Release all resources associated with a logical unit.

Arguments:

    Unit - Supplies the logical unit to release resources for.

Return Value:

    NTSTATUS code.

--*/
{
    PVOID Buffer;

    PAGED_CODE();
    
    //
    // Free the XRB lookaside list.
    //

    if (Unit->XrbList.L.Size != 0) {
        ExDeleteNPagedLookasideList (&Unit->XrbList);
    }

    //
    // Free the SRB extension region and pool, if necessary.
    //
    
    if (RaidIsRegionInitialized (&Unit->SrbExtensionRegion)) {

        RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                 &Unit->SrbExtensionRegion,
                                 FALSE);
        RaidDeleteFixedPool (&Unit->SrbExtensionPool);
    }

    StorDeleteEventQueue (&Unit->PendingQueue);
    StorDeleteScsiIdentity (&Unit->Identity);
    RaDeleteTagList (&Unit->TagList);

    if (Unit->UnitExtension != NULL) {
        RaidFreePool (Unit->UnitExtension, UNIT_EXT_TAG);
        Unit->UnitExtension = NULL;
    }

    KeCancelTimer (&Unit->PendingTimer);

//    StorDeleteEventQueue (&Unit->PendingQueue);

    return STATUS_SUCCESS;
}



//
// Handler functions.
//

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (&Unit->RemoveLock, Irp);
}

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (&Unit->RemoveLock, Irp);
}

NTSTATUS
RaUnitSystemControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for system control (WMI) irps for the logical unit.

Arguments:

    Unit - Logical unit to handle the irp.

    Irp - Irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;

    PAGED_CODE ();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_NOT_SUPPORTED);
}


NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the PnP dispatch routine for the Raid Unit object.  It's
    purpose it to forward the irp on to sub-dispatch routines for the
    specific irp.

Arguments:

    Unit - The unit object this irp is for.

    Irp - Pnp irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;
    
    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Pnp, Minor %x\n",
                 Unit,
                 Irp,
                 Minor));

    //
    // Dispatch the IRP to one of our handlers.
    //

    switch (Minor) {

        case IRP_MN_START_DEVICE:
            Status = RaUnitStartDeviceIrp (Unit, Irp);
            break;
        
        case IRP_MN_STOP_DEVICE:
            Status = RaUnitStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaUnitQueryStopDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaUnitCancelStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaUnitQueryRemoveDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaUnitCancelRemoveDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaUnitSurpriseRemovalIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_CAPABILITIES:
            Status = RaUnitQueryCapabilitiesIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaUnitQueryPnpDeviceStateIrp (Unit, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            Status = RaUnitDeviceUsageNotificationIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaUnitQueryDeviceRelationsIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaUnitQueryIdIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:
            Status = RaUnitQueryDeviceTextIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = RaUnitSucceedPnpIrp (Unit, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_BUS_INFORMATION:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        default:
            Status = RaUnitIgnorePnpIrp (Unit, Irp);

    }

    DebugTrace (("Unit %p, Irp %p, Pnp Minor %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Minor,
                 Status));

    if (RemlockHeld) {
        IoReleaseRemoveLock (&Unit->RemoveLock, Irp);
    }

    return Status;
}


NTSTATUS
RaUnitStartDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to start.

    Irp - Start device irp.

Return Value:

    NTSTATUS code.

--*/

{
    DEVICE_STATE PreviousState;
    
    PAGED_CODE ();

    RaidUnlockUnitQueue (Unit);
    PreviousState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                         DeviceStateWorking);
    ASSERT (PreviousState == DeviceStateStopped);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to stop.

    Irp - Stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    RaidLockUnitQueue (Unit);

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitQueryStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )

/*++

Routine Description:

    Handler function for the unit query stop device irp.

Arguments:

    Unit - Unit to query for stop.

    Irp - Query stop device irp.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    //
    // NB: Even if we fail this IRP, we must still enter the PendingStop
    // state because the PnP manager will send us cancel stop after this.
    //
    
    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    
    if (Unit->PagingPathCount == 0) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }
    
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitCancelStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for unit cancel stop device irp.

Arguments:

    Unit - Unit to cancel stop for.

    Irp - Cancel stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateWorking);

    //
    // We can receive a cancel stop without having ever receiving a
    // pending stop. This is ok, either way we want to go back to
    // working state.
    //
    
    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



NTSTATUS
RaUnitRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to remove.

    Irp - Remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateRemoved);

    switch (PriorState) {

        case DeviceStateRemoved:

            //
            // This is the second remove IRP. Actually delete underlying
            // resources this time.
            //
            
            ASSERT (!Unit->Flags.Enumerated);
            RaidAdapterRemoveUnit (Unit->Adapter, Unit);
            RaidDeleteUnit (Unit);
            break;

        case DeviceStatePendingRemove:

            //
            // Release remove lock and wait for all pending IO to complete.
            //

            IoReleaseRemoveLockAndWait (&Unit->RemoveLock, Irp);
            break;

        case DeviceStateSurpriseRemoval:
        case DeviceStateStopped:

            //
            // Delete all outstanding/queued requests.
            //

            REVIEW();

            break;
            
        default:
            ASSERT (!"PnP state machine is broken.");
    }
    
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitQueryRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit query remove device irp.

Arguments:

    Unit - Unit to query remove for.

    Irp - Query remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    if (Unit->PagingPathCount == 0) {
        PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                          DeviceStatePendingRemove);
        ASSERT (PriorState == DeviceStateWorking);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitCancelRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to cancel remove device for.

    Irp - Cancel remove device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = InterlockedExchange ((PLONG)&Unit->DeviceState,
                                      DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingRemove ||
            PriorState == DeviceStateWorking);
            
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitSurpriseRemovalIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit surprise removal irp.

Arguments:

    Unit - Unit to surprise remove.

    Irp - Surprise removal irp.

Return Value:

    NTSTATUS code

--*/
{
    PAGED_CODE ();

    InterlockedExchange ((PLONG)&Unit->DeviceState,
                         DeviceStateSurpriseRemoval);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}
    

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for the query capabilities PnP irp on the unit object.

Arguments:

    Unit - Unit to query.

    Irp - Query capabilities irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_CAPABILITIES Capabilities;
    PSCSI_DEVICE_TYPE DeviceType;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    //
    // Setup parameters
    //
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Capabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

    RtlZeroMemory (Capabilities, sizeof (*Capabilities));
    DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

    //
    // Storage devices install silently.
    //
    
    if (DeviceType->IsStorage) {
        Capabilities->SilentInstall = TRUE;
    }

    Capabilities->Address = StorGetAddressTargetId (Unit->Address);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the query device state irp for the logical unit.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Query device state irp to handle.

Return Value:
<
    NTSTATUS code

--*/
{
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    DeviceState = (PPNP_DEVICE_STATE)&Irp->IoStatus.Information;
    if (Unit->PagingPathCount) {
        SET_FLAG (*DeviceState, PNP_DEVICE_NOT_DISABLEABLE);
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



NTSTATUS
RaUnitDeviceUsageNotificationIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the PnP device usage notification irp.

Arguments:

    Unit - Unit the irp is for.

    Irp - Device usage irp to handle.x

Return Value:

    NTSTATUS code.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    DEVICE_USAGE_NOTIFICATION_TYPE Type;
    BOOLEAN Increment;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.UsageNotification.Type;
    Increment = IrpStack->Parameters.UsageNotification.InPath;
    

    if (Type == DeviceUsageTypeDumpFile ||
        Type == DeviceUsageTypePaging ||
        Type == DeviceUsageTypeHibernation) {

        IoAdjustPagingPathCount (&Unit->PagingPathCount,
                                 Increment);
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query device relations irp for the unit. The unit only
    supports querying TargetDeviceRelations.

Arguments:

    Unit - Unit to query.

    Irp - Query device relations irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDEVICE_RELATIONS DeviceRelations;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_RELATION_TYPE Type;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceRelations.Type;

    if (Type == TargetDeviceRelation) {
        DeviceRelations = RaidAllocatePool (PagedPool,
                                            sizeof (DEVICE_RELATIONS),
                                            DEVICE_RELATIONS_TAG,
                                            Unit->DeviceObject);

        if (DeviceRelations != NULL) {
            DeviceRelations->Count = 1;
            DeviceRelations->Objects[0] = Unit->DeviceObject;
            ObReferenceObject (Unit->DeviceObject);
            Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    } else {
        //
        // We must complete the request with it's current status.
        //
        Status = Irp->IoStatus.Status;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

//
// BUGBUG: For now in free as well
//
VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    );
    
NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query id request for the unit.

Arguments:

    Unit - Unit to handle the request.

    Irp - Query id request to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BUS_QUERY_ID_TYPE IdType;
    PIO_STACK_LOCATION IrpStack;
    PWSTR Id;
    
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    IdType = IrpStack->Parameters.QueryId.IdType;
    Id = NULL;
    
    switch (IdType) {

        case BusQueryDeviceID:
            Status = RaidUnitGetDeviceId (Unit, &Id);
#if DBG
            if (NT_SUCCESS (Status)) {
                DbgPrintIds (IdType, Id);
            }
#endif
            break;

        case BusQueryInstanceID:
            Status = RaidUnitGetInstanceId (Unit, &Id);
            break;

        case BusQueryHardwareIDs:
            Status = RaidUnitGetHardwareIds (Unit, &Id);
            break;

        case BusQueryCompatibleIDs:
            Status = RaidUnitGetCompatibleIds (Unit, &Id);
            break;

        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            Id = NULL;
    }

    Irp->IoStatus.Information = (ULONG_PTR) Id;
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    )
{
    ULONG i;
    PWSTR String;
    
    switch (IdType) {

        case BusQueryDeviceID:
            DbgPrint ("RAID: DeviceId: %ws\n", Id);
            break;

        case BusQueryInstanceID:
            DbgPrint ("RAID: InstanceId: %ws\n", Id);
            break;

        case BusQueryHardwareIDs:
            for (String = Id, i=0;
                 String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("RAID: HardwareId[%d] %ws\n", i, String);
            }
            break;

        case BusQueryCompatibleIDs:
            for (String = Id, i=0;
                 !String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("RAID: CompatibleId[%d] %ws\n", i, String);
            }
            break;
    }
}

NTSTATUS
RaUnitQueryDeviceTextIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{

    NTSTATUS Status;
    PWCHAR Buffer;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    PSCSI_DEVICE_TYPE DeviceType;   
    PIO_STACK_LOCATION IrpStack;
    DEVICE_TEXT_TYPE Type;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceText.DeviceTextType;
    
    Buffer = RaidAllocatePool (PagedPool,
                               256 * sizeof (WCHAR),
                               QUERY_TEXT_TAG,
                               Unit->DeviceObject);

    if (Buffer == NULL) {
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_NO_MEMORY);
    }
    
    switch (Type) {

        case DeviceTextDescription:
            //
            // We use "<VENDOR> SCSI <DEVICE-TYPE> Device", like SCSIPORT.
            //

            StorGetIdentityVendorId (&Unit->Identity,
                                     VendorId,
                                     sizeof (VendorId),
                                     TRUE);

            DeviceType = StorGetIdentityDeviceType (&Unit->Identity);
            swprintf (Buffer,
                      L"%hs SCSI %hs Device",
                      VendorId,
                      DeviceType->Name);
                      
            Status = STATUS_SUCCESS;
        break;

        case DeviceTextLocationInformation:
            //
            // We use "Bus Number <PathId>, Target ID <TargetId>, LUN <LUN>",
            // like SCSIPORT.
            //
            swprintf (Buffer,
                      L"Bus Number %d, Target Id %d, LUN %d",
                      Unit->Address.PathId,
                      Unit->Address.TargetId,
                      Unit->Address.Lun);
                      
            Status = STATUS_SUCCESS;
        break;

        default:
            ExFreePool (Buffer);
            Buffer = NULL;
            Status = STATUS_NOT_SUPPORTED;
    }

    Irp->IoStatus.Information = (ULONG_PTR)Buffer;
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

       
NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Irp->IoStatus.Status);
}
    
NTSTATUS
RaUnitSucceedPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for SCSI irps. 

Arguments:

    Unit - Unit to handle the scsi irp.

    Irp - Scsi irp to handle.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    UCHAR Srb;


    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    Srb = RaidSrbFunctionFromIrp (Irp);

    DebugTrace (("Unit %p, Irp %p, Scsi, Srb %x\n",
                 Unit,
                 Irp,
                 Srb));
                    
    switch (Srb) {

        case SRB_FUNCTION_EXECUTE_SCSI:
            Status = RaUnitExecuteScsiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_CLAIM_DEVICE:
            Status = RaUnitClaimDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_DEVICE:
            Status = RaUnitReleaseDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_BUS:
            Status = RaUnitResetBusSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH_QUEUE:
            Status = RaUnitFlushQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_QUEUE: 
            Status = RaUnitReleaseQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_LOCK_QUEUE:
            Status = RaUnitLockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_UNLOCK_QUEUE:
            Status = RaUnitUnlockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH:
            Status = RaUnitFlushSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_SHUTDOWN:
            Status = RaUnitShutdownSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_IO_CONTROL:
            Status = RaUnitIoControlSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_WMI:
            Status = RaUnitWmiSrb (Unit, Irp);
            break;
#if 0
        case SRB_FUNCTION_ATTACH_DEVICE:
            Status = RaUnitAttachDeviceSrb (Unit, Irp);
            break;


        case SRB_FUNCTION_RECEIVE_EVENT:
            Status = RaUnitReceiveEventSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_ABORT_COMMAND:
            Status = RaUnitAbortCommandSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_RECOVERY:
            Status = RaUnitReleaseRecoverySrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_DEVICE:
            Status = RaUnitResetDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_TERMINATE_IO:
            Status = RaUnitTerminateIoSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceSrb (Unit, Irp);
            break;

#endif

        default:
            Status = RaUnitUnknownSrb (Unit, Irp);

    }

    DebugTrace (("Unit %p, Irp %p, Scsi, Srb %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Srb,
                 Status));

    IoReleaseRemoveLock (&Unit->RemoveLock, Irp);

    return Status;
}



NTSTATUS
RaidUnitSubmitRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    BOOLEAN ByPassRequest;
    PSCSI_REQUEST_BLOCK Srb;
    
    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

    //
    // We only expect two kinds of SRBs to be send down.
    //
    
    ASSERT (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI ||
            Srb->Function == SRB_FUNCTION_IO_CONTROL);

    //
    // Since the bypass frozen and bypass locked flags will not
    // normally be set, we will not normally take this conditional,
    // hence we will not normally have to figure out whether the
    // unit queue is frozen or locked (which requires the
    // aquisition of a spinlock to accomplish).
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {

        if ( (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
              RaidIsUnitQueueFrozen (Unit)) ||
             (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE) &&
               RaidIsUnitQueueLocked (Unit)) ) {

            ByPassRequest = FALSE;
        } else {
            ByPassRequest = TRUE;
        }
    } else {
        ByPassRequest = FALSE;
    }

    RaidStartIoPacket (&Unit->IoQueue,
                       Irp,
                       ByPassRequest,
                       NULL);

    Status = STATUS_PENDING;

    return Status;
}


NTSTATUS
RaUnitExecuteScsiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the SRB_FUNCTION_EXECUTE_SCSI command by queuing the request
    on the LUN queue.

Arguments:

    Unit - Unit to execute the srb on.

    Irp - Irp to execute.

Return Value:

    STATUS_PENDING - On success.

    Other NTSTATUS code - On failure.

    NB: STATUS_SUCCESS should NEVER be returned from this function.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}


NTSTATUS
RaidUnitAllocateIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
{
    //
    // In the current driver architecture, the allocation of the QueueTag
    // can never fail. So don't bother to check for failure.
    //
    
    IoResources->QueueTag = RaAllocateTag (&Unit->TagList);
    ASSERT (IoResources->QueueTag != -1);

    //
    // When the queue tag is allocated, the srb extension slot is reserved.
    // Therefore, the srb extension allocation also cannot fail.
    //
    
    IoResources->SrbExtension =
            RaidAllocateSrbExtension (&Unit->SrbExtensionPool,
                                      IoResources->QueueTag);
    ASSERT (IoResources->SrbExtension != NULL);


    //
    // PERF NOTE: RaidAllocateXrb uses a lookaside list for allocations
    // which locks the bus. We could remove the bus lock by using
    // a fixed pool instead of a lookaside list and not locking at all.
    //

    IoResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                        Unit->DeviceObject);
    ASSERT (IoResources->Xrb != NULL);

    return STATUS_SUCCESS;
}

VOID
RaidUnitFreeIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PRAID_IO_RESOURCES IoResources
    )
{
    RaidFreeSrbExtension (&Unit->SrbExtensionPool, IoResources->QueueTag);

    //
    // Free the queue tag.
    //

    RaFreeTag (&Unit->TagList, IoResources->QueueTag);

    //
    // Free the XRB.
    //
    
    RaidFreeXrb (IoResources->Xrb);

    DbgFillMemory (IoResources, sizeof (RAID_IO_RESOURCES), DBG_DEALLOCATED_FILL);
}



NTSTATUS
RaidUnitClaimIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp,
    IN PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    This routine will allocate any resources necessary to accomplish the
    IO for this specific IRP. At this point, these resources are generally
    SRB resources: queue tag, srb extension, Xrb.

    After an IRP is claimed, it must be released using RaidUnitReleaseIrp.

    This function is only necessary for IRP_MJ_SCSI IRPs.
    
Arguments:

    Unit - Specifies a unit that this SRB should be claimed by.

    Irp - Specifies an IRP to claim.

    IoResources - Preallocated resources to use for this IO.

Return Value:

    NTSTATUS code.

Note:

    This function is generally called from the unit's StartIo routine.

--*/
{
    NTSTATUS Status;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCSI_REQUEST_BLOCK Srb;
    RAID_IO_RESOURCES IoResourcesBuffer;
        

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);

    //
    // Each irp maintains a reference on the remove lock while being
    // processed. If this lock cannot be acquired, it means we are
    // in the process of being removed, so return status to fail
    // the irp.
    //
    
    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If we weren't given any resources, allocate necessary resources.
    // Otherwise, we'll reuse the resources from the previous IRP.
    //
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        Status = RaidUnitAllocateIoResources (Unit, IoResources);
        ASSERT (Status == STATUS_SUCCESS);
    }
    
    //
    // Fill in the SCSI target information.
    //

    Srb->TargetId = Unit->Address.TargetId;
    Srb->PathId = Unit->Address.PathId;
    Srb->Lun = Unit->Address.Lun;
    Srb->QueueTag = (UCHAR)IoResources->QueueTag;

    //
    // Fill in Xrb fields.
    //

    Xrb = IoResources->Xrb;
    Xrb->Irp = Irp;
    Xrb->Srb = Srb;
    Xrb->Unit = Unit;
    Xrb->Mdl = Irp->MdlAddress;

    //
    // Save SRB fields that we may modify.
    //
    
    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;

    //
    // Link the Srb to the Xrb and backlink the Xrb to the Srb.
    //
    
    Srb->OriginalRequest = Xrb;

    //
    // Set the Srb extension.
    //

    Srb->SrbExtension = IoResources->SrbExtension;

    //
    // Perform any buffer mapping that may be necessary.
    //
    
    RaidAdapterMapBuffers (Unit->Adapter, Irp);
    
    //
    // Add the IRP to the unit pending list.
    //
    
    RaUnitAddToPendingList (Unit, Irp);
    
    return STATUS_SUCCESS;
}


VOID
RaidUnitReleaseIrp(
    IN PIRP Irp,
    OUT PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    Undo any modifications to the IRP and SRB that were done by
    RaidUnitClaimIrp.

    This function is generally called from the Dpc routine before the
    IRP has been completed.

Arguments:

    Irp - Irp to release.

    IoResources - Buffer to return resources.

Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    BOOLEAN FreeResources;
    RAID_IO_RESOURCES IoResourcesBuffer;

    Srb = RaidSrbFromIrp (Irp);
    Xrb = RaidGetAssociatedXrb (Srb);
    Unit = Xrb->Unit;
    ASSERT_UNIT (Unit);

    //
    // First, remove the irp from the pending list.
    //
    
    RaUnitRemoveFromPendingList (Unit, Irp);

    //
    // Undo any modifications we made to the srb.
    //

    Srb->OriginalRequest = Xrb->SrbData.OriginalRequest;
    Srb->DataBuffer = Xrb->SrbData.DataBuffer;

    if (IoResources) {
        FreeResources = FALSE;
    } else {
        FreeResources = TRUE;
        IoResources = &IoResourcesBuffer;
    }

    RaidPrepareXrbForReuse (Xrb);
    IoResources->QueueTag = Srb->QueueTag;
    IoResources->SrbExtension = Srb->SrbExtension;
    IoResources->Xrb = Xrb;

    //
    // Fixup the SrbExtension field so upper layers don't access
    // memory they are not permitted to access.
    //
    
    Srb->SrbExtension = NULL;

    if (FreeResources) {
        RaidUnitFreeIoResources (Unit, IoResources);
    }

    //
    // The request maintains a reference to the remove lock while being
    // processed. Release it here.
    //
    
    IoReleaseRemoveLock (&Unit->RemoveLock, Irp);

}



VOID
RaidUnitCompleteRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine is called by the adapter's DPC routine after an
    asynchronous IO has completed. It needs to complete the underlying
    IRP and deallocate any resources associated with the IRP.

Arguments:

    Xrb - Xrb to be completed.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);


    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

        //
        // The IO was successful. Mark the IRP as successful, release
        // resources associated with the IRP and complete the request.
        //
        
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = Srb->DataTransferLength;

        //
        // Release any resources owned by this IRP/SRB, and fixup
        // any modifications we made to the SRB.
        //

        if (RaidChainedIo) {
            RaidUnitReleaseIrp (Irp, &IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }

        //
        // Complete the request
        //

        DebugTrace (("Unit %p, Irp %p, completing = %08x\n",
                     Unit,
                     Irp,
                     Irp->IoStatus.Status));

        
        RaidCompleteRequest (Irp, IO_DISK_INCREMENT, Irp->IoStatus.Status);

        //
        // Start the next io packet.
        //

        if (RaidChainedIo) {

#if 0
            {
                PSTOR_IO_GATEWAY Gateway;

                Gateway = &Unit->Adapter->Gateway;
                
                if (Gateway->BusyCount > 0 &&
                    Gateway->Outstanding - 1 < Gateway->LowWaterMark &&
                    Unit->IoQueue.DeviceQueue.DeviceRequests > 0) {

                    REVIEW();
                }
            }
#endif
            
            Started = RaidStartNextIoPacket (&Unit->IoQueue,
                                             FALSE,
                                             &IoResources,
                                             &RestartQueues);
            if (!Started) {
                RaidUnitFreeIoResources (Unit, &IoResources);
            }
        } else {
            RaidStartNextIoPacket (&Unit->IoQueue,
                                   FALSE,
                                   NULL,
                                   &RestartQueues);
        }

        if (RestartQueues) {
            RaidAdapterRestartQueues (Unit->Adapter);
        }
        
    } else {

        //
        // Error: Leave all the detail of handling the error, including
        // whether the IRP should be released and completed or not, to
        // the error handling routine.
        //
           
        RaUnitAsyncError (Unit, Xrb);
    }

}


VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Start the next irp on the specified logical unit.

Arguments:

    DeviceObject - DeviceObject associated with the logical unit
            to start the next irp on.

    Irp - Irp to execute.

    Context - Context for this call.

Return Value:

    None. All errors will be handled asynchronously in the DPC routine.

Environment:

    Called from DISPATCH_LEVEL only.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;

    //
    // StartIo should only be called from DISPATCH_LEVEL.
    //
    
    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);

    //
    // Get the logical unit extension.
    //
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);

    //
    // Allocate any resources necessary, and modify the associated SRB
    // to be for this LU.

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {

        REVIEW ();

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        DebugTrace (("Unit %p, Irp %p, completing %08x\n",
                     Irp->IoStatus.Status));
        RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }
        
        
    ASSERT (NT_SUCCESS (Status));

    //
    // Get associated Xrb.
    //
    
    Xrb = RaidXrbFromIrp (Irp);

    //
    // Set a completion routine for the Xrb.
    //

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteRequest);
    
    //
    // Issue the Execute request to the adapter.
    //
    
    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

    //
    // Busy errors are handled synchronously. All other IO related errors
    // are handled asynchronously (in the Dpc routine).
    //
    
    if (!NT_SUCCESS (Status)) {

        REVIEW();
        
        //
        // This means we weren't even able to submit the request to the
        // miniport. There's nothing to do but fail the request.
        //

        RaidUnitReleaseIrp (Irp, NULL);
        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }
}

NTSTATUS
RaUnitClaimDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    If the device is unclaimed, claim it, otherwise return STATUS_DEVICE_BUSY
    as an error.

Arguments:

    Unit - The unit to claim.

    Irp - The irp representing the claim device irp.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    PSCSI_REQUEST_BLOCK Srb;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    Srb = RaidSrbFromIrp (Irp);
    if (!Unit->Flags.DeviceClaimed) {
        Unit->Flags.DeviceClaimed = TRUE;
        Srb->DataBuffer = Unit->DeviceObject;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Status = STATUS_SUCCESS;
    } else {
        Srb->DataBuffer = NULL;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_DEVICE_BUSY;
        Status = STATUS_DEVICE_BUSY;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitReleaseDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Release the claim on this unit.

Arguments:

    Unit - The unit which must have been claimed.

    Irp - The release device irp.
    
Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    Srb = RaidSrbFromIrp (Irp);
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // The class driver is not allowed to release the device multiple
    // times.
    //
    
    ASSERT (Unit->Flags.DeviceClaimed);
    Unit->Flags.DeviceClaimed = FALSE;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Status = STATUS_SUCCESS;

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitIoControlSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle an ioctl SRB sent to the miniport.

Arguments:

    Unit - Logical unit the ioctl SRB is for.

    Irp - IRP representing an SRB ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitReleaseQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    RaidResumeUnitQueue (Unit);
    Irp->IoStatus.Information = 0;

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP FlushIrp
    )

/*++

Routine Description:

    Flush the pending queue, canceling all requests.

Arguments:

    Unit - Supplies pointer to unit to flush.

    FlushIrp - Supplies the IRP representing the flush queue request.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/

{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    

    ASSERT (RaidIsUnitQueueFrozen (Unit));

    //
    // Flush all entries.
    //
    
    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;

        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_UNSUCCESSFUL);
    }

    RaidResumeUnitQueue (Unit);
    
    FlushIrp->IoStatus.Information = 0;
    return RaidCompleteRequest (FlushIrp, IO_NO_INCREMENT, STATUS_SUCCESS);
}


NTSTATUS
RaUnitReceiveEventSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitAttachDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaUnitShutdownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    return RaUnitFlushSrb (Unit, Irp);
}

NTSTATUS
RaUnitFlushSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN ByPassFrozen;


    if (!Unit->Adapter->Miniport.PortConfiguration.CachesData) {

        Status = RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);

    } else {

        Srb = RaidSrbFromIrp (Irp);
        IoMarkIrpPending (Irp);
        RaidSrbMarkPending (RaidSrbFromIrp (Irp));
        ByPassFrozen = TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE);
        RaidStartIoPacket (&Unit->IoQueue,
                           Irp,
                           ByPassFrozen,
                           NULL);
        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
RaUnitAbortCommandSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitReleaseRecoverySrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitResetBusSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitResetDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitTerminateIoSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitRemoveDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitWmiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitLockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    //
    // Lock the device queue, queuing all pending IRPs for processing
    // later. This is used in Power Management.
    //

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnlockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    //
    // Unlock the unit device queue, allowing all queued IRPs to continue
    // processing. This is used in Power Management.
    //

    RaidUnlockUnitQueue (Unit);

    //
    // BUGBUG: Do we need to explicitly restart the queue? Probably.
    // See the QueueChanged loop in RaidStartNextIoPacket for an
    // example on how to do this. If we don't do this, we will not
    // send the next request down until the next IO operation is
    // started.
    //

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnknownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    PAGED_CODE ();

    //
    // Fail requests we do not handle.
    //

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    Status = STATUS_NOT_SUPPORTED;
    Srb->InternalStatus = Status;

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}


NTSTATUS
RaUnitPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for the unit's power irps.

Arguments:

    Unit - Unit to handle the power irp.

    Irp - Irp to be handled.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_POWER);
    Minor = RaidMinorFunctionFromIrp (Irp);
    
    switch (Minor) {

        case IRP_MN_QUERY_POWER:
            Status = RaidUnitQueryPowerIrp (Unit, Irp);
            break;

        case IRP_MN_SET_POWER:
            Status = RaidUnitSetPowerIrp (Unit, Irp);
            break;

        default:
            PoStartNextPowerIrp (Irp);
            Status = RaidCompleteRequest (Irp,
                                          IO_NO_INCREMENT,
                                          STATUS_NOT_SUPPORTED);
    }

    return Status;
}

NTSTATUS
RaidUnitQueryPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP_MN_QUERY_POWER irp for the unit.
    
Arguments:

    Unit - Logical unit that must handle the irp.

    Irp - Query power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    //
    // Succeed all queries.
    //

    //
    // NB: Do we need to set the IoStatus.Status for the irp to success
    // before calling PoStartNextPowerIrp?
    //

    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}

NTSTATUS
RaidUnitSetPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP_MN_SET_POWER irps for the logical unit.

Arguments:

    Unit - Logical unit to handle this irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    POWER_STATE_TYPE PowerType;
    POWER_STATE PowerState;
    
    //
    // Ignore shutdown irps.
    //

    PowerState = RaidPowerStateFromIrp (Irp);
    
    if (PowerState.SystemState >= PowerSystemShutdown) {

        PoStartNextPowerIrp (Irp);
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
    }
    
    PowerType = RaidPowerTypeFromIrp (Irp);

    switch (PowerType) {

        case SystemPowerState:
            Status = RaidUnitSetSystemPowerIrp (Unit, Irp);
            break;

        case DevicePowerState:
            Status = RaidUnitSetDevicePowerIrp (Unit, Irp);
            break;

        default:
            ASSERT (FALSE);
            Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
RaidUnitSetSystemPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the IRP_MJ_POWER, IRP_MN_SET_POWER irp of type SystemPowerState.

Arguments:

    Unit - Logical unit to handle the irp.

    Irp - Set power irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    SYSTEM_POWER_STATE CurrentState;
    SYSTEM_POWER_STATE RequestedState;
    POWER_STATE PowerState;
    BOOLEAN RequestHandled;

    ASSERT_UNIT (Unit);
    ASSERT (RaidPowerTypeFromIrp (Irp) == SystemPowerState);
    
    DebugTrace (("Unit %p, Irp %p, SetSystemPower\n",
                  Unit, Irp));
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Unit->Power.SystemState;
    RequestedState = IrpStack->Parameters.Power.State.SystemState;

    //
    // If the request has been handled then we do not complete it. Otherwise,
    // it is our responsability to complete it.
    //
    
    RequestHandled = FALSE;
    Unit->Power.SystemState = RequestedState;

    if (CurrentState == PowerSystemWorking &&
        RequestedState != PowerSystemWorking) {

        //
        // Transitioning from working to a sleeping state. Request
        // a device D3 state.
        //

        DebugTrace (("Unit %p, Irp %p, SetSystemPower defering to device power\n",
                      Unit, Irp));

        IoMarkIrpPending (Irp);
        
        PowerState.SystemState = PowerSystemUnspecified;
        PowerState.DeviceState = PowerDeviceD3;

        Status = PoRequestPowerIrp (Unit->DeviceObject,
                                    IRP_MN_SET_POWER,
                                    PowerState,
                                    RaidpUnitEnterD3Completion,
                                    Irp,
                                    NULL);

        //
        // The completion function will complete the system power
        // irp.
        //
        
        RequestHandled = TRUE;

    } else if (CurrentState != PowerSystemWorking &&
               RequestedState == PowerSystemWorking) {

        //
        // Transitioning from a spleeping state to a working state.
        //

        NYI ();
        Status = STATUS_UNSUCCESSFUL;

    } else {

        REVIEW();
        Status = STATUS_UNSUCCESSFUL;
    }
    

    //
    // Complete the request if it was not completed by a completion function.
    //

    if (!RequestHandled) {
        //
        // NB: Do we need to set the IRP status before calling PoStartNextPowerIrp?
        //
        PoStartNextPowerIrp (Irp);
        Status = RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    return Status;
}


VOID
RaidpUnitEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This completion function is invoked when the unit had entered the
    PowerDeviceD3 power state.

Arguments:

    DeviceObject - Device object representing the unit object.

    MinorFunction - Minor function this irp is for; must be IRP_MN_SET_POWER.

    PowerState - Power state we are entering; must be PowerDeviceD3.

    SystemPowerIrp - Pointer to the system power irp that generated the
            device power irp we are completing.

    IoStatus - IoStatus for the device irp.

Return Value:

    None.

--*/
{

    DebugTrace (("DO %p, Irp %p, Completing Irp in D3Completion routine\n",
                  DeviceObject, SystemPowerIrp));
    REVIEW();

    //
    // BUGBUG: Is it possible for the IoStatus to not be STATUS_SUCCESS? How
    // do we approach failure processing in that case?
    //

    ASSERT (NT_SUCCESS (IoStatus->Status));

    //
    // NB: Do we need to set the IRP status before calling PoStartNextPowerIrp?
    //
    PoStartNextPowerIrp (SystemPowerIrp);
    RaidCompleteRequest (SystemPowerIrp, IO_NO_INCREMENT, IoStatus->Status);
    
}


NTSTATUS
RaidUnitSetDevicePowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the set power irp, for a device state on the unit.

Arguments:

    Unit - Unit that this irp is for.

    Irp - Set power irp to handle.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_POWER_STATE CurrentState;
    DEVICE_POWER_STATE RequestedState;  

    ASSERT_UNIT (Unit);
    ASSERT (RaidPowerTypeFromIrp (Irp) == DevicePowerState);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    CurrentState = Unit->Power.DeviceState;
    RequestedState = IrpStack->Parameters.Power.State.DeviceState;
    
    Unit->Power.DeviceState = RequestedState;

    //
    // NB: Do we need to set the IRP IO status before calling
    // PoStartNextPowerIrp?
    //
    
    PoStartNextPowerIrp (Irp);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);

    return Status;
}
    

NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for device control (ioctl) irps.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Device control irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Ioctl;

    PAGED_CODE ();

    Status = IoAcquireRemoveLock (&Unit->RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }
    
    Ioctl = RaidIoctlFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x\n",
                  Unit,
                  Irp,
                  Ioctl));
                 
    switch (Ioctl) {

        //
        // SCSI Ioctls
        //
        
        case IOCTL_SCSI_PASS_THROUGH:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_MINIPORT:
            Status = RaUnitScsiMiniportIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_INQUIRY_DATA:
            Status = RaUnitScsiGetInquiryDataIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_CAPABILITIES:
            Status = RaUnitScsiGetCapabilitesIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            Status = RaUnitScsiPassThroughDirectIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_ADDRESS:
            Status = RaUnitScsiGetAddressIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_RESCAN_BUS:
            Status = RaUnitScsiRescanBusIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_DUMP_POINTERS:
            Status = RaUnitScsiGetDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            Status = RaUnitScsiFreeDumpPointersIoctl (Unit, Irp);
            break;

        //
        // Storage Ioctls
        //
        
        case IOCTL_STORAGE_RESET_BUS:
            Status = RaUnitStorageResetBusIoctl (Unit, Irp);
            break;
            
        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaUnitStorageQueryPropertyIoctl (Unit, Irp);
            break;

        default:
            Status = RaUnitUnknownIoctl (Unit, Irp);
    }

    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x, ret = %08x\n", 
                  Unit,
                  Irp,
                  Ioctl,
                  Status));

    IoReleaseRemoveLock (&Unit->RemoveLock, Irp);

    return Status;
}


//
// IRP_MJ_DEVICE_CONTROL IRP handlers.
//

NTSTATUS
RaUnitScsiPassThroughIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiMiniportIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetInquiryDataIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetCapabilitesIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiPassThroughDirectIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetAddressIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_ADDRESS ScsiAddress;
    ULONG BufferLength;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ScsiAddress = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (BufferLength < sizeof (SCSI_ADDRESS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        ScsiAddress->Length = sizeof (SCSI_ADDRESS);
        ScsiAddress->PortNumber = -1; // BUGBUG: S/B Unit->PortNumber;
        ScsiAddress->PathId = Unit->Address.PathId;
        ScsiAddress->TargetId = Unit->Address.TargetId;
        ScsiAddress->Lun = Unit->Address.Lun;

        Irp->IoStatus.Information = sizeof (SCSI_ADDRESS);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitScsiRescanBusIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Create a DUMP_POINTERS structure describing any resources necessary
    for crashdump and hiber.

Arguments:

    Unit - Unit the ioctl is for.

    Irp - Get dump pointers ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PPORT_CONFIGURATION_INFORMATION Configuration;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    
    //
    // Only kernel mode is allowed to get the dump pointers.
    //

    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof (DUMP_POINTERS);
        goto done;
    }

    DumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

    //
    // Diskdump requires a complete copy of the configuration information.
    // This must be nonpaged. Also, this memory is never freed, since in
    // practice we never call FreeDumpStack.
    //
    
    Configuration = RaidAllocatePool (NonPagedPool,
                                      sizeof (PORT_CONFIGURATION_INFORMATION),
                                      CRASHDUMP_TAG,
                                      Unit->DeviceObject);

    if (Configuration == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    //
    // Initialize DMA information.
    //
    
    DumpPointers->AdapterObject = (PVOID)Dma->DmaAdapter;

    //
    // This is head of a list of MAPPED_ADDRESS structures that
    // diskdump uses to map io addresses.
    //
    
    DumpPointers->MappedRegisterBase = &Adapter->MappedAddressList;

    //
    // Copy the private port configuration.
    //

    RtlCopyMemory (Configuration,
                   &Adapter->Miniport.PortConfiguration,
                   sizeof (PORT_CONFIGURATION_INFORMATION));
    
    Configuration->SlotNumber = Adapter->SlotNumber;
    Configuration->SystemIoBusNumber = Adapter->BusNumber;
    DumpPointers->DumpData = Configuration;

    //
    // We do not fill in values for the CommonBufferVa, CommonBufferPa
    // and CommonBufferSize. Instead, we leave it to the crashdump
    // mechanism to do this for us.
    //
    
    DumpPointers->AllocateCommonBuffers = TRUE;
    DumpPointers->UseDiskDump = TRUE;
    DumpPointers->DeviceObject = Adapter->DeviceObject;

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof (DUMP_POINTERS);

done:

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Free any resources associated with the crashdump, hiber DUMP_POINTERS
    structure previously allocated by the get dump pointers ioctl.

Arguments:

    Unit - Unit this ioctl is for.

    Irp - Free dump pointers irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE ();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Only kernel mode is allowed to get or free the dump pointers.
    //
    
    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    DumpPointers= (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

    //
    // Do some basic validation that we were actually passed in
    // a valid DUMP_POINTERS structure.
    //
    
    ASSERT (DumpPointers->AdapterObject == (PVOID)Dma->DmaAdapter);
    ASSERT (DumpPointers->MappedRegisterBase == Dma->MapRegisterBase);
    ASSERT (DumpPointers->CommonBufferSize == 0);
    ASSERT (DumpPointers->CommonBufferVa == NULL);

    RaidFreePool (DumpPointers->DumpData, CRASHDUMP_TAG);
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

done:

    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
}

NTSTATUS
RaUnitStorageResetBusIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitStorageQueryPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;
    BOOLEAN CompleteRequest;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    

    //
    // We do not support the mask property or any others above mask.
    //
    
    if (Query->QueryType >= PropertyMaskQuery) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    IO_NO_INCREMENT,
                                    STATUS_INVALID_PARAMETER_1);
    }

    CompleteRequest = FALSE;
    
    switch (Query->PropertyId) {

        case StorageDeviceProperty:
            if (Query->QueryType == PropertyStandardQuery) {
                Status = RaGetUnitStorageDeviceProperty (Unit,
                                                         Buffer,
                                                         &BufferSize);
                Irp->IoStatus.Information = BufferSize;
                CompleteRequest = TRUE;
            } else {
                ASSERT (Query->QueryType == PropertyExistsQuery);
                Status = STATUS_SUCCESS;
                CompleteRequest = TRUE;
            }
            break;              


#if 0
        //
        // NYI
        //
        
        case StorageDeviceIdProperty:
            if (Query->QueryType == PropertyExistsQuery) {
                Status = STATUS_SUCCESS;
            } else {
                ASSERT (Query->QueryType == ...);
                Status = RiGetUnitStorageDeviceIdProperty (Unit, Buffer, &BufferSize);
            }
            break;
#endif

        default:

            //
            // Setting CompleteRequest to FALSE causes the IRP to be forwarded
            // to the next lower driver.x
            //

            CompleteRequest = FALSE;
    }


    //
    // If we need to complete this request, complete it now. Otherwise, forward
    // it to the next lower level driver.
    //
    
    if (CompleteRequest) {
        Status = RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    } else {
        IoSkipCurrentIrpStackLocation (Irp);
        Status = IoCallDriver (Unit->Adapter->DeviceObject, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitUnknownIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,
                                IO_NO_INCREMENT,
                                STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* DeviceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR DeviceId;
    PSCSI_DEVICE_TYPE DeviceType;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    CHAR Revision [SCSI_REVISION_ID_LENGTH + 1];
    ULONG i;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    DeviceId = RaidAllocatePool (PagedPool,
                                 DEVICE_ID_LENGTH * sizeof (WCHAR),
                                 ID_TAG,
                                 Unit->DeviceObject);

    if (DeviceId != NULL) {

        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        StorGetIdentityVendorId (&Unit->Identity,
                                 VendorId,
                                 sizeof (VendorId),
                                 TRUE);

        StorGetIdentityProductId (&Unit->Identity,
                                  ProductId,
                                  sizeof (ProductId),
                                  TRUE);

        StorGetIdentityRevision (&Unit->Identity,
                                 Revision,
                                 sizeof (Revision),
                                 TRUE);

        swprintf (DeviceId,
             L"SCSI\\%hs&Ven_%hs&Prod_%hs&Rev_%hs",
             DeviceType->Name,
             VendorId,
             ProductId,
             Revision);

        RaFixupIds (DeviceId, FALSE);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *DeviceIdBuffer = DeviceId;

    return Status;
}


NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* InstanceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR InstanceId;
    ULONG Count;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    InstanceId = RaidAllocatePool (PagedPool,
                                   INSTANCE_ID_LENGTH * sizeof (WCHAR),
                                   ID_TAG,
                                   Unit->DeviceObject);

    if (InstanceId != NULL) {

        Count = swprintf (InstanceId,
                          L"%x%x%x",
                          Unit->Address.PathId,
                          Unit->Address.TargetId,
                          Unit->Address.Lun
                          );

        //
        // Sanity check that we didn't overflow our buffer.
        //
        
        ASSERT ((Count + 1) < INSTANCE_ID_LENGTH);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *InstanceIdBuffer = InstanceId;

    return Status;
}


NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* HardwareIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR HardwareIds;
    ULONG Count;
    PWCHAR Buffer;
    PSCSI_DEVICE_TYPE DeviceType;
    PINQUIRYDATA InquiryData;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    HardwareIds = RaidAllocatePool (PagedPool,
                                    HARDWARE_ID_LENGTH * sizeof (WCHAR),
                                    ID_TAG,
                                    Unit->DeviceObject);
                                         

    if (HardwareIds != NULL) {

        Buffer = HardwareIds;
        InquiryData = StorGetIdentityInquiryData (&Unit->Identity);
        DeviceType = RaGetDeviceType (InquiryData->DeviceType);

        //
        // bus + device + vendor + product + revision
        //
        
        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs%4.4hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel);

        Buffer += (Count + 1);

        //
        // bus + device + vendor + product
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId);

        Buffer += (Count + 1);

        //
        // bus + device + vendor
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs",
                          DeviceType->Name,
                          InquiryData->VendorId);

        Buffer += (Count + 1);

        //
        // bus + vendor + product + revision[0]
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%8.8hs%16.16hs%hc___",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);

        Buffer += (Count + 1);

        //
        // vendor + product + revision[0] (win9x)
        //

        Count = swprintf (Buffer,
                          L"%8.8hs%16.16hs%hc___",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);
                          
        Buffer += (Count + 1);
        
        //
        // generic device
        //

        Count = swprintf (Buffer,
                          L"%hs",
                          DeviceType->GenericName);

        Buffer += (Count + 1);

        *Buffer++ = UNICODE_NULL;
        RaFixupIds (HardwareIds, TRUE);
        Status = STATUS_SUCCESS;

        ASSERT ((LONG)(Buffer - HardwareIds) < HARDWARE_ID_LENGTH);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    *HardwareIdsBuffer = HardwareIds;

    return Status;
}


NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* CompatibleIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR CompatibleIds;
    PWCHAR Buffer;
    ULONG Count;
    PSCSI_DEVICE_TYPE DeviceType;

    PAGED_CODE ();

    CompatibleIds = RaidAllocatePool (PagedPool,
                                      COMPATIBLE_ID_LENGTH * sizeof (WCHAR),
                                      ID_TAG,
                                      Unit->DeviceObject);

    if (CompatibleIds != NULL) {

        Buffer = CompatibleIds;
        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        //
        // First is, SCSI\<DEVICE>
        //
        
        Count = swprintf (Buffer, L"SCSI\\%hs", DeviceType->Name);
        Buffer += (Count + 1);

        //
        // Second is SCSI\RAW
        //
        
        Count = swprintf (Buffer, L"SCSI\\RAW");
        Buffer += (Count + 1);

        //
        // Append the final UNICODE_NULL because this is a multi-sz string.
        //
        
        *Buffer++ = UNICODE_NULL;

        //
        // Remove invalid characters.
        //
        
        RaFixupIds (CompatibleIds, TRUE);

        //
        // Sanity check that we didn't overflow our allocated buffer.
        //
        
        ASSERT ((ULONG)(Buffer - CompatibleIds) < COMPATIBLE_ID_LENGTH);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_NO_MEMORY;
    }

    *CompatibleIdsBuffer = CompatibleIds;

    return Status;
}


NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    Create a device descriptor based on the information in the device
    extension. Copy as much data as possible into the Decescriptor and
    update the DescriptorLength to indicate the number of bytes copied

Arguments:

    Unit - Supplies Unit we are querying property for.

    DescriptorBuffer - Pointer to a buffer where the data for this
            property will be copied. The buffer size is determined by the
            input value of the BufferLength parameter.

    BufferLength - On input, supplies the length of the buffer, on output
            return the number of bytes copied.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_DRIVER_EXTENSION Driver;
    PINQUIRYDATA InquiryData;
    RAID_DEVICE_DESCRIPTOR Descriptor;
    ULONG Length;


    PAGED_CODE();
    ASSERT_UNIT (Unit);
    ASSERT (DescriptorBuffer != NULL);


    InquiryData = StorGetIdentityInquiryData (&Unit->Identity);

    //
    // Zero the temporary descriptor buffer out. Note that since
    // we don't explicitly zero out or NULL-terminated strings
    // below, the zeroing is necessary.
    //

    RtlZeroMemory (&Descriptor, sizeof (Descriptor));

    //
    // Length is the number of bytes we will copy into the descriptor
    // buffer. The Size field in the storage descriptor is the size
    // of the descriptor we want to copy -- not the number of bytes
    // copied. This is important.
    //
    
    Length = min (((ULONG)sizeof (Descriptor)), *BufferLength);

    Descriptor.Storage.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    Descriptor.Storage.Size = sizeof (Descriptor);
    Descriptor.Storage.DeviceType = InquiryData->DeviceType;
    Descriptor.Storage.DeviceTypeModifier = InquiryData->DeviceTypeModifier;
    Descriptor.Storage.RemovableMedia = InquiryData->RemovableMedia;
    Descriptor.Storage.CommandQueueing = InquiryData->CommandQueue; 
    Descriptor.Storage.BusType = Unit->Adapter->Driver->BusType;

    //
    // Copy the VendorId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.VendorId,
                   InquiryData->VendorId,
                   sizeof (Descriptor.VendorId) - 1);

    Descriptor.Storage.VendorIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, VendorId);

    //
    // Copy the ProductId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.ProductId,
                   InquiryData->ProductId,
                   sizeof (Descriptor.ProductId) - 1);

    Descriptor.Storage.ProductIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductId);

    //
    // Copy the RevisionLevel and initialize it's offset.
    //

    RtlCopyMemory (Descriptor.ProductRevision,
                   InquiryData->ProductRevisionLevel,
                   sizeof (Descriptor.ProductRevision) - 1);

    Descriptor.Storage.ProductRevisionOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductRevision);

    //
    // BUGBUG: We don't provide a serial number yet.
    //

    Descriptor.Storage.SerialNumberOffset = 0;

    //
    // Copy the temporary descriptor back to the buffer, and update the
    // length parameter.
    //
    
    RtlCopyMemory (DescriptorBuffer, &Descriptor, Length);
    *BufferLength = Length;

    return STATUS_SUCCESS;
}



VOID
RaidFreezeUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // We should never double freeze the queue.
    //
    
    ASSERT (!Unit->Flags.QueueFrozen);
    Unit->Flags.QueueFrozen = TRUE;

    //
    // The lower-level IoQueue can be frozen either through an error or
    // because of a lock queue request. Since it doesn't support double
    // freezing, only request it to be actually frozen if it isn't locked.
    //
    
    if (!Unit->Flags.QueueLocked) {
        RaidFreezeIoQueue (&Unit->IoQueue);
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


VOID
RaidResumeUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    ASSERT (Unit->Flags.QueueFrozen);
    Unit->Flags.QueueFrozen = FALSE;

    if (!Unit->Flags.QueueLocked) {
        RaidResumeIoQueue (&Unit->IoQueue);
    }   
    
    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


BOOLEAN
RaidIsUnitQueueFrozen(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    BOOLEAN Frozen;
    KLOCK_QUEUE_HANDLE LockHandle;

    PAGED_CODE ();
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    Frozen = Unit->Flags.QueueFrozen;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return Frozen;
}

VOID
RaidLockUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // We should never double freeze the queue.
    //
    
    ASSERT (!Unit->Flags.QueueLocked);
    Unit->Flags.QueueLocked = TRUE;

    //
    // The lower-level IoQueue can be frozen either through an error or
    // because of a lock queue request. Since it doesn't support double
    // freezing, only request it to be actually frozen if it isn't locked.
    //
    
    if (!Unit->Flags.QueueFrozen) {
        RaidFreezeIoQueue (&Unit->IoQueue);
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


VOID
RaidUnlockUnitQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    ASSERT (Unit->Flags.QueueLocked);
    Unit->Flags.QueueLocked = FALSE;

    if (!Unit->Flags.QueueFrozen) {
        RaidResumeIoQueue (&Unit->IoQueue);
    }   
    
    KeReleaseInStackQueuedSpinLock (&LockHandle);
}


BOOLEAN
RaidIsUnitQueueLocked(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    BOOLEAN Locked;
    KLOCK_QUEUE_HANDLE LockHandle;

    PAGED_CODE ();
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    Locked = Unit->Flags.QueueLocked;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return Locked;
}
    

BOOLEAN
RaidIsUnitQueueStopped(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    BOOLEAN Stopped;
    KLOCK_QUEUE_HANDLE LockHandle;

    PAGED_CODE ();
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    Stopped = (Unit->Flags.QueueLocked || Unit->Flags.QueueFrozen);
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return Stopped;
}

VOID
RaidUnitProcessBusyRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Process a request that has come to us as busy.

Arguments:

    Unit - Supplies the logical unit that this request was submitted to.

    Xrb - Supplies the request.

Return Value:

    None.

--*/
{
    BOOLEAN Inserted;
    PKDEVICE_QUEUE_ENTRY Entry;
    PEXTENDED_DEVICE_QUEUE ExQueue;
    PSCSI_REQUEST_BLOCK Srb;
    PIRP Irp;
    PRAID_ADAPTER_EXTENSION Adapter;
    KLOCK_QUEUE_HANDLE LockHandle;


    Srb = Xrb->Srb;
    Irp = Xrb->Irp;

    //
    // SRB_STATUS_BUSY signals an adapter is busy.
    //

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY) {

        LOGICAL RestartQueues;

        RaidUnitReleaseIrp (Irp, NULL);

        //
        // After releasing the Irp, we no longer have a Xrb to play with.
        //
        
        Xrb = NULL;
        
        Adapter = Unit->Adapter;

        //
        // Mark the adapter queue as busy.
        //

        //
        // REVIEW: Check this for race conditions. In particular,
        // can it happen that we mark the queue as busy, but by the
        // time we queue the request to the queue, it's not busy?
        // This could happen, for example, if the dpc routine is
        // running on a different processor at the same time
        // as we're submitting items. Note that there's
        // also a race condition between when we're told by the
        // adapter that we're busy and when we mark it as busy.
        // In that time period, we could have completed enough
        // requests to make us not busy.
        //

#if 0
        StorBusyIoGateway (&Adapter->Gateway, TRUE);
#endif
#if 0

        //
        // Remove it from the gateway queue
        //

        RestartQueues = StorRemoveIoGatewayItem (&Adapter->Gateway);

        if (RestartQueues) {
            REVIEW();
            StorBusyIoGateway (&Adapter->Gateway);
        }



        //
        // Return the IRP to the head of the queue.
        //
        
        RaidReturnExDeviceQueue (&Unit->IoQueue.DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry);
#endif

        //
        // Remove the item from the various queues.
        //
        // NB: Fix this.
        //
        
        InterlockedDecrement (&Adapter->Gateway.Outstanding);
        InterlockedDecrement (&Unit->IoQueue.DeviceQueue.OutstandingRequests);

        //
        // Then resubmit it.
        //

        RaidUnitSubmitRequest (Unit, Irp);
                            
    } else {

        ASSERT (Srb->ScsiStatus == SCSISTAT_BUSY ||
                Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);

        //
        // Logical unit busy has not been dealt with yet.
        //

        NYI ();
    }
}


LOGICAL
INLINE
IsBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);
}



VOID
RaUnitAsyncError(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine handles errors asynchronous errors.

Arguments:

    Unit - Supplies Logical Unit that Xrb is for.

    Xrb - Supplies Xrb that caused an error.

Return Value:

    None.

--*/
{

    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN RestartQueues;

    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    RestartQueues = FALSE;

    DebugTrace (("Unit %p Srb %p, generated err = %08x\n",
                  Unit,
                  Srb,
                  SRB_STATUS (Srb->SrbStatus)));

    //
    // Busy processing is handled synchronous with the StartIo call.
    // Therefore, we should never get a busy error in the async error
    // handler.
    //

    if (IsBusy (Srb)) {
        RaidUnitProcessBusyRequest (Unit, Xrb);
        return;
    }

    if (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE)) {

        //
        // Freeze the queue so the class driver has a chance to process
        // the error.
        //
        
        RaidFreezeUnitQueue (Unit);
        SET_FLAG (Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Propagate the translated error condition in the IRP.
    //
    
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Information = Srb->DataTransferLength;
    } else {
        Irp->IoStatus.Information = 0;
    }

    //
    // Release any resources associated with the IRP.
    //

    RaidUnitReleaseIrp (Irp, NULL);

    //
    // Finally, complete the request.
    //
    
    DebugTrace (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    RaidCompleteRequest (Irp, IO_NO_INCREMENT, Irp->IoStatus.Status);

    RaidStartNextIoPacket (&Unit->IoQueue,
                           FALSE,
                           NULL,
                           &RestartQueues);

    if (RestartQueues) {
        RaidAdapterRestartQueues (Unit->Adapter);
    }
}


VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidRestartIoQueue (&Unit->IoQueue);
}


VOID
RaUnitAddToPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);
    ASSERT (Xrb->Srb != NULL);
    
    StorInsertEventQueue (&Unit->PendingQueue,
                          &Xrb->PendingLink,
                          Xrb->Srb->TimeOutValue);
}


VOID
RaUnitRemoveFromPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);

    StorRemoveEventQueue (&Unit->PendingQueue, &Xrb->PendingLink);
}


BOOLEAN
RaidUnitIsEnumerated(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    //
    // This should be an atomic operation, so there is no need to
    // acquire the SlowLock.
    //
    
    return Unit->Flags.Enumerated;
}


BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    )
{
    BOOLEAN PreviouslyEnumerated;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    PreviouslyEnumerated = Unit->Flags.Enumerated;
    Unit->Flags.Enumerated = Enumerated;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return PreviouslyEnumerated;
}


PVOID
RaidGetKeyFromUnit(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    PVOID Key;
    PRAID_UNIT_EXTENSION Unit;
    
    Unit = CONTAINING_RECORD (Entry,
                              RAID_UNIT_EXTENSION,
                              UnitTableLink);

    ASSERT_UNIT (Unit);

    Key = RaidAddressToKey (Unit->Address);

    return (PVOID) Key;
}



VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    
    Status = StorTickEventQueue (&Unit->PendingQueue);

    if (NT_SUCCESS (Status)) {
        return;
    }

    //
    // We timed out. Reset the unit
    //
    
    RaidUnitReset (Unit);
}



NTSTATUS
RaidUnitReset(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Perform a hierarchical reset on the logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

--*/
{
    UCHAR PathId;

    PathId = StorGetAddressPathId (Unit->Address);
    return RaidAdapterReset (Unit->Adapter, PathId);
}



LOGICAL
RaidUnitNotifyHardwareGone(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is invoked by the enumeration code when a logical unit
    goes away.

Arguments:

    Unit - Logical unit that went away.

Return Value:

    TRUE - If PnP should be notified of the removal.

    FALSE - If PnP does not need to be notified.

--*/
{
    NTSTATUS Status;
    LOGICAL ChangeDetected;
    
    if (Unit->Flags.Present) {
        Unit->Flags.Present = FALSE;
        Status = RaidUnitCancelPendingRequestsAsync (Unit);
    }

    if (Unit->Flags.Enumerated) {
        ChangeDetected = TRUE;
    }

    return ChangeDetected;
}


NTSTATUS
RaidUnitCancelPendingRequestsAsync(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Asynchronously remove all queued requests from the logical unit. 

Arguments:

    Unit - Logical unit to remove queued requests for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_WORKITEM WorkItem;
    
    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {
        IoQueueWorkItem (WorkItem,
                         RaidCancelRequestsWorkRoutine,
                         DelayedWorkQueue,
                         WorkItem);
        Status = STATUS_SUCCESS;
    } else {
        //
        // Low memory: we failed to allocate the work item, so perform
        // the operation(s) synchronously.
        //
        REVIEW();
        Status = RaidUnitCancelPendingRequests (Unit);
    }

    return Status;
}



NTSTATUS
RaidCancelRequestsWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Called from a work queue; this routine synchronously cancels all
    queued requests on a device queue.

Arguments:

    DeviceObject - Device object of queue to flush.

    Context - Context representing the work item.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;

    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);
    
    Status = RaidUnitCancelPendingRequests (Unit);

    IoFreeWorkItem (WorkItem);

    return Status;
}



NTSTATUS
RaidUnitCancelPendingRequests(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Synchronously cancel all pending requests.

Arguments:

    Unit - Logical unit to cancel pending requests for.

Return Value:

    NTSTATUS code.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;

    REVIEW();

    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_NO_SUCH_DEVICE);
    }


    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\unit.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	unit.h

Abstract:

	Definintion and declaration of the RAID_UNIT (PDO) object.
	
Author:

	Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once


typedef struct _RAID_IO_RESOURCES RAID_IO_RESOURCES, *PRAID_IO_RESOURCES;

typedef struct _RAID_UNIT_EXTENSION {

	//
	// The device object type. Must be RaidUnitObject for the raid unit
	// extension.
	//
	// Protected by: RemoveLock
	//
	
	RAID_OBJECT_TYPE ObjectType;

	//
	// The device object that owns this extension.
	//
	// Protected by: RemoveLock
	//

	PDEVICE_OBJECT DeviceObject;

	//
	// Pointer to the adapter that owns this unit.
	//
	// Protected by: RemoveLock
	//

	PRAID_ADAPTER_EXTENSION Adapter;

	//
	// Slow lock for any data not protected by another lock.
	//
	// NB: The slow lock should not be used to access
	// anything on the i/o path. Hence the name.
	//
	// Protected by: SlowLock
	//
	
	KSPIN_LOCK SlowLock;
	
	//
	// PnP device state.
	//
	// Protected by: Interlocked access
	//

	DEVICE_STATE DeviceState;

	//
	// List of all the units on this adapter.
	//
	// Protected by: ADAPTER::UnitList::Lock
	//
	
	LIST_ENTRY NextUnit;

	//
	// A hash-table containing all units on this adapter.
	//
	// Protected by: Read access must hold the interrupt lock.
	//               Write access must hold the Adapter UnitList lock
	//				 AND the interrupt lock.
	//

	STOR_DICTIONARY_ENTRY UnitTableLink;

	//
	// The RAID address of the unit.
	//
	// Protected by: 
	//

	RAID_ADDRESS Address;

	//
	// Inquiry Data
	//
	// Protected by:
	//

	STOR_SCSI_IDENTITY Identity;

	//
	// Flags for the unit device.
	//
	// Protected by: SlowLock
	//
	
	struct {

		//
		// Flag specifying whether the device has been
		// claimed or not.
		//
		
		BOOLEAN DeviceClaimed : 1;

		//
		// The LU's device queue is frozen on an error.
		//
		
		BOOLEAN QueueFrozen : 1;

		//
		// The LU's device queue is locked at the request
		// of the class driver.
		//
		
		BOOLEAN QueueLocked : 1;

		//
		// Did the last bus enumeration include this unit? If so, we cannot
		// delete the unit in response to an IRP_MN_REMOVE request; rather,
		// we have to wait until the bus is enumerated again OR the adapter
		// is removed.
		//
		
		BOOLEAN Enumerated : 1;

		//
		// Flag specifying that the unit is physically present (TRUE),
		// or not (FALSE).
		//
		
		BOOLEAN Present : 1;

		//
		// Flag specifying whether the unit is temporary or not. That is,
		// is the unit being used as a temporary unit for enumerating
		// the bus (TRUE) or not.
		//
		
		BOOLEAN Temporary : 1;
		

	} Flags;

	//
	// Remove Lock for this unit.
	//
	// Protected by: RemoveLock
	//

	IO_REMOVE_LOCK RemoveLock;

	//
	// Count of devices that are in the paging/hiber/dump path.
	// We use a single count for all three paging, hiber and dump,
	// since there is no need (at this time) to distinguish between
	// the three.
	//
	// Protected by: Interlocked access
	//

	ULONG PagingPathCount;

	//
	// Elements for tagged queuing.
	//
	// Protected by: TagList
	//
	
	QUEUE_TAG_LIST TagList;
	
	//
	// SrbExtensions are allocated out of this pool. The memory for
	// this pool is allocated early on from common buffer.
	//
	// Protected by: TagList
	//

	RAID_MEMORY_REGION SrbExtensionRegion;
	
	RAID_FIXED_POOL SrbExtensionPool;

#if 0
	//
	// REVIEW - Does sense info get allocated by port or class.
	//
	
	//
	// The sense info buffer for a srb is allocated from this pool. Like
	// the SrbExtensionPool, it is a fixed size pool allocated from
	// common buffer.
	//
	// Protected by: TagList
	//

	RAID_FIXED_POOL SenseInfoPool;

	//
	// Create a lookaside list Xrbs.
	//
	// Protected by: XrbList
	//
#endif

	NPAGED_LOOKASIDE_LIST XrbList;

	//
	// An I/O queue for unit requests.
	//
	// Protected by: IoQueue
	//
	
	IO_QUEUE IoQueue;

	//
	// Power state information for the unit.
	//
	// Protected by: Multiple power irps are not
	// sent to the unit.
	//

	RAID_POWER_STATE Power;

	//
	// Queue of items currently pending in the adapter.
	//
	// Protected by: Self.
	//

	STOR_EVENT_QUEUE PendingQueue;

	//
	// Timer for entries in the pending queue.
	//
	// Protected by: only modified in start/stop unit routiens.
	//
	
	KTIMER PendingTimer;

	//
	// DPC routine for entries in the pending queue.
	//
	// Protected by: modified in start/stop unit routines.
	//
	
	KDPC PendingDpc;

	//
	// Specific LU extension.
	//
	// Protected by: Read only after initialization.
	//

	PVOID UnitExtension;

} RAID_UNIT_EXTENSION, *PRAID_UNIT_EXTENSION;



//
// This structure is used to handle the IOCTL_STORAGE_QUERY_PROPERTY ioctl.
//

typedef struct _RAID_DEVICE_DESCRIPTOR {

	//
	// Common STORAGE_DEVICE_DESCRIPTOR header.
	//
	
    STORAGE_DEVICE_DESCRIPTOR Storage;

	//
	// SCSI VendorId directly from the SCSI InquiryData.
	//
	
	CHAR VendorId [SCSI_VENDOR_ID_LENGTH];

	//
	// SCSI ProuctId directly from the SCSI InquiryData.
	//

	CHAR ProductId [SCSI_PRODUCT_ID_LENGTH];

	//
	// SCSI ProductRevision directly from the SCSI InquiryData.
	//

	CHAR ProductRevision [SCSI_REVISION_ID_LENGTH];

	//
	// SCSI SerialNumber.
	//

	CHAR SerialNumber [1];	//Not currently used

} RAID_DEVICE_DESCRIPTOR;


//
// These are the resources necessary to execute a single IO
// request.
//

typedef struct _RAID_IO_RESOURCES {

	//
	// SCSI_REQUEST_BLOCK::QueueTag
	//
	
    ULONG QueueTag;

	//
	// SCSI_REQUEST_BLOCK::SrbExtension
	//
	
    PVOID SrbExtension;

	//
	// SCSI_REQUEST_BLOCK::OriginalRequest
	//
	
	PEXTENDED_REQUEST_BLOCK Xrb;

} RAID_IO_RESOURCES, *PRAID_IO_RESOURCES;




//
// Creation and destruction
//


NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* Unit
    );

VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    );

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    );

VOID
RaidDeleteUnit(
	IN PRAID_UNIT_EXTENSION Unit
	);

VOID
RaidPrepareUnitForReuse(
	IN PRAID_UNIT_EXTENSION Unit
	);
	

NTSTATUS
RaCreateUnitPools(
    IN PRAID_UNIT_EXTENSION Unit
    );

VOID
RaUnitAsyncError(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PEXTENDED_REQUEST_BLOCK Xrb
	);

VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
	IN PVOID Context
    );
	
//
// Callback and Handler routines
//

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitSystemControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );


//
// PnP Irps
//

NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );
	
NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitSucceedPnpIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitStartDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitStopDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitQueryStopDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitCancelStopDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitRemoveDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitQueryRemoveDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);
	
NTSTATUS
RaUnitCancelRemoveDeviceIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitSurpriseRemovalIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitDeviceUsageNotificationIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitQueryDeviceTextIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);
	

	

//
// IRP_MJ_SCSI Commands
//


NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitExecuteScsiSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitClaimDeviceSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitIoControlSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitReleaseQueueSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitReceiveEventSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitAttachDeviceSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitReleaseDeviceSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitShutdownSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitFlushSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitAbortCommandSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitReleaseRecoverySrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitResetBusSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitResetDeviceSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitTerminateIoSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitFlushQueueSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitRemoveDeviceSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitWmiSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitLockQueueSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitUnlockQueueSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitUnknownSrb(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);


//
// IRP_MJ_DEVICE_CONTROL IRP handlers.
//


NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

NTSTATUS
RaUnitScsiPassThroughIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiMiniportIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiGetInquiryDataIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiGetCapabilitesIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiPassThroughDirectIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiGetAddressIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiRescanBusIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitStorageResetBusIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitStorageQueryPropertyIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitUnknownIoctl(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

//
// Power
//
    
NTSTATUS
RaUnitPowerIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    );

//
// Other
//


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
	IN PWSTR* DeviceIdBuffer
    );

NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
	IN PWSTR* InstanceIdBuffer
    );
	
NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
	IN PWSTR* HardwareIdsBuffer
    );
	
NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
	IN PWSTR* CompatibleIdsBuffer
    );
	

NTSTATUS
RaUnitBusQueryInstanceIdIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitBusQueryHardwareIdsIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaUnitBusQueryCompatibleIdsIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    );


//
// Private operations
//

NTSTATUS
RaidUnitClaimIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp,
	IN PRAID_IO_RESOURCES IoResources OPTIONAL
	);

VOID
RaidUnitReleaseIrp(
	IN PIRP Irp,
	OUT PRAID_IO_RESOURCES IoResources OPTIONAL
	);

VOID
RaidFreezeUnitQueue(
	IN PRAID_UNIT_EXTENSION Unit
	);

VOID
RaidResumeUnitQueue(
	IN PRAID_UNIT_EXTENSION Unit
	);

BOOLEAN
RaidIsUnitQueueFrozen(
	IN PRAID_UNIT_EXTENSION Unit
	);

VOID
RaidLockUnitQueue(
	IN PRAID_UNIT_EXTENSION Unit
	);

VOID
RaidUnlockUnitQueue(
	IN PRAID_UNIT_EXTENSION Unit
	);

BOOLEAN
RaidIsUnitQueueLocked(
	IN PRAID_UNIT_EXTENSION Unit
	);
NTSTATUS
RaidUnitQueryPowerIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaidUnitSetPowerIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaidUnitSetSystemPowerIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

NTSTATUS
RaidUnitSetDevicePowerIrp(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

VOID
RaidpUnitEnterD3Completion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP SystemPowerIrp,
    IN PIO_STATUS_BLOCK IoStatus
	);

VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    );
    
VOID
RaUnitAddToPendingList(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

VOID
RaUnitRemoveFromPendingList(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

VOID
RaidUnitProcessBusyRequest(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PEXTENDED_REQUEST_BLOCK Xrb
	);

VOID
RaidUnitProcessBusyRequestAtDirql(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PEXTENDED_REQUEST_BLOCK Xrb
	);

BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    );

VOID
RaidAdapterRemoveUnit(
	IN PRAID_ADAPTER_EXTENSION Adapter,
	IN PRAID_UNIT_EXTENSION Unit
	);

PVOID
RaidGetKeyFromUnit(
	IN PSTOR_DICTIONARY_ENTRY Entry
	);

NTSTATUS
RaidUnitSubmitRequest(
	IN PRAID_UNIT_EXTENSION Unit,
	IN PIRP Irp
	);

RAID_ADDRESS
INLINE
RaidUnitGetAddress(
	IN PRAID_UNIT_EXTENSION Unit
	)
{
	return Unit->Address;
}

VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
RaidUnitReset(
	IN PRAID_UNIT_EXTENSION Unit
	);

LOGICAL
RaidUnitNotifyHardwareGone(
	IN PRAID_UNIT_EXTENSION Unit
	);
	
NTSTATUS
RaidUnitCancelPendingRequestsAsync(
	IN PRAID_UNIT_EXTENSION Unit
	);

NTSTATUS
RaidCancelRequestsWorkRoutine(
	IN PDEVICE_OBJECT DeviceObject,
	IN PVOID Context
	);

NTSTATUS
RaidUnitCancelPendingRequests(
	IN PRAID_UNIT_EXTENSION Unit
	);
	
VOID
RaidZeroUnit(
	IN PRAID_UNIT_EXTENSION Unit
	);

NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    );

NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    );

VOID
RaidStartUnit(
	IN PRAID_UNIT_EXTENSION Unit
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\srb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	srb.h

Abstract:

	Declarations of the SRB object and it's related operations.
	
Author:

	Matthew D Hendel (math) 04-May-2000

Revision History:

--*/

#pragma once


#define XRB_SIGNATURE				(0x1F2E3D4C)
#define SRB_EXTENSION_SIGNATURE		(0x11FF22EE)

//
// Physical break value is the number of elements necessary in an SG list
// to map a 64K buffer.
//

#define	PHYSICAL_BREAK_VALUE		(17)

//
// BUGBUG: For long-term we can't used a fixed size buffer for the SG list.
//

#define SCATTER_GATHER_BUFFER_SIZE								\
	(sizeof (SCATTER_GATHER_LIST) +								\
	 sizeof (SCATTER_GATHER_ELEMENT) * PHYSICAL_BREAK_VALUE)	\

//
// The srb completion routine is called when the io for a srb is
// completed.
//

typedef
VOID
(*XRB_COMPLETION_ROUTINE)(
	IN PEXTENDED_REQUEST_BLOCK Xrb
	);

//  
// The Extended Request Block (XRB) is the raid port's notion of an i/o
// request.  It wraps the srb by inserting itself into the
// OriginalRequest field of the SRB, adding fields we need to process the
// SRB. In SCSIPORT this is the SRB_DATA field.
//
  

typedef struct _EXTENDED_REQUEST_BLOCK {

	//
	// The first three fields are private XRB data, and should only be
	// accessed by XRB specific functions.
	//
	
	//
	// Signature value used to identify an XRB.
	//
	
	ULONG Signature;

	//
	// Pool this Xrb was allocated from.
	//

	PNPAGED_LOOKASIDE_LIST Pool;

	struct {
		BOOLEAN OwnedMdl : 1;
	};


	//
	// The remainder of the fields are publicly accessible.
	//

	//
	// The next element in the completed queue.
	//
	// Protected by: Interlocked access.
	//
	
	SINGLE_LIST_ENTRY CompletedLink;

	//
	// The next element in the pending queue.
	//
	// Protected by: event queue spinlock.
	//
	// NOTE: this field is valid until we remove the element in the DPC
	// routine even though LOGICALLL the element is not on the pending
	// queue as soon as it is placed on the completed list.
	//
	
	STOR_EVENT_QUEUE_ENTRY PendingLink;
	
	//
	// The MDL assoicated with this SRB's DataBuffer.
	//
	
	PMDL Mdl;

	//
	// If this SRB supports Scatter/Gather IO, this will be the 
	// ScatterGather list.
	//
	
	PSCATTER_GATHER_LIST SgList;

	//
	// The IRP this SRB is for.
	//

	PIRP Irp;

	//
	// Pointer back to the SRB this XRB is for.
	//

	PSCSI_REQUEST_BLOCK Srb;

	//
	// Data that is overwritten by raidport that should be restored
	// before completing the IRP.
	//
	
	struct {

		//
		// The OriginalRequest field from the srb. We use this field
		// to store the xrb when passing requests to the miniport.
		// The value needs to be saved so it can be restored when
		// we complete the request.
		//

		PVOID OriginalRequest;

		//
		// The DataBuffer field from the srb.
		//
		
		PVOID DataBuffer;

	} SrbData;
		

	//
	// The adapter or unit this request is for.
	//

	PRAID_ADAPTER_EXTENSION Adapter;

	//
	// The logical unit this request is for. May be NULL if this is
	// a request made by the adapter, for example, during enumeration.
	//
	
	PRAID_UNIT_EXTENSION Unit;

	//
	// BUGBUG: This should be done differently.
	//

	UCHAR ScatterGatherBuffer [ SCATTER_GATHER_BUFFER_SIZE ];

	//
	// Should the SRB be completed by the DPC
	//
	
	XRB_COMPLETION_ROUTINE CompletionRoutine;

	//
	// Data used by the different completion events
	//
	
	union {

		//
		// This is an event that a creator of a SRB can wait on when performing
		// synchronous IO.
		//

		KEVENT CompletionEvent;

	} u;

} EXTENDED_REQUEST_BLOCK, *PEXTENDED_REQUEST_BLOCK;




//
// Creation and destruction operations for XRBs.
//

PEXTENDED_REQUEST_BLOCK
RaidAllocateXrb(
	IN PNPAGED_LOOKASIDE_LIST List,
	IN PDEVICE_OBJECT DeviceObject
	);

VOID
RaidFreeXrb(
	IN PEXTENDED_REQUEST_BLOCK
	);

VOID
RaidPrepareXrbForReuse(
	IN PEXTENDED_REQUEST_BLOCK Xrb
	);	
	
//
// Other operations for XRBS.
//

VOID
RaidXrbSetSgList(
	IN PEXTENDED_REQUEST_BLOCK Xrb,
	IN PRAID_ADAPTER_EXTENSION Adapter,
	IN PSCATTER_GATHER_LIST SgList
	);


VOID
RaidXrbSetCompletionRoutine(
	IN PEXTENDED_REQUEST_BLOCK Xrb,
	IN XRB_COMPLETION_ROUTINE CompletionRoutine
	);
	
NTSTATUS
RaidBuildMdlForXrb(
	IN PEXTENDED_REQUEST_BLOCK Xrb,
	IN PVOID Buffer,
	IN SIZE_T BufferSize
	);

//
// Creation and destruction routines for SRBs.
//

PSCSI_REQUEST_BLOCK
RaidAllocateSrb(
	IN PVOID IoObject
	);

VOID
RaidFreeSrb(
	IN PSCSI_REQUEST_BLOCK Srb
	);

VOID
RaidPrepareSrbForReuse(
	IN PSCSI_REQUEST_BLOCK Srb
	);

NTSTATUS
RaidInitializeInquirySrb(
	IN PSCSI_REQUEST_BLOCK Srb,
	IN UCHAR PathId,
	IN UCHAR TargetId,
	IN UCHAR Lun,
	IN PVOID Buffer,
	IN SIZE_T BufferSize
	);

PEXTENDED_REQUEST_BLOCK
RaidGetAssociatedXrb(
	IN PSCSI_REQUEST_BLOCK Srb
	);

//
// Managing SRB extensions.
//

PVOID
RaidAllocateSrbExtension(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG QueueTag
	);

VOID
RaidFreeSrbExtension(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG QueueTag
	);

//
// Other operations for SRBs and XRBs.
//

NTSTATUS
RaidSrbStatusToNtStatus(
	IN UCHAR SrbStatus
	);
	
VOID
RaidSrbMarkPending(
	IN PSCSI_REQUEST_BLOCK Srb
	);

VOID
RaidXrbSignalCompletion(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\util.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for the RAID port driver.

Author:

    Matthew D Hendel (math) 13-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "precomp.h"

#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaSizeOfCmResourceList)
#pragma alloc_text(PAGE, RaDuplicateCmResourceList)
#pragma alloc_text(PAGE, RaFixupIds)
#pragma alloc_text(PAGE, RaCopyPaddedString)
#pragma alloc_text(PAGE, RaCreateTagList)
#pragma alloc_text(PAGE, RaDeleteTagList)
#pragma alloc_text(PAGE, RaInitializeTagList)
#endif // ALLOC_PRAGMA



#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

SCSI_DEVICE_TYPE ScsiDeviceTypes [] = {
    {"Disk",        "GenDisk",          L"DiskPeripheral",                  TRUE},
    {"Sequential",  "",                 L"TapePeripheral",                  TRUE},
    {"Printer",     "GenPrinter",       L"PrinterPeripheral",               FALSE},
    {"Processor",   "",                 L"OtherPeripheral",                 FALSE},
    {"Worm",        "GenWorm",          L"WormPeripheral",                  TRUE},
    {"CdRom",       "GenCdRom",         L"CdRomPeripheral",                 TRUE},
    {"Scanner",     "GenScanner",       L"ScannerPeripheral",               FALSE},
    {"Optical",     "GenOptical",       L"OpticalDiskPeripheral",           TRUE},
    {"Changer",     "ScsiChanger",      L"MediumChangerPeripheral",         TRUE},
    {"Net",         "ScsiNet",          L"CommunicationsPeripheral",        FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"ASCIT8",      "ScsiASCIT8",       L"ASCPrePressGraphicsPeripheral",   FALSE},
    {"Array",       "ScsiArray",        L"ArrayPeripheral",                 FALSE},
    {"Enclosure",   "ScsiEnclosure",    L"EnclosurePeripheral",             FALSE},
    {"RBC",         "ScsiRBC",          L"RBCPeripheral",                   TRUE},
    {"CardReader",  "ScsiCardReader",   L"CardReaderPeripheral",            FALSE},
    {"Bridge",      "ScsiBridge",       L"BridgePeripheral",                FALSE},
    {"Other",       "ScsiOther",        L"OtherPeripheral",                 FALSE}
};

#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif

const RAID_ADDRESS RaidNullAddress = { -1, -1, -1, -1 };

PSCSI_DEVICE_TYPE
RaGetDeviceType(
    IN ULONG DeviceType
    )
{
    if (DeviceType >= ARRAY_COUNT (ScsiDeviceTypes)) {
        DeviceType = ARRAY_COUNT (ScsiDeviceTypes) - 1;
    }
    
    return &ScsiDeviceTypes[DeviceType];
}


NTSTATUS
RaQueryInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCGUID InterfaceType,
    IN USHORT InterfaceSize,
    IN USHORT InterfaceVersion,
    IN PINTERFACE Interface,
    IN PVOID InterfaceSpecificData
    )
    
/*++

Routine Description:

    This routine sends an IRP_MJ_PNP, IRP_MN_QUERY_INTERFACE to the
    driver specified by DeviceObject and synchronously waits for a reply.

Arguments:

    DeviceObject -

    InterfaceType -

    InterfaceSize -

    InterfaceVersion -

    InterfaceBuffer -

    InterfaceSpecificData - 

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION IrpStack;


    Irp = IoAllocateIrp (DeviceObject->StackSize, FALSE);

    if (Irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    IrpStack = IoGetNextIrpStackLocation (Irp);
    
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IrpStack->MajorFunction = IRP_MJ_PNP;
    IrpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    IrpStack->Parameters.QueryInterface.InterfaceType = InterfaceType;
    IrpStack->Parameters.QueryInterface.Size = InterfaceSize;
    IrpStack->Parameters.QueryInterface.Version = InterfaceVersion;
    IrpStack->Parameters.QueryInterface.Interface = Interface;
    IrpStack->Parameters.QueryInterface.InterfaceSpecificData = InterfaceSpecificData;

    Status = RaSendIrpSynchronous (DeviceObject, Irp);

    IoFreeIrp (Irp);
    Irp = NULL;

    return Status;
}

    
NTSTATUS
RaForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    
    IoCopyCurrentIrpStackLocationToNext (Irp);
    Status = RaSendIrpSynchronous (DeviceObject, Irp);

    return Status;
}

VOID
INLINE
RaidInitializeKeTimeout(
    OUT PLARGE_INTEGER Timeout,
    IN ULONG Seconds
    )
/*++

Routine Description:

    Initialize a relative timeout value for use in KeWaitForXXXObject in
    terms of seconds.

Arguments:

    Timeout - Timeout variable to be initialized.

    Seconds - Number of seconds to wait before timing out.

Return Value:

    None.

--*/
{
    Timeout->QuadPart = (LONGLONG)(-1 * 10 * 1000 * (LONGLONG)1000 * Seconds);
}

NTSTATUS
RaForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    
    IoCopyCurrentIrpStackLocationToNext (Irp);
    Status = IoCallDriver (DeviceObject, Irp);

    return Status;
}
    

NTSTATUS
RiSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
{
    KeSetEvent (Event, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
RaSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT Event;
    NTSTATUS Status;

    ASSERT (DeviceObject != NULL);
    ASSERT (Irp != NULL);
    ASSERT (Irp->StackCount >= DeviceObject->StackSize);


    KeInitializeEvent (&Event, SynchronizationEvent, FALSE);
    
    IoSetCompletionRoutine (Irp,
                            RiSignalCompletion,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE);
                            
    Status = IoCallDriver (DeviceObject, Irp);

    if (Status == STATUS_PENDING) {

#if DBG
        
        LARGE_INTEGER Timeout;

        RaidInitializeKeTimeout (&Timeout, 30);

        do {

            Status = KeWaitForSingleObject(&Event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           &Timeout);


            if (Status == STATUS_TIMEOUT) {

                //
                // This DebugPrint should almost always be investigated by the
                // party who sent the irp and/or the current owner of the irp.
                // Synchronous Irps should not take this long (currently 30
                // seconds) without good reason.  This points to a potentially
                // serious problem in the underlying device stack.
                //

                DebugPrint(("RaidSendIrpSynchronous (%p) irp %p did not "
                            "complete within %x seconds\n",
                            DeviceObject,
                            Irp,
                            30));

                ASSERT(!" - Irp failed to complete within 30 seconds - ");
            }


        } while (Status == STATUS_TIMEOUT);


#else  // !DBG

        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

#endif // DBG

        Status = Irp->IoStatus.Status;
    }

    return Status;
}

NTSTATUS
RaDuplicateUnicodeString(
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
    IN POOL_TYPE Pool,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS Status;
    
    ASSERT (DestString != NULL);
    ASSERT (SourceString != NULL);

    //
    // Allocate the destination string.
    //
    
    DestString->Length = SourceString->Length;
    DestString->MaximumLength = SourceString->MaximumLength;
    DestString->Buffer = RaidAllocatePool (Pool,
                                           DestString->MaximumLength,
                                           STRING_TAG,
                                           DeviceObject);

    if (DestString->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Copy the string.
    //
    
    RtlCopyUnicodeString (DestString, SourceString);

    return STATUS_SUCCESS;
}
                                                
                                                
INTERFACE_TYPE
RaGetBusInterface(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS Status;
    GUID BusType;
    ULONG Size;

    Status = IoGetDeviceProperty( DeviceObject,
                                  DevicePropertyBusTypeGuid,
                                  sizeof (GUID),
                                  &BusType,
                                  &Size );

    if (!NT_SUCCESS (Status)) {
        return InterfaceTypeUndefined;
    }

    if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_PCMCIA)) {
        return Isa;
    } else if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_PCI)) {
        return PCIBus;
    } else if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_ISAPNP)) {
        return Isa;
    } else if (IsEqualGUID (&BusType, &GUID_BUS_TYPE_EISA)) {
        return Eisa;
    }

    return InterfaceTypeUndefined;
}


ULONG
RaSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine returns the size of a CM_RESOURCE_LIST.

Arguments:

    ResourceList - the resource list to be copied

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/

{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    ULONG i;

    PAGED_CODE();

    for(i = 0; i < ResourceList->Count; i++) {

        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor = &(ResourceList->List[i]);
        ULONG j;

        //
        // First descriptor is included in the size of the resource list.
        //

        if(i != 0) {
            size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        }

        for(j = 0; j < fullDescriptor->PartialResourceList.Count; j++) {

            //
            // First descriptor is included in the size of the partial list.
            //

            if(j != 0) {
                size += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
            }
        }
    }

    return size;
}

PCM_RESOURCE_LIST
RaDuplicateCmResourceList(
    IN POOL_TYPE PoolType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Tag
    )
/*++

Routine Description:

    This routine will attempt to allocate memory to copy the supplied
    resource list.  If sufficient memory cannot be allocated then the routine
    will return NULL.

Arguments:

    PoolType - the type of pool to allocate the duplicate from

    ResourceList - the resource list to be copied

    Tag - a value to tag the memory allocation with.  If 0 then untagged
          memory will be allocated.

Return Value:

    an allocated copy of the resource list (caller must free) or
    NULL if memory could not be allocated.

--*/
{
    ULONG size = sizeof(CM_RESOURCE_LIST);
    PVOID buffer;

    PAGED_CODE();

    size = RaSizeOfCmResourceList(ResourceList);

    buffer = ExAllocatePoolWithTag (PoolType, size, Tag);

    if (buffer != NULL) {
        RtlCopyMemory(buffer,
                      ResourceList,
                      size);
    }

    return buffer;
}


VOID
RaFixupIds(
    IN PWCHAR Id,
    IN BOOLEAN MultiSz
    )

/*++

Routine Description:

    This routine replaces any invalid PnP characters in the buffer passed
    in with the valid PnP character '_'.

Arguments:

    Id - A string or MULTI_SZ string that needs to be modified.

    MultiSz - TRUE if this is a MULTI_SZ string, FALSE if this is ax
            normal NULL terminated string.

Return Value:

    None.

--*/

{
    ULONG i;
    PAGED_CODE ();
    
    if (!MultiSz) {

        for (i = 0; Id[i] != UNICODE_NULL; i++) {

            if (Id[i] <= L' ' ||
                Id[i] > (WCHAR) 0x7F ||
                Id[i] == L',') {
            
                Id[i] = L'_';
            }
        }

    } else {

        for (i = 0;
             !(Id[i] == UNICODE_NULL && Id[i+1] == UNICODE_NULL);
             i++) {

            if (Id[i] == UNICODE_NULL) {
                continue;
            }
            
            if (Id[i] <= L' ' ||
                Id[i] > (WCHAR) 0x7F ||
                Id[i] == L',') {
            
                Id[i] = L'_';
            }
        }
    }
}


VOID
RaCopyPaddedString(
    OUT PCHAR Dest,
    IN ULONG DestLength,
    IN PCHAR Source,
    IN ULONG SourceLength
    )
/*++

Routine Description:

    This routine copies a padded string from Source to Dest, truncating
    any trailing spaces.

Arguments:

    Dest - Destination string where the string will be copied.

    DestLength - Length of the destination string.

    Source - Source string where the string will be copied from.

    SourceLength - Length of the source string.

Return Value:

    None.

--*/
{
    BOOLEAN FoundChar;
    LONG i;
    
    PAGED_CODE ();

    //
    // This function copies a padded string from source to dest, truncated
    // any trailing spaces.
    //
    
    ASSERT (SourceLength < DestLength);

    FoundChar = FALSE;
    Dest [SourceLength] = '\000';

    for (i = SourceLength - 1; i != -1 ; i--) {
        if (Source [i] != ' ') {
            FoundChar = TRUE;
            Dest [i] = Source [i];
        } else {
            if (!FoundChar) {
                Dest [i] = '\000';
            }
        }
    }
}



//
// Implementation of the QUEUE_TAG_LIST object.
//


#if DBG
VOID
ASSERT_TAG_LIST(
    IN PQUEUE_TAG_LIST TagList
    )
{
    //
    // The list lock should be held 
    //
    
    if (TagList->OutstandingTags != RtlNumberOfSetBits (&TagList->BitMap)) {
        DebugPrint (("OutstandingTags != NumberOfSetBits\n"));
        DebugPrint (("Outstanding = %d, NumberOfSetBits = %d\n",
                     TagList->OutstandingTags,
                     RtlNumberOfSetBits (&TagList->BitMap)));
        KdBreakPoint();
    }
}

#else

#define ASSERT_TAG_LIST(Arg)   (TRUE)

#endif

VOID
RaCreateTagList(
    OUT PQUEUE_TAG_LIST TagList
    )
/*++

Routine Description:

    Create a tagged queue list and initialize it to NULL.

Arguments:

    TagList - TagList to crate.

Return Value:

    NTSTATUS code.

--*/
{
    PAGED_CODE ();
    
    KeInitializeSpinLock (&TagList->Lock);
    TagList->Buffer = NULL;
}

VOID
RaDeleteTagList(
    IN PQUEUE_TAG_LIST TagList
    )
{

    PAGED_CODE ();
    
    if (TagList->Buffer) {
        RaidFreePool (TagList->Buffer, TAG_MAP_TAG);
    }

    DbgFillMemory (TagList, sizeof (*TagList), DBG_DEALLOCATED_FILL);
}
    

NTSTATUS
RaInitializeTagList(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG TagCount,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize a queue tag list.

Arguments:

    TagList - List to initialize.

    Count - Number of tags to allocate in the tag list. Elements will be
            allocated in the range 0 - Count - 1 inclusive.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG MapSize;

    PAGED_CODE ();
    
    MapSize = ((TagCount + 1) / 8) + 1;
    MapSize = ALIGN_UP (MapSize, ULONG);

    TagList->Buffer = RaidAllocatePool (NonPagedPool,
                                        MapSize,
                                        TAG_MAP_TAG,
                                        DeviceObject);
    if (TagList->Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    
    TagList->Count = TagCount;
    RtlInitializeBitMap (&TagList->BitMap, TagList->Buffer, TagCount);
    RtlClearAllBits (&TagList->BitMap);

    TagList->Hint = 0;
    TagList->HighWaterMark = 0;
    TagList->OutstandingTags = 0;

    return STATUS_SUCCESS;
}

ULONG
RaAllocateTag(
    IN OUT PQUEUE_TAG_LIST TagList
    )
/*++

Routine Description:

    Allocate a tag from the tag list and return it. Return -1 (0xFFFFFFFF)
    if no tag is available.
    
Arguments:

    TagList - Tag list that the tag should be allocated from.

Return Value:

    Allocated tag value or -1 for failure.

--*/
{
    ULONG QueueTag;
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock (&TagList->Lock, &LockHandle);

    //
    // Verify that the tag list is consistent.
    //
    
    ASSERT_TAG_LIST (TagList);
    
    //
    // Find the first clear tag in the tag bitmap,
    //

    //
    // NB: RAID 150434: when the bitmap is nearly full and the HintIndex
    // is non-zero, RtlFindClearBitsXXX can fail incorrectly. Until this
    // is resolved use a HintIndex of zero to work-around the bug.
    //
    
    QueueTag = RtlFindClearBitsAndSet (&TagList->BitMap,
                                       1,
                                       TagList->Hint);

#if DBG

    //
    // NB: Remove this test code when RtlFindClearBitsAndSet is working
    // properly.
    //

    if (QueueTag == -1) {
        ULONG i;
        
        KdBreakPoint();

        QueueTag = RtlFindClearBits(&TagList->BitMap, 1, TagList->Hint);
        QueueTag = RtlFindClearBits(&TagList->BitMap, 1, 0);

        for (i = 0; i < TagList->Count; i++) {
            ASSERT (RtlTestBit (&TagList->BitMap, i) == FALSE);
        }
    }

#endif

    
    //
    // The Hint value is the next point in the list where we should
    // begin our search.
    //
    
    TagList->Hint = (QueueTag + 1) % TagList->Count;

    //
    // Update the number of outstanding tags, and, if we're above the
    // highwater mark for the taglist, the maximum number of outstanding
    // tags we had pending at one time.
    //
    
    TagList->OutstandingTags++;

    if (TagList->OutstandingTags > TagList->HighWaterMark) {
        TagList->HighWaterMark = TagList->OutstandingTags;
    }
    
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return QueueTag;
}

VOID
RaFreeTag(
    IN OUT PQUEUE_TAG_LIST TagList,
    IN ULONG QueueTag
    )
/*++

Routine Description:

    Free a tag previously allocated by RaAllocateTag.

Arguments:

    TagList - List to free tag to.

    QueueTag - Tag to free.

Return Value:

    None.

--*/
{
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&TagList->Lock, &LockHandle);

    //
    // We should never attempt to free a tag that we haven't allocated.
    //
    
    ASSERT (RtlTestBit (&TagList->BitMap, QueueTag));
    RtlClearBit (&TagList->BitMap, QueueTag);

    ASSERT (TagList->OutstandingTags != 0);
    TagList->OutstandingTags--;

    //
    // Verify the tag list's consistency.
    //
    
    ASSERT_TAG_LIST (TagList);

    KeReleaseInStackQueuedSpinLock (&LockHandle);
}

#if 0

BOOLEAN
RaidGetModuleName(
    IN PVOID Address,
    IN OUT PANSI_STRING ModuleName
    )
/*++

Routine Description:

    Get a module name from a code address within the module.

Arguments:

    Address - Code address within a module.

    ModuleName - Supplies a pointer to an ansi string where the
            module name will be stored.

Return Value:

    None.

--*/
{
    PAGED_CODE ();
    
    Status = ZwQuerySystemInformation (SystemModuleInformation,
                                       ModuleInfo,
                                       RequiredLength,
                                       &RequiredLength );

    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        return FALSE;
    }
    
    ModuleList = RaidAllocatePool (DeviceObject,
                                   PagedPool,
                                   RequiredLength,
                                   RAID_TAG);

    if (!ModuleList) {
        return FALSE;
    }
    
    Status = ZwQuerySystemInformation (SystemModuleInformation,
                                       ModuleInfo,
                                       RequiredLength,
                                       &RequiredLength);
                                               
    if (!NT_SUCCESS (Status)) {
        RaidFreePool (ModuleList, RAID_TAG);
        return FALSE;
    }

    //
    // Walk the module list, searching for an address that matches.
    //
    
    for (i = 0; i < ModuleList->NumberOfModules; i++) {

        Module = &ModuleList[i];

        //
        // If the address is in range
        //
        
        if (Module->ImageBase <= Address &&
            Address < Module->ImageBase + Module->ImageSizs) {

            strcpy (Buffer, ModuleInfo->Modules[i].FullPathName[....]);
        }
    }

}

#endif



NTSTATUS
RaidSrbStatusToNtStatus(
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    Translate a SCSI Srb status to an NT Status code.

Arguments:

    SrbStatus - Supplies the srb status code to translate.

Return Value:

    NTSTATUS code.

--*/
{
    switch (SRB_STATUS(SrbStatus)) {

        case SRB_STATUS_BUSY:
            return STATUS_DEVICE_BUSY;

        case SRB_STATUS_SUCCESS:
            return STATUS_SUCCESS;

        case SRB_STATUS_INVALID_LUN:
        case SRB_STATUS_INVALID_TARGET_ID:
        case SRB_STATUS_NO_DEVICE:
        case SRB_STATUS_NO_HBA:
            return STATUS_DEVICE_DOES_NOT_EXIST;

        case SRB_STATUS_COMMAND_TIMEOUT:
        case SRB_STATUS_TIMEOUT:
            return STATUS_IO_TIMEOUT;
            
        case SRB_STATUS_SELECTION_TIMEOUT:
            return STATUS_DEVICE_NOT_CONNECTED;

        case SRB_STATUS_BAD_FUNCTION:
        case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
            return STATUS_INVALID_DEVICE_REQUEST;

        case SRB_STATUS_DATA_OVERRUN:
            return STATUS_BUFFER_OVERFLOW;

        default:
            return STATUS_IO_DEVICE_ERROR;
    }
}

UCHAR
RaidNtStatusToSrbStatus(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    Translate an NT status value into a SCSI Srb status code.

Arguments:

    Status - Supplies the NT status code to translate.

Return Value:

    SRB status code.

--*/
{
    switch (Status) {

        case STATUS_DEVICE_BUSY:
            return SRB_STATUS_BUSY;

        case STATUS_DEVICE_DOES_NOT_EXIST:
            return SRB_STATUS_NO_DEVICE;

        case STATUS_IO_TIMEOUT:
            return SRB_STATUS_TIMEOUT;

        case STATUS_DEVICE_NOT_CONNECTED:
            return SRB_STATUS_SELECTION_TIMEOUT;

        case STATUS_INVALID_DEVICE_REQUEST:
            return SRB_STATUS_BAD_FUNCTION;

        case STATUS_BUFFER_OVERFLOW:
            return SRB_STATUS_DATA_OVERRUN;

        default:
            if (NT_SUCCESS (Status)) {
                return SRB_STATUS_SUCCESS;
            } else {
                return SRB_STATUS_ERROR;
            }
    }
}

        
NTSTATUS
RaidAllocateAddressMapping(
    IN PMAPPED_ADDRESS* ListHead,
    IN SCSI_PHYSICAL_ADDRESS Address,
    IN PVOID MappedAddress,
    IN ULONG NumberOfBytes,
    IN ULONG BusNumber,
    IN PVOID IoObject
    )
/*++

Routine Description:

    We need to maintain a list of mapped addresses for two reasons:

        1) Because ScsiPortFreeDeviceBase doesn't take as a parameter
            the number of bytes to unmap.

        2) For crashdump to know whether it needs to map the address or
            whether it can reuse an already mapped address.

    Becase diskdump uses the MAPPED_ADDRESS structure, we must maintain
    the address list as a list of MAPPED_ADDRESS structures.
    
Arguments:

    ListHead - Head of the list to add the address mapping to.

    Address - Physical address of address to add.

    MappedAddress - Virtual address of address to add.

    NumberOfBytes - Number of bytes in the range.

    BusNumber - The system bus number this region is for.

Return Value:

    NTSTATUS code.

--*/
{
    PMAPPED_ADDRESS Mapping;
    
    PAGED_CODE ();

    Mapping = RaidAllocatePool (NonPagedPool,
                                sizeof (MAPPED_ADDRESS),
                                MAPPED_ADDRESS_TAG,
                                IoObject);

    if (Mapping == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (Mapping, sizeof (MAPPED_ADDRESS));

    Mapping->NextMappedAddress = *ListHead;
    *ListHead = Mapping;

    Mapping->IoAddress = Address;
    Mapping->MappedAddress = MappedAddress;
    Mapping->NumberOfBytes = NumberOfBytes;
    Mapping->BusNumber = BusNumber;

    return STATUS_SUCCESS;
}
                                           

NTSTATUS
RaidFreeAddressMapping(
    IN PMAPPED_ADDRESS* ListHead,
    IN PVOID MappedAddress
    )
/*++

Routine Description:

    Free a mapped address previously allocated by RaidAllocateMappedAddress.

Arguments:

    ListHead - Address list for the address to free.

    MappedAddress - Address to free.

Return Value:

    NTSTATUS code.

--*/
{
    PMAPPED_ADDRESS* MappingPtr;
    PMAPPED_ADDRESS Mapping;

    PAGED_CODE ();
    
    for (MappingPtr = ListHead;
        *MappingPtr != NULL;
         MappingPtr = &(*MappingPtr)->NextMappedAddress) {

        if ((*MappingPtr)->MappedAddress == MappedAddress) {

            Mapping = *MappingPtr;

            MmUnmapIoSpace (Mapping, Mapping->NumberOfBytes);

            *MappingPtr = Mapping->NextMappedAddress;
            DbgFillMemory (Mapping, sizeof (MAPPED_ADDRESS), DBG_DEALLOCATED_FILL);
            RaidFreePool (Mapping,
                               MAPPED_ADDRESS_TAG);
                                

            return STATUS_SUCCESS;
        }
    }


    return STATUS_NOT_FOUND;
}
    

NTSTATUS
RaidHandleCreateCloseIrp(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PIRP Irp
    )
/*++

Routine Description:

    Common create logic for Adapter and Unit objects.

Arguments:

    RemoveLock -

    Irp -

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE ();

    ASSERT (RemoveLock != NULL);
    ASSERT (Irp != NULL);
    
    Status = IoAcquireRemoveLock (RemoveLock, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, IO_NO_INCREMENT, Status);
    }

    IoReleaseRemoveLock (RemoveLock, Irp);
    return RaidCompleteRequest (Irp, IO_NO_INCREMENT, STATUS_SUCCESS);
}



VOID
RaidLogAllocationFailure(
    IN PDEVICE_OBJECT DeviceObject,
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    PRAID_ALLOCATION_ERROR Error;

    Error = IoAllocateErrorLogEntry (DeviceObject,
                                     sizeof (RAID_ALLOCATION_ERROR));

    if (Error == NULL) {
        InterlockedIncrement (&RaidUnloggedErrors);
    } else {
        
        Error->Packet.SequenceNumber = 0;
        Error->Packet.MajorFunctionCode = 0;
        Error->Packet.RetryCount = 0;

        Error->Packet.ErrorCode = IO_WARNING_ALLOCATION_FAILED;
        Error->Packet.UniqueErrorValue = RAID_ERROR_NO_MEMORY;
        Error->Packet.FinalStatus = STATUS_NO_MEMORY;
        Error->Packet.DumpDataSize = sizeof (RAID_ALLOCATION_ERROR) -
                sizeof (IO_ERROR_LOG_PACKET);
        Error->PoolType = PoolType;
        Error->NumberOfBytes = NumberOfBytes;
        Error->Tag = Tag;

        IoWriteErrorLogEntry (&Error->Packet);
    }
}


PVOID
RaidAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Allocate memory from pool and log an error in case of failure.

Arguments:

    DeviceObject -

    PoolType -

    NumberOfBytes -

    Tag - 

Return Value:

    Non-NULL if the allocation succeeded.

    NULL if the allocation failed.

--*/
{
    PVOID Data;
     
    VERIFY_DISPATCH_LEVEL();
    ASSERT (DeviceObject != NULL);
    
    Data = ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);

    if (Data == NULL) {
        RaidLogAllocationFailure (DeviceObject,
                                  PoolType,
                                  NumberOfBytes,
                                  Tag);
    }

    return Data;
}

ULONG
RaidScsiErrorToIoError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    Translate a SCSIPORT SP error to an IO error.

Arguments:

    ErrorCode - SCSI-port specific error code.

Return Value:

    IO-specific error code.

--*/
{
    switch (ErrorCode) {

        case SP_BUS_PARITY_ERROR:
            return IO_ERR_PARITY;
            
        case SP_BUS_TIME_OUT:
            return IO_ERR_TIMEOUT;

        case SP_IRQ_NOT_RESPONDING:
            return IO_ERR_INCORRECT_IRQL;

        case SP_BAD_FW_ERROR:
            return IO_ERR_BAD_FIRMWARE;

        case SP_BAD_FW_WARNING:
            return IO_ERR_BAD_FIRMWARE;

        case SP_PROTOCOL_ERROR:
        case SP_UNEXPECTED_DISCONNECT:
        case SP_INVALID_RESELECTION:
        case SP_INTERNAL_ADAPTER_ERROR:
        default:
            return IO_ERR_CONTROLLER_ERROR;
    }
}

PVOID
RaidGetSystemAddressForMdl(
    IN PMDL Mdl,
    IN MM_PAGE_PRIORITY Priority,
    IN PVOID DeviceObject
    )
{
    PVOID SystemAddress;

    
    SystemAddress = MmGetSystemAddressForMdlSafe (Mdl, Priority);

    if (SystemAddress == NULL) {

        //
        // Log an allocation failure here.
        //
        
        NYI();
    }

    return SystemAddress;
}
        

NTSTATUS
StorCreateScsiSymbolicLink(
    IN PUNICODE_STRING DeviceName,
    OUT PULONG PortNumber OPTIONAL
    )
/*++

Routine Description:

    Create the appropiate symbolic link between the device name and
    the SCSI device name.

Arguments:

    DeviceName - Supplies the name of the device.

    PortNumber - Supplies a buffer where SCSI port number will be
        returned upon success.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    NTSTATUS Status;
    UNICODE_STRING ScsiLinkName;
    WCHAR Buffer[32];

    PAGED_CODE();

    for (i = 0; ; i++) {

        swprintf (Buffer, L"\\Device\\ScsiPort%d", i);
        RtlInitUnicodeString (&ScsiLinkName, Buffer);
        Status = IoCreateSymbolicLink (&ScsiLinkName, DeviceName);

        if (Status == STATUS_SUCCESS) {
            break;
        }

        if (Status != STATUS_OBJECT_NAME_COLLISION) {
            return Status;
        }
    }

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    swprintf (Buffer, L"\\DosDevices\\Scsi%d:", i);
    RtlInitUnicodeString (&ScsiLinkName, Buffer);
    IoCreateSymbolicLink (&ScsiLinkName, DeviceName);

    //
    // NB: Why doesn't this need to be synchronized?
    //
    
    IoGetConfigurationInformation()->ScsiPortCount++;

    if (PortNumber) {
        *PortNumber = i;
    }

    return Status;
}


LONG GlobalPortNumber = -1;

NTSTATUS
RaidCreateDeviceName(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING DeviceName
    )
{
    WCHAR Buffer[32];
    UNICODE_STRING TempDeviceName;

    PAGED_CODE();

    swprintf (Buffer,
              L"\\Device\\RaidPort%d",
              InterlockedIncrement (&GlobalPortNumber));

    RtlInitUnicodeString (&TempDeviceName, Buffer);
    RaDuplicateUnicodeString (DeviceName,
                              &TempDeviceName,
                              PagedPool,
                              DeviceObject);

    return STATUS_SUCCESS;
}

BOOLEAN
StorCreateAnsiString(
    OUT PANSI_STRING AnsiString,
    IN PCSTR String,
    IN ULONG Length,
    IN POOL_TYPE PoolType,
    IN PVOID IoObject
    )
{
    ASSERT_IO_OBJECT (IoObject);

    if (Length == -1) {
        Length = strlen (String);
    }

    AnsiString->Buffer = RaidAllocatePool (PoolType,
                                           Length,
                                           STRING_TAG,
                                           IoObject);
    if (AnsiString->Buffer == NULL) {
        return FALSE;
    }

    RtlCopyMemory (AnsiString->Buffer, String, Length);
    AnsiString->MaximumLength = (USHORT)Length;
    AnsiString->Length = (USHORT)(Length - 1);
    return TRUE;
}



VOID
StorFreeAnsiString(
    IN PANSI_STRING AnsiString
    )
{
    PAGED_CODE();

    if (AnsiString->Buffer) {
        DbgFillMemory (AnsiString->Buffer,
                       AnsiString->MaximumLength,
                       DBG_DEALLOCATED_FILL);
        RaidFreePool (AnsiString->Buffer, STRING_TAG);
    }

    AnsiString->Buffer = NULL;
    AnsiString->Length = 0;
    AnsiString->MaximumLength = 0;
}



NTSTATUS
StorProbeAndLockPages(
    IN PMDL Mdl,
    IN KPROCESSOR_MODE AccessMode,
    IN LOCK_OPERATION Operation
    )
/*++

Routine Description:

    Same thing as MmProbeAndLockPages except returns an error value
    instead of throwing an exception.

Arguments:

    Mdl, AccessMode, Operation - See MmProbeAndLockPages.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    try {
        MmProbeAndLockPages (Mdl, AccessMode, Operation);
        Status = STATUS_SUCCESS;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

PIRP
StorBuildSynchronousScsiRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )
/*++

Routine Description:

    Similiar to IoBuildSynchronousFsdRequest, this routine builds an I/O
    request for a SCSI driver.

    This function assumes the SRB has been properly validate by the higher
    level routines before being called.
    
Arguments:

    DeviceObject - Pointer to device object on which the IO will be performed.

    Srb - SCSI request block describing the IO.

    Event - Pointer to a kernel event structure for synchronization.

    IoStatusBlock - Pointer to the IO status block for completion status.

Return Value:

    The routine returns a pointer to an IRP on success or NULL for failure.

--*/
{
    NTSTATUS Status;
    PMDL Mdl;
    PIRP Irp;
    LOCK_OPERATION IoAccess;
    PIO_STACK_LOCATION Stack;
    

    PAGED_CODE();
    
    Irp = NULL;
    
    Irp = IoAllocateIrp (DeviceObject->StackSize, FALSE);
    if (Irp == NULL) {
        return NULL;
    }

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Stack = IoGetNextIrpStackLocation (Irp);

    Stack->MajorFunction = IRP_MJ_SCSI;
    Stack->MinorFunction = 0;

    //
    // We assume that the buffer(s) have already been validated. Setup
    // the Buffer, BufferSize and IoAccess variables as appropiate for
    // reading or writing data.
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)) {
        IoAccess = IoModifyAccess;
    } else if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_IN)) {
        IoAccess = IoWriteAccess;
    } else if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_DATA_OUT)) {
        IoAccess = IoReadAccess;
    } else {
        IoAccess = -1;
    }
    
    //
    // We assume the port driver does direct IO.
    //
    
    ASSERT (DeviceObject->Flags & DO_DIRECT_IO);

    //
    // If there is a buffer present, build and lock down a MDL describing
    // it.
    //
    
    if (Srb->DataTransferLength != 0) {
    
        //
        // Allocate a MDL that describes the buffer.
        //
        
        Irp->MdlAddress = IoAllocateMdl (Srb->DataBuffer,
                                         Srb->DataTransferLength,
                                         FALSE,
                                         FALSE,
                                         NULL);
        if (Irp->MdlAddress == NULL) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        //
        // Probe and lock the buffer.
        //
        
        Status = StorProbeAndLockPages (Irp->MdlAddress, KernelMode, IoAccess);
        if (!NT_SUCCESS (Status)) {
            goto done;
        }
    }

    Stack->Parameters.Scsi.Srb = Srb;
    Irp->UserIosb = IoStatusBlock;
    Irp->UserEvent = Event;
    Status = STATUS_SUCCESS;

    //IopQueueThreadIrp (...);

done:

    if (!NT_SUCCESS (Status)) {
        if (Irp != NULL) {
            IoFreeIrp (Irp);
            Irp = NULL;
        }
    }

    return Irp;
}



#if 0
NTSTATUS
RaidUnitReset(
    IN PRAID_UNIT_OBJECT Unit
    )
/*++

Routine Description:

    Perform a hierarchical reset on the logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

--*/
{
    // Build a SRB

    Srb->Function = SRB_FUNCTION_RESET_LOGICAL_UNIT;

    //
    // Issue the Srb.
    //


    if ( succeeded )
        return status;


    Srb->Function = SRB_FUNCTION_RESET_TARGET;

    //
    // Issue the srb.
    //

    if ( succeeded ) {
        return status;


    Srb->Function = SRB_FUNCTION_BUS_RESET;
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\util.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	util.h

Abstract:

	Utilities for RAIDPORT driver.

Author:

	Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once


#define REMLOCK_MAX_WAIT    (1)		// Minutes

//
// We can have 255 outstanding IOs, plus how ever many are currently
// being processed. 355 is just a guess, we may need to refine this later.
//

#define REMLOCK_HIGH_MARK   (355)

#define TAG_QUEUE_COUNT		(254)

//
// Lengths of various identifiers.
//
									 
#define SCSI_BUS_NAME_LENGTH			(sizeof ("SCSI"))
#define MAX_DEVICE_NAME_LENGTH			(sizeof ("Sequential"))
#define SCSI_VENDOR_ID_LENGTH			(8)
#define SCSI_PRODUCT_ID_LENGTH			(16)
#define SCSI_REVISION_ID_LENGTH			(4)
#define MAX_GENERIC_DEVICE_NAME_LENGTH	(sizeof ("ScsiCardReader"))

#define HARDWARE_B_D_V_LENGTH		(SCSI_BUS_NAME_LENGTH +					\
									 MAX_DEVICE_NAME_LENGTH +				\
									 SCSI_VENDOR_ID_LENGTH + 1)

#define HARDWARE_B_D_V_P_LENGTH		(HARDWARE_B_D_V_LENGTH +				\
									 SCSI_PRODUCT_ID_LENGTH)

#define HARDWARE_B_D_V_P_R_LENGTH	(HARDWARE_B_D_V_P_LENGTH +				\
									 SCSI_REVISION_ID_LENGTH)

#define HARDWARE_B_V_P_LENGTH		(SCSI_BUS_NAME_LENGTH +					\
									 SCSI_VENDOR_ID_LENGTH +				\
									 SCSI_PRODUCT_ID_LENGTH + 1)

#define HARDWARE_B_V_P_R0_LENGTH	(SCSI_BUS_NAME_LENGTH +					\
									 SCSI_VENDOR_ID_LENGTH +				\
									 SCSI_PRODUCT_ID_LENGTH +				\
									 SCSI_REVISION_ID_LENGTH + 1)

#define HARDWARE_V_P_R0_LENGTH		(SCSI_VENDOR_ID_LENGTH +				\
									 SCSI_PRODUCT_ID_LENGTH +				\
									 SCSI_REVISION_ID_LENGTH + 1)


#define HARDWARE_ID_LENGTH			(HARDWARE_B_D_V_LENGTH +				\
									 HARDWARE_B_D_V_P_LENGTH +				\
									 HARDWARE_B_D_V_P_R_LENGTH +			\
									 HARDWARE_B_V_P_LENGTH +				\
									 HARDWARE_B_V_P_R0_LENGTH +				\
									 HARDWARE_V_P_R0_LENGTH +				\
									 MAX_GENERIC_DEVICE_NAME_LENGTH + 2)


#define DEVICE_ID_LENGTH			(HARDWARE_B_D_V_P_R_LENGTH +			\
									 sizeof ("&Ven_") +						\
									 sizeof ("&Prod_") +					\
									 sizeof ("&Rev_"))


#define INSTANCE_ID_LENGTH			(20)

#define COMPATIBLE_ID_LENGTH		(SCSI_BUS_NAME_LENGTH +					\
									 MAX_DEVICE_NAME_LENGTH +				\
									 1 +									\
									 sizeof ("SCSI\\RAW") +					\
									 1 +									\
									 1)										\

typedef struct _SCSI_DEVICE_TYPE {

	//
	// String specifying the device name, e.g., "Disk", "Sequential", etc.
	//
	
	PCHAR Name;

	//
	// The generic device name for this device, e.g., "GenDisk", "GenPrinter", etc.
	//
	
	PCHAR GenericName;

	//
	// NOT CURRENTLY USED BY RAIDPORT
	//
	
	PWCHAR DeviceMap;		// Maybe not necessary for RAIDPORT

	//
	// Is this a storage device?
	//
	
	BOOLEAN IsStorage;		// Necessary for RAIDPORT?

} SCSI_DEVICE_TYPE, *PSCSI_DEVICE_TYPE;


ULONG
RaidMinorFunctionFromIrp(
    IN PIRP Irp
    );

ULONG
RaidMajorFunctionFromIrp(
    IN PIRP Irp
    );

ULONG
RaidIoctlFromIrp(
    IN PIRP Irp
    );

PSCSI_REQUEST_BLOCK
RaidSrbFromIrp(
	IN PIRP Irp
	);

UCHAR
RaidSrbFunctionFromIrp(
    IN PIRP Irp
    );

UCHAR
RaidScsiOpFromIrp(
	IN PIRP Irp
	);

NTSTATUS
RaidNtStatusFromScsiStatus(
    IN ULONG ScsiStatus
    );

UCHAR
RaidNtStatusToSrbStatus(
	IN NTSTATUS Status
	);

NTSTATUS
RaidNtStatusFromBoolean(
    IN BOOLEAN Succ
    );

POWER_STATE_TYPE
RaidPowerTypeFromIrp(
	IN PIRP Irp
	);

POWER_STATE
RaidPowerStateFromIrp(
	IN PIRP Irp
	);

INTERFACE_TYPE
RaGetBusInterface(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RaForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RaSendIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
	
NTSTATUS
RaForwardIrp(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS
RaDuplicateUnicodeString(
    OUT PUNICODE_STRING DestString,
    IN PUNICODE_STRING SourceString,
	IN POOL_TYPE Pool,
	IN PVOID IoObject
    );

ULONG
RaSizeOfCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList
    );

PCM_RESOURCE_LIST
RaDuplicateCmResourceList(
    IN POOL_TYPE PoolType,
    IN PCM_RESOURCE_LIST ResourceList,
    IN ULONG Tag
    );

NTSTATUS
RaQueryInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCGUID InterfaceType,
    IN USHORT InterfaceSize,
    IN USHORT InterfaceVersion,
    IN PINTERFACE Interface,
    IN PVOID InterfaceSpecificData
    );

PSCSI_DEVICE_TYPE
RaGetDeviceType(
	IN ULONG DeviceType
	);
VOID
RaFixupIds(
    IN PWCHAR Id,
    IN BOOLEAN MultiSz
    );

VOID
RaCopyPaddedString(
    OUT PCHAR Dest,
    IN ULONG DestLength,
    IN PCHAR Source,
    IN ULONG SourceLength
    );


typedef struct _RAID_FIXED_POOL {

	//
	// Buffer to allocate from.
	//
	
	PUCHAR Buffer;

	//
	// Number of elements in the pool.
	//
	
	ULONG NumberOfElements;

	//
	// Size of each element.
	//
	
	SIZE_T SizeOfElement;

} RAID_FIXED_POOL, *PRAID_FIXED_POOL;



VOID
RaidCreateFixedPool(
	IN PRAID_FIXED_POOL Pool
	);

VOID
RaidInitializeFixedPool(
	OUT PRAID_FIXED_POOL Pool,
	IN PVOID Buffer,
	IN ULONG NumberOfElements,
	IN SIZE_T SizeOfElement
	);

VOID
RaidDeleteFixedPool(
	IN PRAID_FIXED_POOL Pool
	);

PVOID
RaidAllocateFixedPoolElement(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG Index
	);

PVOID
RaidGetFixedPoolElement(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG Index
	);

VOID
RaidFreeFixedPoolElement(
	IN PRAID_FIXED_POOL Pool,
	IN ULONG Element
	);

//
// A list for managing entries in the tagged queue list.
//

typedef struct _QUEUE_TAG_LIST {

	//
	// Spinlock held while accessing the queue list.
	//
	
	KSPIN_LOCK Lock;

	//
	// Number of elements in the list.
	//
	
	ULONG Count;

	//
	// Hint to speed up tag allocation.
	//
	
	ULONG Hint;

	//
	// BitMap to hold the tag values.
	//
	
	RTL_BITMAP BitMap;

	//
	// BitMap Buffer.
	//

	PULONG Buffer;

	//
	// Number of outstanding tags. This could probably be DBG only.
	//

	ULONG OutstandingTags;

	//
	// The maximum number of tags that were outstanding at one time.
	//

	ULONG HighWaterMark;
	
	
} QUEUE_TAG_LIST, *PQUEUE_TAG_LIST;


VOID
RaCreateTagList(
	OUT PQUEUE_TAG_LIST TagList
	);

VOID
RaDeleteTagList(
	IN PQUEUE_TAG_LIST TagList
	);

NTSTATUS
RaInitializeTagList(
	IN OUT PQUEUE_TAG_LIST TagList,
	IN ULONG TagCount,
	IN PVOID IoObject
	);

ULONG
RaAllocateTag(
	IN OUT PQUEUE_TAG_LIST TagList
	);

VOID
RaFreeTag(
	IN OUT PQUEUE_TAG_LIST TagList,
	IN ULONG Tag
	);
	


typedef struct CONTEXT_STATUS_TUPLE {
	PVOID Context;
	NTSTATUS Status;
} CONTEXT_STATUS_TUPLE, *PCONTEXT_STATUS_TUPLE;


//
// RAID_MEMORY_REGION represents a region of physical contiguous memory.
// Generally, this is used for DMA common buffer regions.
//

typedef struct _RAID_MEMORY_REGION {

	//
	// Beginning virtual address of the region.
	//
	
	PUCHAR VirtualBase;

	//
	// Beginning physical address of the region.
	//
	
	PHYSICAL_ADDRESS PhysicalBase;

	//
	// Length of the region. (Is there any need to make this a SIZE_T
	// value?)
	//
	
	ULONG Length;
	
} RAID_MEMORY_REGION, *PRAID_MEMORY_REGION;


//
// Creation and destruction of the memory region.
//

VOID
INLINE
RaidCreateRegion(
	OUT PRAID_MEMORY_REGION Region
	)
{
	RtlZeroMemory (Region, sizeof (RAID_MEMORY_REGION));
}

VOID
INLINE
RaidInitializeRegion(
	IN OUT PRAID_MEMORY_REGION Region,
	IN PVOID VirtualAddress,
	IN PHYSICAL_ADDRESS PhysicalAddress,
	IN ULONG Length
	)
{
	ASSERT (Region->Length == 0);

	Region->VirtualBase = VirtualAddress;
	Region->PhysicalBase = PhysicalAddress;
	Region->Length = Length;
}

BOOLEAN
INLINE
RaidIsRegionInitialized(
	IN PRAID_MEMORY_REGION Region
	)
{
	return (Region->Length != 0);
}

VOID
INLINE
RaidDeleteRegion(
	IN OUT PRAID_MEMORY_REGION Region
	)
{
	//
	// Nothing
	//
}


//
// Operations on the memory region.
//

PVOID
INLINE
RaidRegionGetVirtualBase(
	IN PRAID_MEMORY_REGION Region
	)
{
	ASSERT (RaidIsRegionInitialized (Region));
	return Region->VirtualBase;	
}

PHYSICAL_ADDRESS
INLINE
RaidRegionGetPhysicalBase(
	IN PRAID_MEMORY_REGION Region
	)
{
	ASSERT (RaidIsRegionInitialized (Region));
	return Region->PhysicalBase;
}

ULONG
INLINE
RaidRegionGetSize(
	IN PRAID_MEMORY_REGION Region
	)
{
	ASSERT (RaidIsRegionInitialized (Region));
	return Region->Length;
}

BOOLEAN
INLINE
RaidRegionInPhysicalRange(
	IN PRAID_MEMORY_REGION Region,
	IN PHYSICAL_ADDRESS PhysicalAddress
	)
{
	return IN_RANGE (Region->PhysicalBase.QuadPart,
					 PhysicalAddress.QuadPart,
					 Region->PhysicalBase.QuadPart + Region->Length);
}

BOOLEAN
INLINE
RaidRegionInVirtualRange(
	IN PRAID_MEMORY_REGION Region,
	IN PVOID VirtualAddress
	)
{
	return IN_RANGE (Region->VirtualBase,
					 (PUCHAR)VirtualAddress,
					 Region->VirtualBase + Region->Length);
}

BOOLEAN
INLINE
RaidRegionGetPhysicalAddress(
	IN PRAID_MEMORY_REGION Region,
	IN PVOID VirtualAddress,
	OUT PPHYSICAL_ADDRESS PhysicalAddress,
	OUT PULONG Length OPTIONAL
	)
/*++

Routine Description:

	Get a physical address for a specific virtual address within
	the region.

Arguments:

	Region - Supplies a pointer to a region object that contain the
			specified virtual address.

	VirtualAddress - Supplies the source virtual address.

	PhysicalAddress - Buffer where the physical address for this virtual
			address will be stored on success.

	Length - Optional out parameter taking the length of the physical
			region that is valid.

Return Value:

	TRUE - If the operation succeeded.

	FALSE - If the virtual address was out of range.

--*/
{
	ULONG Offset;

	//
	// If the virtual address isn't within range, fail.
	//
	
	if (!RaidRegionInVirtualRange (Region, VirtualAddress)) {
		return FALSE;
	}

	Offset = (ULONG)((PUCHAR)VirtualAddress - Region->VirtualBase);
	PhysicalAddress->QuadPart = Region->PhysicalBase.QuadPart + Offset;

	if (Length) {
		*Length = Region->Length - Offset;
	}

	//
	// Check that we did the fixup correctly.
	//
	
	ASSERT (RaidRegionInPhysicalRange (Region, *PhysicalAddress));
	
	return TRUE;
}

	

BOOLEAN
INLINE
RaidRegionGetVirtualAddress(
	IN PRAID_MEMORY_REGION Region,
	IN PHYSICAL_ADDRESS PhysicalAddress,
	OUT PVOID* VirtualAddress,
	OUT PULONG Length OPTIONAL
	)
{
	ULONG Offset;
	
	//
	// If the physical address isn't within range, fail.
	//
	
	if (!RaidRegionInPhysicalRange (Region, PhysicalAddress)) {
		return FALSE;
	}

	Offset = (ULONG)(Region->PhysicalBase.QuadPart - PhysicalAddress.QuadPart);
	VirtualAddress = (PVOID)(Region->VirtualBase + Offset);

	if (Length) {
		*Length = Region->Length - Offset;
	}

	return TRUE;
}


NTSTATUS
RaidAllocateAddressMapping(
	IN PMAPPED_ADDRESS* ListHead,
	IN SCSI_PHYSICAL_ADDRESS Address,
	IN PVOID MappedAddress,
	IN ULONG NumberOfBytes,
	IN ULONG BusNumber,
	IN PVOID IoObject
	);

NTSTATUS
RaidFreeAddressMapping(
	IN PMAPPED_ADDRESS* ListHead,
	IN PVOID MappedAddress
	);

NTSTATUS
RaidHandleCreateCloseIrp(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PIRP Irp
    );


//
// Irp state tracking
//

typedef struct _EX_DEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
	ULONG SortKey;
	BOOLEAN Inserted;
	UCHAR State;
	UCHAR reserved[2];
} EX_DEVICE_QUEUE_ENTRY, *PEX_DEVICE_QUEUE_ENTRY;

C_ASSERT (sizeof (EX_DEVICE_QUEUE_ENTRY) == sizeof (KDEVICE_QUEUE_ENTRY));


//
// Port processing irp means the port driver is currently executing
// instructions to complete the irp. The irp is NOT waiting for
// resources on any queue.
//

#define RaidPortProcessingIrp			(0xA8)

//
// Pending resources is when the irp is in an IO queue awaiting
// resources.
//

#define RaidPendingResourcesIrp			(0xA9)

//
// The irp takes on state Miniport Processing while the miniport has
// control over the irp. That is, between the time we call HwStartIo
// and when the miniport calls ScsiPortNotification with a completion
// status for the irp.
//

#define RaidMiniportProcessingIrp		(0xAA)

//
// The irp takes on the Pending Completion state when it is moved to
// the completed list.
//

#define RaidPendingCompletionIrp		(0xAB)

//
// We set the irp state to Completed just before we call IoCompleteRequest
// for the irp.
//

#define RaidCompletedIrp				(0xAC)


typedef UCHAR RAID_IRP_STATE;

VOID
INLINE
RaidSetIrpState(
	IN PIRP Irp,
	IN RAID_IRP_STATE State
	)
{
	((PEX_DEVICE_QUEUE_ENTRY)&Irp->Tail.Overlay.DeviceQueueEntry)->State = State;
}

	

RAID_IRP_STATE
INLINE
RaidGetIrpState(
	IN PIRP Irp
	)
{
	return ((PEX_DEVICE_QUEUE_ENTRY)&Irp->Tail.Overlay.DeviceQueueEntry)->State;
}

//
// Completion wrapper function.
//

NTSTATUS
INLINE
RaidCompleteRequest(
	IN PIRP Irp,
	IN CCHAR PriorityBoost,
	IN NTSTATUS Status
	)
{
	RAID_IRP_STATE IrpState;

	IrpState = RaidGetIrpState (Irp);

	ASSERT (IrpState == RaidPortProcessingIrp ||
			IrpState == RaidPendingResourcesIrp ||
			IrpState == RaidMiniportProcessingIrp ||
			IrpState == RaidPendingCompletionIrp);

	RaidSetIrpState (Irp, RaidCompletedIrp);
	Irp->IoStatus.Status = Status;

	IoCompleteRequest (Irp, PriorityBoost);

	return Status;
}


//
// Error log information
//

typedef struct _RAID_ALLOCATION_ERROR {
    IO_ERROR_LOG_PACKET Packet;
	POOL_TYPE PoolType;
	SIZE_T NumberOfBytes;
	ULONG Tag;
} RAID_ALLOCATION_ERROR, *PRAID_ALLOCATION_ERROR;

typedef struct _RAID_IO_ERROR {
	IO_ERROR_LOG_PACKET Packet;
	UCHAR PathId;
	UCHAR TargetId;
	UCHAR Lun;
	UCHAR _unused;
	ULONG ErrorCode;
	ULONG UniqueId;
} RAID_IO_ERROR, *PRAID_IO_ERROR;


PVOID
RaidAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
	IN PVOID IoObject
    );

//
// Memory allocated with RaidAllocatePool MUST be freed by RaidFreePool.
//

#define RaidFreePool ExFreePoolWithTag


#define VERIFY_DISPATCH_LEVEL()	ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);


extern LONG RaidUnloggedErrors;

#define RAID_ERROR_NO_MEMORY	(10)

ULONG
RaidScsiErrorToIoError(
	IN ULONG ErrorCode
	);


PVOID
RaidGetSystemAddressForMdl(
	IN PMDL,
	IN MM_PAGE_PRIORITY Priority,
	IN PVOID DeviceObject
	);
	
NTSTATUS
StorCreateScsiSymbolicLink(
	IN PUNICODE_STRING DeviceName,
	OUT PULONG PortNumber OPTIONAL
	);

NTSTATUS
RaidCreateDeviceName(
	IN PDEVICE_OBJECT DeviceObject,
	OUT PUNICODE_STRING DeviceName
	);

NTSTATUS
StorDuplicateUnicodeString(
    IN PUNICODE_STRING Source,
    IN PUNICODE_STRING Dest
    );

#define RtlDuplicateUnicodeString(X,Y,Z) (StorDuplicateUnicodeString(Y,Z))



VOID
INLINE
ASSERT_IO_OBJECT(
	IN PVOID IoObject
	)
{
	//
	// The IO object must be either a device object or a driver object.
	// NB: Should probably protect this with a read check as well. 
	//
	
	ASSERT (IoObject != NULL);
	ASSERT (((PDEVICE_OBJECT)IoObject)->Type == IO_TYPE_DEVICE ||
			((PDRIVER_OBJECT)IoObject)->Type == IO_TYPE_DRIVER);
}

BOOLEAN
StorCreateAnsiString(
	OUT PANSI_STRING AnsiString,
	IN PCSTR String,
	IN ULONG Length,
	IN POOL_TYPE PoolType,
	IN PVOID IoObject
	);

VOID
StorFreeAnsiString(
	IN PANSI_STRING String
	);

PIRP
StorBuildSynchronousScsiRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


//
// The time to pause, in seconds, after we issue a bus-reset to an adapter.
//

#define RAID_BUS_RESET_TIME	(4)

//++
//
// BOOLEAN
// C_MATCH_FIELD_OFFSET(
//     Type1,
//	   Type2,
//	   FieldName
//     );
//
// Routine Description:
//
//   Verify that a field is at the same offset in one type as another.
//   This is done at compile time, so may be a part of a compile-time
//   C_ASSERT.
//
// Return Values:
//
//    TRUE - if the field offsets match.
//
//    FALSE - if the field offsets do not match.
//
//-- 

#define C_MATCH_FIELD_OFFSET(Type1, Type2, FieldName)\
    (FIELD_OFFSET (Type1, FieldName) == FIELD_OFFSET (Type1, FieldName))


//
// Verify that the kernel's SCATTER_GATHER_ELEMENT is the same as the
// storport.h STOR_SCATTER_GATHER_ELEMENT.
//
	
C_ASSERT (C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_ELEMENT, SCATTER_GATHER_ELEMENT, PhysicalAddress) &&
          C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_ELEMENT, SCATTER_GATHER_ELEMENT, Length) &&
          C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_ELEMENT, SCATTER_GATHER_ELEMENT, Reserved));

//
// Verify that the kernel's SCATTER_GATHER_LIST is the same as the storport.h
// STOR_SCATTER_GATHER_LIST. We just cast the list from one type to the other,
// so the had better be the same.
//

C_ASSERT (C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_LIST, SCATTER_GATHER_LIST, NumberOfElements) &&
          C_MATCH_FIELD_OFFSET (STOR_SCATTER_GATHER_LIST, SCATTER_GATHER_LIST, List));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\port\wmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	wmi.h

Abstract:

	Definition of RAID_WMI object and operations.

Author:

	Matthew D Hendel (math) 20-Apr-2000

Revision History:

--*/

#pragma once

typedef struct _RAID_WMI {
	BOOLEAN Initialized;
} RAID_WMI, *PRAID_WMI;


NTSTATUS
RaCreateWmi(
	IN OUT PRAID_WMI Wmi
	);

NTSTATUS
RaInitializeWmi(
	IN PRAID_WMI Wmi
	);

NTSTATUS
RaDeleteWmi(
	IN PRAID_WMI Wmi
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\storlib\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for storlib library.

Author:

    Matthew D Hendel (math) 13-Feb-2001

Revision History:

--*/


#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>

#include "storlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\storlib\gateway.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	gateway.c

Abstract:

	Declaration of a gateway class that manages multiple interrelated
	sub-devices on a device.

	The IO gateway keeps track of elements queued to a device. The
	gateway is only necessary for device/driver pairs that have multiple
	independent device queues per physical device. A SCSI port driver,
	for example, can queue items on a per-logical-unit basis instead of
	per-HBA basis. The advantage of a per-logical-unit queue is that if a
	logical-unit becomes busy, requests for different logical units can
	be submitted to the adapter while the first logical unit is frozen.

	The gateway object is the object that coordinates the communication
	to the physical HBA.

						 ---
	 -------------		| H |
	| LUN 1 Queue | --> | B |
	 -------------		| A |
						|   |      ----------
	 -------------		| G |     | 	     |
	| LUN 2 Queue | -->	| a | --> | HBA  ----
	 -------------		| t |     |     |
						| e |      ------
	 -------------		| w |
	| LUN 1 Queue | -->	| a |
	 -------------		| y |
						 ---

	The gateway keeps track of whether the HBA is busy or frozen, how
	many outstanding requests are on the HBA, and, when the HBA is busy,
	the algorithm it uses to clear it's busy state.

Author:

	Matthew D Hendel (math) 15-June-2000

Revision History:

--*/

#include "precomp.h"


INLINE
VOID
ASSERT_GATEWAY(
	IN PSTOR_IO_GATEWAY Gateway
	)
{
#if DBG
	ASSERT (Gateway->BusyRoutine != NULL);
	ASSERT (Gateway->BusyCount >= 0);
	ASSERT (Gateway->PauseCount >= 0);
#endif
}

VOID
StorCreateIoGateway(
	IN PSTOR_IO_GATEWAY Gateway,
	IN PSTOR_IO_GATEWAY_BUSY_ROUTINE BusyRoutine,
	IN PVOID BusyContext
    )
/*++

Routine Description:

	Create an IO gateway.

Arguments:

	Gateway - IO Gateway to create.

	BusyAlgorithm - Description of the algorithm to use and associated
			parameters when the gatway is busy.

Return Value:

	None.

--*/
{
	ASSERT (BusyRoutine != NULL);
	
    RtlZeroMemory (Gateway, sizeof (STOR_IO_GATEWAY));

    //
    // The initial high and low water marks are somewhat irrelevant since
    // we will define these when we get busied.
    //
    
    Gateway->HighWaterMark = MAXLONG;
    Gateway->LowWaterMark = MAXLONG;

	Gateway->BusyRoutine = BusyRoutine;
	Gateway->BusyContext = BusyContext;
	
    KeInitializeSpinLock (&Gateway->Lock);
}


BOOLEAN
StorSubmitIoGatewayItem(
	IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

	Attempt to submit an item to the gateway.

Arguments:

	Gateway - Gateway to submit the item to.

Return Value:

	TRUE - If the item can be submitted to the underlying hardware.

	FALSE - If the underlying hardware is currently busy with other
			requests and the request should be held until the hardware is
			ready to process more requets.

--*/
{
    BOOLEAN Ready;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // PERF NOTE: This is the only adapter-wide lock aquisition done
    // for an IO. Therefore, we can suppose it is the hottest lock
    // in raidport (this remains to be seen from performance data).
    // We should seriously investigate a way to either eliminate this
    // lock or to turn it into a series of interlocked operations.
    // Do not do any significant processing while this lock is held.
    //
    
    KeAcquireInStackQueuedSpinLockAtDpcLevel (&Gateway->Lock, &LockHandle);

	//
	// If the gateway is busy or paused, do not submit it.
	//
	
    if (Gateway->BusyCount > 0 ||
		Gateway->PauseCount > 0 ||
        Gateway->Outstanding >= Gateway->HighWaterMark) {

        Ready = FALSE;

    } else {

        Gateway->Outstanding++;

        if (Gateway->Outstanding >= Gateway->HighWaterMark) {
            Gateway->BusyCount = TRUE;
        }
        
        Ready = TRUE;
    }

    KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);

    return Ready;
}



BOOLEAN
StorIsIoGatewayBusy(
	IN PSTOR_IO_GATEWAY Gateway
	)
{
	return (Gateway->BusyCount >= 1);
}

BOOLEAN
StorRemoveIoGatewayItem(
    IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

    Notify the gateway that an item has been completed.

Arguments:

    Gateway - Gateway to submit notification to.

Return Value:

    TRUE -  If the completion of this item transitions the gateway from a
		    busy state to a non-busy state. In this case, the unit queues
		    that submit items to the gateway need to be restarted.

    FALSE - If this completion did not change the busy state of the
			gateway.

--*/
{
    BOOLEAN Restart;
    KLOCK_QUEUE_HANDLE LockHandle;

    //
    // PERF NOTE: This is the only adapter-wide lock used by the system
    // in the IO path. See perf note in RaidAdapterGatewaySubmitItem.
    //
    
    KeAcquireInStackQueuedSpinLockAtDpcLevel (&Gateway->Lock, &LockHandle);
    
    Gateway->Outstanding--;
    ASSERT (Gateway->Outstanding >= 0);

    if ((Gateway->BusyCount > 0) &&
		(Gateway->Outstanding <= Gateway->LowWaterMark)) {

		Gateway->BusyCount = FALSE;
		Restart = TRUE; // (Gateway->BusyCount == 0) ? TRUE : FALSE;

    } else {

        Restart = FALSE;
    }

    KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);

    return Restart;
}

VOID
StorBusyIoGateway(
    IN PSTOR_IO_GATEWAY Gateway
    )
/*++

Routine Description:

	Place the gateway into the busy state. The gateway will stay busy
	until the number of requests has drained to a specific level.

Arguments:

	Gateway - The gateway to make busy.

Return Value:

	None.

--*/
{
    //
    // The adapter MUST have some outstanding requests if it's claiming
    // to be busy.
    //
    
	//
	// Invoke the supplied busy routine to modify the high/low-water marks.
	//

	if (Gateway->BusyCount) {
		return ;
	}
	
	Gateway->BusyRoutine (Gateway->BusyContext,
						  Gateway->Outstanding - 1,
						  &Gateway->HighWaterMark,
						  &Gateway->LowWaterMark);
							
	Gateway->BusyCount = TRUE;
}

VOID
StorPauseIoGateway(
	IN PSTOR_IO_GATEWAY Gateway
	)
{
    KLOCK_QUEUE_HANDLE LockHandle;
    
    //
    // PERF NOTE: This is the only adapter-wide lock used by the system
    // in the IO path. See perf note in RaidAdapterGatewaySubmitItem.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel (&Gateway->Lock, &LockHandle);
	Gateway->PauseCount++;
    KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);
	
}


VOID
StorResumeIoGateway(
	IN OUT PSTOR_IO_GATEWAY Gateway
	)
{
    KLOCK_QUEUE_HANDLE LockHandle;
    
    //
    // PERF NOTE: This is the only adapter-wide lock used by the system
    // in the IO path. See perf note in RaidAdapterGatewaySubmitItem.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel (&Gateway->Lock, &LockHandle);
	Gateway->PauseCount--;
    KeReleaseInStackQueuedSpinLockFromDpcLevel (&LockHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\storlib\dict.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dict.c

Abstract:

    This module implements a dictionary package. A dictionary is a
    generic mapping of an arbitrary domain to an arbitrary range.

    This implementation uses a hash-table to give constant time insert
    and delete access to the elements in the table, assuming the table is
    relativly close in size to the number of elements in the table.

Author:

    Matthew D Hendel (math) 9-Feb-2001

Revision History:

--*/

#include "precomp.h"

#define DICT_TAG    ('tciD')

#ifdef ExAllocatePool
#undef ExAllocatePool
#define ExAllocatePool(Type, Size) ExAllocatePoolWithTag(Type, Size, DICT_TAG)
#endif

#ifdef ExFreePool
#undef ExFreePool
#define ExFreePool(Type) ExFreePoolWithTag (Type, DICT_TAG)
#endif


NTSTATUS
StorCreateDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN ULONG EntryCount,
    IN POOL_TYPE PoolType,
    IN STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine,
    IN STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareKeyRoutine, OPTIONAL
    IN STOR_DICTIONARY_HASH_KEY_ROUTINE HashKeyRoutine OPTIONAL
    )
/*++

Routine Description:

    Initialize a dictionary object.

Arguments:

    Dictionary - Supplies the dictionary object to initialize.

    EntryCount - Supplies the initial number of empty slots in the dictioanry
        table. This number can increase via a call to StorSetElementCount.

    PoolType - Pool type of memory to be used.

    GetKeyRoutine - User-supplied routine to get a key from a specific
        element.

    CompareKeyRoutine - User-supplied routine to compare the keys of
        two elements. If this routine is not supplied, the default
        comparison will be used which assumes the values of the keys
        are ULONGs.

    HashKeyRoutine - User-supplied routine to has the key to a ULONG.
        If this routine is not supplied, the default has routine
        merely returns the value of the key as a ULONG.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    PLIST_ENTRY Entries;

    Dictionary->MaxEntryCount = EntryCount;
    Dictionary->EntryCount = 0;
    Dictionary->PoolType = PoolType;
    Dictionary->GetKeyRoutine = GetKeyRoutine;

    if (CompareKeyRoutine != NULL) {
        Dictionary->CompareKeyRoutine = CompareKeyRoutine;
    } else {
        Dictionary->CompareKeyRoutine = StorCompareUlongKey;
    }

    if (HashKeyRoutine != NULL) {
        Dictionary->HashKeyRoutine = HashKeyRoutine;
    } else {
        Dictionary->HashKeyRoutine = StorHashUlongKey;
    }

    Entries = ExAllocatePool (PoolType,
                              EntryCount * sizeof (LIST_ENTRY));

    if (Entries == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the table of lists.
    //
    
    for (i = 0; i < EntryCount; i++) {
        InitializeListHead (&Entries[i]);
    }
    
    Dictionary->Entries = Entries;

    return STATUS_SUCCESS;
}

NTSTATUS
StorDeleteDictionary(
    IN PSTOR_DICTIONARY Dictionary
    )
/*++

Routine Description:

    Delete the dictionary and all resources held by the dictionary.

    NB: This routine does not delete all of the individual elements from
    the dictionary -- it can't.  You should delete the elements from the
    dictionary before calling this routine.

Arguments:

    Dictionary - Supplies the dictinoary to delete.

Return Value:

    NTSTATUS code.

--*/
{
    if (Dictionary->EntryCount != 0) {
        ASSERT (FALSE);
        //
        //NB: should we define a new NTSTATUS value for
        //STATUS_NOT_EMPTY condition?
        //
        return STATUS_DIRECTORY_NOT_EMPTY;
    }

    ASSERT (Dictionary->Entries != NULL);
    ExFreePool (Dictionary->Entries);

    return STATUS_SUCCESS;
}

NTSTATUS
StorInsertDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
/*++

Routine Description:

    Insert an entry into the dictionary.

Arguments:

    Dictionary - Supplies the dictionary to insert into.
    
    Entry - Supplies the entry to insert.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Index;
    PLIST_ENTRY NextEntry;
    PLIST_ENTRY ListHead;
    LONG Comparison;
    STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine;
    STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareRoutine;
    STOR_DICTIONARY_HASH_KEY_ROUTINE HashRoutine;


    GetKeyRoutine = Dictionary->GetKeyRoutine;
    CompareRoutine = Dictionary->CompareKeyRoutine;
    HashRoutine = Dictionary->HashKeyRoutine;
    
    Index = (HashRoutine (GetKeyRoutine (Entry)) % Dictionary->MaxEntryCount);
    ListHead = &Dictionary->Entries[Index];

    //
    // Otherwise, walk the list searching for the place to insert the entry.
    //
    
    for (NextEntry = ListHead->Flink;
         NextEntry != ListHead;
         NextEntry = NextEntry->Flink) {

        Comparison = CompareRoutine (GetKeyRoutine (NextEntry),
                                     GetKeyRoutine (Entry));

        if (Comparison == 0) {

            return STATUS_DUPLICATE_OBJECTID;

        } else if (Comparison < 0) {

            //
            // Insert the entry directly before this entry.


            Entry->Flink = NextEntry;
            Entry->Blink = NextEntry->Blink;
            Entry->Flink->Blink = Entry;
            Entry->Blink->Flink = Entry;

            ASSERT (Entry->Flink->Blink == Entry);
            ASSERT (Entry->Blink->Flink == Entry);

#if DBG
            for (NextEntry = ListHead->Flink;
                 NextEntry != ListHead;
                 NextEntry = NextEntry->Flink) {

                 NOTHING;
            }
#endif

            Dictionary->EntryCount++;
            return STATUS_SUCCESS;

        } else {

            //
            // Continue searching
            //

            ASSERT (Comparison > 0);
        }
    }

    //
    // We'll only exit the loop if there isn't a entry less than the
    // one we're inserting. The list is either empty, or all of the
    // entries in the list are less than the one we're inserting.
    // In either case, the correct action is to add and entry to the
    // end of the list.
    //
    
    Dictionary->EntryCount++;
    InsertTailList (ListHead, Entry);

    return STATUS_SUCCESS;
}
    
        
NTSTATUS
StorFindDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PVOID Key,
    OUT PSTOR_DICTIONARY_ENTRY* EntryBuffer OPTIONAL
    )
/*++

Routine Description:

    Find an entry in the dictionary and, optionally, retun the found
    entry.

Arguments:

    Dictionary - Supplies the dictionary to search through.

    Key - Supplies the key of the entry to search for.

    EntryBuffer - Supplies an optional buffer where the entry will be copied
            if found.

Return Value:

    STATUS_NOT_FOUND - If the entry could not be found.

    STATUS_SUCCESS - If the entry was successfully found.

    Other NTSTATUS code - For other errors.

--*/
{
    NTSTATUS Status;
    LONG Comparison;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    STOR_DICTIONARY_GET_KEY_ROUTINE GetKeyRoutine;
    STOR_DICTIONARY_COMPARE_KEY_ROUTINE CompareRoutine;
    STOR_DICTIONARY_HASH_KEY_ROUTINE HashRoutine;

    GetKeyRoutine = Dictionary->GetKeyRoutine;
    CompareRoutine = Dictionary->CompareKeyRoutine;
    HashRoutine = Dictionary->HashKeyRoutine;
    
    Index = HashRoutine (Key) % Dictionary->MaxEntryCount;
    ListHead = &Dictionary->Entries[Index];

    Status = STATUS_NOT_FOUND;

    for (NextEntry = ListHead->Flink;
         NextEntry != ListHead;
         NextEntry = NextEntry->Flink) {

        Comparison = CompareRoutine (GetKeyRoutine (NextEntry), Key);

        if (Comparison == 0) {

            //
            // Found it.
            //

            Status = STATUS_SUCCESS;
            
            if (EntryBuffer) {
                *EntryBuffer = NextEntry;
            }
            
            break;

        } else if (Comparison < 0) {

            //
            // Done searching
            //
            
            Status = STATUS_NOT_FOUND;

            if (EntryBuffer) {
                *EntryBuffer = NULL;
            }
            break;

        } else {

            //
            // Continue searching
            //

            ASSERT (Comparison > 0);
        }
    }

    return Status;

}

NTSTATUS
StorRemoveDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PVOID Key,
    OUT PSTOR_DICTIONARY_ENTRY* EntryBuffer OPTIONAL
    )
/*++

Routine Description:

    Remove an entry from the dictionary.

Arguments:

    Dictioanry - Supplies the dictionary to remove the entry from.

    Key - Supplies the key used to identify the entry.

    EntryBuffer - Optional parameter that supplies a buffer to copy the
            removed entry into.

Return Value:

    STATUS_NOT_FOUND - If the entry was not found.

    STATUS_SUCCESS - If the entry was successfully removed.

    Other NTSTATUS code - other error condition.

--*/
{
    NTSTATUS Status;
    PSTOR_DICTIONARY_ENTRY Entry;

    Entry = NULL;
    Status = StorFindDictionary (Dictionary, Key, &Entry);

    if (NT_SUCCESS (Status)) {
        RemoveEntryList (Entry);
        Dictionary->EntryCount--;
        
    }

    if (EntryBuffer) {
        *EntryBuffer = Entry;
    }
    
    return Status;
}

NTSTATUS
StorAdjustDictionarySize(
    IN PSTOR_DICTIONARY Dictionary,
    IN ULONG MaxEntryCount
    )
/*++

Routine Description:

    Adjust the number of bins in the underlying hash table. Having the
    number of bins relativly large compared to the number of entries in
    the table gives much better performance.

    Adjusting the size of the dictionary is an expensive operation. It
    takes about the same amount of time to adjust the dictionary size as
    it does to delete the dictionary and create a new one.

Arguments:

    Dictionary - Supplies the dictionary whose size is to be adjusted.

    MaxEntryCount - Supplies the new maximum entry count. This can be
            greater or less than the current entry count. (It can
            actually be the same as the current entry count, but
            doing so merely wastes time.)

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG i;
    ULONG OldMaxEntryCount;
    PLIST_ENTRY OldEntries;
    PLIST_ENTRY Entries;
    PLIST_ENTRY Head;
    PLIST_ENTRY Entry;


    OldEntries = Dictionary->Entries;
    OldMaxEntryCount = Dictionary->MaxEntryCount;

    Entries = ExAllocatePool (Dictionary->PoolType,
                              sizeof (LIST_ENTRY) * MaxEntryCount);

    if (Entries == NULL) {
        return STATUS_NO_MEMORY;
    }

    for (i = 0; i < MaxEntryCount; i++) {
        InitializeListHead (&Entries[i]);
    }

    //
    // Save the old dictionary
    //
    
    OldEntries = Dictionary->Entries;
    OldMaxEntryCount = Dictionary->MaxEntryCount;

    //
    // Replace it with the new, empty one
    //
    
    Dictionary->Entries = Entries;
    Dictionary->MaxEntryCount = MaxEntryCount;

    //
    // Remove all the old entries, placing them in the new dictioanry
    //
    
    for (i = 0; i < OldMaxEntryCount; i++) {
        Head = &OldEntries[i];
        while (!IsListEmpty (Head)) {
            Entry = RemoveHeadList (Head);
            Status = StorInsertDictionary (Dictionary, Entry);
            ASSERT (NT_SUCCESS (Status));
        }
    }

    ExFreePool (Entries);

    return STATUS_SUCCESS;
}


VOID
StorEnumerateDictionary(
    IN PSTOR_DICTIONARY Dictionary,
    IN PSTOR_DICTIONARY_ENUMERATOR Enumerator
    )
/*++

Routine Description:

    Enumerate the entries in the dictionary. 

Arguments:

    Dictionary - Supplies the dictionary to enumerate.

    Enumerator - Supplies an enumerator used to enumerate the dictionary.
        To halt the enumeration, the enumerator should return FALSE.

Caveats:

    The entries are listed in ARBITRARY ORDER. This is not an ordered
    enumeration.

    Multiple enumerations of the list can happen at the same time. But
    the list CANNOT BE MODIFIED while it is being enumerated.

Return Value:

    None.
    
--*/
{
    ULONG i;
    PLIST_ENTRY NextEntry;
    PLIST_ENTRY ListHead;
    BOOLEAN Continue;

    REVIEW();

    for (i = 0; i < Dictionary->MaxEntryCount; i++) {
        ListHead = &Dictionary->Entries[i];
        for (NextEntry = ListHead->Flink;
             NextEntry != ListHead;
             NextEntry = NextEntry->Flink) {
            Continue = Enumerator->EnumerateEntry (Enumerator, NextEntry);
            if (!Continue) {
                return ;
            }
        }
    }
}

LONG
StorCompareUlongKey(
    IN PVOID Key1,
    IN PVOID Key2
    )
/*++

Routine Description:

    Compare key routine for ULONG keys.

Arguments:

    Key1 - First key to compare.

    Key2 - Second key to compare.

Return Value:

    -1 - if Key1 < Key2

     0 - if Key1 == Key2

     1 - if Key1 > Key2

--*/
{
    if (Key1 < Key2) {
        return -1;
    } else if (Key1 == Key2) {
        return 0;
    } else {
        return 1;
    }
}

ULONG
StorHashUlongKey(
    IN PVOID Key
    )
/*++

Routine Description:

    Hash routine for ULONG keys.

Arguments:

    Key - Supplies the key to hash.

Return Value:

    Hash code for the key.

--*/
{
    return (ULONG)(ULONG_PTR)Key;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\storlib\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debugging routines exported by the STOR library.

Author:

    Matthew D Hendel (math) 29-Apr-2000

Revision History:

--*/

#include "precomp.h"

//#include "ntrtl.h"

#if DBG

BOOLEAN StorQuiet = FALSE;
ULONG StorComponentId = -1;
PCSTR StorDebugPrefix = "STOR: ";


//
// NB: These should come from ntrtl.h
//

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCSTR Format,
    va_list arglist
    );

NTSYSAPI
ULONG
NTAPI
DbgPrompt(
    PCH Prompt,
    PCH Response,
    ULONG MaximumResponseLength
    );

BOOLEAN
StorAssertHelper(
    PCHAR Expression,
    PCHAR File,
    ULONG Line,
    PBOOLEAN Ignore
    )
{
    CHAR Response[2];

    DebugPrint (("*** Assertion failed: %s\n", Expression));
    DebugPrint (("*** Source File: %s, line %ld\n\n", File, Line));

    if (*Ignore == TRUE) {
        DebugPrint (("Ignored\n"));
        return FALSE;
    }

    for (;;) {

        //
        // The following line will print the prefix, not just the space.
        //
        DebugPrint ((" "));
        DbgPrompt( "(B)reak, (S)kip (I)gnore (bsi)? ",
                   Response,
                   sizeof (Response) );

        switch (tolower (Response[0])) {

            case 'b':
                return TRUE;

            case 'i':
                *Ignore = TRUE;
                return FALSE;

            case 's':
                return FALSE;
        }
    }
}


VOID
StorSetDebugPrefixAndId(
    IN PCSTR Prefix,
    IN ULONG ComponentId
    )
/*++

Routine Description:

    Set the default debug prefix to something other than "STOR: ".

Arguments:

    Prefix - Supplies the prefix. The pointer to the prefix is saved
            preserved, so the prefix memory cannot be paged deallocated.
            Generally, using a static string here is best.

    ComponentId -

Return Value:

    None.

--*/
{
    StorDebugPrefix = Prefix;
    StorComponentId = ComponentId;
}


VOID
StorDebugPrint(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);

    vDbgPrintExWithPrefix ((PSTR)StorDebugPrefix,
                           StorComponentId,
                           DPFLTR_ERROR_LEVEL,
                           Format,
                           ap);

    va_end (ap);
}

VOID
StorDebugTrace(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);

    if (!StorQuiet) {
        vDbgPrintExWithPrefix ((PSTR)StorDebugPrefix,
                               StorComponentId,
                               DPFLTR_TRACE_LEVEL,
                               Format,
                               ap);
    }

    va_end (ap);
}


VOID
StorDebugWarn(
    IN PCSTR Format,
    ...
    )
{
    va_list ap;

    va_start (ap, Format);

    if (!StorQuiet) {
        vDbgPrintExWithPrefix ((PSTR)StorDebugPrefix,
                               StorComponentId,
                               DPFLTR_WARNING_LEVEL,
                               Format,
                               ap);
    }

    va_end (ap);
}

#endif // DBG


//
// The following are support functions for compiler runtime checks.
//


#if defined (_RTC) || (DBG == 1)

typedef struct _RTC_vardesc {
    int addr;
    int size;
    char *name;
} _RTC_vardesc;

typedef struct _RTC_framedesc {
    int varCount;
    _RTC_vardesc *variables;
} _RTC_framedesc;



VOID
__cdecl
_RTC_InitBase(
    VOID
    )
{
}

VOID
__cdecl
_RTC_Shutdown(
    VOID
    )
{
}

VOID
#if defined (_X86_)
__declspec(naked)
#endif // _X86_
__cdecl
_RTC_CheckEsp(
    )
{

#if defined (_X86_)

    __asm {
        jne esperror    ;
        ret

    esperror:
        ; function prolog

        push ebp
        mov ebp, esp
        sub esp, __LOCAL_SIZE

        push eax        ; save the old return value
        push edx

        push ebx
        push esi
        push edi
    }

    DebugPrint (("*** Callstack Check failure at %p\n", _ReturnAddress()));
    KdBreakPoint();

    __asm {
        ; function epilog

        pop edi
        pop esi
        pop ebx

        pop edx         ; restore the old return value
        pop eax

        mov esp, ebp
        pop ebp
        ret
    }

#endif

}


VOID
FASTCALL
_RTC_CheckStackVars(
    PVOID frame,
    _RTC_framedesc *v
    )
{
    int i;

    for (i = 0; i < v->varCount; i++) {
        int *head = (int *)(((char *)frame) + v->variables[i].addr + v->variables[i].size);
        int *tail = (int *)(((char *)frame) + v->variables[i].addr - sizeof(int));

        if (*tail != 0xcccccccc || *head != 0xcccccccc) {

            DebugPrint(("*** RTC Failure %p: stack corruption near %p (%s)\n",
                     _ReturnAddress(),
                     v->variables[i].addr + (ULONG_PTR)frame,
                     v->variables[i].name));
            KdBreakPoint();
        }
    }
}

VOID
__cdecl
_RTC_UninitUse(
    IN PCSTR varname
    )
{
    DebugPrint(("\n*** RTC Failure %p: uninitialized variable %s.\n",
             _ReturnAddress(),
             varname));
    KdBreakPoint();
}

#endif // _RTC || DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\storlib\tdict.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define POOL_TYPE ULONG

#include "defs.h"
#include "dict.h"


typedef struct _TEST_ENTRY {
    ULONG Unused;
    ULONG Key;
    STOR_DICTIONARY_ENTRY Link;
} TEST_ENTRY, *PTEST_ENTRY;

PVOID
WINAPI
TestGetKey(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    return (PVOID)(CONTAINING_RECORD (Entry, TEST_ENTRY, Link)->Key);
}

void __cdecl main()
{
    STOR_DICTIONARY Dict;
    PTEST_ENTRY Entry;
    LONG i;
    NTSTATUS Status;
    PSTOR_DICTIONARY_ENTRY Link;

    Status = StorCreateDictionary (&Dict,
                                   1,
                                   0,
                                   TestGetKey,
                                   NULL,
                                   NULL);

    if (!NT_SUCCESS (Status)) {
        printf ("Failed to create dictionary!\n");
        exit (1);
    }

    //
    // Insert 1000 elements, verifying they were successfully
    // inserted.
    //
    
    for (i = 0; i < 1000; i++) {
        Entry = malloc (sizeof (TEST_ENTRY));
        RtlZeroMemory (Entry, sizeof (TEST_ENTRY));

        Entry->Key = i;
        Status = StorInsertDictionary (&Dict, &Entry->Link);
        ASSERT (Status == STATUS_SUCCESS);
        
        Status = StorFindDictionary (&Dict, (PVOID)i, NULL);
        ASSERT (Status == STATUS_SUCCESS);
    }

    //
    // Test that they we cannot insert any more items with the same key.
    //
    
    for (i = 0; i < 1000; i++) {
        Entry = malloc (sizeof (TEST_ENTRY));
        RtlZeroMemory (Entry, sizeof (TEST_ENTRY));

        Entry->Key = i;
        Status = StorInsertDictionary (&Dict, &Entry->Link);

        ASSERT (!NT_SUCCESS (Status));

        free (Entry);
    }

    //
    // Remove all items, one at a time.
    //
    
    for (i = 999; i >= 0; i--) {

        Status = StorRemoveDictionary (&Dict, (PVOID)i, &Link);
        ASSERT (Status == STATUS_SUCCESS);
        Entry = CONTAINING_RECORD (Link, TEST_ENTRY, Link);
        ASSERT (Entry->Key == i);
        free (Entry);
    }

    //
    // Verify that there are no more items.
    //
    
    ASSERT (StorGetDictionaryCount (&Dict) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\test\exqueue.c ===
#include "raidport.h"
#include "..\port\exqueue.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\test\tq.c ===
//
// Test/simulation program for the extended device queue
//

#include "raidport.h"
#include "exqueue.h"

#define	SECONDS (1000)

typedef struct _TQ_ITEM {
	ULONG Thread;
	ULONG64 Data;
	ULONG64 Sequence;
	KDEVICE_QUEUE_ENTRY DeviceEntry;
	LIST_ENTRY DpcEntry;
} TQ_ITEM, *PTQ_ITEM;


typedef struct _DPC_QUEUE {
	HANDLE Available;
	HANDLE Mutex;
	LIST_ENTRY Queue;
	ULONG Count;
} DPC_QUEUE, *PDPC_QUEUE;


BOOL Verbose = FALSE;
BOOL Cerbose = TRUE;
DPC_QUEUE DpcQueue;
EXTENDED_DEVICE_QUEUE DeviceQueue;
BOOLEAN Pause = FALSE;
BOOLEAN PauseProducer = FALSE;
ULONG64 GlobalSequence = 0;
DWORD Owner = 0;
BOOL Available = FALSE;


VOID
GetNext(
	OUT PULONG64 Sequence,
	OUT PULONG Data
	)
{
	*Sequence = ++GlobalSequence;
	*Data = (ULONG)rand();
}

#pragma warning (disable:4715)

BOOL
WINAPI
UpdateThread(
	PVOID Unused
	)
{
	for (;;) {

		while (Pause) {
			Sleep (500);
		}
		
		printf ("Seq: %I64d, dev %d bypass %d dpc %d                       \r",
				 GlobalSequence,
				 DeviceQueue.DeviceRequests,
				 DeviceQueue.ByPassRequests,
				 DpcQueue.Count);
		Sleep (2000);
	}

	return FALSE;
}

VOID
CreateDpcQueue(
	PDPC_QUEUE DpcQueue
	)
{
	DpcQueue->Available = CreateEvent (NULL, FALSE, FALSE, NULL);
	DpcQueue->Mutex = CreateMutex (NULL, FALSE, NULL);
	InitializeListHead (&DpcQueue->Queue);
	DpcQueue->Count = 0;
}


VOID
InsertDpcItem(
	IN PDPC_QUEUE DpcQueue,
	IN PLIST_ENTRY Entry
	)
{
	WaitForSingleObject (DpcQueue->Mutex, INFINITE);
	InsertTailList (&DpcQueue->Queue, Entry);
	DpcQueue->Count++;
	Owner = GetCurrentThreadId ();
	Available = TRUE;
	SetEvent (DpcQueue->Available);
	ReleaseMutex (DpcQueue->Mutex);
}

PLIST_ENTRY
RemoveDpcItem(
	IN PDPC_QUEUE DpcQueue
	)
{
	PLIST_ENTRY Entry;
	HANDLE Tuple[2];

	Tuple[0] = DpcQueue->Mutex;
	Tuple[1] = DpcQueue->Available;

	WaitForMultipleObjects (2, Tuple, TRUE, INFINITE);
	Available = FALSE;
	Owner = GetCurrentThreadId ();
	ASSERT (!IsListEmpty (&DpcQueue->Queue));
	Entry = RemoveHeadList (&DpcQueue->Queue);
	DpcQueue->Count--;
	if (!IsListEmpty (&DpcQueue->Queue)) {
		Available = TRUE;
		SetEvent (DpcQueue->Available);
	}
	ReleaseMutex (DpcQueue->Mutex);

	return Entry;
}


BOOL
WINAPI
ProducerThread(
	PVOID Unused
	)
{
	BOOLEAN Inserted;
	PTQ_ITEM Item;
	ULONG Data;
	ULONG64 Sequence;

	srand (GetCurrentThreadId());
	
	for (;;) {

		Sleep (10);

		while (Pause) {
			Sleep (100);
		}

		while (PauseProducer) {
			Sleep (100);
		}
			
		Item = malloc (sizeof (TQ_ITEM));
		ZeroMemory (Item, sizeof (*Item));
		
		GetNext (&Sequence, &Data);
		Item->Thread = GetCurrentThreadId ();
		Item->Sequence = Sequence;
		Item->Data = Data;

		Inserted = RaidInsertExDeviceQueue (&DeviceQueue,
										    &Item->DeviceEntry,
										    FALSE,
											(ULONG)Item->Data);

		if (!Inserted) {

			if (Verbose) {
				printf ("started %x.%I64d\n", Item->Thread, Item->Data);
			}

			InsertDpcItem (&DpcQueue, &Item->DpcEntry);

		} else {
			if (Verbose) {
				printf ("queued %x.%I64d\n", Item->Thread, Item->Data);
			}
		}
	}

	return FALSE;
}

BOOL
WINAPI
ProducerThread100(
	PVOID Unused
	)
{
	BOOLEAN Inserted;
	PTQ_ITEM Item;
	ULONG Data;
	ULONG64 Sequence;

	srand (GetCurrentThreadId());
	
	for (;;) {

		Sleep (0);

		while (Pause) {
			Sleep (100);
		}

		while (PauseProducer) {
			Sleep (100);
		}
			
		Item = malloc (sizeof (TQ_ITEM));
		ZeroMemory (Item, sizeof (*Item));
		
		GetNext (&Sequence, &Data);
		Item->Thread = GetCurrentThreadId ();
		Item->Sequence = Sequence;
		Item->Data = 100;

		Inserted = RaidInsertExDeviceQueue (&DeviceQueue,
										    &Item->DeviceEntry,
										    FALSE,
											(ULONG)Item->Data);

		if (!Inserted) {

			if (Verbose) {
				printf ("started %x.%I64d\n", Item->Thread, Item->Data);
			}

			InsertDpcItem (&DpcQueue, &Item->DpcEntry);

		} else {
			if (Verbose) {
				printf ("queued %x.%I64d\n", Item->Thread, Item->Data);
			}
		}
	}

	return FALSE;
}

BOOL
WINAPI
ErrorProducerThread(
	PVOID Unused
	)
{
	BOOLEAN Inserted;
	PTQ_ITEM Item;
	ULONG64 Sequence;
	ULONG Data;

	for (;;) {

		Sleep (500);
		
		while (Pause) {
			Sleep (10);
		}
			
		Item = malloc (sizeof (TQ_ITEM));
		ZeroMemory (Item, sizeof (*Item));

		GetNext (&Sequence, &Data);
		Item->Thread = GetCurrentThreadId ();
		Item->Sequence = Sequence;
		Item->Data = Data;
		
		Inserted = RaidInsertExDeviceQueue (&DeviceQueue,
										    &Item->DeviceEntry,
										    TRUE,
											(ULONG)Item->Data);

		if (!Inserted) {

			if (Verbose) {
				printf ("started %x.%I64d\n", Item->Thread, Item->Data);
			}

			InsertDpcItem (&DpcQueue, &Item->DpcEntry);

		} else {
			if (Verbose) {
				printf ("queued %x.%I64d\n", Item->Thread, Item->Data);
			}
		}
	}

	return FALSE;
}

VOID
DpcRoutine(
	IN PTQ_ITEM Item
	)
{
	BOOLEAN RestartQueue;
	PKDEVICE_QUEUE_ENTRY Entry;

	if (Verbose || Cerbose) {
		printf ("completed %x.%I64d\n", Item->Thread, Item->Data);
	}

	free (Item);

	Entry = RaidRemoveExDeviceQueue (&DeviceQueue, &RestartQueue);

	if (Entry) {
		Item = CONTAINING_RECORD (Entry, TQ_ITEM, DeviceEntry);
		InsertDpcItem (&DpcQueue, &Item->DpcEntry);
		if (Verbose) {
			printf ("dpc started %x.%I64d\n", Item->Thread, Item->Data);
		}

		//
		// NB: in the port driver, we actually only do this when necessary.
		// The only problem with doing this always is a speed issue, and
		// we're not measuring speed in the simulation program.
		//
		
		for (Entry = RaidNormalizeExDeviceQueue (&DeviceQueue);
			 Entry != NULL;
			 Entry = RaidNormalizeExDeviceQueue (&DeviceQueue)) {

			Item = CONTAINING_RECORD (Entry, TQ_ITEM, DeviceEntry);
			InsertDpcItem (&DpcQueue, &Item->DpcEntry);
		}
		
		
	}
}


BOOL
WINAPI
DpcThread(
	PVOID Unused
	)
{
	PLIST_ENTRY Entry;
	PTQ_ITEM Item;

#if 1
	SetThreadPriority (GetCurrentThread (),
					   THREAD_PRIORITY_ABOVE_NORMAL);
#endif

	for (;;) {

		while (Pause) {
			Sleep (10);
		}

		//
		// Wait for DPC queue to have an item in it
		//

		Entry = RemoveDpcItem (&DpcQueue);
		Item = CONTAINING_RECORD (Entry, TQ_ITEM, DpcEntry);

		DpcRoutine (Item);
	}

	return FALSE;
}

enum {
	NoControl = 0,
	FreezeQueue,
	ResumeQueue
};

volatile ULONG Control = NoControl;

BOOL
WINAPI
ControlThread(
	PVOID Unused
	)
{
	for (;;) {

		Sleep (500);

		switch (Control) {
			case FreezeQueue:
				RaidFreezeExDeviceQueue (&DeviceQueue);
				Control = NoControl;
				break;

			case ResumeQueue:
				RaidResumeExDeviceQueue (&DeviceQueue);
				Control = NoControl;
				break;

			case NoControl:
				break;

			default:
				ASSERT (FALSE);
		}
	}

	return FALSE;
}
	

BOOL
WINAPI
ControlHandler(
	DWORD Val
	)
{
	PLIST_ENTRY NextEntry;
	PTQ_ITEM Item;
	int ch;

	if (Val != CTRL_C_EVENT) {
		return FALSE;
	}

	Pause = TRUE;
	Sleep (1000);
	printf ("\n");

	do {
		printf ("tq> ");
		ch = getchar ();
		printf (" %c\n", ch);

		switch (tolower (ch)) {

			case 'd':

				printf ("Dump of DeviceQueue: %p\n", &DeviceQueue);
				printf ("    Depth %d\n", DeviceQueue.Depth);
				printf ("    Outstanding %d\n", DeviceQueue.OutstandingRequests);
				printf ("    Device %d\n", DeviceQueue.DeviceRequests);
				printf ("    ByPass %d\n", DeviceQueue.ByPassRequests);
				printf ("    Frozen %d\n", DeviceQueue.Frozen);
				break;

			case 'l':
				__try {

					ULONG Count;

					Count = 0;
					for ( NextEntry  = DeviceQueue.DeviceListHead.Flink;
						NextEntry != &DeviceQueue.DeviceListHead;
						NextEntry = NextEntry->Flink ) {
						Count++;

						Item = CONTAINING_RECORD (NextEntry, TQ_ITEM, DeviceEntry);
						printf ("    item %d.%I64d [seq=%d]\n",
								 Item->Thread,
								 Item->Data,
								 Item->Sequence);
					}

					printf ("DeviceList: %d entries\n", Count);
				}

				__except (EXCEPTION_EXECUTE_HANDLER) {
					printf ("ERROR: Inconsistent device list!\n");
				}
				break;

			case 'r':
				Control = ResumeQueue;
				break;

			case 'f':
				Control = FreezeQueue;
				break;

			case 'q':
				exit (0);
				break;

			case 'c':
			case 'g':
				break;

			case 'p':
				if (PauseProducer) {
					printf ("unpausing producers\n");
					PauseProducer = FALSE;
				} else {
					printf ("unpausing producers\n");
					PauseProducer = TRUE;
				}
				break;

			case 'v':
				if (Verbose) {
					Verbose = FALSE;
					printf ("verbose mode off\n");
				} else {
					Verbose = TRUE;
					printf ("verbose mode enabled\n");
				}

			case 'x': {
				ULONG NewDepth;
				printf ("depth> ");
				scanf ("%d", &NewDepth);
				RaidSetExDeviceQueueDepth (&DeviceQueue, NewDepth);
				printf ("stack depth set to %d\n", NewDepth);
				break;
			}

			case '?':
				printf ("    d - dump queue\n");
				printf ("    f - freeze queue\n");
				printf ("    r - resume queue\n");
				printf ("    p - toggle pause of producer threads\n");
				printf ("    u - resume producer threads\n");
				printf ("    g - go\n");
				printf ("    x - set stack depth to new value\n");
				printf ("    v - toggle verbose mode\n");
				printf ("    q - stop\n");
				break;
				
			default:
				printf ("unrecognized operation '%c'\n", ch);
		}

	} while (ch != 'c' && ch != 'g');
				

	Pause = FALSE;
	return TRUE;
}


VOID
__cdecl
main(
	)
{
	DWORD ThreadId;
	ULONG Depth;
	ULONG ProducerThreads;
	ULONG DpcThreads;
	ULONG i;
	SCHEDULING_ALGORITHM SchedulingAlgorithm;
	RAID_ADAPTER_QUEUE AdapterQueue;
	QUEUING_MODEL QueuingModel;

	//
	// Generic adapter queue.
	// 

	QueuingModel.Algorithm = BackOffFullQueue;
	QueuingModel.BackOff.HighWaterPercent = 120;
	QueuingModel.BackOff.LowWaterPercent = 40;

	RaidCreateAdapterQueue (&AdapterQueue, &QueuingModel);
	
	//
	// NB: these should all be parameters
	//
	
	Depth = 1;
	ProducerThreads = 8;
	DpcThreads = 1;
	SchedulingAlgorithm = CScanScheduling;

	printf ("DeviceQueue Test: Depth %d Producers %d DPC Threads %d\n",
			 Depth,
			 ProducerThreads,
			 DpcThreads);

	if (Verbose) {
		printf ("Verbose\n");
	}
	printf ("\n");
	
	CreateDpcQueue (&DpcQueue);
	RaidInitializeExDeviceQueue (&DeviceQueue,
								 &AdapterQueue,
								 Depth,
								 SchedulingAlgorithm);

	SetConsoleCtrlHandler (ControlHandler, TRUE);
	
	for (i = 0; i < DpcThreads; i++) {
		CreateThread (NULL,
					  0,
					  DpcThread,
					  0,
					  0,
					  &ThreadId);
	}
				  
	for (i = 0; i < ProducerThreads; i++) {

		CreateThread (NULL,
					  0,
					  ProducerThread,
					  0,
					  0,
					  &ThreadId);
	}

	CreateThread (NULL,
				  0,
				  ControlThread,
				  0,
				  0,
				  &ThreadId);


	CreateThread (NULL,
				 0,
				 ProducerThread100,
				 0,
				 0,
				 &ThreadId);
#if 0
	CreateThread (NULL,
				  0,
				  ErrorProducerThread,
				  0,
				  0,
				  &ThreadId);

	CreateThread (NULL,
				  0,
				  UpdateThread,
				  0,
				  0,
				  &ThreadId);
				 
#endif
	Sleep (INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\ae_init1.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** ae_init1.c
**
** for EISA initialization only
*/

#include "ascinc.h"

#if CC_INCLUDE_EISA

/* ----------------------------------------------------------------------
**  Product ID
**  0xC80 - 0x04
**  0xC81 - 0x50
**  0xC82 - 0x74 or 0x75
**  0xC83 - 0x01
**
** ------------------------------------------------------------------ */
ulong  AscGetEisaProductID(
          PortAddr iop_base
       )
{
       PortAddr  eisa_iop ;
       ushort    product_id_high, product_id_low ;
       ulong     product_id ;

       eisa_iop = ASC_GET_EISA_SLOT( iop_base ) | ASC_EISA_PID_IOP_MASK ;
       product_id_low = inpw( eisa_iop ) ;
       product_id_high = inpw( eisa_iop+2 ) ;
       product_id = ( ( ulong)product_id_high << 16 ) | ( ulong )product_id_low ;
       return( product_id ) ;
}

/* -----------------------------------------------------------------
** Description: search EISA host adapter
**
** - search starts with iop_base equals zero( 0 )
**
** return i/o port address found ( non-zero )
** return 0 if not found
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddrEISA(
            PortAddr iop_base
         )
{
       ulong  eisa_product_id ;

       if( iop_base == 0 )
       {
           iop_base = ASC_EISA_MIN_IOP_ADDR ;
       }/* if */
       else
       {
           if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
           if( ( iop_base & 0x0050 ) == 0x0050 )
           {
               iop_base += ASC_EISA_BIG_IOP_GAP ;  /* when it is 0zC50 */
           }/* if */
           else
           {
               iop_base += ASC_EISA_SMALL_IOP_GAP ; /* when it is 0zC30 */
           }/* else */
       }/* else */
       while( iop_base <= ASC_EISA_MAX_IOP_ADDR )
       {
/*
** search product id first
*/
            eisa_product_id = AscGetEisaProductID( iop_base ) ;
            if(
                 ( eisa_product_id == ASC_EISA_ID_740 )
              || ( eisa_product_id == ASC_EISA_ID_750 )
              )
            {
                if( AscFindSignature( iop_base ) )
                {
/*
** chip found, clear ID left in latch
** to clear, read any i/o port word that doesn't contain data 0x04c1
** iop_base plus four should do it
*/
                    inpw( iop_base+4 ) ;
                    return( iop_base ) ;
                }/* if */
            }/* if */
            if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
            if( ( iop_base & 0x0050 ) == 0x0050 )
            {
                iop_base += ASC_EISA_BIG_IOP_GAP ;
            }/* if */
            else
            {
                iop_base += ASC_EISA_SMALL_IOP_GAP ;
            }/* else */
       }/* while */
       return( 0 ) ;
}

#endif /* CC_INCLUDE_EISA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\wmidebug.c ===
/*++

Copyright (c) 1999 Microsoft, Inc

Module Name:

    wmi.c

Abstract:

    This is the common source code for WMI debugging support within a NT
    SCSI miniport. This code implements the WMI specific functionality that
    needed and is independent of the miniport that includes it. To include
    the wmi debugging code in a miniport, the miniport must do the following:
        
    1. Create a file (say wmi.c) that includes any headers needed by the
       the miniport and #define PHWDEVEXT to the name for its hardware device 
       extension. One of the headers needs to #define WMI_TEST_CODE to include
       wmi debug code in the build.
           
    2. Include the following before the hardware device extension structure:
        
#ifdef WMI_TEST_CODE

#define MAX_STRING 255

typedef struct
{
    BOOLEAN boolean;
    UCHAR uchar;
    USHORT ushort;
    ULONG ulong;
    ULONGLONG ulonglong;
    CHAR achar;
    SHORT ashort;
    LONG along;
    LONGLONG longlong;
    WCHAR datetime[25];
    USHORT stringlen;
    WCHAR string[MAX_STRING];
} EC1, *PEC1;

typedef struct
{
    BOOLEAN boolean[8];
    UCHAR uchar[8];
    USHORT ushort[4];
    ULONG ulong[2];
    ULONGLONG ulonglong;
    CHAR achar[8];
    SHORT ashort[4];
    LONG along[2];
    LONGLONG longlong;
    WCHAR datetime[25];
    USHORT stringlen;
    WCHAR string[MAX_STRING];
} EC2, *PEC2;

#define WMI_EVENT_BUFFER_SIZE (sizeof(EC2) + 0x40)
#endif
        
           
    3. Include the following within the hardware device extension structure:
        
#ifdef WMI_TEST_CODE    
    SCSI_WMILIB_CONTEXT WmiLibContext;

    ULONG Ec1Count;
    ULONG Ec1Length[4];
    ULONG Ec1ActualLength[4];
    EC1 Ec1[4];
    
    ULONG Ec2Count;
    ULONG Ec2Length[4];
    ULONG Ec2ActualLength[4];
    EC2 Ec2[4];

    UCHAR EventBuffer[WMI_EVENT_BUFFER_SIZE];
#endif

    4. Include the following in the HwDetect routine
#ifdef WMI_TEST_CODE    
    //
    // Enable and initialize WMI
    ConfigInfo->WmiDataProvider = TRUE;
    WmiInitialize(CardPtr);
#endif    

    5. Dispatch wmi srbs to WmiSrb().
        

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifdef WMI_TEST_CODE    


BOOLEAN WmiSampSetEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    );

BOOLEAN WmiSampSetEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    );



#define WmiSampDateTime L"19940525133015.000000-300"

#define Wmi_MofResourceName        L"MofResource"

#define WmiSampleClass1 0
#define WmiSampleClass2 1
#define WmiSampleClass3 2
#define WmiSampleClass4 3
#define WmiSampleClass5 4
#define WmiSampleClass6 5
#define WmiSampleClass7 6
#define WmiGetSetData   7
#define WmiFireEvent    8
#define WmiEventClass1  9
#define WmiEventClass2  10
#define WmiEventClass3  11
#define WmiEventClass4  12
#define WmiEventClass5  13
#define WmiEventClass6  14
#define WmiEventClass7  15

GUID WmiSampleClass1Guid =         { 0x15d851f1, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass2Guid =         { 0x15d851f2, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass3Guid =         { 0x15d851f3, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass4Guid =         { 0x15d851f4, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass5Guid =         { 0x15d851f5, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass6Guid =         { 0x15d851f6, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiSampleClass7Guid =         { 0x15d851f7, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiGetSetDataGuid =         { 0x15d851f8, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiFireEventGuid =         { 0x15d851f9, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass1Guid =         { 0x15d851e1, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass2Guid =         { 0x15d851e2, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass3Guid =         { 0x15d851e3, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass4Guid =         { 0x15d851e4, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass5Guid =         { 0x15d851e5, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass6Guid =         { 0x15d851e6, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };
GUID WmiEventClass7Guid =         { 0x15d851e7, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 };

SCSIWMIGUIDREGINFO GuidList[] = 
{
    {
        &WmiSampleClass1Guid,
        1,
        0
    },

    {
        &WmiSampleClass2Guid,
        1,
        0
    },

    {
        &WmiSampleClass3Guid,
        1,
        0
    },

    {
        &WmiSampleClass4Guid,
        1,
        0
    },

    {
        &WmiSampleClass5Guid,
        1,
        0
    },

    {
        &WmiSampleClass6Guid,
        1,
        0
    },

    {
        &WmiSampleClass7Guid,
        1,
        0
    },

    {
        &WmiGetSetDataGuid,
        1,
        0
    },

    {
        &WmiFireEventGuid,
        1,
        0
    },

    {
        &WmiEventClass1Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass2Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass3Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass4Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass5Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass6Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &WmiEventClass7Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

};

#define WmiGuidCount (sizeof(GuidList) / sizeof(SCSIWMIGUIDREGINFO))

UCHAR
QueryWmiDataBlock(
    IN PVOID Context,
    IN PVOID DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    );
        
UCHAR
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    );

UCHAR
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

UCHAR
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

UCHAR
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

void WmiInitialize(
    IN  PHWDEVEXT CardPtr
    )
{
    PSCSI_WMILIB_CONTEXT WmiLibContext;
    UCHAR Ec[sizeof(EC2) + 11*sizeof(WCHAR)];
    PEC1 Ec1;
    PEC2 Ec2;
    ULONG i;
    
    WmiLibContext = &CardPtr->WmiLibContext;
    
    WmiLibContext->GuidList = GuidList;
    WmiLibContext->GuidCount = WmiGuidCount;
    WmiLibContext->QueryWmiRegInfo = QueryWmiRegInfo;
    WmiLibContext->QueryWmiDataBlock = QueryWmiDataBlock;
    WmiLibContext->WmiFunctionControl = WmiFunctionControl;
    WmiLibContext->SetWmiDataBlock = WmiSetDataBlock;
    WmiLibContext->SetWmiDataItem = WmiSetDataItem;
    WmiLibContext->ExecuteWmiMethod = WmiExecuteMethod;
    
    CardPtr->Ec1Count = 3;
    CardPtr->Ec2Count = 3;
    for (i = 0; i < 4; i++)
    {
        Ec1 = (PEC1)Ec;
        memset(Ec1, i, sizeof(EC1));            
        ScsiPortMoveMemory(Ec1->string, L"EC1-0", 5*sizeof(WCHAR));
        Ec1->stringlen = 10;
        Ec1->string[4] += (USHORT)i;
        ScsiPortMoveMemory(Ec1->datetime, WmiSampDateTime, 25*sizeof(WCHAR));
            
        WmiSampSetEc1(CardPtr,
                      (PUCHAR)Ec1,
                      FIELD_OFFSET(EC1, string) + 10,
                      i);
                  

        Ec2 = (PEC2)Ec;
        memset(Ec2, i, sizeof(EC2));            
        ScsiPortMoveMemory(Ec2->string, L"EC2-0", 5*sizeof(WCHAR));
        Ec2->stringlen = 10;
        Ec2->string[4] += (USHORT)i;
        ScsiPortMoveMemory(Ec2->datetime, WmiSampDateTime, 25*sizeof(WCHAR));
            
        WmiSampSetEc2(CardPtr,
                      (PUCHAR)Ec2,
                      FIELD_OFFSET(EC2, string) + 10,
                      i);
    }
    
}



BOOLEAN
WmiSrb(
    IN     PHWDEVEXT   CardPtr,
    IN OUT PSCSI_WMI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

   Process an SRB_FUNCTION_WMI request packet.

   This routine is called from the SCSI port driver synchronized with the
   kernel via StartIo.   On completion of WMI processing, the SCSI
   port driver is notified that the adapter can take another request,  if
   any are available.

Arguments:

   HwCardPtr - HBA miniport driver's adapter data storage.

   Srb               - IO request packet.

Return Value:

   Value to return to Aha154xStartIo caller.   Always TRUE.

--*/
{
   UCHAR status;
   SCSIWMI_REQUEST_CONTEXT dc;
   PSCSIWMI_REQUEST_CONTEXT dispatchContext = &dc;
   ULONG retSize;
   BOOLEAN pending;

   //
   // Validate our assumptions.
   //

   ASSERT(Srb->Function == SRB_FUNCTION_WMI);
   ASSERT(Srb->Length == sizeof(SCSI_WMI_REQUEST_BLOCK));
   ASSERT(Srb->DataTransferLength >= sizeof(ULONG));
   ASSERT(Srb->DataBuffer);

   //
   // Only support wmi for the adapter and not disks
   if (!(Srb->WMIFlags & SRB_WMI_FLAGS_ADAPTER_REQUEST)) {
      Srb->DataTransferLength = 0;
      Srb->SrbStatus = SRB_STATUS_SUCCESS;
      return SRB_STATUS_SUCCESS;
   }

   //
   // Process the incoming WMI request.
   //
   dispatchContext->UserContext = Srb;
       
   DebugPrint((1, "ScsiPortWmiDispatchFunction(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
       &CardPtr->WmiLibContext,
               Srb->WMISubFunction,
                       CardPtr,
                               dispatchContext,
                                       Srb->DataPath,
                                               Srb->DataTransferLength,
                                                       Srb->DataBuffer));

   pending = ScsiPortWmiDispatchFunction(&CardPtr->WmiLibContext,
                                            Srb->WMISubFunction,
                                            CardPtr,
                                            dispatchContext,
                                            Srb->DataPath,
                                            Srb->DataTransferLength,
                                            Srb->DataBuffer);
                                        
    ASSERT(pending == FALSE);
       
   // We can do this since we assume it is done synchronously
   retSize =  ScsiPortWmiGetReturnSize(dispatchContext);
   status =  ScsiPortWmiGetReturnStatus(dispatchContext);

   DebugPrint((1,"WmiSrb %x completed %d, retsize 0x%x\n", Srb, status, retSize));
                          
   Srb->DataTransferLength = retSize;
          
   //
   // Adapter ready for next request.
   //

   Srb->SrbStatus = status;

   return TRUE;
}

ULONG WmiSampGetEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec1[Index], 
                  CardPtr->Ec1Length[Index]);
              
    return(CardPtr->Ec1Length[Index]);
}

ULONG WmiSampGetActualEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec1[Index], 
                  CardPtr->Ec1ActualLength[Index]);
              
    return(CardPtr->Ec1ActualLength[Index]);
}

BOOLEAN WmiSampSetEc1(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    )
{
    PEC1 New;
    ULONG NewLength;
    
    NewLength = (Length + 7) & ~7;
    
    if (NewLength > sizeof(EC1))
    {
        return(FALSE);
    }
    
    CardPtr->Ec1Length[Index] = NewLength;
    CardPtr->Ec1ActualLength[Index] = Length;
    ScsiPortMoveMemory(&CardPtr->Ec1[Index], 
                  Buffer, 
                  Length);
              
    return(TRUE);
}

ULONG WmiSampGetEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec2[Index], 
                  CardPtr->Ec2Length[Index]);
              
    return(CardPtr->Ec2Length[Index]);
}

ULONG WmiSampGetActualEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Index
    )
{
    ScsiPortMoveMemory(Buffer, 
                  &CardPtr->Ec2[Index], 
                  CardPtr->Ec2ActualLength[Index]);
              
    return(CardPtr->Ec2ActualLength[Index]);
}

BOOLEAN WmiSampSetEc2(
    PHWDEVEXT CardPtr,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    )
{
    PEC2 New;
    ULONG NewLength;
    
    NewLength = (Length + 7) & ~7;
    
    if (NewLength > sizeof(EC2))
    {
        return(FALSE);
    }
    
    CardPtr->Ec2Length[Index] = NewLength;
    CardPtr->Ec2ActualLength[Index] = Length;
    ScsiPortMoveMemory(&CardPtr->Ec2[Index], 
                  Buffer, 
                  Length);
    return(TRUE);
}



BOOLEAN
QueryWmiDataBlock(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
{
    PHWDEVEXT CardPtr = (PHWDEVEXT)Context;
    UCHAR status;
    ULONG i;
    ULONG sizeNeeded;
    ULONG sizeUsed;
    ULONG vlSize;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));

    DebugPrint((1, "QueryWmiDataBlock (%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n",
        Context,
        DispatchContext,
        GuidIndex,
        InstanceIndex,
        InstanceCount,
                InstanceLengthArray,
        BufferAvail,
        Buffer));
    
    switch(GuidIndex)
    {
        case WmiSampleClass1:
        case WmiSampleClass2:
        case WmiEventClass1:
        case WmiEventClass2:
        {
            // plain EC1
            sizeNeeded = CardPtr->Ec1Length[0];
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                WmiSampGetEc1(CardPtr, Buffer, 0);
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass3:
        case WmiEventClass3:
        {
            // fixed array of EC1
            sizeNeeded = 0;
            for (i = 0; i < 4; i++)
            {
                //
                // Embedded classes must be naturally aligned, but we
                // maintain naturally aligned lengths not acttual lengths
                sizeNeeded += CardPtr->Ec1Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                for (i = 0; i < 4; i++)
                {
                    sizeUsed = WmiSampGetEc1(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass4:
        case WmiEventClass4:
        {
            // variable array of EC1
            sizeNeeded = (sizeof(ULONG) + 7) & ~7;
            vlSize = CardPtr->Ec1Count;
            ASSERT(vlSize <= 4);
            for (i = 0; i < vlSize; i++)
            {
                sizeNeeded += CardPtr->Ec1Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                *((PULONG)Buffer) = vlSize;
                Buffer += (sizeof(ULONG) + 7) & ~7;
                for (i = 0; i < vlSize; i++)
                {
                    sizeUsed = WmiSampGetEc1(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass5:
        case WmiEventClass5:
        {
            // plain EC2
            sizeNeeded = CardPtr->Ec2Length[0];
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                WmiSampGetEc2(CardPtr, Buffer, 0);
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass6:
        case WmiEventClass6:
        {
            // fixed array EC2
            sizeNeeded = 0;
            for (i = 0; i < 4; i++)
            {
                sizeNeeded += CardPtr->Ec2Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                for (i = 0; i < 4; i++)
                {
                    sizeUsed = WmiSampGetEc2(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiSampleClass7:
        case WmiEventClass7:
        {
            // VL array EC2
            sizeNeeded = (sizeof(ULONG) + 7) & ~7;
            vlSize = CardPtr->Ec2Count;
            for (i = 0; i < vlSize; i++)
            {
                sizeNeeded += CardPtr->Ec2Length[i];
            }
            
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                *((PULONG)Buffer) = vlSize;
                Buffer += (sizeof(ULONG)+7) & ~7;
                for (i = 0; i < vlSize; i++)
                {
                    sizeUsed = WmiSampGetEc2(CardPtr, Buffer, i);
                    Buffer += sizeUsed;
                }
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
        
        case WmiFireEvent:
        case WmiGetSetData:
        {
            // return no data
            sizeNeeded = sizeof(USHORT);
            if (BufferAvail < sizeNeeded)
            {
                status = SRB_STATUS_DATA_OVERRUN;
            } else {
                *InstanceLengthArray = sizeNeeded;
                status =  SRB_STATUS_SUCCESS;
            }
            break;
        }
    
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  sizeNeeded);

    return FALSE;
}

UCHAR
QueryWmiRegInfo(
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    OUT PWCHAR *MofResourceName
    )
{
    *MofResourceName = Wmi_MofResourceName;    
    return SRB_STATUS_SUCCESS;
}

UCHAR WmiSampSetEc1Worker(
    PHWDEVEXT CardPtr,
    ULONG BufferSize,
    ULONG Index,
    PUCHAR Buffer,
    PULONG BufferUsed
    )
{
    ULONG blockLen;
    UCHAR status;
    PEC1 Ec1;
    
    Ec1 = (PEC1)Buffer;
    if (BufferSize >= FIELD_OFFSET(EC1, string))
    {
        blockLen = FIELD_OFFSET(EC1, string) + Ec1->stringlen;
                
        if (blockLen <= BufferSize)
        {
            if (! WmiSampSetEc1(CardPtr,
                            Buffer,
                            blockLen,
                            Index))
            {
                return(SRB_STATUS_ERROR);
            }
            *BufferUsed = (blockLen+7) & ~7;
            status = SRB_STATUS_SUCCESS;
        } else {
            DebugPrint((1,"Set EC1 buffer too small\n"));
            status = SRB_STATUS_ERROR;
        }                
    } else {
        DebugPrint((1,"Set EC1 buffer size wrong %d\n", BufferSize));
        status = SRB_STATUS_ERROR;
    }
    return(status);
}

UCHAR WmiSampSetEc2Worker(
    PHWDEVEXT CardPtr,
    ULONG BufferSize,
    ULONG Index,
    PUCHAR Buffer,
    PULONG BufferUsed
    )
{
    ULONG blockLen;
    UCHAR status;
    PUSHORT wPtr;
    PEC2 Ec2;
    
    Ec2 = (PEC2)Buffer;
    if (BufferSize >= FIELD_OFFSET(EC2, string))
    {
        blockLen = FIELD_OFFSET(EC2, string) + Ec2->stringlen;
                
        if (blockLen <= BufferSize)
        {
            if (! WmiSampSetEc2(CardPtr,
                            Buffer,
                            blockLen,
                            Index))
            {
                return(SRB_STATUS_ERROR);
            }
            *BufferUsed = (blockLen+7) & ~7;
            status = SRB_STATUS_SUCCESS;
        } else {
            DebugPrint((1,"Set EC2 buffer too small\n"));
            status = SRB_STATUS_ERROR;
        }                
    } else {
        DebugPrint((1,"Set EC2 buffer size wrong %d\n", BufferSize));
        status = SRB_STATUS_ERROR;
    }
    return(status);
}


BOOLEAN
WmiSetDataBlock (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    PHWDEVEXT CardPtr = (PHWDEVEXT)Context;
    UCHAR status;
    ULONG bufferUsed;
    ULONG i;
    ULONG vlSize;

    DebugPrint((1, "WmiSetDataBlock(%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        BufferSize,
                             Buffer));

                         
    switch(GuidIndex)
    {
        case WmiSampleClass1:
        case WmiSampleClass2:
        {
            // plain EC1
            status = WmiSampSetEc1Worker(CardPtr,
                                         BufferSize,
                                         0,
                                         Buffer,
                                         &bufferUsed);
            break;
        }
        
        case WmiSampleClass3:
        {
            // fixed array of EC1
             
            for (i = 0, status = SRB_STATUS_SUCCESS; 
                 (i < 4) && (status == SRB_STATUS_SUCCESS); i++)
            {
                status = WmiSampSetEc1Worker(CardPtr,
                                             BufferSize,
                                             i,
                                             Buffer,
                                             &bufferUsed);
                Buffer += bufferUsed;
                BufferSize -= bufferUsed;
            }
            break;
        }
        
        case WmiSampleClass4:
        {
            // variable array of EC1

            if (BufferSize >= ((sizeof(ULONG) +7) & ~7))
            {
                vlSize = *((PULONG)Buffer);
                Buffer += ((sizeof(ULONG) +7) & ~7);
                
                if ((vlSize >= 1) && (vlSize <= 4))
                {
                    for (i = 0, status = SRB_STATUS_SUCCESS; 
                         (i < vlSize) && (status == SRB_STATUS_SUCCESS); i++)
                    {
                        status = WmiSampSetEc1Worker(CardPtr,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                                 &bufferUsed);
                        Buffer += bufferUsed;
                        BufferSize -= bufferUsed;
                    }
                    if (status == SRB_STATUS_SUCCESS)
                    {
                        CardPtr->Ec1Count = vlSize;
                    }
                } else {
                    DebugPrint((1,"SetEc1 only up to [4] allowed, not %d\n",
                            vlSize));
                    status = SRB_STATUS_ERROR;
                }
            } else {
                DebugPrint((1,"SetEc1 size too small\n"));
                status = SRB_STATUS_ERROR;
            }
                
            break;
        }
        
        case WmiSampleClass5:
        {
            // plain EC2
            status = WmiSampSetEc2Worker(CardPtr,
                                         BufferSize,
                                             0,
                                         Buffer,
                                         &bufferUsed);
            break;
        }
        
        case WmiSampleClass6:
        {
            // fixed array EC2
            for (i = 0, status = SRB_STATUS_SUCCESS; 
                 (i < 4) && (status == SRB_STATUS_SUCCESS); i++)
            {
                status = WmiSampSetEc2Worker(CardPtr,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                             &bufferUsed);
                Buffer += bufferUsed;
                BufferSize -= bufferUsed;
            }
            break;
        }
        
        case WmiSampleClass7:
        {
            // VL array EC2
            if (BufferSize >= sizeof(ULONG))
            {
                vlSize = *((PULONG)Buffer);
                Buffer += (sizeof(ULONG) +7) & ~7;
                if ((vlSize >= 1) && (vlSize <= 4))
                {
                    for (i = 0, status = SRB_STATUS_SUCCESS; 
                         (i < vlSize) && (status == SRB_STATUS_SUCCESS); i++)
                    {
                        status = WmiSampSetEc2Worker(CardPtr,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                             &bufferUsed);
                        Buffer += bufferUsed;
                        BufferSize -= bufferUsed;
                    }
                    if (status == SRB_STATUS_SUCCESS)
                    {
                        CardPtr->Ec1Count = vlSize;
                    }
                } else {
                    DebugPrint((1,"SetEc2 only up to [4] allowed, not %d\n",
                            vlSize));
                    status = SRB_STATUS_ERROR;
                }
            } else {
                DebugPrint((1,"SetEc2 size too small\n"));
                status = SRB_STATUS_ERROR;
            }
                
            break;
        }
        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }
                         
                                             
    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);
    return(FALSE);    
}

BOOLEAN
WmiSetDataItem (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    UCHAR status;
    
    DebugPrint((1, "WmiSetDataItem(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        DataItemId,
                        BufferSize,
                             Buffer));
    switch(GuidIndex)
    {
        case WmiSampleClass1:
        case WmiSampleClass2:
        case WmiSampleClass3:
        case WmiSampleClass4:
        case WmiSampleClass5:
        case WmiSampleClass6:
        case WmiSampleClass7:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
        
        
        default:
        {
            status = SRB_STATUS_ERROR;
            break;
        }
    }

     ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}

UCHAR WmiSampFireEvent(
    PHWDEVEXT CardPtr,
    ULONG WnodeType,  // 0 - AllData, 1 - Single Instance
    ULONG DataType,   // 1 - 7 is guid id
    ULONG BlockIndex  // 0 - 3 is block index containing data
    )
{
    PWNODE_HEADER Wnode;
    PWNODE_EVENT_REFERENCE WnodeER;
    ULONG dataSize;
    LPGUID Guid;
    UCHAR status;
    ULONG sizeNeeded;
    
    
    if (BlockIndex > 3)
    {
        return(SRB_STATUS_ERROR);
    }
    
    switch(DataType)
    {
        case 1:
        {
            // EC1
            dataSize = CardPtr->Ec1Length[BlockIndex];
            Guid = &WmiEventClass1Guid;
            break;
        }
        
        case 2:
        {
            // EC1 (embedded)
            dataSize = CardPtr->Ec1Length[BlockIndex];
            Guid = &WmiEventClass2Guid;
            break;
        }
                
        case 5:
        {
            // EC2 (embedded)
            dataSize = CardPtr->Ec2Length[BlockIndex];
            Guid = &WmiEventClass5Guid;
            break;
        }
        

        default:
        {
            return(SRB_STATUS_ERROR);
        }
    }
    
    Wnode = (PWNODE_HEADER)CardPtr->EventBuffer;
    
    sizeNeeded = sizeof(WNODE_EVENT_REFERENCE);

    if (sizeNeeded > WMI_EVENT_BUFFER_SIZE)
    {
        ASSERT(FALSE);
        return(SRB_STATUS_ERROR);
    }
        
    Wnode->Flags =  WNODE_FLAG_EVENT_ITEM |
                    WNODE_FLAG_EVENT_REFERENCE |
                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
    WnodeER = (PWNODE_EVENT_REFERENCE)Wnode;
    WnodeER->TargetGuid = *Guid;
    WnodeER->TargetDataBlockSize = dataSize + sizeof(WNODE_SINGLE_INSTANCE);
    WnodeER->TargetInstanceIndex = 0;
    
    Wnode->Guid = *Guid;
    Wnode->BufferSize = sizeNeeded;
    
    ScsiPortNotification(WMIEvent,
                         CardPtr,
                         Wnode,
                         0xff);
    
    return(SRB_STATUS_SUCCESS);    
}


BOOLEAN
WmiExecuteMethod (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG BufferAvail,
    IN OUT PUCHAR Buffer
    )
{
    PHWDEVEXT CardPtr = (PHWDEVEXT)Context;
    ULONG sizeNeeded = 0;
    UCHAR status;
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK)(DispatchContext->UserContext);
    ULONG bufferUsed;
    ULONG blockIndex;
    ULONG UlongPadSize = (sizeof(ULONG) + 7) & ~7;
    
    DebugPrint((1, "WmiExecuteMethod(%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x,\n%x)\n",
        Context,
            DispatchContext,
                GuidIndex,
                    InstanceIndex,
                        MethodId,
                        InBufferSize,
                        BufferAvail,
                             Buffer));
                         
                         
    if (GuidIndex == WmiGetSetData)
    {
        switch(MethodId)
        {
            case 1:
            case 7:
            {
                // SetEc1                    

                if (InBufferSize < UlongPadSize)
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                    Buffer += UlongPadSize;
                    InBufferSize -= UlongPadSize;
                }                
                
                status = WmiSampSetEc1Worker(CardPtr,
                                         InBufferSize,
                                             blockIndex,
                                         Buffer,
                                         &bufferUsed);
                sizeNeeded = 0;
                break;
            }
            
            case 2:
            case 8:
            {
                // SetEc2

                if (InBufferSize < UlongPadSize)
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                    Buffer += UlongPadSize;
                    InBufferSize -= UlongPadSize;
                }                
                
                status = WmiSampSetEc2Worker(CardPtr,
                                         InBufferSize,
                                             blockIndex,
                                         Buffer,
                                         &bufferUsed);
                sizeNeeded = 0;
                break;
            }
            
            case 3:
            case 9:
            {
                // GetEc1
                    
                if (InBufferSize != sizeof(ULONG))
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                }                
                
                sizeNeeded = CardPtr->Ec1ActualLength[blockIndex];
                if (BufferAvail < sizeNeeded)
                {
                    status = SRB_STATUS_DATA_OVERRUN;
                } else {
                    WmiSampGetActualEc1(CardPtr, Buffer, blockIndex);
                    status = SRB_STATUS_SUCCESS;
                }
                break;
            }
            
            case 4:
            case 10:
            {
                // GetEc2
                if (InBufferSize != sizeof(ULONG))
                {
                    status = SRB_STATUS_ERROR;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = SRB_STATUS_ERROR;
                        break;                        
                    }
                }                
                
                sizeNeeded = CardPtr->Ec2ActualLength[blockIndex];
                if (BufferAvail < sizeNeeded)
                {
                    status = SRB_STATUS_DATA_OVERRUN;
                } else {
                    WmiSampGetActualEc2(CardPtr, Buffer, blockIndex);
                    status = SRB_STATUS_SUCCESS;
                }
                break;
            }
           
	    
    	    case 13:
	        {
                ScsiPortNotification(WMIReregister,
                         CardPtr,
                         0xff);
                 status = SRB_STATUS_SUCCESS;
				 sizeNeeded = 0;				 
		        break;
    	    }
	    
            case 5:
            case 11:            
            case 6:
            case 12:
            default: 
            {
                status = SRB_STATUS_ERROR;
            }
        }
    } else if (GuidIndex == WmiFireEvent) {
        if (MethodId == 1)
        {
            if (InBufferSize == 3*sizeof(ULONG))
            {
                ULONG wnodeType;
                ULONG dataType;
                ULONG blockIndex;
                
                wnodeType = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);
                
                dataType = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);
                
                blockIndex = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);
                
                status = WmiSampFireEvent(CardPtr,
                                 wnodeType,
                                 dataType,
                                 blockIndex);
                             
                sizeNeeded = 0;

            } else {
                status = SRB_STATUS_ERROR;
            }
        } else {
            status = SRB_STATUS_ERROR;
        }
    } else  {
        status = SRB_STATUS_ERROR;
    }
    
    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  sizeNeeded);

    return(FALSE);    
}

BOOLEAN
WmiFunctionControl (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    )
{
    UCHAR status = SRB_STATUS_SUCCESS;

    //
    // TODO: Verify that expensive guids are being enbled and inexpensive ones
    //       are not, same with events
    DebugPrint((1, "WmiFunctionControl(%x,\n%x,\n%x,\n%x,\n%x)\n\n",
        Context,
            DispatchContext,
                GuidIndex,
                    Function,
                             Enable));
                                 

    ScsiPortWmiPostProcess(
                                  DispatchContext,
                                  status,
                                  0);

    return(FALSE);    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\raid\test\raidport.h ===
#define UTEST	(1)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined (UTEST)

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY;

#define KSPIN_LOCK CRITICAL_SECTION
#define KLOCK_QUEUE_HANDLE PCRITICAL_SECTION
#define PKLOCK_QUEUE_HANDLE PCRITICAL_SECTION*
#define KeInitializeSpinLock	InitializeCriticalSection
#define KeAcquireInStackQueuedSpinLockAtDpcLevel(Lock, Handle)\
	do {									\
		*Handle = Lock;						\
		EnterCriticalSection(Lock);			\
	} while (0)
	
#define KeReleaseInStackQueuedSpinLockFromDpcLevel(Handle)\
	LeaveCriticalSection(*Handle)

#define INLINE __inline
#define REVIEW()\
	do {													 \
		OutputDebugString ("Math needs to review this\n");   \
		DebugBreak();										 \
	} while (0)

#endif



#undef ASSERT
#define ASSERT(exp)\
	if (!(exp)) {										\
		static BOOL Ignore = FALSE;					\
		printf ("ASSERT failed, \"%s\" %s %d\n",	\
				 #exp,								\
				 __FILE__,							\
				 __LINE__);							\
													\
		if (!Ignore) {								\
			DebugBreak();							\
		}											\
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc.c ===
/*++

 Copyright (c) 1994-1998 Advanced System Products, Inc.
 All Rights Reserved.

Module Name:

    asc.c

Abstract:

    This is the port driver for the Advansys SCSI Protocol Chips.

Environment:

    kernel mode only

Notes:
    This file is formatted with 4-space tab stops. If you want to
    print without tabs filter them out.

--*/

#include "miniport.h"                   // NT requires
#include "scsi.h"                       // NT requires

#include "a_ddinc.h"                    // Asc Library requires
#include "asclib.h"
#include "asc.h"                        // ASC NT driver specific

PortAddr _asc_def_iop_base[ ASC_IOADR_TABLE_MAX_IX ] = {
  0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
  ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
} ;

//
// Vendor and Device IDs.
//
UCHAR VenID[4] = {'1', '0', 'C', 'D'};
UCHAR DevID[1] = {'1'};

//
// Function declarations
//

ULONG HwFindAdapterISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG HwFindAdapterVL(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG HwFindAdapterEISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ULONG FoundPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

BOOLEAN HwInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN HwInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    );

SCSI_ADAPTER_CONTROL_STATUS HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
        IN PVOID Paramters
    );

VOID BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

int
AscExecuteIO(
    IN PSCSI_REQUEST_BLOCK srb
    );

VOID DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_QDONE_INFO *scbDoneInfo
    );

UCHAR ErrXlate (
    UCHAR ascErrCode
    );

PortAddr HwSearchIOPortAddr(
    PortAddr iop_beg,
    ushort bus_type,
    IN PVOID HwDE,
    IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
    );

ULONG PCIGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG SystemIoBusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    );

VOID AscZeroMemory(IN UCHAR *cp, IN ULONG length);

//======================================================================
//
// All procedures start here
//
//======================================================================

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object

Return Value:

    Status from ScsiPortInitialize()

--*/

ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    HW_INITIALIZATION_DATA      hwInitializationData;
    SRCH_CONTEXT                srchContext;
    ULONG                       Status = 0xFFFFFFFFL;
    ULONG                       tStatus;

    ASC_DBG(2, "Asc: DriverEntry: begin\n");

    //
    // Zero out structure.
    //
    AscZeroMemory((PUCHAR) &hwInitializationData,
        sizeof(HW_INITIALIZATION_DATA));

    //
    // Set size of hwInitializationData.
    //
    hwInitializationData.HwInitializationDataSize =
        sizeof(HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //
    hwInitializationData.HwInitialize = HwInitialize;
    hwInitializationData.HwResetBus = HwResetBus;
    hwInitializationData.HwStartIo = HwStartIo;
    hwInitializationData.HwInterrupt = HwInterrupt;
    // 'HwAdapterControl' is a SCSI miniport interface added with NT 5.0.
    hwInitializationData.HwAdapterControl = HwAdapterControl;

    //
    // Indicate need buffer mapping and physical addresses.
    //
    hwInitializationData.NeedPhysicalAddresses = TRUE;
    hwInitializationData.MapBuffers = TRUE;
    hwInitializationData.AutoRequestSense = TRUE;

    //
    // Specify size of extensions.
    //
    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = 0;
    hwInitializationData.NumberOfAccessRanges = 1;
    hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);


    //
    // Search for ISA
    //
    srchContext.lastPort = 0;
    hwInitializationData.AdapterInterfaceType = Isa;
    hwInitializationData.HwFindAdapter = HwFindAdapterISA;
    Status = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);

    //
    // Search for VL
    //
    srchContext.lastPort = 0;
    hwInitializationData.AdapterInterfaceType = Isa;
    hwInitializationData.HwFindAdapter = HwFindAdapterVL;
    tStatus = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);
    if (tStatus < Status)
    {
        Status = tStatus;
    }

    //
    // Search for EISA
    //
    srchContext.lastPort = 0;
    hwInitializationData.AdapterInterfaceType = Eisa;
    hwInitializationData.HwFindAdapter = HwFindAdapterEISA;
    tStatus = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);
    if (tStatus < Status)
    {
        Status = tStatus;
    }

    //
    // Search for PCI
    //
    srchContext.PCIBusNo = 0;
    srchContext.PCIDevNo = 0;

    hwInitializationData.VendorIdLength = 4;
    hwInitializationData.VendorId = VenID;
    hwInitializationData.DeviceIdLength = 1;
    hwInitializationData.DeviceId = DevID;

    hwInitializationData.AdapterInterfaceType = PCIBus;
    hwInitializationData.HwFindAdapter = HwFindAdapterPCI;
    tStatus = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &srchContext);
    if (tStatus < Status)
    {
        Status = tStatus;
    }

    ASC_DBG1(2, "Asc: DriverEntry: Status %d\n", Status);
    //
    // Return the status.
    //
    return( Status );

} // end DriverEntry()

/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the adapter's configuration.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Context - Register base address
    ConfigInfo - Configuration information structure describing HBA
    This structure is defined in PORT.H.

Return Value:

    ULONG

--*/

ULONG
HwFindAdapterISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PSRCH_CONTEXT           psrchContext = Context;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &deviceExtension->chipConfig;
    USHORT                  initstat;

    ASC_DBG1(2, "HwFindAdapterISA: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterISA: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterISA: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);

    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            (*ConfigInfo->AccessRanges)[0].RangeStart,
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );
    } else
    {
        *Again = FALSE;

        //
        // Scan though the adapter addresses looking for adapters.
        //
        portFound = psrchContext->lastPort;
        if ((portFound = HwSearchIOPortAddr(portFound, ASC_IS_ISA,
                HwDeviceExtension, ConfigInfo )) == 0)
        {
            return(SP_RETURN_NOT_FOUND);
        }
        psrchContext->lastPort = portFound;

        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            ScsiPortConvertUlongToPhysicalAddress(portFound),
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        (*ConfigInfo->AccessRanges)[0].RangeStart =
            ScsiPortConvertUlongToPhysicalAddress(portFound);
    }


    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &deviceExtension->chipInfo;
    chipConfig->bus_type = ASC_IS_ISA;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0x000fffff;

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

    ConfigInfo->BusInterruptLevel = chipConfig->irq_no;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0x000fffff;
    //
    // 'ResetTargetSupported' is flag added with NT 5.0 that will
    // result in SRB_FUNCTION_RESET_DEVICE SRB requests being sent
    // to the miniport driver.
    //
    ConfigInfo->ResetTargetSupported = TRUE;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->InterruptMode = Latched;
    ConfigInfo->AdapterInterfaceType = Isa;
    ConfigInfo->AlignmentMask = 3;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->DmaChannel = chipConfig->cfg->isa_dma_channel;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));
    HDE2DONE(deviceExtension) = 0;

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "HwFindAdapterISA: IO Base addr %x\n",
        chipConfig->iop_base);
    ASC_DBG1(2, "HwFindAdapterISA: Int Level    %x\n",
        ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "HwFindAdapterISA: Initiator ID %x\n",
        ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "HwFindAdapterISA(): SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
} // end HwFindAdapterISA()

ULONG
HwFindAdapterVL(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PSRCH_CONTEXT           psrchContext = Context;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &deviceExtension->chipConfig;
    USHORT                  initstat;

    ASC_DBG1(2, "HwFindAdapterVL: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterVL: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterVL: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);


    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            (*ConfigInfo->AccessRanges)[0].RangeStart,
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

    } else
    {
        *Again = FALSE;

        //
        // Scan though the adapter addresses looking for adapters.
        //
        portFound = psrchContext->lastPort;
        if ((portFound = HwSearchIOPortAddr(portFound, ASC_IS_VL,
            HwDeviceExtension, ConfigInfo )) == 0)
        {
            return(SP_RETURN_NOT_FOUND);
        }
        psrchContext->lastPort = portFound;

        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            ScsiPortConvertUlongToPhysicalAddress(portFound),
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        (*ConfigInfo->AccessRanges)[0].RangeStart =
            ScsiPortConvertUlongToPhysicalAddress(portFound);
    }

    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &(deviceExtension->chipInfo);
    chipConfig->bus_type = ASC_IS_VL;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0xffffffff;

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

    ConfigInfo->BusInterruptLevel = chipConfig->irq_no;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->InterruptMode = Latched;
    ConfigInfo->AdapterInterfaceType = Isa;
    ConfigInfo->AlignmentMask = 3;
    ConfigInfo->BufferAccessScsiPortControlled = TRUE;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "HwFindAdapterVL: IO Base addr %x\n",
        chipConfig->iop_base);
    ASC_DBG1(2, "HwFindAdapterVL: Int Level    %x\n",
        ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "HwFindAdapterVL: Initiator ID %x\n",
        ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "HwFindAdapterVL: SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
} // end HwFindAdapterVL()

ULONG
HwFindAdapterEISA(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PORT_ADDR               eisaportaddr;
    PVOID                   eisacfgbase;
    PSRCH_CONTEXT           psrchContext = Context;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &(deviceExtension->chipConfig);
    USHORT                  initstat;
    uchar                   eisairq;

    ASC_DBG1(2, "HwFindAdapterEISA: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterEISA: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterEISA: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);

    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            (*ConfigInfo->AccessRanges)[0].RangeStart,
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        // Save EISA address to obtain IRQ later.
        eisaportaddr =
                ScsiPortConvertPhysicalAddressToUlong(
                 (*ConfigInfo->AccessRanges)[0].RangeStart);
    } else
    {
        *Again = FALSE;

        //
        // Scan though the adapter addresses looking for adapters.
        //
        portFound = psrchContext->lastPort;
        if ((portFound = HwSearchIOPortAddr(portFound, ASC_IS_EISA,
                HwDeviceExtension, ConfigInfo )) == 0)
        {
            return(SP_RETURN_NOT_FOUND);
        }
        psrchContext->lastPort = portFound;

        // Save EISA address to obtain IRQ later.
        eisaportaddr = portFound;

        //
        // Get the system physical address for this card.
        // The card uses I/O space.
        //
        portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
            HwDeviceExtension,                      // HwDeviceExtension
            ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
            ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
            ScsiPortConvertUlongToPhysicalAddress(portFound),
            0x10,                                   // NumberOfBytes
            TRUE                                    // InIoSpace
            );

        (*ConfigInfo->AccessRanges)[0].RangeStart =
            ScsiPortConvertUlongToPhysicalAddress(portFound);
    }

    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &(deviceExtension->chipInfo);
    chipConfig->bus_type = ASC_IS_EISA;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0x00ffffff;

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    /*
     * Read the chip's IRQ from the chip EISA slot configuration space.
     */
    eisacfgbase = ScsiPortGetDeviceBase(
        HwDeviceExtension,                      // HwDeviceExtension
        ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
        ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
        ScsiPortConvertUlongToPhysicalAddress(
           (ASC_GET_EISA_SLOT(eisaportaddr) | ASC_EISA_CFG_IOP_MASK)),
        2,
        TRUE);

    if (eisacfgbase == NULL)
    {
        eisairq = 0;
    } else
    {
        eisairq = (uchar) (((inpw(eisacfgbase) >> 8) & 0x07) + 10);
        if ((eisairq == 13) || (eisairq > 15))
        {
            /*
             * Valid IRQ numbers are 10, 11, 12, 14, 15.
             */
            eisairq = 0;
        }
        ScsiPortFreeDeviceBase(HwDeviceExtension, eisacfgbase);
    }
    chipConfig->irq_no = eisairq;

    if ((initstat = AscInitSetConfig (chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

    ConfigInfo->BusInterruptLevel = chipConfig->irq_no;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = FALSE;
    ConfigInfo->InterruptMode = LevelSensitive;
    ConfigInfo->AdapterInterfaceType = Eisa;
    ConfigInfo->AlignmentMask = 3;
    ConfigInfo->BufferAccessScsiPortControlled = TRUE;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "HwFindAdapterEISA: IO Base addr %x\n",
        chipConfig->iop_base);
    ASC_DBG1(2, "HwFindAdapterEISA: Int Level    %x\n",
        ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "HwFindAdapterEISA: Initiator ID %x\n",
        ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "HwFindAdapterEISA(): SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
} // end HwFindAdapterEISA()

ULONG
HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ASC_DBG1(2, "HwFindAdapterPCI: NumberOfAccessRanges = %d\n",
        ConfigInfo->NumberOfAccessRanges);
    ASC_DBG1(2, "HwFindAdapterPCI: RangeStart = %x\n",
        (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart);
    ASC_DBG1(2, "HwFindAdapterPCI: RangeLength = %d\n",
        (*ConfigInfo->AccessRanges)[0].RangeLength);

    //
    // If NT provides an address, use it.
    //
    if ((*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart != 0)
    {
        return FoundPCI(HwDeviceExtension, BusInformation,
            ArgumentString, ConfigInfo, Again);
    }
    *Again = FALSE;
    return(SP_RETURN_NOT_FOUND);
} // end HwFindAdapterPCI()

//
//
// This routine handles PCI adapters that are found by NT.
//
//
ULONG
FoundPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    PORT_ADDR               portFound;
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &(deviceExtension->chipConfig);
    USHORT                  initstat;
    PCI_SLOT_NUMBER         SlotNumber;
    PCI_COMMON_CONFIG       pciCommonConfig;
    PCI_COMMON_CONFIG       *pPciCommonConfig = &pciCommonConfig;
    ULONG                   size;

    ASC_DBG(2, "FoundPCI: begin\n");

    SlotNumber.u.AsULONG = 0L;
    SlotNumber.u.bits.DeviceNumber = ConfigInfo->SlotNumber;

    ASC_DBG2(3, "FoundPCI: Checking Bus: %X, Device: %X\n",
        ConfigInfo->SystemIoBusNumber,
        ConfigInfo->SlotNumber);

    if ((size = PCIGetBusData(
            HwDeviceExtension,              // HwDeviceExtension
            ConfigInfo->SystemIoBusNumber,  // SystemIoBusNumber
            SlotNumber,                     // slot number
            pPciCommonConfig,               // buffer pointer with PCI INFO
            sizeof(PCI_COMMON_CONFIG)       // length of buffer
            )) != sizeof(PCI_COMMON_CONFIG)) {
        ASC_DBG1(0, "FoundPCI: Bad PCI Config size: %d\n", size);
        return(SP_RETURN_NOT_FOUND);
    }

    if (((pciCommonConfig.DeviceID != ASC_PCI_DEVICE_ID) &&
         (pciCommonConfig.DeviceID != ASC_PCI_DEVICE_ID2) &&
         (pciCommonConfig.DeviceID != ASC_PCI_DEVICE_ID3)) ||
        (pciCommonConfig.VendorID != ASC_PCI_VENDOR_ID))
    {
        ASC_DBG(1, "FoundPCI: Bad Vendor/Device ID\n");
        return(SP_RETURN_NOT_FOUND);
    }

    portFound =
        (PORT_ADDR)pciCommonConfig.u.type0.BaseAddresses[0] &
        (~PCI_ADDRESS_IO_SPACE);

    if (ScsiPortConvertUlongToPhysicalAddress(portFound).QuadPart
        != (*ConfigInfo->AccessRanges)[0].RangeStart.QuadPart)
    {
        ASC_DBG(1, "FoundPCI: PCI Config addr .NE. RangeStart!\n");
        return(SP_RETURN_NOT_FOUND);
    }

    //
    // Convert to logical base address so we can do IO.
    //
    portFound = (PORT_ADDR) ScsiPortGetDeviceBase(
        HwDeviceExtension,                      // HwDeviceExtension
        ConfigInfo->AdapterInterfaceType,       // AdapterInterfaceType
        ConfigInfo->SystemIoBusNumber,          // SystemIoBusNumber
        (*ConfigInfo->AccessRanges)[0].RangeStart,
        (*ConfigInfo->AccessRanges)[0].RangeLength,
        (BOOLEAN)!(*ConfigInfo->AccessRanges)[0].RangeInMemory);

    if (ConfigInfo->BusInterruptLevel != pciCommonConfig.u.type0.InterruptLine)
    {
        ASC_DBG2(2, "FoundPCI: IRQ Variance ConfigInfo: %X, pciConfig: %X\n",
                ConfigInfo->BusInterruptLevel,
                pciCommonConfig.u.type0.InterruptLine);
    }
    ASC_DBG(2, "FoundPCI: IRQs match\n");

    //
    // Hardware found; Get the hardware configuration.
    //
    chipConfig->iop_base = portFound;
    chipConfig->cfg = &(deviceExtension->chipInfo);
    chipConfig->bus_type = ASC_IS_PCI;
    chipConfig->cfg->pci_device_id = pciCommonConfig.DeviceID;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->exe_callback = 0;
    chipConfig->max_dma_count = 0xffffffff;
    chipConfig->irq_no = (UCHAR) ConfigInfo->BusInterruptLevel;
    chipConfig->cfg->pci_slot_info =
         (USHORT) ASC_PCI_MKID(ConfigInfo->SystemIoBusNumber,
                    SlotNumber.u.bits.DeviceNumber,
                    SlotNumber.u.bits.FunctionNumber);

    if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitGetConfig: successful\n");
    }

    if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitSetConfig: successful\n");
    }

    //
    // Fill out ConfigInfo table for WinNT
    //
    (*ConfigInfo->AccessRanges)[0].RangeLength = 16;
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->cfg->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;

    /*
     * Change NumberOfPhysicalBreaks to maximum scatter-gather
     * elements - 1 the adapter can handle based on the BIOS
     * "Host Queue Size" setting.
     *
     * According to the NT DDK miniport drivers are not supposed to
     * change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". NT is broken in that it sets
     * MaximumPhysicalPages, the value class drivers use, to the
     * same value as NumberOfPhysicalBreaks.
     *
     */
    ConfigInfo->NumberOfPhysicalBreaks =
        (((chipConfig->max_total_qng - 2) / 2) * ASC_SG_LIST_PER_Q);
    if (ConfigInfo->NumberOfPhysicalBreaks > ASC_MAX_SG_LIST - 1) {
        ConfigInfo->NumberOfPhysicalBreaks = ASC_MAX_SG_LIST - 1;
    }

    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = TRUE;
    ConfigInfo->InterruptMode = LevelSensitive;
    ConfigInfo->AdapterInterfaceType = PCIBus;
    /*
     * Set the buffer alignment mask to require double word
     * alignment for old PCI chips and no alignment for
     * Ultra PCI chips.
     */
    if ((chipConfig->cfg->pci_device_id == ASC_PCI_DEVICE_ID) ||
        (chipConfig->cfg->pci_device_id == ASC_PCI_DEVICE_ID2)) {
        ConfigInfo->AlignmentMask = 3;
    } else {
        ConfigInfo->AlignmentMask = 0;
    }
    ConfigInfo->BufferAccessScsiPortControlled = TRUE;
    ConfigInfo->MaximumNumberOfTargets = 7;
    ConfigInfo->TaggedQueuing = TRUE;

    /*
     * Clear adapter wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    //
    // Allocate a Noncached Extension to use for overrun handling.
    //
    deviceExtension->inquiryBuffer = (PVOID) ScsiPortGetUncachedExtension(
            deviceExtension,
            ConfigInfo,
            NONCACHED_EXTENSION);

    *Again = TRUE;

    ASC_DBG1(2, "FoundPCI: IO Base addr %x\n", chipConfig->iop_base);
    ASC_DBG1(2, "FoundPCI: Int Level    %x\n", ConfigInfo->BusInterruptLevel);
    ASC_DBG1(2, "FoundPCI: Initiator ID %x\n", ConfigInfo->InitiatorBusId[0]);
    ASC_DBG(2, "FoundPCI: SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
}

BOOLEAN
HwInitialize(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is called from ScsiPortInitialize
    to set up the adapter so that it is ready to service requests.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = HwDeviceExtension;
    uchar                   *inqBuffer = deviceExtension->inquiryBuffer;
    ushort                  initstat;

    ASC_DBG1(2, "HwInitialize: chipConfig %x\n", chipConfig);

    chipConfig->cfg->overrun_buf = inqBuffer;

    if ((initstat = AscInitAsc1000Driver(chipConfig)) != 0) {
        ASC_DBG1(1, "AscInitAsc1000Driver: warning code %x\n", initstat);
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AscInitAsc1000Driver: err_code code %x\n",
            chipConfig->err_code);
        return(SP_RETURN_ERROR);
    } else {
        ASC_DBG(2, "AscInitAsc1000Driver: successful\n");
    }

    ASC_DBG(2, "HwInitialize: TRUE\n");
    return( TRUE );
} // HwInitialize()

/*
 * AscExecuteIO()
 *
 * If ASC_BUSY is returned, the request was not executed and it
 * should be enqueued and tried later.
 *
 * For all other return values the request is active or has
 * been completed.
 */
int
AscExecuteIO(IN PSCSI_REQUEST_BLOCK srb)
{
    PVOID           HwDeviceExtension;
    PCHIP_CONFIG    chipConfig;
    PSCB            scb;
    uchar           PathId, TargetId, Lun;
    uint            status;

    ASC_DBG1(3, "AscExecuteIO: srb %x\n", srb);
    HwDeviceExtension = SRB2HDE(srb);
    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    //
    // Build SCB.
    //
    BuildScb(HwDeviceExtension, srb);
    scb = &SRB2SCB(srb);
    PathId = srb->PathId;
    TargetId = srb->TargetId;
    Lun = srb->Lun;

    //
    // Execute SCSI Command
    //
    status = AscExeScsiQueue(chipConfig, scb);

    if (status == ASC_NOERROR) {
        /*
         * Request successfully started.
         *
         * If more requests can be sent to the Asc Library then
         * call NextRequest or NextLuRequest.
         *
         * NextRequest indicates that another request may be sent
         * to any non-busy target. Since a request was just issued
         * to the target 'TargetId' that target is now busy and won't
         * be sent another request until a RequestComplete is done.
         *
         * NextLuRequest indicates that another request may be sent
         * to any non-busy target as well as the specified target even
         * if the specified target is busy.
         */
        ASC_DBG1(3, "AscExeScsiQueue: srb %x ASC_NOERROR\n", srb);
        ASC_DBG1(3, "AscExecuteIO: srb %x, NextLuRequest\n", srb);
        ScsiPortNotification(NextLuRequest, HwDeviceExtension,
                        PathId, TargetId, Lun);
    } else if (status == ASC_BUSY) {
        ASC_DBG1(1, "AscExeScsiQueue: srb %x ASC_BUSY\n", srb);
        ASC_DBG1(3, "AscExecuteIO: srb %x, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    } else {
        /*
         * AscExeScsiQueue() returned an error...
         */
        ASC_DBG2(1, "AscExeScsiQueue: srb %x, error code %x\n", srb, status);
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        ASC_DBG1(3, "AscExecuteIO: srb %x, RequestComplete\n", srb);
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ASC_DBG1(3, "AscExecuteIO: srb %x, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    }

    ASC_DBG1(3, "AscExecuteIO: status %d\n", status);
    return status;
}

BOOLEAN
HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )

/*++

Routine Description:

    This routine is called from the SCSI port driver to send a
    command to controller or target.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PCHIP_CONFIG    chipConfig;
    PSCB            scb;
    REQP            reqp;
    short           status;
    asc_queue_t     *waitq;

    ASC_DBG(3, "HwStartIo: begin\n");

    scb = &SRB2SCB(srb);
    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    waitq = &HDE2WAIT(HwDeviceExtension);

    switch (srb->Function) {

    case SRB_FUNCTION_ABORT_COMMAND:
        ASC_DBG1(1, "HwStartIo: Abort srb %x \n", srb->NextSrb);
        ASC_DBG1(1, "chipConfig %x\n", chipConfig);

        if (asc_rmqueue(waitq, srb->NextSrb) == ASC_TRUE)
        {
            srb->NextSrb->SrbStatus = SRB_STATUS_ABORTED;
            ScsiPortNotification(RequestComplete, HwDeviceExtension,
                                    srb->NextSrb);
        } else if (status = (AscAbortSRB(chipConfig,
                    (ulong) srb->NextSrb )) == 1) {
            ASC_DBG(2, "Abort Success\n");
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else {
            ASC_DBG(1, "Abort error!\n");
            srb->SrbStatus = SRB_STATUS_ABORT_FAILED;
        }

        /*
         * Call AscISR() to process all requests completed by the
         * microcode and then call AscCompleteRequest() to complete
         * these requests to the OS. If AscAbortSRB() succeeded,
         * then one of the requests completed will include the
         * aborted SRB.
         */
        (void) AscISR(chipConfig);
        AscCompleteRequest(HwDeviceExtension);

        /* Complete srb */
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_RESET_BUS:
        //
        // Reset SCSI bus.
        //
        ASC_DBG(1, "HwStartIo: Reset Bus\n");
        HwResetBus(chipConfig, 0L);
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_EXECUTE_SCSI:

        ASC_DBG(3, "HwStartIo: Execute SCSI\n");
        /*
         * Set the srb's Device Extension pointer before attempting
                 * to start the IO. It will be needed for any retrys and in
                 * DvcISRCallBack().
         */
        SRB2HDE(srb) = HwDeviceExtension;
        SRB2RETRY(srb)=ASC_RETRY_CNT;
        /* Execute any queued commands for the host adapter. */
        if (waitq->tidmask) {
            asc_execute_queue(waitq);
        }

        /*
         * If the target for the current command has any queued
         * commands or if trying to execute the command returns
         * BUSY, then enqueue the command.
         */
        if ((waitq->tidmask & ASC_TIX_TO_TARGET_ID(srb->TargetId)) ||
            (AscExecuteIO(srb) == ASC_BUSY)) {
            asc_enqueue(waitq, srb, ASC_BACK);
        }

        return TRUE;

    case SRB_FUNCTION_RESET_DEVICE:
        ASC_DBG1(1, "HwStartIo: Reset device: %d\n", srb->TargetId);

                while ((reqp = asc_dequeue(waitq, srb->TargetId)) != NULL)
                {
                        reqp->SrbStatus = SRB_STATUS_BUS_RESET;
                        ScsiPortNotification(RequestComplete,
                            HwDeviceExtension, reqp);
                }

        AscResetDevice(chipConfig, ASC_TIDLUN_TO_IX(srb->TargetId,
                    srb->Lun));

                /*
                 * Call AscISR() to process all requests completed by the
                 * microcode and then call AscCompleteRequest() to complete
                 * these requests to the OS. If AscAbortSRB() succeeded,
                 * then one of the requests completed will include the
                 * aborted SRB.
                 */
                (void) AscISR(chipConfig);
                AscCompleteRequest(HwDeviceExtension);

        srb->SrbStatus = SRB_STATUS_SUCCESS;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_SHUTDOWN:
        /*
         * Shutdown - HwAdapterControl() ScsiStopAdapter performs
         * all needed shutdown of the adapter.
         */
        ASC_DBG(1, "HwStartIo: SRB_FUNCTION_SHUTDOWN\n");
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    default:
        //
        // Set error, complete request
        // and signal ready for next request.
        //
        ASC_DBG1(1, "HwStartIo: Function %x: invalid request\n", srb->Function);
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    } // end switch
    /* NOTREACHED */
} /* HwStartIo() */

BOOLEAN
HwInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This is the interrupt service routine for the SCSI adapter.
    It reads the interrupt register to determine if the adapter is indeed
    the source of the interrupt and clears the interrupt at the device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:


--*/
{
    PCHIP_CONFIG              chipConfig;
    PSCB                      pscb, tpscb;
    int                       retstatus;
    int                       status;
    PSCSI_REQUEST_BLOCK       srb;
    asc_queue_t               *waitq;

    ASC_DBG(3, "HwInterrupt: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    if (AscIsIntPending(chipConfig->iop_base) == ASC_FALSE) {
        retstatus = FALSE;
        ASC_DBG(4, "HwInterrupt: AscIsIntPending() FALSE\n");
    } else {
        retstatus = TRUE;
        do {
            switch (status = AscISR(chipConfig)) {
            case ASC_TRUE:
                ASC_DBG(3, "HwInterrupt: AscISR() TRUE\n");
                break;
            case ASC_FALSE:
                ASC_DBG(3, "HwInterrupt: AscISR() FALSE\n");
                break;
            case ASC_ERROR:
            default:
                ASC_DBG2(1,
                    "HwInterrupt: AscISR() ERROR status %d, err_code %d\n",
                        status, chipConfig->err_code);
                break;
            }
        } while (AscIsIntPending(chipConfig->iop_base) == ASC_TRUE);
    }

    /*
     * Execute any waiting requests.
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        asc_execute_queue(waitq);
    }

    /*
     * Complete I/O requests queued in DvcISRCallBack();
     */
    AscCompleteRequest(HwDeviceExtension);

    ASC_DBG1(3, "HwInterrupt: end %d\n", retstatus);

    return (BOOLEAN)retstatus;
} // end HwInterrupt()

SCSI_ADAPTER_CONTROL_STATUS
HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
/*++

Routine Description:

    HwAdapterControl() interface added in NT 5.0 for
        Plug and Play/Power Management.

Arguments:

    DeviceExtension
    ControlType
        Parameters

Return Value:

    SCSI_ADAPTER_CONTROL_STATUS.

--*/
{
    PCHIP_CONFIG                chipConfig = &HDE2CONFIG(HwDeviceExtension);
    PHW_DEVICE_EXTENSION        deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    asc_queue_t                 *waitq;
    REQP                        reqp;
    int                         i;
    USHORT                      initstat;

    switch (ControlType)
    {
    //
    // Query Adapter.
    //
    case ScsiQuerySupportedControlTypes:
        ASC_DBG(2, "HwAdapterControl: ScsiQuerySupportControlTypes\n");

        ControlTypeList =
            (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;
        if (ControlTypeList->MaxControlType < ScsiStopAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 1\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiStopAdapter] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiSetRunningConfig)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 2\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiSetRunningConfig] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiRestartAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 3\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiRestartAdapter] = TRUE;

        ASC_DBG(1, "HwAdapterControl: ScsiAdapterControlSuccess\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Stop Adapter.
    //
    case ScsiStopAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiStopAdapter\n");

        /*
         * Complete any waiting requests.
         */
        if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask)
        {
            for (i = 0; i <= ASC_MAX_TID; i++)
            {
                while ((reqp = asc_dequeue(waitq, i)) != NULL)
                {
                    reqp->SrbStatus = SRB_STATUS_ABORTED;
                    ScsiPortNotification(RequestComplete, HwDeviceExtension,
                        reqp);
                }
            }
        }

        //
        // Disable interrupts and halt the chip.
        //
        AscDisableInterrupt(chipConfig->iop_base);

        if (AscResetChip(chipConfig->iop_base) == 0)
        {
            ASC_DBG(1, "HwAdapterControl: ScsiStopdapter Unsuccessful\n");
            return ScsiAdapterControlUnsuccessful;
        } else
        {
            ASC_DBG(2, "HwAdapterControl: ScsiStopdapter Success\n");
            return ScsiAdapterControlSuccess;
        }
        /* NOTREACHED */

    //
    // ScsiSetRunningConfig.
    //
    // Called before ScsiRestartAdapter. Can use ScsiPort[Get|Set]BusData.
    //
    case ScsiSetRunningConfig:
        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig\n");

        /*
         * Execute Asc Library initialization.
         */
        if ((initstat = AscInitGetConfig(chipConfig)) != 0) {
            ASC_DBG1(1, "AscInitGetConfig: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AscInitGetConfig: err_code code %x\n",
                chipConfig->err_code);
            return(SP_RETURN_ERROR);
        } else {
            ASC_DBG(2, "AscInitGetConfig: successful\n");
        }

        if ((initstat = AscInitSetConfig(chipConfig)) != 0) {
            ASC_DBG1(1, "AscInitSetConfig: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AscInitSetConfig: err_code code %x\n",
                chipConfig->err_code);
            return(SP_RETURN_ERROR);
        } else {
            ASC_DBG(2, "AscInitSetConfig: successful\n");
        }

        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig successful\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Restart Adapter.
    //
    // Cannot use ScsiPort[Get|Set]BusData.
    //
    case ScsiRestartAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter\n");

        chipConfig->cfg->overrun_buf = deviceExtension->inquiryBuffer;

        if ((initstat = AscInitAsc1000Driver(chipConfig)) != 0)
        {
            ASC_DBG1(1,
                "AscInitAsc1000Driver: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AscInitAsc1000Driver: err_code code %x\n",
                chipConfig->err_code);
            return ScsiAdapterControlUnsuccessful;
        } else {
            ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter success\n");
            return ScsiAdapterControlSuccess;
        }
        /* NOTREACHED */

    //
    // Unsupported Control Operation.
    //
    default:
        return ScsiAdapterControlUnsuccessful;
        /* NOTREACHED */
    }
    /* NOTREACHED */
}

VOID
BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )

/*++

Routine Description:

    Build SCB for Library routines.

Arguments:

    DeviceExtension
    SRB

Return Value:

    Nothing.

--*/

{
    PSCB            scb;
    PCHIP_CONFIG    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    ULONG           length, xferLength, remainLength;
    ULONG           virtualAddress;
    UCHAR           i;

    //
    // Set target id and LUN.
    //
    scb = &SRB2SCB(srb);    /* scb is part of the srb */
    AscZeroMemory((PUCHAR) scb, sizeof(SCB));
    SCB2SRB(scb) = srb;
    scb->sg_head = (ASC_SG_HEAD *) &SRB2SDL(srb);
    AscZeroMemory((PUCHAR) scb->sg_head, sizeof(SDL));
    ASC_ASSERT(SCB2HDE(scb) == HwDeviceExtension);

    scb->q1.target_lun = srb->Lun;
    scb->q1.target_id = ASC_TID_TO_TARGET_ID(srb->TargetId & 0x7);
    scb->q2.target_ix = ASC_TIDLUN_TO_IX(srb->TargetId & 0x7, srb->Lun);

    //
    // Check if tag queueing enabled. Our host adapter will support
    // tag queuing anyway. However, we will use OS's tag action if
    // available. chip_no is used to store whether the device support
    // tag queuing or not, each target per bit.
    //

    if (srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE ) {
        scb->q2.tag_code = srb->QueueAction;
    } else {
        scb->q2.tag_code = M2_QTAG_MSG_SIMPLE ;
    }

    //
    // Set CDB length and copy to CCB.
    //

    scb->q2.cdb_len = (UCHAR)srb->CdbLength;
    scb->cdbptr = (uchar *) &( srb->Cdb );

    scb->q1.data_cnt = srb->DataTransferLength;

    //
    // Build SDL in SCB if data transfer. Scatter gather list
    // array is allocated per request basis. The location is
    // assigned right after SCB in SrbExtension.
    //

    i = 0;

    // Assume no data transfer

    scb->q1.cntl = 0 ;

    if (srb->DataTransferLength > 0) {

        scb->q1.cntl = QC_SG_HEAD ;
        scb->sg_head->entry_cnt = 0;
        xferLength = srb->DataTransferLength;
        virtualAddress = (ulong) srb->DataBuffer;
        remainLength = xferLength;

        //
        // Build scatter gather list
        //

        do {
            scb->sg_head->sg_list[i].addr = (ulong)
                ScsiPortConvertPhysicalAddressToUlong(
                    ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                    (PVOID) virtualAddress, &length));

            if ( length > remainLength ) {
                length = remainLength;
            }
            scb->sg_head->sg_list[i].bytes = length;

            ASC_DBG1(4, "Transfer Data Buffer logical %lx\n", virtualAddress);
            ASC_DBG1(4, "Transfer Data Length            %lx\n", length);
            ASC_DBG1(4, "Transfer Data Buffer physical %lx\n",
                scb->sg_head->sg_list[i].addr);
            //
            // Calculate next virtual address and remaining byte count
            //
            virtualAddress += length;

            if(length >= remainLength) {
                remainLength = 0;
            } else {
                remainLength -= length;
            }
            i++;
        } while ( remainLength > 0);

        scb->sg_head->entry_cnt = i;
    }

    //
    // Convert sense buffer length and buffer into physical address
    //

    if (srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE ) {
        scb->q1.sense_len = 0;
    } else {
        ASC_DBG1(3, "srb->senseLength %x\n", srb->SenseInfoBufferLength);
        ASC_DBG1(3, "srb->sensePtr    %x\n", srb->SenseInfoBuffer);
        scb->q1.sense_len = (uchar) srb->SenseInfoBufferLength;
        if (srb->SenseInfoBufferLength > 0) {
            scb->q1.sense_addr =
                    ScsiPortConvertPhysicalAddressToUlong(
                    ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                    srb->SenseInfoBuffer, &length));
        }
        //
        // Sense buffer can not be scatter-gathered
        //
        if ( srb->SenseInfoBufferLength > length ) {
                ASC_DBG(1, "Sense Buffer Overflow to next page.\n");
            scb->q1.sense_len = (uchar) length;
        }
    }
    return;
} // end BuildScb()

BOOLEAN
HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
    )

/*++

Routine Description:

    Reset SCSI bus.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PCHIP_CONFIG    chipConfig;
    REQP            reqp;
    asc_queue_t     *waitq;
    int             i;
    int             retstatus;

    ASC_DBG(1, "HwResetBus: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    /*
     * Complete all waiting requests.
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            while ((reqp = asc_dequeue(waitq, i)) != NULL) {
                reqp->SrbStatus = SRB_STATUS_BUS_RESET;
                ScsiPortNotification(RequestComplete, HwDeviceExtension, reqp);
            }
        }
    }

    /*
     * Perform the bus reset.
     */
    retstatus = AscResetSB(chipConfig);
    ASC_DBG1(2, "HwResetBus: AscResetSB() retstatus %d\n", retstatus);

    /*
     * Call AscISR() to process all requests completed by the
     * microcode and then call AscCompleteRequest() to complete
     * these requests to the OS.
     */
    (void) AscISR(chipConfig);
    AscCompleteRequest(HwDeviceExtension);

    /*
     * Complete all pending requests to the OS.
     *
     * All requests that have been sent to the microcode should have been
     * completed by the call to AscResetSB(). In case there were requests
     * that were misplaced by the microcode and not completed, use the
     * SRB_STATUS_BUS_RESET function with no TID and LUN to clear all
     * pending requests.
     */
ScsiPortCompleteRequest(HwDeviceExtension,
        (UCHAR) PathId,
        SP_UNTAGGED,
        SP_UNTAGGED,
        SRB_STATUS_BUS_RESET);

    return (BOOLEAN)retstatus;
} // end HwResetBus()

//
// Following are the routines required by Asc1000 library. These
// routine will be called from Asc1000 library.
//

void
DvcDisplayString(
    uchar *string
    )
/*++

Routine Description:

    This routine is required for Asc Library. Since NT mini
    port does not display anything, simply provide a dummy routine.

--*/
{
    ASC_DBG1(2, "%s", string);
}

int
DvcEnterCritical(
    void
    )
/*++

    This routine claims critical section. In NT, the OS will handle
    it properly, we simply provide a dummy routine to make Asc1000
    library happy.

--*/
{
    return TRUE;
}

void
DvcLeaveCritical(
    int myHandle
    )
/*++

    This routine exits critical section. In NT, the OS will handle
    it properly, we simply provide a dummy routine to make Asc1000
    library happy.

--*/
{
}

VOID
DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_QDONE_INFO *scbDoneInfo
    )

/*++

Routine Description:

    Callback routine for interrupt handler.

Arguments:

    chipConfig - Pointer to chip configuration structure
    scbDoneInfo - Pointer to a structure contains information about
        the scb just completed

Return Value:

--*/
{
    asc_queue_t       *waitq;
    ASC_REQ_SENSE     *sense;
    uchar             underrun = FALSE;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) chipConfig;
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK) scbDoneInfo->d2.srb_ptr;
    PSCB *ppscb;

    ASC_DBG2(3, "DvcISRCallBack: chipConfig %x, srb %x\n", chipConfig, srb);

    if (srb == NULL) {
        ASC_DBG(1, "DvcISRCallBack: srb is NULL\n");
        return;
    }

    ASC_DBG1(3, "DvcISRCallBack: %X bytes requested\n",
        srb->DataTransferLength);

    ASC_DBG1(3, "DvcISRCallBack: %X bytes remaining\n",
        scbDoneInfo->remain_bytes);
#if DBG
    if (scbDoneInfo->remain_bytes != 0) {
        ASC_DBG2(1, "DvcISRCallBack: underrun/overrun: remain %X, request %X\n",
            scbDoneInfo->remain_bytes, srb->DataTransferLength);
    }
#endif /* DBG */

    //
    // Set Underrun Status in the SRB.
    //
    // If 'DataTransferlength' is set to a non-zero value when
    // the SRB is returned and the SRB_STATUS_DATA_OVERRUN flag
    // is set, then an Underrun condition is indicated. There is
    // no separate SrbStatus flag to indicate an Underrun condition.
    //
    if (srb->DataTransferLength != 0 && scbDoneInfo->remain_bytes != 0 &&
        scbDoneInfo->remain_bytes <= srb->DataTransferLength)
    {
        srb->DataTransferLength -= scbDoneInfo->remain_bytes;
        underrun = TRUE;
    }

    if (scbDoneInfo->d3.done_stat == QD_NO_ERROR) {
        //
        // Command sucessfully completed
        //
        if (underrun == TRUE)
        {
            //
            // Set Underrun Status in the SRB.
            //
            // If 'DataTransferlength' is set to a non-zero value when
            // the SRB is returned and the SRB_STATUS_DATA_OVERRUN flag
            // is set, then an Underrun condition is indicated. There
            // is no separate SrbStatus flag to indicate an Underrun
            // condition.
            //
            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
        } else
        {
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

        //
        // If an INQUIRY command successfully completed, then call
        // the AscInquiryHandling() function.
        //
        if (srb->Cdb[0] == SCSICMD_Inquiry && srb->Lun == 0 &&
            srb->DataTransferLength >= 8)
        {
            AscInquiryHandling(chipConfig,
                (uchar) (srb->TargetId & 0x7),
                (ASC_SCSI_INQUIRY *) srb->DataBuffer);
        }

        srb->ScsiStatus = 0;

        ASC_DBG(3, "DvcISRCallBack: QD_NO_ERROR\n");

#if DBG
        if (SRB2RETRY(srb) < ASC_RETRY_CNT)
        {
            ASC_DBG2(3,
                 "DvcISRCallBack: srb retry success: srb %x, retry %d\n",
                 srb, SRB2RETRY(srb));
        }
#endif /* DBG */
    } else {

        ASC_DBG4(2,
            "DvcISRCallBack: id %d, done_stat %x, scsi_stat %x, host_stat %x\n",
            ASC_TIX_TO_TID(scbDoneInfo->d2.target_ix),
            scbDoneInfo->d3.done_stat, scbDoneInfo->d3.scsi_stat,
            scbDoneInfo->d3.host_stat);

        /* Notify NT of a Bus Reset */
        if (scbDoneInfo->d3.host_stat == QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {
            ASC_DBG(1, "DvcISRCallBack: QHSTA_M_HUNG_REQ_SCSI_BUS_RESET\n");
            ScsiPortNotification(ResetDetected, HwDeviceExtension);
        }
        if (scbDoneInfo->d3.done_stat == QD_ABORTED_BY_HOST) {
            //
            // Command aborted by host
            //
            ASC_DBG(2, "DvcISRCallBack: QD_ABORTED_BY_HOST\n");
            srb->SrbStatus = SRB_STATUS_ABORTED;
            srb->ScsiStatus = 0;
        } else if (scbDoneInfo->d3.scsi_stat != SS_GOOD)
        {
            ASC_DBG(1, "DvcISRCallBack: scsi_stat != SS_GOOD\n");
            //
            // Set ScsiStatus for SRB
            //
            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = scbDoneInfo->d3.scsi_stat;

            //
            // Treat a SCSI Status Byte of BUSY status as a special case
            // in setting the 'SrbStatus' field. STI (Still Image Capture)
            // drivers need this 'SrbStatus', because the STI interface does
            // not include the 'ScsiStatus' byte. These drivers must rely
            // on the 'SrbStatus' field to determine when the target device
            // returns BUSY.
            //
            if (scbDoneInfo->d3.scsi_stat == SS_TARGET_BUSY)
            {
                srb->SrbStatus = SRB_STATUS_BUSY;
            }
            else if ((scbDoneInfo->d3.host_stat == 0) &&
                     (scbDoneInfo->d3.scsi_stat == SS_CHK_CONDITION))
            {
                srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                ASC_DBG1(2,
                    "DvcISRCallBack: srb %x, SRB_STATUS_AUTOSENSE_VALID\n",
                    srb);

                sense = (ASC_REQ_SENSE *)  srb->SenseInfoBuffer;
#if DBG
                if (sense->sense_key == SCSI_SENKEY_MEDIUM_ERR)
                {
                    ASC_DBG2(2,
        "DvcISRCallBack: check condition with medium error: cdb %x retry %d\n",
                        srb->Cdb[0], SRB2RETRY(srb));
                }
#endif /* DBG */
                /*
                 * Perform up to ASC_RETRY_CNT retries for Medium Errors
                 * on Write-10 (0x2A), Write-6 (0x0A), Write-Verify (0x2E),
                 * and Verify (0x2F) commands.
                 */
                if (sense->sense_key == SCSI_SENKEY_MEDIUM_ERR &&
                    (srb->Cdb[0] == 0x2A || srb->Cdb[0] == 0x0A ||
                     srb->Cdb[0] == 0x2E || srb->Cdb[0] == 0x2F) &&
                    SRB2RETRY(srb)-- > 0)
                {
                    ASC_DBG1(2, "DvcISRCallBack: doing retry srb %x\n", srb);
                    waitq = &HDE2WAIT(HwDeviceExtension);
                    /*
                     * Because a retry is being done if
                     * an underrun occured, then restore
                     * 'DataTransferLength' to its original
                     * value so the retry will use the
                     * correct 'DataTransferLength' value.
                     */
                    if (underrun == TRUE)
                    {
                       srb->DataTransferLength += scbDoneInfo->remain_bytes;
                    }
                    if (AscExecuteIO(srb) == ASC_BUSY)
                    {
                        ASC_DBG(2, "DvcISRCallBack: busy - retry queued\n");
                        asc_enqueue(waitq, srb, ASC_FRONT);
                    }
                    else {
                        ASC_DBG(2, "DvcISRCallBack: retry started\n");
                    }
                    return;
                }
            }
        } else {
            //
            // Scsi Status is ok, but host status is not
            //
            srb->SrbStatus = ErrXlate(scbDoneInfo->d3.host_stat);
            srb->ScsiStatus = 0;
        }
    }

#if DBG_SRB_PTR
    /* Check the integrity of the done list. */
    if (*(ppscb = &HDE2DONE(HwDeviceExtension)) != NULL) {
        if (SCB2SRB(*ppscb) == NULL) {
            ASC_DBG1(1, "DvcISRCallBack: SCB2SRB() is NULL 1, *ppscb %x\n",
                *ppscb);
            DbgBreakPoint();
        }
        for (; *ppscb; ppscb = &SCB2PSCB(*ppscb)) {
            if (SCB2SRB(*ppscb) == NULL) {
                ASC_DBG1(1, "DvcISRCallBack: SCB2SRB() is NULL 2, *ppscb %x\n",
                    *ppscb);
                DbgBreakPoint();
            }
        }
    }
#endif /* DBG_SRBPTR */

    /*
     * Add the SCB to end of the completion list. The request will be
     * completed in HwInterrupt().
     */
    for (ppscb = &HDE2DONE(HwDeviceExtension); *ppscb;
         ppscb = &SCB2PSCB(*ppscb)) {
        ;
    }
    *ppscb = &SRB2SCB(srb);
    SRB2PSCB(srb) = NULL;

    return;
}

UCHAR
ErrXlate (UCHAR ascErrCode)

/*++

Routine Description:

    This routine translate Library status into SrbStatus which
    is requried by NT

Arguments:

    ascErrCode - Error code defined by host_stat

Return Value:

    Error code defined by NT SCSI port driver

--*/


{
    switch (ascErrCode) {

    case QHSTA_M_SEL_TIMEOUT:
        return ( SRB_STATUS_SELECTION_TIMEOUT );

    case QHSTA_M_DATA_OVER_RUN:
        return ( SRB_STATUS_DATA_OVERRUN );

    case QHSTA_M_UNEXPECTED_BUS_FREE:
        return ( SRB_STATUS_UNEXPECTED_BUS_FREE );

    case QHSTA_D_HOST_ABORT_FAILED:
        return ( SRB_STATUS_ABORT_FAILED );

    case QHSTA_M_HUNG_REQ_SCSI_BUS_RESET:
        return ( SRB_STATUS_BUS_RESET );

    //
    // Don't know what to report
    //

    default:
        return ( SRB_STATUS_TIMEOUT );

    }
}

/*
 * Description: search EISA host adapter
 *
 * - search starts with iop_base equals zero( 0 )
 *
 * return i/o port address found ( non-zero )
 * return 0 if not found
 */
PortAddr
HwSearchIOPortAddrEISA(
                PortAddr iop_base,
                IN PVOID HwDE,
                IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
            )
{
    ulong eisa_product_id ;
    PVOID new_base ;
    PVOID prodid_base ;
    ushort product_id_high, product_id_low ;

    if( iop_base == 0 ) {
        iop_base = ASC_EISA_MIN_IOP_ADDR ;
    }/* if */
    else {
        if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
        if( ( iop_base & 0x0050 ) == 0x0050 ) {
                iop_base += ASC_EISA_BIG_IOP_GAP ; /* when it is 0zC50 */
        }/* if */
        else {
                iop_base += ASC_EISA_SMALL_IOP_GAP ; /* when it is 0zC30 */
        }/* else */
    }/* else */
    while( iop_base <= ASC_EISA_MAX_IOP_ADDR )
    {
        //
        // Validate range:
        //
        if (ScsiPortValidateRange(HwDE,
            Cfg->AdapterInterfaceType,
            Cfg->SystemIoBusNumber,
            ScsiPortConvertUlongToPhysicalAddress(iop_base),
            16,
            TRUE))
        {
            //
            // First obtain the EISA product ID for the current slot.
            //
            new_base = ScsiPortGetDeviceBase(HwDE,
                Cfg->AdapterInterfaceType,
                Cfg->SystemIoBusNumber,
                ScsiPortConvertUlongToPhysicalAddress(
                   ASC_GET_EISA_SLOT( iop_base ) | ASC_EISA_PID_IOP_MASK),
                4,
                TRUE);

            if (new_base == NULL)
            {
                eisa_product_id = 0;
            } else
            {
                product_id_low = inpw( new_base) ;
                product_id_high = inpw( ((ushort *) new_base) + 2 ) ;
                eisa_product_id = ( ( ulong)product_id_high << 16 ) |
                    ( ulong )product_id_low ;
                ScsiPortFreeDeviceBase(HwDE, new_base);
            }

            //
            // Map the address
            //
            new_base = ScsiPortGetDeviceBase(HwDE,
                Cfg->AdapterInterfaceType,
                Cfg->SystemIoBusNumber,
                ScsiPortConvertUlongToPhysicalAddress(iop_base),
                16,
                TRUE);

            /*
             * search product id first
             */
            if (new_base != NULL)
            {
                if( ( eisa_product_id == ASC_EISA_ID_740 ) ||
                    ( eisa_product_id == ASC_EISA_ID_750 ) ) {
                    if( AscFindSignature( (PortAddr)new_base ) ) {
                        /*
                         * chip found, clear ID left in latch
                         * to clear, read any i/o port word that doesn't
                         * contain data 0x04c1 iop_base plus four should do it
                         */
                        inpw( ((PortAddr)new_base)+4 ) ;
                        ScsiPortFreeDeviceBase(HwDE, new_base);
                        return( iop_base ) ;
                    }/* if */
                }/* if */
                ScsiPortFreeDeviceBase(HwDE, new_base);
            }
        }/* if */
        if( iop_base == ASC_EISA_MAX_IOP_ADDR ) return( 0 ) ;
        if( ( iop_base & 0x0050 ) == 0x0050 ) {
                iop_base += ASC_EISA_BIG_IOP_GAP ;
        }/* if */
        else {
            iop_base += ASC_EISA_SMALL_IOP_GAP ;
        }/* else */
    }/* while */
    return( 0 ) ;
}

/*
 * Description: Search for VL and ISA host adapters (at 9 default addresses).
 *
 * Return 0 if not found.
 */
PortAddr
HwSearchIOPortAddr11(
                PortAddr s_addr,
                IN PVOID HwDE,
                IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
            )
{
    /*
     * VL, ISA
     */
    int     i ;
    PortAddr iop_base ;
    PVOID new_base ;

    for( i = 0 ; i < ASC_IOADR_TABLE_MAX_IX ; i++ ) {
        if( _asc_def_iop_base[ i ] > s_addr ) {
            break ;
        }/* if */
    }/* for */
    for( ; i < ASC_IOADR_TABLE_MAX_IX ; i++ ) {
        iop_base = _asc_def_iop_base[ i ] ;
        //
        // Validate range:
        //
        if (!ScsiPortValidateRange(HwDE,
            Cfg->AdapterInterfaceType,
            Cfg->SystemIoBusNumber,
            ScsiPortConvertUlongToPhysicalAddress(iop_base),
            16,
            TRUE))
        {
            continue;               // No good, skip this one
        }
        //
        // Map the address
        //
        new_base = ScsiPortGetDeviceBase(HwDE,
            Cfg->AdapterInterfaceType,
            Cfg->SystemIoBusNumber,
            ScsiPortConvertUlongToPhysicalAddress(iop_base),
            16,
            TRUE);

        if( AscFindSignature( (PortAddr)new_base ) ) {
            ScsiPortFreeDeviceBase(HwDE, new_base);
            return( iop_base ) ;
        }/* if */
        ScsiPortFreeDeviceBase(HwDE, new_base);
    }/* for */
    return( 0 ) ;
}

/*
 * Description: Search for VL and ISA host adapters.
 *
 * Return 0 if not found.
 */
PortAddr
HwSearchIOPortAddr(
                PortAddr iop_beg,
                ushort bus_type,
                IN PVOID HwDE,
                IN OUT PPORT_CONFIGURATION_INFORMATION Cfg
            )
{
    if( bus_type & ASC_IS_VL ) {
        while( ( iop_beg = HwSearchIOPortAddr11( iop_beg, HwDE, Cfg ) ) != 0 ) {
            if( AscGetChipVersion( iop_beg, bus_type ) <=
                ASC_CHIP_MAX_VER_VL ) {
            return( iop_beg ) ;
            }/* if */
        }/* if */
        return( 0 ) ;
    }/* if */
    if( bus_type & ASC_IS_ISA ) {
        while( ( iop_beg = HwSearchIOPortAddr11( iop_beg, HwDE, Cfg ) ) != 0 ) {
            if( ( AscGetChipVersion( iop_beg, bus_type ) &
                ASC_CHIP_VER_ISA_BIT ) != 0 ) {
            return( iop_beg ) ;
            }/* if */
        }/* if */
        return( 0 ) ;
    }/* if */
    if( bus_type & ASC_IS_EISA ) {
        if( ( iop_beg = HwSearchIOPortAddrEISA( iop_beg, HwDE, Cfg ) ) != 0 ) {
            return( iop_beg ) ;
        }/* if */
        return( 0 ) ;
    }/* if */
    return( 0 ) ;
}

ULONG
PCIGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG SystemIoBusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return ScsiPortGetBusData(
                   DeviceExtension,
                   PCIConfiguration,
                   SystemIoBusNumber,
                   SlotNumber.u.AsULONG,
                   Buffer,
                   Length);

}

/*
 * Complete all requests on the adapter done list by
 * DvcISRCallBack().
 */
void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    )
{
    PSCB                pscb, tpscb;
    PSCSI_REQUEST_BLOCK srb;

    /*
     * Return if the done list is empty.
     */
    if ((pscb = HDE2DONE(HwDeviceExtension)) == NULL) {
        ASC_DBG(4, "AscCompleteRequest: adapter scb_done == NULL\n");
        return;
    }

    HDE2DONE(HwDeviceExtension) = NULL;

    /*
     * Interrupts could now be enabled during the SRB callback
     * without adversely affecting the driver.
     */
    while (pscb) {
        tpscb = SCB2PSCB(pscb);
        SCB2PSCB(pscb) = NULL;
        srb = SCB2SRB(pscb);
        ASC_DBG2(4,
            "AscCompleteRequest: RequestComplete: srb 0x%lx, scb 0x%lx\n",
            srb, pscb);
        ASC_ASSERT(SRB2HDE(srb) != NULL);
        ScsiPortNotification(RequestComplete, SRB2HDE(srb), srb);
        pscb = tpscb;
    }
}

/*
 * Add a 'REQP' to the end of specified queue. Set 'tidmask'
 * to indicate a command is queued for the device.
 *
 * 'flag' may be either ASC_FRONT or ASC_BACK.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
void
asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
{
    REQP    *reqpp;
    int     tid;

    ASC_DBG3(3, "asc_enqueue: ascq %x, reqp %x, flag %d\n", ascq, reqp, flag);
    tid = REQPTID(reqp);
    ASC_ASSERT(flag == ASC_FRONT || flag == ASC_BACK);
    if (flag == ASC_FRONT) {
        REQPNEXT(reqp) = ascq->queue[tid];
        ascq->queue[tid] = reqp;
    } else { /* ASC_BACK */
        for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
            ASC_ASSERT(ascq->tidmask & ASC_TIX_TO_TARGET_ID(tid));
            ;
        }
        *reqpp = reqp;
        REQPNEXT(reqp) = NULL;
    }
    /* The queue has at least one entry, set its bit. */
    ascq->tidmask |= ASC_TIX_TO_TARGET_ID(tid);
    ASC_DBG1(2, "asc_enqueue: reqp %x\n", reqp);
    return;
}

/*
 * Return first queued 'REQP' on the specified queue for
 * the specified target device. Clear the 'tidmask' bit for
 * the device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
REQP
asc_dequeue(asc_queue_t *ascq, int tid)
{
    REQP    reqp;

    ASC_DBG2(3, "asc_dequeue: ascq %x, tid %d\n", ascq, tid);
    if ((reqp = ascq->queue[tid]) != NULL) {
        ASC_ASSERT(ascq->tidmask & ASC_TIX_TO_TARGET_ID(tid));
        ascq->queue[tid] = REQPNEXT(reqp);
        /* If the queue is empty, clear its bit. */
        if (ascq->queue[tid] == NULL) {
            ascq->tidmask &= ~ASC_TIX_TO_TARGET_ID(tid);
        }
    }
    ASC_DBG1(2, "asc_dequeue: reqp %x\n", reqp);

    return reqp;
}

/*
 * Remove the specified 'REQP' from the specified queue for
 * the specified target device. Clear the 'tidmask' bit for the
 * device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's the next pointer.
 *
 * Return ASC_TRUE if the command was found and removed,
 * otherwise return ASC_FALSE.
 */
int
asc_rmqueue(asc_queue_t *ascq, REQP reqp)
{
    REQP            *reqpp;
    int             tid;
    int             ret;

    ret = ASC_FALSE;
    tid = REQPTID(reqp);
    for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
        ASC_ASSERT(ascq->tidmask & ASC_TIX_TO_TARGET_ID(tid));
        if (*reqpp == reqp) {
            ret = ASC_TRUE;
            *reqpp = REQPNEXT(reqp);
            REQPNEXT(reqp) = NULL;
            /* If the queue is now empty, clear its bit. */
            if (ascq->queue[tid] == NULL) {
                ascq->tidmask &= ~ASC_TIX_TO_TARGET_ID(tid);
            }
            break; /* Note: *reqpp may now be NULL; don't iterate. */
        }
    }
    ASC_DBG2(3, "asc_rmqueue: reqp %x, ret %d\n", reqp, ret);

    return ret;
}

/*
 * Execute as many queued requests as possible for the specified queue.
 *
 * Calls AscExecuteIO() to execute a REQP.
 */
void
asc_execute_queue(asc_queue_t *ascq)
{
    ASC_SCSI_BIT_ID_TYPE    scan_tidmask;
    REQP                    reqp;
    int                     i;

    ASC_DBG1(2, "asc_execute_queue: ascq %x\n", ascq);
    /*
     * Execute queued commands for devices attached to
     * the current board in round-robin fashion.
     */
    scan_tidmask = ascq->tidmask;
    do {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            if (scan_tidmask & ASC_TIX_TO_TARGET_ID(i)) {
                if ((reqp = asc_dequeue(ascq, i)) == NULL) {
                    scan_tidmask &= ~ASC_TIX_TO_TARGET_ID(i);
                } else if (AscExecuteIO(reqp) == ASC_BUSY) {
                    scan_tidmask &= ~ASC_TIX_TO_TARGET_ID(i);
                    /* Put the request back at front of the list. */
                    asc_enqueue(ascq, reqp, ASC_FRONT);
                }
            }
        }
    } while (scan_tidmask);
    return;
}

VOID
DvcSleepMilliSecond(
    ulong i
    )
/*++

    This routine delays i msec as required by Asc Library.

--*/

{
    ulong j;
    for (j=0; j <i; j++)
        ScsiPortStallExecution(1000L);
}

/*
 * Delay for specificed number of nanoseconds.
 *
 * Granularity is 1 microsecond.
 */
void
DvcDelayNanoSecond(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong nano_sec
          )
{
       ulong    micro_sec;

       if ((micro_sec = nano_sec/1000) == 0)
       {
           micro_sec = 1;
       }
       ScsiPortStallExecution(micro_sec);
}

ULONG
DvcGetSGList(
    PCHIP_CONFIG chipConfig,
    uchar *bufAddr,
    ulong   xferLength,
    ASC_SG_HEAD *ascSGHead
)
/*++

    This routine is used to create a Scatter Gather for low level
    driver during device driver initialization

--*/

{
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) chipConfig;
    ulong   virtualAddress, uncachedStart, length;

    ASC_DBG(4, "DvcGetSGlist: begin\n");

    virtualAddress = (ulong) bufAddr;
    uncachedStart = (ulong) HwDeviceExtension->inquiryBuffer;

    ascSGHead->sg_list[0].addr = (ulong)
    ScsiPortConvertPhysicalAddressToUlong(
    ScsiPortGetPhysicalAddress(HwDeviceExtension,
                    NULL,
                    (PVOID) HwDeviceExtension->inquiryBuffer,
                    &length));

    ASC_DBG1(4, "Uncached Start Phys    = %x\n", ascSGHead->sg_list[0].addr);
    ASC_DBG1(4, "Uncached Start Length = %x\n", length);

    ascSGHead->sg_list[0].addr += (virtualAddress - uncachedStart);
    ascSGHead->sg_list[0].bytes = xferLength;
    ascSGHead->entry_cnt = 1;

    ASC_DBG1(4, "Uncached Start = %x\n", uncachedStart);
    ASC_DBG1(4, "Virtual Addr    = %x\n", virtualAddress);

    ASC_DBG1(4, "Segment 0: Addr = %x\n", ascSGHead->sg_list[0].addr);
    ASC_DBG1(4, "Segment 0: Leng = %x\n", ascSGHead->sg_list[0].bytes);

    ASC_DBG1(4, "DvcGetSGlist: xferLength %d\n", xferLength);
    return( xferLength );
}

void
DvcInPortWords( PortAddr iop, ushort dosfar *buff, int count)
{
    while (count--)
    {
        *(buff++) = ScsiPortReadPortUshort( (PUSHORT)iop );
    }
}

void
DvcOutPortWords( PortAddr iop, ushort dosfar *buff, int count)
{
    while (count--)
    {
        ScsiPortWritePortUshort( (PUSHORT)iop, *(buff++) );
    }
}

void
DvcOutPortDWords( PortAddr iop, ulong dosfar *buff, int count)
{
    DvcOutPortWords(iop, (PUSHORT)buff, count*2);
}

int
DvcDisableCPUInterrupt ( void )
{
    return(0);
}

void
DvcRestoreCPUInterrupt ( int state)
{
    return;
}

//
//  Input a configuration byte.
//
uchar
DvcReadPCIConfigByte(
    ASC_DVC_VAR asc_ptr_type *asc_dvc,
    ushort offset )
{
    PCI_COMMON_CONFIG   pciCommonConfig;
    PCI_SLOT_NUMBER     SlotNumber;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    SlotNumber.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);

    (void) PCIGetBusData(
        (PVOID) asc_dvc,            // HwDeviceExtension
    (ULONG) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), // Bus Number
        SlotNumber,                 // slot number
        &pciCommonConfig,           // Buffer
        sizeof(PCI_COMMON_CONFIG)   // Length
        );

    return(*((PUCHAR)(&pciCommonConfig) + offset));
}

//
//  Output a configuration byte.
//
void
DvcWritePCIConfigByte(
    ASC_DVC_VAR asc_ptr_type *asc_dvc,
    ushort offset,
    uchar  byte_data )
{
    PCI_SLOT_NUMBER     SlotNumber;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    SlotNumber.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);


    //
    // Write it out
    //
    (void) ScsiPortSetBusDataByOffset(
    (PVOID)asc_dvc,                         // HwDeviceExtension
    PCIConfiguration,                       // Bus type
    (ULONG) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), // Bus Number
    SlotNumber.u.AsULONG,                   // Device and function
    &byte_data,                                     // Buffer
        offset,                                 // Offset
        1                                       // Length
        );
}

/*
 * Zero memory starting at 'cp' for 'length' bytes.
 */
VOID
AscZeroMemory(UCHAR *cp, ULONG length)
{
    ULONG i;

    for (i = 0; i < length; i++)
    {
        *cp++ = 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascbios.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ascbios.h
**
**  Definition file for BIOS.
*/

#ifndef __ASC_BIOS_H_
#define __ASC_BIOS_H_

/* ------------------------------------------------------------------------
**       Structure defined for BIOS INT 13h, function 12h
** --------------------------------------------------------------------- */

typedef struct Bios_Info_Block {
        uchar    AdvSig[4] ;      /* 0    Signature                                          */
        uchar    productID[8] ;   /* 4    Product ID                                         */
        ushort   BiosVer ;        /* 12   BIOS Version                                       */
        PortAddr iopBase ;        /* 14 IO port address                                      */
        ushort   underBIOSMap ;   /* 16 Drive map - Under BIOS control                       */
        uchar    numOfDrive ;     /* 18 Num of drive under BIOS control for this controller  */
        uchar    startDrive ;     /* 19 Starting drive number under this BIOS control        */
        ushort   extTranslation ; /* 20 extended translation enable                          */
} BIOS_INFO_BLOCK ;


#define CTRL_A         0x1E01

#define BIOS_VER       0x0100  /* 1.00 */

#endif /* #ifndef __ASC_BIOS_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc.h ===
/*++

 Copyright (c) 1994-1998 Advanced System Products, Inc.
 All Rights Reserved.

Module Name:

    asc.h

Abstract:

    This module contains the structures, specific to the Advansys
    host bus adapter, used by the SCSI miniport driver. Data structures
    that are part of standard ANSI SCSI will be defined in a header
    file that will be available to all SCSI device drivers.

--*/


//
// Scatter/Gather Segment List Definitions
//


//
// Adapter limits
//

#define MAX_SG_DESCRIPTORS ASC_MAX_SG_LIST
#define MAX_TRANSFER_SIZE  (MAX_SG_DESCRIPTORS - 1) * 4096


//
// Device extension
//

#define CHIP_CONFIG     ASC_DVC_VAR
#define PCHIP_CONFIG ASC_DVC_VAR *

#define CHIP_INFO       ASC_DVC_CFG
#define PCHIP_INFO      ASC_DVC_CFG *

#define NONCACHED_EXTENSION     256

/*
 * Generalized waiting and active request queuing.
 */

/*
 * Implementation specific definitions.
 *
 * REQ and REQP are the generic name for a SCSI request block and pointer.
 * REQPNEXT(reqp) returns reqp's next pointer.
 * REQPTID(reqp) returns reqp's target id.
 */
typedef SCSI_REQUEST_BLOCK      REQ, *REQP;
#define REQPNEXT(reqp)          ((REQP) SRB2PSCB((SCSI_REQUEST_BLOCK *) (reqp)))
#define REQPTID(reqp)           ((reqp)->TargetId)

/* asc_enqueue() flags */
#define ASC_FRONT               1
#define ASC_BACK                2

typedef struct asc_queue {
  ASC_SCSI_BIT_ID_TYPE  tidmask;              /* queue mask */
  REQP                  queue[ASC_MAX_TID+1]; /* queue linked list */
} asc_queue_t;

void                            asc_enqueue(asc_queue_t *, REQP, int);
REQP                            asc_dequeue(asc_queue_t *, int);
int                             asc_rmqueue(asc_queue_t *, REQP);
void                            asc_execute_queue(asc_queue_t *);


//
// Scatter/Gather Segment Descriptor Definition
//
typedef ASC_SCSI_Q SCB, *PSCB;

typedef struct _SGD {
	ULONG   Length;
	ULONG   Address;
} SGD, *PSGD;

typedef struct _SDL {
   ushort               sg_entry_count;
   ushort               q_count;
   ASC_SG_LIST sg_list[MAX_SG_DESCRIPTORS];
} SDL, *PSDL;

#define SEGMENT_LIST_SIZE         MAX_SG_DESCRIPTORS * sizeof(SGD)

/*
 * Hardware Device Extenstion Definition
 */
typedef struct _HW_DEVICE_EXTENSION {
	CHIP_CONFIG     chipConfig;
	CHIP_INFO       chipInfo;                                        
	PVOID           inquiryBuffer;
	asc_queue_t     waiting;        /* Waiting command queue */
	PSCB            done;           /* Done list for adapter */
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

/* Macros for accessing HW Device Extension structure fields. */
#define HDE2CONFIG(hde)         (((PHW_DEVICE_EXTENSION) (hde))->chipConfig)
#define HDE2WAIT(hde)           (((PHW_DEVICE_EXTENSION) (hde))->waiting)
#define HDE2DONE(hde)           (((PHW_DEVICE_EXTENSION) (hde))->done)

//
// SRB Extenstion
//
typedef struct _SRB_EXTENSION {
   SCB                    scb;    /* SCSI command block */
   SDL                    sdl;    /* scatter gather descriptor list */
   PSCB                   pscb;   /* next pointer for scb singly linked list */
   PHW_DEVICE_EXTENSION   dext;   /* device extension pointer */
   int                    retry;  /* retry counter */
} SRB_EXTENSION, *PSRB_EXTENSION;

/* Macros for accessing SRB Extension structure fields. */
#define SRB2SCB(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->scb)
#define SRB2SDL(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->sdl)
#define SRB2PSCB(srb)   (((PSRB_EXTENSION) ((srb)->SrbExtension))->pscb)
#define SRB2HDE(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->dext)
#define SRB2RETRY(srb)  (((PSRB_EXTENSION) ((srb)->SrbExtension))->retry)
#define SCB2SRB(scb)    ((PSCSI_REQUEST_BLOCK) ((scb)->q2.srb_ptr))
/* srb_ptr must be valid to use the following macros */
#define SCB2PSCB(scb)   (SRB2PSCB(SCB2SRB(scb)))
#define SCB2HDE(scb)    (SRB2HDE(SCB2SRB(scb)))

//
// Write retry count
//
#define ASC_RETRY_CNT   4


//
// Starting base IO address for ASC10xx chip
//

#define ASC_BEGIN_IO_ADDR       0x00
#define ASC_NEXT_PORT_INCREMENT 0x10

//
//  PCI Definitions
//
#define ASC_PCI_VENDOR_ID       0x10CD
#define ASC_PCI_DEVICE_ID       0x1100
#define ASC_PCI_DEVICE_ID2      0x1200
#define ASC_PCI_DEVICE_ID3      0x1300

#define PCI_MAX_BUS                             (16)

//
// Port Search structure:
//
typedef struct _SRCH_CONTEXT                    // Port search context
{
	PORT_ADDR                lastPort;      // Last port searched
	ULONG                    PCIBusNo;      // Last PCI Bus searched
	ULONG                    PCIDevNo;      // Last PCI Device searched
} SRCH_CONTEXT, *PSRCH_CONTEXT;


//
// ASC library return status
//
#define ASC_SUCCESS     0


//
// GetChipInfo returned status
//

#define ASC_INIT_FAIL           0x1
#define ASC_ERR_IOP_ROTATE      0x2
#define ASC_ERR_EEP_CHKSUM      0x3
#define ASC_ERR_EEPROM_WRITE    0x4

//
// GetChipInfo returned status
//

#define ASC_PUTQ_BUSY                   0x1
#define ASC_PUTQ_ERR                    0x2

//
// ASC RESET command

#define RESET_BUS       0

//
// Structure containing bus dependant constants
//
typedef struct _BUS_INFO
{
    ushort              BusType;            // Our library bus type
    INTERFACE_TYPE      NTType;             // NT's bus type
    BOOLEAN             DMA32Bit;           // T/F Supports 32 bit dma.
    KINTERRUPT_MODE     IntMode;            // Level or edge triggered.
} BUS_INFO, *PBUS_INFO;

/*
 * Asc Library Definitions
 */
#define ASC_TRUE                1
#define ASC_FALSE               0
#define ASC_NOERROR             1
#define ASC_BUSY                0
#define ASC_ERROR               (-1)

/*
 * Debug/Tracing Macros
 */
#if DBG == 0

#define ASC_DBG(lvl, s)
#define ASC_DBG1(lvl, s, a1)
#define ASC_DBG2(lvl, s, a1, a2)
#define ASC_DBG3(lvl, s, a1, a2, a3)
#define ASC_DBG4(lvl, s, a1, a2, a3, a4)
#define ASC_ASSERT(a)

#else /* DBG */

/*
 * Windows NT Debugging
 *
 * NT Debug Message Levels:
 *  1: Errors Only
 *  2: Information
 *  3: Function Tracing
 *  4: Arcane Information
 */

#define ASC_DBG(lvl, s) \
                    DebugPrint(((lvl), (s)))

#define ASC_DBG1(lvl, s, a1) \
                    DebugPrint(((lvl), (s), (a1)))

#define ASC_DBG2(lvl, s, a1, a2) \
                    DebugPrint(((lvl), (s), (a1), (a2)))

#define ASC_DBG3(lvl, s, a1, a2, a3) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3)))

#define ASC_DBG4(lvl, s, a1, a2, a3, a4) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3), (a4)))

#define ASC_ASSERT(a) \
    { \
        if (!(a)) { \
            DebugPrint((1, "ASC_ASSERT() Failure: file %s, line %d\n", \
                __FILE__, __LINE__)); \
        } \
    }
#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascdep.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** ascdep.h
**
*/

#ifndef __ASCDEP_H_
#define __ASCDEP_H_

/* -----------------------------------------------------------------
** Chip Dependent definition
**
** ASC_CHIP_VERSION == 1
**
** ASC_CHIP_VERSION == 2
**
** 1. status is 16 bits (
** 2. IRQ is in CHIP Configuration registers
** 3.
** 4.
** 5.
**
**  VL   - ASC_CHIP_VERSION=3  ( version 1 and 2 should not be used )
**  PCI  - ASC_CHIP_VERSION=9
**  ISA  - ASC_CHIP_VERSION=17 ( 0x11 )
**  EISA - ASC_CHIP_VERSION=35 ( 0x23, use VL version 3 )
**
** ASC_CHIP_VERSION number
** VL   - 3  to 7
** PCI  - 9  to 15
** ISA  - 17 to 23
** ISAPNP - 33 to 39
** EISA - 65 to 71
**
** -------------------------------------------------------------- */

/*
** Some compiler default setting
*/
#ifndef CC_TARGET_MODE
#define CC_TARGET_MODE         FALSE  /* enable target mode ( processor device ) */
#endif /* CC_TARGET_MODE */

#ifndef CC_STRUCT_ALIGNED
#define CC_STRUCT_ALIGNED      FALSE
#endif /* CC_STRUCT_ALIGNED */

#ifndef CC_LITTLE_ENDIAN_HOST
#define CC_LITTLE_ENDIAN_HOST  TRUE   /* host is little-endian machine, Example: IBM PC with Intel CPUs */
#endif /* CC_LITTLE_ENDIAN_HOST */

#ifndef CC_TEST_LRAM_ENDIAN
#define CC_TEST_LRAM_ENDIAN    FALSE
#endif /* if CC_TEST_LRAM_ENDIAN not defined */

#ifndef CC_MEMORY_MAPPED_IO
#define CC_MEMORY_MAPPED_IO    FALSE
#endif /* CC_MEMORY_MAPPIO */

#ifndef CC_WRITE_IO_COUNT
#define CC_WRITE_IO_COUNT      FALSE
#endif

#ifndef CC_CLEAR_DMA_REMAIN
#define CC_CLEAR_DMA_REMAIN    FALSE
#endif

#ifndef CC_ASC_SCSI_Q_USRDEF
#define CC_ASC_SCSI_Q_USRDEF         FALSE
#endif

#ifndef CC_ASC_SCSI_REQ_Q_USRDEF
#define CC_ASC_SCSI_REQ_Q_USRDEF     FALSE
#endif

#ifndef CC_ASCISR_CHECK_INT_PENDING
#define CC_ASCISR_CHECK_INT_PENDING  TRUE  /* ADVW32.386 and PowerPC SIM set this false */
#endif

#ifndef CC_CHK_FIX_EEP_CONTENT
#define CC_CHK_FIX_EEP_CONTENT       TRUE
#endif

#ifndef CC_CHK_AND_COALESCE_SG_LIST
#define CC_CHK_AND_COALESCE_SG_LIST  FALSE
#endif


#ifndef CC_DISABLE_PCI_PARITY_INT
#define CC_DISABLE_PCI_PARITY_INT    TRUE  /* turn CFG_MSW bit 0 - 5 off */
#endif                                     /* generate h/w interrupt if error */

#ifndef CC_PCI_ADAPTER_ONLY
#define CC_PCI_ADAPTER_ONLY          FALSE  /* PowerMac SIM set this TRUE to reduce code size */
#endif

#ifndef CC_INCLUDE_EEP_CONFIG
#define CC_INCLUDE_EEP_CONFIG        TRUE  /* PowerMac SIM set this FALSE */
#endif

#ifndef CC_INIT_INQ_DISPLAY
#define CC_INIT_INQ_DISPLAY          FALSE
#endif

#ifndef CC_INIT_TARGET_TEST_UNIT_READY
#define CC_INIT_TARGET_TEST_UNIT_READY  TRUE  /* PowerMac SIM set this FALSE */
#endif

#ifndef CC_INIT_TARGET_READ_CAPACITY
#define CC_INIT_TARGET_READ_CAPACITY  FALSE
#endif

#if CC_INIT_TARGET_TEST_UNIT_READY
#ifndef CC_INIT_TARGET_START_UNIT
#define CC_INIT_TARGET_START_UNIT       TRUE  /* PowerMac SIM set this FALSE */
#endif /* CC_INIT_TARGET_START_UNIT */
#else
#ifndef CC_INIT_TARGET_START_UNIT
#define CC_INIT_TARGET_START_UNIT       FALSE
#endif /* CC_INIT_TARGET_START_UNIT */
#endif

#ifndef CC_USE_AscResetSB
#define CC_USE_AscResetSB            TRUE
#endif

#ifndef CC_USE_AscResetDevice
#define CC_USE_AscResetDevice        TRUE
#endif

#ifndef CC_USE_AscAbortSRB
#define CC_USE_AscAbortSRB           TRUE
#endif

#ifndef CC_USE_DvcSetMemory
#define CC_USE_DvcSetMemory          FALSE
#endif

#ifndef CC_USE_DvcCopyMemory
#define CC_USE_DvcCopyMemory         FALSE
#endif

/*
 * Warning: Using this option may result in a stack overrun.
 * If this option is set TRUE AscISRCheckQDone() calls from
 * the interrupt handler AscStartUnit() to start another I/O.
 */
#ifndef CC_USE_AscISR_CheckQDone
#define CC_USE_AscISR_CheckQDone     FALSE
#endif

#ifndef CC_USE_AscSearchIOPortAddr100
#define CC_USE_AscSearchIOPortAddr100  FALSE
#endif

#ifndef CC_POWER_SAVER
#define CC_POWER_SAVER               FALSE
#endif

#ifndef CC_INIT_CLEAR_ASC_DVC_VAR
#define CC_INIT_CLEAR_ASC_DVC_VAR    TRUE
#endif

#ifndef CC_CHECK_RESTORE_LRAM_ADDR
#define CC_CHECK_RESTORE_LRAM_ADDR   FALSE
#endif

#ifndef CC_TEST_RW_LRAM
#define CC_TEST_RW_LRAM              FALSE
#endif

#ifndef CC_PCI_ULTRA
#define CC_PCI_ULTRA                 TRUE  /* include ultra scsi code or not */
#endif

#ifndef CC_PLEXTOR_VL
#define CC_PLEXTOR_VL                FALSE /* IRQ 14 routed to IRQ 9 */
#endif

#ifndef CC_INCLUDE_EISA
#define CC_INCLUDE_EISA              TRUE
#endif

#ifndef CC_INCLUDE_VL
#define CC_INCLUDE_VL                TRUE
#endif

#ifndef CC_TMP_USE_EEP_SDTR
#define CC_TMP_USE_EEP_SDTR          FALSE
#endif

#ifndef CC_CHK_COND_REDO_SDTR
#define CC_CHK_COND_REDO_SDTR        TRUE
#endif

#ifndef CC_SET_PCI_CONFIG_SPACE
#define CC_SET_PCI_CONFIG_SPACE  TRUE
#endif

#ifndef CC_FIX_QUANTUM_XP34301_1071
#define CC_FIX_QUANTUM_XP34301_1071  FALSE
#endif

#ifndef CC_CHECK_MCODE_SIZE_AT_COMPILE
#define CC_CHECK_MCODE_SIZE_AT_COMPILE  FALSE
#endif

#ifndef CC_DISABLE_PCI_BURST_MODE
#define CC_DISABLE_PCI_BURST_MODE  FALSE
#endif

#ifndef CC_INIT_SCSI_TARGET
#define CC_INIT_SCSI_TARGET TRUE
#endif

#define ASC_CS_TYPE  unsigned short

/*
** Normal DOS, pointer to  ASC_DVC_VAR is near
** windows need far pointer to ASC_DVC_VAR
*/
#ifndef asc_ptr_type
#define asc_ptr_type
#endif

#ifndef CC_SCAM
#define CC_SCAM  FALSE
#endif

#ifndef ASC_GET_PTR2FUNC
#define ASC_GET_PTR2FUNC( fun )  ( Ptr2Func )( fun )
#endif

/* flip high/low nibbles of a byte */
#define FLIP_BYTE_NIBBLE( x )    ( ((x<<4)& 0xFF) | (x>>4) )

/* -----------------------------------------------------------------
**
** -------------------------------------------------------------- */

/*
**
**  bit definition for asc_dvc->bus_type
**
*/
#define ASC_IS_ISA          (0x0001)
#define ASC_IS_ISAPNP       (0x0081)
#define ASC_IS_EISA         (0x0002)
#define ASC_IS_PCI          (0x0004)
#define ASC_IS_PCI_ULTRA    (0x0104)
#define ASC_IS_PCMCIA       (0x0008)
/* #define ASC_IS_PNP          (0x0010)  */ /* plug and play support */
#define ASC_IS_MCA          (0x0020)
#define ASC_IS_VL           (0x0040)

/*
** ISA plug and play
*/
#define ASC_ISA_PNP_PORT_ADDR  (0x279) /* printer status port, PNP address port */
#define ASC_ISA_PNP_PORT_WRITE (ASC_ISA_PNP_PORT_ADDR+0x800)
                    /* printer status port + 0x800, PNP write data port */

#define ASC_IS_WIDESCSI_16  (0x0100)
#define ASC_IS_WIDESCSI_32  (0x0200)

#define ASC_IS_BIG_ENDIAN   (0x8000) /* default is always Intel convention ( little endian ) */
                                     /* */
/* ---------------------------------------------- */
#define ASC_CHIP_MIN_VER_VL      (0x01)
#define ASC_CHIP_MAX_VER_VL      (0x07)

#define ASC_CHIP_MIN_VER_PCI     (0x09) /* 9, bit 4 set */
#define ASC_CHIP_MAX_VER_PCI     (0x0F) /* 15 */
#define ASC_CHIP_VER_PCI_BIT     (0x08) /* */

#define ASC_CHIP_MIN_VER_ISA     (0x11) /* 17, bit 5 set */
#define ASC_CHIP_MIN_VER_ISA_PNP (0x21) /* bit 6 set */
#define ASC_CHIP_MAX_VER_ISA     (0x27) /* 39 */
#define ASC_CHIP_VER_ISA_BIT     (0x30) /* */
#define ASC_CHIP_VER_ISAPNP_BIT  (0x20) /* */

#define ASC_CHIP_VER_ASYN_BUG    (0x21) /* This version of ISA has async xfer problem */

/*
 * PCI ULTRA Chip Revision Number Definitions
 *
 * Chip Revision Number - Bank 0, Base Address + 3
 */
#define ASC_CHIP_VER_PCI             0x08
#define ASC_CHIP_VER_PCI_ULTRA_3150  (ASC_CHIP_VER_PCI | 0x02)
#define ASC_CHIP_VER_PCI_ULTRA_3050  (ASC_CHIP_VER_PCI | 0x03)

/*
** Note: EISA has same version number as VL
**       the number generated is VL_version + ( ASC_CHIP_MIN_VER_EISA - 1 )
**       a VL version 3 chip when calling AscGetChipVersion()
**       will return version number 35
*/
#define ASC_CHIP_MIN_VER_EISA (0x41) /* 65, bit 7 set */
#define ASC_CHIP_MAX_VER_EISA (0x47) /* 71 */
#define ASC_CHIP_VER_EISA_BIT (0x40) /* */
#define ASC_CHIP_LATEST_VER_EISA   ( ( ASC_CHIP_MIN_VER_EISA - 1 ) + 3 )

#define ASC_MAX_LIB_SUPPORTED_ISA_CHIP_VER   0x21 // new ISA PNP start from 0x21
#define ASC_MAX_LIB_SUPPORTED_PCI_CHIP_VER   0x0A // PCI ultra starts from 0x0a

/* ---------------------------------------------- */
#define ASC_MAX_VL_DMA_ADDR     (0x07FFFFFFL)  /* 27 bit address = 128 MB */
#define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)

#define ASC_MAX_PCI_DMA_ADDR    (0xFFFFFFFFL)  /* 32 bit address = 4GB */
#define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)

#define ASC_MAX_ISA_DMA_ADDR    (0x00FFFFFFL)  /* 24 bit address = 16 MB */
#define ASC_MAX_ISA_DMA_COUNT   (0x00FFFFFFL)

#define ASC_MAX_EISA_DMA_ADDR   (0x07FFFFFFL)  /* 27 bit address = 128 MB */
#define ASC_MAX_EISA_DMA_COUNT  (0x07FFFFFFL)

#if !CC_STRUCT_ALIGNED

#define DvcGetQinfo( iop_base, s_addr, outbuf, words)  \
        AscMemWordCopyFromLram( iop_base, s_addr, outbuf, words)


#define DvcPutScsiQ( iop_base, s_addr, outbuf, words) \
        AscMemWordCopyToLram( iop_base, s_addr, outbuf, words)

#endif  /* if struct packing */

/*
**
*/
#ifdef ASC_CHIP_VERSION

/* #error defining ASC_CHIP_VERSION is no longer required ! */

#endif

/*
** ==========================================================================
*/
#if CC_MEMORY_MAPPED_IO

/*
** Macro for memory mapped i/o
*/
#define inp( port )            *( (uchar *)(port) )
#define outp( port, data )     *( (uchar *)(port) ) = ( uchar )( data )

/* #define inp( pb )              ( *( uchar  *)(pb) ) */
/* #define outp( pb, val_byte )   *( uchar  * )(pb) = (val_byte) */

#if CC_LITTLE_ENDIAN_HOST

#define inpw( port )              *( (ushort *)(port) )
#define outpw( port, data )       *( (ushort *)(port) ) = ( ushort )( data )

#else

/*
**
**  wordswap( word_val ) is a function that exchanges high/lower bytes of a word
**  that is word_val of 0x1234 retuns 0x3412
**
**  Warning:
**  the function should be inplemented as a function
**  to avoid i/o port being referenced more than once in macro
**
*/

#define inpw( port )             EndianSwap16Bit( (*((ushort *)(port))) )
#define outpw( port, data )      *( (ushort *)(port) ) = EndianSwap16Bit( (ushort)(data) )

#define inpw_noswap( port )          *( (ushort *)(port) )
#define outpw_noswap( port, data )   *( (ushort *)(port) ) = ( ushort )( data )

#endif /* CC_LITTLE_ENDIAN_HOST */

#endif /* CC_MEMORY_MAPPED_IO */


#ifndef inpw_noswap
#define inpw_noswap( port )         inpw( port )
#endif

#ifndef outpw_noswap
#define outpw_noswap( port, data )  outpw( port, data )
#endif

#endif /* __ASCDEP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascinc.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ascinc.h
**
*/

#ifndef __ASCINC_H_
#define __ASCINC_H_

#include "ascdef.h"
#include "a_osdep.h"   /* os dependent */
#include "a_cc.h"      /* code generation control */
#include "ascdep.h"    /* chip dependent include file  */
#include "ascsidef.h"  /* ASC SCSI definition          */
#include "aspiq.h"     /* ASC QUEUE                    */

/* #include "aaspidef.h" */

#include "asc1000.h"
#include "asclib.h"

#include "a_ddlib.h"

#endif /* #ifndef __ASCINC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascdef.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ascdef.h
**
*/

#ifndef __ASCDEF_H_
#define __ASCDEF_H_

#ifndef __USRDEF_H_

typedef unsigned char   uchar ;
typedef unsigned short  ushort ;
typedef unsigned int    uint ;
typedef unsigned long   ulong ;

typedef unsigned char   BYTE ;
typedef unsigned short  WORD ;
typedef unsigned long   DWORD ;

#ifndef BOOL
typedef int             BOOL ;
#endif

#ifndef NULL
#define NULL     (0)          /* zero          */
#endif

#define  REG     register

#define rchar    REG char
#define rshort   REG short
#define rint     REG int
#define rlong    REG long

#define ruchar   REG uchar
#define rushort  REG ushort
#define ruint    REG uint
#define rulong   REG ulong

#define NULLPTR   ( void *)0   /* null pointer  */
#define FNULLPTR  ( void dosfar *)0UL   /* Far null pointer  */
#define EOF      (-1)         /* end of file   */
#define EOS      '\0'         /* end of string */
#define ERR      (-1)         /* boolean error */
#define UB_ERR   (uchar)(0xFF)         /* unsigned byte error */
#define UW_ERR   (uint)(0xFFFF)        /* unsigned word error */
#define UL_ERR   (ulong)(0xFFFFFFFFUL)   /* unsigned long error */

#define iseven_word( val )  ( ( ( ( uint )val) & ( uint )0x0001 ) == 0 )
#define isodd_word( val )   ( ( ( ( uint )val) & ( uint )0x0001 ) != 0 )
#define toeven_word( val )  ( ( ( uint )val ) & ( uint )0xFFFE )

#define biton( val, bits )   ((( uint )( val >> bits ) & (uint)0x0001 ) != 0 )
#define bitoff( val, bits )  ((( uint )( val >> bits ) & (uint)0x0001 ) == 0 )
#define lbiton( val, bits )  ((( ulong )( val >> bits ) & (ulong)0x00000001UL ) != 0 )
#define lbitoff( val, bits ) ((( ulong )( val >> bits ) & (ulong)0x00000001UL ) == 0 )

  /* convert signed short word to unsigned short word */
#define  absh( val )    ( ( val ) < 0 ? -( val ) : ( val ) )
  /* swap high nibble and lower nibble of a byte */
#define  swapbyte( ch )  ( ( ( (ch) << 4 ) | ( (ch) >> 4 ) ) )

/*
** common sizes
*/
#ifndef GBYTE
#define GBYTE       (0x40000000UL)
#endif

#ifndef MBYTE
#define MBYTE       (0x100000UL)
#endif

#ifndef KBYTE
#define KBYTE       (0x400)
#endif

#define HI_BYTE(x) ( *( ( BYTE *)(&x)+1 ) )  /* Returns high byte of word */
#define LO_BYTE(x) ( *( ( BYTE *)&x ) )      /* Returns low byte of word */

/* added 18 Nov 1993, Jim Nelson */

#define HI_WORD(x) ( *( ( WORD *)(&x)+1 ) )
#define LO_WORD(x) ( *( ( WORD *)&x ) )

#ifndef MAKEWORD
#define MAKEWORD(lo, hi)    ((WORD) (((WORD) lo) | ((WORD) hi << 8)))
#endif

#ifndef MAKELONG
#define MAKELONG(lo, hi)    ((DWORD) (((DWORD) lo) | ((DWORD) hi << 16)))
#endif

#define SwapWords(dWord)        ((DWORD) ((dWord >> 16) | (dWord << 16)))
#define SwapBytes(word)         ((WORD) ((word >> 8) | (word << 8)))

/*
** big-endian to little-endian and back conversions
*/
#define BigToLittle(dWord) \
    ((DWORD) (SwapWords(MAKELONG(SwapBytes(LO_WORD(dWord)), SwapBytes(HI_WORD(dWord))))))
#define LittleToBig(dWord)      BigToLittle(dWord)

/* end JN */

#endif /* #ifndef __USRDEF_H_ */


/* --------------------------------------------------------------------
** PCI CONFIG SPACE
**
**   typedef struct
**   {
**       WORD        vendorID;
**       WORD        deviceID;
**       WORD        command;
**       WORD        status;
**       BYTE        revision;
**       BYTE        classCode[3];
**       BYTE        cacheSize;
**       BYTE        latencyTimer;
**       BYTE        headerType;
**       BYTE        BIST;
**       DWORD       baseAddress[6];
**       WORD        reserved[4];
**       DWORD       optionRomAddr;
**       WORD        reserved2[4];
**       BYTE        irqLine;
**       BYTE        irqPin;
**       BYTE        minGnt;
**       BYTE        maxLatency;
**   } PCI_CONFIG_SPACE;
**
** ------------------------------------------------------------------ */

/*
 * PCI Configuration Space Offsets
 */
#define AscPCIConfigVendorIDRegister      0x0000 /* 1 word */
#define AscPCIConfigDeviceIDRegister      0x0002 /* 1 word */
#define AscPCIConfigCommandRegister       0x0004 /* 1 word */
#define AscPCIConfigStatusRegister        0x0006 /* 1 word */
#define AscPCIConfigRevisionIDRegister    0x0008 /* 1 byte */
#define AscPCIConfigCacheSize             0x000C /* 1 byte */
#define AscPCIConfigLatencyTimer          0x000D /* 1 byte */
#define AscPCIIOBaseRegister              0x0010

#define AscPCICmdRegBits_IOMemBusMaster   0x0007

/*
 * Device Driver Macros
 */
#define ASC_PCI_ID2BUS( id )    ((id) & 0xFF)
#define ASC_PCI_ID2DEV( id )    (((id) >> 11) & 0x1F)
#define ASC_PCI_ID2FUNC( id )   (((id) >> 8) & 0x7)

#define ASC_PCI_MKID( bus, dev, func ) \
     ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))


/*
 * AdvanSys PCI Constants
 */

/* PCI Vendor ID */
#define ASC_PCI_VENDORID                  0x10CD

/* PCI Device IDs */
#define ASC_PCI_DEVICEID_1200A            0x1100      /* SCSI FAST Rev A */
#define ASC_PCI_DEVICEID_1200B            0x1200      /* SCSI FAST Rev B */
#define ASC_PCI_DEVICEID_ULTRA            0x1300      /* SCSI ULTRA */

/*
 * PCI ULTRA Revision IDs
 *
 * AdvanSys ULTRA ICs are differentiated by their PCI Revision ID.
 */
#define ASC_PCI_REVISION_3150             0x02        /* SCSI ULTRA 3150 */
#define ASC_PCI_REVISION_3050             0x03        /* SCSI ULTRA 3050 */


/*
**
** device driver function call return type
**
*/
#define  Asc_DvcLib_Status   int

#define  ASC_DVCLIB_CALL_DONE     (1)  // operation performed
#define  ASC_DVCLIB_CALL_FAILED   (0)  // operation not ferformed
#define  ASC_DVCLIB_CALL_ERROR    (-1) // operation


#endif /* #ifndef __ASCDEF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\ascsidef.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: ASCSIDEF.H
**
*/

#ifndef __ASCSIDEF_H_
#define __ASCSIDEF_H_

/* --------------------------------------------------------------------
** SCSI definition file
**
**
** ------------------------------------------------------------------ */

#define ASC_SCSI_ID_BITS  3   /* bit width of scsi id */
#define ASC_SCSI_TIX_TYPE     uchar
#define ASC_ALL_DEVICE_BIT_SET  0xFF

/* --------------------------------------------------------- */
#ifdef ASC_WIDESCSI_16

#undef  ASC_SCSI_ID_BITS
#define ASC_SCSI_ID_BITS  4
#define ASC_ALL_DEVICE_BIT_SET  0xFFFF

#endif /* if is 16 bit wide scsi */

/* --------------------------------------------------------- */
#ifdef ASC_WIDESCSI_32

#undef  ASC_SCSI_ID_BITS
#define ASC_SCSI_ID_BITS  5
#define ASC_ALL_DEVICE_BIT_SET  0xFFFFFFFFL

#endif /* if is 32 bit wide scsi */

/*
**
*/
#if ASC_SCSI_ID_BITS == 3

#define ASC_SCSI_BIT_ID_TYPE  uchar /* default is byte for 8 bit SCSI bus */
#define ASC_MAX_TID       7
#define ASC_MAX_LUN       7
#define ASC_SCSI_WIDTH_BIT_SET  0xFF

/*
** if is 16 bit wide scsi
*/
#elif ASC_SCSI_ID_BITS == 4

#define ASC_SCSI_BIT_ID_TYPE   ushort
#define ASC_MAX_TID         15
#define ASC_MAX_LUN         7
#define ASC_SCSI_WIDTH_BIT_SET  0xFFFF

/*
** if is 32 bit wide scsi
*/
#elif ASC_SCSI_ID_BITS == 5

#define ASC_SCSI_BIT_ID_TYPE    ulong
#define ASC_MAX_TID         31
#define ASC_MAX_LUN         7
#define ASC_SCSI_WIDTH_BIT_SET  0xFFFFFFFF

#else

#error  ASC_SCSI_ID_BITS definition is wrong

#endif

#define ASC_MAX_SENSE_LEN   32
#define ASC_MIN_SENSE_LEN   14

#define ASC_MAX_CDB_LEN     12 /* maximum command descriptor block */

/* --------------------------------------------------------------
**
** -------------------------------------------------------------*/
#define SCSICMD_TestUnitReady     0x00
#define SCSICMD_Rewind            0x01
#define SCSICMD_Rezero            0x01
#define SCSICMD_RequestSense      0x03
#define SCSICMD_Format            0x04
#define SCSICMD_FormatUnit        0x04
#define SCSICMD_Read6             0x08
#define SCSICMD_Write6            0x0A
#define SCSICMD_Seek6             0x0B
#define SCSICMD_Inquiry           0x12
#define SCSICMD_Verify6           0x13
#define SCSICMD_ModeSelect6       0x15
#define SCSICMD_ModeSense6        0x1A

#define SCSICMD_StartStopUnit     0x1B
#define SCSICMD_LoadUnloadTape    0x1B
#define SCSICMD_ReadCapacity      0x25
#define SCSICMD_Read10            0x28
#define SCSICMD_Write10           0x2A
#define SCSICMD_Seek10            0x2B
#define SCSICMD_Erase10           0x2C
#define SCSICMD_WriteAndVerify10  0x2E
#define SCSICMD_Verify10          0x2F

#define SCSICMD_WriteBuffer       0x3B
#define SCSICMD_ReadBuffer        0x3C
#define SCSICMD_ReadLong          0x3E
#define SCSICMD_WriteLong         0x3F

#define SCSICMD_ReadTOC           0x43
#define SCSICMD_ReadHeader        0x44

#define SCSICMD_ModeSelect10      0x55
#define SCSICMD_ModeSense10       0x5A

/* -------------------------------------------------------------
** peripheral device type
** ---------------------------------------------------------- */
#define SCSI_TYPE_DASD     0x00
#define SCSI_TYPE_SASD     0x01
#define SCSI_TYPE_PRN      0x02
#define SCSI_TYPE_PROC     0x03 /* processor device type */
                                /* HP scanner return this type too */

#define SCSI_TYPE_WORM     0x04 /* some CD-R too */
#define SCSI_TYPE_CDROM    0x05
#define SCSI_TYPE_SCANNER  0x06
#define SCSI_TYPE_OPTMEM   0x07
#define SCSI_TYPE_MED_CHG  0x08
#define SCSI_TYPE_COMM     0x09
#define SCSI_TYPE_UNKNOWN  0x1F
#define SCSI_TYPE_NO_DVC   0xFF


#define ASC_SCSIDIR_NOCHK    0x00
        /* Direction determined by SCSI command, length not check */
#define ASC_SCSIDIR_T2H      0x08
        /* Transfer from SCSI Target to Host adapter, length check */
#define ASC_SCSIDIR_H2T      0x10
        /* Transfer from Host adapter to Target, length check  */
#define ASC_SCSIDIR_NODATA   0x18
        /* No data transfer */

/* -------------------------------------------------------------
** SENSE KEY
** ---------------------------------------------------------- */
#define SCSI_SENKEY_NO_SENSE      0x00
#define SCSI_SENKEY_UNDEFINED     0x01
#define SCSI_SENKEY_NOT_READY     0x02
#define SCSI_SENKEY_MEDIUM_ERR    0x03
#define SCSI_SENKEY_HW_ERR        0x04
#define SCSI_SENKEY_ILLEGAL       0x05
#define SCSI_SENKEY_ATTENTION     0x06
#define SCSI_SENKEY_PROTECTED     0x07
#define SCSI_SENKEY_BLANK         0x08
#define SCSI_SENKEY_V_UNIQUE      0x09
#define SCSI_SENKEY_CPY_ABORT     0x0A
#define SCSI_SENKEY_ABORT         0x0B
#define SCSI_SENKEY_EQUAL         0x0C
#define SCSI_SENKEY_VOL_OVERFLOW  0x0D
#define SCSI_SENKEY_MISCOMP       0x0E
#define SCSI_SENKEY_RESERVED      0x0F

/* -------------------------------------------------------------
** ASC ( Additional sense code )
** ---------------------------------------------------------- */
#define SCSI_ASC_POWER_ON_RESET   0x29 /* power on, reset, bus device reset occured */
#define SCSI_ASC_NOMEDIA          0x3A /* no media present */


/* -------------------------------------------------------------
**
** ---------------------------------------------------------- */
#define ASC_SRB_HOST( x )  ( ( uchar )( ( uchar )( x ) >> 4 ) )
#define ASC_SRB_TID( x )   ( ( uchar )( ( uchar )( x ) & ( uchar )0x0F ) )
/* #define ASC_SRB_DIR( x )   ( ( uchar )( ( uchar )( x ) & 0x18 ) ) */
#define ASC_SRB_LUN( x )   ( ( uchar )( ( uint )( x ) >> 13 ) )

/* take high byte of unit number put it into CDB block index 1 */
#define PUT_CDB1( x )   ( ( uchar )( ( uint )( x ) >> 8 ) )

/*
** SCSI status
*/
#define SS_GOOD              0x00 /* target has successfully completed the command  */
#define SS_CHK_CONDITION     0x02 /* contigent allegiance condition has occured     */
#define SS_CONDITION_MET     0x04 /* the requested operation is satisfied           */
#define SS_TARGET_BUSY       0x08 /* target is busy                                 */
#define SS_INTERMID          0x10 /* intermediate                                   */
#define SS_INTERMID_COND_MET 0x14 /* intermediate-condition met                     */
                                  /* the combination of condition-met ( 0x04 )      */
                                  /* and intermediate ( 0x10 ) statuses             */
#define SS_RSERV_CONFLICT    0x18 /* reservation conflict                           */
#define SS_CMD_TERMINATED    0x22 /* command terminated                             */
                                  /* by terminated I/O process message or           */
                                  /* a contigent allegiance condition has occured   */
#define SS_QUEUE_FULL        0x28 /* queue full                                     */

/* --------------------------------------------------------------
** SCSI messages
** ----------------------------------------------------------- */
#define MS_CMD_DONE    0x00 /* command completed            */

/*
** Extended Messages (Multi-Byte)
**
** Byte 0: 0x01
** Byte 1: Additional Message Length
** Byte 2: Message Code
** Byte 3 - Byte ((Additional Message Length + 2) - 1): Message Data
*/
#define MS_EXTEND      0x01 /* first byte of extended message */
/* SDTR (Synchronous Data Transfer Request) Extended Message */
#define MS_SDTR_LEN    0x03 /* SDTR additional message length */
#define MS_SDTR_CODE   0x01 /* SDTR message code */
/* WDTR (Wide Data Transfer Request) Extended Message */
#define MS_WDTR_LEN    0x02 /* WDTR additional message length */
#define MS_WDTR_CODE   0x03 /* WDTR message code*/
/* MDP (Modify Data Pointer) Extended Message */
#define MS_MDP_LEN    0x05 /* MDP additional message length */
#define MS_MDP_CODE   0x00 /* MDP message code */


/*
**
** One byte Messages
**
** one byte messages, 0x02 - 0x1F
** 0x12 - 0x1F: reserved for one-byte messages
**                                     I T, I-initiator T-target support
**                                          O: Optional, M:mandatory
*/
#define M1_SAVE_DATA_PTR        0x02 /*; O O save data pointer                */
#define M1_RESTORE_PTRS         0x03 /*; O O restore pointers                 */
#define M1_DISCONNECT           0x04 /*; O O disconnect                       */
#define M1_INIT_DETECTED_ERR    0x05 /*; M M initiator detected error         */
#define M1_ABORT                0x06 /*; O M abort                            */
#define M1_MSG_REJECT           0x07 /*; M M message reject                   */
#define M1_NO_OP                0x08 /*; M M no operation                     */
#define M1_MSG_PARITY_ERR       0x09 /*; M M message parity error             */
#define M1_LINK_CMD_DONE        0x0A /*; O O link command completed           */
#define M1_LINK_CMD_DONE_WFLAG  0x0B /*; O O link command completed with flag */
#define M1_BUS_DVC_RESET        0x0C /*; O M bus device reset                 */
#define M1_ABORT_TAG            0x0D /*; O O abort tag                        */
#define M1_CLR_QUEUE            0x0E /*; O O clear queue                      */
#define M1_INIT_RECOVERY        0x0F /*; O O initiate recovery                */
#define M1_RELEASE_RECOVERY     0x10 /*; O O release recovery                 */
#define M1_KILL_IO_PROC         0x11 /*; O O terminate i/o process            */

/*
** Two Byte Messages
**
** first byte of two-byte queue tag messages, 0x20 - 0x2F
** queue tag messages, 0x20 - 0x22
*/
#define M2_QTAG_MSG_SIMPLE      0x20 /* O O simple queue tag     */
#define M2_QTAG_MSG_HEAD        0x21 /* O O head of queue tag    */
#define M2_QTAG_MSG_ORDERED     0x22 /* O O ordered queue tag    */
#define M2_IGNORE_WIDE_RESIDUE  0x23 /* O O ignore wide residue  */

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar peri_dvc_type   : 5 ; /* peripheral device type */
  uchar peri_qualifier  : 3 ; /* peripheral qualifier   */
} ASC_SCSI_INQ0 ;
#else
typedef struct {
  uchar peri_qualifier  : 3 ; /* peripheral qualifier   */
  uchar peri_dvc_type   : 5 ; /* peripheral device type */
} ASC_SCSI_INQ0 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar dvc_type_modifier : 7 ; /* device type modifier ( for SCSI I ) */
  uchar rmb      : 1 ; /* RMB - removable medium bit          */
} ASC_SCSI_INQ1 ;
#else
typedef struct {
  uchar rmb      : 1 ; /* RMB - removable medium bit          */
  uchar dvc_type_modifier : 7 ; /* device type modifier ( for SCSI I ) */
} ASC_SCSI_INQ1 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar ansi_apr_ver : 3 ; /* ANSI approved version */
  uchar ecma_ver : 3 ;     /* ECMA version          */
  uchar iso_ver  : 2 ;     /* ISO version           */
} ASC_SCSI_INQ2 ;
#else
typedef struct {
  uchar iso_ver  : 2 ;     /* ISO version           */
  uchar ecma_ver : 3 ;     /* ECMA version          */
  uchar ansi_apr_ver : 3 ; /* ANSI approved version */
} ASC_SCSI_INQ2 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar rsp_data_fmt : 4 ; /* response data format                                            */
                           /* 0   SCSI 1 */
                           /* 1   CCS */
                           /* 2   SCSI-2 */
                           /* 3-F reserved */
  uchar res      : 2 ;     /* reserved                                                        */
  uchar TemIOP   : 1 ;     /* terminate I/O process bit ( see 5.6.22 )                        */
  uchar aenc     : 1 ;     /* asynchronous event notification ( for Processor device type )   */
} ASC_SCSI_INQ3 ;
#else
typedef struct {
  uchar aenc     : 1 ;     /* asynchronous event notification ( for Processor device type )   */
  uchar TemIOP   : 1 ;     /* terminate I/O process bit ( see 5.6.22 )                        */
  uchar res      : 2 ;     /* reserved                                                        */
  uchar rsp_data_fmt : 4 ; /* response data format                                            */
                           /* 0   SCSI 1 */
                           /* 1   CCS */
                           /* 2   SCSI-2 */
                           /* 3-F reserved */
} ASC_SCSI_INQ3 ;
#endif

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct {
  uchar StfRe   : 1 ; /* soft reset implemented                */
  uchar CmdQue  : 1 ; /* command queuing                       */
  uchar Reserved: 1 ; /* reserved                              */
  uchar Linked  : 1 ; /* linked command for this logical unit  */
  uchar Sync    : 1 ; /* synchronous data transfer             */
  uchar WBus16  : 1 ; /* wide bus 16 bit data transfer         */
  uchar WBus32  : 1 ; /* wide bus 32 bit data transfer         */
  uchar RelAdr  : 1 ; /* relative addressing mode              */
} ASC_SCSI_INQ7 ;
#else
typedef struct {
  uchar RelAdr  : 1 ; /* relative addressing mode              */
  uchar WBus32  : 1 ; /* wide bus 32 bit data transfer         */
  uchar WBus16  : 1 ; /* wide bus 16 bit data transfer         */
  uchar Sync    : 1 ; /* synchronous data transfer             */
  uchar Linked  : 1 ; /* linked command for this logical unit  */
  uchar Reserved: 1 ; /* reserved                              */
  uchar CmdQue  : 1 ; /* command queuing                       */
  uchar StfRe   : 1 ; /* soft reset implemented                */
} ASC_SCSI_INQ7 ;
#endif

/*
**
*/
typedef struct {
  ASC_SCSI_INQ0  byte0 ;          /*                          */
  ASC_SCSI_INQ1  byte1 ;          /*                          */
  ASC_SCSI_INQ2  byte2 ;          /*                          */
  ASC_SCSI_INQ3  byte3 ;          /*                          */
  uchar  add_len ;                /* additional length        */
  uchar  res1 ;                   /* reserved                 */
  uchar  res2 ;                   /* reserved                 */
  ASC_SCSI_INQ7  byte7 ;          /*                          */
  uchar  vendor_id[ 8 ] ;         /* vendor identification    */
  uchar  product_id[ 16 ] ;       /* product identification   */
  uchar  product_rev_level[ 4 ] ; /* product revision level   */
} ASC_SCSI_INQUIRY ;              /* 36 bytes */

/*
**
*/
#if CC_LITTLE_ENDIAN_HOST
typedef struct asc_req_sense {
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h            */
  uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid       */

  uchar segment_no ;          /* 1, segment number                            */

  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                      */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                        */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )    */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                 */
  uchar file_mark: 1 ;        /*    bit 7 file mark encountered               */

  uchar info1[ 4 ] ;          /* 3-6, information                             */
  uchar add_sense_len ;       /* 7, additional sense length                   */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific infomation            */
  uchar asc ;                 /* 12, additional sense code                    */
  uchar ascq ;                /* 13, additional sense code qualifier          */
/*
** minimum request sense length stop here
*/
  uchar fruc ;                /* 14, field replaceable unit code              */

  uchar sks_byte0: 7 ;        /* 15,                                          */
  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid           */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV       */
  uchar notused[ 2 ] ;        /* 18-19,                                       */
  uchar ex_sense_code ;       /* 20, extended additional sense code           */
  uchar info2[ 4 ] ;          /* 21-24, additional sense bytes                */
} ASC_REQ_SENSE ;
#else
typedef struct asc_req_sense {
   uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid       */
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h            */

  uchar segment_no ;          /* 1, segment number                            */

  uchar file_mark: 1 ;        /*    bit 7 file mark encountered               */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                 */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )    */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                        */
  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                      */

  uchar info1[ 4 ] ;          /* 3-6, information                             */
  uchar add_sense_len ;       /* 7, additional sense length                   */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific infomation            */
  uchar asc ;                 /* 12, additional sense code                    */
  uchar ascq ;                /* 13, additional sense code qualifier          */
/*
** minimum request sense length stop here
*/
  uchar fruc ;                /* 14, field replaceable unit code              */

  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid           */
  uchar sks_byte0: 7 ;        /* 15,                                          */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV       */
  uchar notused[ 2 ] ;        /* 18-19,                                       */
  uchar ex_sense_code ;       /* 20, extended additional sense code           */
  uchar info2[ 4 ] ;          /* 21-24, additional sense bytes                */
} ASC_REQ_SENSE ;
#endif

#endif /* #ifndef __ASCSIDEF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asclib.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: asclib.h
**
*/

#ifndef __ASCLIB_H_
#define __ASCLIB_H_

/* *******************************************************************
** asc_eep.c
** ***************************************************************** */
int    AscWriteEEPCmdReg( PortAddr iop_base, uchar cmd_reg ) ;
int    AscWriteEEPDataReg( PortAddr iop_base, ushort data_reg ) ;
void   AscWaitEEPRead( void ) ;
void   AscWaitEEPWrite( void ) ;
ushort AscReadEEPWord( PortAddr, uchar ) ;
ushort AscWriteEEPWord( PortAddr, uchar, ushort ) ;
ushort AscGetEEPConfig( PortAddr, ASCEEP_CONFIG dosfar *, ushort ) ;
int    AscSetEEPConfigOnce( PortAddr, ASCEEP_CONFIG dosfar *, ushort ) ;
int    AscSetEEPConfig( PortAddr, ASCEEP_CONFIG dosfar *, ushort ) ;
ushort AscEEPSum( PortAddr, uchar, uchar ) ;

/* *******************************************************************
** asc_chip.c
** ***************************************************************** */
int    AscStartChip( PortAddr ) ;
int    AscStopChip( PortAddr ) ;
void   AscSetChipIH( PortAddr, ushort ) ;

int    AscIsChipHalted( PortAddr ) ;

void   AscResetScsiBus( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscResetChip( PortAddr ) ;
void   AscSetChipCfgDword( PortAddr, ulong ) ;
ulong  AscGetChipCfgDword( PortAddr ) ;

void   AscAckInterrupt( PortAddr ) ;
void   AscDisableInterrupt( PortAddr ) ;
void   AscEnableInterrupt( PortAddr ) ;
void   AscSetBank( PortAddr, uchar ) ;
uchar  AscGetBank( PortAddr ) ;
int    AscResetChipAndScsiBus( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscGetIsaDmaChannel( PortAddr ) ;
ushort AscSetIsaDmaChannel( PortAddr, ushort ) ;
uchar  AscSetIsaDmaSpeed( PortAddr, uchar ) ;
uchar  AscGetIsaDmaSpeed( PortAddr ) ;

/* ******************************************************************
** asc_lram.c
** **************************************************************** */
uchar  AscReadLramByte( PortAddr, ushort) ;
ushort AscReadLramWord( PortAddr, ushort ) ;
ulong  AscReadLramDWord( PortAddr, ushort ) ;
void   AscWriteLramWord( PortAddr, ushort, ushort ) ;
void   AscWriteLramDWord( PortAddr, ushort, ulong );
void   AscWriteLramByte( PortAddr, ushort, uchar ) ;

ulong  AscMemSumLramWord( PortAddr, ushort, int ) ;
void   AscMemWordSetLram( PortAddr, ushort, ushort, int ) ;
void   AscMemWordCopyToLram( PortAddr, ushort, ushort dosfar *, int ) ;
void   AscMemDWordCopyToLram( PortAddr, ushort, ulong dosfar *, int ) ;
void   AscMemWordCopyFromLram( PortAddr, ushort, ushort dosfar *, int ) ;
int    AscMemWordCmpToLram( PortAddr, ushort, ushort dosfar *, int ) ;

/* *******************************************************************
** asc_dvc.c
** ***************************************************************** */
ushort AscInitAscDvcVar( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitFromEEP( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitWithoutEEP( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitFromAscDvcVar( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitMicroCodeVar( ASC_DVC_VAR asc_ptr_type *asc_dvc ) ;
/* ushort AscGetSetConfig( ASC_DVC_VAR asc_ptr_type * ) ; */
/* ushort AscInitCfgRegister( ASC_DVC_VAR asc_ptr_type * ) ; */
/* ushort AscInitGetConfig( ASC_DVC_VAR asc_ptr_type * ) ; */
/* ushort AscInitAsc1000Driver( ASC_DVC_VAR asc_ptr_type * ) ; */
void dosfar AscInitPollIsrCallBack( ASC_DVC_VAR asc_ptr_type *,
                                    ASC_QDONE_INFO dosfar * ) ;
int    AscTestExternalLram( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscTestLramEndian( PortAddr ) ;


/* *******************************************************************
** a_qop.c
** int    AscHostReqRiscHalt( PortAddr )        ; 6-16-95
** ***************************************************************** */
uchar  AscMsgOutSDTR( ASC_DVC_VAR asc_ptr_type *, uchar, uchar ) ;

uchar  AscCalSDTRData( ASC_DVC_VAR asc_ptr_type *, uchar, uchar ) ;
void   AscSetChipSDTR( PortAddr, uchar, uchar ) ;
int    AscInitChipAllSynReg( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
uchar  AscGetSynPeriodIndex( ASC_DVC_VAR asc_ptr_type *, ruchar ) ;
uchar  AscAllocFreeQueue( PortAddr, uchar ) ;
uchar  AscAllocMultipleFreeQueue( PortAddr, uchar, uchar ) ;
int    AscRiscHaltedAbortSRB( ASC_DVC_VAR asc_ptr_type *, ulong ) ;
int    AscRiscHaltedAbortTIX( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscRiscHaltedAbortALL( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscHostReqRiscHalt( PortAddr ) ;
int    AscStopQueueExe( PortAddr ) ;
int    AscStartQueueExe( PortAddr ) ;
int    AscCleanUpDiscQueue( PortAddr ) ;
int    AscCleanUpBusyQueue( PortAddr ) ;
int    _AscAbortTidBusyQueue( ASC_DVC_VAR asc_ptr_type *,
                              ASC_QDONE_INFO dosfar *, uchar ) ;
int    _AscAbortSrbBusyQueue( ASC_DVC_VAR asc_ptr_type *,
                              ASC_QDONE_INFO dosfar *, ulong ) ;
int    AscWaitTixISRDone( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscWaitISRDone( ASC_DVC_VAR asc_ptr_type * ) ;
ulong  AscGetOnePhyAddr( ASC_DVC_VAR asc_ptr_type *, uchar dosfar *, ulong ) ;

/* *******************************************************************
** a_q.c
** ***************************************************************** */
int    AscSendScsiQueue( ASC_DVC_VAR asc_ptr_type *asc_dvc,
                         ASC_SCSI_Q dosfar *scsiq,
                         uchar n_q_required ) ;
int    AscPutReadyQueue( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar *, uchar ) ;
int    AscPutReadySgListQueue( ASC_DVC_VAR asc_ptr_type *,
                               ASC_SCSI_Q dosfar *, uchar ) ;
int    AscAbortScsiIO( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;
void   AscExeScsiIO( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;
int    AscSetChipSynRegAtID( PortAddr, uchar, uchar ) ;
int    AscSetRunChipSynRegAtID( PortAddr, uchar, uchar ) ;
ushort AscInitLram( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscReInitLram( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitQLinkVar( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscSetLibErrorCode( ASC_DVC_VAR asc_ptr_type *, ushort ) ;
int    _AscWaitQDone( PortAddr, ASC_SCSI_Q dosfar * ) ;

/* *******************************************************************
** a_osdep.c
** ***************************************************************** */
int    AscEnterCritical( void ) ;
void   AscLeaveCritical( int ) ;

/* *******************************************************************
** a_isr.c
** ***************************************************************** */
int    AscIsrChipHalted( ASC_DVC_VAR asc_ptr_type * ) ;
uchar  _AscCopyLramScsiDoneQ( PortAddr, ushort,
                              ASC_QDONE_INFO dosfar *, ulong ) ;
int    AscIsrQDone( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscIsrExeBusyQueue( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscScsiSetupCmdQ( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar *,
                         uchar dosfar *, ulong ) ;

/* ******************************************************************
** asc_scsi.c
** **************************************************************** */
int    AscScsiInquiry( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar *,
                       uchar dosfar *, int ) ;
int    AscScsiTestUnitReady( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar * ) ;
int    AscScsiStartStopUnit( ASC_DVC_VAR asc_ptr_type *,
                             ASC_SCSI_REQ_Q dosfar *, uchar ) ;
int    AscScsiReadCapacity( ASC_DVC_VAR asc_ptr_type *,
                            ASC_SCSI_REQ_Q dosfar *,
                            uchar dosfar * ) ;

/* *******************************************************************
** asc_inq.c
** ***************************************************************** */
ulong  dosfar *swapfarbuf4( uchar dosfar * ) ;
int    PollQueueDone( ASC_DVC_VAR asc_ptr_type *,
                      ASC_SCSI_REQ_Q dosfar *,
                      int ) ;
int    PollScsiReadCapacity( ASC_DVC_VAR asc_ptr_type *,
                             ASC_SCSI_REQ_Q dosfar *,
                             ASC_CAP_INFO dosfar * ) ;
int    PollScsiInquiry( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_REQ_Q dosfar *,
                        uchar dosfar *, int ) ;
int    PollScsiTestUnitReady( ASC_DVC_VAR asc_ptr_type *,
                              ASC_SCSI_REQ_Q dosfar * ) ;
int    PollScsiStartUnit( ASC_DVC_VAR asc_ptr_type *,
                          ASC_SCSI_REQ_Q dosfar * ) ;
int    InitTestUnitReady( ASC_DVC_VAR asc_ptr_type *,
                          ASC_SCSI_REQ_Q dosfar * ) ;
void   AscDispInquiry( uchar, uchar, ASC_SCSI_INQUIRY dosfar * ) ;
int    AscPollQDone( ASC_DVC_VAR asc_ptr_type *,
                     ASC_SCSI_REQ_Q dosfar *, int ) ;
int    AscCompareString( uchar *, uchar *, int ) ;

/* ------------------------------------------------------------------
** asc_bios.c
** ---------------------------------------------------------------- */
int    AscSetBIOSBank( PortAddr, int, ushort ) ;
int    AscSetVlBIOSBank( PortAddr, int ) ;
int    AscSetEisaBIOSBank( PortAddr, int ) ;
int    AscSetIsaBIOSBank( PortAddr, int ) ;


/* *******************************************************************
** a_eisa.c
** ***************************************************************** */
ushort AscGetEisaChipCfg( PortAddr ) ;
ushort AscGetEisaChipGpReg( PortAddr ) ;
ushort AscSetEisaChipCfg( PortAddr, ushort ) ;
ushort AscSetEisaChipGpReg( PortAddr, ushort ) ;


/* *******************************************************************
** ae_init1.c
** ***************************************************************** */
ulong  AscGetEisaProductID( PortAddr ) ;
PortAddr AscSearchIOPortAddrEISA( PortAddr ) ;


/* *******************************************************************
** a_init1.c
** **************************************************************** */
void   AscClrResetScsiBus( PortAddr ) ;
uchar  AscGetChipScsiCtrl( PortAddr ) ;
uchar  AscSetChipScsiID( PortAddr, uchar ) ;
uchar  AscGetChipVersion( PortAddr, ushort ) ;
ushort AscGetChipBusType( PortAddr ) ;
ulong  AscLoadMicroCode( PortAddr, ushort,
                         ushort dosfar *, ushort );
int    AscFindSignature( PortAddr ) ;

/* ******************************************************************
** a_init2.c
** ******************************************************************/
PortAddr AscSearchIOPortAddr11( PortAddr ) ;
PortAddr AscSearchIOPortAddr100( PortAddr ) ;
void   AscToggleIRQAct( PortAddr ) ;
void   AscClrResetChip( PortAddr ) ;

short  itos( ushort, uchar dosfar *, short, short ) ;
int    insnchar( uchar dosfar *, short , short, ruchar, short ) ;
void   itoh( ushort, ruchar dosfar * ) ;
void   btoh( uchar, ruchar dosfar * ) ;
void   ltoh( ulong, ruchar dosfar * ) ;
uchar dosfar *todstr( ushort, uchar dosfar * ) ;
uchar dosfar *tohstr( ushort, uchar dosfar * ) ;
uchar dosfar *tobhstr( uchar, uchar dosfar * ) ;
uchar dosfar *tolhstr( ulong, uchar dosfar * ) ;


/* ******************************************************************
** a_init3.c
** ******************************************************************/
void   AscSetISAPNPWaitForKey( void ) ;
uchar  AscGetChipIRQ( PortAddr, ushort ) ;
uchar  AscSetChipIRQ( PortAddr, uchar, ushort ) ;

/* ******************************************************************
** a_bios.c
** ******************************************************************/
int    AscIsBiosEnabled( PortAddr, ushort ) ;
int    AscEnableBios( PortAddr, ushort ) ;
ushort AscGetChipBiosAddress( PortAddr, ushort ) ;
ushort AscSetChipBiosAddress( PortAddr, ushort, ushort ) ;
/* ulong  AscGetMaxDmaCount( ushort ) ; */ /* the function prototype in a_ddlib.h */

/* *******************************************************************
** asc_diag.c
** ***************************************************************** */
void   AscSingleStepChip( PortAddr ) ;


/* *******************************************************************
** asc_res.c
** ***************************************************************** */
int    AscPollQTailSync( PortAddr ) ;
int    AscPollQHeadSync( PortAddr ) ;
int    AscWaitQTailSync( PortAddr ) ;

/* *******************************************************************
** a_novell.c
** ***************************************************************** */
int    _AscRestoreMicroCode( PortAddr, ASC_MC_SAVED dosfar * ) ;


/* *******************************************************************
** a_scam.c
******************************************************************* */
int   AscSCAM( ASC_DVC_VAR asc_ptr_type * ) ;

/* *******************************************************************
** a_mmio.c
** added # S47
**
******************************************************************* */
ushort  SwapByteOfWord( ushort word_val ) ;
ulong   SwapWordOfDWord( ulong dword_val ) ;
ulong   AdjEndianDword( ulong dword_val ) ;

/* *******************************************************************
** a_endian c
** added # S47
**
******************************************************************* */
int     AscAdjEndianScsiQ( ASC_SCSI_Q dosfar * ) ;
int     AscAdjEndianQDoneInfo( ASC_QDONE_INFO dosfar * ) ;


/* *******************************************************************
** a_sg c
** added # S62
**
******************************************************************* */
int    AscCoalesceSgList( ASC_SCSI_Q dosfar  * );

/* *******************************************************************
** a_debug.c
** added since # S89
**
******************************************************************* */
int    AscVerWriteLramDWord( PortAddr, ushort, ulong ) ;
int    AscVerWriteLramWord( PortAddr, ushort, ushort ) ;
int    AscVerWriteLramByte( PortAddr, ushort, uchar ) ;


#endif /* __ASCLIB_H_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc1000.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: asc1000.h
**
*/

#ifndef __ASC1000_H_
#define __ASC1000_H_

#include "ascdep.h"

#define ASC_EXE_SCSI_IO_MAX_IDLE_LOOP  0x1000000UL
#define ASC_EXE_SCSI_IO_MAX_WAIT_LOOP  1024


/*
** error code of asc_dvc->err_code
*/
#define ASCQ_ERR_NO_ERROR             0     /* */
#define ASCQ_ERR_IO_NOT_FOUND         1     /* */
#define ASCQ_ERR_LOCAL_MEM            2     /* */
#define ASCQ_ERR_CHKSUM               3     /* */
#define ASCQ_ERR_START_CHIP           4     /* */
#define ASCQ_ERR_INT_TARGET_ID        5     /* */
#define ASCQ_ERR_INT_LOCAL_MEM        6     /* */
#define ASCQ_ERR_HALT_RISC            7     /* */
#define ASCQ_ERR_GET_ASPI_ENTRY       8     /* */
#define ASCQ_ERR_CLOSE_ASPI           9     /* */
#define ASCQ_ERR_HOST_INQUIRY         0x0A  /* */
#define ASCQ_ERR_SAVED_SRB_BAD        0x0B  /* */
#define ASCQ_ERR_QCNTL_SG_LIST        0x0C  /* */
#define ASCQ_ERR_Q_STATUS             0x0D  /* */
#define ASCQ_ERR_WR_SCSIQ             0x0E  /* */
#define ASCQ_ERR_PC_ADDR              0x0F  /* */
#define ASCQ_ERR_SYN_OFFSET           0x10  /* */
#define ASCQ_ERR_SYN_XFER_TIME        0x11  /* */
#define ASCQ_ERR_LOCK_DMA             0x12  /* */
#define ASCQ_ERR_UNLOCK_DMA           0x13  /* */
#define ASCQ_ERR_VDS_CHK_INSTALL      0x14  /* */
#define ASCQ_ERR_MICRO_CODE_HALT      0x15  /* unknown halt error code */
#define ASCQ_ERR_SET_LRAM_ADDR        0x16  /* */
#define ASCQ_ERR_CUR_QNG              0x17  /* */
#define ASCQ_ERR_SG_Q_LINKS           0x18  /* */
#define ASCQ_ERR_SCSIQ_PTR            0x19  /* */
#define ASCQ_ERR_ISR_RE_ENTRY         0x1A  /* */
#define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B  /* */
#define ASCQ_ERR_ISR_ON_CRITICAL      0x1C  /* */
#define ASCQ_ERR_SG_LIST_ODD_ADDRESS  0x1D  /* */
#define ASCQ_ERR_XFER_ADDRESS_TOO_BIG 0x1E  /* */
#define ASCQ_ERR_SCSIQ_NULL_PTR       0x1F  /* */
#define ASCQ_ERR_SCSIQ_BAD_NEXT_PTR   0x20  /* */
#define ASCQ_ERR_GET_NUM_OF_FREE_Q    0x21  /* */
#define ASCQ_ERR_SEND_SCSI_Q          0x22  /* */
#define ASCQ_ERR_HOST_REQ_RISC_HALT   0x23  /* */
#define ASCQ_ERR_RESET_SDTR           0x24  /* */

/*
** AscInitGetConfig() and AscInitAsc1000Driver()
** return values
*/
#define ASC_WARN_NO_ERROR             0x0000 /* there is no warning */
#define ASC_WARN_IO_PORT_ROTATE       0x0001 /* i/o port addrsss modified */
#define ASC_WARN_EEPROM_CHKSUM        0x0002 /* EEPROM check sum error */
#define ASC_WARN_IRQ_MODIFIED         0x0004 /* IRQ number is modified */
#define ASC_WARN_AUTO_CONFIG          0x0008 /* auto i/o port rotation is on, available after chip version 3 */
#define ASC_WARN_CMD_QNG_CONFLICT     0x0010 /* tag queuing without enabled */
                                             /* disconnection */
#define ASC_WARN_EEPROM_RECOVER       0x0020 /* eeprom data recovery attempted */
#define ASC_WARN_CFG_MSW_RECOVER      0x0040 /* cfg register recover attempted */
#define ASC_WARN_SET_PCI_CONFIG_SPACE 0x0080 /* DvcWritePCIConfigByte() not working */

/*
** AscInitGetConfig() and AscInitAsc1000Driver()
** Init Fatal error code in variable asc_dvc->err_code
*/
#define ASC_IERR_WRITE_EEPROM         0x0001 /* write EEPROM error */
#define ASC_IERR_MCODE_CHKSUM         0x0002 /* micro code check sum error */
#define ASC_IERR_SET_PC_ADDR          0x0004 /* set program counter error */
#define ASC_IERR_START_STOP_CHIP      0x0008 /* start/stop chip failed */
                                             /* probably SCSI flat cable reversed */
#define ASC_IERR_IRQ_NO               0x0010 /* this error will reset irq to */
                                             /* ASC_DEF_IRQ_NO */
#define ASC_IERR_SET_IRQ_NO           0x0020 /* this error will reset irq to */
#define ASC_IERR_CHIP_VERSION         0x0040 /* wrong chip version */
#define ASC_IERR_SET_SCSI_ID          0x0080 /* set SCSI ID failed */
#define ASC_IERR_GET_PHY_ADDR         0x0100 /* get physical address */
#define ASC_IERR_BAD_SIGNATURE        0x0200 /* signature not found, i/o port address may be wrong */
#define ASC_IERR_NO_BUS_TYPE          0x0400 /* bus type field no set */
#define ASC_IERR_SCAM                 0x0800
#define ASC_IERR_SET_SDTR             0x1000
#define ASC_IERR_RW_LRAM              0x8000 /* read/write local RAM error */


/*
** IRQ setting
*/
#define ASC_DEF_IRQ_NO  10   /* minimum IRQ number */
#define ASC_MAX_IRQ_NO  15   /* maximum IRQ number */
#define ASC_MIN_IRQ_NO  10   /* default IRQ number */

/*
** number of queue(s)
*/
#define ASC_MIN_REMAIN_Q        (0x02) /* minimum number of queues remained in main queue links */
#define ASC_DEF_MAX_TOTAL_QNG   (0xF0) /* default total number of queues */
/* #define ASC_DEF_MAX_SINGLE_QNG  (0x02) default number of queued command per device */
#define ASC_MIN_TAG_Q_PER_DVC   (0x04)
#define ASC_DEF_TAG_Q_PER_DVC   (0x04)

/*
** minimum total number of queues
*/
/* #define ASC_MIN_FREE_Q        (( ASC_MAX_SG_QUEUE )+( ASC_MIN_REMAIN_Q )) */
#define ASC_MIN_FREE_Q        ASC_MIN_REMAIN_Q

#define ASC_MIN_TOTAL_QNG     (( ASC_MAX_SG_QUEUE )+( ASC_MIN_FREE_Q )) /* we must insure that a urgent queue with sg list can go through */
/* #define ASC_MIN_TOTAL_QNG  ( (2)+ASC_MIN_FREE_Q ) */ /* for testing 12 queue only */

/*
** the following depends on chip version
*/
#define ASC_MAX_TOTAL_QNG 240 /* maximum total number of queues */
#define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16 /* maximum total number of queues without external RAM */
                                             /* with ucode size 2.5KB */
#define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8  /* maximum total number of tagged queues without external RAM */
#define ASC_MAX_PCI_INRAM_TOTAL_QNG  20  /* maximum total number of queues without external RAM */
                                        /* with ucode size 2.5KB */
#define ASC_MAX_INRAM_TAG_QNG   16      /* maximum total number of tagged queues without external RAM */

/*
** default I/O port addresses
*/
/* #define ASC_IOADR_NO    8  */   /* number of default addresses to rotate */
#define ASC_IOADR_TABLE_MAX_IX  11  /* io port default addresses for ISA(PNP) and VL */
#define ASC_IOADR_GAP   0x10     /* io address register space */
#define ASC_SEARCH_IOP_GAP 0x10  /*                        */
#define ASC_MIN_IOP_ADDR   ( PortAddr )0x0100 /* minimum io address */
#define ASC_MAX_IOP_ADDR   ( PortAddr )0x3F0  /*                        */

#define ASC_IOADR_1     ( PortAddr )0x0110
#define ASC_IOADR_2     ( PortAddr )0x0130
#define ASC_IOADR_3     ( PortAddr )0x0150
#define ASC_IOADR_4     ( PortAddr )0x0190
#define ASC_IOADR_5     ( PortAddr )0x0210
#define ASC_IOADR_6     ( PortAddr )0x0230
#define ASC_IOADR_7     ( PortAddr )0x0250
#define ASC_IOADR_8     ( PortAddr )0x0330
#define ASC_IOADR_DEF   ASC_IOADR_8  /* the default BIOS address */

/*
**
**
**
*/

#define ASC_LIB_SCSIQ_WK_SP        256   /* for library scsiq and data buffer working space */
#define ASC_MAX_SYN_XFER_NO        16
/* #define ASC_SYN_XFER_NO            8 , removed since S89, use asc_dvc->max_sdtr_index instead */
/* #define ASC_MAX_SDTR_PERIOD_INDEX  7   */  /* maximum sdtr peroid index */
#define ASC_SYN_MAX_OFFSET         0x0F  /* maximum sdtr offset */
#define ASC_DEF_SDTR_OFFSET        0x0F  /* default sdtr offset */
#define ASC_DEF_SDTR_INDEX         0x00  /* default sdtr period index */
#define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02  /* ultra PCI 10mb/sec sdtr index */

#if 1
/* syn xfer time, in nanosecond, for 50M HZ clock */
#define SYN_XFER_NS_0  25  /* 25=0x19 100 ns  10MB/SEC, fast SCSI */
#define SYN_XFER_NS_1  30  /* 30=0x1E 120 ns  8.3MB/sec           */
#define SYN_XFER_NS_2  35  /* 35=0x23 140 ns  7.2MB/sec           */
#define SYN_XFER_NS_3  40  /* 40=0x28 160 ns  6.25MB/sec          */
#define SYN_XFER_NS_4  50  /* 50=0x32 200 ns, 5MB/SEC normal use  */
#define SYN_XFER_NS_5  60  /* 60=0x3C 240 ns  4.16MB/sec          */
#define SYN_XFER_NS_6  70  /* 70=0x46 280 ns  3.6.MB/sec          */
#define SYN_XFER_NS_7  85  /* 85=0x55 340 ns  3MB/sec             */
#else
/* syn xfer time, in nanosecond, for 33M HZ clock */
#define SYN_XFER_NS_0  38  /* 38=0x26 152 ns             */
#define SYN_XFER_NS_1  45  /* 45=0x2D 180 ns             */
#define SYN_XFER_NS_2  53  /* 53=0x35 ns                 */
#define SYN_XFER_NS_3  60  /* 60=0x3C ns                 */
#define SYN_XFER_NS_4  75  /* 75=0x4B ns                 */
#define SYN_XFER_NS_5  90  /* 90=0x5A ns normal use      */
#define SYN_XFER_NS_6  105 /* 105=0x69 ns                */
#define SYN_XFER_NS_7  128 /* 128=0x80 ns                */
#endif

                                   /* at 40MHZ clock */
#define SYN_ULTRA_XFER_NS_0    12  /* 50  ns 20.0 MB/sec, at SCSI 12 is 48ns, 13 is 52ns */
#define SYN_ULTRA_XFER_NS_1    19  /* 75  ns 13.3 MB/sec            */
#define SYN_ULTRA_XFER_NS_2    25  /* 100 ns 10.0 MB/sec            */
#define SYN_ULTRA_XFER_NS_3    32  /* 125 ns 8.00 MB/sec            */
#define SYN_ULTRA_XFER_NS_4    38  /* 150 ns 6.67 MB/SEC            */
#define SYN_ULTRA_XFER_NS_5    44  /* 175 ns 5.71 MB/sec            */
#define SYN_ULTRA_XFER_NS_6    50  /* 200 ns 5.00 MB/sec            */
#define SYN_ULTRA_XFER_NS_7    57  /* 225 ns 4.44 MB/sec            */
#define SYN_ULTRA_XFER_NS_8    63  /* 250 ns 4.00 MB/sec            */
#define SYN_ULTRA_XFER_NS_9    69  /* 275 ns 3.64 MB/sec            */
#define SYN_ULTRA_XFER_NS_10   75  /* 300 ns 3.33 MB/sec            */
#define SYN_ULTRA_XFER_NS_11   82  /* 325 ns 3.08 MB/sec            */
#define SYN_ULTRA_XFER_NS_12   88  /* 350 ns 2.86 MB/sec            */
#define SYN_ULTRA_XFER_NS_13   94  /* 375 ns 2.67 MB/sec            */
#define SYN_ULTRA_XFER_NS_14  100  /* 400 ns 2.50 MB/sec            */
#define SYN_ULTRA_XFER_NS_15  107  /* 425 ns 2.35 MB/sec            */

#if 0
#define SYN_ULTRA_XFER_NS_8   63  /*  4.00 MB/SEC            */
#define SYN_ULTRA_XFER_NS_9   69  /*  3.64 MB/sec            */
#define SYN_ULTRA_XFER_NS_10  75  /*  3.33 MB/sec            */
#define SYN_ULTRA_XFER_NS_11  82  /*  3.08 MB/sec            */
#define SYN_ULTRA_XFER_NS_12  88  /*  2.86 MB/sec            */
#define SYN_ULTRA_XFER_NS_13  94  /*  2.67 MB/sec            */
#define SYN_ULTRA_XFER_NS_14  100 /*  2.5  MB/sec            */
#define SYN_ULTRA_XFER_NS_15  107 /*  2.35 MB/sec            */
#endif


/* #define ASC_SDTR_PERIOD_IX_MIN  7 */  /* below this will be rejected*/


/*
** Extended Message struct
**
** All Extended Messages have the same first 3 byte format.
**
** Note: The EXT_MSG structure size must be a word (16 bit) multiple to
**       be able to use the AscMemWordCopy*Lram() functions.
*/
typedef struct ext_msg {
  uchar msg_type ;                  /* Byte 0 */
  uchar msg_len ;                   /* Byte 1 */
  uchar msg_req ;                   /* Byte 2 */
  union {
    /* SDTR (Synchronous Data Transfer Request) specific fields */
    struct {
      uchar sdtr_xfer_period ;      /* Byte 3 */
      uchar sdtr_req_ack_offset ;   /* Byte 4 */
    } sdtr;
    /* WDTR (Wide Data Transfer Request) specific fields */
    struct {
      uchar wdtr_width ;            /* Byte 3 */
    } wdtr;
    /* MDP (Modify Data Pointer) specific fields */
    struct {
      uchar mdp_b3 ;                /* Byte 3 */
      uchar mdp_b2 ;                /* Byte 4 */
      uchar mdp_b1 ;                /* Byte 5 */
      uchar mdp_b0 ;                /* Byte 6 */
    } mdp;
  } u_ext_msg;
  uchar res ;                       /* Byte 7 (Word Padding) */
} EXT_MSG;

#define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period
#define req_ack_offset  u_ext_msg.sdtr.sdtr_req_ack_offset
#define wdtr_width      u_ext_msg.wdtr.wdtr_width
#define mdp_b3          u_ext_msg.mdp_b3
#define mdp_b2          u_ext_msg.mdp_b2
#define mdp_b1          u_ext_msg.mdp_b1
#define mdp_b0          u_ext_msg.mdp_b0


/*
** pointer to functions for device driver
**
**
**
** typedef void ( *AscIsrCallBack )( uchar *, ASC_QDONE_INFO dosfar * ) ;
** typedef void ( *AscDispFun )( char * ) ;
** typedef void ( *AscSleepMsec )( ulong msec ) ;
*/


typedef struct asc_dvc_cfg {
  ASC_SCSI_BIT_ID_TYPE  can_tagged_qng ;   /* device is capable of doing tag queuing */
/*  uchar    max_qng_scsi1 ;   maximum number of queued SCSI 1 command */
/*  uchar    max_qng_scsi2 ;   maximum number of queued SCSI 2 command */
/*  uchar    mcode_cntl ;      micro code control byte */
  ASC_SCSI_BIT_ID_TYPE  cmd_qng_enabled ; /* use tag queuing if possible */
  ASC_SCSI_BIT_ID_TYPE  disc_enable ;     /* enable disconnection */
  ASC_SCSI_BIT_ID_TYPE  sdtr_enable ;     /* enable SDTR if possible */
  uchar    chip_scsi_id : 4 ;  /* the chip SCSI id */
                               /* default should be 0x80 ( target id 7 ) */
  uchar    isa_dma_speed : 4 ; /* 06H high nibble, ISA Chip DMA Speed  */
                               /*     0 - 10MB - default */
                               /*     1 - 7.69 MB */
                               /*     2 - 6.66 MB */
                               /*     3 - 5.55 MB */
                               /*     4 - 5.00 MB */
                               /*     5 - 4.00 MB */
                               /*     6 - 3.33 MB */
                               /*     7 - 2.50 MB */
  uchar    isa_dma_channel ;   /* DMA channel 5, 6, 7 */
  uchar    chip_version ;     /* chip version */
  ushort   pci_device_id ;    /* PCI device code number */
  ushort   lib_serial_no ;   /* internal serial release number */
  ushort   lib_version ;     /* ASC library version number */
  ushort   mcode_date ;      /* ASC micro code date */
  ushort   mcode_version ;   /* ASC micro code version */
  uchar    max_tag_qng[ ASC_MAX_TID+1 ] ; /* number of request issued to each target ( and its LUN ) */
  uchar dosfar *overrun_buf ; /* virtual address of data overrun buffer */
                              /* overrun size is defined as ASC_OVERRUN_BSIZE */
                              /* during init, will call DvcGetSgList() to get physical address */
  uchar    sdtr_period_offset[ ASC_MAX_TID+1 ] ;

  ushort   pci_slot_info ;     /* high byte device/function number, bits 7-3 device number, bits 2-0 function number */
                               /* low byte bus number */

} ASC_DVC_CFG ;

#define ASC_DEF_DVC_CNTL       0xFFFF /* default dvc_cntl value */
#define ASC_DEF_CHIP_SCSI_ID   7  /* CHIP SCSI ID */
#define ASC_DEF_ISA_DMA_SPEED  4  /* 4 is 5MB per second */

#define ASC_INIT_STATE_NULL          0x0000
#define ASC_INIT_STATE_BEG_GET_CFG   0x0001
#define ASC_INIT_STATE_END_GET_CFG   0x0002
#define ASC_INIT_STATE_BEG_SET_CFG   0x0004
#define ASC_INIT_STATE_END_SET_CFG   0x0008
#define ASC_INIT_STATE_BEG_LOAD_MC   0x0010
#define ASC_INIT_STATE_END_LOAD_MC   0x0020
#define ASC_INIT_STATE_BEG_INQUIRY   0x0040
#define ASC_INIT_STATE_END_INQUIRY   0x0080
#define ASC_INIT_RESET_SCSI_DONE     0x0100
#define ASC_INIT_STATE_WITHOUT_EEP   0x8000

#define ASC_PCI_DEVICE_ID_REV_A      0x1100
#define ASC_PCI_DEVICE_ID_REV_B      0x1200

/*
** BUG FIX control
*/
#define ASC_BUG_FIX_IF_NOT_DWB       0x0001 /* add bytes until end address is dword boundary */
#define ASC_BUG_FIX_ASYN_USE_SYN     0x0002

/* #define ASC_ISAPNP_ADD_NUM_OF_BYTES   7    */  /* */
/* #define ASC_BUG_FIX_ISAPNP_ADD_BYTES  0x0002 */ /* for chip version 0x21 ( ISA PNP ) */
                                                  /* add three bytes when read from target */
                                                  /* active on command 0x08 and 0x28 only */

#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41  /* init SYN regs value for PCI rev B */

#define ASC_MIN_TAGGED_CMD  7  /* minimum number of tagged queues to re-adjust maximum number */
#define ASC_MAX_SCSI_RESET_WAIT      30   /* in seconds */

/*
**
*/
typedef struct asc_dvc_var {
  PortAddr iop_base ; /* 0-1 I/O port address */
  ushort   err_code ; /* 2-3 fatal error code */
  ushort   dvc_cntl ; /* 4-5 device control word, normally 0xffff */
  ushort   bug_fix_cntl ; /* 6-7 BUG fix contrl word, normally zero, bit set turn on fix */
  ushort   bus_type ; /* 8-9 BUS interface type, ISA, VL, PCI, EISA, etc... */
  Ptr2Func isr_callback ; /* 10-13 pointer to function, called in AscISR() to notify a done queue */
  Ptr2Func exe_callback ; /* 14-17 pointer to function, called when a scsiq put into local RAM */
                          /* if value is ZERO, will not be called */

  ASC_SCSI_BIT_ID_TYPE init_sdtr ; /* 18 host adapter should initiate SDTR request */
                        /*   ( bit field for each target ) */
  ASC_SCSI_BIT_ID_TYPE sdtr_done ; /* 19 SDTR is completed ( bit field for each target ) */

  ASC_SCSI_BIT_ID_TYPE use_tagged_qng ; /* 20 use tagged queuing, must be capable of tagged queuing */

  ASC_SCSI_BIT_ID_TYPE unit_not_ready ; /* 21 device is spinning up motor */
                                  /* a start unit command has sent to device */
                                  /* bit will be cleared when start unit command is returned */

  ASC_SCSI_BIT_ID_TYPE queue_full_or_busy ; /* 22 tagged queue full */

  ASC_SCSI_BIT_ID_TYPE  start_motor ;     /* 23 send start motor at init  */
  uchar    scsi_reset_wait ;  /* 24 delay number of second after scsi bus reset */
  uchar    chip_no ;         /*  25 should be assigned by caller */
                             /*   to know which chip is causing the interrupt */
                             /*   has no meaning inside library */
  char     is_in_int ;       /* 26  is (TRUE) if inside ISR */
  uchar    max_total_qng ;   /* 27 maximum total number of queued command allowed */

  uchar    cur_total_qng ;   /* 28 total number of queue issue to RISC */
  /* uchar    sdtr_reject ;      reject if SDTR period below 5MB/sec */
  /* uchar    max_single_qng ;   maximum number of queued command per target id */
                             /*    this is not used anymore */
  uchar    in_critical_cnt ; /* 29 non-zero if in critical section */

  uchar    irq_no ;          /* 30 IRQ number */
  uchar    last_q_shortage ; /* 31 number of queue required, set when request failed */

  ushort   init_state ;      /* 32 indicate which initialization stage */
  uchar    cur_dvc_qng[ ASC_MAX_TID+1 ] ; /* 34-41 number of request issued to each target ( and its LUN ) */
  uchar    max_dvc_qng[ ASC_MAX_TID+1 ] ; /* 42-49 maximum number of request per target device */

  ASC_SCSI_Q dosfar *scsiq_busy_head[ ASC_MAX_TID+1 ] ; /* busy queue */
  ASC_SCSI_Q dosfar *scsiq_busy_tail[ ASC_MAX_TID+1 ] ; /* busy queue */

/*
** BIOS will not use fields below here
**
**  uchar    max_qng[ ASC_MAX_TID+1 ] ;
**  uchar    cur_qng[ ASC_MAX_TID+1 ] ;
**  uchar    sdtr_data[ ASC_MAX_TID+1 ] ;
*/

  uchar    sdtr_period_tbl[ ASC_MAX_SYN_XFER_NO ] ;
  /* ulong    int_count ; */  /* number of request */

/*
** the following field will not be used after initilization
** you may discard the buffer after initialization is done
*/
  ASC_DVC_CFG dosfar *cfg ;  /* pointer to configuration buffer */
  Ptr2Func saved_ptr2func ;  /* reserved for internal working, and for future expansion */
  ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always ;
  char     redo_scam ;
  ushort   res2 ;
  uchar    dos_int13_table[ ASC_MAX_TID+1 ] ;
  ulong max_dma_count ;
  ASC_SCSI_BIT_ID_TYPE no_scam ;
  ASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer ;
  uchar    max_sdtr_index ;
  uchar    host_init_sdtr_index ; /* added since, S89 */
  ulong    drv_ptr ; /* driver pointer to private structure */
  ulong    uc_break ; /* micro code break point calling function */
  ulong    res7 ;
  ulong    res8 ;
} ASC_DVC_VAR ;

typedef int ( dosfar *ASC_ISR_CALLBACK )( ASC_DVC_VAR asc_ptr_type *, ASC_QDONE_INFO dosfar * ) ;
typedef int ( dosfar *ASC_EXE_CALLBACK )( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;

/*
** this is ued in AscInitScsiTarget( ) to return inquiry data
*/
typedef struct asc_dvc_inq_info {
  uchar type[ ASC_MAX_TID+1 ][ ASC_MAX_LUN+1 ] ;
} ASC_DVC_INQ_INFO ;

typedef struct asc_cap_info {
  ulong lba ;       /* the maximum logical block size */
  ulong blk_size ;  /* the logical block size in bytes */
} ASC_CAP_INFO ;

typedef struct asc_cap_info_array {
  ASC_CAP_INFO  cap_info[ ASC_MAX_TID+1 ][ ASC_MAX_LUN+1 ] ;
} ASC_CAP_INFO_ARRAY ;

/*
** the aspimgr control word at EEPROM word offset 14
** also in ASC_DVC_VAR dvc_cntl field
**
**
** the following is enabled when bit cleared
** used by micro code
*/
#define ASC_MCNTL_NO_SEL_TIMEOUT  ( ushort )0x0001 /* no selection time out */
#define ASC_MCNTL_NULL_TARGET     ( ushort )0x0002 /* null targets simulation */
                                         /* operation always successful */
/*
** the following is enabled when bit set
** used by device driver
*/
#define ASC_CNTL_INITIATOR         ( ushort )0x0001 /* control */
#define ASC_CNTL_BIOS_GT_1GB       ( ushort )0x0002 /* bios will support greater than 1GB disk */
#define ASC_CNTL_BIOS_GT_2_DISK    ( ushort )0x0004 /* bios will support more than 2 disk */
#define ASC_CNTL_BIOS_REMOVABLE    ( ushort )0x0008 /* bios support removable disk drive */
#define ASC_CNTL_NO_SCAM           ( ushort )0x0010 /* do not call SCAM at init time */
/* #define ASC_CNTL_NO_PCI_FIX_ASYN_XFER ( ushort )0x0020 */ /* fix PCI rev A/B async data xfer problem */
                                                       /* default is off, bit set */
#define ASC_CNTL_INT_MULTI_Q       ( ushort )0x0080 /* process more than one queue for every interrupt */

#define ASC_CNTL_NO_LUN_SUPPORT    ( ushort )0x0040

#define ASC_CNTL_NO_VERIFY_COPY    ( ushort )0x0100 /* verify copy to local ram */
#define ASC_CNTL_RESET_SCSI        ( ushort )0x0200 /* reset scsi bus at start up */
#define ASC_CNTL_INIT_INQUIRY      ( ushort )0x0400 /* inquiry target during init */
#define ASC_CNTL_INIT_VERBOSE      ( ushort )0x0800 /* verbose display of initialization */

#define ASC_CNTL_SCSI_PARITY       ( ushort )0x1000
#define ASC_CNTL_BURST_MODE        ( ushort )0x2000

/* #define ASC_CNTL_USE_8_IOP_BASE    ( ushort )0x4000 */
#define ASC_CNTL_SDTR_ENABLE_ULTRA  ( ushort )0x4000 /* bit set is ultra enabled */
                                                     /* default is ultra enabled */
                                                     /* when disable, it need to disable target inited sdtr at 20mb/sec also */
                                                     /* if disabled, use 10mb/sec sdtr instead of 20mb/sec */
/* #define ASC_CNTL_FIX_DMA_OVER_WR  ( ushort )0x4000  restore the overwritten one byte */
/* #define ASC_CNTL_INC_DATA_CNT     ( ushort )0x8000  increase transfer count by one */

/*
** ASC-1000 EEPROM configuration ( 16 words )
*/

/*
** to fix version 3 chip problem, we use EEPROM word from 0 to 15
**
**
*/
/*
** only version 3 has this bug !!!
*/

#define ASC_EEP_DVC_CFG_BEG_VL    2 /* we use eeprom from index 2 for VL version 3 */
#define ASC_EEP_MAX_DVC_ADDR_VL   15 /* number of words used by driver configuration */

#define ASC_EEP_DVC_CFG_BEG      32 /* we use eeprom from index 32 */
#define ASC_EEP_MAX_DVC_ADDR     45 /* number of words used by driver configuration */

#define ASC_EEP_DEFINED_WORDS    10 /* number of eeprom usage word defined */
#define ASC_EEP_MAX_ADDR         63 /* maximum word address from zero */
#define ASC_EEP_RES_WORDS         0 /* number of reserved word */
#define ASC_EEP_MAX_RETRY        20 /* maximum number of retries write eeprom */
#define ASC_MAX_INIT_BUSY_RETRY   8 /* retry at init driver */

/*
** ISA PNP resource size in words
*/
#define ASC_EEP_ISA_PNP_WSIZE    16

typedef struct asceep_config {
  ushort cfg_lsw ;         /* 00 */
  ushort cfg_msw ;         /* 01 */

#if 0
  ushort pnp_resource[ ASC_EEP_ISA_PNP_WSIZE ] ;
#endif

                           /*        for detail see xxxx */
  uchar  init_sdtr ;       /* 02L    host initiate SDTR, default 0x00 */
  uchar  disc_enable ;     /* 02H    disconnection enabled, default 0xFF */

  uchar  use_cmd_qng ;     /* 03L    use command queuing if possible */
                           /*        default 0x00 */
  uchar  start_motor ;     /* 03H    send start motor command, default 0x00 */
  uchar  max_total_qng ;   /*        maximum total number of queued commands                */
  uchar  max_tag_qng ;     /*        maximum number of tag queue command per target id      */
  uchar  bios_scan ;       /* 04L    BIOS will try to scan and take over the device         */
                           /*        if BIOS is enabled, one of the bit here should be set  */
                           /*        default 0x01                                           */
                           /*        if zero, BIOS is disabled, but may still               */
                           /*        occupied a address space, depends on bios_addr         */

  uchar  power_up_wait ;   /*  04H   BIOS delay number of second when first come up */

  uchar  no_scam ;          /* 05L   non-SCAM tolerant device */
  uchar  chip_scsi_id : 4 ; /* 05H   the chip SCSI id */
                            /* default should be 0x80 ( target id 7 ) */
  uchar  isa_dma_speed : 4 ;  /* 06H high nibble, ISA Chip DMA Speed  */
                                                   /*     0 - 10MB - default */
                                                   /*     1 - 7.69 MB */
                                                   /*     2 - 6.66 MB */
                                                   /*     3 - 5.55 MB */
                                                   /*     4 - 5.00 MB */
                                                   /*     5 - 4.00 MB */
                                                   /*     6 - 3.33 MB */
                                                   /*     7 - 2.50 MB */
  uchar  dos_int13_table[ ASC_MAX_TID+1 ] ;

#if 0
  uchar  sdtr_data[ ASC_MAX_TID+1 ] ;  /* 07-10  SDTR value to 8 target devices */
                           /*        lower nibble is SDTR offset ( default 0xf )                           */
                           /*        high nibble is SDTR period index ( default 0, 10MB/sec )              */
                           /*        default value will be 0x0F                                            */
#endif

  uchar  adapter_info[ 6 ] ;       /* 11-13 host adapter information  */
  /* DATE: 5-17-94,  micro code control word will not read from EEPROM */
  /* ushort mcode_cntl ;             set to 0xFFFF                                                         */
                           /*      * bit 0 clear: no selection time out                                    */
                           /*      * bit 1 clear: null target simulation                                   */
                           /*        bit 2:                                                                */
                           /*        bit 3:                                                                */
                           /*        bit 4:                                                                */
                           /*        bit 5:                                                                */
                           /*        bit 6:                                                                */
                           /*        bit 7:                                                                */
                           /*                                                                              */
  ushort cntl ;            /* 14     the control word                                                      */
                           /*        default value is 0xffff                                               */
                           /*                                                                              */
                           /* enabled when bit set, default 0xFF                                           */
                           /*                                                                              */
                           /*  bit 0  set: do not act as initiator                                         */
                           /*              ( acting as target )                                            */
                           /*  bit 1  set: BIOS greater than one giga byte support                         */
                           /*  bit 2  set: BIOS support more than two drives                               */
                           /*              ( DOS 5.0 and later only )                                      */
                           /*  bit 3  set: BIOS do not support removable disk drive                               */
                           /*  bit 4  set:                                                                 */
                           /*  bit 5  set:                                                                 */
                           /*  bit 6  set: do not inquiry logical unit number                              */
                           /*  bit 7  set: interrupt service routine will process more than one queue      */
                           /*  bit 8  set: no local RAM copying verification                               */
                           /*  bit 9  set: reset SCSI bus during initialization                            */
                           /*  bit 10 set: inquiry scsi devices during initialization                      */
                           /*  bit 11 set: no initilization verbose display                                */
                           /*  bit 12 set: SCSI parity enabled                                             */
                           /*  bit 13 set: burst mode disabled                                             */
                           /*  bit 14 set: use only default i/o port address set                           */
                           /*  bit 15 set: */
                           /* for chip version 1 only                                                      */
                           /*        bit 14 set: restore DMA overwritten byte                              */
                           /*        bit 15 set: increment data transfer count by one                      */
                           /*                                                                              */
                           /*    * - always use default setting                                            */
                           /*        do not turn off these bits in normal operation                        */
                           /*        turn off for debuging only !!!                                        */
                           /*                                                                              */
  ushort chksum ;          /* 15     check sum of EEPROM                                                   */
} ASCEEP_CONFIG ;


#define ASC_PCI_CFG_LSW_SCSI_PARITY  0x0800
#define ASC_PCI_CFG_LSW_BURST_MODE   0x0080
#define ASC_PCI_CFG_LSW_INTR_ABLE    0x0020

/*
** the EEP command register
*/
#define ASC_EEP_CMD_READ          0x80 /* read operation             */
#define ASC_EEP_CMD_WRITE         0x40 /* write operation            */
#define ASC_EEP_CMD_WRITE_ABLE    0x30 /* enable write opeartion     */
#define ASC_EEP_CMD_WRITE_DISABLE 0x00 /* disable write opeartion    */

#define ASC_OVERRUN_BSIZE  0x00000048UL /* data overrun buffer size */
  /* is 8 bytes more than acutual size to adjust address to double word boundary */

#define ASC_CTRL_BREAK_ONCE        0x0001 /* */
#define ASC_CTRL_BREAK_STAY_IDLE   0x0002 /* */

/*
** important local memory variables address
*/
#define ASCV_MSGOUT_BEG         0x0000  /* send message out buffer begin */
#define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)
#define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)

#define ASCV_BREAK_SAVED_CODE   ( ushort )0x0006 /* the saved old instruction code */

#define ASCV_MSGIN_BEG          (ASCV_MSGOUT_BEG+8) /* message in buffer begin */
#define ASCV_MSGIN_SDTR_PERIOD  (ASCV_MSGIN_BEG+3)
#define ASCV_MSGIN_SDTR_OFFSET  (ASCV_MSGIN_BEG+4)

#define ASCV_SDTR_DATA_BEG      (ASCV_MSGIN_BEG+8)
#define ASCV_SDTR_DONE_BEG      (ASCV_SDTR_DATA_BEG+8)
#define ASCV_MAX_DVC_QNG_BEG    ( ushort )0x0020 /* maximum number of tagged queue per device */

#define ASCV_BREAK_ADDR           ( ushort )0x0028 /* */
#define ASCV_BREAK_NOTIFY_COUNT   ( ushort )0x002A /* when to call DvcNotifyUcBreak() when hit count reach this value */
#define ASCV_BREAK_CONTROL        ( ushort )0x002C /* */
#define ASCV_BREAK_HIT_COUNT      ( ushort )0x002E /* current break address hit count, clear to zero */
                                                   /* after reach number specified in ASC_BREAK_NOTIFY_COUNT */

/* #define ASCV_LAST_HALTCODE_W ( ushort )0x0030  last saved halt code */
#define ASCV_ASCDVC_ERR_CODE_W  ( ushort )0x0030  /* last saved halt code */
#define ASCV_MCODE_CHKSUM_W   ( ushort )0x0032 /* code section check sum */
#define ASCV_MCODE_SIZE_W     ( ushort )0x0034 /* code size check sum */
#define ASCV_STOP_CODE_B      ( ushort )0x0036 /* stop RISC queue processing */
#define ASCV_DVC_ERR_CODE_B   ( ushort )0x0037 /* for device driver ( not library ) fatal error code */

#define ASCV_OVERRUN_PADDR_D  ( ushort )0x0038 /* data overrun buffer physical address */
#define ASCV_OVERRUN_BSIZE_D  ( ushort )0x003C /* data overrun buffer size variable */

#define ASCV_HALTCODE_W       ( ushort )0x0040 /* halt code */
#define ASCV_CHKSUM_W         ( ushort )0x0042 /* code chksum */
#define ASCV_MC_DATE_W        ( ushort )0x0044 /* microcode version date */
#define ASCV_MC_VER_W         ( ushort )0x0046 /* microcode version number */
#define ASCV_NEXTRDY_B        ( ushort )0x0048 /* next ready cdb */
#define ASCV_DONENEXT_B       ( ushort )0x0049 /* next done cdb */
#define ASCV_USE_TAGGED_QNG_B ( ushort )0x004A /* bit field of use tagged queuing device */
#define ASCV_SCSIBUSY_B       ( ushort )0x004B /* bit field of SCSI busy device */
/* #define ASCV_CDBCNT_B         ( ushort )0x004C  2-24-96 obsolete */  /* total cdb count */
#define ASCV_Q_DONE_IN_PROGRESS_B  ( ushort )0x004C  /* ucode send early interrupt */
#define ASCV_CURCDB_B         ( ushort )0x004D /* current active CDB */
#define ASCV_RCLUN_B          ( ushort )0x004E /* current active CDB */
#define ASCV_BUSY_QHEAD_B     ( ushort )0x004F /* busy queue head */
#define ASCV_DISC1_QHEAD_B    ( ushort )0x0050 /* SCSI 1 queue disconnected head */
/* #define ASCV_SDTR_DONE_B      ( ushort )0x0051 bit set is disconnection priviledge enabled */
#define ASCV_DISC_ENABLE_B    ( ushort )0x0052 /* bit set is disconnection priviledge enabled */
#define ASCV_CAN_TAGGED_QNG_B ( ushort )0x0053 /* bit field of capable tagged queuing device */
#define ASCV_HOSTSCSI_ID_B    ( ushort )0x0055 /* host scsi id */
#define ASCV_MCODE_CNTL_B     ( ushort )0x0056 /* micro code control word */
#define ASCV_NULL_TARGET_B    ( ushort )0x0057

#define ASCV_FREE_Q_HEAD_W    ( ushort )0x0058 /* */
#define ASCV_DONE_Q_TAIL_W    ( ushort )0x005A /* */
#define ASCV_FREE_Q_HEAD_B    ( ushort )(ASCV_FREE_Q_HEAD_W+1)
#define ASCV_DONE_Q_TAIL_B    ( ushort )(ASCV_DONE_Q_TAIL_W+1)

#define ASCV_HOST_FLAG_B      ( ushort )0x005D /* HOST adadpter action flag */

#define ASCV_TOTAL_READY_Q_B  ( ushort )0x0064 /* total number of ready queue(s) */
#define ASCV_VER_SERIAL_B     ( ushort )0x0065 /* micro code modification serial number */
#define ASCV_HALTCODE_SAVED_W ( ushort )0x0066 /* error code, that is go to happened if it is not a bus free */
#define ASCV_WTM_FLAG_B       ( ushort )0x0068 /* watch dog timeout flag */
#define ASCV_RISC_FLAG_B      ( ushort )0x006A /* HOST adadpter action flag */
#define ASCV_REQ_SG_LIST_QP   ( ushort )0x006B /* requesting sg list qp */

/*
** definition of ASCV_HOST_FLAG_B
*/
#define ASC_HOST_FLAG_IN_ISR        0x01  /* host is processing ISR */
#define ASC_HOST_FLAG_ACK_INT       0x02  /* host is acknowledging interrupt */

#define ASC_RISC_FLAG_GEN_INT      0x01  /* risc is generating interrupt */
#define ASC_RISC_FLAG_REQ_SG_LIST  0x02  /* risc is requesting more sg list */

#define IOP_CTRL         (0x0F) /* chip control */
#define IOP_STATUS       (0x0E) /* chip status */
#define IOP_INT_ACK      IOP_STATUS /* write only - interrupt ack */

/*
** bank zero, i/o port address
*/
#define IOP_REG_IFC      (0x0D)   /* interface control register, byte */
                                  /* for ASC-1090, ISA PNP, ver number from 33(0x21) */
                                  /* default value = 0x09 */
#define IOP_SYN_OFFSET    (0x0B)
#define IOP_EXTRA_CONTROL (0x0D)  /* byte register, begin with PCI ultra chip */
#define IOP_REG_PC        (0x0C)
#define IOP_RAM_ADDR      (0x0A)
#define IOP_RAM_DATA      (0x08)
#define IOP_EEP_DATA      (0x06)
#define IOP_EEP_CMD       (0x07)

#define IOP_VERSION       (0x03)
#define IOP_CONFIG_HIGH   (0x04)
#define IOP_CONFIG_LOW    (0x02)
#define IOP_SIG_BYTE      (0x01)
#define IOP_SIG_WORD      (0x00)

/*
** bank one, i/o port address
*/
#define IOP_REG_DC1      (0x0E)
#define IOP_REG_DC0      (0x0C)
#define IOP_REG_SB       (0x0B) /* scsi data bus */
#define IOP_REG_DA1      (0x0A)
#define IOP_REG_DA0      (0x08)
#define IOP_REG_SC       (0x09) /* scsi control */
#define IOP_DMA_SPEED    (0x07)
#define IOP_REG_FLAG     (0x07) /* flag */
#define IOP_FIFO_H       (0x06)
#define IOP_FIFO_L       (0x04)
#define IOP_REG_ID       (0x05)
#define IOP_REG_QP       (0x03) /* queue pointer */
#define IOP_REG_IH       (0x02) /* instruction holding register */
#define IOP_REG_IX       (0x01) /* index register */
#define IOP_REG_AX       (0x00) /* accumuloator */

/*
** ISA IFC
*/
#define IFC_REG_LOCK      (0x00) /* [3:0] write this value to lock read/write permission to all register */
#define IFC_REG_UNLOCK    (0x09) /* [3:0] write this value to unlock read/write permission to all register */

#define IFC_WR_EN_FILTER  (0x10) /* write only, EN filter */
#define IFC_RD_NO_EEPROM  (0x10) /* read only, No EEPROM */
#define IFC_SLEW_RATE     (0x20) /* SCSI slew rate */
#define IFC_ACT_NEG       (0x40) /* turn on this ( default is off ) */
#define IFC_INP_FILTER    (0x80) /* SCSI input filter */

#define IFC_INIT_DEFAULT  ( IFC_ACT_NEG | IFC_REG_UNLOCK )

/*
** chip scsi control signal
*/
#define SC_SEL   ( uchar )(0x80)
#define SC_BSY   ( uchar )(0x40)
#define SC_ACK   ( uchar )(0x20)
#define SC_REQ   ( uchar )(0x10)
#define SC_ATN   ( uchar )(0x08)
#define SC_IO    ( uchar )(0x04)
#define SC_CD    ( uchar )(0x02)
#define SC_MSG   ( uchar )(0x01)

/*
 * Extra control Register Definitions
 * Bank 0, Base Address + 0xD
 */
#define SEC_SCSI_CTL         ( uchar )( 0x80 )
#define SEC_ACTIVE_NEGATE    ( uchar )( 0x40 )
#define SEC_SLEW_RATE        ( uchar )( 0x20 )
#define SEC_ENABLE_FILTER    ( uchar )( 0x10 )


/*
** the LSB of halt code is the error code
** the MSB of halt code is used as control
*/
#define ASC_HALT_EXTMSG_IN     ( ushort )0x8000 /* halt code of extended message */
#define ASC_HALT_CHK_CONDITION ( ushort )0x8100 /* halt code of extended message */
#define ASC_HALT_SS_QUEUE_FULL ( ushort )0x8200 /* halt code of queue full status */
#define ASC_HALT_DISABLE_ASYN_USE_SYN_FIX  ( ushort )0x8300
#define ASC_HALT_ENABLE_ASYN_USE_SYN_FIX   ( ushort )0x8400
#define ASC_HALT_SDTR_REJECTED ( ushort )0x4000 /* halt code of reject SDTR      */
/* #define ASC_HALT_COPY_SG_LIST_FROM_HOST ( ushort )0x2000 */

/* #define ASC_MAX_QNO        0xFF */
#define ASC_MAX_QNO        0xF8   /* queue used from 0x00 to 0xF7, total=0xF8 */
#define ASC_DATA_SEC_BEG   ( ushort )0x0080 /* data section begin */
#define ASC_DATA_SEC_END   ( ushort )0x0080 /* data section end   */
#define ASC_CODE_SEC_BEG   ( ushort )0x0080 /* code section begin */
#define ASC_CODE_SEC_END   ( ushort )0x0080 /* code section end   */
#define ASC_QADR_BEG       (0x4000) /* queue buffer begin */
#define ASC_QADR_USED      ( ushort )( ASC_MAX_QNO * 64 )
#define ASC_QADR_END       ( ushort )0x7FFF /* queue buffer end */
#define ASC_QLAST_ADR      ( ushort )0x7FC0 /* last queue address, not used */
#define ASC_QBLK_SIZE      0x40
#define ASC_BIOS_DATA_QBEG 0xF8   /* BIOS data section is from queue 0xF8     */
                                  /* total size 64*8=512 bytes                */
#define ASC_MIN_ACTIVE_QNO 0x01   /* minimum queue number of active queue     */
/* #define ASC_MAX_ACTIVE_QNO 0xF0   maximum queue number of active queue  */
#define ASC_QLINK_END      0xFF   /* forward pointer of end of queue       */
#define ASC_EEPROM_WORDS   0x10   /* maximum number of words in EEPROM     */
#define ASC_MAX_MGS_LEN    0x10   /*                                       */

#define ASC_BIOS_ADDR_DEF  0xDC00 /* default BIOS address                      */
#define ASC_BIOS_SIZE      0x3800 /* BIOS ROM size                             */
#define ASC_BIOS_RAM_OFF   0x3800 /* BIOS ram address offset from bios address */
#define ASC_BIOS_RAM_SIZE  0x800  /* BIOS ram size in bytes, 2KB               */
#define ASC_BIOS_MIN_ADDR  0xC000 /* BIOS ram size in bytes, 2KB               */
#define ASC_BIOS_MAX_ADDR  0xEC00 /* BIOS ram size in bytes, 2KB               */
#define ASC_BIOS_BANK_SIZE 0x0400 /* BIOS one bank size                        */


#define ASC_MCODE_START_ADDR  0x0080 /* micro code starting address */

/*
**
*/
#define ASC_CFG0_HOST_INT_ON    0x0020 /* VESA burst mode enable    */
#define ASC_CFG0_BIOS_ON        0x0040 /* BIOS is enabled           */
#define ASC_CFG0_VERA_BURST_ON  0x0080 /* VESA burst mode enable    */
#define ASC_CFG0_SCSI_PARITY_ON 0x0800 /* SCSI parity enable        */

#define ASC_CFG1_SCSI_TARGET_ON 0x0080 /* SCSI target mode enable   */
#define ASC_CFG1_LRAM_8BITS_ON  0x0800 /* 8 bit local RAM access    */

/* use this value to clear any unwanted bits in cfg_msw */
#define ASC_CFG_MSW_CLR_MASK    0x3080
                                        /* clear fast EEPROM CLK */
                                        /* clear fast scsi clk */
                                        /* clear scsi target mode */


/*
** chip status
*/
#if 0
/*
**  VL chip version 1
*/

    #define IOP0B_STAT      ( PortAddr )((_io_port_base)+( PortAddr )0x09)
    #define IOP0B_INT_ACK   ( PortAddr )((_io_port_base)+( PortAddr )0x09)

    #define CS_DMA_DONE     ( ASC_CS_TYPE )0x80 /*                                                       */
    #define CS_FIFO_RDY     ( ASC_CS_TYPE )0x40 /*                                                       */
    #define CS_RAM_DONE     ( ASC_CS_TYPE )0x20 /*                                                       */
    #define CS_HALTED       ( ASC_CS_TYPE )0x10 /* risc halted                                           */
    #define CS_SCSI_RESET   ( ASC_CS_TYPE )0x08 /* scsi reset in                                         */
    #define CS_PARITY_ERR   ( ASC_CS_TYPE )0x04 /* parity error                                          */
    #define CS_INT_HALT     ( ASC_CS_TYPE )0x02 /* interrupt with halt, 11-2-93, replaced by scsi reset  */
    #define CS_INT          ( ASC_CS_TYPE )0x01 /* normal interrupt                                      */
    #define ASC_INT_ACK     ( ASC_CS_TYPE )0x01 /* interrupt acknowledge                                 */

#endif

/*
** chip status: read only
** expaned to word size at chip version 2
*/
    #define CSW_TEST1             ( ASC_CS_TYPE )0x8000 /*                         */
    #define CSW_AUTO_CONFIG       ( ASC_CS_TYPE )0x4000 /* i/o port rotation is on */
    #define CSW_RESERVED1         ( ASC_CS_TYPE )0x2000 /*                         */
    #define CSW_IRQ_WRITTEN       ( ASC_CS_TYPE )0x1000 /* set new IRQ toggled high*/
    #define CSW_33MHZ_SELECTED    ( ASC_CS_TYPE )0x0800 /* use 33 Mhz clock        */
    #define CSW_TEST2             ( ASC_CS_TYPE )0x0400 /*                         */
    #define CSW_TEST3             ( ASC_CS_TYPE )0x0200 /*                         */
    #define CSW_RESERVED2         ( ASC_CS_TYPE )0x0100 /*                         */
    #define CSW_DMA_DONE          ( ASC_CS_TYPE )0x0080 /*                         */
    #define CSW_FIFO_RDY          ( ASC_CS_TYPE )0x0040 /*                         */

/*
**  for VL chip version under 2
**
**  #define CSW_RAM_DONE          ( ASC_CS_TYPE )0x0020
**
*/
    #define CSW_EEP_READ_DONE     ( ASC_CS_TYPE )0x0020

    #define CSW_HALTED            ( ASC_CS_TYPE )0x0010 /* asc-1000 is currently halted         */
    #define CSW_SCSI_RESET_ACTIVE ( ASC_CS_TYPE )0x0008 /* scsi bus reset is still high         */
                                                        /* wait until this bit go low to        */
                                                        /* start chip reset ( initialization )  */
    #define CSW_PARITY_ERR        ( ASC_CS_TYPE )0x0004 /* parity error                         */
    #define CSW_SCSI_RESET_LATCH  ( ASC_CS_TYPE )0x0002 /* scsi bus reset is toggled on         */
                                                        /* normally should stay low             */
    #define CSW_INT_PENDING       ( ASC_CS_TYPE )0x0001 /* interrupt is pending,                */
                                                        /* not acknowledged yet                 */

    /*
    ** interrupt acknowledge register: write only
    */
    #define CIW_CLR_SCSI_RESET_INT ( ASC_CS_TYPE )0x1000  /* clear interrupt caused by scsi reset */

    #define CIW_INT_ACK      ( ASC_CS_TYPE )0x0100 /* interrupt acknowledge bit */
    #define CIW_TEST1        ( ASC_CS_TYPE )0x0200 /* for testing               */
    #define CIW_TEST2        ( ASC_CS_TYPE )0x0400 /* for testing               */
    #define CIW_SEL_33MHZ    ( ASC_CS_TYPE )0x0800 /* interrupt acknowledge bit */

    #define CIW_IRQ_ACT      ( ASC_CS_TYPE )0x1000 /* irq activation, toggle once to set new irq */
                                                   /* normally should stay low */

/*
** chip control
*/
#define CC_CHIP_RESET   ( uchar )0x80 /* reset risc chip  */
#define CC_SCSI_RESET   ( uchar )0x40 /* reset scsi bus   */
#define CC_HALT         ( uchar )0x20 /* halt risc chip   */
#define CC_SINGLE_STEP  ( uchar )0x10 /* single step      */
#define CC_DMA_ABLE     ( uchar )0x08 /* host dma enabled */
#define CC_TEST         ( uchar )0x04 /* test bit         */
#define CC_BANK_ONE     ( uchar )0x02 /* bank switch bit  */
#define CC_DIAG         ( uchar )0x01 /* diagnostic bit   */

/*
** ASC 1000
*/
#define ASC_1000_ID0W      0x04C1 /* ASC1000 signature word */
#define ASC_1000_ID0W_FIX  0x00C1 /* ASC1000 signature word */
#define ASC_1000_ID1B      0x25   /* ASC1000 signature byte */

#define ASC_EISA_BIG_IOP_GAP   (0x1C30-0x0C50)  /* = 0x0FE0 */
#define ASC_EISA_SMALL_IOP_GAP (0x0020)  /*  */
#define ASC_EISA_MIN_IOP_ADDR  (0x0C30)  /*  */
#define ASC_EISA_MAX_IOP_ADDR  (0xFC50)  /*  */
#define ASC_EISA_REV_IOP_MASK  (0x0C83)  /* EISA revision number, from 0x01, MSB of product id */
#define ASC_EISA_PID_IOP_MASK  (0x0C80)  /* product ID i/o port address mask */
#define ASC_EISA_CFG_IOP_MASK  (0x0C86)  /* EISA cfg i/o port address mask */
                                      /* old value is 0x0C86 */
#define ASC_GET_EISA_SLOT( iop )  ( PortAddr )( (iop) & 0xF000 ) /* get EISA slot number */

#define ASC_EISA_ID_740    0x01745004UL  /* EISA single channel */
#define ASC_EISA_ID_750    0x01755004UL  /* EISA dual channel */



/* #define NOP_INS_CODE    ( ushort )0x6200 */
#define INS_HALTINT        ( ushort )0x6281 /* halt with interrupt instruction code */
#define INS_HALT           ( ushort )0x6280 /* halt instruction code */
#define INS_SINT           ( ushort )0x6200 /* set interrupt */
#define INS_RFLAG_WTM      ( ushort )0x7380 /* reset watch dog timer */

/* ---------------------------------------------------------
** meaning of control signal at bank 1 port offset 9
** bit7: sel
** bit6: busy
** bit5: ack
** bit4: req
** bit3: atn
** bit2: i/o
** bit1: c/d
** bit0: msg
*/

#define ASC_MC_SAVE_CODE_WSIZE  0x500  /* size of microcode data section in words to save */
#define ASC_MC_SAVE_DATA_WSIZE  0x40   /* size of microcode code section in words to save */

/*
**
*/
typedef struct asc_mc_saved {
    ushort data[ ASC_MC_SAVE_DATA_WSIZE ] ;
    ushort code[ ASC_MC_SAVE_CODE_WSIZE ] ;
} ASC_MC_SAVED ;


/*
** Macro
*/
#define AscGetQDoneInProgress( port )         AscReadLramByte( (port), ASCV_Q_DONE_IN_PROGRESS_B )
#define AscPutQDoneInProgress( port, val )    AscWriteLramByte( (port), ASCV_Q_DONE_IN_PROGRESS_B, val )

#define AscGetVarFreeQHead( port )            AscReadLramWord( (port), ASCV_FREE_Q_HEAD_W )
#define AscGetVarDoneQTail( port )            AscReadLramWord( (port), ASCV_DONE_Q_TAIL_W )
#define AscPutVarFreeQHead( port, val )       AscWriteLramWord( (port), ASCV_FREE_Q_HEAD_W, val )
#define AscPutVarDoneQTail( port, val )       AscWriteLramWord( (port), ASCV_DONE_Q_TAIL_W, val )

#define AscGetRiscVarFreeQHead( port )        AscReadLramByte( (port), ASCV_NEXTRDY_B )
#define AscGetRiscVarDoneQTail( port )        AscReadLramByte( (port), ASCV_DONENEXT_B )
#define AscPutRiscVarFreeQHead( port, val )   AscWriteLramByte( (port), ASCV_NEXTRDY_B, val )
#define AscPutRiscVarDoneQTail( port, val )   AscWriteLramByte( (port), ASCV_DONENEXT_B, val )

#define AscPutMCodeSDTRDoneAtID( port, id, data )  AscWriteLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DONE_BEG+( ushort )id ), (data) ) ;
#define AscGetMCodeSDTRDoneAtID( port, id )        AscReadLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DONE_BEG+( ushort )id ) ) ;

#define AscPutMCodeInitSDTRAtID( port, id, data )  AscWriteLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DATA_BEG+( ushort )id ), data ) ;
#define AscGetMCodeInitSDTRAtID( port, id )        AscReadLramByte( (port), ( ushort )( ( ushort )ASCV_SDTR_DATA_BEG+( ushort )id ) ) ;

#define AscSynIndexToPeriod( index )        ( uchar )( asc_dvc->sdtr_period_tbl[ (index) ] )

/*
** Macro for get/set Bank 0 registers
*/

#define AscGetChipSignatureByte( port )     ( uchar )inp( (port)+IOP_SIG_BYTE )
#define AscGetChipSignatureWord( port )     ( ushort )inpw( (port)+IOP_SIG_WORD )

#define AscGetChipVerNo( port )             ( uchar )inp( (port)+IOP_VERSION )

#define AscGetChipCfgLsw( port )            ( ushort )inpw( (port)+IOP_CONFIG_LOW )
#define AscGetChipCfgMsw( port )            ( ushort )inpw( (port)+IOP_CONFIG_HIGH )
#define AscSetChipCfgLsw( port, data )      outpw( (port)+IOP_CONFIG_LOW, data )
#define AscSetChipCfgMsw( port, data )      outpw( (port)+IOP_CONFIG_HIGH, data )

#define AscGetChipEEPCmd( port )            ( uchar )inp( (port)+IOP_EEP_CMD )
#define AscSetChipEEPCmd( port, data )      outp( (port)+IOP_EEP_CMD, data )
#define AscGetChipEEPData( port )           ( ushort )inpw( (port)+IOP_EEP_DATA )
#define AscSetChipEEPData( port, data )     outpw( (port)+IOP_EEP_DATA, data )

#define AscGetChipLramAddr( port )          ( ushort )inpw( ( PortAddr )((port)+IOP_RAM_ADDR) )
#define AscSetChipLramAddr( port, addr )    outpw( ( PortAddr )( (port)+IOP_RAM_ADDR ), addr )
#define AscGetChipLramData( port )          ( ushort )inpw( (port)+IOP_RAM_DATA )
#define AscSetChipLramData( port, data )    outpw( (port)+IOP_RAM_DATA, data )
#define AscGetChipLramDataNoSwap( port )         ( ushort )inpw_noswap( (port)+IOP_RAM_DATA )
#define AscSetChipLramDataNoSwap( port, data )   outpw_noswap( (port)+IOP_RAM_DATA, data )

#define AscGetChipIFC( port )               ( uchar )inp( (port)+IOP_REG_IFC )
#define AscSetChipIFC( port, data )          outp( (port)+IOP_REG_IFC, data )

#define AscGetChipStatus( port )            ( ASC_CS_TYPE )inpw( (port)+IOP_STATUS )
#define AscSetChipStatus( port, cs_val )    outpw( (port)+IOP_STATUS, cs_val )

#define AscGetChipControl( port )           ( uchar )inp( (port)+IOP_CTRL )
#define AscSetChipControl( port, cc_val )   outp( (port)+IOP_CTRL, cc_val )

#define AscGetChipSyn( port )               ( uchar )inp( (port)+IOP_SYN_OFFSET )
#define AscSetChipSyn( port, data )         outp( (port)+IOP_SYN_OFFSET, data )

#define AscSetPCAddr( port, data )          outpw( (port)+IOP_REG_PC, data )
#define AscGetPCAddr( port )                ( ushort )inpw( (port)+IOP_REG_PC )


#define AscIsIntPending( port )             ( AscGetChipStatus(port) & ( CSW_INT_PENDING | CSW_SCSI_RESET_LATCH ) )
#define AscGetChipScsiID( port )            ( ( AscGetChipCfgLsw(port) >> 8 ) & ASC_MAX_TID )


/* this extra control begin with PCI ultra chip */
#define AscGetExtraControl( port )          ( uchar )inp( (port)+IOP_EXTRA_CONTROL )
#define AscSetExtraControl( port, data )    outp( (port)+IOP_EXTRA_CONTROL, data )

/* AscSetChipScsiID() is a function */

/*
** Macro for read/write BANK 1 registers
*/

#define AscReadChipAX( port )               ( ushort )inpw( (port)+IOP_REG_AX )
#define AscWriteChipAX( port, data )        outpw( (port)+IOP_REG_AX, data )

#define AscReadChipIX( port )               ( uchar )inp( (port)+IOP_REG_IX )
#define AscWriteChipIX( port, data )        outp( (port)+IOP_REG_IX, data )

#define AscReadChipIH( port )               ( ushort )inpw( (port)+IOP_REG_IH )
#define AscWriteChipIH( port, data )        outpw( (port)+IOP_REG_IH, data )

#define AscReadChipQP( port )               ( uchar )inp( (port)+IOP_REG_QP )
#define AscWriteChipQP( port, data )        outp( (port)+IOP_REG_QP, data )

#define AscReadChipFIFO_L( port )           ( ushort )inpw( (port)+IOP_REG_FIFO_L )
#define AscWriteChipFIFO_L( port, data )    outpw( (port)+IOP_REG_FIFO_L, data )
#define AscReadChipFIFO_H( port )           ( ushort )inpw( (port)+IOP_REG_FIFO_H )
#define AscWriteChipFIFO_H( port, data )    outpw( (port)+IOP_REG_FIFO_H, data )

#define AscReadChipDmaSpeed( port )         ( uchar )inp( (port)+IOP_DMA_SPEED )
#define AscWriteChipDmaSpeed( port, data )  outp( (port)+IOP_DMA_SPEED, data )

#define AscReadChipDA0( port )              ( ushort )inpw( (port)+IOP_REG_DA0 )
#define AscWriteChipDA0( port )             outpw( (port)+IOP_REG_DA0, data )
#define AscReadChipDA1( port )              ( ushort )inpw( (port)+IOP_REG_DA1 )
#define AscWriteChipDA1( port )             outpw( (port)+IOP_REG_DA1, data )

#define AscReadChipDC0( port )              ( ushort )inpw( (port)+IOP_REG_DC0 )
#define AscWriteChipDC0( port )             outpw( (port)+IOP_REG_DC0, data )
#define AscReadChipDC1( port )              ( ushort )inpw( (port)+IOP_REG_DC1 )
#define AscWriteChipDC1( port )             outpw( (port)+IOP_REG_DC1, data )

#define AscReadChipDvcID( port )            ( uchar )inp( (port)+IOP_REG_ID )
#define AscWriteChipDvcID( port, data )     outp( (port)+IOP_REG_ID, data )


#endif /* __ASC1000_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_eep.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_eep.c
**
*/

#include "ascinc.h"

#if CC_INCLUDE_EEP_CONFIG

#if 0

/*
**  how "ABP" is compress to 0x0450
**                      byte 0 bit 7 is 0
**  'A' equal 0b00001 - is byte 0 bit[6:2]
**  'B' equal 0b00010 - is byte 0 bit[1:0] and byte 1 bit[7:5]
**  'P' equal 0b10000 - is byte 1 bit[4:0]
**
**              A     B     P
**  binrary 0,00001,00010,10000  = 0x0450
*/


#define ISA_VID_LSW  0x5004 /* ABP compressed */
#define ISA_VID_MSW  0x0154 /* 0x54 plus revision number 0x01 */

/*
**  serial number byte 0 is unique device number, set to 0xZZ
**  means SCSI HOST ADAPTER
**
**  byte 1 to byte 3 is product serial number
**
**  currently only support one per system, thus 0xffffffff
*/

#define ISA_SERIAL_LSW  0xFF01
#define ISA_SERIAL_MSW  0xFFFF

ushort _isa_pnp_resource[ ] = {
        ISA_VID_MSW, ISA_VID_LSW, ISA_SERIAL_MSW, ISA_SERIAL_LSW, 0x0A3E,
        0x0129, 0x0015, 0x0000, 0x0100, 0x702A,
        0x220C, 0x9C00, 0x0147, 0x0100, 0x03F0,
        0x1010, 0xFD79 } ;

#endif /* if PNP */

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    AscWriteEEPCmdReg(
          PortAddr iop_base,
          uchar cmd_reg
       )
{
       uchar  read_back ;
       int    retry ;
#if 0
       uchar  numstr[ 12 ] ;
#endif
       retry = 0 ;
       while( TRUE )
       {
           AscSetChipEEPCmd( iop_base, cmd_reg ) ;
           DvcSleepMilliSecond( 1 ) ;
           read_back = AscGetChipEEPCmd( iop_base ) ;
           if( read_back == cmd_reg )
           {
               return( 1 ) ;
           }/* if */
           if( retry++ > ASC_EEP_MAX_RETRY )
           {
               return( 0 ) ;
           }/* if */
#if 0
           else
           {
               DvcDisplayString( "Write eep_cmd 0x" ) ;
               DvcDisplayString( tohstr( cmd_reg, numstr ) ) ;
               DvcDisplayString( ", read back 0x" ) ;
               DvcDisplayString( tohstr( read_back, numstr ) ) ;
               DvcDisplayString( "\r\n" ) ;

/*             printf( "write eeprom cmd reg 0x%04X, read back 0x%04X\n", cmd_reg, read_back ) ; */

           }/* else */
#endif
       }/* while */
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    AscWriteEEPDataReg(
          PortAddr iop_base,
          ushort data_reg
       )
{
       ushort  read_back ;
       int     retry ;

       retry = 0 ;
       while( TRUE )
       {
           AscSetChipEEPData( iop_base, data_reg ) ;
           DvcSleepMilliSecond( 1 ) ;
           read_back = AscGetChipEEPData( iop_base ) ;
           if( read_back == data_reg )
           {
               return( 1 ) ;
           }/* if */
           if( retry++ > ASC_EEP_MAX_RETRY )
           {
               return( 0 ) ;
           }/* if */
#if 0
           else
           {

               printf( "write eeprom data reg 0x%04X, read back 0x%04X\n", data_reg, read_back ) ;

           }/* else */
#endif
       }/* while */
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWaitEEPRead(
          void
       )
{
#if 0
/*
** h/w support of EEPROM done status
** this is not working properly
*/
       while( ( AscGetChipStatus( iop_base ) & CSW_EEP_READ_DONE ) == 0 ) ;
       while( ( AscGetChipStatus( iop_base ) & CSW_EEP_READ_DONE ) != 0 ) ;
#endif
       DvcSleepMilliSecond( 1 ) ;  /* data will be ready in 24 micro second */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWaitEEPWrite(
          void
       )
{
       DvcSleepMilliSecond( 20 ) ;  /* data will be ready in 24 micro second */
       return ;
}

/* ----------------------------------------------------------------------
** ushort AscReadEEPWord( ushort iop_base, ushort addr )
**
** description:
**
** return: return the word read from EEPROM
**
** Note: you must halt chip to access eeprom
** ------------------------------------------------------------------- */
ushort AscReadEEPWord(
          PortAddr iop_base,
          uchar  addr
       )
{
       ushort  read_wval ;
       uchar   cmd_reg ;

       AscWriteEEPCmdReg( iop_base, ASC_EEP_CMD_WRITE_DISABLE ) ;
       AscWaitEEPRead( ) ;
       cmd_reg = addr | ASC_EEP_CMD_READ ;
       AscWriteEEPCmdReg( iop_base, cmd_reg ) ;
       AscWaitEEPRead( ) ;
       read_wval = AscGetChipEEPData( iop_base ) ;
       AscWaitEEPRead( ) ;
       return( read_wval ) ;
}

/* ---------------------------------------------------------------------
** ushort AscWriteEEPWord( ushort iop_base, ushort addr, ushort word_value )
**
** description:
**
** return: return the word read back from EEPROM after written
**
** ------------------------------------------------------------------- */
ushort AscWriteEEPWord(
          PortAddr iop_base,
          uchar  addr,
          ushort word_val
       )
{
       ushort  read_wval ;

       read_wval = AscReadEEPWord( iop_base, addr ) ;
       if( read_wval != word_val )
       {
           AscWriteEEPCmdReg( iop_base, ASC_EEP_CMD_WRITE_ABLE ) ;
           AscWaitEEPRead( ) ;

           AscWriteEEPDataReg( iop_base, word_val ) ;
           AscWaitEEPRead( ) ;

           AscWriteEEPCmdReg( iop_base,
                       ( uchar )( ( uchar )ASC_EEP_CMD_WRITE | addr ) ) ;
           AscWaitEEPWrite( ) ;
/*
** we disable write EEP
** DATE: 5-6-94, we found this will cause it write to another location !
*/
           AscWriteEEPCmdReg( iop_base, ASC_EEP_CMD_WRITE_DISABLE ) ;
           AscWaitEEPRead( ) ;
           return( AscReadEEPWord( iop_base, addr ) ) ;
       }/* if */
       return( read_wval ) ;
}

/* ----------------------------------------------------------------------
** ushort AscGetEEPConfig( PortAddr iop_base, ushort *wbuf )
**
** description: read entire EEPROM configuration to buffer
**
** return: return the word read from EEPROM
**
** ------------------------------------------------------------------- */
ushort AscGetEEPConfig(
          PortAddr iop_base,
          ASCEEP_CONFIG dosfar *cfg_buf, ushort bus_type
       )
{
       ushort  wval ;
       ushort  sum ;
       ushort  dosfar *wbuf ;
       int     cfg_beg ;
       int     cfg_end ;
       int     s_addr ;
       int     isa_pnp_wsize ;

       wbuf = ( ushort dosfar *)cfg_buf ;
       sum = 0 ;
/*
** get chip configuration word
*/

       isa_pnp_wsize = 0 ;
#if 0
       if( ( bus_type & ASC_IS_ISA ) != 0 )
       {
           isa_pnp_wsize = ASC_EEP_ISA_PNP_WSIZE ;
       }/* if */
#endif
       for( s_addr = 0 ; s_addr < ( 2 + isa_pnp_wsize ) ; s_addr++, wbuf++ )
       {
            wval = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
            sum += wval ;
            *wbuf = wval ;
       }/* for */

       if( bus_type & ASC_IS_VL )
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG_VL ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR_VL ;
       }/* if */
       else
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR ;
       }/* else */

       for( s_addr = cfg_beg ; s_addr <= ( cfg_end - 1 ) ;
            s_addr++, wbuf++ )
       {
            wval = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
            sum += wval ;
            *wbuf = wval ;
       }/* for */
       *wbuf = AscReadEEPWord( iop_base, ( uchar )s_addr ) ;
       return( sum ) ;
}


#if CC_CHK_FIX_EEP_CONTENT

/* ----------------------------------------------------------------------
** ushort AscSetEEPConfig( ushort iop_base, ushort *wbuf )
**
** description: write entire configuration buffer
**              ( struct ASCEEP_CONFIG ) to EEPROM
**
** return: return the word read from EEPROM
**
** Note: you must halt chip to access eeprom
** ------------------------------------------------------------------- */
int    AscSetEEPConfigOnce(
          PortAddr iop_base,
          ASCEEP_CONFIG dosfar *cfg_buf, ushort bus_type
       )
{
       int     n_error ;
       ushort  dosfar *wbuf ;
       ushort  sum ;
       int     s_addr ;
       int     cfg_beg ;
       int     cfg_end ;

       wbuf = ( ushort dosfar *)cfg_buf ;
       n_error = 0 ;
       sum = 0 ;
       for( s_addr = 0 ; s_addr < 2 ; s_addr++, wbuf++ )
       {
            sum += *wbuf ;
            if( *wbuf != AscWriteEEPWord( iop_base, ( uchar )s_addr, *wbuf ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
#if 0
       if( ( bus_type & ASC_IS_ISAPNP ) ) == ASC_IS_ISAPNP )
       {
           for( i = 0 ; i < ASC_EEP_ISA_PNP_WSIZE ; s_addr++, wbuf++, i++ )
           {
                wval = _isa_pnp_resource[ i ] ;
                sum += wval ;
                if( wval != AscWriteEEPWord( iop_base, s_addr, wval ) )
                {
                    n_error++ ;
                }/* if */
           }/* for */
       }/* if */
#endif
       if( bus_type & ASC_IS_VL )
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG_VL ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR_VL ;
       }/* if */
       else
       {
           cfg_beg = ASC_EEP_DVC_CFG_BEG ;
           cfg_end = ASC_EEP_MAX_DVC_ADDR ;
       }/* else */
       for( s_addr = cfg_beg ; s_addr <= ( cfg_end - 1 ) ;
            s_addr++, wbuf++ )
       {
            sum += *wbuf ;
            if( *wbuf != AscWriteEEPWord( iop_base, ( uchar )s_addr, *wbuf ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
       *wbuf = sum ;
       if( sum != AscWriteEEPWord( iop_base, ( uchar )s_addr, sum ) )
       {
           n_error++ ;
       }/* if */
/*
**  for version 3 chip, we read back the whole block again
*/
       wbuf = ( ushort dosfar *)cfg_buf ;
       for( s_addr = 0 ; s_addr < 2 ; s_addr++, wbuf++ )
       {
            if( *wbuf != AscReadEEPWord( iop_base, ( uchar )s_addr ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
       for( s_addr = cfg_beg ; s_addr <= cfg_end ;
            s_addr++, wbuf++ )
       {
            if( *wbuf != AscReadEEPWord( iop_base, ( uchar )s_addr ) )
            {
                n_error++ ;
            }/* if */
       }/* for */
       return( n_error ) ;
}

/* ----------------------------------------------------------------------
** ushort AscSetEEPConfig( ushort iop_base, ushort *wbuf )
**
** description: write entire configuration buffer
**              ( struct ASCEEP_CONFIG ) to EEPROM
**
** return: return the word read from EEPROM
**
** Note: you must halt chip to access eeprom
** ------------------------------------------------------------------- */
int    AscSetEEPConfig(
          PortAddr iop_base,
          ASCEEP_CONFIG dosfar *cfg_buf, ushort bus_type
       )
{
       int   retry ;
       int   n_error ;

       retry = 0 ;
       while( TRUE )
       {
           if( ( n_error = AscSetEEPConfigOnce( iop_base, cfg_buf,
               bus_type ) ) == 0 )
           {
               break ;
           }/* if */
           if( ++retry > ASC_EEP_MAX_RETRY )
           {
               break ;
           }/* if */
       }/* while */
       return( n_error ) ;
}
#endif /* CC_CHK_FIX_EEP_CONTENT */

/* ---------------------------------------------------------------------
** ushort AscEEPSum( ushort iop_base, ushort s_addr, ushort words )
**
** description:
**
** return: return the word read from EEPROM
**
** ------------------------------------------------------------------ */
ushort AscEEPSum(
          PortAddr iop_base,
          uchar s_addr,
          uchar words
       )
{
       ushort  sum ;
       uchar   e_addr ;
       uchar   addr ;

       e_addr = s_addr + words ;
       sum = 0 ;
       if( s_addr > ASC_EEP_MAX_ADDR ) return( sum ) ;
       if( e_addr > ASC_EEP_MAX_ADDR ) e_addr = ASC_EEP_MAX_ADDR ;
       for( addr = s_addr ; addr < e_addr ; addr++ )
       {
            sum += AscReadEEPWord( iop_base, addr ) ;
       }/* for */
       return( sum ) ;
}

#endif /* CC_INCLUDE_EEP_CONFIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_chip.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_chip.c
**
*/

#include "ascinc.h"

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
int    AscStartChip(
          PortAddr iop_base
       )
{
       AscSetChipControl( iop_base, 0 ) ;
       if( ( AscGetChipStatus( iop_base ) & CSW_HALTED ) != 0 )
       {
           return( 0 ) ; /* cannot start chip */
       }/* if */
       return( 1 ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
int    AscStopChip(
          PortAddr iop_base
       )
{
       uchar  cc_val ;

       cc_val = AscGetChipControl( iop_base ) & ( ~( CC_SINGLE_STEP | CC_TEST | CC_DIAG ) ) ;
       AscSetChipControl( iop_base, ( uchar )( cc_val | CC_HALT ) ) ;
       AscSetChipIH( iop_base, INS_HALT ) ;
       AscSetChipIH( iop_base, INS_RFLAG_WTM ) ;
       if( ( AscGetChipStatus( iop_base ) & CSW_HALTED ) == 0 )
       {
           return( 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
int    AscIsChipHalted(
          PortAddr iop_base
       )
{

       if( ( AscGetChipStatus( iop_base ) & CSW_HALTED ) != 0 )
       {
           if( ( AscGetChipControl( iop_base ) & CC_HALT ) != 0 )
           {
               return( 1 ) ;
           }/* if */
       }/* if */
       return( 0 ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscSetChipIH(
          PortAddr iop_base,
          ushort ins_code
       )
{
       AscSetBank( iop_base, 1 ) ;
       AscWriteChipIH( iop_base, ins_code ) ;
       AscSetBank( iop_base, 0 ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscAckInterrupt(
          PortAddr iop_base
       )
{
       /*  ushort  cfg ;  */
       uchar   host_flag ;
       uchar   risc_flag ;
       ushort  loop ;

/*
**       cfg = inpw( IOP0W_CONFIG_LOW ) ;
**       cfg &= CIW_SEL_33MHZ ;
**       cfg |= CIW_INT_ACK ;
**       outpw( IOP0W_INT_ACK, cfg ) ;
*/

#if 0
       /* disable interrupt at CFG  */
       cfg = AscGetChipCfgLsw( iop_base ) ;
       AscSetChipCfgLsw( iop_base, cfg & ~ASC_CFG0_HOST_INT_ON ) ;
#endif
       loop = 0 ;
       do {
           risc_flag = AscReadLramByte( iop_base, ASCV_RISC_FLAG_B ) ;
           if( loop++ > 0x7FFF ) {
               break ;
           }/* if */
       }while( ( risc_flag & ASC_RISC_FLAG_GEN_INT ) != 0 ) ;
/*
** ACK interrupt
*/
       host_flag = AscReadLramByte( iop_base, ASCV_HOST_FLAG_B ) & (~ASC_HOST_FLAG_ACK_INT) ;
       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B,
                         ( uchar )( host_flag | ASC_HOST_FLAG_ACK_INT ) ) ;

       AscSetChipStatus( iop_base, CIW_INT_ACK ) ;
       loop = 0 ;
       while( AscGetChipStatus( iop_base ) & CSW_INT_PENDING )
       {
           /* AscDelay( 1000L ) ; */
           AscSetChipStatus( iop_base, CIW_INT_ACK ) ;
           if( loop++ > 3 )
           {
               break ;
           }/* if */
       }/* if */
#if 0
       /* restore CFG */
       AscSetChipCfgLsw( iop_base, cfg | ASC_CFG0_HOST_INT_ON ) ;
#endif
       /* restore host_flag */
       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B, host_flag ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscDisableInterrupt(
          PortAddr iop_base
       )
{
       ushort  cfg ;

       cfg = AscGetChipCfgLsw( iop_base ) ;
       AscSetChipCfgLsw( iop_base, cfg & (~ASC_CFG0_HOST_INT_ON) ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscEnableInterrupt(
          PortAddr iop_base
       )
{
       ushort  cfg ;

       cfg = AscGetChipCfgLsw( iop_base ) ;
       AscSetChipCfgLsw( iop_base, cfg | ASC_CFG0_HOST_INT_ON ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
ulong  AscGetChipCfgDword(
          PortAddr iop_base
       )
{
       ushort  cfg_msw, cfg_lsw ;

       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
       cfg_msw = AscGetChipCfgMsw( iop_base ) ;
       return( ( ( ulong )cfg_msw << 16  ) | cfg_lsw ) ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
void   AscSetChipCfgDword(
          PortAddr iop_base,
          ulong cfg_reg
       )
{
       AscSetChipCfgLsw( iop_base, ( ushort )cfg_reg ) ;
       AscSetChipCfgMsw( iop_base, ( ushort )( cfg_reg >> 16 ) ) ;
       return ;
}

/* --------------------------------------------------------------------
** set bank 0 or 1
**
** ----------------------------------------------------------------- */
void   AscSetBank(
          PortAddr iop_base,
          uchar bank
       )
{
       uchar  val ;

       val = AscGetChipControl( iop_base ) &
             ( ~( CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET | CC_CHIP_RESET ) ) ;
       if( bank == 1 )
       {
           val |= CC_BANK_ONE ;
       }/* if */
       else if( bank == 2 )
       {
           val |= CC_DIAG | CC_BANK_ONE ;
       }/* else */
       else
       {
           val &= ~CC_BANK_ONE ;
       }/* if */
       AscSetChipControl( iop_base, val ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** ----------------------------------------------------------------- */
uchar  AscGetBank(
          PortAddr iop_base
       )
{
       if( ( AscGetChipControl( iop_base ) & CC_BANK_ONE ) == 0 )
       {
           return( 0 ) ;
       }/* if */
       else
       {
           return( 1 ) ;
       }/* else */
}

/* --------------------------------------------------------------------
**
** Note:
**   1. this function will reset SCSI bus
**
** ----------------------------------------------------------------- */
void   AscResetScsiBus( ASC_DVC_VAR asc_ptr_type *asc_dvc )   
         
{
       uchar  val ;
       PortAddr  iop_base;

       iop_base = asc_dvc->iop_base;



       val = AscGetChipControl( iop_base ) & ( ~( CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ) ;
/*
** this is a temporary fix, to make sure the chip will halt
*/
       AscStopChip( iop_base ) ;
       AscSetChipControl( iop_base, ( uchar )( val | CC_SCSI_RESET | CC_HALT ) ) ;

       DvcDelayNanoSecond(asc_dvc, 60000);    /* 60 uSec.  Fix  Panasonic problem */
       val &= ~( CC_SCSI_RESET | CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ;

       AscSetChipControl( iop_base, val | CC_HALT ) ;
       DvcSleepMilliSecond( 300 ) ;
       AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return ;
}

/* ---------------------------------------------------------------------
**
** Note:
**   1. this function will reset chip and SCSI bus, then place the chip
**      in halt state
**
** return TRUE if chip is halted
** return FALSE if not halted
** ------------------------------------------------------------------ */
int    AscResetChipAndScsiBus( ASC_DVC_VAR asc_ptr_type *asc_dvc )     
      
{
       PortAddr  iop_base;

       iop_base = asc_dvc->iop_base;

       while( AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE ) ;
       AscStopChip( iop_base ) ;

       AscSetChipControl( iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT ) ;
       DvcDelayNanoSecond(asc_dvc,60000);    /* 60 uSec.  Fix  Panasonic problem */
/*
** this is a fix, to make sure the chip will halt
*/
       AscSetChipIH( iop_base, INS_RFLAG_WTM ) ;
       AscSetChipIH( iop_base, INS_HALT ) ;

       AscSetChipControl( iop_base, CC_CHIP_RESET | CC_HALT ) ;
       AscSetChipControl( iop_base, CC_HALT ) ;
       DvcSleepMilliSecond( 200 ) ;
       AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return( AscIsChipHalted( iop_base ) ) ;
}

/* ---------------------------------------------------------------------
**
** Note:
**   1. this function will reset chip, then place the chip
**      in halt state
** ------------------------------------------------------------------ */
int    AscResetChip(
          PortAddr iop_base
       )
{
       int i = 10;

       while ((AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE) &&
              (i-- > 0)) 
       {
             DvcSleepMilliSecond(100); // Wait up to 1 second.
       }

       AscSetChipStatus( iop_base, 0 ) ;
       AscStopChip( iop_base ) ;
       AscSetChipControl( iop_base, CC_CHIP_RESET | CC_HALT ) ;
/*
** this is a fix, to make sure the chip will halt
*/
       AscSetChipIH( iop_base, INS_RFLAG_WTM ) ;
       AscSetChipIH( iop_base, INS_HALT ) ;

       DvcSleepMilliSecond( 60 ) ;
       AscSetChipControl( iop_base, CC_HALT ) ;

       return( AscIsChipHalted( iop_base ) ) ;
}

/* --------------------------------------------------------------
** Get maximum permisable DMA transfer address
** ----------------------------------------------------------- */
ulong  AscGetMaxDmaAddress(
          ushort bus_type
       )
{
#if !CC_PCI_ADAPTER_ONLY
       if( bus_type & ASC_IS_VL ) return( ASC_MAX_VL_DMA_ADDR ) ;
       if( bus_type & ASC_IS_ISA ) return( ASC_MAX_ISA_DMA_ADDR ) ;
       if( bus_type & ASC_IS_EISA ) return( ASC_MAX_EISA_DMA_ADDR ) ;
#endif
       if( bus_type & ASC_IS_PCI ) return( ASC_MAX_PCI_DMA_ADDR ) ;
       return( 0L ) ;
}


/* ----------------------------------------------------------------------
** Description: return maximum number of dam counter ( dword )
**
** ------------------------------------------------------------------- */
ulong  AscGetMaxDmaCount(
          ushort bus_type
       )
{
#if !CC_PCI_ADAPTER_ONLY
       if( bus_type & ASC_IS_ISA ) return( ASC_MAX_ISA_DMA_COUNT ) ;
       else if( bus_type & ( ASC_IS_EISA | ASC_IS_VL ) ) return( ASC_MAX_VL_DMA_COUNT ) ;
#endif
       return( ASC_MAX_PCI_DMA_COUNT ) ;
}

#if !CC_PCI_ADAPTER_ONLY

/* --------------------------------------------------------------
** get ASC ISA DMA channel number 5-7
** 0x00 - DMA 7
** 0x01 - DMA 5
** 0x02 - DMA 6
** ----------------------------------------------------------- */
ushort AscGetIsaDmaChannel(
          PortAddr iop_base
       )
{
       ushort channel ;

       channel = AscGetChipCfgLsw( iop_base ) & 0x0003 ;
       if( channel == 0x03 ) return( 0 ) ;
       else if( channel == 0x00 ) return( 7 ) ;
       return( channel + 4 ) ;
}

/* --------------------------------------------------------------
** Set ISA DMA channel 5-7
** ----------------------------------------------------------- */
ushort AscSetIsaDmaChannel(
          PortAddr iop_base,
          ushort dma_channel
       )
{
       ushort cfg_lsw ;
       uchar  value ;

       if( ( dma_channel >= 5 ) && ( dma_channel <= 7 ) )
       {
           /* AscDisableIsaDma( AscGetIsaDmaChannel( iop_base ) ) ; */
           if( dma_channel == 7 ) value = 0x00 ;
           else value = dma_channel - 4 ;
           cfg_lsw = AscGetChipCfgLsw( iop_base ) & 0xFFFC ; /* clear old value */
           cfg_lsw |= value ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           return( AscGetIsaDmaChannel( iop_base ) ) ;
       }/* if */
       return( 0 ) ;
}

/* --------------------------------------------------------------
** Set ISA DMA speed
** ----------------------------------------------------------- */
uchar  AscSetIsaDmaSpeed(
          PortAddr iop_base,
          uchar speed_value
       )
{
       speed_value &= 0x07 ;
       AscSetBank( iop_base, 1 ) ;
       AscWriteChipDmaSpeed( iop_base, speed_value ) ;
       AscSetBank( iop_base, 0 ) ;
       return( AscGetIsaDmaSpeed( iop_base ) ) ;
}

/* --------------------------------------------------------------
** Get ISA DMA speed
** ----------------------------------------------------------- */
uchar  AscGetIsaDmaSpeed(
          PortAddr iop_base
       )
{
       uchar speed_value ;

       AscSetBank( iop_base, 1 ) ;
       speed_value = AscReadChipDmaSpeed( iop_base ) ;
       speed_value &= 0x07 ;
       AscSetBank( iop_base, 0 ) ;
       return( speed_value ) ;
}

#endif /* if !CC_PCI_ADAPTER_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_dvc.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_dvc.c
**
*/

#include "a_ver.h"
#include "ascinc.h"

#if CC_SET_PCI_CONFIG_SPACE
/*
 * Read a word from the PCI Configuration Space using the device
 * driver supplied byte read function.
 */
ushort
AscReadPCIConfigWord(
    ASC_DVC_VAR asc_ptr_type *asc_dvc,
    ushort pci_config_offset)
{
    uchar       lsb, msb;

    lsb = DvcReadPCIConfigByte(asc_dvc, pci_config_offset);
    msb = DvcReadPCIConfigByte(asc_dvc, (ushort) (pci_config_offset + 1));

    return ((ushort) ((msb << 8) | lsb));
}
#endif /* CC_SET_PCI_CONFIG_SPACE */


ushort AscInitGetConfig(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ushort   warn_code ;
       PortAddr iop_base ;
#if CC_SET_PCI_CONFIG_SPACE
       ushort   PCIDeviceID;
       ushort   PCIVendorID;
       uchar    PCIRevisionID;
       uchar    prevCmdRegBits;
#endif /* CC_SET_PCI_CONFIG_SPACE */
#if CC_DISABLE_PCI_BURST_MODE
       ushort   cfg_lsw ;
#endif
       warn_code= 0 ;
       iop_base = asc_dvc->iop_base ;
       asc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG ;
       if( asc_dvc->err_code != 0 )
       {
           return( UW_ERR ) ;
       }

#if CC_SET_PCI_CONFIG_SPACE
       if( asc_dvc->bus_type == ASC_IS_PCI )
       {
           PCIVendorID = AscReadPCIConfigWord(asc_dvc,
                                       AscPCIConfigVendorIDRegister);

           PCIDeviceID = AscReadPCIConfigWord(asc_dvc,
                                       AscPCIConfigDeviceIDRegister);

           PCIRevisionID = DvcReadPCIConfigByte(asc_dvc,
                                       AscPCIConfigRevisionIDRegister);

           if (PCIVendorID != ASC_PCI_VENDORID) {
               warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
           }

           /*
            * All PCI adapters must have the I/O Space (0),
            * Memory Space (1), and Bus Master (2) bits set
            * in the PCI Configuration Command Register.
            */
           prevCmdRegBits = DvcReadPCIConfigByte(asc_dvc,
                                       AscPCIConfigCommandRegister);

           /* If the Bus Mastering bits aren't already set, try to set them. */
           if ((prevCmdRegBits & AscPCICmdRegBits_IOMemBusMaster) !=
               AscPCICmdRegBits_IOMemBusMaster)
           {
               DvcWritePCIConfigByte( asc_dvc, AscPCIConfigCommandRegister,
                  (uchar) (prevCmdRegBits | AscPCICmdRegBits_IOMemBusMaster));

               if ((DvcReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
                    & AscPCICmdRegBits_IOMemBusMaster)
                   != AscPCICmdRegBits_IOMemBusMaster)
               {
                   warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
               }
           }

           /*
            * ASC-1200 FAST ICs must set the Latency Timer to zero.
            *
            * ASC ULTRA ICs must set the Latency Timer to at least 0x20.
            */
           if ((PCIDeviceID == ASC_PCI_DEVICEID_1200A) ||
               (PCIDeviceID == ASC_PCI_DEVICEID_1200B))
           {
               DvcWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer, 0x00);
               if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                   != 0x00 )
               {
                   warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
               }
           } else if (PCIDeviceID == ASC_PCI_DEVICEID_ULTRA)
           {
               if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                   < 0x20 )
               {
                   DvcWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer,
                       0x20);

                   if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer)
                       < 0x20 )
                   {
                       warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE ;
                   }
               }
           }
       }
#endif /* CC_SET_PCI_CONFIG_SPACE */

       if( AscFindSignature( iop_base ) )
       {
           warn_code |= AscInitAscDvcVar( asc_dvc ) ;

#if CC_INCLUDE_EEP_CONFIG
           if( asc_dvc->init_state & ASC_INIT_STATE_WITHOUT_EEP )
           {
               warn_code |= AscInitWithoutEEP( asc_dvc ) ;
           }
           else
           {
               warn_code |= AscInitFromEEP( asc_dvc ) ;
           }
#else
           warn_code |= AscInitWithoutEEP( asc_dvc ) ;

#endif /* #if CC_INCLUDE_EEP_CONFIG */

           asc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG ;

           /*csf072795 Insure scsi_reset_wait is a reasonable value */
           if( asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT )
           {
               asc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT ;
           }
       }/* if */
       else
       {
           asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE ;
       }/* else */

#if CC_DISABLE_PCI_BURST_MODE
       if( asc_dvc->bus_type & ASC_IS_PCI )
       {
           cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
           cfg_lsw &= ~ASC_PCI_CFG_LSW_BURST_MODE ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
       }
#endif
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
ushort AscInitSetConfig(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ushort  warn_code ;

       warn_code= 0 ;
       asc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG ;
       if( asc_dvc->err_code != 0 ) return( UW_ERR ) ;
       if( AscFindSignature( asc_dvc->iop_base ) )
       {
           warn_code |= AscInitFromAscDvcVar( asc_dvc ) ;
           asc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG ;
       }/* if */
       else
       {
           asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE ;
       }/* else */
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code and set error code if fatal error occured
** -------------------------------------------------------------------- */
ushort AscInitFromAscDvcVar(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       ushort   cfg_msw ;
       ushort   warn_code ;
       ushort   pci_device_id ;

       iop_base = asc_dvc->iop_base ;
       pci_device_id = asc_dvc->cfg->pci_device_id ;
       warn_code = 0 ;

       cfg_msw = AscGetChipCfgMsw( iop_base ) ;

       if( ( cfg_msw & ASC_CFG_MSW_CLR_MASK ) != 0 )
       {
           cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
           warn_code |= ASC_WARN_CFG_MSW_RECOVER ;
           AscSetChipCfgMsw( iop_base, cfg_msw ) ;
       }/* if */

       if( ( asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable ) !=
           asc_dvc->cfg->cmd_qng_enabled )
       {
           asc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled ;
           warn_code |= ASC_WARN_CMD_QNG_CONFLICT ;
       }/* if */

#if !CC_PCI_ADAPTER_ONLY

       if( AscGetChipStatus( iop_base ) & CSW_AUTO_CONFIG )
       {
           warn_code |= ASC_WARN_AUTO_CONFIG ;
/*
** when auto configuration is on, BIOS will be disabled
**
*/
       }/* if */

       if( ( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL ) ) != 0 )
       {
/*
** for VL, ISA only
*/
           if( AscSetChipIRQ( iop_base, asc_dvc->irq_no, asc_dvc->bus_type )
               != asc_dvc->irq_no )
           {
               asc_dvc->err_code |= ASC_IERR_SET_IRQ_NO ;
           }/* if */
       }/* if */
#endif /* #if !CC_PCI_ADAPTER_ONLY */

/*
**
*/
       if( asc_dvc->bus_type & ASC_IS_PCI )
       {
/*
**
** both PCI Fast and Ultra should enter here
*/
#if CC_DISABLE_PCI_PARITY_INT
               cfg_msw &= 0xFFC0 ;
               AscSetChipCfgMsw( iop_base, cfg_msw ) ;
#endif /* CC_DISABLE_PCI_PARITY_INT */

           if( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
           {

           }
           else
           {
               if( ( pci_device_id == ASC_PCI_DEVICE_ID_REV_A ) ||
                   ( pci_device_id == ASC_PCI_DEVICE_ID_REV_B ) )
               {
                   asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB ;
                   asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN ;

               }/* if */
           }
       }/* if */
       else if( asc_dvc->bus_type == ASC_IS_ISAPNP )
       {
#if !CC_PCI_ADAPTER_ONLY
/*
** fix ISAPNP (0x21) async xfer problem with sync offset one
*/
            if( AscGetChipVersion( iop_base, asc_dvc->bus_type )
                == ASC_CHIP_VER_ASYN_BUG )
            {
                asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN ;
                /* asc_dvc->pci_fix_asyn_xfer = ASC_ALL_DEVICE_BIT_SET ; */
            }/* if */
#endif
       }/* else */

       if( AscSetChipScsiID( iop_base, asc_dvc->cfg->chip_scsi_id ) !=
           asc_dvc->cfg->chip_scsi_id )
       {
           asc_dvc->err_code |= ASC_IERR_SET_SCSI_ID ;
       }/* if */

#if !CC_PCI_ADAPTER_ONLY
       if( asc_dvc->bus_type & ASC_IS_ISA )
       {
           AscSetIsaDmaChannel( iop_base, asc_dvc->cfg->isa_dma_channel ) ;
           AscSetIsaDmaSpeed( iop_base, asc_dvc->cfg->isa_dma_speed ) ;
       }/* if */
#endif /* #if !CC_PCI_ADAPTER_ONLY */

       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitAsc1000Driver(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ushort   warn_code ;
       PortAddr iop_base ;

extern ushort _mcode_size ;
extern ulong  _mcode_chksum ;
extern uchar  _mcode_buf[] ;

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
/*
**
** we must reset scsi bus, if only reset chip
** next DMA xfer will hang !!!
**
** however after AscResetChipAndScsiBus( ) before you do any data xfer
** you may reset chip as many times as you want
**
*/
       if( ( asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI ) &&
           !( asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE ) )
       {
/*
** if AscGetChipScsiCtrl() is not zero, chip is hanging in certain scsi phase
** in this case, we must reset scsi bus !
*/
           AscResetChipAndScsiBus( asc_dvc ) ;
           DvcSleepMilliSecond( ( ulong )( ( ushort )asc_dvc->scsi_reset_wait*1000 ) ) ;
       }/* if */

       asc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC ;
       if( asc_dvc->err_code != 0 ) return( UW_ERR ) ;
       if( !AscFindSignature( asc_dvc->iop_base ) )
       {
           asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE ;
           return( warn_code ) ;
       }/* if */

       AscDisableInterrupt( iop_base ) ;

#if CC_SCAM
       if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
       {
           AscSCAM( asc_dvc ) ;
       }/* if */
#endif
/*
**     always setup memory after reset !!!
*/
       warn_code |= AscInitLram( asc_dvc ) ;
       if( asc_dvc->err_code != 0 ) return( UW_ERR ) ;
       if( AscLoadMicroCode( iop_base, 0, ( ushort dosfar *)_mcode_buf,
                             _mcode_size ) != _mcode_chksum )
       {
           asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM ;
           return( warn_code ) ;
       }/* if */
       warn_code |= AscInitMicroCodeVar( asc_dvc ) ;
       asc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC ;
       AscEnableInterrupt( iop_base ) ;
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitAscDvcVar(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int      i ;
       PortAddr iop_base ;
       ushort   warn_code ;
       uchar    chip_version ;

/*       asc_dvc->dvc_type = OS_TYPE ; */
       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
       asc_dvc->err_code = 0 ;


       if(
           ( asc_dvc->bus_type &
           ( ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL ) ) == 0
         )
       {
           asc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE ;
       }/* if */
/*
**
** set chip halt ( idle )
** this also clear chip reset bit
**
*/
       AscSetChipControl( iop_base, CC_HALT ) ;
/*
**
** 6/28/96, since S87
** if chip status bit 12 is set, you cannot R/W EEP and Local RAM in VL/EISA chip
**
*/
       AscSetChipStatus( iop_base, 0 ) ;

#if CC_LINK_BUSY_Q
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->scsiq_busy_head[ i ] = ( ASC_SCSI_Q dosfar *)0L ;
            asc_dvc->scsiq_busy_tail[ i ] = ( ASC_SCSI_Q dosfar *)0L ;
       }/* for */
#endif /* CC_LINK_BUSY_Q */

#if CC_INIT_CLEAR_ASC_DVC_VAR
       asc_dvc->bug_fix_cntl = 0 ;
       asc_dvc->pci_fix_asyn_xfer = 0 ;
       asc_dvc->pci_fix_asyn_xfer_always = 0 ;
       asc_dvc->init_state = 0 ;
       asc_dvc->sdtr_done = 0 ;
       asc_dvc->cur_total_qng = 0 ;
       asc_dvc->is_in_int = 0 ;
       asc_dvc->in_critical_cnt = 0 ;
/*       asc_dvc->dvc_reset = 0 ; */
       asc_dvc->last_q_shortage = 0 ;
       asc_dvc->use_tagged_qng = 0 ;
       asc_dvc->no_scam = 0 ;
       asc_dvc->unit_not_ready = 0 ;
       asc_dvc->queue_full_or_busy = 0 ;
       /* asc_dvc->req_count = 0L ; */
       /* asc_dvc->int_count = 0L ; */
       /* asc_dvc->busy_count = 0L ; */
       asc_dvc->redo_scam = 0 ;
       asc_dvc->res2 = 0 ;
       /* asc_dvc->res3 = 0 ; */
       asc_dvc->host_init_sdtr_index = 0 ;
       /* asc_dvc->res6 = 0 ; */
       asc_dvc->res7 = 0 ;
       asc_dvc->res8 = 0 ;

       asc_dvc->cfg->can_tagged_qng = 0 ;
       asc_dvc->cfg->cmd_qng_enabled = 0;
#endif /* CC_INIT_CLEAR_ASC_DVC_VAR */

       asc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL ;
#if CC_INIT_SCSI_TARGET
       /*
        * Only if CC_INIT_SCSI_TARGET is set TRUE, then initialize
        * ASC_DVC_VAR 'init_sdtr' to all 1's.
        *
        * If CC_INIT_SCSI_TARGET is set FALSE, then the ASC_DVC_VAR
        * 'init_sdtr' bits are set in AscInquiryHandling().
        */
       asc_dvc->init_sdtr = ASC_SCSI_WIDTH_BIT_SET ;
#else /* CC_INIT_SCSI_TARGET */
       asc_dvc->init_sdtr = 0;
#endif /* CC_INIT_SCSI_TARGET */
       asc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG ;
       asc_dvc->scsi_reset_wait = 3 ; /* delay after scsi bus reset */
       /* asc_dvc->irq_no = 10 ; */
       asc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET ;
       asc_dvc->max_dma_count = AscGetMaxDmaCount( asc_dvc->bus_type ) ;

       asc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET ;
       asc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET ;
       asc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID ;
       asc_dvc->cfg->lib_serial_no = ASC_LIB_SERIAL_NUMBER ;
       asc_dvc->cfg->lib_version = ( ASC_LIB_VERSION_MAJOR << 8 ) |
                                     ASC_LIB_VERSION_MINOR ;

       chip_version = AscGetChipVersion( iop_base, asc_dvc->bus_type ) ;
       asc_dvc->cfg->chip_version = chip_version ;

       asc_dvc->sdtr_period_tbl[ 0 ] = SYN_XFER_NS_0 ;
       asc_dvc->sdtr_period_tbl[ 1 ] = SYN_XFER_NS_1 ;
       asc_dvc->sdtr_period_tbl[ 2 ] = SYN_XFER_NS_2 ;
       asc_dvc->sdtr_period_tbl[ 3 ] = SYN_XFER_NS_3 ;
       asc_dvc->sdtr_period_tbl[ 4 ] = SYN_XFER_NS_4 ;
       asc_dvc->sdtr_period_tbl[ 5 ] = SYN_XFER_NS_5 ;
       asc_dvc->sdtr_period_tbl[ 6 ] = SYN_XFER_NS_6 ;
       asc_dvc->sdtr_period_tbl[ 7 ] = SYN_XFER_NS_7 ;
       asc_dvc->max_sdtr_index = 7 ;

#if CC_PCI_ULTRA
       /*
        * PCI Ultra Initialization
        *
        * Because ASC_CHIP_VER_PCI_ULTRA_3050 is numerically greater
        * than ASC_CHIP_VER_PCI_ULTRA_3150, the following block will
        * be entered by ASC_CHIP_VER_PCI_ULTRA_3050.
        */
       if(
           ( asc_dvc->bus_type & ASC_IS_PCI )
           && ( chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150 )
         )
       {
           asc_dvc->bus_type = ASC_IS_PCI_ULTRA ;

           asc_dvc->sdtr_period_tbl[ 0 ] = SYN_ULTRA_XFER_NS_0 ;
           asc_dvc->sdtr_period_tbl[ 1 ] = SYN_ULTRA_XFER_NS_1 ;
           asc_dvc->sdtr_period_tbl[ 2 ] = SYN_ULTRA_XFER_NS_2 ;
           asc_dvc->sdtr_period_tbl[ 3 ] = SYN_ULTRA_XFER_NS_3 ;
           asc_dvc->sdtr_period_tbl[ 4 ] = SYN_ULTRA_XFER_NS_4 ;
           asc_dvc->sdtr_period_tbl[ 5 ] = SYN_ULTRA_XFER_NS_5 ;
           asc_dvc->sdtr_period_tbl[ 6 ] = SYN_ULTRA_XFER_NS_6 ;
           asc_dvc->sdtr_period_tbl[ 7 ] = SYN_ULTRA_XFER_NS_7 ;
           asc_dvc->sdtr_period_tbl[ 8 ] = SYN_ULTRA_XFER_NS_8 ;
           asc_dvc->sdtr_period_tbl[ 9 ] = SYN_ULTRA_XFER_NS_9 ;
           asc_dvc->sdtr_period_tbl[ 10 ] = SYN_ULTRA_XFER_NS_10 ;
           asc_dvc->sdtr_period_tbl[ 11 ] = SYN_ULTRA_XFER_NS_11 ;
           asc_dvc->sdtr_period_tbl[ 12 ] = SYN_ULTRA_XFER_NS_12 ;
           asc_dvc->sdtr_period_tbl[ 13 ] = SYN_ULTRA_XFER_NS_13 ;
           asc_dvc->sdtr_period_tbl[ 14 ] = SYN_ULTRA_XFER_NS_14 ;
           asc_dvc->sdtr_period_tbl[ 15 ] = SYN_ULTRA_XFER_NS_15 ;
           asc_dvc->max_sdtr_index = 15 ;

           if (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150)
           {
               AscSetExtraControl(iop_base,
                   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
           } else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050)
           {
               AscSetExtraControl(iop_base,
                   (SEC_ACTIVE_NEGATE | SEC_ENABLE_FILTER));
           }
       }/* if PCI ULTRA */
#endif /* #if CC_PCI_ULTRA */

       /*
        * Set the Extra Control Register for PCI FAST.  'bus_type' is
        * set to ASC_IS_PCI_ULTRA above for PCI ULTRA.
        */
       if (asc_dvc->bus_type == ASC_IS_PCI)
       {
           /* Only for PCI FAST */
           AscSetExtraControl(iop_base, (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));
       }

       asc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED ;
       if( AscGetChipBusType( iop_base ) == ASC_IS_ISAPNP )
       {
/*
** turn on active neagtion for better wave form
*/
           AscSetChipIFC( iop_base, IFC_INIT_DEFAULT ) ;
           asc_dvc->bus_type = ASC_IS_ISAPNP ;
       }

#if !CC_PCI_ADAPTER_ONLY
       if( ( asc_dvc->bus_type & ASC_IS_ISA ) != 0 )
       {
           asc_dvc->cfg->isa_dma_channel = ( uchar )AscGetIsaDmaChannel( iop_base ) ;
       }/* if */
#endif /* #if !CC_PCI_ADAPTER_ONLY */

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->cur_dvc_qng[ i ] = 0 ;
            asc_dvc->max_dvc_qng[ i ] = ASC_MAX_SCSI1_QNG ;
            asc_dvc->scsiq_busy_head[ i ] = ( ASC_SCSI_Q dosfar * )0L ;
            asc_dvc->scsiq_busy_tail[ i ] = ( ASC_SCSI_Q dosfar * )0L ;
            asc_dvc->cfg->max_tag_qng[ i ] = ASC_MAX_INRAM_TAG_QNG ;
       }/* for */
       return( warn_code ) ;
}

#if CC_INCLUDE_EEP_CONFIG

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitFromEEP(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ASCEEP_CONFIG eep_config_buf ;
       ASCEEP_CONFIG dosfar *eep_config ;
       PortAddr iop_base ;
       ushort   chksum ;
       ushort   warn_code ;
       ushort   cfg_msw, cfg_lsw ;
       int      i ;
       int      write_eep = 0;
/*     uchar    iop_byte ;  */
/*     uchar    irq_no ;    */

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
/*
** write to ucode var "halt_code"
** for old( BIOS ) micro code, chip is not idle but looping forever
** we may be able to stop it in this loop
*/
       AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0x00FE ) ;
/*
** request microcode to stop chip itself
*/
       AscStopQueueExe( iop_base ) ;
       if( ( AscStopChip( iop_base ) == FALSE ) ||
           ( AscGetChipScsiCtrl( iop_base ) != 0 ) )
       {
           asc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE ;
           AscResetChipAndScsiBus( asc_dvc ) ;
           DvcSleepMilliSecond( ( ulong )( ( ushort )asc_dvc->scsi_reset_wait*1000 ) ) ;
       }/* if */
       if( AscIsChipHalted( iop_base ) == FALSE )
       {
           asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP ;
           return( warn_code ) ;
       }/* if */

/*
** we set PC to 0x80 to prevent EEPROM read error
** ( hardware will generate one extra clock to cause data to shife one bit )
*/
       AscSetPCAddr( iop_base, ASC_MCODE_START_ADDR ) ;
       if( AscGetPCAddr( iop_base ) != ASC_MCODE_START_ADDR )
       {
           asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR ;
           return( warn_code ) ;
       }/* if */

       eep_config = ( ASCEEP_CONFIG dosfar *)&eep_config_buf ;
/*
** first thing before access anything !!!
** we must disable the target mode and local ram 8 bits
*/
       cfg_msw = AscGetChipCfgMsw( iop_base ) ;
       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;

       if( ( cfg_msw & ASC_CFG_MSW_CLR_MASK ) != 0 )
       {
           cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
           warn_code |= ASC_WARN_CFG_MSW_RECOVER ;
           AscSetChipCfgMsw( iop_base, cfg_msw ) ;
       }/* if */
       chksum = AscGetEEPConfig( iop_base, eep_config, asc_dvc->bus_type ) ;
       if (chksum == 0) chksum = 0xaa55 ;     /* ensure not blank */

       if( AscGetChipStatus( iop_base ) & CSW_AUTO_CONFIG )
       {
           warn_code |= ASC_WARN_AUTO_CONFIG ;
/*
** when auto configuration is on, BIOS will be disabled
**
*/
           if( asc_dvc->cfg->chip_version == 3 )
           {
/*
** VERSION 3 ONLY, EEPROM BUG
*/
               if( eep_config->cfg_lsw != cfg_lsw )
               {
                   warn_code |= ASC_WARN_EEPROM_RECOVER ;
                   eep_config->cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
               }/* if */
               if( eep_config->cfg_msw != cfg_msw )
               {
                   warn_code |= ASC_WARN_EEPROM_RECOVER ;
                   eep_config->cfg_msw = AscGetChipCfgMsw( iop_base ) ;
               }/* if */
           }/* if */
       }/* if */
/*
** always enable EEPROM host interrupt
*/
       eep_config->cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
       eep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON ;


       /*
        * Check the calculated EEPROM checksum against the checksum
        * stored in the EEPROM.
        */
       if( chksum != eep_config->chksum )
       {
           /*
            * Ignore checksum errors for cards with the ASC-3050
            * chip revision. This will include the ASC-3030 which
            * does not have EEPROM.
            *
            * For all other cards that have a bad checksu, set
            * 'write_eep' so that the EEPROM will be written
            * back out to try to correct the error.
            */
           if (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==
                   ASC_CHIP_VER_PCI_ULTRA_3050 )
           {
               eep_config->init_sdtr = 0xFF;     /* Allow SDTR. */
               eep_config->disc_enable = 0xFF;   /* Allow Disconnect. */
               eep_config->start_motor = 0xFF;   /* Allow start motor. */
               eep_config->use_cmd_qng = 0;      /* No tag queuing. */
               eep_config->max_total_qng = 0xF0; /* 250 */
               eep_config->max_tag_qng = 0x20;   /* 32 */
               eep_config->cntl = 0xBFFF;
               eep_config->chip_scsi_id = 7;
               eep_config->no_scam = 0;          /* No SCAM. */
           }
           else
           {
               write_eep = 1 ;
               warn_code |= ASC_WARN_EEPROM_CHKSUM ;
           }
       }/* if */
#if CC_INIT_SCSI_TARGET
       /*
        * Only if CC_INIT_SCSI_TARGET is set TRUE, then initialize
        * ASC_DVC_VAR 'init_sdtr' to the EEPROM 'init_sdtr' value.
        *
        * If CC_INIT_SCSI_TARGET is set FALSE, then the ASC_DVC_VAR
        * 'init_sdtr' bits are set in AscInquiryHandling().
        */
       asc_dvc->init_sdtr = eep_config->init_sdtr ;
#endif /* CC_INIT_SCSI_TARGET */
       asc_dvc->cfg->sdtr_enable = eep_config->init_sdtr ;
       asc_dvc->cfg->disc_enable = eep_config->disc_enable ;

       /* Set the target id that should enable command queuing. */
       asc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng ;
       asc_dvc->cfg->isa_dma_speed = eep_config->isa_dma_speed ;
       asc_dvc->start_motor = eep_config->start_motor ;
       asc_dvc->dvc_cntl = eep_config->cntl ;
       asc_dvc->no_scam = eep_config->no_scam ;

       if( !AscTestExternalLram( asc_dvc ) )
       {
           if(
               ( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
             )
           {
               eep_config->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG ;
               eep_config->max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG ;
           }/* if */
           else
           {
               eep_config->cfg_msw |= 0x0800 ;
               cfg_msw |= 0x0800 ;  /* set ucode size to 2.5 KB */
               AscSetChipCfgMsw( iop_base, cfg_msw ) ;
/*
**
** we ignore EEP setting in PCI
**
*/
               eep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG ;
               eep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG ;
           }/* if */
       }/* if there is no external RAM */
       else
       {
#if CC_TEST_RW_LRAM
           asc_dvc->err_code |= AscTestLramEndian( iop_base ) ;
#endif
       }
       if( eep_config->max_total_qng < ASC_MIN_TOTAL_QNG )
       {
           eep_config->max_total_qng = ASC_MIN_TOTAL_QNG ;
       }/* if */
       if( eep_config->max_total_qng > ASC_MAX_TOTAL_QNG )
       {
           eep_config->max_total_qng = ASC_MAX_TOTAL_QNG ;
       }/* if */
       if( eep_config->max_tag_qng > eep_config->max_total_qng )
       {
           eep_config->max_tag_qng = eep_config->max_total_qng ;
       }/* if */
       if( eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC )
       {
           eep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC ;
       }/* if */

       asc_dvc->max_total_qng = eep_config->max_total_qng ;

       if( ( eep_config->use_cmd_qng & eep_config->disc_enable ) !=
           eep_config->use_cmd_qng )
       {
           eep_config->disc_enable = eep_config->use_cmd_qng ;
           warn_code |= ASC_WARN_CMD_QNG_CONFLICT ;
       }/* if */
/*
** we will now get irq number from CFG register instead of from EEPROM
*/
#if !CC_PCI_ADAPTER_ONLY
       if( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL) )
       {
           asc_dvc->irq_no = AscGetChipIRQ( iop_base, asc_dvc->bus_type ) ;
       }
#endif /* not PCI ONLY */

       eep_config->chip_scsi_id &= ASC_MAX_TID ;
       asc_dvc->cfg->chip_scsi_id = eep_config->chip_scsi_id ;

/*
**
** check do we need disable ultra sdtr ( from both host/target inited sdtr )
**
**
*/
       if(
           ( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
           && !( asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA )
         )
       {
/*
**
** some combination of cable/terminator ( for example with Iomega ZIP drive )
** we cannot work with ultra( fast-20 ) and fast-10 scsi device together
** the EEPROM device control bit 14 is used to turn off host inited ultra sdtr
**
** ultra PCI, but host inited SDTR use 10MB/sec speed, that is index two instead of zero
**
** - be very careful that asc_dvc->bus_type is already equals ASC_IS_PCI_ULTRA
**   which is verified and modified in function AscInitAscDvcVar()
**
*/
           asc_dvc->host_init_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX ;
       }
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
#if CC_TMP_USE_EEP_SDTR
            asc_dvc->cfg->sdtr_period_offset[ i ] = eep_config->dos_int13_table[ i ] ;
#endif
            asc_dvc->dos_int13_table[ i ] = eep_config->dos_int13_table[ i ] ;
            asc_dvc->cfg->max_tag_qng[ i ] = eep_config->max_tag_qng ;
            asc_dvc->cfg->sdtr_period_offset[ i ] = ( uchar )( ASC_DEF_SDTR_OFFSET
                                                    | ( asc_dvc->host_init_sdtr_index << 4 ) ) ;
       }/* for */
/*
** wait motor spin up
**
**     asc_dvc->sleep_msec( ( ulong )( eep_config->spin_up_wait * 50 ) ) ;
**     asc_dvc->sleep_msec( 1000L ) ;
*/

/*
**
** this will write IRQ number back to EEPROM word 0
*/
       eep_config->cfg_msw = AscGetChipCfgMsw( iop_base ) ;

       /*
        * For boards with a bad EEPROM checksum, other than ASC-3050/3030
        * which might not have an EEPROM, try to re-write the EEPROM.
        *
        */
       if (write_eep)
       {
            /*
             * Ingore EEPROM write errors. A bad EEPROM will not prevent
             * the board from initializing.
             */
           (void) AscSetEEPConfig( iop_base, eep_config, asc_dvc->bus_type ) ;
       }
       return( warn_code ) ;
}

#endif /* CC_INCLUDE_EEP_CONFIG */

/* -----------------------------------------------------------------------
**
**
** PowerMac don't use EEP
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitWithoutEEP(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       ushort   warn_code ;
       ushort   cfg_msw ;
       int      i ;
       int      max_tag_qng = ASC_MAX_INRAM_TAG_QNG ;

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;

       cfg_msw = AscGetChipCfgMsw( iop_base ) ;

       if( ( cfg_msw & ASC_CFG_MSW_CLR_MASK ) != 0 )
       {
           cfg_msw &= ( ~( ASC_CFG_MSW_CLR_MASK ) ) ;
           warn_code |= ASC_WARN_CFG_MSW_RECOVER ;
           AscSetChipCfgMsw( iop_base, cfg_msw ) ;
       }/* if */

       if( !AscTestExternalLram( asc_dvc ) )
       {
           if(
               ( ( asc_dvc->bus_type & ASC_IS_PCI_ULTRA ) == ASC_IS_PCI_ULTRA )
             )
           {
               asc_dvc->max_total_qng = ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG ;
               max_tag_qng = ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG ;
           }/* if */
           else
           {
               cfg_msw |= 0x0800 ;  /* set ucode size to 2.5 KB */
               AscSetChipCfgMsw( iop_base, cfg_msw ) ;
               asc_dvc->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG ;
               max_tag_qng = ASC_MAX_INRAM_TAG_QNG ;
           }/* if */
       }/* if there is no external RAM */
       else
       {
#if CC_TEST_RW_LRAM
           asc_dvc->err_code |= AscTestLramEndian( iop_base ) ;
#endif
       }

#if !CC_PCI_ADAPTER_ONLY

       if( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL ) )
       {
           asc_dvc->irq_no = AscGetChipIRQ( iop_base, asc_dvc->bus_type ) ;
       }
#endif
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->dos_int13_table[ i ] = 0 ;
            asc_dvc->cfg->sdtr_period_offset[ i ] = ( uchar )( ASC_DEF_SDTR_OFFSET
                                                    | ( asc_dvc->host_init_sdtr_index << 4 ) ) ;
            asc_dvc->cfg->max_tag_qng[ i ] = ( uchar )max_tag_qng ;
       }/* for */
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** this routine
** 1. set up micro code initialize micro code variable
** 2. run micro code at pc = 0x80
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitMicroCodeVar(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int      i ;
       ushort   warn_code ;
       PortAddr iop_base ;
       ulong    phy_addr ;
/*
** set microcode variables
*/
       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            AscPutMCodeInitSDTRAtID( iop_base, i,
                                     asc_dvc->cfg->sdtr_period_offset[ i ]
                                   ) ;
       }/* for */

       AscInitQLinkVar( asc_dvc ) ;

       AscWriteLramByte( iop_base, ASCV_DISC_ENABLE_B,
                         asc_dvc->cfg->disc_enable ) ;
       AscWriteLramByte( iop_base, ASCV_HOSTSCSI_ID_B,
                         ASC_TID_TO_TARGET_ID( asc_dvc->cfg->chip_scsi_id ) ) ;
       if( ( phy_addr = AscGetOnePhyAddr( asc_dvc,
            ( uchar dosfar *)asc_dvc->cfg->overrun_buf,
            ASC_OVERRUN_BSIZE ) ) == 0L )
       {
            asc_dvc->err_code |= ASC_IERR_GET_PHY_ADDR ;
       }/* if */
       else
       {
/*
** adjust address to double word boundary
** that is why we need 0x48 byte to create 0x40 size buffer
*/
            phy_addr = ( phy_addr & 0xFFFFFFF8UL ) + 8 ;
            AscWriteLramDWord( iop_base, ASCV_OVERRUN_PADDR_D, phy_addr );
            AscWriteLramDWord( iop_base, ASCV_OVERRUN_BSIZE_D,
                               ASC_OVERRUN_BSIZE-8 );
       }/* else */
/*
**     AscWriteLramByte( iop_base, ASCV_MCODE_CNTL_B,
**                       ( uchar )asc_dvc->cfg->mcode_cntl ) ;
*/

       asc_dvc->cfg->mcode_date = AscReadLramWord( iop_base,
                                              ( ushort )ASCV_MC_DATE_W ) ;
       asc_dvc->cfg->mcode_version = AscReadLramWord( iop_base,
                                                 ( ushort )ASCV_MC_VER_W ) ;
       AscSetPCAddr( iop_base, ASC_MCODE_START_ADDR ) ;
       if( AscGetPCAddr( iop_base ) != ASC_MCODE_START_ADDR )
       {
           asc_dvc->err_code |= ASC_IERR_SET_PC_ADDR ;
           return( warn_code ) ;
       }/* if */
       if( AscStartChip( iop_base ) != 1 )
       {
           asc_dvc->err_code |= ASC_IERR_START_STOP_CHIP ;
           return( warn_code ) ;
       }/* if */
       return( warn_code ) ;
}

/* ---------------------------------------------------------------------
** ISR call back function for initialization
**
** ------------------------------------------------------------------ */
void dosfar AscInitPollIsrCallBack(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_QDONE_INFO dosfar *scsi_done_q
       )
{
       ASC_SCSI_REQ_Q dosfar *scsiq_req ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       uchar  cp_sen_len ;
       uchar  i ;

       if( ( scsi_done_q->d2.flag & ASC_FLAG_SCSIQ_REQ ) != 0 )
       {
           scsiq_req = ( ASC_SCSI_REQ_Q dosfar *)scsi_done_q->d2.srb_ptr ;
           scsiq_req->r3.done_stat = scsi_done_q->d3.done_stat ;
           scsiq_req->r3.host_stat = scsi_done_q->d3.host_stat ;
           scsiq_req->r3.scsi_stat = scsi_done_q->d3.scsi_stat ;
           scsiq_req->r3.scsi_msg = scsi_done_q->d3.scsi_msg ;
           if( ( scsi_done_q->d3.scsi_stat == SS_CHK_CONDITION ) &&
               ( scsi_done_q->d3.host_stat == 0 ) )
           {
               cp_sen_len = ( uchar )ASC_MIN_SENSE_LEN ;
               if( scsiq_req->r1.sense_len < ASC_MIN_SENSE_LEN )
               {
                   cp_sen_len = ( uchar )scsiq_req->r1.sense_len ;
               }/* if */
               for( i = 0 ; i < cp_sen_len ; i++ )
               {
                    scsiq_req->sense[ i ] = scsiq_req->sense_ptr[ i ] ;
               }/* for */
           }/* if */
#if 0
           if( AscISR_CheckQDone( asc_dvc, scsi_done_q, scsiq_req->sense_ptr ) == 1 )
           {

           }/* if */
#endif
       }/* if */
       else
       {
           if( asc_dvc->isr_callback != 0 )
           {
               asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
               ( * asc_isr_callback )( asc_dvc, scsi_done_q ) ;
           }/* if */
       }/* else */
       return ;
}

/* ----------------------------------------------------------------------
**
** return 1 if there is external RAM
** return 0 if there is no external RAM
** ------------------------------------------------------------------- */
int    AscTestExternalLram(
          ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       ushort   q_addr ;
       ushort   saved_word ;
       int      sta ;

       iop_base = asc_dvc->iop_base ;
       sta = 0 ;
/*
** if ucode size 2.0 KB, maximum queue = 30
** if ucode size 2.5 KB, maximum queue = 24
*/
       q_addr = ASC_QNO_TO_QADDR( 241 ) ; /* queue 241 doesn't exist if no external RAM */
       saved_word = AscReadLramWord( iop_base, q_addr ) ;

       AscSetChipLramAddr( iop_base, q_addr ) ;
       AscSetChipLramData( iop_base, 0x55AA ) ;

       DvcSleepMilliSecond(10);

       AscSetChipLramAddr( iop_base, q_addr ) ;
       if( AscGetChipLramData( iop_base ) == 0x55AA )
       {
           sta = 1 ; /* yes, has external RAM */
           AscWriteLramWord( iop_base, q_addr, saved_word ) ;
       }/* if */
       return( sta ) ;
}

#if CC_TEST_LRAM_ENDIAN

/* ----------------------------------------------------------------------
**
** Requirements:
** adapter must have external local RAM
** ( local RAM address 0 to 0x7fff must exist )
**
** return 0 if no error
** ------------------------------------------------------------------- */
ushort AscTestLramEndian(
          PortAddr iop_base
       )
{

#define TEST_LRAM_DWORD_ADDR  0x7FF0
#define TEST_LRAM_DWORD_VAL   0x12345678UL
#define TEST_LRAM_WORD_ADDR   0x7FFE
#define TEST_LRAM_WORD_VAL    0xAA55

       ulong   dword_val ;
       ushort  word_val ;
       uchar   byte_val ;

/*
**
*/
       AscWriteLramDWord( iop_base,
          TEST_LRAM_DWORD_ADDR,
          TEST_LRAM_DWORD_VAL ) ;

       dword_val = AscReadLramDWord( iop_base,
          TEST_LRAM_DWORD_ADDR ) ;
       if( dword_val != TEST_LRAM_DWORD_VAL )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
/*
**
*/
       AscWriteLramWord( iop_base,
          TEST_LRAM_WORD_ADDR,
          TEST_LRAM_WORD_VAL ) ;
       word_val = AscReadLramWord( iop_base, TEST_LRAM_WORD_ADDR ) ;
       if( word_val != TEST_LRAM_WORD_VAL )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
/*
**
*/
       byte_val = AscReadLramByte( iop_base, TEST_LRAM_WORD_ADDR ) ;
       if( byte_val != ( uchar )( TEST_LRAM_WORD_VAL & 0xFF ) )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
       byte_val = AscReadLramByte( iop_base, TEST_LRAM_WORD_ADDR+1 ) ;
       if( byte_val != ( TEST_LRAM_WORD_VAL >> 8 ) )
       {
           return( ASC_IERR_RW_LRAM ) ;
       }
       return( 0 ) ;
}

#endif /* CC_TEST_LRAM_ENDIAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_lram.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_lram.c
*/

#include "ascinc.h"


/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar  AscReadLramByte(
          PortAddr iop_base,
          ushort addr
       )
{
       uchar   byte_data ;
       ushort  word_data ;

       if( isodd_word( addr ) )
       {
           AscSetChipLramAddr( iop_base, addr-1 ) ;
           word_data = AscGetChipLramData( iop_base ) ;
           byte_data = ( uchar )( ( word_data >> 8 ) & 0xFF ) ;
       }/* if */
       else
       {
           AscSetChipLramAddr( iop_base, addr ) ;
           word_data = AscGetChipLramData( iop_base ) ;
           byte_data = ( uchar )( word_data & 0xFF ) ;
       }/* else */
       return( byte_data ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
ushort AscReadLramWord(
          PortAddr iop_base,
          ushort addr
       )
{
       ushort  word_data ;

       AscSetChipLramAddr( iop_base, addr ) ;
       word_data = AscGetChipLramData( iop_base ) ;
       return( word_data ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
ulong  AscReadLramDWord(
          PortAddr iop_base,
          ushort addr
       )
{
       ushort   val_low, val_high ;
       ulong    dword_data ;

       AscSetChipLramAddr( iop_base, addr ) ;

       val_low = AscGetChipLramData( iop_base ) ;
/*       outpw( IOP0W_RAM_ADDR, addr+2 ) ;  */
       val_high = AscGetChipLramData( iop_base ) ;

       dword_data = ( ( ulong )val_high << 16 ) | ( ulong )val_low ;
       return( dword_data ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWriteLramWord(
          PortAddr iop_base,
          ushort addr,
          ushort word_val
       )
{
       AscSetChipLramAddr( iop_base, addr ) ;
       AscSetChipLramData( iop_base, word_val ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWriteLramDWord(
          PortAddr iop_base,
          ushort addr,
          ulong dword_val
       )
{
       ushort  word_val ;

       AscSetChipLramAddr( iop_base, addr ) ;

       word_val = ( ushort )dword_val ;
       AscSetChipLramData( iop_base, word_val ) ;
       word_val = ( ushort )( dword_val >> 16 ) ;
       AscSetChipLramData( iop_base, word_val ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscWriteLramByte(
          PortAddr iop_base,
          ushort addr,
          uchar byte_val
       )
{
       ushort  word_data ;

       if( isodd_word( addr ) )
       {
           addr-- ;
           word_data = AscReadLramWord( iop_base, addr ) ;
           word_data &= 0x00FF ;
           word_data |= ( ( ( ushort )byte_val << 8 ) & 0xFF00 ) ;
       }/* if */
       else
       {
           word_data = AscReadLramWord( iop_base, addr ) ;
           word_data &= 0xFF00 ;
           word_data |= ( ( ushort )byte_val & 0x00FF ) ;
       }/* else */
       AscWriteLramWord( iop_base, addr, word_data ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemWordCopyToLram(
          PortAddr iop_base,
          ushort s_addr,
          ushort dosfar *s_buffer,
          int    words
       )
{
       AscSetChipLramAddr( iop_base, s_addr ) ;
       DvcOutPortWords( (PortAddr) (iop_base+IOP_RAM_DATA), s_buffer, words ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemDWordCopyToLram(
          PortAddr iop_base,
          ushort s_addr,
          ulong  dosfar *s_buffer,
          int    dwords
       )
{
       AscSetChipLramAddr( iop_base, s_addr ) ;
       DvcOutPortDWords( (PortAddr) (iop_base+IOP_RAM_DATA), s_buffer, dwords );
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemWordCopyFromLram(
          PortAddr iop_base,
          ushort   s_addr,
          ushort   dosfar *d_buffer,
          int      words
       )
{
       AscSetChipLramAddr( iop_base, s_addr ) ;
       DvcInPortWords( (PortAddr) (iop_base+IOP_RAM_DATA), d_buffer, words ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
ulong  AscMemSumLramWord(
          PortAddr iop_base,
          ushort   s_addr,
          rint     words
       )
{
       ulong   sum ;
       int     i ;

       sum = 0L ;
       for( i = 0 ; i < words ; i++, s_addr += 2 )
       {
            sum += AscReadLramWord( iop_base, s_addr ) ;
       }/* for */
       return( sum ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscMemWordSetLram(
          PortAddr iop_base,
          ushort   s_addr,
          ushort   set_wval,
          rint     words
       )
{
       rint  i ;

       AscSetChipLramAddr( iop_base, s_addr ) ;
       for( i = 0 ; i < words ; i++ )
       {
            AscSetChipLramData( iop_base, set_wval ) ;
       }/* for */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    AscMemWordCmpToLram(
          PortAddr iop_base,
          ushort   s_addr,
          ushort   dosfar *buffer,
          rint     words
       )
{
       rint     i ;
       ushort  word_val ;
       int     mismatch ;

       AscSetChipLramAddr( iop_base, s_addr ) ;
       mismatch = 0 ;
       for( i = 0 ; i < words ; i++ )
       {
            word_val = AscGetChipLramData( iop_base ) ;
            if( word_val != *buffer++ )
            {
                mismatch++ ;
            }/* if */
       }/* for */
       return( mismatch ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_inq.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_inq.c
**
*/

#include "ascinc.h"
#include "ascsidef.h"

#if CC_INIT_SCSI_TARGET
/* ---------------------------------------------------------------------
** Init SCSI devices
**
** NOTE:
**  1. if you don't want the capacity information, let cap_array parameter
**     equals zero
**  2. the work_sp_buf needs at least ASC_LIB_SCSIQ_WK_SP bytes of buffer
**
**     the work space must be a memory buffer that can be translated
**     by following virtural to physical address translation functions:
**     ( which are provided by each driver code )
**
**        ulong  DvcGetPhyAddr( uchar dosfar *buf_addr, ulong buf_len ) ;
**        ulong  DvcGetSGList( ASC_DVC_VAR asc_ptr_type *, uchar dosfar *,
**                             ulong, ASC_SG_HEAD dosfar * ) ;
**
**  3. if you want to write your own AscInitScsiTarget() function
**
**     a. you must first call AscInitPollBegin() to begin
**     b. then you may call AscInitPollTarget() as many time as you want
**     c. afterward use AscInitPollEnd() to end.
**
**     Warning: after using AscInitPollBegin() you must call AscInitPollEnd()
**              to end the polling process ! do not return from the function
**              without calling AscInitPollEnd()
**
** ------------------------------------------------------------------ */
int    AscInitScsiTarget(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_DVC_INQ_INFO dosfar *target,
          ruchar dosfar *work_sp_buf,
          REG ASC_CAP_INFO_ARRAY dosfar *cap_array,
          ushort cntl_flag
       )
{
       int     dvc_found ;
       int     sta ;
       ruchar   tid, lun ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       ASC_SCSI_INQUIRY dosfar *inq ;
       /* ASC_MIN_SG_HEAD sg_head ; */
       ASC_CAP_INFO dosfar *cap_info ;
       uchar   max_lun_scan ;

       AscInitPollBegin( asc_dvc ) ;
       scsiq = ( ASC_SCSI_REQ_Q dosfar *)work_sp_buf ;
       inq = ( ASC_SCSI_INQUIRY dosfar *)( work_sp_buf + sizeof( ASC_SCSI_REQ_Q ) + 4 ) ;

#if CC_USE_DvcSetMemory
       DvcSetMemory( ( uchar dosfar *)target->type, sizeof( ASC_DVC_INQ_INFO ), SCSI_TYPE_NO_DVC ) ;
#else
       for( tid = 0 ; tid <= ASC_MAX_TID ; tid++ )
       {
            for( lun = 0 ; lun <= ASC_MAX_LUN ; lun++ )
            {
                 target->type[ lun ][ tid ] = SCSI_TYPE_NO_DVC ;
            }/* for */
       }/* for */
#endif
       dvc_found = 0 ;
       tid = 0 ;
       if( cntl_flag & 0x01 ) max_lun_scan = ASC_MAX_LUN ;
       else max_lun_scan = 0 ;
       for( ; tid <= ASC_MAX_TID ; tid++ )
       {
           for( lun = 0 ; lun <= max_lun_scan ; lun++ )
           {
                scsiq->r1.target_id = ASC_TID_TO_TARGET_ID( tid ) ;
                scsiq->r1.target_lun = lun ;
                scsiq->r2.target_ix = ASC_TIDLUN_TO_IX( tid, lun ) ;

                if( tid != asc_dvc->cfg->chip_scsi_id )
                {
                    if( cap_array != 0L )
                    {
                        cap_info = &cap_array->cap_info[ tid ][ lun ] ;
                    }/* if */
                    else
                    {
                        cap_info = ( ASC_CAP_INFO dosfar *)0L ;
                    }/* else */
                    sta = AscInitPollTarget( asc_dvc, scsiq, inq, cap_info ) ;
                    if( sta == 1 )
                    {
                       /*
                        * If the Peripheral Device Type is SCSI_TYPE_UNKNOWN
                        * (0x1F) and the Peripheral Qualifier is 0x3, then
                        * the LUN does not exist.
                        */
                        if( inq->byte0.peri_dvc_type == SCSI_TYPE_UNKNOWN &&
                            inq->byte0.peri_qualifier == 0x3
                           )
                        {
                            /* Non-existent LUN device - stop LUN scanning. */
                            break;
                        }
                        dvc_found++ ;
                        target->type[ tid ][ lun ] = inq->byte0.peri_dvc_type ;
                    }/* if */
                    else
                    {
                        /* AscInitPollTarget() returned an error. */
                        if( sta == ERR ) break ;
                        if( lun == 0 ) break ;
                    }/* else */
                }/* if */
           }/* for */
       }/* for */
       AscInitPollEnd( asc_dvc ) ;
       return( dvc_found ) ;
}

/* -----------------------------------------------------------------------
**
** ---------------------------------------------------------------------*/
int    AscInitPollBegin(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr  iop_base ;

       iop_base = asc_dvc->iop_base ;

#if CC_INIT_INQ_DISPLAY
       DvcDisplayString( ( uchar dosfar *)"\r\n" ) ;
#endif /* CC_INIT_INQ_DISPLAY */

/*
**  reset chip to prevent chip generate an interrupt
**  when interrupt disabled
**
**  this could be a watch dog timer timeout
*/
       AscDisableInterrupt( iop_base ) ;

       asc_dvc->init_state |= ASC_INIT_STATE_BEG_INQUIRY ;
/*
** it was found disable interrupt generate an interrupt !?
** we need to have everything setup
*/
       AscWriteLramByte( iop_base, ASCV_DISC_ENABLE_B, 0x00 ) ;
       asc_dvc->use_tagged_qng = 0 ;
       asc_dvc->cfg->can_tagged_qng = 0 ;
       asc_dvc->saved_ptr2func = ( ulong )asc_dvc->isr_callback ;
       asc_dvc->isr_callback = ASC_GET_PTR2FUNC( AscInitPollIsrCallBack ) ;
       return( 0 ) ;
}

/* -----------------------------------------------------------------------
**
** ---------------------------------------------------------------------*/
int    AscInitPollEnd(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr  iop_base ;
       rint  i ;

       iop_base = asc_dvc->iop_base ;
       asc_dvc->isr_callback = ( Ptr2Func )asc_dvc->saved_ptr2func ;
       AscWriteLramByte( iop_base, ASCV_DISC_ENABLE_B,
                         asc_dvc->cfg->disc_enable ) ;
       AscWriteLramByte( iop_base, ASCV_USE_TAGGED_QNG_B,
                         asc_dvc->use_tagged_qng ) ;
       AscWriteLramByte( iop_base, ASCV_CAN_TAGGED_QNG_B,
                         asc_dvc->cfg->can_tagged_qng ) ;

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            AscWriteLramByte( iop_base,
               ( ushort )( ( ushort )ASCV_MAX_DVC_QNG_BEG+( ushort )i ),
                 asc_dvc->max_dvc_qng[ i ] ) ;
       }/* for */
/*
**  interrupt disabled in AscInitAsc1000Driver()
*/
/*
** if timer is timeout to fast
** there will be interrupt pending left here
*/
       AscAckInterrupt( iop_base ) ;
       AscEnableInterrupt( iop_base ) ;

#if CC_INIT_INQ_DISPLAY
       DvcDisplayString( ( uchar dosfar *)"\r\n" ) ;
#endif /* CC_INIT_INQ_DISPLAY */
       asc_dvc->init_state |= ASC_INIT_STATE_END_INQUIRY ;

       return( 0 ) ;
}
#endif /* CC_INIT_SCSI_TARGET */

void AscAsyncFix(ASC_DVC_VAR asc_ptr_type *, uchar,
    ASC_SCSI_INQUIRY dosfar *);

/*
 * AscAsyncFix()
 *
 * Simlpy set default to no asyn-fix on Processor, Scanner, CDROM,
 * and Tape devices. Selectively apply the fix for Asynchronous
 * Transfer problem which is to run in Synchronous Mode with offset one.
 */
void
AscAsyncFix(ASC_DVC_VAR asc_ptr_type *asc_dvc,
            uchar tid_no,
            ASC_SCSI_INQUIRY dosfar *inq)
{
    uchar  dvc_type;
    ASC_SCSI_BIT_ID_TYPE tid_bits;

    dvc_type = inq->byte0.peri_dvc_type;
    tid_bits = ASC_TIX_TO_TARGET_ID(tid_no);

    if(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN)
    {
        if(!( asc_dvc->init_sdtr & tid_bits))
        {
/*
 * set syn xfer register to ASYN_SDTR_DATA_FIX_PCI_REV_AB
 */
            if((dvc_type == SCSI_TYPE_CDROM)
                && (AscCompareString((uchar *)inq->vendor_id,
                    (uchar *)"HP ", 3) == 0))
            {
                asc_dvc->pci_fix_asyn_xfer_always |= tid_bits;
            }
            asc_dvc->pci_fix_asyn_xfer |= tid_bits;
            if((dvc_type == SCSI_TYPE_PROC) ||
                (dvc_type == SCSI_TYPE_SCANNER) ||
                (dvc_type == SCSI_TYPE_CDROM) ||
                (dvc_type == SCSI_TYPE_SASD))
            {
                asc_dvc->pci_fix_asyn_xfer &= ~tid_bits;
            }

            if(asc_dvc->pci_fix_asyn_xfer & tid_bits)
            {
                AscSetRunChipSynRegAtID(asc_dvc->iop_base, tid_no,
                    ASYN_SDTR_DATA_FIX_PCI_REV_AB);
            }
        }/* if */
    }
    return;
}

int AscTagQueuingSafe(ASC_SCSI_INQUIRY dosfar *);

/*
 * Return non-zero if Tag Queuing can be used with the
 * target with the specified Inquiry information.
 */
int
AscTagQueuingSafe(ASC_SCSI_INQUIRY dosfar *inq)
{
#if CC_FIX_QUANTUM_XP34301_1071
    if ((inq->add_len >= 32) &&
        (AscCompareString((uchar *) inq->vendor_id,
            (uchar *) "QUANTUM XP34301", 15) == 0) &&
        (AscCompareString((uchar *) inq->product_rev_level,
            (uchar *) "1071", 4) == 0))
    {
        return 0;
    }
#endif /* #if CC_FIX_QUANTUM_XP34301_1071 */

    return 1;
}

#if CC_INIT_SCSI_TARGET
/* -----------------------------------------------------------------------
**
** ---------------------------------------------------------------------*/
int    AscInitPollTarget(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          REG ASC_SCSI_INQUIRY dosfar *inq,
          REG ASC_CAP_INFO dosfar *cap_info
       )
{
       uchar  tid_no, lun ;
       uchar  dvc_type ;
       ASC_SCSI_BIT_ID_TYPE tid_bits ;
       int    dvc_found ;
       int    support_read_cap ;
       int    tmp_disable_init_sdtr ;
       int    sta ;

       dvc_found = 0 ;
       tmp_disable_init_sdtr = FALSE ;
       tid_bits = scsiq->r1.target_id ;
       lun = scsiq->r1.target_lun ;
       tid_no = ASC_TIX_TO_TID( scsiq->r2.target_ix ) ;
       if(
           ( ( asc_dvc->init_sdtr & tid_bits ) != 0 )
           && ( ( asc_dvc->sdtr_done & tid_bits ) == 0 )
         )
       {
/*
**
** if host will init sdtr
** we must disable host init SDTR temporarily, as to prevent sending SDTR message
** before we find out which device support SDTR
**
** NOTE: we can not prevent target from sending SDTR here
**
*/
           asc_dvc->init_sdtr &= ~tid_bits ;
           tmp_disable_init_sdtr = TRUE ;
       }/* if */

       if(
           PollScsiInquiry( asc_dvc, scsiq, ( uchar dosfar *)inq,
                            sizeof( ASC_SCSI_INQUIRY ) ) == 1
         )
       {
           dvc_found = 1 ;
           dvc_type = inq->byte0.peri_dvc_type ;
           /*
            * If the Peripheral Device Type is SCSI_TYPE_UNKNOWN (0x1F)
            * then the Peripheral Qualifier must also be checked. The
            * caller is responsible for this checking.
            */
           if( dvc_type != SCSI_TYPE_UNKNOWN )
           {
               support_read_cap = TRUE ;
               if(
                   ( dvc_type != SCSI_TYPE_DASD )
                   && ( dvc_type != SCSI_TYPE_WORM )
                   && ( dvc_type != SCSI_TYPE_CDROM )
                   && ( dvc_type != SCSI_TYPE_OPTMEM )
                 )
               {
                   asc_dvc->start_motor &= ~tid_bits ;
                   support_read_cap = FALSE ;
               }/* if */

#if CC_INIT_INQ_DISPLAY
               AscDispInquiry( tid_no, lun, inq ) ;
#endif /* CC_INIT_INQ_DISPLAY */

               if( lun == 0 )
               {
/*
** we have to check ANSI approved version
*/
                   if(
                       ( inq->byte3.rsp_data_fmt >= 2 )
                       || ( inq->byte2.ansi_apr_ver >= 2 )
                     )
                   {
/*
** response data format >= 2
*/

                       if( inq->byte7.CmdQue )
                       {
                           asc_dvc->cfg->can_tagged_qng |= tid_bits ;
                           if( asc_dvc->cfg->cmd_qng_enabled & tid_bits )
                           {
                               if (AscTagQueuingSafe(inq))
                               {
                                   asc_dvc->use_tagged_qng |= tid_bits ;
                                   asc_dvc->max_dvc_qng[ tid_no ] =
                                       asc_dvc->cfg->max_tag_qng[ tid_no ] ;
                               }
                           }
                       }/* if */

                       if( !inq->byte7.Sync )
                       {
/*
** target does not support SDTR
*/
                           asc_dvc->init_sdtr &= ~tid_bits ;
                           asc_dvc->sdtr_done &= ~tid_bits ;
                       }/* if */
                       else if( tmp_disable_init_sdtr )
                       {
/*
**
** target do support SDTR
**
** we reenable host-inited SDTR here
**
**  NOTE: it is possible target already finished SDTR ( target inited SDTR )
**
*/
                           asc_dvc->init_sdtr |= tid_bits ;
                       }/* else */
                   }/* if */
                   else
                   {
/*
**
** no tagged queuing if response data format < 2
** no SDTR
**
*/
                       asc_dvc->init_sdtr &= ~tid_bits ;
                       asc_dvc->sdtr_done &= ~tid_bits ;
                       asc_dvc->use_tagged_qng &= ~tid_bits ;
                   }/* else */
               }/* if LUN is zero */
/*
** clear PCI asyn xfer fix when:
** 1. if host-inited bit is set ( it means target can do sync xfer )
*/
               AscAsyncFix(asc_dvc, tid_no, inq);

               sta = 1 ;
#if CC_INIT_TARGET_TEST_UNIT_READY
               sta = InitTestUnitReady( asc_dvc, scsiq ) ;
#endif

#if CC_INIT_TARGET_READ_CAPACITY
               if( sta == 1 )
               {
                   if( ( cap_info != 0L ) && support_read_cap )
                   {
                       if( PollScsiReadCapacity( asc_dvc, scsiq,
                           cap_info ) != 1 )
                       {
                           cap_info->lba = 0L ;
                           cap_info->blk_size = 0x0000 ;
                       }/* if */
                       else
                       {

                       }/* else */
                   }/* if */
               }/* if unit is ready */
#endif /* #if CC_INIT_TARGET_READ_CAPACITY */
           }/* if device type is not unknown */
           else
           {
               asc_dvc->start_motor &= ~tid_bits ;
           }/* else */
       }/* if */
       return( dvc_found ) ;
}
#endif /* CC_INIT_SCSI_TARGET */

/*
 * Set Synchronous Transfer and Tag Queuing target capabilities
 * for the specified target from the specified Inquiry information.
 */
void
AscInquiryHandling(ASC_DVC_VAR asc_ptr_type *asc_dvc,
            uchar tid_no, ASC_SCSI_INQUIRY dosfar *inq)
{
    ASC_SCSI_BIT_ID_TYPE tid_bit = ASC_TIX_TO_TARGET_ID(tid_no);
    ASC_SCSI_BIT_ID_TYPE orig_init_sdtr, orig_use_tagged_qng;

    /*
     * Save original values.
     */
    orig_init_sdtr = asc_dvc->init_sdtr;
    orig_use_tagged_qng = asc_dvc->use_tagged_qng;

    /*
     * Clear values by default.
     */
    asc_dvc->init_sdtr &= ~tid_bit;
    asc_dvc->cfg->can_tagged_qng &= ~tid_bit;
    asc_dvc->use_tagged_qng &= ~tid_bit;

    if (inq->byte3.rsp_data_fmt >= 2 || inq->byte2.ansi_apr_ver >= 2)
    {
        /*
         * Synchronous Transfer Capability
         */
        if ((asc_dvc->cfg->sdtr_enable & tid_bit) && inq->byte7.Sync)
        {
            asc_dvc->init_sdtr |= tid_bit;
        }

        /*
         * Command Tag Queuing Capability
         */
        if ((asc_dvc->cfg->cmd_qng_enabled & tid_bit) && inq->byte7.CmdQue)
        {
            if (AscTagQueuingSafe(inq))
            {
                asc_dvc->use_tagged_qng |= tid_bit;
                asc_dvc->cfg->can_tagged_qng |= tid_bit;
            }
        }
    }

    /*
     * Change other operating variables only if there
     * has been a change.
     */
    if (orig_use_tagged_qng != asc_dvc->use_tagged_qng)
    {
        AscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,
            asc_dvc->cfg->disc_enable ) ;
        AscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,
            asc_dvc->use_tagged_qng);
        AscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,
            asc_dvc->cfg->can_tagged_qng);

        asc_dvc->max_dvc_qng[tid_no] =
            asc_dvc->cfg->max_tag_qng[tid_no];
        AscWriteLramByte(asc_dvc->iop_base,
            (ushort) (ASCV_MAX_DVC_QNG_BEG + tid_no),
            asc_dvc->max_dvc_qng[tid_no]);
    }

    if (orig_init_sdtr != asc_dvc->init_sdtr)
    {
        /* Asynchronous Transfer Fix */
        AscAsyncFix(asc_dvc, tid_no, inq);
    }
    return;
}

#if CC_INIT_SCSI_TARGET
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollQueueDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          int  timeout_sec
       )
{
       int  status ;
       int  retry ;

       retry = 0 ;
       do {
           if(
               ( status = AscExeScsiQueue( asc_dvc,
                          ( ASC_SCSI_Q dosfar *)scsiq ) ) == 1
             )
           {
               if( ( status = AscPollQDone( asc_dvc, scsiq,
                   timeout_sec ) ) != 1 )
               {
                   if( status == 0x80 )
                   {
                       if( retry++ > ASC_MAX_INIT_BUSY_RETRY )
                       {
                           break ;
                       }/* if */
                       scsiq->r3.done_stat = 0 ;
                       scsiq->r3.host_stat = 0 ;
                       scsiq->r3.scsi_stat = 0 ;
                       scsiq->r3.scsi_msg = 0 ;
                       DvcSleepMilliSecond( 1000 ) ;
                       continue ;  /* target busy */
                   }/* if */
                   scsiq->r3.done_stat = 0 ;
                   scsiq->r3.host_stat = 0 ;
                   scsiq->r3.scsi_stat = 0 ;
                   scsiq->r3.scsi_msg = 0 ;

#if CC_USE_AscAbortSRB
                   AscAbortSRB( asc_dvc, ( ulong )scsiq ) ;
#endif

               }/* if */
               return( scsiq->r3.done_stat ) ;
           }/* if */
       }while( ( status == 0 ) || ( status == 0x80 ) ) ;
       return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiInquiry(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *buf,
          int buf_len
       )
{
       if( AscScsiInquiry( asc_dvc, scsiq, buf, buf_len ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       return( PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 4 ) ) ;
}

#if CC_INIT_TARGET_START_UNIT
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiStartUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       if( AscScsiStartStopUnit( asc_dvc, scsiq, 1 ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
/*
** wait 40 second to time out
*/
       return( PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 40 ) ) ;
}
#endif
#endif /* CC_INIT_SCSI_TARGET */

#if CC_LITTLE_ENDIAN_HOST
/* -----------------------------------------------------------------------
**
** ----------------------------------------------------------------------- */
ulong dosfar *swapfarbuf4(
          ruchar dosfar *buf
       )
{
       uchar tmp ;

       tmp = buf[ 3 ] ;
       buf[ 3 ] = buf[ 0 ] ;
       buf[ 0 ] = tmp ;

       tmp = buf[ 1 ] ;
       buf[ 1 ] = buf[ 2 ] ;
       buf[ 2 ] = tmp ;

       return( ( ulong dosfar *)buf ) ;
}
#endif /* #if CC_LITTLE_ENDIAN_HOST */

#if CC_INIT_SCSI_TARGET
#if CC_INIT_TARGET_READ_CAPACITY

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiReadCapacity(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          REG ASC_CAP_INFO dosfar *cap_info
       )
{
       ASC_CAP_INFO  scsi_cap_info ;
       int  status ;

       if( AscScsiReadCapacity( asc_dvc, scsiq,
                                ( uchar dosfar *)&scsi_cap_info ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       status = PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 8 ) ;
       if( status == 1 )
       {

#if CC_LITTLE_ENDIAN_HOST
           cap_info->lba = ( ulong )*swapfarbuf4( ( uchar dosfar *)&scsi_cap_info.lba ) ;
           cap_info->blk_size = ( ulong )*swapfarbuf4( ( uchar dosfar *)&scsi_cap_info.blk_size ) ;
#else
           cap_info->lba = scsi_cap_info.lba ;
           cap_info->blk_size = scsi_cap_info.blk_size ;
#endif /* #if CC_LITTLE_ENDIAN_HOST */

           return( scsiq->r3.done_stat ) ;
       }/* if */
       return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
}

#endif /* if CC_INIT_TARGET_READ_CAPACITY */

#if CC_INIT_TARGET_TEST_UNIT_READY
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    PollScsiTestUnitReady(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       if( AscScsiTestUnitReady( asc_dvc, scsiq ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       return( PollQueueDone( asc_dvc, ( ASC_SCSI_REQ_Q dosfar *)scsiq, 12 ) ) ;
}

/* -----------------------------------------------------------------------
**
** --------------------------------------------------------------------- */
int    InitTestUnitReady(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       ASC_SCSI_BIT_ID_TYPE tid_bits ;
       int    retry ;
       ASC_REQ_SENSE dosfar *sen ;

       retry = 0 ;
       tid_bits = scsiq->r1.target_id ;
       while( retry++ < 4 )
       {
           PollScsiTestUnitReady( asc_dvc, scsiq ) ;
           if( scsiq->r3.done_stat == 0x01 )
           {
               return( 1 ) ;
           }/* if */
           else if( scsiq->r3.done_stat == QD_WITH_ERROR )
           {
               sen = ( ASC_REQ_SENSE dosfar *)scsiq->sense_ptr ;

               if(
                   ( scsiq->r3.scsi_stat == SS_CHK_CONDITION )
                   && ( ( sen->err_code & 0x70 ) != 0 )
                 )
               {
                   if( sen->sense_key == SCSI_SENKEY_NOT_READY )
                   {
                       /*
                        * If No Media Is Present don't perform a retry
                        * and don't perform a Start Unit.
                        *
                        * Warning: AscIsrQDone() calls AscStartUnit()
                        * from teh interrupt hanlder. This causes a
                        * stack overrun in ASPI with ADVANCD if the
                        * start_motor bit is not cleared here. Refer
                        * to the log file for more information.
                        */
                       if (sen->asc == SCSI_ASC_NOMEDIA)
                       {
                           asc_dvc->start_motor &= ~tid_bits ;
                           break;
                       }
#if CC_INIT_TARGET_START_UNIT
                       /*
                       ** device is in process of becoming ready
                       */
                       if( asc_dvc->start_motor & tid_bits )
                       {
                           if( PollScsiStartUnit( asc_dvc, scsiq ) == 1 )
                           {
                               /*
                                * Delay for 250 ms after the successful
                                * Start Unit command. A Conner and IBM
                                * disk drive have been found to hang
                                * on commands that come too soon after
                                * a Start Unit.
                                */
                               DvcSleepMilliSecond(250) ;
                               continue ;
                           }/* if */
                           else
                           {
                               asc_dvc->start_motor &= ~tid_bits ;
                               break ;
                           }/* else */
                       }/* if start unit */
                       else
                       {
                           DvcSleepMilliSecond( 250 ) ;
                       }/* else */
#endif /* #if CC_INIT_TARGET_START_UNIT */
                   }/* if is not ready */
                   else if( sen->sense_key == SCSI_SENKEY_ATTENTION )
                   {
                       DvcSleepMilliSecond( 250 ) ;
                   }/* else */
                   else
                   {
                       break ;
                   }/* else if */
               }/* if valid sense key found */
               else
               {
                   break ;
               }/* else */
           }/* else */
           else if( scsiq->r3.done_stat == QD_ABORTED_BY_HOST )
           {
               break ;
           }/* else */
           else
           {
               break ;
           }/* else */
       }/* while */
       return( 0 ) ;
}
#endif /* #if CC_INIT_TARGET_TEST_UNIT_READY */


#if CC_INIT_INQ_DISPLAY
/* ------------------------------------------------------------------
**
** ---------------------------------------------------------------- */
void   AscDispInquiry(
          uchar tid,
          uchar lun,
          REG ASC_SCSI_INQUIRY dosfar *inq
       )
{

       int    i ;
       uchar  strbuf[ 18 ] ;
       uchar dosfar *strptr ;
       uchar  numstr[ 12 ] ;

       strptr = ( uchar dosfar *)strbuf ;
       DvcDisplayString( ( uchar dosfar *)" SCSI ID #" ) ;
       DvcDisplayString( todstr( tid, numstr ) ) ;
       if( lun != 0 )
       {
           DvcDisplayString( ( uchar dosfar *)" LUN #" ) ;
           DvcDisplayString( todstr( lun, numstr ) ) ;
       }/* if */
       DvcDisplayString( ( uchar dosfar *)"  Type: " ) ;
       DvcDisplayString( todstr( inq->byte0.peri_dvc_type, numstr ) ) ;
       DvcDisplayString( ( uchar dosfar *)"  " ) ;

       for( i = 0 ; i < 8 ; i++ ) strptr[ i ] = inq->vendor_id[ i ] ;
       strptr[ i ] = EOS ;
       DvcDisplayString( strptr ) ;

       DvcDisplayString( ( uchar dosfar *)" " ) ;
       for( i = 0 ; i < 16 ; i++ ) strptr[ i ] = inq->product_id[ i ] ;
       strptr[ i ] = EOS ;
       DvcDisplayString( strptr ) ;

       DvcDisplayString( ( uchar dosfar *)" " ) ;
       for( i = 0 ; i < 4 ; i++ ) strptr[ i ] = inq->product_rev_level[ i ] ;
       strptr[ i ] = EOS ;
       DvcDisplayString( strptr ) ;
       DvcDisplayString( ( uchar dosfar *)"\r\n" ) ;
       return ;
}
#endif /* CC_INIT_INQ_DISPLAY */

/* ---------------------------------------------------------------------
**
** return values:
**
** FALSE(0): if timed out
** ERR(-1):  if fatla error !
** TRUE(1):  if command completed
** 0x80:     if target is busy
**
** ------------------------------------------------------------------- */
int    AscPollQDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          int timeout_sec
       )
{
       int      loop, loop_end ;
       int      sta ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       loop = 0 ;
       loop_end = timeout_sec * 100 ;
       sta = 1 ;

       while( TRUE )
       {
           if( asc_dvc->err_code != 0 )
           {
               scsiq->r3.done_stat = QD_WITH_ERROR ;
               sta = ERR ;
               break ;
           }/* if */
           if( scsiq->r3.done_stat != QD_IN_PROGRESS )
           {
               if( ( scsiq->r3.done_stat == QD_WITH_ERROR ) &&
                   ( scsiq->r3.scsi_stat == SS_TARGET_BUSY ) )
               {
                   sta = 0x80 ;
               }/* if */
               break ;
           }/* if */
           DvcSleepMilliSecond( 10 ) ; /* for dos 55 millisec is one unit */
           if( loop++ > loop_end )
           {
               sta = 0 ;
               break ;
           }/* if */
           if( AscIsChipHalted( iop_base ) )
           {
#if !CC_ASCISR_CHECK_INT_PENDING
               AscAckInterrupt( iop_base ) ;
#endif
               AscISR( asc_dvc ) ;
               loop = 0 ;
           }/* if */
           else
           {
               if( AscIsIntPending( iop_base ) )
               {
#if !CC_ASCISR_CHECK_INT_PENDING
                   AscAckInterrupt( iop_base ) ;
#endif
                   AscISR( asc_dvc ) ;
               }/* if */
           }/* else */
       }/* while */
/*
** should not break to here
*/
       return( sta ) ;
}

#endif /* CC_INIT_SCSI_TARGET */

/* ---------------------------------------------------------------------
**
**
**
** ------------------------------------------------------------------- */
int    AscCompareString(
          ruchar *str1,
          ruchar *str2,
          int    len
       )
{
       int  i ;
       int  diff ;

       for( i = 0 ; i < len ; i++ )
       {
            diff = ( int )( str1[ i ] - str2[ i ]  ) ;
            if( diff != 0 ) return( diff ) ;
       }
       return( 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_mis.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_mis.c
*/

#include "ascinc.h"

/* -----------------------------------------------------------------------
** Description: convert ASC1000 target id number ( bit 0 set to bit 7 set )
** to target id number ( 0 to 7 )
**
** return 0xFF if input is invalid
** -------------------------------------------------------------------- */
uchar  AscScsiIDtoTID(
          uchar tid
       )
{
       uchar  i ;

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            if( ( ( tid >> i ) & 0x01 ) != 0 ) return( i ) ;
       }/* for */
       return( 0xFF ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_scsi.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** asc_scsi.c
**
*/

#include "ascinc.h"
#include "ascsidef.h"

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscScsiInquiry(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *buf,
          int buf_len
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, buf,
           ( ulong )buf_len ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_Inquiry ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = buf_len ;
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->r2.cdb_len = 6 ;
       return( 0 ) ;
}

#if CC_INIT_TARGET_READ_CAPACITY

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscScsiReadCapacity(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *info
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, info, 8L ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_ReadCapacity ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = 0 ;
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->cdb[ 6 ] = 0 ;
       scsiq->cdb[ 7 ] = 0 ;
       scsiq->cdb[ 8 ] = 0 ;
       scsiq->cdb[ 9 ] = 0 ;
       scsiq->r2.cdb_len = 10 ;
       return( 0 ) ;
}

#endif /*  #if CC_INIT_TARGET_READ_CAPACITY */

#if CC_INIT_TARGET_TEST_UNIT_READY
/* -----------------------------------------------------------------------
**
**
** --------------------------------------------------------------------- */
int    AscScsiTestUnitReady(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR,
           ( ulong )0L ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->r1.cntl = ( uchar )ASC_SCSIDIR_NODATA ;
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_TestUnitReady ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = 0 ;
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->r2.cdb_len = 6 ;
       return( 0 ) ;
}
#endif /* #if CC_INIT_TARGET_TEST_UNIT_READY */

#if CC_INIT_TARGET_START_UNIT
/* -----------------------------------------------------------------------
**
**
** --------------------------------------------------------------------- */
int    AscScsiStartStopUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar op_mode
       )
{
       if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR, ( ulong )0L ) == ERR )
       {
           return( scsiq->r3.done_stat = QD_WITH_ERROR ) ;
       }/* if */
       scsiq->r1.cntl = ( uchar )ASC_SCSIDIR_NODATA ;
       scsiq->cdb[ 0 ] = ( uchar )SCSICMD_StartStopUnit ;
       scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
       scsiq->cdb[ 2 ] = 0 ;
       scsiq->cdb[ 3 ] = 0 ;
       scsiq->cdb[ 4 ] = op_mode ; /* to start/stop unit set bit 0 */
                                   /* to eject/load unit set bit 1 */
       scsiq->cdb[ 5 ] = 0 ;
       scsiq->r2.cdb_len = 6 ;
       return( 0 ) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\asc_res.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** ASC_RES.C
**
*/

#include "ascinc.h"

/* -----------------------------------------------------------------------
** NOT FOR GENERAL PUBLIC !!!
**
** Description: poll queue head syncronization status
**
** returns:
** 0 - pointer not sycronized
** 1 - queue pointer syncronized
** else - unrecoverable error
**
** -------------------------------------------------------------------- */
int    AscPollQTailSync(
          PortAddr iop_base
       )
{
       uchar  risc_done_q_tail ;

       risc_done_q_tail = AscReadLramByte( iop_base, ASCV_DONENEXT_B ) ;
       if( AscGetVarDoneQTail( iop_base ) != risc_done_q_tail ) {
           return( 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
** NOT FOR GENERAL PUBLIC !!!
**
** Description: syncronize queue pointers
**
** returns:
** 0 - no fault found,
** 1 - queue pointer syncronized, error corrected
** else - unrecoverable error
**
** NOTE:
** 1. if RISC is not in idle state, result can be catastrophic !!!
**
** -------------------------------------------------------------------- */
int    AscPollQHeadSync(
          PortAddr iop_base
       )
{
       uchar  risc_free_q_head ;

       risc_free_q_head = AscReadLramByte( iop_base, ASCV_NEXTRDY_B ) ;
       if( AscGetVarFreeQHead( iop_base ) != risc_free_q_head ) {
           return( 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
int    AscWaitQTailSync(
          PortAddr iop_base
       )
{
       uint loop ;

       loop = 0 ;
       while( AscPollQTailSync( iop_base ) != 1 ) {
/*
** wait 15 seconds for all queues to be done
*/
              DvcSleepMilliSecond( 100L ) ;
              if( loop++ > 150 ) {
                  return( 0 ) ;
              }/* if */
       }/* while */
       return( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_ddinc.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_ddinc.h
*/

#ifndef __ASCINC_H_
#define __ASCINC_H_

#include "ascdef.h"
#include "a_osdep.h"
#include "a_cc.h"
#include "ascdep.h"    /* chip dependent include file */
#include "ascsidef.h"  /* ASC SCSI definition         */
#include "aspiq.h"     /* ASC QUEUE                   */
#include "asc1000.h"
#include "a_ddlib.h"

#endif /* #ifndef __ASCINC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_eisa.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_eisa.c
**
** for EISA only, functions may be called at run time
**
*/

#include "ascinc.h"

#if CC_INCLUDE_EISA

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
ushort AscGetEisaChipCfg(
          PortAddr iop_base
       )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                  ( PortAddr )( ASC_EISA_CFG_IOP_MASK ) ;
       return( inpw( eisa_cfg_iop ) ) ;
}

/* ----------------------------------------------------------------------
**  read EISA general purpose register
**  Note: currently unused
** ------------------------------------------------------------------ */
ushort AscGetEisaChipGpReg( PortAddr iop_base )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                 ( PortAddr )( ASC_EISA_CFG_IOP_MASK - 2 ) ;
       return( inpw( eisa_cfg_iop ) ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
ushort AscSetEisaChipCfg(
          PortAddr iop_base,
          ushort cfg_lsw
       )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                 ( PortAddr )( ASC_EISA_CFG_IOP_MASK ) ;
       outpw( eisa_cfg_iop, cfg_lsw ) ;
       return( 0 ) ;
}

/* ----------------------------------------------------------------------
**
** write EISA general purpose register
** Note:
**  currently unused
** ------------------------------------------------------------------ */
ushort AscSetEisaChipGpReg(
          PortAddr iop_base,
          ushort gp_reg
       )
{
       PortAddr  eisa_cfg_iop ;

       eisa_cfg_iop = ( PortAddr )ASC_GET_EISA_SLOT( iop_base ) |
                                 ( PortAddr )( ASC_EISA_CFG_IOP_MASK - 2 ) ;
       outpw( eisa_cfg_iop, gp_reg ) ;
       return( 0 ) ;
}

#endif /* CC_INCLUDE_EISA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_init1.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_init1.c
**
*/

#include "ascinc.h"

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
void   AscClrResetScsiBus(
          PortAddr iop_base
       )
{
       uchar  cc ;

       cc = AscGetChipControl( iop_base ) ;
       cc &= ~( CC_SCSI_RESET | CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ;
       AscSetChipControl( iop_base, cc ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
uchar  AscSetChipScsiID(
          PortAddr iop_base,
          uchar new_host_id
       )
{
       ushort cfg_lsw ;

       if( AscGetChipScsiID( iop_base ) == new_host_id ) {
           return( new_host_id ) ;
       }/* if */
       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
       cfg_lsw &= 0xF8FF ;
       cfg_lsw |= ( ushort )( ( new_host_id & ASC_MAX_TID ) << 8 ) ;
       AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
       return( AscGetChipScsiID( iop_base ) ) ;
}

/* ----------------------------------------------------------------------
** return chip scsi contrl
**
** see asc1000.h definition SC_?? for details
** ------------------------------------------------------------------- */
uchar  AscGetChipScsiCtrl(
          PortAddr iop_base
       )
{
       uchar  sc ;

       AscSetBank( iop_base, 1 ) ;
       sc = inp( iop_base+IOP_REG_SC ) ;
       AscSetBank( iop_base, 0 ) ;
       return( sc ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
uchar  AscGetChipVersion(
          PortAddr iop_base,
          ushort bus_type
       )
{

#if !CC_PCI_ADAPTER_ONLY
#if CC_INCLUDE_EISA
       if( ( bus_type & ASC_IS_EISA ) != 0 ) {
/*
** EISA
**
** Only version 1 of the EISA chip was ever and will ever be released.
*/
           return( 1 );
       }/* if */
#endif
#endif
       return( AscGetChipVerNo( iop_base ) ) ;
}

/* ----------------------------------------------------------------------
**
** return following bus type
** ASC_IS_VL
** ASC_IS_ISA
** ASC_IS_PCI
** ASC_IS_EISA
**
** Note:
**   the function cannot get PCI device ID, which was needed
**   in PCI driver init time ( for bug fix of certain version )
**
** ------------------------------------------------------------------ */
ushort AscGetChipBusType(
          PortAddr iop_base
       )
{
       ushort chip_ver ;

#if !CC_PCI_ADAPTER_ONLY
       chip_ver = AscGetChipVerNo( iop_base ) ;

#if CC_INCLUDE_VL
       if(
           ( chip_ver >= ASC_CHIP_MIN_VER_VL )
           && ( chip_ver <= ASC_CHIP_MAX_VER_VL )
         )
       {
           if(
               ( ( iop_base & 0x0C30 ) == 0x0C30 )
               || ( ( iop_base & 0x0C50 ) == 0x0C50 )
             )
           {
               return( ASC_IS_EISA ) ;
           }/* if */
           return( ASC_IS_VL ) ;
       }
#endif /* CC_INCLUDE_VL */

       if( ( chip_ver >= ASC_CHIP_MIN_VER_ISA ) &&
              ( chip_ver <= ASC_CHIP_MAX_VER_ISA ) )
       {
           if( chip_ver >= ASC_CHIP_MIN_VER_ISA_PNP )
           {
               return( ASC_IS_ISAPNP ) ;
           }
           return( ASC_IS_ISA ) ;
       }else if( ( chip_ver >= ASC_CHIP_MIN_VER_PCI ) &&
              ( chip_ver <= ASC_CHIP_MAX_VER_PCI ) )
       {
#endif /* !CC_PCI_ADAPTER_ONLY  */
           return( ASC_IS_PCI ) ;
#if !CC_PCI_ADAPTER_ONLY
       }
       return( 0 ) ; /* error cannot identify bus type */
#endif /* !CC_PCI_ADAPTER_ONLY  */
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
ulong  AscLoadMicroCode(
          PortAddr iop_base,
          ushort s_addr,
          ushort dosfar *mcode_buf,
          ushort mcode_size
       )
{
       ulong   chksum ;
       ushort  mcode_word_size ;
       ushort  mcode_chksum ;

       mcode_word_size = ( ushort )( mcode_size >> 1 ) ;
       AscMemWordSetLram( iop_base, s_addr, 0, mcode_word_size ) ;
       AscMemWordCopyToLram( iop_base, s_addr, mcode_buf, mcode_word_size ) ;

#if 0
/*
**  use busy queue head as the auto request sense command queue
**  when a check condition occured
**  we put request sense command ( 6 bytes ) into its cdb buffer
*/
       q_no = AscReadLramByte( iop_base, ASCV_BUSY_QHEAD_B ) ;
       q_addr = ASC_QNO_TO_QADDR( q_no ) ;
       AscWriteLramByte( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_B_CDB_LEN ), 0x06 ) ;
       AscWriteLramWord( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_CDB_BEG ), 0x0003 ) ;
       AscWriteLramWord( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_CDB_BEG+2 ), 0x0000 ) ;
       AscWriteLramWord( iop_base,
                       ( ushort )( q_addr + ASC_SCSIQ_CDB_BEG+4 ), 0x0000 ) ;
#endif
/*
** we need to set entire queue buffer data to 0xFF
** it means no queue is disconnected
*/
#if 0
       q_no = AscReadLramByte( iop_base, ASCV_DISC1_QHEAD_B ) ;
       q_addr = ASC_QNO_TO_QADDR( q_no ) ;
       AscMemWordSetLram( iop_base, q_addr,
                          0xFFFF, ( ushort )( ASC_QBLK_SIZE >> 1 ) ) ;
#endif
       chksum = AscMemSumLramWord( iop_base, s_addr, mcode_word_size ) ;
       mcode_chksum = ( ushort )AscMemSumLramWord( iop_base,
                                                 ( ushort )ASC_CODE_SEC_BEG,
       ( ushort )( ( mcode_size - s_addr - ( ushort )ASC_CODE_SEC_BEG )/2 ) ) ;
       AscWriteLramWord( iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum ) ;
       AscWriteLramWord( iop_base, ASCV_MCODE_SIZE_W, mcode_size ) ;
       return( chksum ) ;
}

/* -----------------------------------------------------------------
** return 0 if not found
** -------------------------------------------------------------- */
int    AscFindSignature(
          PortAddr iop_base
       )
{
       ushort  sig_word ;

       if( AscGetChipSignatureByte( iop_base ) == ( uchar )ASC_1000_ID1B ) {
           sig_word = AscGetChipSignatureWord( iop_base ) ;
           if( ( sig_word == ( ushort )ASC_1000_ID0W ) ||
               ( sig_word == ( ushort )ASC_1000_ID0W_FIX ) ) {
               return( 1 ) ;
           }/* if */
       }/* if */
       return( 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_init2.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_init2.c
**
*/


#include "ascinc.h"

#if !CC_PCI_ADAPTER_ONLY
/*
** for VL, ISA
*/

uchar _isa_pnp_inited = 0 ;

PortAddr _asc_def_iop_base[ ASC_IOADR_TABLE_MAX_IX ] = {
  0x100, ASC_IOADR_1, 0x120, ASC_IOADR_2, 0x140, ASC_IOADR_3, ASC_IOADR_4,
  ASC_IOADR_5, ASC_IOADR_6, ASC_IOADR_7, ASC_IOADR_8
} ;


/* -----------------------------------------------------------------
** return 0 if not found
**
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddr(
            PortAddr iop_beg,
            ushort bus_type
         )
{

#if CC_INCLUDE_VL
       if( bus_type & ASC_IS_VL )
       {
           while( ( iop_beg = AscSearchIOPortAddr11( iop_beg ) ) != 0 )
           {
               if( AscGetChipVersion( iop_beg, bus_type ) <= ASC_CHIP_MAX_VER_VL )
               {
                   return( iop_beg ) ;
               }/* if */
           }/* if */
           return( 0 ) ;
       }/* if */
#endif /* CC_INCLUDE_VL */

       if( bus_type & ASC_IS_ISA )
       {
           if( _isa_pnp_inited == 0 )
           {
               AscSetISAPNPWaitForKey( ) ;
               _isa_pnp_inited++ ;
           }/* if */
           while( ( iop_beg = AscSearchIOPortAddr11( iop_beg ) ) != 0 )
           {
               if( ( AscGetChipVersion( iop_beg, bus_type ) & ASC_CHIP_VER_ISA_BIT ) != 0 )
               {
                   return( iop_beg ) ;
               }/* if */
           }/* if */
           return( 0 ) ;
       }/* if */

#if CC_INCLUDE_EISA
       if( bus_type & ASC_IS_EISA )
       {
           if( ( iop_beg = AscSearchIOPortAddrEISA( iop_beg ) ) != 0 )
           {
               return( iop_beg ) ;
           }/* if */
           return( 0 ) ;
       }/* if */
#endif
       return( 0 ) ;
}

/* -----------------------------------------------------------------
** Description: search VL and ISA host adapter ( on 8 default address )
**
** return 0 if not found
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddr11(
            PortAddr s_addr
         )
{
/*
** VL, ISA
*/
       int      i ;
       PortAddr iop_base ;

       for( i = 0 ; i < ASC_IOADR_TABLE_MAX_IX ; i++ )
       {
            if( _asc_def_iop_base[ i ] > s_addr )
            {
                break ;
            }/* if */
       }/* for */
       for( ; i < ASC_IOADR_TABLE_MAX_IX ; i++ )
       {
            iop_base = _asc_def_iop_base[ i ] ;
            if( AscFindSignature( iop_base ) )
            {
                return( iop_base ) ;
            }/* if */
       }/* for */
       return( 0 ) ;
}

/* -----------------------------------------------------------------
** Description: search VL and ISA host adapter
**
** search starts with iop_base equals 0
** return i/o port address found
** return 0 if not found
** -------------------------------------------------------------- */
PortAddr AscSearchIOPortAddr100(
            PortAddr iop_base
         )
{
/*
** VL, ISA
*/
       if( iop_base > ASC_MAX_IOP_ADDR ) return( 0 ) ;
       if( iop_base == 0 ) iop_base = ASC_MIN_IOP_ADDR ;
       else
       {
           iop_base += ( PortAddr )( ASC_SEARCH_IOP_GAP ) ;
       }/* else */
       while( iop_base <= ASC_MAX_IOP_ADDR )
       {
           if( AscFindSignature( iop_base ) )
           {
               return( iop_base ) ;
           }/* if */
           iop_base += ( PortAddr )( ASC_SEARCH_IOP_GAP ) ;
       }/* while */
       return( 0 ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscToggleIRQAct(
          PortAddr iop_base
       )
{
       AscSetChipStatus( iop_base, CIW_IRQ_ACT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
void   AscClrResetChip(
          PortAddr iop_base
       )
{
       uchar  cc ;

       while( AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE ) ;
       cc = AscGetChipControl( iop_base ) ;
       cc &= ( uchar )( ~( CC_CHIP_RESET | CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ) ;
       AscSetChipControl( iop_base, cc ) ;
       return ;
}

#endif /* #if !CC_PCI_ADAPTER_ONLY */

#if CC_INIT_INQ_DISPLAY

uchar  _hextbl_[ 16 ] = { '0','1','2','3','4','5','6','7','8','9',
                          'A','B','C','D','E','F' } ;

/* -----------------------------------------------------------------------
** Usage  :  void  itos( num, nstr, ndigit, f_blank )
**                 short  num, ndigit, f_blank ;
**                 U_CHAR  *nstr ;
**
**           num  :   the integer to be converted
**           nstr :   the converted ascii string
**           ndigit : minimum number of digits
**           f_blank : if TRUE,  fill string under ndigit with blanks
**                     else fill with '0'
**
** Description : convert an integer to ascii string
**
** -------------------------------------------------------------------- */
short  itos(
             ushort num,
             ruchar dosfar *nstr,
             short ndigit,
             short f_blank
       )
{
       short    len, div ;
       short    fill ;
       ushort   divisor ;
       uchar    f_ch ;

       len = 0 ;
       if( num == 0 )
       {
           *nstr = '0' ;
           len++ ;
       }/* if */
       else
       {
           if( num < 10 ) divisor = 1 ;
           else if( num < 100 ) divisor = 10 ;
           else if( num < 1000 ) divisor = 100 ;
           else if( num < 10000 ) divisor = 1000 ;
           else divisor = 10000 ;
           while( divisor != 0 )
           {
               if( num >= divisor )
               {
                   div = ( num / divisor ) ;
                   num -= divisor * div ;
                   nstr[ len ] = div + '0' ;
               }/* if */
               else nstr[ len ] = '0' ;
               len++ ;
               divisor /= 10 ;
           }/* while */
       }/* else */
       nstr[ len ] = EOS ;
       if( ( fill = ndigit - len ) > 0 )
       {
           if( f_blank == 0 ) f_ch = '0' ;
           else  f_ch = ' ' ;
           return( insnchar( nstr, len, 0, f_ch, fill ) ) ;
       }/* if string length under ndigit specified */
       return( len ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
int    insnchar(
           uchar dosfar *str,
           short len,
           short beg_po,
           ruchar ch,
           short n_ch
       )
{
       ruchar dosfar *strbeg ;
       ruchar dosfar *str2 ;

       strbeg = str + beg_po ;
       str += len ;
       str2 = str + n_ch ;
       while( str >= strbeg ) *str2-- = *str-- ;
       str2 = strbeg + n_ch ; /* end of insertion */
       while( strbeg < str2 ) *strbeg++ = ch ;
       /* move string content fill position */
       return( len + n_ch ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   itoh(
             ushort word_val,
             ruchar dosfar *hstr
       )
{
       short     shf ;
       ruchar dosfar *strend ;
       ruchar dosfar *htbl = ( uchar dosfar *)_hextbl_ ;

       strend = hstr + 4 ;
       *strend-- = EOS ;
       for( shf = 0 ; strend >= hstr ; shf += 4 )
       {
            *strend-- = htbl[ ( word_val >> shf ) & 0x000F ] ;
       }/* for */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   btoh(
             uchar byte_val,
             ruchar dosfar *hstr
       )
{
       short     shf ;
       ruchar dosfar *strend ;
       ruchar dosfar *htbl = ( uchar dosfar *)_hextbl_ ;

       strend = hstr + 2 ;
       *strend-- = EOS ;
       for( shf = 0 ; strend >= hstr ; shf += 4 )
       {
            *strend-- = htbl[ ( byte_val >> shf ) & 0x0F ] ;
       }/* for */
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   ltoh(
             ulong lval,
             ruchar dosfar *hstr
       )
{
       ushort dosfar *val ;

       val = ( ushort *)&lval ;
       val++ ;
       itoh( *val--, hstr ) ;
       hstr += 4 ;
       *hstr++ = ':' ;
       itoh( *val, hstr ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *todstr(
           ushort val,
           uchar dosfar *strhex
       )
{
       itos( val, strhex, 0, 0 ) ;
       return( strhex ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *tohstr(
           ushort val,
           uchar dosfar *hstr
        )
{
        itoh( val, hstr ) ;
        return( hstr ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *tobhstr(
         uchar val,
         uchar dosfar *hstr
      )
{
        btoh( val, hstr ) ;
        return( hstr ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
uchar dosfar *tolhstr(
          ulong val,
          uchar dosfar *hstr
      )
{
        ltoh( val, hstr ) ;
        return( hstr ) ;
}


#endif /* CC_INIT_INQ_DISPLAY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_ddlib.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_ddlib.h
**
** include file for device driver writer
**
*/

#ifndef __A_DDLIB_H_
#define __A_DDLIB_H_

#include "ascdef.h"
#include "a_osdep.h"   /* os dependent */
#include "a_cc.h"      /* code generation control */
#include "ascdep.h"    /* chip dependent include file  */
#include "ascsidef.h"  /* ASC SCSI definition          */
#include "aspiq.h"     /* ASC QUEUE                    */

#include "asc1000.h"

/*
** for device driver writer
** you need to support the following routines
*/

extern int    DvcEnterCritical( void ) ;
extern void   DvcLeaveCritical( int ) ;
extern void   DvcSetMemory( uchar dosfar *, uint, uchar ) ;
extern void   DvcCopyMemory( uchar dosfar *, uchar dosfar *, uint ) ;

extern void   DvcInPortWords( PortAddr, ushort dosfar *, int ) ;
extern void   DvcOutPortWords( PortAddr, ushort dosfar *, int ) ;
extern void   DvcOutPortDWords( PortAddr, ulong dosfar *, int ) ;

extern uchar  DvcReadPCIConfigByte( ASC_DVC_VAR asc_ptr_type *, ushort ) ;
extern void   DvcWritePCIConfigByte( ASC_DVC_VAR asc_ptr_type *, ushort, uchar ) ;
/* extern ushort DvcReadPCIConfigWord( ASC_DVC_VAR asc_ptr_type *, ushort ) ; */
/* extern void   DvcWritePCIConfigWord( ASC_DVC_VAR asc_ptr_type *, ushort, ushort ) ; */
/* extern ulong  DvcReadPCIConfigDWord( ASC_DVC_VAR asc_ptr_type *, ushort ) ; */
/* extern void   DvcWritePCIConfigDWord( ASC_DVC_VAR asc_ptr_type *, ushort, ulong ) ; */

extern void   DvcSleepMilliSecond( ulong ) ;
extern void   DvcDelayNanoSecond( ASC_DVC_VAR asc_ptr_type *, ulong ) ;

extern void   DvcDisplayString( uchar dosfar * ) ;
extern ulong  DvcGetPhyAddr( uchar dosfar *buf_addr, ulong buf_len ) ;
extern ulong  DvcGetSGList( ASC_DVC_VAR asc_ptr_type *, uchar dosfar *, ulong,
                            ASC_SG_HEAD dosfar * ) ;

/*
** for SCAM only, define CC_SCAM as TRUE in "a_cc.h" to enable SCAM
*/
extern void   DvcSCAMDelayMS( ulong ) ;
extern int    DvcDisableCPUInterrupt( void ) ;
extern void   DvcRestoreCPUInterrupt( int ) ;

/*
**
** extern int    DvcNotifyUcBreak( ASC_DVC_VAR asc_ptr_type *asc_dvc, ushort break_addr ) ;
**
*/
extern int    DvcNotifyUcBreak( ASC_DVC_VAR asc_ptr_type *, ushort ) ;
/* extern int    DvcDebugDisplayString( uchar * ) ; */


/*
**
** special put/get Q struct routine
** for compiler aligned struct ( no packing ) use file "a_align.c"
**
*/
void  DvcPutScsiQ( PortAddr, ushort, ushort dosfar *, int ) ;
void  DvcGetQinfo( PortAddr, ushort, ushort dosfar *, int ) ;

/*
** if you use AscInitScsiTarget(), you need to provide the following
** two functions, and also two source files of asc_inq.c and asc_scsi.c
*/

/*
** you only need the following routines to write a device driver
*/

/*
** initialization functions
*/
PortAddr AscSearchIOPortAddr( PortAddr, ushort ) ;
ushort AscInitGetConfig( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitSetConfig( ASC_DVC_VAR asc_ptr_type * ) ;
ushort AscInitAsc1000Driver( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscInitScsiTarget( ASC_DVC_VAR asc_ptr_type *,
                          ASC_DVC_INQ_INFO dosfar *,
                          uchar dosfar *,
                          ASC_CAP_INFO_ARRAY dosfar *,
                          ushort ) ;
int    AscInitPollBegin( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscInitPollEnd( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscInitPollTarget( ASC_DVC_VAR asc_ptr_type *,
                          ASC_SCSI_REQ_Q dosfar *,
                          ASC_SCSI_INQUIRY dosfar *,
                          ASC_CAP_INFO dosfar * ) ;
void   AscInquiryHandling(ASC_DVC_VAR asc_ptr_type *,
                          uchar,
                          ASC_SCSI_INQUIRY dosfar *);
int    AscExeScsiQueue( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_Q dosfar * ) ;

/*
** handle interrupt functions
*/
int    AscISR( ASC_DVC_VAR asc_ptr_type * ) ;
void   AscISR_AckInterrupt( ASC_DVC_VAR asc_ptr_type * ) ;
int    AscISR_CheckQDone( ASC_DVC_VAR asc_ptr_type *,
                          ASC_QDONE_INFO dosfar *,
                          uchar dosfar * ) ;
/*
** Macro
**
**     AscIsIntPending( port )
**
*/

/*
** for Power Saver
*/
int    AscStartUnit( ASC_DVC_VAR asc_ptr_type *, ASC_SCSI_TIX_TYPE ) ;

int    AscStopUnit(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_SCSI_TIX_TYPE target_ix
       ) ;

/*
** queue resource inquiry functions
*/
uint   AscGetNumOfFreeQueue( ASC_DVC_VAR asc_ptr_type *, uchar, uchar ) ;
int    AscSgListToQueue( int ) ;
int    AscQueueToSgList( int ) ;
int    AscSetDvcErrorCode( ASC_DVC_VAR asc_ptr_type *, uchar ) ;

/*
**  handle unexpected event
*/
int    AscAbortSRB( ASC_DVC_VAR asc_ptr_type *, ulong ) ;
int    AscResetDevice( ASC_DVC_VAR asc_ptr_type *, uchar ) ;
int    AscResetSB( ASC_DVC_VAR asc_ptr_type * ) ;

/*
** for ISA only
*/
void   AscEnableIsaDma( uchar ) ;
void   AscDisableIsaDma( uchar ) ;

/*
**
**  for DMA limitation
**
*/
ulong  AscGetMaxDmaAddress( ushort ) ;
ulong  AscGetMaxDmaCount( ushort ) ;


/*
**
** set micro code break point
** file "a_debug.c"
**
*/
int               AscSetUcBreakPoint( ASC_DVC_VAR asc_ptr_type *, ushort, int, ushort ) ;
int               AscClearUcBreakPoint( ASC_DVC_VAR asc_ptr_type *, ushort ) ;

/*
** for Novell only
*/
int    AscSaveMicroCode( ASC_DVC_VAR asc_ptr_type *, ASC_MC_SAVED dosfar * ) ;
int    AscRestoreOldMicroCode( ASC_DVC_VAR asc_ptr_type *, ASC_MC_SAVED dosfar * ) ;
int    AscRestoreNewMicroCode( ASC_DVC_VAR asc_ptr_type *, ASC_MC_SAVED dosfar * ) ;

#endif /* __A_DDLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_cc.h ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_cc.h
**
** compiling code generation control file
**
** This is a MS-DOS template file
*/

#ifndef __A_CC_H_
#define __A_CC_H_

/*
** for debugging
** turn off for released code
*/
#ifdef  OS_MS_DOS

#define CC_INIT_INQ_DISPLAY     TRUE   /* init inquiry display target info */

#else

#define CC_INIT_INQ_DISPLAY     FALSE   /* init inquiry display target info */

#endif

#define CC_CLEAR_LRAM_SRB_PTR   FALSE  /* set srb pointer in local to zero when queue done */
#define CC_VERIFY_LRAM_COPY     FALSE  /* set to TRUE to enable local RAM copy checking capability */
                                       /* performing verification depend on asc_dvc->cntl ASC_CNTL_NO_VERIFY_COPY  bit set/clear */
#define CC_DEBUG_SG_LIST        FALSE  /* set to TRUE to debug sg list odd address problem */
#define CC_FAST_STRING_IO       FALSE  /* use intel string instruction */
                                       /* do not set TRUE, it's not working ! */

#define CC_WRITE_IO_COUNT       FALSE  /* added S47, write scsiq->req_count */


/*
** for fixing bugs
*/

#define CC_DISABLE_PCI_PARITY_INT TRUE /* set to 1 to disable PCI bus parity interrupt */
                                       /* this is necessary for PCI REV A chip ( device code 0x1100 ) */
/*
**
** following control depends on driver
**
*/
#define CC_LINK_BUSY_Q         FALSE  /* AscExeScsiQueue() no busy return status */

#define CC_TARGET_MODE         FALSE  /* enable target mode ( processor device ) */

#define CC_SCAM                TRUE   /* include SCAM code */


/* DATE: 11/28/95 */
#define CC_LITTLE_ENDIAN_HOST  TRUE   /* host is little-endian machine, Example: IBM PC with Intel CPUs */
                                      /* big-endian machine, example: Motorola CPUs */

#if CC_LITTLE_ENDIAN_HOST
#define CC_TEST_LRAM_ENDIAN     FALSE
#else
#define CC_TEST_LRAM_ENDIAN     TRUE
#endif

/* DATE: 11/28/95 */
#define CC_STRUCT_ALIGNED      FALSE  /* default is packing ( not aligned ) */
                                      /* word variable to word boundary address */
                                      /* dword variable to dword boundary address */

/* DATE: 11/28/95 */
#define CC_MEMORY_MAPPED_IO    FALSE  /* define TRUE in memory-mapped host */

#define CC_FIX_QUANTUM_XP34301_1071  TRUE

#define CC_INIT_SCSI_TARGET FALSE

#endif /* #ifndef __A_CC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\aspiq.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: aspiq.h
**
*/

#ifndef __ASPIQ_H_
#define __ASPIQ_H_

/* #define ASCQ_ASPI_COPY_WORDS  13  number of queue words to copy for ASPI */
/* #define ASC_TID_WITH_SCSIQ  0x80  the tid of queue is not a aspi done queue */

#define ASC_SG_LIST_PER_Q   7  /*  */

/*
** q_status
*/
#define QS_FREE        0x00 /* queue is free ( not used )      */
#define QS_READY       0x01 /* queue is ready to be executed   */
#define QS_DISC1       0x02 /* queue is disconnected no tagged queuing */
#define QS_DISC2       0x04 /* queue is disconnected tagged queuing */
#define QS_BUSY        0x08 /* queue is waiting to be executed        */
/* #define QS_ACTIVE      0x08  queue is being executed                */
/* #define QS_DATA_XFER   0x10  queue is doing data transfer           */
#define QS_ABORTED     0x40    /* queue is aborted by host               */
#define QS_DONE        0x80    /* queue is done ( execution completed )  */

/*
** q_cntl
*/
/* conform with ASPI SCSI request flags */
/* #define QC_POST          0x01 */ /* posting fuction need to be called */
/* #define QC_LINK          0x02 */ /* link command */
#define QC_NO_CALLBACK   0x01 /* the queue should not call OS callback in ISR */
                              /* currently use the queue to send out message only */
#define QC_SG_SWAP_QUEUE 0x02 /* more sg list queue in host memory */
#define QC_SG_HEAD       0x04 /* is a sg list head                                 */
#define QC_DATA_IN       0x08 /* check data in transfer byte count match           */
#define QC_DATA_OUT      0x10 /* check data out transfer byte count match          */
/* #define QC_MSG_IN        0x20 */ /* message in from target                        */
#define QC_URGENT        0x20 /* high priority queue, must be executed first */
#define QC_MSG_OUT       0x40 /* send message out to target                        */
#define QC_REQ_SENSE     0x80 /* check condition, automatically do request sense   */
    /* if no data transfer if both data_in and data_out set */
/* #define   QC_DO_TAG_MSG            0x10  set by host */

/*
** following control bit is used on sg list queue only
** doesn't used on sg list queue head
*/
#define QCSG_SG_XFER_LIST  0x02 /* is a sg list queue                      */
#define QCSG_SG_XFER_MORE  0x04 /* there are more sg list in host memory   */
#define QCSG_SG_XFER_END   0x08 /* is end of sg list queue                 */

/*
** completion status, q[ done_stat ]
*/
#define QD_IN_PROGRESS       0x00 /* SCSI request in progress             */
#define QD_NO_ERROR          0x01 /* SCSI request completed without error */
#define QD_ABORTED_BY_HOST   0x02 /* SCSI request aborted by host         */
#define QD_WITH_ERROR        0x04 /* SCSI request completed with error    */
#define QD_INVALID_REQUEST   0x80 /* invalid SCSI request                 */
#define QD_INVALID_HOST_NUM  0x81 /* invalid HOST Aadpter Number          */
#define QD_INVALID_DEVICE    0x82 /* SCSI device not installed            */
#define QD_ERR_INTERNAL      0xFF /* internal error                       */

/*
** host adaptor status
** a fatal error will turn the bit 7 on ( 0x80 )
*/

/*
** ASPI DEFINED error codes
*/
#define QHSTA_NO_ERROR               0x00 /*                              */
#define QHSTA_M_SEL_TIMEOUT          0x11 /* selection time out           */
#define QHSTA_M_DATA_OVER_RUN        0x12 /* data over run                */
#define QHSTA_M_DATA_UNDER_RUN       0x12 /* data under run               */
#define QHSTA_M_UNEXPECTED_BUS_FREE  0x13 /* unexpected bus free          */
#define QHSTA_M_BAD_BUS_PHASE_SEQ    0x14 /* bus phase sequence failure   */

/*
** reported by device driver
*/
#define QHSTA_D_QDONE_SG_LIST_CORRUPTED 0x21 /*                                      */
#define QHSTA_D_ASC_DVC_ERROR_CODE_SET  0x22 /* host adapter internal error          */
#define QHSTA_D_HOST_ABORT_FAILED       0x23 /* abort scsi q failed                  */
#define QHSTA_D_EXE_SCSI_Q_FAILED       0x24 /* call AscExeScsiQueue() failed        */
#define QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT 0x25 /* AscExeScsiQueue() busy time out      */
/* #define QHSTA_D_ASPI_RE_ENTERED      0x26  ASPI EXE SCSI IO is being re entered */
#define QHSTA_D_ASPI_NO_BUF_POOL        0x26 /* ASPI out of buffer pool              */

/*
** reported by micro code to device driver
*/
#define QHSTA_M_WTM_TIMEOUT         0x41 /* watch dog timer timeout  */
#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42 /* bad completion status in */
#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43 /* no sense buffer to get sense data */
#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44 /* automatic request sense failed  */
#define QHSTA_M_TARGET_STATUS_BUSY  0x45 /* device return status busy ( SS_TARGET_BUSY = 0x08 ), tagged queuing disabled */
#define QHSTA_M_BAD_TAG_CODE        0x46 /* bad tag code of tagged queueing device */
                                         /* a tagged queueing device should always have a correct tag code */
                                         /* either 0x20, 0x21, 0x22, please see "ascsidef.h" of M2_QTAG_xxx */
                                         /* it is dangeous to mix tagged and untagged cmd in a device */
#define QHSTA_M_BAD_QUEUE_FULL_OR_BUSY  0x47 /* bad queue full ( 0x28 ) or busy ( 0x08 ) return */
                                             /* there is actually no queued cmd inside */

#define QHSTA_M_HUNG_REQ_SCSI_BUS_RESET 0x48 /* require reset scsi bus to free from hung condition */

/*
** fatal error
*/
#define QHSTA_D_LRAM_CMP_ERROR        0x81 /* comparison of local ram copying failed */
#define QHSTA_M_MICRO_CODE_ERROR_HALT 0xA1 /* fatal error, micro code halt           */
                                           /*                                        */
/* #define QHSTA_BUSY_TIMEOUT         0x16    host adapter busy time out             */
/* #define QHSTA_HOST_ABORT_TIMEOUT   0x21    abort scsi q timeout                   */
/* #define QHSTA_ERR_Q_CNTL           0x23    error queue control                    */
/* #define QHSTA_DRV_FATAL_ERROR      0x82    host driver fatal                      */
                                           /* asc_dvc->err_code not equal zero       */

/*
**
*/
/* #define SG_LIST_BEG_INDEX    0x08 */
/* #define SG_ENTRY_PER_Q       15    maximum size of CDB in bytes */

/*
** ASC_SCSIQ_2
** flag defintion
*/
#define ASC_FLAG_SCSIQ_REQ        0x01
#define ASC_FLAG_BIOS_SCSIQ_REQ   0x02
#define ASC_FLAG_BIOS_ASYNC_IO    0x04
#define ASC_FLAG_SRB_LINEAR_ADDR  0x08

#define ASC_FLAG_WIN16            0x10
#define ASC_FLAG_WIN32            0x20
#define ASC_FLAG_ISA_OVER_16MB    0x40
#define ASC_FLAG_DOS_VM_CALLBACK  0x80
/* #define ASC_FLAG_ASPI_SRB     0x01  */
/* #define ASC_FLAG_DATA_LOCKED  0x02  */
/* #define ASC_FLAG_SENSE_LOCKED 0x04  */

/*
** tag_code is normally 0x20
*/
/* #define ASC_TAG_FLAG_ADD_ONE_BYTE     0x10 */ /* for PCI fix, we add one byte to data transfer */
/* #define ASC_TAG_FLAG_ISAPNP_ADD_BYTES 0x40 */ /* for ISAPNP (ver 0x21 ) fix, we add three byte to data transfer */
#define ASC_TAG_FLAG_EXTRA_BYTES               0x10
#define ASC_TAG_FLAG_DISABLE_DISCONNECT        0x04
#define ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX  0x08
#define ASC_TAG_FLAG_DISABLE_CHK_COND_INT_HOST 0x40

/*
**
*/
#define ASC_SCSIQ_CPY_BEG              4
#define ASC_SCSIQ_SGHD_CPY_BEG         2

#define ASC_SCSIQ_B_FWD                0
#define ASC_SCSIQ_B_BWD                1

#define ASC_SCSIQ_B_STATUS             2
#define ASC_SCSIQ_B_QNO                3

#define ASC_SCSIQ_B_CNTL               4
#define ASC_SCSIQ_B_SG_QUEUE_CNT       5
/*
**
*/
#define ASC_SCSIQ_D_DATA_ADDR          8
#define ASC_SCSIQ_D_DATA_CNT          12
#define ASC_SCSIQ_B_SENSE_LEN         20 /* sense data length */
#define ASC_SCSIQ_DONE_INFO_BEG       22
#define ASC_SCSIQ_D_SRBPTR            22
#define ASC_SCSIQ_B_TARGET_IX         26
#define ASC_SCSIQ_B_CDB_LEN           28
#define ASC_SCSIQ_B_TAG_CODE          29
#define ASC_SCSIQ_W_VM_ID             30
#define ASC_SCSIQ_DONE_STATUS         32
#define ASC_SCSIQ_HOST_STATUS         33
#define ASC_SCSIQ_SCSI_STATUS         34
#define ASC_SCSIQ_CDB_BEG             36
#define ASC_SCSIQ_DW_REMAIN_XFER_ADDR 56
#define ASC_SCSIQ_DW_REMAIN_XFER_CNT  60
#define ASC_SCSIQ_B_SG_WK_QP          49
#define ASC_SCSIQ_B_SG_WK_IX          50
#define ASC_SCSIQ_W_REQ_COUNT         52 /* command execution sequence number */
#define ASC_SCSIQ_B_LIST_CNT          6
#define ASC_SCSIQ_B_CUR_LIST_CNT      7

/*
** local address of SG_LIST_Q field
*/
#define ASC_SGQ_B_SG_CNTL             4
#define ASC_SGQ_B_SG_HEAD_QP          5
#define ASC_SGQ_B_SG_LIST_CNT         6
#define ASC_SGQ_B_SG_CUR_LIST_CNT     7
#define ASC_SGQ_LIST_BEG              8

/*
**
*/
#define ASC_DEF_SCSI1_QNG    4
#define ASC_MAX_SCSI1_QNG    4 /* queued commands for non-tagged queuing device */
#define ASC_DEF_SCSI2_QNG    16
#define ASC_MAX_SCSI2_QNG    32

#define ASC_TAG_CODE_MASK    0x23

/*
** stop code definition
*/
#define ASC_STOP_REQ_RISC_STOP      0x01 /* Host set this value to stop RISC  */
                                         /* in fact any value other than zero */
                                         /* will stop the RISC                */
#define ASC_STOP_ACK_RISC_STOP      0x03 /* RISC set this value to confirm    */
                                         /* it has stopped                    */
#define ASC_STOP_CLEAN_UP_BUSY_Q    0x10 /* host request risc clean up busy q */
#define ASC_STOP_CLEAN_UP_DISC_Q    0x20 /* host request risc clean up disc q */
#define ASC_STOP_HOST_REQ_RISC_HALT 0x40 /* host request risc halt, no interrupt generated */
/* #define ASC_STOP_SEND_INT_TO_HOST   0x80 */ /* host request risc generate an interrupt */

/* from tid and lun to taregt_ix */
#define ASC_TIDLUN_TO_IX( tid, lun )  ( ASC_SCSI_TIX_TYPE )( (tid) + ((lun)<<ASC_SCSI_ID_BITS) )
/* from tid to target_id */
#define ASC_TID_TO_TARGET_ID( tid )   ( ASC_SCSI_BIT_ID_TYPE )( 0x01 << (tid) )
#define ASC_TIX_TO_TARGET_ID( tix )   ( 0x01 << ( (tix) & ASC_MAX_TID ) )
#define ASC_TIX_TO_TID( tix )         ( (tix) & ASC_MAX_TID )
#define ASC_TID_TO_TIX( tid )         ( (tid) & ASC_MAX_TID )
#define ASC_TIX_TO_LUN( tix )         ( ( (tix) >> ASC_SCSI_ID_BITS ) & ASC_MAX_LUN )

#define ASC_QNO_TO_QADDR( q_no )      ( (ASC_QADR_BEG)+( ( int )(q_no) << 6 ) )

#pragma pack(1)
typedef struct asc_scisq_1 {
  uchar  status ;        /* 2  q current execution status               */
  uchar  q_no ;          /* 3                                           */
  uchar  cntl ;          /* 4  queue control byte                       */
  uchar  sg_queue_cnt ;  /* 5  number of sg_list queue(s), from 1 to n  */
                         /*    equal zero if is not a sg list queue     */
  uchar  target_id ;     /* 6  Target SCSI ID                           */
  uchar  target_lun ;    /* 7  Target SCSI logical unit number          */
                         /*                                             */
  ulong  data_addr ;     /* 8 -11 dma transfer physical address         */
  ulong  data_cnt ;      /* 12-15 dma transfer byte count               */
  ulong  sense_addr ;    /* 16-19 request sense message buffer          */
  uchar  sense_len ;     /* 20 SCSI request sense data length           */
/* uchar user_def ;  */
  uchar  extra_bytes ;   /* 21 number of extra bytes to send ( for bug fix ) */
                         /*    from cutting last transfer length to dword boundary */
} ASC_SCSIQ_1 ;

typedef struct asc_scisq_2 {
  ulong  srb_ptr ;     /* 22-25 the SCSI SRB from device driver         */
  uchar  target_ix ;   /* 26 target index ( 0 to 63 )                   */
                       /*    calculated by host                         */
  uchar  flag ;        /* 27 left to user implemenation                 */
  uchar  cdb_len ;     /* 28 SCSI command length                        */
  uchar  tag_code ;    /* 29 first byte of tagged queuing messasge      */
                       /*    either 0x20, 0x21, 0x22                    */
  ushort vm_id ;       /* 30-31 Virtual machine ID for DOS and Windows  */
} ASC_SCSIQ_2 ;

typedef struct asc_scsiq_3 {
  uchar  done_stat ;   /* 32 queue completion status        */
  uchar  host_stat ;   /* 33 host adapter error status      */
  uchar  scsi_stat ;   /* 34 SCSI command completion status */
  uchar  scsi_msg ;    /* 35 SCSI command done message      */
} ASC_SCSIQ_3 ;

typedef struct asc_scsiq_4 {
  uchar  cdb[ ASC_MAX_CDB_LEN ] ; /* 36-47 SCSI CDB block, 12 bytes maximum */
  uchar  y_first_sg_list_qp ;     /* 48 B                                   */
  uchar  y_working_sg_qp ;        /* 49 B                                   */
  uchar  y_working_sg_ix ;        /* 50 B                                   */
  uchar  y_res ;                  /* 51 B                                   */
  ushort x_req_count ;            /* 52 W                                   */
  ushort x_reconnect_rtn ;        /* 54 W                                   */
  ulong  x_saved_data_addr ;      /* 56 DW next data transfer address       */
  ulong  x_saved_data_cnt ;       /* 60 DW remaining data transfer count    */
} ASC_SCSIQ_4 ;

typedef struct asc_q_done_info {
  ASC_SCSIQ_2  d2 ;      /*                                 */
  ASC_SCSIQ_3  d3 ;      /*                                 */
  uchar  q_status ;      /* queue status                    */
  uchar  q_no ;          /* queue number                    */
  uchar  cntl ;          /* queue control byte */
  uchar  sense_len ;     /* sense buffer length */
  uchar  extra_bytes ;   /* use  */
  uchar  res ;           /* reserved, for alignment */
  ulong  remain_bytes ;  /* data transfer remaining bytes   */
} ASC_QDONE_INFO ;       /* total 16 bytes                  */
#pragma pack()

/*
** SCSI SG LIST
*/
typedef struct asc_sg_list {
  ulong   addr ;  /* far pointer to physical address */
  ulong   bytes ; /* number of bytes for the entry   */
} ASC_SG_LIST ;

/*
** SCSI SG LIST QUEUE HEAD
*/
typedef struct asc_sg_head {
  ushort entry_cnt ;       /* number of sg entry ( list )                    */
                           /* entered by driver                              */
                           /* when passed to DvcGetSGList() it holds number  */
                           /* of available entry                             */
                           /* when returned DvcGetSGList() return number of  */
                           /* filled entry                                   */
  ushort queue_cnt ;       /* total number of queues not including sg head   */
                           /* from 1 to n                                    */
                           /* entered by library function call               */
  ushort entry_to_copy ;
  ushort res ;
  ASC_SG_LIST sg_list[ ASC_MAX_SG_LIST ] ; /* sg list array */
} ASC_SG_HEAD ;

/*
**
*/
#define ASC_MIN_SG_LIST   2

typedef struct asc_min_sg_head {
  ushort entry_cnt ;         /* number of sg entry ( list )                                */
                             /* when passed to DvcGetSGList() it holds number              */
                             /* of available entry                                         */
                             /* when returned DvcGetSGList() return number of filled entry */
  ushort queue_cnt ;         /* total number of queues not including sg head               */
                             /* from 1 to n                                                */
  ushort entry_to_copy ;     /* should equal entry_cnt when done */
  ushort res ;
  ASC_SG_LIST sg_list[ ASC_MIN_SG_LIST ] ; /* sg list array                                              */
} ASC_MIN_SG_HEAD ;

/*
**
** extended queue control word
**
*/
#define QCX_SORT        (0x0001)  /* insert queue in order */
#define QCX_COALEASE    (0x0002)  /* coalease queue into single command */
                                  /* if possible */
                                  /* in order to provide coalease */
                                  /* "sg_head" must point to a SG LIST buffer */
                                  /* with number of entry available at entry_cnt */

#if CC_LINK_BUSY_Q
typedef struct asc_ext_scsi_q {
  ulong  lba ;                     /* logical block address of i/o */
  ushort lba_len ;                 /* logical block length in sector */
  struct asc_scsi_q dosfar *next ; /* NULL if no more queue */
  struct asc_scsi_q dosfar *join ; /* NULL if not coaleased */
  ushort cntl ;                    /* control word */
  ushort buffer_id ;               /* used for allocation/deallocation */
  uchar  q_required ;              /* number of queues required */
  uchar  res ;
} ASC_EXT_SCSI_Q ;
#endif /* CC_LINK_BUSY_Q */

/*
** ========================================================
** the asc-1000 queue struct on host side for device driver
**
** ======================================================
*/
typedef struct asc_scsi_q {
  ASC_SCSIQ_1  q1 ;
  ASC_SCSIQ_2  q2 ;
  uchar dosfar *cdbptr ;         /* pointer to SCSI CDB block         */
                                 /* CDB length is in q2.cdb_len       */
  ASC_SG_HEAD dosfar *sg_head ;  /* pointer to sg list                */
                                 /* if you have sg list you must set  */
                                 /* QC_SG_HEAD bit of q1.cntl         */
#if CC_LINK_BUSY_Q
  ASC_EXT_SCSI_Q  ext ;
#endif /* CC_LINK_BUSY_Q */

#if CC_ASC_SCSI_Q_USRDEF
  ASC_SCSI_Q_USR  usr ;
#endif

} ASC_SCSI_Q ;

/*
** ----------------------------------------------------------------------
** NOTE:
** 1. the first four fields of ASC_SCSI_REQ_Q must be the same as ASC_SCSI_Q
** -------------------------------------------------------------------
*/
typedef struct asc_scsi_req_q {
  ASC_SCSIQ_1  r1 ;
  ASC_SCSIQ_2  r2 ;
  uchar dosfar *cdbptr ;         /* pointer to SCSI CDB block, 12 bytes maximum */
  ASC_SG_HEAD dosfar *sg_head ;  /* pointer to sg list */

#if CC_LINK_BUSY_Q
  ASC_EXT_SCSI_Q  ext ;
#endif /* CC_LINK_BUSY_Q */
/*
** we must maintain the struct the same as ASC_SCSI_Q before here
*/
  uchar dosfar *sense_ptr ;  /* the pointer to sense buffer address      */
                             /* this is useful when sense buffer is not  */
                             /* in the sense[ ] array                    */
                             /*                                          */
  ASC_SCSIQ_3  r3 ;
  uchar  cdb[ ASC_MAX_CDB_LEN ] ;
  uchar  sense[ ASC_MIN_SENSE_LEN ] ;

#if CC_ASC_SCSI_REQ_Q_USRDEF
  ASC_SCSI_REQ_Q_USR  usr ;
#endif

} ASC_SCSI_REQ_Q ;

typedef struct asc_scsi_bios_req_q {
  ASC_SCSIQ_1  r1 ;
  ASC_SCSIQ_2  r2 ;
  uchar dosfar *cdbptr ;         /* pointer to SCSI CDB block, 12 bytes maximum */
  ASC_SG_HEAD dosfar *sg_head ;  /* pointer to sg list */

/*
** we must maintain the struct the same as ASC_SCSI_Q before here
*/
  uchar dosfar *sense_ptr ;  /* the pointer to sense buffer address      */
                             /* this is useful when sense buffer is not  */
                             /* in the sense[ ] array                    */
                             /*                                          */
  ASC_SCSIQ_3  r3 ;
  uchar  cdb[ ASC_MAX_CDB_LEN ] ;
  uchar  sense[ ASC_MIN_SENSE_LEN ] ;
} ASC_SCSI_BIOS_REQ_Q ;

/*
**
*/
typedef struct asc_risc_q {
  uchar  fwd ;
  uchar  bwd ;
  ASC_SCSIQ_1  i1 ;
  ASC_SCSIQ_2  i2 ;
  ASC_SCSIQ_3  i3 ;
  ASC_SCSIQ_4  i4 ;
} ASC_RISC_Q ;

/*
** sg list queue, exclude the fwd and bwd links
** should not exceed 6 bytes !
*/
typedef struct asc_sg_list_q {
/*  uchar fwd ;                   0  forward pointer, does not exist on host side   */
/*  uchar bwd ;                   1  backward pointer, does not exist on host side  */
  uchar  seq_no ;              /* 2  will be set to zero when the queue is done     */
  uchar  q_no ;                /* 3  queue number                                   */
  uchar  cntl ;                /* 4  queue control byte                             */
  uchar  sg_head_qp ;          /* 5  queue number of sg head queue                  */
  uchar  sg_list_cnt ;         /* 6  number of sg list entries in this queue        */
  uchar  sg_cur_list_cnt ;     /* 7  initially same as sg list_cnt */
                               /* 7  will reach zero when list done */
} ASC_SG_LIST_Q ;

typedef struct asc_risc_sg_list_q {
  uchar  fwd ;                 /* 0  forward pointer, does not exist on host side  */
  uchar  bwd ;                 /* 1  backward pointer, does not exist on host side */
  ASC_SG_LIST_Q  sg ;          /*                                                  */
  ASC_SG_LIST sg_list[ 7 ] ;   /* 8-63 the sg list of address and bytes            */
} ASC_RISC_SG_LIST_Q ;

#endif /* #ifndef _ASPIQ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_init3.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_init3.c
**
** non PCI init modules
**
*/

#include "ascinc.h"

#if !CC_PCI_ADAPTER_ONLY

/* -----------------------------------------------------------------
**
** -------------------------------------------------------------- */
void   AscSetISAPNPWaitForKey( void )
{
/*
**  write 0x02 to address 0x02
*/
       outp( ASC_ISA_PNP_PORT_ADDR, 0x02 ) ;
       outp( ASC_ISA_PNP_PORT_WRITE, 0x02 ) ;
       return ;
}

/* ----------------------------------------------------------------------
**
** returns:
** 0 :   no irq
** 10 - xx : either 10, 11, 12, 14, 15
**
** ------------------------------------------------------------------- */
uchar  AscGetChipIRQ(
          PortAddr iop_base,
          ushort bus_type
       )
{
       ushort  cfg_lsw ;
       uchar   chip_irq ;

/*
** else VL, ISA, PCI
*/
#if CC_INCLUDE_VL
       if( ( bus_type & ASC_IS_VL ) != 0 )
       {
/*
** VL VERSION
*/
           cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
           chip_irq = ( uchar )( ( ( cfg_lsw >> 2 ) & 0x07 ) ) ;
           if( ( chip_irq == 0 ) ||
               ( chip_irq == 4 ) ||
               ( chip_irq == 7 ) )
           {
               return( 0 ) ;
           }/* if */
#if CC_PLEXTOR_VL
/*
**
** special plextor version VL adapter
** IRQ 14 is routed to IRQ 9
**
*/
           if( chip_irq == 5 )
           {
               return( 9 ) ;
           }
#endif /* CC_PLEXTOR_VL */
           return( ( uchar )( chip_irq + ( ASC_MIN_IRQ_NO - 1 ) ) ) ;
       }/* if VL */
#endif /* CC_INCLUDE_VL */
/*
** ISA VERSION
** PCI VERSION
*/
       cfg_lsw = AscGetChipCfgLsw( iop_base ) ;
       chip_irq = ( uchar )( ( ( cfg_lsw >> 2 ) & 0x03 ) ) ;
       if( chip_irq == 3 ) chip_irq += ( uchar )2 ;
       return( ( uchar )( chip_irq + ASC_MIN_IRQ_NO ) ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscToggleIRQAct(
          PortAddr iop_base
       )
{
       AscSetChipStatus( iop_base, CIW_IRQ_ACT ) ;
       AscSetChipStatus( iop_base, 0 ) ;
       return ;
}

/* ----------------------------------------------------------------------
** input:
** IRQ should be : 0, 10 - 15
** use IRQ = 0 to disable it
**
** returns:
** same as AscGetChipIRQ
**
** Note:
**  1. you should also change the EEPROM IRQ setting after this
**  2. this should be done only during chip initialization
**
** ------------------------------------------------------------------- */
uchar  AscSetChipIRQ(
          PortAddr iop_base,
          uchar irq_no,
          ushort bus_type
       )
{
       ushort  cfg_lsw ;

#if CC_INCLUDE_VL
       if( ( bus_type & ASC_IS_VL ) != 0 )
       {
/*
** VL VERSION
*/
           if( irq_no != 0 )
           {
#if CC_PLEXTOR_VL
               if( irq_no == 9 )
               {
                   irq_no = 14 ;
               }
#endif /* CC_PLEXTOR_VL */
               if( ( irq_no < ASC_MIN_IRQ_NO ) || ( irq_no > ASC_MAX_IRQ_NO ) )
               {
                   irq_no = 0 ;
               }/* if */
               else
               {
                   irq_no -= ( uchar )( ( ASC_MIN_IRQ_NO - 1 ) ) ;
               }/* else */
           }/* if */
/*
** first reset IRQ
*/
           cfg_lsw = ( ushort )( AscGetChipCfgLsw( iop_base ) & 0xFFE3 ) ;
           cfg_lsw |= ( ushort )0x0010 ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           AscToggleIRQAct( iop_base ) ;
/*
** set new IRQ
*/
           cfg_lsw = ( ushort )( AscGetChipCfgLsw( iop_base ) & 0xFFE0 ) ;
           cfg_lsw |= ( ushort )( ( irq_no & 0x07 ) << 2 ) ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           AscToggleIRQAct( iop_base ) ;
/*
** now we must toggle write IRQ bit
*/
           return( AscGetChipIRQ( iop_base, bus_type ) ) ;

      }/* if VL */

#endif /* CC_INCLUDE_VL */

      if( ( bus_type & ( ASC_IS_ISA ) ) != 0 )
      {
/*
** ISA VERSION
*/
           if( irq_no == 15 ) irq_no -= ( uchar )2 ;
           irq_no -= ( uchar )ASC_MIN_IRQ_NO ;
           cfg_lsw = ( ushort )( AscGetChipCfgLsw( iop_base ) & 0xFFF3 ) ;
           cfg_lsw |= ( ushort )( ( irq_no & 0x03 ) << 2 ) ;
           AscSetChipCfgLsw( iop_base, cfg_lsw ) ;
           return( AscGetChipIRQ( iop_base, bus_type ) ) ;
      }/* else if ISA */
/*
** PCI, EISA VERSION
*/
      return( 0 ) ;
}

/* --------------------------------------------------------------
** enable ISA DMA channel 0-7
**
**
** ----------------------------------------------------------- */
void   AscEnableIsaDma(
          uchar dma_channel
       )
{
       if( dma_channel < 4 )
       {
           outp( 0x000B, ( ushort )( 0xC0 | dma_channel ) ) ;
           outp( 0x000A, dma_channel ) ;
       }/* if */
       else if( dma_channel < 8 )
       {
/*
** 0xC0 set CASCADE MODE
*/
           outp( 0x00D6, ( ushort )( 0xC0 | ( dma_channel - 4 ) ) ) ;
           outp( 0x00D4, ( ushort )( dma_channel - 4 ) ) ;
       }/* else */
       return ;
}

/* --------------------------------------------------------------
**
** ----------------------------------------------------------- */
void   AscDisableIsaDma(
          uchar dma_channel
       )
{
       if( dma_channel < 4 )
       {
           outp( 0x000A, ( ushort )( 0x04 | dma_channel ) ) ;
       }/* if */
       else if( dma_channel < 8 )
       {
           outp( 0x00D4, ( ushort )( 0x04 | ( dma_channel - 4 ) ) ) ;
       }/* else */
       return ;
}

#endif /* !CC_PCI_ADAPTER_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_osdep.h ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_osdep.h
**
*/

#ifndef __A_OSDEP_H_
#define __A_OSDEP_H_

#include "a_winnt.h"
#include "miniport.h"
#include "scsi.h"

#endif /* #ifndef __A_OSDEP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_mcode3.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_mcode3.c
**
*/

#include "ascinc.h"
#include "a_uc.h"

#if CC_CHECK_MCODE_SIZE_AT_COMPILE

#if sizeof( _mcode_buf ) > 0x900

/* #error micro code size too big ! */

yes, I intentionally made a syntax error here !

#endif /* if uc size too big */

#endif /* CC_CHECK_MCODE_SIZE_AT_COMPILE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_osdef.h ===
//
// a_osdef.h
//

//
// if your compiler does not support a command line constant definition
// you may put your platform definition here
//

#ifndef OS_WINNT
#define OS_WINNT
#endif  // OS_WINNT

//#define ASC_CHIP_VERSION 17

#ifndef __A_OSDEF_H_
#define __A_OSDEF_H_


#endif // __A_OSDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_irq.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: A_IRQ.H
**
*/

#ifndef  __A_IRQ_H
#define  __A_IRQ_H

/* ----------------------------------------------------------------- */
#define IRQ0_VECT   0x08 /* Timer tick, 18.2 times per second            */
#define IRQ1_VECT   0x09 /* keyboard service request                     */
#define IRQ2_VECT   0x0A /* INT form slave 8259A:                        */
#define IRQ3_VECT   0x0B /* COM2, COM4, network adapter, CD-ROM adapter, */
                         /* and sound board                              */
#define IRQ4_VECT   0x0C /* COM1 and COM3                                */
#define IRQ5_VECT   0x0D /* LPT2 parallel port                           */
#define IRQ6_VECT   0x0E /* floppy disk controller                       */
#define IRQ7_VECT   0x0F /* LPT1, but rarely used                        */

#define IRQ8_VECT   0x70 /*     real time clock service                  */
#define IRQ9_VECT   0x71 /*     software redirected to IRQ 2             */
#define IRQ10_VECT  0x72 /*     reserved                                 */
#define IRQ11_VECT  0x73 /*     reserved                                 */
#define IRQ12_VECT  0x74 /*     reserved                                 */
#define IRQ13_VECT  0x75 /*     numeric( math ) coprocessor              */
#define IRQ14_VECT  0x76 /*     fixed disk controller                    */
#define IRQ15_VECT  0x77 /*     reserved                                 */

/*
** progamable interrupt controller (PIC) 8259A
*/
#define PIC1_OCR  0x20 /* location of first 8259A operational control register   */
#define PIC1_IMR  0x21 /* location of first 8259A interrupt mask register        */
#define PIC2_OCR  0xA0 /* location of second 8259A operational control register  */
#define PIC2_IMR  0xA1 /* location of second 8259A interrupt mask register       */

#define NONSPEC_EOI 0x20  /* Non-specific EOI     */
#define SPEC_EOI7   0x67  /* specific EOI for int level 7 */

#define REARM3   0x2F3 /* global REARM location for interrupt level 3   */
#define REARM4   0x2F4 /* global REARM location for interrupt level 4   */
#define REARM5   0x2F5 /* global REARM location for interrupt level 5   */
#define REARM6   0x2F6 /* global REARM location for interrupt level 6   */
#define REARM7   0x2F7 /* global REARM location for interrupt level 7   */
#define REARM9   0x2F2 /* global REARM location for interrupt level 9   */
#define REARM10  0x6F2 /* global REARM location for interrupt level 10  */
#define REARM11  0x6F3 /* global REARM location for interrupt level 11  */
#define REARM12  0x6F4 /* global REARM location for interrupt level 12  */
#define REARM13  0x6F5 /* global REARM location for interrupt level 13  */
#define REARM14  0x6F6 /* global REARM location for interrupt level 14  */
#define REARM15  0x6F7 /* global REARM location for interrupt level 15  */

#endif /* __A_IRQ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_isr.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_isr.c
**
*/

#include "ascinc.h"

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
int    AscIsrChipHalted(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       EXT_MSG  ext_msg ;
       EXT_MSG  out_msg ;
       ushort  halt_q_addr ;
       int     sdtr_accept ;
       ushort  int_halt_code ;
       ASC_SCSI_BIT_ID_TYPE scsi_busy ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       PortAddr iop_base ;
       uchar   tag_code ;
       uchar   q_status ;
       uchar   halt_qp ;
       uchar   sdtr_data ;
       uchar   target_ix ;
       uchar   q_cntl, tid_no ;
       uchar   cur_dvc_qng ;
       uchar   asyn_sdtr ;
       uchar   scsi_status ;

       iop_base = asc_dvc->iop_base ;
       int_halt_code = AscReadLramWord( iop_base, ASCV_HALTCODE_W ) ;
       /* _err_halt_code = int_halt_code ; */
       halt_qp = AscReadLramByte( iop_base, ASCV_CURCDB_B ) ;
       halt_q_addr = ASC_QNO_TO_QADDR( halt_qp ) ;
       target_ix = AscReadLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_TARGET_IX ) ) ;
       q_cntl = AscReadLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ) ) ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       target_id = ( uchar )ASC_TID_TO_TARGET_ID( tid_no ) ;
       if( asc_dvc->pci_fix_asyn_xfer & target_id )
       {
/*
** PCI REV A/B BUG FIX, Let ASYN as SYN 5MB( speed index 4 ) and offset 1
*/
           asyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB ;
       }/* if */
       else
       {
           asyn_sdtr = 0 ;
       }/* else */
       if( int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX )
       {
           if( asc_dvc->pci_fix_asyn_xfer & target_id )
           {
               AscSetChipSDTR( iop_base, 0, tid_no ) ;
           }
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }
       else if( int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX )
       {
           if( asc_dvc->pci_fix_asyn_xfer & target_id )
           {
               AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
           }
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }
       else if( int_halt_code == ASC_HALT_EXTMSG_IN )
       {
/* ------------------------------------------------------------ */
           /*
           ** Copy the message saved by the microcode at ASCV_MSGIN_BEG
           ** to the local variable ext_msg.
           */
           AscMemWordCopyFromLram( iop_base,
                                   ASCV_MSGIN_BEG,
                                   ( ushort dosfar *)&ext_msg,
                                   ( ushort )( sizeof( EXT_MSG ) >> 1 ) ) ;

           if (ext_msg.msg_type == MS_EXTEND &&
               ext_msg.msg_req == MS_SDTR_CODE &&
               ext_msg.msg_len == MS_SDTR_LEN) {
               sdtr_accept = TRUE ;
               if(
                   ( ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET )
                 )
               {
                   /*
                   **
                   ** we set the offset to less than 0x0F
                   ** and re do sdtr
                   **
                   ** if speed is faster than we can handle
                   ** we need to re do sdtr also
                   **
                   **
                   */
                   sdtr_accept = FALSE ;
                   ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET ;
               }/* if */
               if(
                   ( ext_msg.xfer_period < asc_dvc->sdtr_period_tbl[ asc_dvc->host_init_sdtr_index ] )
                   || ( ext_msg.xfer_period > asc_dvc->sdtr_period_tbl[ asc_dvc->max_sdtr_index ] )
                 )
               {
                   sdtr_accept = FALSE ;
                   ext_msg.xfer_period = asc_dvc->sdtr_period_tbl[ asc_dvc->host_init_sdtr_index ] ;
               }
               if( sdtr_accept )
               {
                   sdtr_data = AscCalSDTRData( asc_dvc, ext_msg.xfer_period,
                                               ext_msg.req_ack_offset ) ;
                   if( ( sdtr_data == 0xFF ) )
                   {
/*
** we should reject the SDTR, because our chip cannot support it
** the period value is out of our range
*/
                       q_cntl |= QC_MSG_OUT ;
                       asc_dvc->init_sdtr &= ~target_id ;
                       asc_dvc->sdtr_done &= ~target_id ;
                       AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
                   }/* if */
               }
               if( ext_msg.req_ack_offset == 0 )
               {
                   /*
                   ** an offset zero is the same as async transfer
                   */
                   q_cntl &= ~QC_MSG_OUT ;
                   asc_dvc->init_sdtr &= ~target_id ;
                   asc_dvc->sdtr_done &= ~target_id ;
                   AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
               }/* if */
               else
               {
                   if(
                       sdtr_accept
                       && ( q_cntl & QC_MSG_OUT )
                     )
                   {
/*
** we agreed and will not send message out again
**
**
** turn off ISAPNP( chip ver 0x21 ) fix if use sync xfer
*/
                       q_cntl &= ~QC_MSG_OUT ;
                       asc_dvc->sdtr_done |= target_id ;
                       asc_dvc->init_sdtr |= target_id ;
                       asc_dvc->pci_fix_asyn_xfer &= ~target_id ;
                       sdtr_data = AscCalSDTRData( asc_dvc, ext_msg.xfer_period,
                                                   ext_msg.req_ack_offset ) ;
                       AscSetChipSDTR( iop_base, sdtr_data, tid_no ) ;
                   }/* if */
                   else
                   {
/*
** DATE: 12/7/94
** if SDTR is target inited
** we must answer the target even if we agreed
** because according to SCSI specs.
** if we does not answer back right away
** the SDTR will take effect after bus free which is next command
** we want it take effect now
*/
                   /* ext_msg.req_ack_offset = ASC_SYN_MAX_OFFSET ; */
/*
** it is assumed that if target doesn't reject this message
** we will use the SDTR values we send
*/
              /*
              ** we assume drive will not send the message again
              ** so we set the chip's SDTR data here
              */
                       q_cntl |= QC_MSG_OUT ;
                       AscMsgOutSDTR( asc_dvc,
                                      ext_msg.xfer_period,
                                      ext_msg.req_ack_offset ) ;
                       asc_dvc->pci_fix_asyn_xfer &= ~target_id ;
                       sdtr_data = AscCalSDTRData( asc_dvc, ext_msg.xfer_period,
                                                   ext_msg.req_ack_offset ) ;
                       AscSetChipSDTR( iop_base, sdtr_data, tid_no ) ;
                       asc_dvc->sdtr_done |= target_id ;
                       asc_dvc->init_sdtr |= target_id ;
                   }/* else */
               }/* else */
               /*
               ** AscWriteLramByte( iop_base,
               **                   ASCV_SDTR_DONE_B,
               **                   asc_dvc->sdtr_done ) ;
               */
               AscWriteLramByte( iop_base,
                   ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                     q_cntl ) ;
               AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
               return( 0 ) ;
           } else if (ext_msg.msg_type == MS_EXTEND &&
                      ext_msg.msg_req == MS_WDTR_CODE &&
                      ext_msg.msg_len == MS_WDTR_LEN) {
               /*
               ** Respond to a WDTR message with a WDTR message that
               ** specifies narrow transfers.
               */
               ext_msg.wdtr_width = 0;
               AscMemWordCopyToLram(iop_base,
                                    ASCV_MSGOUT_BEG,
                                    ( ushort dosfar *)&ext_msg,
                                    ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
               q_cntl |= QC_MSG_OUT ;
               AscWriteLramByte( iop_base,
                   ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                     q_cntl ) ;
               AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
               return( 0 ) ;
           } else {
               /*
               ** Reject messages not handled.
               */
               ext_msg.msg_type = M1_MSG_REJECT;
               AscMemWordCopyToLram(iop_base,
                                    ASCV_MSGOUT_BEG,
                                    ( ushort dosfar *)&ext_msg,
                                    ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
               q_cntl |= QC_MSG_OUT ;
               AscWriteLramByte( iop_base,
                   ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                     q_cntl ) ;
               AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
               return( 0 ) ;
           }
       }/* if is extended message halt code */
       else if( int_halt_code == ASC_HALT_CHK_CONDITION )
       {

#if CC_CHK_COND_REDO_SDTR
           /*
            * XXX - should setting this flag really be within
            * CC_CHK_COND_REDO_SDTR?
            */
           q_cntl |= QC_REQ_SENSE ;

          /*
           * After a CHECK CONDITION if the 'init_stdr' bit is set,
           * redo SDTR. SDTR is redone regardless of 'sdtr_done'.
           */
           if ((asc_dvc->init_sdtr & target_id) != 0)
           {
              /*
               * get sync xfer data
               */
               asc_dvc->sdtr_done &= ~target_id ;
               sdtr_data = AscGetMCodeInitSDTRAtID( iop_base, tid_no ) ;
               q_cntl |= QC_MSG_OUT ;
               AscMsgOutSDTR( asc_dvc,
                              asc_dvc->sdtr_period_tbl[ ( sdtr_data >> 4 ) & ( uchar )(asc_dvc->max_sdtr_index-1) ],
                              ( uchar )( sdtr_data & ( uchar )ASC_SYN_MAX_OFFSET ) ) ;
           }/* if */
#endif /* CC_CHK_COND_REDO_SDTR */

           AscWriteLramByte( iop_base,
               ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                 q_cntl ) ;

/*
** clear bit 5
** DO NOT USE tagged queueing for request sense at all
** if there is no queued cmd in target
** Note: non-tagged queueing device this
**
*/
/*
**
** one HP fix disk apprantly get confused by same tag id again
** and return check cond when we send request sense again
** use the same queue ( and same tag id )
** it report a overlapped command error !
** although if we clear the tag_code field, the cmd
** will be sent using untagged method, but it's not allowed !
**
** we cannot mix a tagged and untagged cmd in a device !
**
*/
           tag_code = AscReadLramByte( iop_base,
               ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_TAG_CODE ) ) ;
           tag_code &= 0xDC ; /* clear bit 5 */
           if(
                ( asc_dvc->pci_fix_asyn_xfer & target_id )
                && !( asc_dvc->pci_fix_asyn_xfer_always & target_id )
             )
           {
/*
** disable use sync. offset one fix for auto request sense
**
*/
                tag_code |= ( ASC_TAG_FLAG_DISABLE_DISCONNECT
                            | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX );

           }
           AscWriteLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_TAG_CODE ),
                  tag_code ) ;
/*
**
** change queue status to QS_READY and QS_BUSY
** QS_BUSY will make sure the queue if busy again will link to head of queue in busy list
**
*/
           q_status = AscReadLramByte( iop_base,
                        ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_STATUS  ) ) ;
           q_status |= ( QS_READY | QS_BUSY ) ;
           AscWriteLramByte( iop_base,
                ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_STATUS  ),
                  q_status ) ;

           scsi_busy = AscReadLramByte( iop_base,
                                        ( ushort )ASCV_SCSIBUSY_B ) ;
           scsi_busy &= ~target_id ;
           AscWriteLramByte( iop_base, ( ushort )ASCV_SCSIBUSY_B, scsi_busy ) ;

           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }/* else if */
       else if( int_halt_code == ASC_HALT_SDTR_REJECTED )
       {
/* ------------------------------------------------------------ */
     /*
     ** first check what message it is rejecting
     **
     */
           AscMemWordCopyFromLram( iop_base,
                                   ASCV_MSGOUT_BEG,
                                   ( ushort dosfar *)&out_msg,
                                   ( ushort )( sizeof( EXT_MSG ) >> 1 ) ) ;

           if( ( out_msg.msg_type == MS_EXTEND ) &&
               ( out_msg.msg_len == MS_SDTR_LEN ) &&
               ( out_msg.msg_req == MS_SDTR_CODE ) )
           {
               /*
               ** we should handle target that rejects SDTR
               */
               asc_dvc->init_sdtr &= ~target_id ;
               asc_dvc->sdtr_done &= ~target_id ;
               AscSetChipSDTR( iop_base, asyn_sdtr, tid_no ) ;
               /*
               ** AscWriteLramByte( iop_base, ASCV_SDTR_DONE_B,
               **                   asc_dvc->sdtr_done ) ;
               */
           }/* if a SDTR rejected */
           else
           {
               /*
               ** probably following message rejected:
               ** 1. a bus device reset message
               **
               ** continue with the command
               */

           }/* else */

           q_cntl &= ~QC_MSG_OUT ;
           AscWriteLramByte( iop_base,
               ( ushort )( halt_q_addr+( ushort )ASC_SCSIQ_B_CNTL ),
                 q_cntl ) ;
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }/* else if */
       else if( int_halt_code == ASC_HALT_SS_QUEUE_FULL )
       {
/* ------------------------------------------------------------ */
/*
** either a queue full ( 0x28 ) or status busy ( 0x08 )
**
*/
           scsi_status = AscReadLramByte( iop_base,
                  ( ushort )( ( ushort )halt_q_addr+( ushort )ASC_SCSIQ_SCSI_STATUS ) ) ;
           cur_dvc_qng = AscReadLramByte( iop_base,
                  ( ushort )( ( ushort )ASC_QADR_BEG+( ushort )target_ix ) ) ;
           if( ( cur_dvc_qng > 0 ) &&
               ( asc_dvc->cur_dvc_qng[ tid_no ] > 0 ) )
           {
/*
** cur_dvc_qng is already decremented, so is the correct number of cmds
** in the target
**
** only set busy of tagged queueing device
** a non-tagged queueing device should not send intterrupt
** also a non-tagged queueing device cannot have cur_dvc_qng > 0
*/
              scsi_busy = AscReadLramByte( iop_base,
                                           ( ushort )ASCV_SCSIBUSY_B ) ;
              scsi_busy |= target_id ;
              AscWriteLramByte( iop_base,
                      ( ushort )ASCV_SCSIBUSY_B, scsi_busy ) ;
              asc_dvc->queue_full_or_busy |= target_id ;

              if( scsi_status == SS_QUEUE_FULL ) {
                  if( cur_dvc_qng > ASC_MIN_TAGGED_CMD )
                  {
                      cur_dvc_qng -= 1 ;
                      asc_dvc->max_dvc_qng[ tid_no ] = cur_dvc_qng ;
       /*
       ** write it down for reference only
       */
                      AscWriteLramByte( iop_base,
                         ( ushort )( ( ushort )ASCV_MAX_DVC_QNG_BEG+( ushort )tid_no ),
                           cur_dvc_qng ) ;
                  }/* if */
              }/* if queue full */
           }/* if over */
           AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
           return( 0 ) ;
       }/* else if queue full */
/* ------------------------------------------------------------ */
  /*
  ** fatal error !
  ** chip halted
  **
  **     scsiq = ( ASC_QDONE_INFO )
  **     scsiq->d2.done_stat = QD_WITH_ERROR ;
  **     scsiq->d2.host_stat = QHSTA_MICRO_CODE_HALT ;
  */
       /* AscSetLibErrorCode( asc_dvc, ASCQ_ERR_MICRO_CODE_HALT ) ; */
       /* return( ERR ) ; */
       return( 0 ) ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
uchar  _AscCopyLramScsiDoneQ(
           PortAddr iop_base,
           ushort  q_addr,
           REG ASC_QDONE_INFO dosfar *scsiq,
           ulong max_dma_count
       )
{
       ushort  _val ;
       uchar   sg_queue_cnt ;

       DvcGetQinfo( iop_base,
            ( ushort )( q_addr+( ushort )ASC_SCSIQ_DONE_INFO_BEG ),
            ( ushort dosfar *)scsiq,
            ( ushort )( (sizeof(ASC_SCSIQ_2)+sizeof(ASC_SCSIQ_3))/2 )) ;

#if !CC_LITTLE_ENDIAN_HOST
       AscAdjEndianQDoneInfo( scsiq ) ;
#endif

       _val = AscReadLramWord( iop_base,
                    ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ) ) ;
       scsiq->q_status = ( uchar )_val ;
       scsiq->q_no = ( uchar )( _val >> 8 ) ;

       _val = AscReadLramWord( iop_base,
                     ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_CNTL ) ) ;
       scsiq->cntl = ( uchar )_val ;
       sg_queue_cnt = ( uchar )( _val >> 8 ) ;

       _val = AscReadLramWord( iop_base,
                     ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_SENSE_LEN ) ) ;
       scsiq->sense_len = ( uchar )_val ;
       scsiq->extra_bytes = ( uchar )( _val >> 8 ) ;

       /*
        * XXX - Read only the first word of 'remain_bytes' from the RISC
        * queue. With the ASC-3050 (Finch) with External LRAM, reading the
        * last word of the last queue before External LRAM (queue 0x13)
        * appears to cause the RISC to read a corrupted byte from status
        * field of the first queue in External LRAM (queue 0x14).
        */
#define FINCH_WORKAROUND 1
#if FINCH_WORKAROUND
       scsiq->remain_bytes = AscReadLramWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_CNT ) ) ;
#else /* FINCH_WORKAROUND */
       scsiq->remain_bytes = AscReadLramDWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_CNT ) ) ;
#endif /* FINCH_WORKAROUND */

       scsiq->remain_bytes &= max_dma_count ;

       return( sg_queue_cnt ) ;
}

/* ---------------------------------------------------------------------
** return number of Qs processed
**
** returns:
**
** Note: should call this routine repeatly until bit 0 is clear
**
** 0 - no queue processed
** 1 - one done queue process
** 0x11 - one aborted queue processed
** 0x80 - fatal error encountered
**
** ------------------------------------------------------------------ */
int    AscIsrQDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       uchar   next_qp ;
       uchar   n_q_used ;
       uchar   sg_list_qp ;
       uchar   sg_queue_cnt ;
       uchar   q_cnt ;
       uchar   done_q_tail ;
       uchar   tid_no ;

#if CC_LINK_BUSY_Q
       uchar   exe_tid_no ;
#endif
       ASC_SCSI_BIT_ID_TYPE scsi_busy ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       PortAddr iop_base ;
       ushort  q_addr ;
       ushort  sg_q_addr ;
       uchar   cur_target_qng ;
       ASC_QDONE_INFO scsiq_buf ;
       REG ASC_QDONE_INFO dosfar *scsiq ;
       int     false_overrun ; /* for PCI fix */
       ASC_ISR_CALLBACK asc_isr_callback ;

#if CC_LINK_BUSY_Q
       ushort   n_busy_q_done ;
#endif /* CC_LINK_BUSY_Q */

/*
**
** function code begin
**
*/
       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;

       n_q_used = 1 ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;
       done_q_tail = ( uchar )AscGetVarDoneQTail( iop_base ) ;
       q_addr = ASC_QNO_TO_QADDR( done_q_tail ) ;
       next_qp = AscReadLramByte( iop_base,
                 ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_FWD ) ) ;
       if( next_qp != ASC_QLINK_END )
       {
           /* _err_qp = next_qp ; */
           AscPutVarDoneQTail( iop_base, next_qp ) ;
           q_addr = ASC_QNO_TO_QADDR( next_qp ) ;
/*
** copy ASC_SCSIQ_2 and ASC_SCSIQ_3 to scsiq in word size
*/
           sg_queue_cnt = _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;

           AscWriteLramByte( iop_base,
                             ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                             ( uchar )( scsiq->q_status & ( uchar )~( QS_READY | QS_ABORTED ) ) ) ;
           tid_no = ASC_TIX_TO_TID( scsiq->d2.target_ix ) ;
           target_id = ASC_TIX_TO_TARGET_ID( scsiq->d2.target_ix ) ;
           if( ( scsiq->cntl & QC_SG_HEAD ) != 0 )
           {
               sg_q_addr = q_addr ;
               sg_list_qp = next_qp ;
               for( q_cnt = 0 ; q_cnt < sg_queue_cnt ; q_cnt++ )
               {
                    sg_list_qp = AscReadLramByte( iop_base,
                         ( ushort )( sg_q_addr+( ushort )ASC_SCSIQ_B_FWD ) ) ;
                    sg_q_addr = ASC_QNO_TO_QADDR( sg_list_qp ) ;
                    if( sg_list_qp == ASC_QLINK_END )
                    {
                        AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SG_Q_LINKS ) ;
                        scsiq->d3.done_stat = QD_WITH_ERROR ;
                        scsiq->d3.host_stat = QHSTA_D_QDONE_SG_LIST_CORRUPTED ;
                        goto FATAL_ERR_QDONE ;
                    }/* if */
                    AscWriteLramByte( iop_base,
                         ( ushort )( sg_q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                                   QS_FREE ) ;
               }/* for */
#if 0
/*
** calculate remaining bytes of sg list
*/
               sg_wk_qp = AscReadLramByte( iop_base,
                                           q_addr+ASC_SCSIQ_B_SG_WK_QP ) ;
               sg_wk_ix = AscReadLramByte( iop_base,
                                           q_addr+ASC_SCSIQ_B_SG_WK_IX ) ;
/*
** skip until you found the
**
*/
               if( sg_wk_qp != done_q_tail )
               {
                   while( TRUE ) {

                   }/* while */
               }/* if */
#endif
               n_q_used = sg_queue_cnt + 1 ;
               AscPutVarDoneQTail( iop_base, sg_list_qp ) ;
           }/* if */

           if( asc_dvc->queue_full_or_busy & target_id )
           {
/*
** clear tagged queue busy device
** when number of queue fall below maximum value
*/
               cur_target_qng = AscReadLramByte( iop_base,
                  ( ushort )( ( ushort )ASC_QADR_BEG+( ushort )scsiq->d2.target_ix ) ) ;
               if( cur_target_qng < asc_dvc->max_dvc_qng[ tid_no ] )
               {
                   scsi_busy = AscReadLramByte( iop_base,
                            ( ushort )ASCV_SCSIBUSY_B ) ;
                   scsi_busy &= ~target_id ;
                   AscWriteLramByte( iop_base,
                      ( ushort )ASCV_SCSIBUSY_B, scsi_busy ) ;
                   asc_dvc->queue_full_or_busy &= ~target_id ;
               }/* if */
           }/* if */

           if( asc_dvc->cur_total_qng >= n_q_used )
           {
               asc_dvc->cur_total_qng -= n_q_used ;
               if( asc_dvc->cur_dvc_qng[ tid_no ] != 0 )
               {
                   asc_dvc->cur_dvc_qng[ tid_no ]-- ;
               }/* if */
           }/* if */
           else
           {
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_CUR_QNG ) ;
               scsiq->d3.done_stat = QD_WITH_ERROR ;
               goto FATAL_ERR_QDONE ;
           }/* else */

           if( ( scsiq->d2.srb_ptr == 0UL ) ||
               ( ( scsiq->q_status & QS_ABORTED ) != 0 ) )
               {
/*
** do not write information to an aborted queue
** the caller probably has terminated !
*/
               /*
               ** _err_qp = scsiq->q_no ;
               ** _err_q_done_stat = scsiq->d3.done_stat ;
               ** _err_q_status = scsiq->q_status ;
               */
               return( 0x11 ) ;
           }/* else */
           else if( scsiq->q_status == QS_DONE )
           {
/*
** this will clear overrun/underrun error
** if QC_DATA_IN and QC_DATA_OUT is not set
**
*/
               false_overrun = FALSE ;

               if( scsiq->extra_bytes != 0 )
               {
                   scsiq->remain_bytes += ( ulong )scsiq->extra_bytes ;
               }/* if */

               if( scsiq->d3.done_stat == QD_WITH_ERROR )
               {
                   if( scsiq->d3.host_stat == QHSTA_M_DATA_OVER_RUN )
                   {
                       if( ( scsiq->cntl & ( QC_DATA_IN | QC_DATA_OUT ) ) == 0 )
                       {
                           scsiq->d3.done_stat = QD_NO_ERROR ;
                           scsiq->d3.host_stat = QHSTA_NO_ERROR ;
                       }/* if */
                       else if( false_overrun )
                       {
                           scsiq->d3.done_stat = QD_NO_ERROR ;
                           scsiq->d3.host_stat = QHSTA_NO_ERROR ;
                       }/* else */
                   }/* if */
                   else if( scsiq->d3.host_stat == QHSTA_M_HUNG_REQ_SCSI_BUS_RESET )
                   {
                       AscStopChip( iop_base ) ;
                       AscSetChipControl( iop_base, ( uchar )( CC_SCSI_RESET | CC_HALT ) ) ;
                       DvcDelayNanoSecond( asc_dvc, 60000 ) ; /* 60 uSec.  Fix  Panasonic problem */
                       AscSetChipControl( iop_base, CC_HALT ) ;
                       AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
                       AscSetChipStatus( iop_base, 0 ) ;
                       AscSetChipControl( iop_base, 0 ) ;
#if CC_SCAM
                       if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
                       {
                           asc_dvc->redo_scam = TRUE ;
                       }/* if */
#endif
                   }
               }/* if */
#if CC_CLEAR_LRAM_SRB_PTR
               AscWriteLramDWord( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                             asc_dvc->int_count ) ;
#endif /* #if CC_CLEAR_LRAM_SRB_PTR */
/*
** normal completion
*/
               if( ( scsiq->cntl & QC_NO_CALLBACK ) == 0 )
               {
                   ( *asc_isr_callback )( asc_dvc, scsiq ) ;
               }/* if */
               else
               {
                   if( ( AscReadLramByte( iop_base,
                       ( ushort )( q_addr+( ushort )ASC_SCSIQ_CDB_BEG ) ) ==
                       SCSICMD_StartStopUnit ) )
                   {
/*
** reset target as unit ready now
*/
                       asc_dvc->unit_not_ready &= ~target_id ;
                       if( scsiq->d3.done_stat != QD_NO_ERROR )
                       {
                           asc_dvc->start_motor &= ~target_id ;
                       }/* if */
                   }/* if */
               }/* else */

#if CC_LINK_BUSY_Q
               n_busy_q_done = AscIsrExeBusyQueue( asc_dvc, tid_no ) ;
               if( n_busy_q_done == 0 )
               {
/*
** no busy queue found on the device
**
** in order to be fair
** we do not search queue in a specific order
** search start from current scsi id plus one
*/
                   exe_tid_no = ( uint )tid_no + 1 ;
                   while( TRUE )
                   {
                        if( exe_tid_no > ASC_MAX_TID ) exe_tid_no = 0 ;
                        if( exe_tid_no == ( uint )tid_no ) break ;
                        n_busy_q_done = AscIsrExeBusyQueue( asc_dvc, exe_tid_no ) ;
                        if( n_busy_q_done != 0 ) break ;
                        exe_tid_no++ ;
                   }/* for */
               }/* if */
               if( n_busy_q_done == 0xFFFF ) return( 0x80 ) ;
#endif /* CC_LINK_BUSY_Q */

               return( 1 ) ;
           }/* if */
           else
           {
/*
** fatal error ! incorrect queue done status
**
**               _err_int_count = asc_dvc->int_count ;
**               _err_q_done_stat = scsiq->q_status ;
**               _err_qp = next_qp ;
*/
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_Q_STATUS ) ;

FATAL_ERR_QDONE:
               if( ( scsiq->cntl & QC_NO_CALLBACK ) == 0 )
               {
                   ( *asc_isr_callback )( asc_dvc, scsiq ) ;
               }/* if */
               return( 0x80 ) ;
           }/* else */
       }/* if */
       return( 0 ) ;
}

#if CC_LINK_BUSY_Q

/* ----------------------------------------------------------------------
** return 0 if RISC queue is still full
** return 0 if no busy queue found at tid_no list
** return 0xFFFF if fatal error occured
** return number of queue sent to RISC
** ------------------------------------------------------------------- */
ushort AscIsrExeBusyQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar tid_no
       )
{
       ASC_SCSI_Q dosfar *scsiq_busy ;
       int  n_q_done ;
       int  sta ;
       ASC_EXE_CALLBACK asc_exe_callback ;

       n_q_done = 0 ;
       scsiq_busy = asc_dvc->scsiq_busy_head[ tid_no ] ;
       while( scsiq_busy != ( ASC_SCSI_Q dosfar *)0UL )
       {
           if( AscGetNumOfFreeQueue( asc_dvc, scsiq_busy->q2.target_ix,
               scsiq_busy->ext.q_required ) >= scsiq_busy->ext.q_required )
           {
               if( ( sta = AscSendScsiQueue( asc_dvc, scsiq_busy,
                   scsiq_busy->ext.q_required ) ) != 1 )
               {
/*
** something is wrong !!!
*/
                   if( sta == 0 )
                   {
                       AscSetLibErrorCode( asc_dvc, ASCQ_ERR_GET_NUM_OF_FREE_Q ) ;
                       return( 0xFFFF ) ;
                   }/* if */
                   else
                   {
                       AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SEND_SCSI_Q ) ;
                       return( 0xFFFF ) ;
                   }/* else */
               }/* if */
               n_q_done++ ;
               if( asc_dvc->exe_callback != 0 )
               {
                   asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
                   ( *asc_exe_callback )( asc_dvc, scsiq_busy ) ;
               }/* if */
           }/* if */
           else
           {
               if( n_q_done == 0 ) return( 0 ) ;
               break ;
           }/* else */
           scsiq_busy = scsiq_busy->ext.next ;
           asc_dvc->scsiq_busy_head[ tid_no ] = scsiq_busy ;
           if( scsiq_busy == ( ASC_SCSI_Q dosfar *)0UL )
           {
               asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)0UL ;
               break ;
           }/* if */

           break ; /* now we force it only do one queue */
       }/* while */
       return( n_q_done ) ;
}
#endif /* CC_LINK_BUSY_Q */

/* ----------------------------------------------------------------------
** return TRUE ( 1 )  if interrupt pending bit set
** return FALSE ( 0 ) if interrupt pendinf bit is not set
** return ERR if error occured
** ------------------------------------------------------------------- */
int    AscISR(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       ASC_CS_TYPE chipstat ;
       PortAddr iop_base ;
       ushort   saved_ram_addr ;
       uchar    ctrl_reg ;
       uchar    saved_ctrl_reg ;
       int      int_pending ;
       int      status ;
       uchar    host_flag ;

/*
** BC compiler cannot take the address of buffer in stack
**
** static SCSI_Q  dosfar *scsiq ;
*/

       iop_base = asc_dvc->iop_base ;
       int_pending = FALSE ;

       /* asc_dvc->int_count++ ; */

       if( ( ( asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC ) == 0 )
           || ( asc_dvc->isr_callback == 0 )
           )
       {
/*
**
** if pointer to asc_isr_call_back function is NULL,
** the init process is not completed yet !
** a spurious interrupt may have occured.
** this will be ignored but not treated as a fatal error.
** however, interrupt count is increased
** you may look at interrupt count to check spurious interrupt
**
*/
           return( ERR ) ;
       }/* if */
       if( asc_dvc->in_critical_cnt != 0 )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL ) ;
           return( ERR ) ;
       }/* if */

       if( asc_dvc->is_in_int )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_ISR_RE_ENTRY ) ;
           return( ERR ) ;
       }/* if */
       asc_dvc->is_in_int = TRUE ;
       ctrl_reg = AscGetChipControl( iop_base ) ;

       saved_ctrl_reg = ctrl_reg & ( ~( CC_SCSI_RESET | CC_CHIP_RESET |
                        CC_SINGLE_STEP | CC_DIAG | CC_TEST ) ) ;
       chipstat = AscGetChipStatus( iop_base ) ;
       if( chipstat & CSW_SCSI_RESET_LATCH )
       {
           if(
               !( asc_dvc->bus_type & ( ASC_IS_VL | ASC_IS_EISA ) )
             )
           {
               int_pending = TRUE ;
               asc_dvc->sdtr_done = 0 ;
               saved_ctrl_reg &= ( uchar )( ~CC_HALT ) ;
               while( AscGetChipStatus( iop_base ) & CSW_SCSI_RESET_ACTIVE ) ;
    /*
    **
    **
    ** SCSI bus reset occured not by initiator
    ** 1. clear scsi reset interrupt, different from normal intrrupt
    ** 2. reset chip to clear CSW_SCSI_RESET_LATCH
    ** 3. redo all SDTR to every device, presume every device also receive scsi reset
    ** 4. let chip stay in halt( idle ) state, the code later will take care of everything
    **
    ** must clear chip reset state
    ** if chip is in reset state, local RAM cannot be accessed
    **
    */
               AscSetChipControl( iop_base, ( CC_CHIP_RESET | CC_HALT ) ) ;
               AscSetChipControl( iop_base, CC_HALT ) ;

               AscSetChipStatus( iop_base, CIW_CLR_SCSI_RESET_INT ) ;
               AscSetChipStatus( iop_base, 0 ) ;
               chipstat = AscGetChipStatus( iop_base ) ;
           }
       }/* if */
/*
** Save local RAM address register
** must be done before any local RAM access
*/
       saved_ram_addr = AscGetChipLramAddr( iop_base ) ; /* save local ram register */

       host_flag = AscReadLramByte( iop_base, ASCV_HOST_FLAG_B ) & ( uchar )( ~ASC_HOST_FLAG_IN_ISR ) ;
       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B,
                         ( uchar )( host_flag | ( uchar )ASC_HOST_FLAG_IN_ISR ) ) ;

/*       AscSetChipControl( iop_base, saved_ctrl_reg & (~CC_BANK_ONE) ) ; switch to bank 0 */

#if CC_ASCISR_CHECK_INT_PENDING
       if( ( chipstat & CSW_INT_PENDING )
           || ( int_pending )
         )
       {
            AscAckInterrupt( iop_base ) ;
#endif
            int_pending = TRUE ;

     /*
     ** do not access local RAM before saving saving its address
     **
     */
     /*
     **       chip_status = chipstat ;
     **
     ** this is to prevent more than one level depth interrupt
     ** but you should never call this function with interrupt enabled anyway
     **
     */
            if( ( chipstat & CSW_HALTED ) &&
                ( ctrl_reg & CC_SINGLE_STEP ) )
            {
                if( AscIsrChipHalted( asc_dvc ) == ERR )
                {
     /*
     ** the global error variable should be set in AscIsrChipHalted
     */
                    goto ISR_REPORT_QDONE_FATAL_ERROR ;

                }/* if */
                else
                {
                    saved_ctrl_reg &= ( uchar )(~CC_HALT) ;
                }/* else */
            }/* if */
            else
            {
ISR_REPORT_QDONE_FATAL_ERROR:

                if( ( asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q ) != 0 )
                {
                    while( ( ( status = AscIsrQDone( asc_dvc ) ) & 0x01 ) != 0 )
                    {
                        /*  n_q_done++ ; */
                    }/* while */
                }/* if */
                else
                {
                    do
                    {
                       if( ( status = AscIsrQDone( asc_dvc ) ) == 1 )
                       {
                           /* n_q_done = 1 ; */
                           break ;
                       }/* if */
                    }while( status == 0x11 ) ;
                }/* else */
                if( ( status & 0x80 ) != 0 ) int_pending = ERR ;
          }/* else */

#if CC_ASCISR_CHECK_INT_PENDING

       }/* if interrupt pending */

#endif

       AscWriteLramByte( iop_base, ASCV_HOST_FLAG_B, host_flag ) ;
/*
** no more local RAM access from here
** address register restored
*/
       AscSetChipLramAddr( iop_base, saved_ram_addr ) ;

#if CC_CHECK_RESTORE_LRAM_ADDR
       if( AscGetChipLramAddr( iop_base ) != saved_ram_addr )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SET_LRAM_ADDR ) ;
       }/* if */
#endif

       AscSetChipControl( iop_base, saved_ctrl_reg ) ;
       asc_dvc->is_in_int = FALSE ;
       return( int_pending ) ;
}

/* ----------------------------------------------------------------------
**
** ------------------------------------------------------------------- */
void   AscISR_AckInterrupt(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int      int_level ;
       ushort   saved_ram_addr ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       int_level = DvcEnterCritical( ) ;
       saved_ram_addr = AscGetChipLramAddr( iop_base ) ;
            /* save local ram register */
       AscAckInterrupt( iop_base ) ;
       AscSetChipLramAddr( iop_base, saved_ram_addr ) ;
       DvcLeaveCritical( int_level ) ;
       return ;
}


#if CC_USE_AscISR_CheckQDone

/* --------------------------------------------------------------------
** Description:
**   this function will take care of following thing
**    1. send start unit command if device is not ready
**
** Notes:
**
**  make calling AscISR_CheckQDone( ) the very first thing
**  inside DvcISRCallBack()
**
**  "sense_data" should be virtual address of physical address
**  "scsiq->q1.sense_addr" that pass to AscExeScsiQueue()
**
**  "scsiq->q1.sense_len" should be at least ASC_MIN_SENSE_LEN bytes
**  when AscExeScsiQueue() was called, otherwise the "sense_data"
**  will not have correct information
**
** ------------------------------------------------------------------ */
int    AscISR_CheckQDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_QDONE_INFO dosfar *scsiq,
          uchar dosfar *sense_data
       )
{
       ASC_REQ_SENSE  dosfar *sense ;
       ASC_SCSI_BIT_ID_TYPE target_id ;

       if( ( scsiq->d3.done_stat == QD_WITH_ERROR ) &&
           ( scsiq->d3.scsi_stat == SS_CHK_CONDITION ) )
       {
           sense = ( ASC_REQ_SENSE dosfar *)sense_data ;
           if( ( sense->err_code == 0x70 ) || ( sense->err_code == 0x71 ) )
           {
               if( sense->sense_key == SCSI_SENKEY_NOT_READY )
               {
                   target_id = ASC_TIX_TO_TARGET_ID( scsiq->d2.target_ix ) ;
                   if( ( asc_dvc->unit_not_ready & target_id ) == 0 )
                   {
                       if( ( asc_dvc->start_motor & target_id ) != 0 )
                       {
                           if( AscStartUnit( asc_dvc, scsiq->d2.target_ix ) != 1 )
                           {
                               asc_dvc->start_motor &= ~target_id ;
                               asc_dvc->unit_not_ready &= ~target_id ;
                               return( ERR ) ;
                           }/* if */
                       }/* if */
                   }/* if */
               }/* if */
           }/* if */
           return( 1 ) ;
       }/* if */
       return( 0 ) ;
}

#if CC_INIT_SCSI_TARGET
/* --------------------------------------------------------------------
** Description:
**   The function issue a start unit command to the specified device
**
** Parameter:
**   asc_dvc:    pointer to adapter struct ASC_DVC_VAR
**   taregt_ix : a combination of target id and lun
**               use ASC_TIDLUN_TO_IX( tid, lun ) to get target_ix value
**               that is:
**                  target_ix = ASC_TIDLUN_TO_IX( tid, lun ) ;
**
** Note:
**  asc_dvc->unit_not_ready will be cleared when the command completed
**
** return values are the same as AscExeScsiQueue()
** TRUE(1):  command issued without error
** FALSE(0): adapter busy
** ERR(-1):  command not issued, error cooured
**
** ------------------------------------------------------------------ */
int    AscStartUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_SCSI_TIX_TYPE target_ix
       )
{
       ASC_SCSI_REQ_Q scsiq_buf ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       uchar   target_id ;
       int     status = 0 ;

       target_id = ASC_TIX_TO_TARGET_ID( target_ix ) ;
       if( !( asc_dvc->unit_not_ready & target_id ) )
       {
           scsiq = ( ASC_SCSI_REQ_Q dosfar *)&scsiq_buf ;
           scsiq->r2.target_ix = target_ix ;
           scsiq->r1.target_id = target_id ;
           scsiq->r1.target_lun = ASC_TIX_TO_LUN( target_ix ) ;
           if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR,
               ( ulong )0L ) == ERR )
           {
               scsiq->r3.done_stat = QD_WITH_ERROR ;
               return( ERR ) ;
           }/* if */
           scsiq->r1.cntl = ( uchar )( ASC_SCSIDIR_NODATA | QC_URGENT |
                                       QC_NO_CALLBACK ) ;
           scsiq->cdb[ 0 ] = ( uchar )SCSICMD_StartStopUnit ;
           scsiq->cdb[ 1 ] = scsiq->r1.target_lun << 5 ;  /* LUN */
           scsiq->cdb[ 2 ] = 0 ;
           scsiq->cdb[ 3 ] = 0 ;
           scsiq->cdb[ 4 ] = 0x01 ; /* to start/stop unit set bit 0 */
                                 /* to eject/load unit set bit 1 */
           scsiq->cdb[ 5 ] = 0 ;
           scsiq->r2.cdb_len = 6 ;
           scsiq->r1.sense_len = 0 ;
           status = AscExeScsiQueue( asc_dvc, ( ASC_SCSI_Q dosfar *)scsiq ) ;
           asc_dvc->unit_not_ready |= target_id ;
       }
       return( status ) ;

}
#endif /* CC_INIT_SCSI_TARGET */

#endif /* CC_USE_AscISR_CheckQDone */

#if CC_INIT_SCSI_TARGET
#if CC_POWER_SAVER

/* --------------------------------------------------------------------
** Description:
**   The function issue a stop unit command to the specified device
**
** Parameter:
**   asc_dvc:    pointer to adapter struct ASC_DVC_VAR
**   taregt_ix : a combination of target id and lun
**               use ASC_TIDLUN_TO_IX( tid, lun ) to get target_ix value
**               that is:
**                  target_ix = ASC_TIDLUN_TO_IX( tid, lun ) ;
**
** Note:
**  asc_dvc->unit_not_ready will be cleared when the command completed
**
** return values are the same as AscExeScsiQueue()
** TRUE(1):  command issued without error
** FALSE(0): adapter busy
** ERR(-1):  command not issued, error cooured
**
** ------------------------------------------------------------------ */
int    AscStopUnit(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ASC_SCSI_TIX_TYPE target_ix
       )
{
       ASC_SCSI_REQ_Q scsiq_buf ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       uchar   target_id ;
       int     status = 0 ;

       target_id = ASC_TIX_TO_TARGET_ID( target_ix ) ;
       if( !( asc_dvc->unit_not_ready & target_ix ) )
       {
           scsiq = ( ASC_SCSI_REQ_Q dosfar *)&scsiq_buf ;
           scsiq->r2.target_ix = target_ix ;
           scsiq->r1.target_id = target_id ;
           scsiq->r1.target_lun = ASC_TIX_TO_LUN( target_ix ) ;
           if( AscScsiSetupCmdQ( asc_dvc, scsiq, FNULLPTR,
               ( ulong )0L ) == ERR )
           {
               scsiq->r3.done_stat = QD_WITH_ERROR ;
               return( ERR ) ;
           }/* if */
           scsiq->r1.cntl = ( uchar )( ASC_SCSIDIR_NODATA | QC_URGENT |
                                       QC_NO_CALLBACK ) ;
           scsiq->cdb[ 0 ] = ( uchar )SCSICMD_StartStopUnit ;
           scsiq->cdb[ 1 ] = ( scsiq->r1.target_lun << 5 ) | 0x01 ;  /* LUN */
           scsiq->cdb[ 2 ] = 0 ;
           scsiq->cdb[ 3 ] = 0 ;
           scsiq->cdb[ 4 ] = 0x00 ; /* to start/stop unit set bit 0 */
           scsiq->cdb[ 5 ] = 0 ;
           scsiq->r2.cdb_len = 6 ;
           scsiq->r1.sense_len = 0 ;
           status = AscExeScsiQueue( asc_dvc, ( ASC_SCSI_Q dosfar *)scsiq ) ;
           asc_dvc->unit_not_ready |= target_id ;
       }
       return( status ) ;
}

#endif /* CC_POWER_SAVER */

/* ------------------------------------------------------------------------
** ASPI command code 0x02
** SCSI Request Flag:
** bit 0: posting
** bit 1: linking
** bit 3 & 4:  direction bits
**             00: Direction determined by SCSI command, length not checked
**             01: Transfer from SCSI to host, length checked
**             10: Transfer from Host to SCSI, length checked
**             11: No data transfer.
** --------------------------------------------------------------------- */
int    AscScsiSetupCmdQ(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_REQ_Q dosfar *scsiq,
          uchar dosfar *buf_addr,
          ulong buf_len
       )
{
       ulong  phy_addr ;

/*
**
** Note: clear entire scsiq wouldn't work
**
*/
       scsiq->r1.cntl = 0 ;
       scsiq->r1.sg_queue_cnt = 0 ;
       scsiq->r1.q_no = 0 ;
       scsiq->r1.extra_bytes = 0 ;
       scsiq->r3.scsi_stat = 0 ;
       scsiq->r3.scsi_msg = 0 ;
       scsiq->r3.host_stat = 0 ;
       scsiq->r3.done_stat = 0 ;
       scsiq->r2.vm_id = 0 ;
       scsiq->r1.data_cnt = buf_len ;
       scsiq->cdbptr = ( uchar dosfar *)scsiq->cdb ;
       scsiq->sense_ptr = ( uchar dosfar *)scsiq->sense ;
       scsiq->r1.sense_len = ASC_MIN_SENSE_LEN ;
/*
**
** will be set to use work space provided
**
*/
       scsiq->r2.tag_code = ( uchar )M2_QTAG_MSG_SIMPLE ;
       scsiq->r2.flag = ( uchar )ASC_FLAG_SCSIQ_REQ ;
       scsiq->r2.srb_ptr = ( ulong )scsiq ;
       scsiq->r1.status = ( uchar )QS_READY ;
       scsiq->r1.data_addr = 0L ;
       /* scsiq->sg_head = &sg_head ; */
       if( buf_len != 0L )
       {
           if( ( phy_addr = AscGetOnePhyAddr( asc_dvc,
               ( uchar dosfar *)buf_addr, scsiq->r1.data_cnt ) ) == 0L )
           {
               return( ERR ) ;
           }/* if */
           scsiq->r1.data_addr = phy_addr ;
       }/* if */
       if(
           ( phy_addr = AscGetOnePhyAddr( asc_dvc,
                       ( uchar dosfar *)scsiq->sense_ptr,
                       ( ulong )scsiq->r1.sense_len ) ) == 0L
         )
       {
           return( ERR ) ;
       }/* if */
       scsiq->r1.sense_addr = phy_addr ;
       return( 0 ) ;
}
#endif /* CC_INIT_SCSI_TARGET */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_qop.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_qop.c
**
*/

#include "ascinc.h"

/* -------------------------------------------------------------------------
** update history
** 1: 12/16/93
**
** version 101: 12/20/93 released
**
** csf 9/13/95 - Change synchronous negotiation code to always use the lower
**               proposed by initiator or target.
**
**     SYN_XFER_NS_0 = 10 MB/sec
**     SYN_XFER_NS_4 = 5 MB/sec
**
** ---------------------------------------------------------------------- */


/* -------------------------------------------------------------------------
**
** return value that should write to chip sdtr register
** but usually not set to chip immediately
** set was done later when target come back with agreed speed
**
** return 0 - means we should use the asyn transfer
**
** ---------------------------------------------------------------------- */
uchar  AscMsgOutSDTR(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar sdtr_period,
          uchar sdtr_offset
       )
{
       EXT_MSG  sdtr_buf ;
       uchar  sdtr_period_index ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       sdtr_buf.msg_type = MS_EXTEND ;
       sdtr_buf.msg_len = MS_SDTR_LEN ;
       sdtr_buf.msg_req = MS_SDTR_CODE ;
       sdtr_buf.xfer_period = sdtr_period ;
       sdtr_offset &= ASC_SYN_MAX_OFFSET ;
       sdtr_buf.req_ack_offset = sdtr_offset ;
       if( ( sdtr_period_index =
           AscGetSynPeriodIndex( asc_dvc, sdtr_period ) ) <=
           asc_dvc->max_sdtr_index )
       {
           AscMemWordCopyToLram( iop_base,
                                 ASCV_MSGOUT_BEG,
                                 ( ushort dosfar *)&sdtr_buf,
                                 ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
           return( ( sdtr_period_index << 4 ) | sdtr_offset ) ;
       }/* if */
       else
       {
/*
**
** the speed is too slow
**
**
*/
           sdtr_buf.req_ack_offset = 0 ;
           AscMemWordCopyToLram( iop_base,
                                 ASCV_MSGOUT_BEG,
                                 ( ushort dosfar *)&sdtr_buf,
                                 ( ushort )( sizeof( EXT_MSG ) >> 1 )) ;
           return( 0 ) ;
       }/* else */
}

/* ---------------------------------------------------------------------
**
** return the value that should be written to sdtr register
** return 0xff if value is not acceptable ( either out of range or too low )
** ------------------------------------------------------------------ */
uchar  AscCalSDTRData(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar sdtr_period,
          uchar syn_offset
       )
{
       uchar  byte ;
       uchar  sdtr_period_ix ;

       sdtr_period_ix = AscGetSynPeriodIndex( asc_dvc, sdtr_period ) ;
       if(
           ( sdtr_period_ix > asc_dvc->max_sdtr_index )
           /* || ( sdtr_period_ix > ASC_SDTR_PERIOD_IX_MIN ) */
           )
       {
           return( 0xFF ) ;
       }/* if */
       byte = ( sdtr_period_ix << 4 ) | ( syn_offset & ASC_SYN_MAX_OFFSET );
       return( byte ) ;
}

/* ---------------------------------------------------------------------
**
** ------------------------------------------------------------------ */
void   AscSetChipSDTR(
          PortAddr iop_base,
          uchar sdtr_data,
          uchar tid_no
       )
{
/*
**
** if we write zero to ASCV_SDTR_DONE_BEG table
** we have disable the sdtr also
**
*/
       /* AscSetChipSyn( iop_base, sdtr_data ) ; */

       AscSetChipSynRegAtID( iop_base, tid_no, sdtr_data ) ;
       AscPutMCodeSDTRDoneAtID( iop_base, tid_no, sdtr_data ) ;
       return ;
}

/* --------------------------------------------------------------------
**
** return speed
** return 0 if if speed is faster than we can handle
**
** if return value > 7, it speed is too slow, use asyn transfer
**
** ----------------------------------------------------------------- */
uchar  AscGetSynPeriodIndex(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ruchar syn_time
       )
{
       ruchar *period_table ;
       int    max_index ;
       int    min_index ;
       int    i ;

       period_table = asc_dvc->sdtr_period_tbl ;
       max_index = ( int )asc_dvc->max_sdtr_index ;
       min_index = ( int )asc_dvc->host_init_sdtr_index ;
       if(
           ( syn_time <= period_table[ max_index ] )
         )
       {
           for( i = min_index ; i < (max_index-1) ; i++ )
           {
                if( syn_time <= period_table[ i ] )
                {
                    return( ( uchar )i ) ;
                }
           }
           return( ( uchar )max_index ) ;
       }/* if */
       else
       {
/*
** out of range !
*/
           return( ( uchar )( max_index+1 ) ) ;
       }/* else */
}

/* -------------------------------------------------------------------
**
** returns:
** 0 - busy
** 1 - queue allocated
** other value: error
** ---------------------------------------------------------------- */
uchar  AscAllocFreeQueue(
          PortAddr iop_base,
          uchar free_q_head
       )
{
       ushort  q_addr ;
       uchar   next_qp ;
       uchar   q_status ;

/*
** this is critical section until user update the asc_dvc->free_q_head
*/
       q_addr = ASC_QNO_TO_QADDR( free_q_head ) ;
       q_status = ( uchar )AscReadLramByte( iop_base,
                  ( ushort )( q_addr+ASC_SCSIQ_B_STATUS ) ) ;
       next_qp = AscReadLramByte( iop_base,
                  ( ushort )( q_addr+ASC_SCSIQ_B_FWD ) ) ;
       if(
           ( ( q_status & QS_READY ) == 0 )
           && ( next_qp != ASC_QLINK_END )
         )
       {
           return( next_qp ) ;
       }/* if */
       return( ASC_QLINK_END ) ;
}

/* -------------------------------------------------------------------
**
** returns:
** 0xFF - busy
** 1 - queue allocated
** other value: error
** ---------------------------------------------------------------- */
uchar  AscAllocMultipleFreeQueue(
          PortAddr iop_base,
          uchar free_q_head,
          uchar n_free_q
       )
{
       uchar  i ;
/*
** this is critical section until user update the asc_dvc->free_q_head
*/
       for( i = 0 ; i < n_free_q ; i++ )
       {
            if( ( free_q_head = AscAllocFreeQueue( iop_base, free_q_head ) )
                == ASC_QLINK_END )
            {
                return( ASC_QLINK_END ) ;
            }/* if */
       }/* for */
       return( free_q_head ) ;
}

#if CC_USE_AscAbortSRB

/* -----------------------------------------------------------------------
**
** srb_ptr is "scsiq->q2.srb_ptr" when you call AscExeScsiQueue()
** return value:
** TRUE(1) : the srb_ptr has been successfully aborted,
**           you should receive a callback later
**
** FALSE(0):
** - the srb_ptr cannot be found
**   most likely the queue is done
**
** - the queue is in a state that cannot be aborted
**
** -------------------------------------------------------------------- */
int    AscRiscHaltedAbortSRB(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong srb_ptr
       )
{
       PortAddr  iop_base ;
       ushort  q_addr ;
       uchar   q_no ;
       ASC_QDONE_INFO scsiq_buf ;
       ASC_QDONE_INFO dosfar *scsiq ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       int    last_int_level ;

       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       last_int_level = DvcEnterCritical( ) ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;

#if CC_LINK_BUSY_Q
       _AscAbortSrbBusyQueue( asc_dvc, scsiq, srb_ptr ) ;
#endif /* CC_LINK_BUSY_Q */

       for( q_no = ASC_MIN_ACTIVE_QNO ; q_no <= asc_dvc->max_total_qng ;
            q_no++ )
       {
            q_addr = ASC_QNO_TO_QADDR( q_no ) ;
            scsiq->d2.srb_ptr = AscReadLramDWord( iop_base,
                        ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ) ) ;
            if( scsiq->d2.srb_ptr == srb_ptr )
            {
                _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;
                if(
                    ( ( scsiq->q_status & QS_READY ) != 0 )
                    && ( ( scsiq->q_status & QS_ABORTED ) == 0 )
                    && ( ( scsiq->cntl & QCSG_SG_XFER_LIST ) == 0 )
                  )
                {
/*
** abort the queue only if QS_READY bit is set
*/
                    scsiq->q_status |= QS_ABORTED ;
                    scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
                    AscWriteLramDWord( iop_base,
                          ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                            0L ) ;
                    AscWriteLramByte( iop_base,
                          ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                            scsiq->q_status ) ;
                    ( *asc_isr_callback )( asc_dvc, scsiq ) ;
                    return( 1 ) ;
                }/* if */
            }/* if */
       }/* for */
       DvcLeaveCritical( last_int_level ) ;
       return( 0 ) ;
}
#endif /* CC_USE_AscAbortSRB */

#if CC_USE_AscResetDevice

/* -----------------------------------------------------------------------
**
**
** return value:
** TRUE(1): target successfully reset and abort all queued command
** -------------------------------------------------------------------- */
int    AscRiscHaltedAbortTIX(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
           uchar target_ix
       )
{
       PortAddr  iop_base ;
       ushort  q_addr ;
       uchar   q_no ;
       ASC_QDONE_INFO scsiq_buf ;
       ASC_QDONE_INFO dosfar *scsiq ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       int    last_int_level ;
#if CC_LINK_BUSY_Q
       uchar  tid_no ;
#endif /* CC_LINK_BUSY_Q */

       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       last_int_level = DvcEnterCritical( ) ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;

#if CC_LINK_BUSY_Q
/*
**
** abort all busy queue of the target_ix
**
*/
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       _AscAbortTidBusyQueue( asc_dvc, scsiq, tid_no ) ;

#endif /* CC_LINK_BUSY_Q */

       for( q_no = ASC_MIN_ACTIVE_QNO ; q_no <= asc_dvc->max_total_qng ;
            q_no++ )
       {
            q_addr = ASC_QNO_TO_QADDR( q_no ) ;
            _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;
            if(
                ( ( scsiq->q_status & QS_READY ) != 0 )
                && ( ( scsiq->q_status & QS_ABORTED ) == 0 )
                && ( ( scsiq->cntl & QCSG_SG_XFER_LIST ) == 0 )
              )
            {
                if( scsiq->d2.target_ix == target_ix )
                {
                    scsiq->q_status |= QS_ABORTED ;
                    scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;

                    AscWriteLramDWord( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                             0L ) ;

                    AscWriteLramByte( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                             scsiq->q_status ) ;
                    ( *asc_isr_callback )( asc_dvc, scsiq ) ;
                }/* if */
            }/* if */
       }/* for */
       DvcLeaveCritical( last_int_level ) ;
       return( 1 ) ;
}

#endif /* CC_USE_AscResetDevice */

#if 0
/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscRiscHaltedAbortALL(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr  iop_base ;
       ushort  q_addr ;
       uchar   q_no ;
       ASC_QDONE_INFO scsiq_buf ;
       ASC_QDONE_INFO dosfar *scsiq ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       int    last_int_level ;
#if CC_LINK_BUSY_Q
       uchar  tid ;
#endif /* CC_LINK_BUSY_Q */

       iop_base = asc_dvc->iop_base ;
       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       last_int_level = DvcEnterCritical( ) ;
       scsiq = ( ASC_QDONE_INFO dosfar *)&scsiq_buf ;

#if CC_LINK_BUSY_Q
       for( tid = 0 ; tid <= ASC_MAX_TID ; tid++ )
       {
            _AscAbortTidBusyQueue( asc_dvc, scsiq, tid ) ;
       }/* for */
#endif /* CC_LINK_BUSY_Q */

       for( q_no = ASC_MIN_ACTIVE_QNO ;
            q_no <= asc_dvc->max_total_qng ;
            q_no++ )
       {
            q_addr = ASC_QNO_TO_QADDR( q_no ) ;
            _AscCopyLramScsiDoneQ( iop_base, q_addr, scsiq, asc_dvc->max_dma_count ) ;
            if(
                ( ( scsiq->q_status & QS_READY ) != 0 )
                && ( ( scsiq->q_status & QS_ABORTED ) == 0 )
                && ( ( scsiq->cntl & QCSG_SG_XFER_LIST ) == 0 )
              )
            {
                scsiq->q_status |= QS_ABORTED ;
                scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
                AscWriteLramDWord( iop_base,
                                   ( ushort )( q_addr+( ushort )ASC_SCSIQ_D_SRBPTR ),
                                   0L ) ;
                AscWriteLramByte( iop_base,
                                  ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
                                  scsiq->q_status ) ;
                ( *asc_isr_callback )( asc_dvc, scsiq ) ;
            }/* if */
       }/* for */
       DvcLeaveCritical( last_int_level ) ;
       /* asc_dvc->cur_total_qng = 0 ; */
       return( 1 ) ;
}
#endif

#if CC_LINK_BUSY_Q

/* ---------------------------------------------------------------------
** this function will abort busy queue list of specified target id
** and all its lun as well
**
** ------------------------------------------------------------------ */
int    _AscAbortTidBusyQueue(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
           REG ASC_QDONE_INFO dosfar *scsiq,
           uchar tid_no
       )
{
       ASC_SCSI_Q dosfar *scsiq_busy ;
       ASC_ISR_CALLBACK asc_isr_callback ;
       ASC_EXE_CALLBACK asc_exe_callback ;

       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
       scsiq_busy = asc_dvc->scsiq_busy_head[ tid_no ] ;
       while( scsiq_busy != 0L )
       {
           scsiq_busy->q1.status = QS_FREE ;
           ( *asc_exe_callback )( asc_dvc, scsiq_busy ) ;

           scsiq->q_status = QS_ABORTED ;
           scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
           scsiq->d3.host_stat = 0 ;
           scsiq->d3.scsi_msg = 0 ;

           scsiq->d2.srb_ptr = scsiq_busy->q2.srb_ptr ;
           scsiq->d2.target_ix = scsiq_busy->q2.target_ix ;
           scsiq->d2.flag = scsiq_busy->q2.flag ;
           scsiq->d2.cdb_len = scsiq_busy->q2.cdb_len ;
           scsiq->d2.tag_code = scsiq_busy->q2.tag_code ;
           scsiq->d2.vm_id = scsiq_busy->q2.vm_id ;

           scsiq->q_no = scsiq_busy->q1.q_no ;
           scsiq->cntl = scsiq_busy->q1.cntl ;
           scsiq->sense_len = scsiq_busy->q1.sense_len ;
           /* scsiq->user_def = scsiq_busy->q1.user_def ; */
           scsiq->remain_bytes = scsiq_busy->q1.data_cnt ;

           ( *asc_isr_callback )( asc_dvc, scsiq ) ;

           scsiq_busy = scsiq_busy->ext.next ;
       }/* while */
       asc_dvc->scsiq_busy_head[ tid_no ] = ( ASC_SCSI_Q dosfar *)0L ;
       asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)0L ;
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
** this function will abort busy queue list of specified target id
** and all its lun as well
**
** ------------------------------------------------------------------ */
int    _AscAbortSrbBusyQueue(
           REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
           REG ASC_QDONE_INFO dosfar *scsiq,
           ulong srb_ptr
       )
{
       ASC_SCSI_Q dosfar *scsiq_busy ;
       ASC_ISR_CALLBACK  asc_isr_callback ;
       ASC_EXE_CALLBACK  asc_exe_callback ;
       int  i ;

       asc_isr_callback = ( ASC_ISR_CALLBACK )asc_dvc->isr_callback ;
       asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
           scsiq_busy = asc_dvc->scsiq_busy_head[ i ] ;
           while( scsiq_busy != 0L )
           {
               if( scsiq_busy->q2.srb_ptr == srb_ptr )
               {
                   scsiq_busy->q1.status = QS_FREE ;
                   ( *asc_exe_callback )( asc_dvc, scsiq_busy ) ;

                   scsiq->q_status = QS_ABORTED ;
                   scsiq->d3.done_stat = QD_ABORTED_BY_HOST ;
                   scsiq->d3.host_stat = 0 ;
                   scsiq->d3.scsi_msg = 0 ;

                   scsiq->d2.srb_ptr = scsiq_busy->q2.srb_ptr ;
                   scsiq->d2.target_ix = scsiq_busy->q2.target_ix ;
                   scsiq->d2.flag = scsiq_busy->q2.flag ;
                   scsiq->d2.cdb_len = scsiq_busy->q2.cdb_len ;
                   scsiq->d2.tag_code = scsiq_busy->q2.tag_code ;
                   scsiq->d2.vm_id = scsiq_busy->q2.vm_id ;

                   scsiq->q_no = scsiq_busy->q1.q_no ;
                   scsiq->cntl = scsiq_busy->q1.cntl ;
                   scsiq->sense_len = scsiq_busy->q1.sense_len ;
                   /* scsiq->user_def = scsiq_busy->q1.user_def ; */
                   scsiq->remain_bytes = scsiq_busy->q1.data_cnt ;

                   ( *asc_isr_callback )( asc_dvc, scsiq ) ;

                   break ;

               }/* if */
               scsiq_busy = scsiq_busy->ext.next ;
           }/* while */
       }/* for */
       return( 1 ) ;
}
#endif /* CC_LINK_BUSY_Q */

/* -----------------------------------------------------------------------
** Host request risc halt
** no interrupt will be generated
**
** return
** 1 - risc is halted
** 0 - risc fail to reponse, ( but may already halt )
** -------------------------------------------------------------------- */
int    AscHostReqRiscHalt(
          PortAddr iop_base
       )
{
       int  count = 0 ;
       int  sta = 0 ;
       uchar saved_stop_code ;

       if( AscIsChipHalted( iop_base ) ) return( 1 ) ;
       saved_stop_code = AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) ;
/*
** we ask RISC to stop and then halt itself
** this is two commands given in one stop_code
** only work with micro code date: serial number 13, ver 4.5 greater ( 6-20-95 )
*/
       AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                         ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP
                       ) ;
       do
       {
           if( AscIsChipHalted( iop_base ) )
           {
               sta = 1 ;
               break;
           }/* if */
           DvcSleepMilliSecond( 100 ) ;
       }while( count++ < 20 )  ;
/*
** if successful, RISC will halt
** so it is safe to write stop_code as zero
**
** we will always restore the stop_code to old value
*/
       AscWriteLramByte( iop_base, ASCV_STOP_CODE_B, saved_stop_code ) ;
       return( sta ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscStopQueueExe(
          PortAddr iop_base
       )
{
       int  count ;

       count = 0 ;
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) == 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                             ASC_STOP_REQ_RISC_STOP ) ;
           do
           {
              if(
                  AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) &
                  ASC_STOP_ACK_RISC_STOP )
              {
                  return( 1 ) ;
              }/* if */
              DvcSleepMilliSecond( 100 ) ;
           }while( count++ < 20 )  ;
       }/* if */
       return( 0 ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscStartQueueExe(
          PortAddr iop_base
       )
{
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) != 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B, 0 ) ;
       }/* if */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscCleanUpBusyQueue(
          PortAddr iop_base
       )
{
       int  count ;
       uchar stop_code ;

       count = 0 ;
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) != 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                             ASC_STOP_CLEAN_UP_BUSY_Q ) ;
           do
           {
               stop_code = AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) ;
               if( ( stop_code & ASC_STOP_CLEAN_UP_BUSY_Q ) == 0 ) break ;
               DvcSleepMilliSecond( 100 ) ;
           }while( count++ < 20 )  ;
       }/* if */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
int    AscCleanUpDiscQueue(
          PortAddr iop_base
       )
{
       int  count ;
       uchar stop_code ;

       count = 0 ;
       if( AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) != 0 )
       {
           AscWriteLramByte( iop_base, ASCV_STOP_CODE_B,
                             ASC_STOP_CLEAN_UP_DISC_Q ) ;
           do
           {
               stop_code = AscReadLramByte( iop_base, ASCV_STOP_CODE_B ) ;
               if( ( stop_code & ASC_STOP_CLEAN_UP_DISC_Q ) == 0 ) break ;
               DvcSleepMilliSecond( 100 ) ;
           }while( count++ < 20 )  ;
       }/* if */
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
**
** Note: interrupt should not be disabled
** ------------------------------------------------------------------ */
int    AscWaitTixISRDone(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar target_ix
       )
{
       uchar  cur_req ;
       uchar  tid_no ;

       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       while( TRUE )
       {
           if( ( cur_req = asc_dvc->cur_dvc_qng[ tid_no ] ) == 0 )
           {
               break ;
           }/* if */
/*
** if no interrupt coming back within xx second
** done queues are probably all processed ?
*/
           DvcSleepMilliSecond( 100L ) ;
           if( asc_dvc->cur_dvc_qng[ tid_no ] == cur_req )
           {
               break ;
           }/* if */
       }/* while */
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
**
** Note: interrupt should not be disabled
** ------------------------------------------------------------------ */
int    AscWaitISRDone(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int  tid ;

       for( tid = 0 ; tid <= ASC_MAX_TID ; tid++ )
       {
            AscWaitTixISRDone( asc_dvc, (uchar) ASC_TID_TO_TIX( tid ) ) ;
       }/* for */
       return( 1 ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ulong  AscGetOnePhyAddr(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar dosfar *buf_addr,
          ulong buf_size
       )
{
       ASC_MIN_SG_HEAD sg_head ;

       sg_head.entry_cnt = ASC_MIN_SG_LIST ;
       if( DvcGetSGList( asc_dvc, ( uchar dosfar *)buf_addr,
           buf_size, ( ASC_SG_HEAD dosfar *)&sg_head ) != buf_size )
       {
           return( 0L ) ;
       }/* if */
       if( sg_head.entry_cnt > 1 )
       {
           return( 0L ) ;
       }/* if */
       return( sg_head.sg_list[ 0 ].addr ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_q.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_q.c
**
*/

#include "ascinc.h"

#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16

uchar   _syn_offset_one_disable_cmd[ ASC_SYN_OFFSET_ONE_DISABLE_LIST ] =
        {
           SCSICMD_Inquiry,
           SCSICMD_RequestSense,
           SCSICMD_ReadCapacity,
           SCSICMD_ReadTOC,
           SCSICMD_ModeSelect6,
           SCSICMD_ModeSense6,
           SCSICMD_ModeSelect10,
           SCSICMD_ModeSense10,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF,
           0xFF
        };

/* --------------------------------------------------------------------
** you should call the function with scsiq->q1.status set to QS_READY
**
** if this function return code is other than 0 or 1
** user must regard the request as error !
**
** if queue is copied to local RAM, scsiq->q1.status = QS_FREE
** if queue is link into busy list, scsiq->q1.status = QS_BUSY
** ----------------------------------------------------------------- */
int    AscExeScsiQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq
       )
{
       PortAddr iop_base ;
       int    last_int_level ;
       int    sta ;
       int    n_q_required ;
       int    disable_syn_offset_one_fix ;
       int    i;
       ulong  addr ;
       ASC_EXE_CALLBACK  asc_exe_callback ;
       ushort sg_entry_cnt ;
       ushort sg_entry_cnt_minus_one ;
       uchar  target_ix ;
       uchar  tid_no ;
       uchar  sdtr_data ;
       uchar  extra_bytes ;
       uchar  scsi_cmd ;
       uchar  disable_cmd;
       ASC_SG_HEAD dosfar *sg_head ;
       ulong  data_cnt ;

#if CC_LINK_BUSY_Q
       ASC_SCSI_Q dosfar *scsiq_tail ;
       ASC_SCSI_Q dosfar *scsiq_next ;
       ASC_SCSI_Q dosfar *scsiq_prev ;
#endif /* CC_LINK_BUSY_Q */

       iop_base = asc_dvc->iop_base ;

#if CC_SCAM
       if( asc_dvc->redo_scam )
       {
           if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
           {
               AscSCAM( asc_dvc ) ;
           }/* if */
       }
#endif
       sg_head = scsiq->sg_head ;
       asc_exe_callback = ( ASC_EXE_CALLBACK )asc_dvc->exe_callback ;
       if( asc_dvc->err_code != 0 ) return( ERR ) ;
       if( scsiq == ( ASC_SCSI_Q dosfar *)0L )
       {
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SCSIQ_NULL_PTR ) ;
           return( ERR ) ;
       }/* if */

       scsiq->q1.q_no = 0 ;
       if(
           ( scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES ) == 0
         )
       {
           scsiq->q1.extra_bytes = 0 ;
       }
       sta = 0 ;
       target_ix = scsiq->q2.target_ix ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;

       n_q_required = 1 ; /* needed for CC_LINK_BUSY */

       if( scsiq->cdbptr[ 0 ] == SCSICMD_RequestSense )
       {
           /*
            * Always redo SDTR before issuing a Request Sense command.
            * SDTR is redone regardless of 'sdtr_done'.
            *
            * The request sense queue is always an urgent queue.
            */
           if ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0)
           {
               asc_dvc->sdtr_done &= ~scsiq->q1.target_id ;
               sdtr_data = AscGetMCodeInitSDTRAtID( iop_base, tid_no ) ;
               AscMsgOutSDTR( asc_dvc,
                              asc_dvc->sdtr_period_tbl[ ( sdtr_data >> 4 ) & ( uchar )(asc_dvc->max_sdtr_index-1) ],
                              ( uchar )( sdtr_data & ( uchar )ASC_SYN_MAX_OFFSET ) ) ;
               scsiq->q1.cntl |= ( QC_MSG_OUT | QC_URGENT ) ;
           }/* if */
       }/* if */
/*
** enter critical section
*/
       last_int_level = DvcEnterCritical( ) ;
       if( asc_dvc->in_critical_cnt != 0 )
       {
           DvcLeaveCritical( last_int_level ) ;
           AscSetLibErrorCode( asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY ) ;
           return( ERR ) ;
       }/* if */

       asc_dvc->in_critical_cnt++ ;
       if( ( scsiq->q1.cntl & QC_SG_HEAD ) != 0 )
       {
/*
** SG_LIST QUEUE
*/
           if( ( sg_entry_cnt = sg_head->entry_cnt ) == 0 )
           {
               asc_dvc->in_critical_cnt-- ;
               DvcLeaveCritical( last_int_level ) ;
               return( ERR ) ;
           }/* if */
           if( sg_entry_cnt > ASC_MAX_SG_LIST )
           {
/*
** A too big SG list !
*/
               return( ERR ) ;
           }/* if */
           if( sg_entry_cnt == 1 )
           {
               scsiq->q1.data_addr = sg_head->sg_list[ 0 ].addr ;
               scsiq->q1.data_cnt = sg_head->sg_list[ 0 ].bytes ;
               scsiq->q1.cntl &= ~( QC_SG_HEAD | QC_SG_SWAP_QUEUE ) ;
           }/* if */
           else
           {
#if CC_CHK_AND_COALESCE_SG_LIST
               AscCoalesceSgList( scsiq );
               sg_entry_cnt = sg_head->entry_cnt ;
#endif
           }/* else */


           sg_entry_cnt_minus_one = sg_entry_cnt - 1 ;

#if CC_DEBUG_SG_LIST
           if( asc_dvc->bus_type & ( ASC_IS_ISA | ASC_IS_VL | ASC_IS_EISA ) )
           {
               for( i = 0 ; i < sg_entry_cnt_minus_one ; i++ )
               {
                    /* _asc_sg_entry = i ; */
                    /* _asc_xfer_addr = sg_head->sg_list[ i ].addr ; */
                    /* _asc_xfer_cnt = sg_head->sg_list[ i ].bytes ; */
                    addr = sg_head->sg_list[ i ].addr + sg_head->sg_list[ i ].bytes ;

                    if( ( ( ushort )addr & 0x0003 ) != 0 )
                    {
                        asc_dvc->in_critical_cnt-- ;
                        DvcLeaveCritical( last_int_level ) ;
                        AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SG_LIST_ODD_ADDRESS ) ;
                        return( ERR ) ;
                    }/* if */
               }/* for */
           }/* if check SG list validity */
#endif /* #if CC_DEBUG_SG_LIST */
       }

       scsi_cmd = scsiq->cdbptr[ 0 ] ;
       disable_syn_offset_one_fix = FALSE ;
       if(
            ( asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id )
            && !( asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id )
         )
       {
/*
**
** calculate transfer data length
**
*/
           if( scsiq->q1.cntl & QC_SG_HEAD )
           {
               data_cnt = 0 ;
               for( i = 0 ; i < sg_entry_cnt ; i++ )
               {
                    data_cnt += sg_head->sg_list[i].bytes ;
               }
           }
           else
           {
               data_cnt = scsiq->q1.data_cnt ;
           }
           if( data_cnt != 0UL )
           {
               if( data_cnt < 512UL )
               {
                   disable_syn_offset_one_fix = TRUE;
               }
               else
               {
                   for( i = 0 ; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST ; i++ )
                   {
                        disable_cmd = _syn_offset_one_disable_cmd[ i ] ;
                        if( disable_cmd == 0xFF )
                        {
                            break;
                        }
                        if( scsi_cmd == disable_cmd )
                        {
                            disable_syn_offset_one_fix = TRUE;
                            break;
                        }
                   }
               }/* else */
           }
       }

       if( disable_syn_offset_one_fix )
       {
           scsiq->q2.tag_code &= ~M2_QTAG_MSG_SIMPLE ;
           scsiq->q2.tag_code |= ( ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |
                                   ASC_TAG_FLAG_DISABLE_DISCONNECT ) ;
       }
       else
       {
           scsiq->q2.tag_code &= 0x23 ;
       }

       if( ( scsiq->q1.cntl & QC_SG_HEAD ) != 0 )
       {
           if( asc_dvc->bug_fix_cntl )
           {
               if( asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB )
               {
                   if(
                       ( scsi_cmd == SCSICMD_Read6 )
                       || ( scsi_cmd == SCSICMD_Read10 )
                     )
                   {
                        addr = sg_head->sg_list[ sg_entry_cnt_minus_one ].addr +
                               sg_head->sg_list[ sg_entry_cnt_minus_one ].bytes ;
                        extra_bytes = ( uchar )( ( ushort )addr & 0x0003 ) ;
                        if(
                            ( extra_bytes != 0 )
                            && ( ( scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES ) == 0 )
                          )
                        {
                            scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES ;
                            scsiq->q1.extra_bytes = extra_bytes ;
                            sg_head->sg_list[ sg_entry_cnt_minus_one ].bytes -= ( ulong )extra_bytes ;
                        }/* if */
                   }/* if */
               }/* if */
           }/* if bug fix */


           sg_head->entry_to_copy = sg_head->entry_cnt ;
           n_q_required = AscSgListToQueue( sg_entry_cnt ) ;

#if CC_LINK_BUSY_Q
           scsiq_next = ( ASC_SCSI_Q dosfar *)asc_dvc->scsiq_busy_head[ tid_no ] ;
           if( scsiq_next != ( ASC_SCSI_Q dosfar *)0L )
           {
               goto link_scisq_to_busy_list ;
           }/* if */
#endif /* CC_LINK_BUSY_Q */

           if(
               ( AscGetNumOfFreeQueue( asc_dvc, target_ix, (uchar) n_q_required)
                 >= ( uint )n_q_required ) ||
               ( ( scsiq->q1.cntl & QC_URGENT ) != 0 )
             )
           {
               if( ( sta = AscSendScsiQueue( asc_dvc, scsiq,
                   (uchar) n_q_required ) ) == 1 )
               {
/*
** leave critical section
*/
                   asc_dvc->in_critical_cnt-- ;
                   if( asc_exe_callback != 0 )
                   {
                       ( *asc_exe_callback )( asc_dvc, scsiq ) ;
                   }/* if */
                   DvcLeaveCritical( last_int_level ) ;
                   return( sta ) ;
               }/* if */
           }/* if */
       }/* if */
       else
       {
/*
** NON SG_LIST QUEUE
*/
           if( asc_dvc->bug_fix_cntl )
           {
               if( asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB )
               {
               /*
               ** SG LIST
               ** fix PCI data in address not dword boundary
               **
               */
                  if(
                      ( scsi_cmd == SCSICMD_Read6 )
                      || ( scsi_cmd == SCSICMD_Read10 )
                    )
                  {
                       addr = scsiq->q1.data_addr + scsiq->q1.data_cnt ;
                       extra_bytes = ( uchar )( ( ushort )addr & 0x0003 ) ;
                       if(
                           ( extra_bytes != 0 )
                           && ( ( scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES ) == 0 )
                         )
                       {
                           if( ( ( ushort )scsiq->q1.data_cnt & 0x01FF ) == 0 )
                           {
    /*
    ** if required addr fix
    ** we only add one byte when dma size is a multiple of 512 byte
    */
                               /*  scsiq->q1.data_cnt += ( 4 - ( addr & 0x0003 ) ) ; */
                               scsiq->q2.tag_code |= ASC_TAG_FLAG_EXTRA_BYTES ;
                               scsiq->q1.data_cnt -= ( ulong )extra_bytes ;
                               scsiq->q1.extra_bytes = extra_bytes ;
                           }/* if */
                       }/* if */
                  }/* if */
               }/* if */
           }/* if bug fix */

/*
**  A single queue allocation must satisfy (last_q_shortage+1)
**  to enabled a failed SG_LIST request
**
**  the last_q_shortage will be clear to zero when last
**  failed QG_LIST request finally go through
**
**  the initial value of last_q_shortage should be zero
*/
           n_q_required = 1 ;

#if CC_LINK_BUSY_Q
           scsiq_next = ( ASC_SCSI_Q dosfar *)asc_dvc->scsiq_busy_head[ tid_no ] ;
           if( scsiq_next != ( ASC_SCSI_Q dosfar *)0L )
           {
               goto link_scisq_to_busy_list ;
           }/* if */
#endif /* CC_LINK_BUSY_Q */
           if( ( AscGetNumOfFreeQueue( asc_dvc, target_ix, 1 ) >= 1 ) ||
               ( ( scsiq->q1.cntl & QC_URGENT ) != 0 ) )
           {
               if( ( sta = AscSendScsiQueue( asc_dvc, scsiq,
                   (uchar) n_q_required ) ) == 1 )
               {
/*
** sta returned, could be 1, -1, 0
*/
                   asc_dvc->in_critical_cnt-- ;
                   if( asc_exe_callback != 0 )
                   {
                       ( *asc_exe_callback )( asc_dvc, scsiq ) ;
                   }/* if */
                   DvcLeaveCritical( last_int_level ) ;
                   return( sta ) ;
               }/* if */
           }/* if */
       }/* else */

#if CC_LINK_BUSY_Q
       if( sta == 0 )
       {
/*
**  we must put queue into busy list
*/
link_scisq_to_busy_list:
           scsiq->ext.q_required = n_q_required ;
           if( scsiq_next == ( ASC_SCSI_Q dosfar *)0L )
           {
               asc_dvc->scsiq_busy_head[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
               asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
               scsiq->ext.next = ( ASC_SCSI_Q dosfar *)0L ;
               scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
               scsiq->q1.status = QS_BUSY ;
               sta = 1 ;
           }/* if */
           else
           {
               scsiq_tail = ( ASC_SCSI_Q dosfar *)asc_dvc->scsiq_busy_tail[ tid_no ] ;
               if( scsiq_tail->ext.next == ( ASC_SCSI_Q dosfar *)0L )
               {
                   if( ( scsiq->q1.cntl & QC_URGENT ) != 0 )
                   {
/*
** link urgent queue into head of queue
*/
                       asc_dvc->scsiq_busy_head[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
                       scsiq->ext.next = scsiq_next ;
                       scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
                   }/* if */
                   else
                   {
                       if( scsiq->ext.cntl & QCX_SORT )
                       {
                           do
                           {
                               scsiq_prev = scsiq_next ;
                               scsiq_next = scsiq_next->ext.next ;
                               if( scsiq->ext.lba < scsiq_prev->ext.lba ) break ;
                           }while( scsiq_next != ( ASC_SCSI_Q dosfar *)0L ) ;
/*
** link queue between "scsiq_prev" and "scsiq_next"
**
*/
                           scsiq_prev->ext.next = scsiq ;
                           scsiq->ext.next = scsiq_next ;
                           if( scsiq_next == ( ASC_SCSI_Q dosfar *)0L )
                           {
                               asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
                           }/* if */
                           scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
                       }/* if */
                       else
                       {
/*
** link non-urgent queue into tail of queue
*/
                           scsiq_tail->ext.next = ( ASC_SCSI_Q dosfar *)scsiq ;
                           asc_dvc->scsiq_busy_tail[ tid_no ] = ( ASC_SCSI_Q dosfar *)scsiq ;
                           scsiq->ext.next = ( ASC_SCSI_Q dosfar *)0L ;
                           scsiq->ext.join = ( ASC_SCSI_Q dosfar *)0L ;
                       }/* else */
                   }/* else */
                   scsiq->q1.status = QS_BUSY ;
                   sta = 1 ;
               }/* if */
               else
               {
/*
** fatal error !
*/
                   AscSetLibErrorCode( asc_dvc, ASCQ_ERR_SCSIQ_BAD_NEXT_PTR ) ;
                   sta = ERR ;
               }/* else */
           }/* else */
       }/* if */
#endif /* CC_LINK_BUSY_Q */
       asc_dvc->in_critical_cnt-- ;
       DvcLeaveCritical( last_int_level ) ;
       return( sta ) ;
}

/* --------------------------------------------------------------------
** return 1 if command issued
** return 0 if command not issued
** ----------------------------------------------------------------- */
int    AscSendScsiQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq,
          uchar n_q_required
       )
{
       PortAddr iop_base ;
       uchar  free_q_head ;
       uchar  next_qp ;
       uchar  tid_no ;
       uchar  target_ix ;
       int    sta ;

       iop_base = asc_dvc->iop_base ;
       target_ix = scsiq->q2.target_ix ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       sta = 0 ;
       free_q_head = ( uchar )AscGetVarFreeQHead( iop_base ) ;
       if( n_q_required > 1 )
       {
           if( ( next_qp = AscAllocMultipleFreeQueue( iop_base,
               free_q_head, ( uchar )( n_q_required ) ) )
               != ( uchar )ASC_QLINK_END )
           {
               asc_dvc->last_q_shortage = 0 ; /* clear the need to reserve queue for SG list */
               scsiq->sg_head->queue_cnt = n_q_required - 1 ;
               scsiq->q1.q_no = free_q_head ;

               if( ( sta = AscPutReadySgListQueue( asc_dvc, scsiq,
                   free_q_head ) ) == 1 )
               {
/*
** sta returned, could be 1, -1, 0
*/

#if CC_WRITE_IO_COUNT
                   asc_dvc->req_count++ ;
#endif /* CC_WRITE_IO_COUNT */

                   AscPutVarFreeQHead( iop_base, next_qp ) ;
                   asc_dvc->cur_total_qng += ( uchar )( n_q_required ) ;
                   asc_dvc->cur_dvc_qng[ tid_no ]++ ;
               }/* if */
               return( sta ) ;
           }/* if */
       }/* if */
       else if( n_q_required == 1 )
       {
/*
**
** DO NOT use "scsiq->sg_head", it may not have buffer at all
**
** set scsiq->sg_heah->queue_cnt = 0 ;
** is not necessary
**
*/
           if( ( next_qp = AscAllocFreeQueue( iop_base,
               free_q_head ) ) != ASC_QLINK_END )
           {
        /*
        ** leave critical section
        */
               scsiq->q1.q_no = free_q_head ;
               if( ( sta = AscPutReadyQueue( asc_dvc, scsiq,
                              free_q_head ) ) == 1 )
               {

#if CC_WRITE_IO_COUNT
                   asc_dvc->req_count++ ;
#endif /* CC_WRITE_IO_COUNT */

                   AscPutVarFreeQHead( iop_base, next_qp ) ;
                   asc_dvc->cur_total_qng++ ;
                   asc_dvc->cur_dvc_qng[ tid_no ]++ ;
               }/* if */
               return( sta ) ;
           }/* if */
       }/* else */
       return( sta ) ;
}

/* -----------------------------------------------------------
** sg_list: number of SG list entry
**
** return number of queue required from number of sg list
**
** -------------------------------------------------------- */
int    AscSgListToQueue(
          int sg_list
       )
{
       int  n_sg_list_qs ;

       n_sg_list_qs = ( ( sg_list - 1 ) / ASC_SG_LIST_PER_Q ) ;
       if( ( ( sg_list - 1 ) % ASC_SG_LIST_PER_Q ) != 0 ) n_sg_list_qs++ ;
       return( n_sg_list_qs + 1 ) ;
}

/* -----------------------------------------------------------
**
** n_queue: number of queue used
**
** return number of sg list available from number of queue(s)
** n_queue should equal 1 to n
**
** -------------------------------------------------------- */
int    AscQueueToSgList(
          int n_queue
       )
{
       if( n_queue == 1 ) return( 1 ) ;
       return( ( ASC_SG_LIST_PER_Q * ( n_queue - 1 ) ) + 1 ) ;
}

/* -----------------------------------------------------------
** Description:
** this routine will return number free queues that is available
** to next AscExeScsiQueue() command
**
**  parameters
**
**  asc_dvc: ASC_DVC_VAR struct
**  target_ix: a combination of target id and LUN
**  n_qs: number of queue required
**
** return number of queue available
** return 0 if no queue is available
** -------------------------------------------------------- */
uint   AscGetNumOfFreeQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar target_ix,
          uchar n_qs
       )
{
       uint  cur_used_qs ;
       uint  cur_free_qs ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       uchar tid_no ;

       target_id = ASC_TIX_TO_TARGET_ID( target_ix ) ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       if( ( asc_dvc->unit_not_ready & target_id ) ||
           ( asc_dvc->queue_full_or_busy & target_id ) )
       {
           return( 0 ) ;
       }/* if */
       if( n_qs == 1 )
       {
           cur_used_qs = ( uint )asc_dvc->cur_total_qng +
                          ( uint )asc_dvc->last_q_shortage +
                          ( uint )ASC_MIN_FREE_Q ;
       }/* if */
       else
       {
           cur_used_qs = ( uint )asc_dvc->cur_total_qng +
                         ( uint )ASC_MIN_FREE_Q ;
       }/* else */

       if( ( uint )( cur_used_qs + n_qs ) <= ( uint )asc_dvc->max_total_qng )
       {
           cur_free_qs = ( uint )asc_dvc->max_total_qng - cur_used_qs ;
           if( asc_dvc->cur_dvc_qng[ tid_no ] >=
               asc_dvc->max_dvc_qng[ tid_no ] )
           {
               return( 0 ) ;
           }/* if */
           return( cur_free_qs ) ;
       }/* if */
/*
**
** allocating queue failed
** we must not let single queue request from using up the resource
**
*/
       if( n_qs > 1 )
       {
          if(
              ( n_qs > asc_dvc->last_q_shortage )
              && ( n_qs <= ( asc_dvc->max_total_qng - ASC_MIN_FREE_Q ) )
/*
**
** 8/16/96
** Do not set last_q_shortage to more than maximum possible queues
**
*/
            )
          {
              asc_dvc->last_q_shortage = n_qs ;
          }/* if */
       }/* if */
       return( 0 ) ;
}

/* ---------------------------------------------------------------------
**
** Description: copy a queue into ASC-1000 ready queue list
**
** Parameters:
**
**   asc_dvc - the driver's global variable
**   scsiq   - the pointer to ASC-1000 queue
**
** Return values:
**   1 - successful
**   0 - busy
**   else - failed, possibly fatal error
**
** See Also:
**   AscAspiPutReadySgListQueue( )
**
** ------------------------------------------------------------------ */
int    AscPutReadyQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq,
          uchar q_no
       )
{
       ushort  q_addr ;
       uchar   tid_no ;
       uchar   sdtr_data ;
       uchar   syn_period_ix ;
       uchar   syn_offset ;
       PortAddr  iop_base ;

       iop_base = asc_dvc->iop_base ;

       /*
        * If we need to send extended message and bus device reset
        * at the same time, the bus device reset message will be sent
        * first.
        *
        * This is the only case where 'sdtr_done' is used to prevent SDTR
        * from being redone. If the target's 'sdtr_done' bit is set here
        * SDTR is not done.
        */
       if( ( ( asc_dvc->init_sdtr & scsiq->q1.target_id ) != 0 ) &&
           ( ( asc_dvc->sdtr_done & scsiq->q1.target_id ) == 0 ) )
       {
/*
** If host adapter initiate syn data xfer request
*/
           tid_no = ASC_TIX_TO_TID( scsiq->q2.target_ix ) ;
/*
** Get sync xfer information
*/

           sdtr_data = AscGetMCodeInitSDTRAtID( iop_base, tid_no ) ;
           syn_period_ix = ( sdtr_data >> 4 ) & ( asc_dvc->max_sdtr_index - 1 ) ;
           syn_offset = sdtr_data & ASC_SYN_MAX_OFFSET ;
           AscMsgOutSDTR( asc_dvc,
                          asc_dvc->sdtr_period_tbl[ syn_period_ix ],
                          syn_offset ) ;
           scsiq->q1.cntl |= QC_MSG_OUT ;
           /*
           ** BUG, DATE: 3-11-94, if the device selection timeout
           ** we will have set the bit as done
           **
           ** asc_dvc->sdtr_done |= scsiq->q1.target_id ;
           */
       }/* if */

       q_addr = ASC_QNO_TO_QADDR( q_no ) ;
/*
** DATE: 12/21/94
** the new microcode depends entirely on tag_code bit 5 set
** to do tagged queuing or not.
**
** we must make sure that bit 5 is cleared for non-tagged queuing device !
*/
       if( ( scsiq->q1.target_id & asc_dvc->use_tagged_qng ) == 0 )
       {
           scsiq->q2.tag_code &= ~M2_QTAG_MSG_SIMPLE ;
       }/* if */
/*
** DATE: 12/19/94
** always set status as free, to indicate that queue is send to RISC
** also means the scsiq can be reused
*/
       scsiq->q1.status = QS_FREE ;

/*
** copy from PC to RISC local RAM
**
** copy queue to RISC local ram
*/
       AscMemWordCopyToLram( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_CDB_BEG ),
                           ( ushort dosfar *)scsiq->cdbptr,
                           ( ushort )( ( ushort )scsiq->q2.cdb_len >> 1 ) ) ;

#if !CC_LITTLE_ENDIAN_HOST
       AscAdjEndianScsiQ( scsiq ) ;
#endif

       DvcPutScsiQ( iop_base,
                  ( ushort )( q_addr+( ushort )ASC_SCSIQ_CPY_BEG ),
                  ( ushort dosfar *)&scsiq->q1.cntl,
          ( ushort )( ((( sizeof(ASC_SCSIQ_1)+sizeof(ASC_SCSIQ_2))/2)-1) ) ) ;
/*
**  write req_count number as reference
*/
#if CC_WRITE_IO_COUNT
       AscWriteLramWord( iop_base,
                         ( ushort )( q_addr+( ushort )ASC_SCSIQ_W_REQ_COUNT ),
                         ( ushort )asc_dvc->req_count ) ;

#endif /* CC_WRITE_IO_COUNT */

/*
** verify local ram copy if the bit is zero
*/
#if CC_VERIFY_LRAM_COPY
       if( ( asc_dvc->dvc_cntl & ASC_CNTL_NO_VERIFY_COPY ) == 0 )
       {
        /*
        ** verify SCSI CDB
        */
           if( AscMemWordCmpToLram( iop_base,
                            ( ushort )( q_addr+( ushort )ASC_SCSIQ_CDB_BEG ),
                            ( ushort dosfar *)scsiq->cdbptr,
                            ( ushort )( scsiq->q2.cdb_len >> 1 ) ) != 0 )
           {
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_LOCAL_MEM ) ;
               return( ERR ) ;
           }/* if */
/*
** verify queue data
*/
           if( AscMemWordCmpToLram( iop_base,
                           ( ushort )( q_addr+( ushort )ASC_SCSIQ_CPY_BEG ),
                           ( ushort dosfar *)&scsiq->q1.cntl,
               ( ushort )((( sizeof(ASC_SCSIQ_1)+sizeof(ASC_SCSIQ_2) )/2)-1) )
                                   != 0 )
           {
               AscSetLibErrorCode( asc_dvc, ASCQ_ERR_LOCAL_MEM ) ;
               return( ERR ) ;
           }/* if */
       }/* if */
#endif /* #if CC_VERIFY_LRAM_COPY */

#if CC_CLEAR_DMA_REMAIN

       AscWriteLramDWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_ADDR ), 0UL ) ;
       AscWriteLramDWord( iop_base,
           ( ushort )( q_addr+( ushort )ASC_SCSIQ_DW_REMAIN_XFER_CNT ), 0UL ) ;

#endif /* CC_CLEAR_DMA_REMAIN */

    /*
    ** write queue status as ready
    */
       AscWriteLramWord( iop_base,
                 ( ushort )( q_addr+( ushort )ASC_SCSIQ_B_STATUS ),
       ( ushort )( ( ( ushort )scsiq->q1.q_no << 8 ) | ( ushort )QS_READY ) ) ;
       return( 1 ) ;
}

/* ---------------------------------------------------------------------
** Description: copy a queue into ASC-1000 ready queue list
**
** Parameters:
**
**   asc_dvc - the driver's global variable
**   scsiq   - the pointer to ASC-1000 queue
**   cdb_blk - the pointer to SCSI CDB
**
**   note: the scsiq->cdb field is not used in the function call
**
** Return values:
**   1 - successful
**   0 - failed
**
** See Also:
**   AscPutReadyQueue( )
**
** ------------------------------------------------------------------ */
int    AscPutReadySgListQueue(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          REG ASC_SCSI_Q dosfar *scsiq,
          uchar q_no
       )
{
       int     sta ;
       int     i ;
       ASC_SG_HEAD dosfar *sg_head ;
       ASC_SG_LIST_Q scsi_sg_q ;
       ulong  saved_data_addr ;
       ulong  saved_data_cnt ;
       PortAddr  iop_base ;
       ushort  sg_list_dwords ;
       ushort  sg_index ;
       ushort  sg_entry_cnt ;
       ushort  q_addr ;
       uchar   next_qp ;

       iop_base = asc_dvc->iop_base ;
/*
** we put the first SG_LIST in sg head !
*/
       sg_head = scsiq->sg_head ;
/*
**  we will destroy: scsiq->q1.data_addr
**                   scsiq->q1.data_cnt in putting SG list
**
**  we should restore them
*/
       saved_data_addr = scsiq->q1.data_addr ;
       saved_data_cnt = scsiq->q1.data_cnt ;
       scsiq->q1.data_addr = sg_head->sg_list[ 0 ].addr ;
       scsiq->q1.data_cnt = sg_head->sg_list[ 0 ].bytes ;
       sg_entry_cnt = sg_head->entry_cnt - 1 ;
       if( sg_entry_cnt != 0 )
       {
           scsiq->q1.cntl |= QC_SG_HEAD ;
           q_addr = ASC_QNO_TO_QADDR( q_no ) ;
           sg_index = 1 ;
           scsiq->q1.sg_queue_cnt = (uchar) sg_head->queue_cnt ;
           scsi_sg_q.sg_head_qp = q_no ;
           scsi_sg_q.cntl = QCSG_SG_XFER_LIST ;
           for( i = 0 ; i < sg_head->queue_cnt ; i++ )
           {
                scsi_sg_q.seq_no = i + 1 ;
                if( sg_entry_cnt > ASC_SG_LIST_PER_Q )
                {
                    sg_list_dwords = ( uchar )( ASC_SG_LIST_PER_Q * 2 ) ;
                    sg_entry_cnt -= ASC_SG_LIST_PER_Q ;
                    if( i == 0 )
                    {
                        scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q ;
                        scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q ;
                    }/* if */
                    else
                    {
                        scsi_sg_q.sg_list_cnt = ASC_SG_LIST_PER_Q - 1 ;
                        scsi_sg_q.sg_cur_list_cnt = ASC_SG_LIST_PER_Q - 1 ;
                    }/* else */
                }/* if */
                else
                {
/*
** is last of SG LIST queue
** we no longer rely on
*/
                    scsi_sg_q.cntl |= QCSG_SG_XFER_END ;
                    sg_list_dwords = sg_entry_cnt << 1 ; /* equals sg_entry_cnt * 2 */
                    if( i == 0 )
                    {
                        scsi_sg_q.sg_list_cnt = (uchar) sg_entry_cnt ;
                        scsi_sg_q.sg_cur_list_cnt = (uchar) sg_entry_cnt ;
                    }/* if */
                    else
                    {
                        scsi_sg_q.sg_list_cnt = sg_entry_cnt - 1 ;
                        scsi_sg_q.sg_cur_list_cnt = sg_entry_cnt - 1 ;
                    }/* else */
                    sg_entry_cnt = 0 ;
                }/* else */
                next_qp = AscReadLramByte( iop_base,
                             ( ushort )( q_addr+ASC_SCSIQ_B_FWD ) ) ;
                scsi_sg_q.q_no = next_qp ;
                q_addr = ASC_QNO_TO_QADDR( next_qp ) ;

                AscMemWordCopyToLram( iop_base,
                             ( ushort )( q_addr+ASC_SCSIQ_SGHD_CPY_BEG ),
                             ( ushort dosfar *)&scsi_sg_q,
                             ( ushort )( sizeof( ASC_SG_LIST_Q ) >> 1 ) ) ;

                AscMemDWordCopyToLram( iop_base,
                             ( ushort )( q_addr+ASC_SGQ_LIST_BEG ),
                             ( ulong dosfar *)&sg_head->sg_list[ sg_index ],
                             ( ushort )sg_list_dwords ) ;

                sg_index += ASC_SG_LIST_PER_Q ;
           }/* for */
       }/* if */
       else
       {
/*
** this should be a fatal error !
*/
           scsiq->q1.cntl &= ~QC_SG_HEAD ;
       }/* else */
       sta = AscPutReadyQueue( asc_dvc, scsiq, q_no ) ;
/*
** restore the modified field that used as first sg list
**
** we restore them just in case these fields are used for other purposes
**
*/
       scsiq->q1.data_addr = saved_data_addr ;
       scsiq->q1.data_cnt = saved_data_cnt ;
       return( sta ) ;
}

#if CC_USE_AscAbortSRB

/* -----------------------------------------------------------
** Description: abort a SRB in ready ( active ) queue list
**
**              the srb_ptr should hold scsiq->q2.srb_ptr that
**              is past to AscExeScsiQueue()
**
** return value:
** TRUE(1): the queue is successfully aborted
**          you should receive a callback later
**
** FALSE(0): the srb_ptr cannot be found in active queue list
**           most likely the queue is done
**
** ERR(-1): the RISC has encountered a fatal error
**          RISC does not response to halt command from host
**
** -------------------------------------------------------- */
int    AscAbortSRB(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong srb_ptr
       )
{
       int  sta ;
       ASC_SCSI_BIT_ID_TYPE saved_unit_not_ready ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       sta = ERR ;
       saved_unit_not_ready = asc_dvc->unit_not_ready ;
       asc_dvc->unit_not_ready = 0xFF ;
       AscWaitISRDone( asc_dvc ) ;
       if( AscStopQueueExe( iop_base ) == 1 )
       {
           if( AscRiscHaltedAbortSRB( asc_dvc, srb_ptr ) == 1 )
           {
               sta = 1 ;
               AscCleanUpBusyQueue( iop_base ) ;
               AscStartQueueExe( iop_base ) ;
/*
** wait until ISR all come back
*/
#if 0
               if( AscWaitQTailSync( iop_base ) != 1 )
               {
                   if( AscStopQueueExe( iop_base ) == 1 )
                   {
                       AscCleanUpDiscQueue( iop_base ) ;
                       AscStartQueueExe( iop_base ) ;
                   }/* if */
               }/* if */
#endif
           }/* if */
           else
           {
               sta = 0 ;
               AscStartQueueExe( iop_base ) ;
           }/* else */
       }/* if */
       asc_dvc->unit_not_ready = saved_unit_not_ready ;
       return( sta ) ;
}
#endif /* CC_USE_AscAbortSRB */

#if CC_USE_AscResetDevice

/* -----------------------------------------------------------
** Description: abort all ready ( active ) queue list
**              of a specific target_ix ( id and lun )
**
**              after abort completed
**              send a bus device reset message to device.
**              this will result to a selection timeout if
**              device power is turn off
**
** Note:
**    h/w interrupt should be enabled when calling the function
**
** return values:
** ERR (-1): a fatal error occured
** TRUE: abort and reset device successfully
** FALSE: reset device failed
** -------------------------------------------------------- */
int    AscResetDevice(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar target_ix
       )
{
       PortAddr iop_base ;
       int    sta ;
       uchar  tid_no ;
       ASC_SCSI_BIT_ID_TYPE target_id ;
       int    i ;
       ASC_SCSI_REQ_Q scsiq_buf ;
       ASC_SCSI_REQ_Q dosfar *scsiq ;
       uchar dosfar *buf ;
       ASC_SCSI_BIT_ID_TYPE  saved_unit_not_ready ;
/*
**
*/
       iop_base = asc_dvc->iop_base ;
       tid_no = ASC_TIX_TO_TID( target_ix ) ;
       target_id = ASC_TID_TO_TARGET_ID( tid_no ) ;
       saved_unit_not_ready = asc_dvc->unit_not_ready ;
       asc_dvc->unit_not_ready = target_id ;
       sta = ERR ;
       AscWaitTixISRDone( asc_dvc, target_ix ) ;
       if( AscStopQueueExe( iop_base ) == 1 )
       {
           if( AscRiscHaltedAbortTIX( asc_dvc, target_ix ) == 1 )
           {

               AscCleanUpBusyQueue( iop_base ) ;
               AscStartQueueExe( iop_base ) ;
/*
** wait cow come home
** it's OK if they don't, we can..., you know.
*/
               AscWaitTixISRDone( asc_dvc, target_ix ) ;
/*
** build a command to send bus device reset message to the target
*/
               sta = TRUE ;
               scsiq = ( ASC_SCSI_REQ_Q dosfar *)&scsiq_buf ;
               buf = ( uchar dosfar *)&scsiq_buf ;
               for( i = 0 ; i < sizeof( ASC_SCSI_REQ_Q ) ; i++ )
               {
                    *buf++ = 0x00 ;
               }/* for */
               /* scsiq->r2.flag = ( uchar )ASC_FLAG_SCSIQ_REQ ;  */
               /* scsiq->r2.srb_ptr = ( ulong )scsiq ;  */
               scsiq->r1.status = ( uchar )QS_READY ;
               scsiq->r2.cdb_len = 6 ;
               scsiq->r2.tag_code = M2_QTAG_MSG_SIMPLE ;
               scsiq->r1.target_id = target_id ;
/*
** NOTE: we do not reset the lun device
*/
               scsiq->r2.target_ix = ASC_TIDLUN_TO_IX( tid_no, 0 ) ;
               scsiq->cdbptr = ( uchar dosfar *)scsiq->cdb ;
/*
** we send a scsi q which will send a bus device reset message
** to device, and return,
** SCSI command in cdb will not be executed
**
** in case we are reset an active device, the queue has to be QC_URGENT
** in order to go thru
**
*/
               scsiq->r1.cntl = QC_NO_CALLBACK | QC_MSG_OUT | QC_URGENT ;
               AscWriteLramByte( asc_dvc->iop_base, ASCV_MSGOUT_BEG,
                                 M1_BUS_DVC_RESET ) ;
/*
** let next device reset go thru, clear not ready bit of the target
*/
               asc_dvc->unit_not_ready &= ~target_id ;
/*
** if sdtr_done is cleared, the reset device message cannot go through
*/
               asc_dvc->sdtr_done |= target_id ;
/*
** make this target ready, so we may send the command
*/
               if( AscExeScsiQueue( asc_dvc, ( ASC_SCSI_Q dosfar *)scsiq )
                   == 1 )
               {
                   asc_dvc->unit_not_ready = target_id ;
                   DvcSleepMilliSecond( 1000 ) ;
                   _AscWaitQDone( iop_base, ( ASC_SCSI_Q dosfar *)scsiq ) ;
                   if( AscStopQueueExe( iop_base ) == 1 )
                   {
/*
** since we send a reset message, every queue inside the drive
** will not coming back, we must clean up all disc queues
*/
                       AscCleanUpDiscQueue( iop_base ) ;
                       AscStartQueueExe( iop_base ) ;
                       if( asc_dvc->pci_fix_asyn_xfer & target_id )
                       {
/*
**
** PCI BUG FIX, Let ASYN as SYN 5MB( speed index 4 ) and offset 1
**
*/
                           AscSetRunChipSynRegAtID( iop_base, tid_no,
                                                    ASYN_SDTR_DATA_FIX_PCI_REV_AB ) ;
                       }/* if */

                       AscWaitTixISRDone( asc_dvc, target_ix ) ;
                   }/* if */
               }/* if */
               else
               {
/*
** command cannot go through !
*/

                   sta = 0 ;
               }/* else */
/*
** redo SDTR
*/
               asc_dvc->sdtr_done &= ~target_id ;
           }/* if */
           else
           {
               sta = ERR ;
               AscStartQueueExe( iop_base ) ;
           }/* else */
       }/* if */
       asc_dvc->unit_not_ready = saved_unit_not_ready ;
       return( sta ) ;
}

#endif /* CC_USE_AscResetDevice */

#if CC_USE_AscResetSB

/* -----------------------------------------------------------
** Descriptoion:
**   reset scsi bus and restart
**   this is a fatal error recovery function
**
** Function:
** 1. reset scsi bus and chip
**    - chip syn registers automatically cleared ( asyn xfer )
**    - the scsi device also reset to asyn xfer ( because of scsi bus reset )
** 2. reinit all variables, clear all error codes
** 3. reinit chip register(s)
**    - set syn register with pci_fix_asyn_xfer
** 4. restart chip
**
** Return Value:
** return TRUE(1) if successful
** return ERR if error occured
** -------------------------------------------------------- */
int    AscResetSB(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       int  sta ;
       int  i ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       asc_dvc->unit_not_ready = 0xFF ;
       sta = TRUE ;
       AscWaitISRDone( asc_dvc ) ;
       AscStopQueueExe( iop_base ) ;
/*
** always redo SDTN
*/
       asc_dvc->sdtr_done = 0 ;
       AscResetChipAndScsiBus( asc_dvc);
/*
** wait xx seconds after reset SCSI BUS
*/
       DvcSleepMilliSecond( ( ulong )( ( ushort )asc_dvc->scsi_reset_wait*1000 ) ) ;

#if CC_SCAM
       if( !( asc_dvc->dvc_cntl & ASC_CNTL_NO_SCAM ) )
       {
           AscSCAM( asc_dvc ) ;
       }/* if */
#endif
       AscReInitLram( asc_dvc ) ;

       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            asc_dvc->cur_dvc_qng[ i ] = 0 ;
            if( asc_dvc->pci_fix_asyn_xfer & ( ASC_SCSI_BIT_ID_TYPE )( 0x01 << i ) )
            {
/*
** CHIP MUST be halted to set syn register
*/
                AscSetChipSynRegAtID( iop_base, (uchar) i,
                    ASYN_SDTR_DATA_FIX_PCI_REV_AB ) ;
            }/* if */
       }/* for */

       asc_dvc->err_code = 0 ;

       AscSetPCAddr( iop_base, ASC_MCODE_START_ADDR ) ;
       if( AscGetPCAddr( iop_base ) != ASC_MCODE_START_ADDR )
       {
           sta = ERR ;
       }/* if */
       if( AscStartChip( iop_base ) == 0 )
       {
           sta = ERR ;
       }/* if */
       AscStartQueueExe( iop_base ) ;
       asc_dvc->unit_not_ready = 0 ;
       asc_dvc->queue_full_or_busy = 0 ;
       return( sta ) ;
}

#endif /* CC_USE_AscResetSB */

/* -----------------------------------------------------------
** write running chip syn register
** we must stop chip to perform the operation
**
** return TRUE  if successful
** return FALSE if error occured
** -------------------------------------------------------- */
int    AscSetRunChipSynRegAtID(
          PortAddr iop_base,
          uchar tid_no,
          uchar sdtr_data
       )
{
       int sta = FALSE ;

       if( AscHostReqRiscHalt( iop_base ) )
       {
           sta = AscSetChipSynRegAtID( iop_base, tid_no, sdtr_data ) ;
/*
** ucode var "stop_code" should be zero
** all we need is restart the chip
*/
           AscStartChip( iop_base ) ;
           return( sta ) ;
       }/* if */
       return( sta ) ;
}

/* --------------------------------------------------------------------
** valid ID is 0 - 7
** chip must in idle state
**
** but when read back ID
**  0 become 0x01
**  1 become 0x02
**  2 become 0x04, etc...
** ----------------------------------------------------------------- */
int    AscSetChipSynRegAtID(
          PortAddr iop_base,
          uchar    id,
          uchar    sdtr_data
       )
{

       ASC_SCSI_BIT_ID_TYPE  org_id ;
       int  i ;
       int  sta ;

       sta = TRUE ;
       AscSetBank( iop_base, 1 ) ;
       org_id = AscReadChipDvcID( iop_base ) ;
       for( i = 0 ; i <= ASC_MAX_TID ; i++ )
       {
            if( org_id == ( 0x01 << i ) ) break ;
       }
       org_id = (ASC_SCSI_BIT_ID_TYPE)i ;
       AscWriteChipDvcID( iop_base, id ) ;
       if( AscReadChipDvcID( iop_base ) == ( 0x01 << id ) )
       {
          AscSetBank( iop_base, 0 ) ;
          AscSetChipSyn( iop_base, sdtr_data ) ;
          if( AscGetChipSyn( iop_base ) != sdtr_data )
          {
              sta = FALSE ;
          }/* if */
       }/* if */
       else
       {
          sta = FALSE ;
       }
/*
** now restore the original id
*/
       AscSetBank( iop_base, 1 ) ;
       AscWriteChipDvcID( iop_base, org_id ) ;
       AscSetBank( iop_base, 0 ) ;
       return( sta ) ;
}

/* -----------------------------------------------------------
**
** -------------------------------------------------------- */
int    AscReInitLram(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       AscInitLram( asc_dvc ) ;
       AscInitQLinkVar( asc_dvc ) ;
       return( 0 ) ;
}

/* -----------------------------------------------------------------------
**
** return warning code
** -------------------------------------------------------------------- */
ushort AscInitLram(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       uchar    i ;
       ushort   s_addr ;
       PortAddr iop_base ;
       ushort   warn_code ;

       iop_base = asc_dvc->iop_base ;
       warn_code = 0 ;
/*
**
** do not clear BIOS data area which is last queue
** we clear two more queues ( busy and disc queue head
**
*/
       AscMemWordSetLram( iop_base, ASC_QADR_BEG, 0,
           ( ushort )( ( ( int )( asc_dvc->max_total_qng+2+1 ) * 64 ) >> 1 )
           ) ;
/*
** init queue buffer
*/

/*
** queue number zero is reserved
*/
       i = ASC_MIN_ACTIVE_QNO ;
       s_addr = ASC_QADR_BEG + ASC_QBLK_SIZE ;
/*
** init first queue link
*/
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_FWD ),
                        ( uchar )( i+1 ) ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_BWD ),
                         ( uchar )( asc_dvc->max_total_qng ) ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_QNO ),
                         ( uchar )i ) ;
       i++ ;
       s_addr += ASC_QBLK_SIZE ;
       for( ; i < asc_dvc->max_total_qng ; i++, s_addr += ASC_QBLK_SIZE )
       {
            AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_FWD ),
                              ( uchar )( i+1 ) ) ;
            AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_BWD ),
                              ( uchar )( i-1 ) ) ;
            AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_QNO ),
                              ( uchar )i ) ;
       }/* for */
/*
** init last queue link
*/
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_FWD ),
                         ( uchar )ASC_QLINK_END ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_BWD ),
                         ( uchar )( asc_dvc->max_total_qng - 1 ) ) ;
       AscWriteLramByte( iop_base, ( ushort )( s_addr+ASC_SCSIQ_B_QNO ),
                         ( uchar )asc_dvc->max_total_qng ) ;
       i++ ;
       s_addr += ASC_QBLK_SIZE ;
/*
** init two more queues, one for busy queue head, one for disc queue head
** all point to themself
*/
       for( ; i <= ( uchar )( asc_dvc->max_total_qng+3 ) ;
              i++, s_addr += ASC_QBLK_SIZE )
       {
/*
** init the rest of queues, all point to themselves
*/
            AscWriteLramByte( iop_base,
                      ( ushort )( s_addr+( ushort )ASC_SCSIQ_B_FWD ), i ) ;
            AscWriteLramByte( iop_base,
                      ( ushort )( s_addr+( ushort )ASC_SCSIQ_B_BWD ), i ) ;
            AscWriteLramByte( iop_base,
                      ( ushort )( s_addr+( ushort )ASC_SCSIQ_B_QNO ), i ) ;
       }/* for */
/*
** Warning: DO NOT initialize BIOS data section !!!
*/
       return( warn_code ) ;
}

/* -----------------------------------------------------------------------
**
** -------------------------------------------------------------------- */
ushort AscInitQLinkVar(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc
       )
{
       PortAddr iop_base ;
       int  i ;
       ushort lram_addr ;

       iop_base = asc_dvc->iop_base ;
       AscPutRiscVarFreeQHead( iop_base, 1 ) ;
       AscPutRiscVarDoneQTail( iop_base, asc_dvc->max_total_qng ) ;

       AscPutVarFreeQHead( iop_base, 1 ) ;
       AscPutVarDoneQTail( iop_base, asc_dvc->max_total_qng ) ;

       AscWriteLramByte( iop_base, ASCV_BUSY_QHEAD_B,
                         ( uchar )( ( int )asc_dvc->max_total_qng+1 ) ) ;
       AscWriteLramByte( iop_base, ASCV_DISC1_QHEAD_B,
                         ( uchar )( ( int )asc_dvc->max_total_qng+2 ) ) ;

       AscWriteLramByte( iop_base, ( ushort )ASCV_TOTAL_READY_Q_B,
                         asc_dvc->max_total_qng ) ;

       AscWriteLramWord( iop_base, ASCV_ASCDVC_ERR_CODE_W, 0 ) ;
       AscWriteLramWord( iop_base, ASCV_HALTCODE_W, 0 ) ;
       AscWriteLramByte( iop_base, ASCV_STOP_CODE_B, 0 ) ;
       AscWriteLramByte( iop_base, ASCV_SCSIBUSY_B, 0 ) ;
       AscWriteLramByte( iop_base, ASCV_WTM_FLAG_B, 0 ) ;

       AscPutQDoneInProgress( iop_base, 0 ) ;

       lram_addr = ASC_QADR_BEG ;
       for( i = 0 ; i < 32 ; i++, lram_addr += 2 )
       {
            AscWriteLramWord( iop_base, lram_addr, 0 ) ;
       }/* for */

       return( 0 ) ;
}

/* -----------------------------------------------------------
** for library internal use
** -------------------------------------------------------- */
int    AscSetLibErrorCode(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ushort err_code
       )
{
       if( asc_dvc->err_code == 0 )
       {
/*
** error code will be set, if and only if no prior error code exist
**
*/
           asc_dvc->err_code = err_code ;
           AscWriteLramWord( asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,
                             err_code ) ;
       }/* if */
       return( err_code ) ;
}

/* -----------------------------------------------------------
** write a error code to local RAM for debugging purpose
**
** for device driver use
** -------------------------------------------------------- */
int    AscSetDvcErrorCode(
          REG ASC_DVC_VAR asc_ptr_type *asc_dvc,
          uchar err_code
       )
{
       if( asc_dvc->err_code == 0 )
       {
/*
** error code will be set, if and only if no prior error code exist
**
*/
           asc_dvc->err_code = err_code ;
           AscWriteLramByte( asc_dvc->iop_base, ASCV_DVC_ERR_CODE_B,
                             err_code ) ;
       }/* if */
       return( err_code ) ;
}

/* -----------------------------------------------------------
** loop until the queue is
** wait until QS_READY bit is cleared
**
** return 1 if queue is done
** return 0 if timeout
** -------------------------------------------------------- */
int    _AscWaitQDone(
           PortAddr iop_base,
           REG ASC_SCSI_Q dosfar *scsiq
       )
{
       ushort q_addr ;
       uchar  q_status ;
       int    count = 0 ;

       while( scsiq->q1.q_no == 0 ) ;
       q_addr = ASC_QNO_TO_QADDR( scsiq->q1.q_no ) ;

       do
       {
           q_status = AscReadLramByte( iop_base,
               (uchar) (q_addr + ASC_SCSIQ_B_STATUS) ) ;
           DvcSleepMilliSecond( 100L ) ;
           if( count++ > 30 )
           {
               return( 0 ) ;
           }/* if */
       }while( ( q_status & QS_READY ) != 0 ) ;
       return( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_time.c ===
/*
** Copyright (c) 1994-1997 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_time.c
**
*/

#include "ascinc.h"

/* -------------------------------------------------------------------------
**
** "delay" means the entire procedure should not be interrupted
**  also means the function can be called inside an h/w interrupt
**
**
**  1 second = 1,000,000,000 nano second
**
**  Note: minimum time needed for read i/o byte from our adapter
**
**                90 ns -- PCI
**               120 ns -- VESA
**               480 ns -- EISA
**               360 ns -- ISA
**
** ---------------------------------------------------------------------- */
void   DvcDelayNanoSecond(
          ASC_DVC_VAR asc_ptr_type *asc_dvc,
          ulong nano_sec
          )
{
       ulong    loop ;
       PortAddr iop_base ;

       iop_base = asc_dvc->iop_base ;
       loop = nano_sec / 90 ;
       loop++ ;
       while( loop-- != 0 )
       {
            inp( iop_base ) ;
       }
       return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_uc.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** This software contains the valuable trade secrets of AdvanSys, Inc.
** The software is protected under copyright laws as unpublished
** work of Advanced System Products, Inc.
**
** micro mode object file converted to C file
** Original object file: MCODE3.OAS
** Converted C file: A_UC.H
** Date: 04-21-1998
** Time: 17:30:47.65
**
*/


#include "ascinc.h"

uchar _mcode_buf[ ] = {
  0x01,  0x03,  0x01,  0x19,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x0F,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x91,  0x10,  0x0A,  0x05,  0x01,  0x00,  0x00,  0x00,  0x00,  0xFF,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0xFF,  0x80,  0xFF,  0xFF,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x23,  0x00,  0x24,  0x00,  0x00,  0x00,  0x07,  0x00,  0xFF,  0x00,  0x00,  0x00,  0x00,
  0xFF,  0xFF,  0xFF,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0xE2,  0x88,  0x00,  0x00,  0x00,  0x00,
  0x80,  0x73,  0x48,  0x04,  0x36,  0x00,  0x00,  0xA2,  0xC2,  0x00,  0x80,  0x73,  0x03,  0x23,  0x36,  0x40,
  0xB6,  0x00,  0x36,  0x00,  0x05,  0xD6,  0x0C,  0xD2,  0x12,  0xDA,  0x00,  0xA2,  0xC2,  0x00,  0x92,  0x80,
  0x1E,  0x98,  0x50,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xDF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,
  0x4F,  0x00,  0xF5,  0x00,  0x48,  0x98,  0xEF,  0x23,  0x36,  0x60,  0xB6,  0x00,  0x92,  0x80,  0x80,  0x62,
  0x92,  0x80,  0x00,  0x46,  0x17,  0xEE,  0x13,  0xEA,  0x02,  0x01,  0x09,  0xD8,  0xCD,  0x04,  0x4D,  0x00,
  0x00,  0xA3,  0xD6,  0x00,  0xA6,  0x97,  0x7F,  0x23,  0x04,  0x61,  0x84,  0x01,  0xE6,  0x84,  0xD2,  0xC1,
  0x80,  0x73,  0xCD,  0x04,  0x4D,  0x00,  0x00,  0xA3,  0xE2,  0x01,  0xA6,  0x97,  0xCE,  0x81,  0x00,  0x33,
  0x02,  0x00,  0xC0,  0x88,  0x80,  0x73,  0x80,  0x77,  0x00,  0x01,  0x01,  0xA1,  0x02,  0x01,  0x4F,  0x00,
  0x84,  0x97,  0x07,  0xA6,  0x0C,  0x01,  0x00,  0x33,  0x03,  0x00,  0xC0,  0x88,  0x03,  0x03,  0x03,  0xDE,
  0x00,  0x33,  0x05,  0x00,  0xC0,  0x88,  0xCE,  0x00,  0x69,  0x60,  0xCE,  0x00,  0x02,  0x03,  0x4A,  0x60,
  0x00,  0xA2,  0x80,  0x01,  0x80,  0x63,  0x07,  0xA6,  0x2C,  0x01,  0x80,  0x81,  0x03,  0x03,  0x80,  0x63,
  0xE2,  0x00,  0x07,  0xA6,  0x3C,  0x01,  0x00,  0x33,  0x04,  0x00,  0xC0,  0x88,  0x03,  0x07,  0x02,  0x01,
  0x04,  0xCA,  0x0D,  0x23,  0x68,  0x98,  0x4D,  0x04,  0x04,  0x85,  0x05,  0xD8,  0x0D,  0x23,  0x68,  0x98,
  0xCD,  0x04,  0x15,  0x23,  0xF6,  0x88,  0xFB,  0x23,  0x02,  0x61,  0x82,  0x01,  0x80,  0x63,  0x02,  0x03,
  0x06,  0xA3,  0x6A,  0x01,  0x00,  0x33,  0x0A,  0x00,  0xC0,  0x88,  0x4E,  0x00,  0x07,  0xA3,  0x76,  0x01,
  0x00,  0x33,  0x0B,  0x00,  0xC0,  0x88,  0xCD,  0x04,  0x36,  0x2D,  0x00,  0x33,  0x1A,  0x00,  0xC0,  0x88,
  0x50,  0x04,  0x90,  0x81,  0x06,  0xAB,  0x8A,  0x01,  0x90,  0x81,  0x4E,  0x00,  0x07,  0xA3,  0x9A,  0x01,
  0x50,  0x00,  0x00,  0xA3,  0x44,  0x01,  0x00,  0x05,  0x84,  0x81,  0x46,  0x97,  0x02,  0x01,  0x05,  0xC6,
  0x04,  0x23,  0xA0,  0x01,  0x15,  0x23,  0xA1,  0x01,  0xC6,  0x81,  0xFD,  0x23,  0x02,  0x61,  0x82,  0x01,
  0x0A,  0xDA,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,  0xBC,  0x01,  0x80,  0x63,  0xCD,  0x04,  0x36,  0x2D,
  0x00,  0x33,  0x1B,  0x00,  0xC0,  0x88,  0x06,  0x23,  0x68,  0x98,  0xCD,  0x04,  0xE6,  0x84,  0x06,  0x01,
  0x00,  0xA2,  0xDC,  0x01,  0x57,  0x60,  0x00,  0xA0,  0xE2,  0x01,  0xE6,  0x84,  0x80,  0x23,  0xA0,  0x01,
  0xE6,  0x84,  0x80,  0x73,  0x4B,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x08,  0x02,  0x04,  0x01,  0x0C,  0xDE,
  0x02,  0x01,  0x03,  0xCC,  0x4F,  0x00,  0x84,  0x97,  0x04,  0x82,  0x08,  0x23,  0x02,  0x41,  0x82,  0x01,
  0x4F,  0x00,  0x62,  0x97,  0x48,  0x04,  0x84,  0x80,  0xF0,  0x97,  0x00,  0x46,  0x56,  0x00,  0x03,  0xC0,
  0x01,  0x23,  0xE8,  0x00,  0x81,  0x73,  0x06,  0x29,  0x03,  0x42,  0x06,  0xE2,  0x03,  0xEE,  0x67,  0xEB,
  0x11,  0x23,  0xF6,  0x88,  0x04,  0x98,  0xF4,  0x80,  0x80,  0x73,  0x80,  0x77,  0x07,  0xA4,  0x32,  0x02,
  0x7C,  0x95,  0x06,  0xA6,  0x3C,  0x02,  0x03,  0xA6,  0x4C,  0x04,  0xC0,  0x88,  0x04,  0x01,  0x03,  0xD8,
  0xB2,  0x98,  0x6A,  0x96,  0x4E,  0x82,  0xFE,  0x95,  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0xB6,  0x2D,
  0x02,  0xA6,  0x78,  0x02,  0x07,  0xA6,  0x66,  0x02,  0x06,  0xA6,  0x6A,  0x02,  0x03,  0xA6,  0x6E,  0x02,
  0x00,  0x33,  0x10,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0x50,  0x82,  0x60,  0x96,  0x50,  0x82,  0x04,  0x23,
  0xA0,  0x01,  0x14,  0x23,  0xA1,  0x01,  0x3C,  0x84,  0x04,  0x01,  0x0C,  0xDC,  0xE0,  0x23,  0x25,  0x61,
  0xEF,  0x00,  0x14,  0x01,  0x4F,  0x04,  0xA8,  0x01,  0x6F,  0x00,  0xA5,  0x01,  0x03,  0x23,  0xA4,  0x01,
  0x06,  0x23,  0x9C,  0x01,  0x24,  0x2B,  0x1C,  0x01,  0x02,  0xA6,  0xB6,  0x02,  0x07,  0xA6,  0x66,  0x02,
  0x06,  0xA6,  0x6A,  0x02,  0x03,  0xA6,  0x20,  0x04,  0x01,  0xA6,  0xC0,  0x02,  0x00,  0xA6,  0xC0,  0x02,
  0x00,  0x33,  0x12,  0x00,  0xC0,  0x88,  0x00,  0x0E,  0x80,  0x63,  0x00,  0x43,  0x00,  0xA0,  0x98,  0x02,
  0x4D,  0x04,  0x04,  0x01,  0x0B,  0xDC,  0xE7,  0x23,  0x04,  0x61,  0x84,  0x01,  0x10,  0x31,  0x12,  0x35,
  0x14,  0x01,  0xEC,  0x00,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,  0xF6,  0x82,  0x18,  0x23,  0x04,  0x61,
  0x18,  0xA0,  0xEE,  0x02,  0x04,  0x01,  0x9C,  0xC8,  0x00,  0x33,  0x1F,  0x00,  0xC0,  0x88,  0x08,  0x31,
  0x0A,  0x35,  0x0C,  0x39,  0x0E,  0x3D,  0x7E,  0x98,  0xB6,  0x2D,  0x01,  0xA6,  0x20,  0x03,  0x00,  0xA6,
  0x20,  0x03,  0x07,  0xA6,  0x18,  0x03,  0x06,  0xA6,  0x1C,  0x03,  0x03,  0xA6,  0x20,  0x04,  0x02,  0xA6,
  0x78,  0x02,  0x00,  0x33,  0x33,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0xFA,  0x82,  0x60,  0x96,  0xFA,  0x82,
  0x82,  0x98,  0x80,  0x42,  0x7E,  0x98,  0x60,  0xE4,  0x04,  0x01,  0x29,  0xC8,  0x31,  0x05,  0x07,  0x01,
  0x00,  0xA2,  0x60,  0x03,  0x00,  0x43,  0x87,  0x01,  0x05,  0x05,  0x86,  0x98,  0x7E,  0x98,  0x00,  0xA6,
  0x22,  0x03,  0x07,  0xA6,  0x58,  0x03,  0x03,  0xA6,  0x3C,  0x04,  0x06,  0xA6,  0x5C,  0x03,  0x01,  0xA6,
  0x22,  0x03,  0x00,  0x33,  0x25,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0x3E,  0x83,  0x60,  0x96,  0x3E,  0x83,
  0x04,  0x01,  0x0C,  0xCE,  0x03,  0xC8,  0x00,  0x33,  0x42,  0x00,  0xC0,  0x88,  0x00,  0x01,  0x05,  0x05,
  0xFF,  0xA2,  0x7E,  0x03,  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x3A,  0x83,  0x05,  0x05,  0x15,  0x01,
  0x00,  0xA2,  0x9E,  0x03,  0xEC,  0x00,  0x6E,  0x00,  0x95,  0x01,  0x6C,  0x38,  0x00,  0x3F,  0x00,  0x00,
  0x01,  0xA6,  0x9A,  0x03,  0x00,  0xA6,  0x9A,  0x03,  0x12,  0x84,  0x80,  0x42,  0x7E,  0x98,  0x01,  0xA6,
  0xA8,  0x03,  0x00,  0xA6,  0xC0,  0x03,  0x12,  0x84,  0xA6,  0x98,  0x80,  0x42,  0x01,  0xA6,  0xA8,  0x03,
  0x07,  0xA6,  0xB6,  0x03,  0xD8,  0x83,  0x7C,  0x95,  0xAC,  0x83,  0x00,  0x33,  0x2F,  0x00,  0xC0,  0x88,
  0xA6,  0x98,  0x80,  0x42,  0x00,  0xA6,  0xC0,  0x03,  0x07,  0xA6,  0xCE,  0x03,  0xD8,  0x83,  0x7C,  0x95,
  0xC4,  0x83,  0x00,  0x33,  0x26,  0x00,  0xC0,  0x88,  0x38,  0x2B,  0x80,  0x32,  0x80,  0x36,  0x04,  0x23,
  0xA0,  0x01,  0x12,  0x23,  0xA1,  0x01,  0x12,  0x84,  0x06,  0xF0,  0x06,  0xA4,  0xF6,  0x03,  0x80,  0x6B,
  0x05,  0x23,  0x83,  0x03,  0x80,  0x63,  0x03,  0xA6,  0x10,  0x04,  0x07,  0xA6,  0x08,  0x04,  0x06,  0xA6,
  0x0C,  0x04,  0x00,  0x33,  0x17,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0xF6,  0x83,  0x60,  0x96,  0xF6,  0x83,
  0x20,  0x84,  0x06,  0xF0,  0x06,  0xA4,  0x20,  0x04,  0x80,  0x6B,  0x05,  0x23,  0x83,  0x03,  0x80,  0x63,
  0xB6,  0x2D,  0x03,  0xA6,  0x3C,  0x04,  0x07,  0xA6,  0x34,  0x04,  0x06,  0xA6,  0x38,  0x04,  0x00,  0x33,
  0x30,  0x00,  0xC0,  0x88,  0x7C,  0x95,  0x20,  0x84,  0x60,  0x96,  0x20,  0x84,  0x1D,  0x01,  0x06,  0xCC,
  0x00,  0x33,  0x00,  0x84,  0xC0,  0x20,  0x00,  0x23,  0xEA,  0x00,  0x81,  0x62,  0xA2,  0x0D,  0x80,  0x63,
  0x07,  0xA6,  0x5A,  0x04,  0x00,  0x33,  0x18,  0x00,  0xC0,  0x88,  0x03,  0x03,  0x80,  0x63,  0xA3,  0x01,
  0x07,  0xA4,  0x64,  0x04,  0x23,  0x01,  0x00,  0xA2,  0x86,  0x04,  0x0A,  0xA0,  0x76,  0x04,  0xE0,  0x00,
  0x00,  0x33,  0x1D,  0x00,  0xC0,  0x88,  0x0B,  0xA0,  0x82,  0x04,  0xE0,  0x00,  0x00,  0x33,  0x1E,  0x00,
  0xC0,  0x88,  0x42,  0x23,  0xF6,  0x88,  0x00,  0x23,  0x22,  0xA3,  0xE6,  0x04,  0x08,  0x23,  0x22,  0xA3,
  0xA2,  0x04,  0x28,  0x23,  0x22,  0xA3,  0xAE,  0x04,  0x02,  0x23,  0x22,  0xA3,  0xC4,  0x04,  0x42,  0x23,
  0xF6,  0x88,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA0,  0xAE,  0x04,  0x45,  0x23,  0xF6,  0x88,  0x04,  0x98,
  0x00,  0xA2,  0xC0,  0x04,  0xB2,  0x98,  0x00,  0x33,  0x00,  0x82,  0xC0,  0x20,  0x81,  0x62,  0xF0,  0x81,
  0x47,  0x23,  0xF6,  0x88,  0x04,  0x01,  0x0B,  0xDE,  0x04,  0x98,  0xB2,  0x98,  0x00,  0x33,  0x00,  0x81,
  0xC0,  0x20,  0x81,  0x62,  0x14,  0x01,  0x00,  0xA0,  0x08,  0x02,  0x43,  0x23,  0xF6,  0x88,  0x04,  0x23,
  0xA0,  0x01,  0x44,  0x23,  0xA1,  0x01,  0x80,  0x73,  0x4D,  0x00,  0x03,  0xA3,  0xF4,  0x04,  0x00,  0x33,
  0x27,  0x00,  0xC0,  0x88,  0x04,  0x01,  0x04,  0xDC,  0x02,  0x23,  0xA2,  0x01,  0x04,  0x23,  0xA0,  0x01,
  0x04,  0x98,  0x26,  0x95,  0x4B,  0x00,  0xF6,  0x00,  0x4F,  0x04,  0x4F,  0x00,  0x00,  0xA3,  0x22,  0x05,
  0x00,  0x05,  0x76,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x1C,  0x05,  0x0A,  0x85,  0x46,  0x97,  0xCD,  0x04,
  0x24,  0x85,  0x48,  0x04,  0x84,  0x80,  0x02,  0x01,  0x03,  0xDA,  0x80,  0x23,  0x82,  0x01,  0x34,  0x85,
  0x02,  0x23,  0xA0,  0x01,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0x40,  0x05,  0x1D,  0x01,  0x04,  0xD6,
  0xFF,  0x23,  0x86,  0x41,  0x4B,  0x60,  0xCB,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x49,  0x00,  0x81,  0x01,
  0x04,  0x01,  0x02,  0xC8,  0x30,  0x01,  0x80,  0x01,  0xF7,  0x04,  0x03,  0x01,  0x49,  0x04,  0x80,  0x01,
  0xC9,  0x00,  0x00,  0x05,  0x00,  0x01,  0xFF,  0xA0,  0x60,  0x05,  0x77,  0x04,  0x01,  0x23,  0xEA,  0x00,
  0x5D,  0x00,  0xFE,  0xC7,  0x00,  0x62,  0x00,  0x23,  0xEA,  0x00,  0x00,  0x63,  0x07,  0xA4,  0xF8,  0x05,
  0x03,  0x03,  0x02,  0xA0,  0x8E,  0x05,  0xF4,  0x85,  0x00,  0x33,  0x2D,  0x00,  0xC0,  0x88,  0x04,  0xA0,
  0xB8,  0x05,  0x80,  0x63,  0x00,  0x23,  0xDF,  0x00,  0x4A,  0x00,  0x06,  0x61,  0x00,  0xA2,  0xA4,  0x05,
  0x1D,  0x01,  0x06,  0xD6,  0x02,  0x23,  0x02,  0x41,  0x82,  0x01,  0x50,  0x00,  0x62,  0x97,  0x04,  0x85,
  0x04,  0x23,  0x02,  0x41,  0x82,  0x01,  0x04,  0x85,  0x08,  0xA0,  0xBE,  0x05,  0xF4,  0x85,  0x03,  0xA0,
  0xC4,  0x05,  0xF4,  0x85,  0x01,  0xA0,  0xCE,  0x05,  0x88,  0x00,  0x80,  0x63,  0xCC,  0x86,  0x07,  0xA0,
  0xEE,  0x05,  0x5F,  0x00,  0x00,  0x2B,  0xDF,  0x08,  0x00,  0xA2,  0xE6,  0x05,  0x80,  0x67,  0x80,  0x63,
  0x01,  0xA2,  0x7A,  0x06,  0x7C,  0x85,  0x06,  0x23,  0x68,  0x98,  0x48,  0x23,  0xF6,  0x88,  0x07,  0x23,
  0x80,  0x00,  0x06,  0x87,  0x80,  0x63,  0x7C,  0x85,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x4A,  0x00,
  0x06,  0x61,  0x00,  0xA2,  0x36,  0x06,  0x1D,  0x01,  0x16,  0xD4,  0xC0,  0x23,  0x07,  0x41,  0x83,  0x03,
  0x80,  0x63,  0x06,  0xA6,  0x1C,  0x06,  0x00,  0x33,  0x37,  0x00,  0xC0,  0x88,  0x1D,  0x01,  0x01,  0xD6,
  0x20,  0x23,  0x63,  0x60,  0x83,  0x03,  0x80,  0x63,  0x02,  0x23,  0xDF,  0x00,  0x07,  0xA6,  0x7C,  0x05,
  0xEF,  0x04,  0x6F,  0x00,  0x00,  0x63,  0x4B,  0x00,  0x06,  0x41,  0xCB,  0x00,  0x52,  0x00,  0x06,  0x61,
  0x00,  0xA2,  0x4E,  0x06,  0x1D,  0x01,  0x03,  0xCA,  0xC0,  0x23,  0x07,  0x41,  0x00,  0x63,  0x1D,  0x01,
  0x04,  0xCC,  0x00,  0x33,  0x00,  0x83,  0xC0,  0x20,  0x81,  0x62,  0x80,  0x23,  0x07,  0x41,  0x00,  0x63,
  0x80,  0x67,  0x08,  0x23,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x01,  0x23,  0xDF,  0x00,  0x06,  0xA6,
  0x84,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x80,  0x63,  0x00,  0x33,  0x00,  0x40,  0xC0,  0x20,
  0x81,  0x62,  0x00,  0x63,  0x00,  0x00,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,  0x94,  0x06,
  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x00,  0x01,  0xA0,  0x14,  0x07,  0x00,  0x2B,  0x40,  0x0E,  0x80,  0x63,
  0x01,  0x00,  0x06,  0xA6,  0xAA,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x40,  0x0E,  0x80,  0x63,  0x00,  0x43,
  0x00,  0xA0,  0xA2,  0x06,  0x06,  0xA6,  0xBC,  0x06,  0x07,  0xA6,  0x7C,  0x05,  0x80,  0x67,  0x40,  0x0E,
  0x80,  0x63,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x23,  0xDF,  0x00,  0x00,  0x63,  0x07,  0xA6,  0xD6,  0x06,
  0x00,  0x33,  0x2A,  0x00,  0xC0,  0x88,  0x03,  0x03,  0x80,  0x63,  0x89,  0x00,  0x0A,  0x2B,  0x07,  0xA6,
  0xE8,  0x06,  0x00,  0x33,  0x29,  0x00,  0xC0,  0x88,  0x00,  0x43,  0x00,  0xA2,  0xF4,  0x06,  0xC0,  0x0E,
  0x80,  0x63,  0xDE,  0x86,  0xC0,  0x0E,  0x00,  0x33,  0x00,  0x80,  0xC0,  0x20,  0x81,  0x62,  0x04,  0x01,
  0x02,  0xDA,  0x80,  0x63,  0x7C,  0x85,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x8C,  0x06,  0x00,  0x33,
  0x2C,  0x00,  0xC0,  0x88,  0x0C,  0xA2,  0x2E,  0x07,  0xFE,  0x95,  0x83,  0x03,  0x80,  0x63,  0x06,  0xA6,
  0x2C,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0x00,  0x33,  0x3D,  0x00,  0xC0,  0x88,  0x00,  0x00,  0x80,  0x67,
  0x83,  0x03,  0x80,  0x63,  0x0C,  0xA0,  0x44,  0x07,  0x07,  0xA6,  0x7C,  0x05,  0xBF,  0x23,  0x04,  0x61,
  0x84,  0x01,  0xE6,  0x84,  0x00,  0x63,  0xF0,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x00,  0x01,  0xF2,  0x00,
  0x01,  0x05,  0x80,  0x01,  0x72,  0x04,  0x71,  0x00,  0x81,  0x01,  0x70,  0x04,  0x80,  0x05,  0x81,  0x05,
  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x01,  0x01,  0xF1,  0x00,  0x70,  0x00,  0x81,  0x01,
  0x70,  0x04,  0x71,  0x00,  0x81,  0x01,  0x72,  0x00,  0x80,  0x01,  0x71,  0x04,  0x70,  0x00,  0x80,  0x01,
  0x70,  0x04,  0x00,  0x63,  0xF0,  0x04,  0xF2,  0x00,  0x72,  0x04,  0x00,  0x01,  0xF1,  0x00,  0x70,  0x00,
  0x80,  0x01,  0x70,  0x04,  0x71,  0x00,  0x80,  0x01,  0x72,  0x00,  0x81,  0x01,  0x71,  0x04,  0x70,  0x00,
  0x81,  0x01,  0x70,  0x04,  0x00,  0x63,  0x00,  0x23,  0xB3,  0x01,  0x83,  0x05,  0xA3,  0x01,  0xA2,  0x01,
  0xA1,  0x01,  0x01,  0x23,  0xA0,  0x01,  0x00,  0x01,  0xC8,  0x00,  0x03,  0xA1,  0xC4,  0x07,  0x00,  0x33,
  0x07,  0x00,  0xC0,  0x88,  0x80,  0x05,  0x81,  0x05,  0x04,  0x01,  0x11,  0xC8,  0x48,  0x00,  0xB0,  0x01,
  0xB1,  0x01,  0x08,  0x23,  0xB2,  0x01,  0x05,  0x01,  0x48,  0x04,  0x00,  0x43,  0x00,  0xA2,  0xE4,  0x07,
  0x00,  0x05,  0xDA,  0x87,  0x00,  0x01,  0xC8,  0x00,  0xFF,  0x23,  0x80,  0x01,  0x05,  0x05,  0x00,  0x63,
  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x80,  0x43,  0x76,  0x08,  0x80,  0x02,
  0x77,  0x04,  0x00,  0x63,  0xF7,  0x04,  0x1A,  0x09,  0xF6,  0x08,  0x6E,  0x04,  0x00,  0x02,  0x00,  0xA0,
  0x14,  0x08,  0x16,  0x88,  0x00,  0x43,  0x76,  0x08,  0x80,  0x02,  0x77,  0x04,  0x00,  0x63,  0xF3,  0x04,
  0x00,  0x23,  0xF4,  0x00,  0x74,  0x00,  0x80,  0x43,  0xF4,  0x00,  0xCF,  0x40,  0x00,  0xA2,  0x44,  0x08,
  0x74,  0x04,  0x02,  0x01,  0xF7,  0xC9,  0xF6,  0xD9,  0x00,  0x01,  0x01,  0xA1,  0x24,  0x08,  0x04,  0x98,
  0x26,  0x95,  0x24,  0x88,  0x73,  0x04,  0x00,  0x63,  0xF3,  0x04,  0x75,  0x04,  0x5A,  0x88,  0x02,  0x01,
  0x04,  0xD8,  0x46,  0x97,  0x04,  0x98,  0x26,  0x95,  0x4A,  0x88,  0x75,  0x00,  0x00,  0xA3,  0x64,  0x08,
  0x00,  0x05,  0x4E,  0x88,  0x73,  0x04,  0x00,  0x63,  0x80,  0x7B,  0x80,  0x63,  0x06,  0xA6,  0x76,  0x08,
  0x00,  0x33,  0x3E,  0x00,  0xC0,  0x88,  0x80,  0x67,  0x83,  0x03,  0x80,  0x63,  0x00,  0x63,  0x38,  0x2B,
  0x9C,  0x88,  0x38,  0x2B,  0x92,  0x88,  0x32,  0x09,  0x31,  0x05,  0x92,  0x98,  0x05,  0x05,  0xB2,  0x09,
  0x00,  0x63,  0x00,  0x32,  0x00,  0x36,  0x00,  0x3A,  0x00,  0x3E,  0x00,  0x63,  0x80,  0x32,  0x80,  0x36,
  0x80,  0x3A,  0x80,  0x3E,  0x00,  0x63,  0x38,  0x2B,  0x40,  0x32,  0x40,  0x36,  0x40,  0x3A,  0x40,  0x3E,
  0x00,  0x63,  0x5A,  0x20,  0xC9,  0x40,  0x00,  0xA0,  0xB2,  0x08,  0x5D,  0x00,  0xFE,  0xC3,  0x00,  0x63,
  0x80,  0x73,  0xE6,  0x20,  0x02,  0x23,  0xE8,  0x00,  0x82,  0x73,  0xFF,  0xFD,  0x80,  0x73,  0x13,  0x23,
  0xF6,  0x88,  0x66,  0x20,  0xC0,  0x20,  0x04,  0x23,  0xA0,  0x01,  0xA1,  0x23,  0xA1,  0x01,  0x81,  0x62,
  0xE0,  0x88,  0x80,  0x73,  0x80,  0x77,  0x68,  0x00,  0x00,  0xA2,  0x80,  0x00,  0x03,  0xC2,  0xF1,  0xC7,
  0x41,  0x23,  0xF6,  0x88,  0x11,  0x23,  0xA1,  0x01,  0x04,  0x23,  0xA0,  0x01,  0xE6,  0x84,
} ;

ushort _mcode_size = sizeof( _mcode_buf ) ; /* 0x08FE */ 
ulong  _mcode_chksum = 0x012B5442UL ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_ver.h ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** Filename: a_ver.h
**
*/

#ifndef __A_VER_H_
#define __A_VER_H_

#define ASC_LIB_VERSION_MAJOR  1   /* for major change  */
#define ASC_LIB_VERSION_MINOR  23  /* for minor bug fix */
#define ASC_LIB_SERIAL_NUMBER  115 /* internal serial number */

#endif /* #ifndef __A_VER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_scam.c ===
/*
** Copyright (c) 1994-1998 Advanced System Products, Inc.
** All Rights Reserved.
**
** a_scam.c
**
*/

#include "ascinc.h"

#if CC_SCAM

#include "a_scam.h"
#include "a_scam2.c"

/*
** Global data:
*/
UINT        IFType;                     // Interface type index
PortAddr    ChipBase;                   // Base IO address of chip
PortAddr    ScsiCtrl;                   // IO address of SCSI Control Reg
PortAddr    ScsiData;                   // IO address of SCSI Data Reg
UCHAR       MyID;                       // Our ID

/*
** Conversion table, library card type to our type:
*/
int   CardTypes[4] =
{
   ASC_IS_ISA,
   ASC_IS_EISA,
   ASC_IS_VL,
   ASC_IS_PCI
};

/*
** These idiotic tables are necessary because some genius decided to correct
** a mistake in the way REQ and ACK are presented.  The order is:
**                  ISA     EISA    VESA    PCI
*/
UCHAR   reqI[] = {  0x10,   0x10,   0x10,   0x20};
UCHAR   ackI[] = {  0x20,   0x20,   0x20,   0x10};

/*
** Constants :
*/
UCHAR   IDBits[8] =
{
    0x01,   0x02,   0x04,   0x08,   0x10,   0x20,   0x40,   0x80
};

UCHAR   IDQuint[8] =                    /* Quintets for setting ID's */
{
    0x18,   0x11,   0x12,   0x0B,   0x14,   0x0D,   0x0E,   0x07
};

UINT  ns1200[] =                      /* loop counts for 1.2us */
{
    4,                                  // ISA
    5,                                  // EISA
    10,                                 // VESA
    14                                  // PCI
};

UINT  ns2000[] =                      // loop counts for 2.0us
{
    6,                                  // ISA
    9,                                  // EISA
    17,                                 // VESA
    23                                  // PCI
};

UINT  ns2400[] =                      // loop counts for 2.4us
{
    7,                                  // ISA
    10,                                 // EISA
    20,                                 // VESA
    27                                  // PCI
};

UINT  us1000[] =                      // loop counts for 1.0ms
{
    2778,                               // ISA
    4167,                               // EISA
    8334,                               // VESA
    11111                               // PCI
};

UINT  dgl[] =                         // DeGlitch counts
{
    64,                                 // ISA
    64,                                 // EISA
    128,                                // VESA
    150                                 // PCI
};

//**************************************************************************
//
//  DelayLoop() -- Wait the specified number of loops.
//
//**************************************************************************
VOID DelayLoop( UINT ns )
{
    while (ns--)
    {
        inp(ScsiCtrl);
    }
}

//**************************************************************************
//
//  Arbitrate() -- Arbitrate for bus master
//
//  Parms:  None
//
//  Return: TRUE if successful.
//
//  NOTE:   On exit, BSY and SEL are asserter
//
//**************************************************************************
BOOL Arbitrate( VOID )
{
    UCHAR       IDBit;
    UCHAR       arbMask;

    //
    // Pre-calculate a mask of ID's ours and greater for arbitration:
    //
    arbMask = ~((IDBit = IDBits[MyID]) - 1);

    //
    // Wait for bus free
    //
    if (DeGlitch(ScsiCtrl, BSY | SEL, ns1200[IFType]) != 0)
    {
        DebugPrintf(("Arbitrate: Timeout waiting for bus free.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    //
    // Assert BSY and our ID bit, then wait 2.4 us:
    //
    outp(ScsiData, IDBit);
    outp(ScsiCtrl, BSY);
    DelayNS(ns2400);

    //
    // See if we won arbitration:
    //
    if (((UCHAR)inp(ScsiData) & arbMask) > IDBit)
    {
        //
        // Lost arbitration.
        //
        DebugPrintf(("Arbitrate: Lost arbitration.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    //
    // Won arbitration!
    //
    outp(ScsiCtrl, BSY | SEL);              // Assert SEL and BSY

    return(TRUE);
}

//**************************************************************************
//
//  StartSCAM() -- Initiate SCAM protocol.
//
//  Parms:  None
//
//  Return: TRUE if successful.
//
//  NOTE:   On exit, BSY, SEL, I/O, C/D and DB(7) are asserted.
//
//**************************************************************************
BOOL StartSCAM( VOID )
{
    //
    // Arbitrate for bus master
    //
    if (!Arbitrate())
    {
        DebugPrintf(("StartSCAM: Failed arbitration.\n"));
        return(FALSE);
    }

    outp(ScsiData, 0x00);                   // Release Data bus
    outp(ScsiCtrl, BSY | SEL | MSG);        // Assert MSG

//  inp(ScsiCtrl);                          // Wait 90 ns (2 deskews)
//
//  5/7/97, YPC, an NEC drive responded to select despite MSG = 1
//  We will keep BSY a little longer to ensure, the drive is not confused
//
    DelayNS(ns2400);
    outp(ScsiCtrl, SEL | MSG);              // then release BSY

    DvcSCAMDelayMS(250);                    // Wait SCAM selection response
    outp(ScsiCtrl, SEL);                    // then release MSG

    //
    // Deglitch MSG:
    //
    if (DeGlitch(ScsiCtrl, MSG, dgl[IFType]) != 0)
    {
        DebugPrintf(("StartSCAM: Timeout waiting for MSG FALSE.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    outp(ScsiCtrl, BSY | SEL);              // Assert BSY,
    inp(ScsiCtrl);                          // Wait 2 deskew delays,
    outp(ScsiData, 0xC0);                   // assert DB(6), DB(7),
    outp(ScsiCtrl, BSY | SEL | IO | CD);    // and I/O and C/D
    inp(ScsiCtrl);                          // Wait 2 more deskew delays.
    outp(ScsiCtrl, BSY | IO | CD);          // Release SEL

    //
    // Deglitch SEL:
    //
    if (DeGlitch(ScsiCtrl, SEL, dgl[IFType]) != 0)
    {
        DebugPrintf(("StartSCAM: Timeout waiting for SEL FALSE.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    outp(ScsiData, 0x80);                   // Release DB(6)

    //
    // Deglitch DB(6):
    //
    if (DeGlitch(ScsiData, 0x40, dgl[IFType]) != 0)
    {
        DebugPrintf(("StartSCAM: Timeout waiting for DB(6) FALSE.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(FALSE);
    }

    outp(ScsiCtrl, BSY | SEL | IO | CD);    // Finally, assert SEL.

    return(TRUE);
}

//**************************************************************************
//
//  Tranceive() -- send/receive one quintet
//
//  This function both transmits and receives one quintet since the SCAM
//  transfer protocol allows transfer in either direction in each transfer
//  cycle.
//
//  Parms:      data -- quintet to output
//
//  Return:     data input -- less than 0 if error
//
//  NOTE:   DB(7) is expected to be asserted prior to entry, and is left
//          asserted on exit.
//**************************************************************************
int Tranceive( UCHAR data )
{
    UCHAR      indata;

    data &= 0x1F;                       // Protect caller from himself

    outp(ScsiData, data | DB7 | DB5);   // Output data, assert DB(5)
    outp(ScsiData, data | DB5);         // Release DB(7)

    //
    // Deglitch DB(7):
    //
    if (DeGlitch(ScsiData, DB7, dgl[IFType]) != 0)
    {
        DebugPrintf(("Tranceive: Timeout waiting for DB7 FALSE.\n"));
        outp(ScsiData, 0x00);           // Release bus
        outp(ScsiCtrl, 0x00);           // Release bus
        return(-1);
    }

    indata = inp(ScsiData);             // Read input data
    outp(ScsiData, data | DB5 | DB6);   // Assert DB(6)
    outp(ScsiData, data | DB6);         // Release DB(5)

    //
    // Deglitch DB(5):
    //
    if (DeGlitch(ScsiData, DB5, dgl[IFType]) != 0)
    {
        DebugPrintf(("Tranceive: Timeout waiting for DB5 FALSE.\n"));
        outp(ScsiData, 0x00);           // Release bus
        outp(ScsiCtrl, 0x00);           // Release bus
        return(-1);
    }

    outp(ScsiData, DB7 | DB6);          // Release data, assert DB7
    outp(ScsiData, DB7);                // Release DB(6)

    //
    // Deglitch DB(6):
    //
    if (DeGlitch(ScsiData, DB6, dgl[IFType]) != 0)
    {
        DebugPrintf(("Tranceive: Timeout waiting for DB6 FALSE.\n"));
        outp(ScsiData, 0x00);           // Release bus
        outp(ScsiCtrl, 0x00);           // Release bus
        return(-1);
    }

    return(indata);                     // Success
}

//**************************************************************************
//
//  AssignID() -- Isolate and assign ID
//
//  This function isolates one device and assigns the specified ID to it.
//
//  Parms:  pBits = pointer to "used" bits.
//
//  Return: TRUE if successful
//
//  Note:  This routine attempts to assign the device's default ID if it
//          is available, cycling to successively lower ID's if not.
//
//**************************************************************************
BOOL AssignID( UCHAR dosfar *pBits )
{
    UCHAR       IDString[40];
    int         temp;
    UCHAR       quint;
    int         i;
    UINT        ID;
    UCHAR       IDBit;

    //
    // Send Sync and Isolate
    //
    if ( Tranceive(SCAMF_SYNC) < 0
        || (temp = Tranceive(SCAMF_ISO)) < 0 )
    {
        DebugPrintf(("AssignID: Unable to send SYNC / ISO!\n"));
        return(FALSE);
    }// End if

    if ((temp & 0x1F) != SCAMF_ISO)
    {
        DebugPrintf(("AssignID: Collision on SCAMF_ISO!\n"));
        return(FALSE);
    }// End if

    //
    // Deserialize one byte of ID string:
    //
    if ((temp = DeSerialize()) < 0)
    {
        // AssignID: No data.
        return(FALSE);
    }

    //
    // Bit 0 (SNA) of first byte means the serial number is not
    // available, we have to stop and retry at a later time.
    //
    if ((temp & 0x0001) == 0)
    {
        DebugPrintf(("AssignID: SNA set on device!\n"));
        if ( Tranceive(SCAM_TERM) < 0)
        {
            DebugPrintf(("AssignID: Failed to transmit TERM!\n"));
        }
        return(FALSE);
    }

    IDString[0] = (UCHAR)temp;              // Save the first byte
    IDString[1] = '\0';                     // Terminate the string

    //
    // Loop getting the rest of the string:
    //
    for (i = 1; i < 32; i++)
    {
        if ((temp = DeSerialize()) < 0)
        {
            break;
        }
        IDString[i] = (UCHAR)temp;
        IDString[i + 1] = '\0';             // Terminate the string
    }

    //
    // Issue the assign ID action code:
    //
    if ( (temp = Tranceive(SCAMQ1_ID00)) < 0)
    {
        DebugPrintf(("AssignID: Unable to send SCAMQ1_ID00!\n"));
        return(FALSE);
    }// End if

    if ((temp & 0x1F) != SCAMQ1_ID00)
    {
        DebugPrintf(("AssignID: Collision on SCAMQ1_ID00!\n"));
        return(FALSE);
    }// End if

    //
    // Determine new ID:
    //
    ID = IDString[1] & 0x07;
    for (i = 0; i < 8; i++)
    {
        IDBit = IDBits[ID];
        if ((*pBits & IDBit) == 0)
            break;
        //
        // Cycle to next ID
        //
        ID = (--ID) & 7;                // Next lower ID modulo 8
    }
    *pBits |= IDBit;
    quint = IDQuint[ID];

    //
    // Send the new ID:
    //
    if ( (temp = Tranceive(quint)) < 0)
    {
        DebugPrintf(("AssignID: Unable to send ID!\n"));
        return(FALSE);
    }// End if

    if ((temp & 0x1F) != quint)
    {
        DebugPrintf(("AssignID: Collision on ID!\n"));
        return(FALSE);
    }// End if

    DebugPrintf(("ID #%x: ", ID));
    DebugPrintf(("Type: %x,%x ", IDString[0], IDString[1]));
    DebugPrintf((&IDString[2]));
    DebugPrintf(("\n"));

    return(TRUE);
}

//***************************************************************************
//
//  Routine to glitch filter a given signal
//
//  ENTRY:       iop = I/O PORT TO CHECK
//               msk = MASK OF BITS WE'RE INTERESTED IN
//               loops = NUMBER OF ITTERATIONS THAT SIGNALS MUST MATCH
//
//  RETURNS:     ZERO IF SUCCESS, ELSE NON-ZERO
//
//  Note: loops must be calculated by caller based on time of an IN
//        as follows:
//                90 -- PCI
//               120 -- VESA
//               480 -- EISA
//               360 -- ISA
//
//***************************************************************************
UINT DeGlitch(PortAddr iop, UCHAR msk, UINT loops)
{
    int     i;
    UINT    esc;

    //
    // Outer loop to ensure we don't lock up forever.
    //
    for (esc = 65535; esc; esc--)
    {
        //
        // Expect the signal(s) to be 0 for the specified loop time:
        //
        for (i = loops; i; i--)
        {
            if (inp(iop) & msk)
                break;                  // Non-zero, restart timer
        }

        if (i == 0)
            return(0);                  // Success.
    }
    return(1);                          // Timeout.
}

//***************************************************************************
//
//  Routine to DeSerialize a byte of ID string
//
//  ENTRY:       NONE
//
//  RETURNS:     AL = BYTE READ
//               AH = 0 IF OK, -1 IF ERROR
//
//***************************************************************************
int DeSerialize(VOID)
{
    UCHAR   accum;
    int     temp;
    int     count;

    for (count = 0, accum = 0; count < 8; count++)
    {
        //
        //  GET A BIT OF THE BYTE:
        //
        if (((temp = Tranceive(0)) < 0) // Check for error
            || (temp & 0x10)            // Check for initiator termination
            || ((temp & 0x03) == 0))    // Check for target termination
        {
            //
            // Premature termination
            //
            return(-1);
        }
        accum = (accum << 1) | ((temp & 0x02)? 1:0);
    }
    return(accum);
}

//**************************************************************************
//
//  Cleanup() -- Clean up the bus prior to exit.
//
//**************************************************************************
VOID Cleanup(UCHAR CCReg)
{
    outp(ChipBase + 0x0F, 0x22);            // Halt chip, bank 1
    outp(ScsiData, 0x00);                   // Release bus
    outp(ScsiCtrl, 0x00);                   // Release bus
    outp(ChipBase + 0x0F, 0x20);            // Bank 0
    outpw(ChipBase + 0x0E, 0x0000);         // Disable SCAM
    outp(ChipBase + 0x0F, CCReg & 0xEF);    // Start chip
    DvcSCAMDelayMS(60);                     // Wait 60ms
}

//**************************************************************************
//
//  Scam() -- Run SCAM
//
// Returns bit map of devices SCAMed, else -1 if error.
//
//**************************************************************************
int AscSCAM(ASC_DVC_VAR asc_ptr_type *asc_dvc)
{
    UCHAR       ID;
    UCHAR       SCAMTolerant;
    UCHAR       SCAMUsed;
    UCHAR       IDBit;
    int         status;
    UCHAR       CCReg;

    DebugPrintf(("\n%ff%b1SCAM 1.0E brought to you by Dave The ScamMan! :D "));
    DebugPrintf((__DATE__ " " __TIME__ "\n"));

    //
    // Look up interface type:
    //
    for (IFType = 0; IFType < 3; IFType++)
    {
        if (CardTypes[IFType] == asc_dvc->bus_type)
        {
            break;                      // Found it.
        }
    }

    //
    // Init globals based on card type and parms:
    //
    ChipBase = asc_dvc->iop_base;
    ScsiCtrl = ChipBase + 0x09;
    ScsiData = ChipBase + 0x0B;

    CCReg = inp(ChipBase + 0x0F);           // Save original Chip Control Reg
    outp(ChipBase + 0x0F, 0x22);            // Halt, Bank 1
    outp(ScsiData, 0x00);                   // Release bus
    outp(ScsiCtrl, 0x00);                   // Release bus
    DvcSCAMDelayMS(1);                      // Wait 1ms
    outp(ChipBase + 0x0F, 0x20);            // Bank 0
    outpw(ChipBase + 0x0E, 0x2000);         // Enable SCAM

    /*
    ** Get our SCSI ID from EEPROM and set into config reg.
    */

    /* Karl 4/24/96, replaced by getting from asc_dvc
    **
    ** MyID = (AscReadEEPWord(ChipBase, (UCHAR)(6+((IFType == 2)? 0:30))) >> 8) & 0x07;
    **
    */

    MyID = asc_dvc->cfg->chip_scsi_id ;
    AscSetChipScsiID(ChipBase, MyID);
    outp(ChipBase + 0x0F, 0x22);            // Bank 1

    /*
    ** Get SCAM intolerants:
    */
    SCAMTolerant = asc_dvc->no_scam;

    /*
    ** Identify SCAM tolerant devices on bus
    */
    DebugPrintf(("\nSearching for scam tolerant devices------------\n", ID));
    for (ID = 0, IDBit = 1; IDBit; ID++, IDBit <<= 1)
    {
        if (SCAMTolerant & IDBit)
        {
            continue;
        }
        if (ID == MyID)
        {
            DebugPrintf(("ID #%d in use by host...\n", ID));
            SCAMTolerant |= IDBit;
            continue;
        }
        if ((status = ScamSel(ID)) < 0)
        {
            DebugPrintf(("Error searching for SCAM tolerants!\n"));
            Cleanup(CCReg);
            return(-1);
        }
        if (status == 1)
        {
            DebugPrintf(("ID #%d in use...\n", ID));
            SCAMTolerant |= IDBit;
        }
    }

//  DvcSCAMDelayMS(1);
    DelayNS(ns2400);  // we must have enough delay here because
    DelayNS(ns2400);  // without delay a NEC driver will respond
    DelayNS(ns2400);  // to the following SCAM select as a normal
    DelayNS(ns2400);  // select, i.e. drive busy in 4 msec.   YPC 5/7/97
    DelayNS(ns2400);

    //
    // Snatch a copy of the devices we're ignoring so we can compute
    // our return value:
    //
    SCAMUsed = SCAMTolerant;

    //
    // Attempt to initiate SCAM protocol:
    //
    if (!StartSCAM())
    {
        DebugPrintf(("Unable to initiate SCAM protocol!\n"));
        Cleanup(CCReg);
        return(-1);
    }

    //
    // Loop isolating and assigning ID's
    //
    DebugPrintf(("\nIsolation phase, assigning ID's----------------\n", ID));
    for (ID = 0; ID < 8; ID++)
    {
        //
        // Assign an ID
        //
        if (!AssignID(&SCAMTolerant))
        {
            DebugPrintf(("End of isolation, %d bits read\n", BCount));
            break;
        }// End if
    }// End for

    //
    // Exit SCAM protocol:
    //
    if ( Tranceive(SCAMF_SYNC) < 0
        || Tranceive(SCAMF_CPC) < 0 )
    {
        DebugPrintf(("Unable to send SYNC / CPC!\n"));
        Cleanup(CCReg);
        return(-1);
    }// End if

    DebugPrintf(("Configuration complete!\n\n"));

    Cleanup(CCReg);
    return(SCAMTolerant ^ SCAMUsed);
}

#endif /* CC_SCAM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_scam2.c ===
//**************************************************************************
//
// Copyright (c) 1994-1998 Advanced System Products, Inc.
// All Rights Reserved.
//
//  SCAM Selection protocol
//
//**************************************************************************

//
// CDB's
//
UCHAR CDB_TUR[] =
{
    0,  0,  0,  0,  0,  0
};

//**************************************************************************
//
//  WaitPhase()
//
//  This function waits the specified time (in ms) for the specified
//  bus condition.
//
//  Parms:  phase = Bits to check
//          result = Bits expected
//          timeout = Time in ms to wait
//
//  Return: TRUE if timeout, otherwise FALSE
//
//**************************************************************************
BOOL WaitPhase( UCHAR phase, UCHAR result, UINT timeout)
{
    while (timeout--)
    {
        if ((inp(ScsiCtrl) & phase) == result)
            return(FALSE);

        DvcSCAMDelayMS(1);
    }
    return(TRUE);
}

//**************************************************************************
//
//  ScsiXmit()
//
//  This function transmits the specified byte with REQ/ACK protocol.
//
//  Parms:  data = byte to transmit
//
//  Return: TRUE if timeout, otherwise FALSE
//
//**************************************************************************
BOOL ScsiXmit(UCHAR data)
{
    //
    // Wait for REQ
    //
    if (WaitPhase(REQI, REQI, 1000))
    {
        DebugPrintf(("ScsiXmit: Failed to receive REQ.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(TRUE);
    }

    outp(ScsiData, data);                   // Assert the data
    inp(ScsiCtrl);                          // Delay 55ns
    outp(ScsiCtrl, ACKO);                   // Assert ACK

    //
    // Wait for Target to release REQ
    //
    if (WaitPhase(REQI, 0, 1000))
    {
        DebugPrintf(("ScsiXmit: Target failed to release REQ.\n"));
        outp(ScsiCtrl, 0);                  // Release Bus
        outp(ScsiData, 0);                  // Release Bus
        return(TRUE);
    }

    outp(ScsiCtrl, 0);                      // Release Bus
    outp(ScsiData, 0);                      // Release Bus
    return(FALSE);
}

//**************************************************************************
//
//  ScsiRcv()
//
//  This function receives one byte with REQ/ACK protocol.
//
//  Parms:  None
//
//  Return: <0 if error, else byte input
//
//**************************************************************************
int ScsiRcv( VOID )
{
    UCHAR data;

    data = inp(ScsiData);               // Read the data
    outp(ScsiCtrl, ACKO);               // Assert ACK

    //
    // Wait for Target to release REQ
    //
    if (WaitPhase(REQI, 0, 1000))
    {
        DebugPrintf(("ScsiRcv: Target failed to release REQ.\n"));
        outp(ScsiCtrl, 0);                  // Release Bus
        return(-1);
    }

    outp(ScsiCtrl, 0);                      // Release Bus
    return(data);
}

//**************************************************************************
//
//  XmitCDB() -- Send a CDB to device.
//
//  This function attempts to send the specified CDB to the device.
//
//  Parms:  len = size of CDB
//          pCDB = pointer to CDB
//
//  Return: TRUE if timeout, otherwise FALSE
//
//**************************************************************************
BOOL XmitCDB(int len, UCHAR *pCDB)
{
    while (len--)
    {
        if (ScsiXmit(*(pCDB++)))
        {
            DebugPrintf(("XmitCDB: Target failed to release REQ.\n"));
            return(TRUE);
        }
    }
    return(FALSE);
}

//**************************************************************************
//
//  Select() -- Attempt to select SCAM tolerant device
//
//  This function attempts to select the specified device, if the device
//  responds to selection within 1ms, it is considered SCAM tolerant.
//
//  Parms:  ID =  ID to be tested
//
//  Return: 1 if SCAM tolerant, 0 if not, < 0 if error.
//
//  NOTE: It is assumed on entry that the SEL and BSY are asserted as
//      result of winning arbitration.
//
//**************************************************************************
int Select( UCHAR ID )
{
    UCHAR       IDBit;
    int         state;

    IDBit = IDBits[ID];

    DelayNS(ns1200);                        // Delay 1.2us
    outp(ScsiData, IDBit | IDBits[MyID]);   // Output My ID and target's
    outp(ScsiCtrl, BSY | SEL | ATN);        // Assert attention
    inp(ScsiCtrl);                          // Wait 90 ns (2 deskews)
    outp(ScsiCtrl, SEL | ATN);              // Release BSY

    state = DvcDisableCPUInterrupt();
    DvcSCAMDelayMS(2);                      // Wait 2ms
    DvcRestoreCPUInterrupt(state);

    //
    // If target fails to respond in 1 ms, abort the select.
    //
    if ((inp(ScsiCtrl) & BSY) == 0)
    {
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(0);
    }

    //
    // Have a valid SCAM tolerant device, complete the protocol
    //
    inp(ScsiCtrl);                          // Wait 90 ns (2 deskews)
    outp(ScsiCtrl, ATN);                    // Release SEL

    return(1);
}

//**************************************************************************
//
//  ScamSel() -- Check ID for SCAM tolerance
//
//  This function attempts to select the specified device, if the device
//  responds to selection within 1ms, it is considered SCAM tolerant.
//
//  Parms:  ID =  ID to be tested
//
//  Return: 1 if SCAM tolerant, 0 if not, < 0 if error.
//
//**************************************************************************
int ScamSel( UCHAR ID )
{
    UINT      status;

    //
    // Arbitrate for bus master
    //
    if (!Arbitrate())
    {
        DebugPrintf(("SamSel: Failed arbitration.\n"));
        return(-1);
    }

    //
    // Select device
    //
    if ((status = Select(ID)) <= 0)
    {
        return(status);
    }

    //
    // Now, device is selected, we have to do something with it...
    // first, wait for REQ, and see if we've gone into Message out phase:
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | MSG | CD | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve MESSAGE OUT phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Drop ATN
    //
    outp(ScsiCtrl, 0x00);

    //
    // Send an Identity message:
    //
    if (ScsiXmit(SCSI_ID))
    {
        DebugPrintf(("ScamSel: Failed to send SCSI_ID.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for CMD phase
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | CD | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve COMMAND phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Send TUR CDB
    //
    if (XmitCDB(sizeof(CDB_TUR), CDB_TUR))
    {
        DebugPrintf(("ScamSel: Failed to transmit CDB_TUR.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for status phase
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | CD | IO | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve STATUS phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Read and ignore the status
    //
    if (ScsiRcv() < 0)
    {
        DebugPrintf(("ScamSel: Failed to receive STATUS.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for Message In phase
    //
    if (WaitPhase((UCHAR)(BSY | MSG | CD | IO | REQI), (UCHAR)(BSY | MSG | CD | IO | REQI), 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve MESSAGE IN phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Read message
    //
    if (ScsiRcv() < 0)
    {
        DebugPrintf(("ScamSel: Failed to receive MESSAGE IN.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    //
    // Wait for Bus Free
    //
    if (WaitPhase(BSY | SEL, 0, 1000))
    {
        DebugPrintf(("ScamSel: Failed to achieve BUS FREE phase.\n"));
        outp(ScsiData, 0x00);               // Release bus
        outp(ScsiCtrl, 0x00);               // Release bus
        return(-1);
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_scam.h ===
//**************************************************************************
//
// Copyright (c) 1994-1998 Advanced System Products, Inc.
// All Rights Reserved.
//
//  SCAM Header
//
//**************************************************************************

//
// Set to 1 to enable debug messages:
//
#define DEBUG_PRINT   0

#define UINT    unsigned int
#define BOOL    unsigned int
#define VOID    void

#ifndef UCHAR
#define UCHAR   unsigned char
#endif

//#define FALSE   (0)
//#define TRUE    (!FALSE)

//
// SCSI Control Signals:
//
#define SEL     (0x80)
#define BSY     (0x40)
#define REQO    (0x20)
#define ACKO    (0x10)
#define ATN     (0x08)
#define IO      (0x04)
#define CD      (0x02)
#define MSG     (0x01)

//
// REQ/ACK defs weird due to hardware differences
//
#define REQI    (reqI[IFType])
#define ACKI    (ackI[IFType])

//
// SCSI Data Signals:
//
#define DB7     (0x80)
#define DB6     (0x40)
#define DB5     (0x20)
#define DB4     (0x10)
#define DB3     (0x08)
#define DB2     (0x04)
#define DB1     (0x02)
#define DB0     (0x01)

//
// SCSI Message Codes
//
#define SCSI_ID     (0x80)

//
// SCAM Function Codes:
//
#define SCAMF_ISO   (0x00)
#define SCAMF_ISPF  (0x01)
#define SCAMF_CPC   (0x03)
#define SCAMF_DIC   (0x0F)
#define SCAMF_SYNC  (0x1F)

//
// SCAM transfer cycle command:
//
#define SCAM_TERM   (0x10)

//
// SCAM Action Codes, first quintet:
//
#define SCAMQ1_ID00 (0x18)
#define SCAMQ1_ID01 (0x11)
#define SCAMQ1_ID10 (0x12)
#define SCAMQ1_ID11 (0x0B)
#define SCAMQ1_CPF  (0x14)
#define SCAMQ1_LON  (0x14)
#define SCAMQ1_LOFF (0x14)

//
// SCAM Action Codes, second quintet:
//
#define SCAMQ2_CPF  (0x18)
#define SCAMQ2_LON  (0x12)
#define SCAMQ2_LOFF (0x0B)

//
// Debugging aids:
//
#if DEBUG_PRINT
#define DebugPrintf(x)  Dbg x
#else
#define DebugPrintf(x)
#endif

//
// Macros
//
#define DelayNS(x)  DelayLoop(x[IFType])

//
// Global data:
//
extern  UINT        IFType;                 // Interface type index
extern  PortAddr    ChipBase;               // Base IO address of chip
extern  PortAddr    ScsiCtrl;               // IO address of SCSI Control Reg
extern  PortAddr    ScsiData;               // IO address of SCSI Data Reg
extern  UCHAR       MyID;                   // Our ID
extern  UCHAR       reqI[];                 // Array of REQ bits by board
extern  UCHAR       ackI[];                 // Array of REQ bits by board

//
// Constants :
//
extern  UCHAR   IDBits[8];
extern  UCHAR   IDQuint[8];                 // Quintets for setting ID's
extern  UINT    ns1200[];                   // loop counts for 1.2us
extern  UINT    ns2000[];                   // loop counts for 2.0us
extern  UINT    ns2400[];                   // loop counts for 2.4us
extern  UINT    us1000[];                   // loop counts for 1.0ms
extern  UINT    dgl[];                      // DeGlitch counts

//
//  Functions defined in SCAM.C:
//
UINT DeGlitch(                      // Deglitch one or more signals
    PortAddr iop,                   // IO port to read
    UCHAR msk,                      // Mask of signals to test
    UINT loops);                    // Number of itterations signals must be low

int DeSerialize(VOID);              // Deserialize one byte of scam data
BOOL Arbitrate( VOID );             // Arbitrate for bus control
VOID DelayLoop( UINT ns );          // Delay a short time

//
// Functions Defined in SELECT.C
//
int ScamSel(                        // Check for SCAM tolerance.
    UCHAR ID);                      // ID to select
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc\a_winnt.h ===
//
// Copyright (c) 1994-1997 Advanced System Products, Inc.
// All Rights Reserved.
//
// a_winnt.h
//
//

#include "ascdef.h"

#define UBYTE  uchar
#define ULONG  ulong

//
// PortAddr must be an unsigned long to support Alpha and x86
// in the same driver.
//
#define PortAddr  unsigned long       // port address size
#define PORT_ADDR       PortAddr
#define AscFunPtr ulong               // pointer to function for call back

#define PBASE_REGISTER PORT_ADDR

#define far
#define Lptr
#define dosfar

/*
 * Define Asc Library required I/O port macros.
 */
#define inp(addr) \
    ScsiPortReadPortUchar((uchar *) (addr))
#define inpw(addr) \
    ScsiPortReadPortUshort((ushort *) (addr))
#define inpd(addr) \
    ScsiPortReadPortUlong((ulong *) (addr))
#define outp(addr, byte) \
    ScsiPortWritePortUchar((uchar *) (addr) , (uchar) (byte))
#define outpw(addr, word) \
    ScsiPortWritePortUshort((ushort *) (addr), (ushort) (word))
#define outpd(addr, dword) \
    ScsiPortWritePortUlong((ulong *) (addr), (ulong) (dword))

// Size of a function pointer:
#define  Ptr2Func  ULONG

#define NULLPTR  ( void *)0   /* null pointer  */
//#define FNULLPTR ( void far *)0   /* Far null pointer  */
#define EOF      (-1)         /* end of file   */
#define EOS      '\0'         /* end of string */
#define ERR      (-1)         /* boolean error */
#define UB_ERR   (uchar)(0xFF)         /* unsigned byte error */
#define UW_ERR   (uint)(0xFFFF)        /* unsigned word error */
//#define UL_ERR   (ulong)(0xFFFFFFFF)   /* unsigned long error */


#ifndef NULL
#define NULL     0            /* zero          */
#endif

#define isodd_word( val )   ( ( ( ( uint )val) & ( uint )0x0001 ) != 0 )

//
//      Max Scatter Gather List Count. 
//

#define ASC_MAX_SG_QUEUE	7
/*
 * The NT driver returns NumberOfPhysicalBreaks to NT which is 1 less
 * then the maximum scatter-gather count. But NT incorrectly sets
 * MaximumPhysicalPages, the parameter class drivers use, to the value
 * of NumberOfPhsysicalBreaks. Set ASC_MAX_SG_LIST to 257 to allow class
 * drivers to actually send 1MB requests (256 * 4KB) *and* to insure
 * the AdvanSys driver won't be broken if Microsoft decides to fix NT
 * in the future and set MaximumPhysicalPages to NumberOfPhsyicalBreaks + 1.
 */
#define ASC_MAX_SG_LIST		257

// For SCAM:
#define CC_SCAM   TRUE
#define DvcSCAMDelayMS(x)           DvcSleepMilliSecond(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\asc3550.c ===
/*
 * AdvanSys 3550 Windows NT SCSI Miniport Driver - asc3550.c
 *
 * Copyright (c) 1994-1998  Advanced System Products, Inc.
 * All Rights Reserved.
 *
 * This Windows 95/NT Miniport driver is written and tested
 * to work with Windows 95, Windows NT 3.51, and Windows NT 4.0.
 *
 * The Driver has the following sections. Each section can be found
 * by searching for '---'.
 *
 *  --- Debug Constants
 *  --- Driver Include Files
 *  --- Debug Definitions
 *  --- Driver Global Data
 *  --- Driver Function Prototypes
 *  --- Initial Driver Entrypoint - DriverEntry()
 *  --- DriverEntry() Support Functions
 *  --- Driver Instance Entrypoint Functions
 *  --- Driver Support Functions
 *  --- Adv Library Required Functions
 *  --- Debug Function Definitions
 *
 */


/*
 * --- Debug Constants
 *
 * Compile time debug options are enabled and disabled here. All debug
 * options must be disabled for the retail driver release.
 */

#if DBG != 0
#define ASC_DEBUG            /* Enable tracing messages. */
#endif /* DBG != 0 */

/*
 * --- Driver Include Files
 */


/* Driver and Adv Library include files */
#include "a_ver.h"
#include "d_os_dep.h"           /* Driver Adv Library include file */
#include "a_scsi.h"
#include "a_condor.h"
#include "a_advlib.h"
#include "asc3550.h"            /* Driver specific include file */

/*
 * --- Debug Definitions
 */

/*
 * --- Driver Global Data
 */

/*
 * AdvanSys PCI Vendor and Device IDs
 *
 * XXX - these definitions should be automatically synched with
 * the Adv Library ADV_PCI_VENDOR_ID and ADV_PCI_DEVICE_ID_REV_A
 * definitions.
 */
UCHAR VenID[4] = { '1', '0', 'C', 'D' };
UCHAR DevID[4] = { '2', '3', '0', '0' };

/*
 * --- Driver Function Prototypes
 */

ulong HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

ulong SearchPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN ulong config_ioport,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    );

BOOLEAN HwInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN HwInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ulong PathId
    );

SCSI_ADAPTER_CONTROL_STATUS HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
        IN PVOID Paramters
    );

int
AscExecuteIO(
    IN PSCSI_REQUEST_BLOCK srb
    );

int BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    );

VOID DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_SCSI_REQ_Q *scb
    );

VOID DvcSBResetCallBack(
    IN PCHIP_CONFIG chipConfig
    );

UCHAR ErrXlate (
    UCHAR host_status
    );

VOID AscZeroMemory(IN UCHAR *cp, IN ULONG length);


/*
 * --- Initial Driver Entrypoint - DriverEntry()
 *
 * DriverEntry()
 *
 * Routine Description:
 *     Installable driver initialization entry point for system.
 * 
 * Arguments:
 *     Driver Object
 *             
 * Return Value:
 *     Status from ScsiPortInitialize()
 */
ulong
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    HW_INITIALIZATION_DATA      hwInitializationData;
    SRCH_CONTEXT                Context;
    ulong                       status;

    ASC_DBG(2, "Asc3550: DriverEntry: begin\n");

    /* Display Driver Parameters */
    ASC_DBG2(2, "Asc3550: sizeof(SRB_EXTENSION) %lu, ASC_NUM_SG_BLOCK %lu\n",
        sizeof(SRB_EXTENSION), ASC_NUM_SG_BLOCK);
    ASC_DBG2(2, "Asc3550: ADV_MAX_SG_LIST %lu, ASC_SG_TOTAL_MEM_SIZE %lu\n",
        ADV_MAX_SG_LIST, ASC_SG_TOTAL_MEM_SIZE);
#if ADV_INITSCSITARGET
    ASC_DBG2(2,
        "Asc3550: ADV_SG_LIST_MAX_BYTE_SIZE %lu, ASC_WORKSPACE_SIZE %lu\n",
        ADV_SG_LIST_MAX_BYTE_SIZE, ASC_WORKSPACE_SIZE);
#else /* ADV_INITSCSITARGET */
    ASC_DBG1(2,
        "Asc3550: ADV_SG_LIST_MAX_BYTE_SIZE %lu\n",
        ADV_SG_LIST_MAX_BYTE_SIZE);
#endif /* ADV_INITSCSITARGET */

    /*
     * Set-up hardware initialization structure used to initialize
     * each adapter instance.
     *
     * Zero out structure and set size.
     */
    AscZeroMemory((PUCHAR) &hwInitializationData,
        sizeof(HW_INITIALIZATION_DATA));
    hwInitializationData.HwInitializationDataSize =
        sizeof(HW_INITIALIZATION_DATA);
        
    /*
     * Set driver entry points.
     */
    hwInitializationData.HwInitialize = HwInitialize;
    hwInitializationData.HwResetBus = HwResetBus;
    hwInitializationData.HwStartIo = HwStartIo;
    hwInitializationData.HwInterrupt = HwInterrupt;
    hwInitializationData.HwDmaStarted = NULL;
    // 'HwAdapterControl' is a SCSI miniport interface added with NT 5.0.
    hwInitializationData.HwAdapterControl = HwAdapterControl;
    hwInitializationData.HwAdapterState = NULL;

    /*
     * Need physical addresses.
     */
    hwInitializationData.NeedPhysicalAddresses = TRUE;
    hwInitializationData.AutoRequestSense = TRUE;
    hwInitializationData.MapBuffers = TRUE;

    /*
     * Enable tag queuing
     */
    hwInitializationData.TaggedQueuing = TRUE;
    hwInitializationData.MultipleRequestPerLu = TRUE;
    hwInitializationData.ReceiveEvent = FALSE;

    /*
     * Specify size of adapter and request extensions.
     */
    hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);
    hwInitializationData.SpecificLuExtensionSize = 0;
    hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);

    /*
     * If PCI memory is going to be used to access Condor's
     * registers, then set 2 access ranges: I/O Space, PCI Memory
     */
#if ADV_PCI_MEMORY
    hwInitializationData.NumberOfAccessRanges = 2;
#else /* ADV_PCI_MEMORY */
    hwInitializationData.NumberOfAccessRanges = 1;
#endif /* ADV_PCI_MEMORY */

    /*
     * Set-up and run search for PCI Adapters.
     */

    /* XXX - lengths needs to be in sync with 'VenID', 'DevID' definitions. */
    hwInitializationData.VendorIdLength = 4;
    hwInitializationData.VendorId = VenID;
    hwInitializationData.DeviceIdLength = 4;
    hwInitializationData.DeviceId = DevID;

    hwInitializationData.AdapterInterfaceType = PCIBus;
    hwInitializationData.HwFindAdapter = HwFindAdapterPCI;

    /* Before starting the search, zero out the search context. */
    AscZeroMemory((PUCHAR) &Context, sizeof(SRCH_CONTEXT));

    status = ScsiPortInitialize(DriverObject, Argument2,
                (PHW_INITIALIZATION_DATA) &hwInitializationData, &Context);

    ASC_DBG1(2, "Asc3550: DriverEntry: status %ld\n", status);
    return status;
}


/*
 * --- DriverEntry() Support Functions
 */

/*
 * HwFindAdapterPCI()
 *
 * Find an instance of an AdvanSys PCI adapter. Windows 95/NT will either
 * pass a non-zero I/O port where it expects this function to look for an
 * adapter or it will pass a zero I/O port and expect the function to
 * scan the PCI bus for an adapter.
 *
 * If an adapter is found, return SP_RETURN_FOUND with *Again set to TRUE.
 * If an adapter is not found, return SP_RETURN_NOT_FOUND with *Again set
 * to FALSE. If an adapter is found but an error occurred while trying to
 * initialize it, return SP_RETURN_ERROR with *Again set to TRUE.
 */
ulong
HwFindAdapterPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ulong                    config_ioport;

    *Again = FALSE;

#ifdef ASC_DEBUG
    {
        /* 
         * Display the access ranges for the adapter supplied
         * by Windows 95/NT.
         */
        uint i;

        ASC_DBG1(2, "HwFindAdapterPCI: NumberOfAccessRanges %lu\n",
            ConfigInfo->NumberOfAccessRanges);
        for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {
            ASC_DBG1(2,
                "HwFindAdapterPCI: [%lu]:\n", i);
            ASC_DBG3(2,
                "  RangeStart 0x%lx, RangeLength 0x%lx, RangeInMemory %d\n",
                ScsiPortConvertPhysicalAddressToUlong(
                    (*ConfigInfo->AccessRanges)[i].RangeStart),
                    (*ConfigInfo->AccessRanges)[i].RangeLength,
                    (*ConfigInfo->AccessRanges)[i].RangeInMemory);
        }
    }
#endif /* ASC_DEBUG */
   
    /*
     * If Windows 95/NT provided an I/O Port, then try to find an AdvanSys
     * adapter at that I/O Port.
     *
     * Otherwise scan the PCI Configuration Space for AdvanSys adapters.
     */

    /* Adapter I/O Port is the first access range. */
    config_ioport = ScsiPortConvertPhysicalAddressToUlong(
        (*ConfigInfo->AccessRanges)[0].RangeStart);

    if (config_ioport != 0)
    {
        ASC_DBG1(2,
            "HwFindAdapterPCI: Windows 95/NT specified I/O port: 0x%x\n",
            config_ioport);
        switch (SearchPCI(HwDeviceExtension, BusInformation,
                      ArgumentString, config_ioport, ConfigInfo)) {
        case SP_RETURN_FOUND:
            *Again = TRUE;
            return SP_RETURN_FOUND;
        case SP_RETURN_ERROR:
            *Again = TRUE;
            return SP_RETURN_ERROR;
        case SP_RETURN_NOT_FOUND:
            return SP_RETURN_NOT_FOUND;
        }
        /* NOTREACHED */
    }
    return SP_RETURN_NOT_FOUND;
}

/*
 * SearchPCI()
 *
 * Search for an AdvanSys PCI adapter at the location specified
 * by 'ConfigInfo'. The PCI Configuration Slot Number, Device Number, 
 * and Function Number specify where to look for the device. If the
 * I/O Port specified in 'ConfigInfo' is non-zero then check it against
 * the I/O Port found in the PCI Configuration Space. Otherwise if the
 * I/O Port is zero, just use the I/O Port obtained from the PCI
 * Configuration Space. Check the adapter IRQ in the same way.
 *
 * If an adapter is found, return SP_RETURN_FOUND. If an adapter is not
 * found, return SP_RETURN_NOT_FOUND. If an adapter is found but an error
 * occurs with trying to initialize it, return SP_RETURN_ERROR.
 */
ulong
SearchPCI(
    IN PVOID HwDeviceExtension,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN ulong config_ioport,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
    PortAddr                pci_ioport;
#if ADV_PCI_MEMORY
    PortAddr                pci_memaddr;
#endif /* ADV_PCI_MEMORY */
    PHW_DEVICE_EXTENSION    deviceExtension = HwDeviceExtension;
    PCHIP_CONFIG            chipConfig = &HDE2CONFIG(deviceExtension);
    USHORT                  initstat;
    PCI_SLOT_NUMBER         pci_slot;
    PCI_COMMON_CONFIG       pci_config;
    ulong                   size;
    PVOID                   map_ioport;
    int                     i;

    /* Set the 'pci_slot' DeviceNumber . */
    pci_slot.u.AsULONG = 0L;
    pci_slot.u.bits.DeviceNumber = ConfigInfo->SlotNumber;

    ASC_DBG3(2,
        "SearchPCI: SystemIoBusNumber %x, DeviceNumber %x, FunctionNumber %x\n",
        ConfigInfo->SystemIoBusNumber,
        pci_slot.u.bits.DeviceNumber, pci_slot.u.bits.FunctionNumber);

    if ((size = ScsiPortGetBusData(
            HwDeviceExtension,               /* HwDeviceExtension */
            PCIConfiguration,                /* Bus type */
            (ulong) ConfigInfo->SystemIoBusNumber,   /* Bus Number */
            pci_slot.u.AsULONG,              /* Device and Function Number */
            &pci_config,                     /* Buffer */
            sizeof(PCI_COMMON_CONFIG)        /* Length */
            )) != sizeof(PCI_COMMON_CONFIG)) {

        ASC_DBG1(1, "SearchPCI: bad PCI config size: %lu\n", size);

        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, size));
        return SP_RETURN_NOT_FOUND;
    }

#ifdef ASC_DEBUG

    /*
     * Display PCI Configuration Information
     */

    ASC_DBG(2, "SearchPCI: Found adapter PCI Configuration information:\n");

    ASC_DBG3(2,
        "SearchPCI: SystemIoBusNumber %x, DeviceNumber %x, FunctionNumber %x\n",
         ConfigInfo->SystemIoBusNumber,
         pci_slot.u.bits.DeviceNumber, pci_slot.u.bits.FunctionNumber);

    ASC_DBG4(2,
        "SearchPCI: VendorID %x, DeviceID %x, Command %x, Status %x\n",
        pci_config.VendorID, pci_config.DeviceID,
        pci_config.Command, pci_config.Status);

    ASC_DBG3(2,
        "SearchPCI: RevisionID %x, CacheLineSize %x, LatencyTimer %x\n",
        pci_config.RevisionID, pci_config.CacheLineSize,
        pci_config.LatencyTimer);

    ASC_DBG2(2,
        "SearchPCI: BaseAddresses[0] %lx, BaseAddresses[1] %lx\n",
        pci_config.u.type0.BaseAddresses[0], 
        pci_config.u.type0.BaseAddresses[1]);

    ASC_DBG2(2,
        "SearchPCI: ROMBaseAddress %lx, InterruptLine %lx\n",
        pci_config.u.type0.ROMBaseAddress,
        pci_config.u.type0.InterruptLine);

#endif /* ASC_DEBUG */


    /*
     * Check returned PCI configuration information.
     */

    if (pci_config.VendorID == PCI_INVALID_VENDORID) {
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_config.VendorID));
        return SP_RETURN_NOT_FOUND;
    }

    if (pci_config.VendorID != ADV_PCI_VENDOR_ID)
    {
        ASC_DBG1(2, "SearchPCI: PCI Vendor ID mismatch: 0x%x\n",
            pci_config.VendorID);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_config.VendorID));
        return SP_RETURN_NOT_FOUND;
    }

    if (pci_config.DeviceID != ADV_PCI_DEVICE_ID_REV_A) 
    {
        ASC_DBG1(2, "SearchPCI: Device ID mismatch: 0x%x\n",
            pci_config.DeviceID);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_config.DeviceID));
        return SP_RETURN_NOT_FOUND;
    }

    /*
     * Set ConfigInfo IRQ information 
     */
    if (ConfigInfo->BusInterruptLevel != pci_config.u.type0.InterruptLine) {
        ASC_DBG2(1,
            "SearchPCI: ConfigInfo IRQ 0x%x != PCI IRQ 0x%x\n",
            ConfigInfo->BusInterruptLevel, pci_config.u.type0.InterruptLine);
    }

    ConfigInfo->BusInterruptLevel = pci_config.u.type0.InterruptLine;

    /*
     * Set ConfigInfo I/O Space Access Range Information
     */
    ASC_DBG1(2, "SearchPCI: PCI BaseAddresses[0]: 0x%x\n",
        pci_config.u.type0.BaseAddresses[0] & (~PCI_ADDRESS_IO_SPACE));

    pci_ioport = (PortAddr)
        (pci_config.u.type0.BaseAddresses[0] & (~PCI_ADDRESS_IO_SPACE));

    ASC_DBG1(2, "SearchPCI: pci_ioport 0x%lx\n", pci_ioport);

    /*
     * If the given I/O Port does not match the I/O Port address
     * found for the PCI device, then return not found.
     */
    if (config_ioport != pci_ioport) {
        ASC_DBG2(1,
            "SearchPCI: config_ioport 0x%x != pci_ioport 0x%x\n",
            config_ioport, pci_ioport);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PCI_CONF, pci_ioport));
        return SP_RETURN_NOT_FOUND;
    }


#if ADV_PCI_MEMORY
    /*
     * Set PCI Memory Space access range information
     */

    ASC_DBG1(2, "SearchPCI: PCI BaseAddresses[1]: 0x%lx\n",
        pci_config.u.type0.BaseAddresses[1] & (~PCI_ADDRESS_MEMORY_TYPE_MASK));

    pci_memaddr = (PortAddr)
        (pci_config.u.type0.BaseAddresses[1] &
        (~PCI_ADDRESS_MEMORY_TYPE_MASK));

    ASC_DBG1(2, "SearchPCI: pci_memaddr 0x%lx\n", pci_memaddr);

    /*
     * Set 'ConfigInfo' information for ScsiPortGetDeviceBase().
     */
    (*ConfigInfo->AccessRanges)[1].RangeStart =
        ScsiPortConvertUlongToPhysicalAddress(pci_memaddr);
    (*ConfigInfo->AccessRanges)[1].RangeLength = ADV_CONDOR_IOLEN;
    (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;
#endif /* ADV_PCI_MEMORY */

#if ADV_PCI_MEMORY
    /*
     * If PCI memory access has been set for Condor, then obtain
     * a mapping for 'pci_memaddr' to allow Condor's registers to
     * be accessed through memory references. Otherwise obtain a
     * mapping for 'pci_ioport' and access Condor's registers with
     * PIO instructions.
     */
    ASC_DBG(2, "SearchPCI: Memory Space ScsiPortGetDeviceBase() Mapping.\n");

    map_ioport = ScsiPortGetDeviceBase(
     HwDeviceExtension,                   /* HwDeviceExtension */
     ConfigInfo->AdapterInterfaceType,    /* AdapterInterfaceType */
     ConfigInfo->SystemIoBusNumber,       /* SystemIoBusNumber */
     (*ConfigInfo->AccessRanges)[1].RangeStart,  /* IoAddress */
     (*ConfigInfo->AccessRanges)[1].RangeLength, /* NumberOfBytes */ 
     (BOOLEAN) !(*ConfigInfo->AccessRanges)[1].RangeInMemory); /* InIoSpace */

#else /* ADV_PCI_MEMORY */

    /*
     * Convert 'config_ioport' to a possibly different mapped
     * I/O port address.
     */
    ASC_DBG(2, "SearchPCI: I/O Space ScsiPortGetDeviceBase() Mapping.\n");

    map_ioport = ScsiPortGetDeviceBase(
     HwDeviceExtension,                   /* HwDeviceExtension */
     ConfigInfo->AdapterInterfaceType,    /* AdapterInterfaceType */
     ConfigInfo->SystemIoBusNumber,       /* SystemIoBusNumber */
     (*ConfigInfo->AccessRanges)[0].RangeStart,  /* IoAddress */
     (*ConfigInfo->AccessRanges)[0].RangeLength, /* NumberOfBytes */ 
     (BOOLEAN) !(*ConfigInfo->AccessRanges)[0].RangeInMemory); /* InIoSpace */

#endif /* ADV_PCI_MEMORY */

    /*
     * PCI adapter found
     */
    ASC_DBG3(2, "SearchPCI: config_ioport 0x%x, map_ioport 0x%lx, IRQ 0x%x\n",
            config_ioport, map_ioport, ConfigInfo->BusInterruptLevel);

    /*
     * Fill-in Adv Library adapter information.
     */
    chipConfig->iop_base = (PortAddr) map_ioport;
    chipConfig->cfg = &HDE2INFO(deviceExtension);
    chipConfig->cfg->pci_device_id = pci_config.DeviceID;
    chipConfig->isr_callback = (Ptr2Func) &DvcISRCallBack;
    chipConfig->sbreset_callback = (Ptr2Func) &DvcSBResetCallBack;
    chipConfig->irq_no = (UCHAR) ConfigInfo->BusInterruptLevel;
    chipConfig->cfg->pci_slot_info =
         (USHORT) ASC_PCI_MKID(ConfigInfo->SystemIoBusNumber,
                    pci_slot.u.bits.DeviceNumber,
                    pci_slot.u.bits.FunctionNumber);
    CONFIG2HDE(chipConfig) = HwDeviceExtension;


    /*
     * Execute Adv Library initialization.
     */
    ASC_DBG(2, "SearchPCI: before AdvInitGetConfig\n");
    if ((initstat = (USHORT)AdvInitGetConfig(chipConfig)) != 0) {
        ASC_DBG1(1, "SearchPCI: AdvInitGetConfig warning code 0x%x\n",
            initstat);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_IWARN_CODE, initstat));
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AdvInitGetConfig: err_code 0x%x\n",
            chipConfig->err_code);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_IERR_CODE, chipConfig->err_code));

        /* Clear the 'iop_base' field to prevent the board from being used. */
        chipConfig->iop_base = (PortAddr) NULL;
        return SP_RETURN_ERROR;
    }
    ASC_DBG(2, "SearchPCI: AscInitGetConfig successful\n");

    /*
     * Fill-in Windows 95/NT ConfigInfo information.
     */
    ConfigInfo->NumberOfBuses = 1;
    ConfigInfo->InitiatorBusId[0] = chipConfig->chip_scsi_id;
    ConfigInfo->MaximumTransferLength = 0xFFFFFFFF;
    ConfigInfo->Master = TRUE;
    ConfigInfo->NeedPhysicalAddresses = TRUE;
    ConfigInfo->Dma32BitAddresses = TRUE;
    ConfigInfo->InterruptMode = LevelSensitive;
    ConfigInfo->AdapterInterfaceType = PCIBus;
    ConfigInfo->AlignmentMask = 0;
    ConfigInfo->BufferAccessScsiPortControlled = FALSE;
    ConfigInfo->MaximumNumberOfTargets = ASC_MAX_TID + 1;
    ConfigInfo->AdapterScansDown = FALSE;
    ConfigInfo->TaggedQueuing = TRUE;
    //
    // 'ResetTargetSupported' is flag added with NT 5.0 that will
    // result in SRB_FUNCTION_RESET_DEVICE SRB requests being sent
    // to the miniport driver.
    //
    ConfigInfo->ResetTargetSupported = TRUE;

    /*
     * Set NumberOfPhysicalBreaks in a single request that the driver
     * is capable of handling.
     *
     * According to the Windows 95/NT DDK miniport drivers are not supposed
     * to change NumberOfPhysicalBreaks if its value on entry is not
     * SP_UNINITIALIZED_VALUE. But AdvanSys has found that performance
     * can be improved by increasing the value to the maximum the
     * adapter can handle.
     *
     * Note: The definition of NumberOfPhysicalBreaks is "maximum
     * scatter-gather elements - 1". Windows 95/NT is broken in that
     * it sets MaximumPhysicalPages, the value class drivers use, to
     * the same value as NumberOfPhysicalBreaks. This bug should be
     * reflected in the value of ADV_MAX_SG_LIST, which should be
     * one greater than it should have to be.
     */
    ConfigInfo->ScatterGather = TRUE;
    ConfigInfo->NumberOfPhysicalBreaks = ADV_MAX_SG_LIST - 1;

    /*
     * Zero out per adapter request wait queue.
     */
    AscZeroMemory((PUCHAR) &HDE2WAIT(deviceExtension), sizeof(asc_queue_t));

    /* Initialize the device type filed to NO_DEVICE_TYPE value */
    for ( i = 0; i <= ASC_MAX_TID; i++ )
    {
        deviceExtension->dev_type[i] =  0x1F;
    }

    ASC_DBG(2, "SearchPCI: SP_RETURN_FOUND\n");
    return SP_RETURN_FOUND;
}


/*
 * --- Driver Instance Entrypoint Functions
 *
 * These entrypoint functions are defined by the initial driver
 * entrypoint 'DriverEntery()' for each driver instance or adapter.
 */

/*
 * HwInitialize()
 *
 * Routine Description:
 * 
 *   This routine is called from ScsiPortInitialize
 *   to set up the adapter so that it is ready to service requests.
 * 
 * Arguments:
 * 
 *   HwDeviceExtension - HBA miniport driver's adapter data storage
 * 
 * Return Value:
 * 
 *   TRUE - if initialization successful.
 *   FALSE - if initialization unsuccessful.
 */
BOOLEAN
HwInitialize(
    IN PVOID HwDeviceExtension
    )
{
    PCHIP_CONFIG            chipConfig = &HDE2CONFIG(HwDeviceExtension);
    USHORT                  initstat;
    
    ASC_DBG1(2, "HwInitialize: chipConfig 0x%lx\n", chipConfig);

    /*
     * If 'iop_base' is NULL, then initialization must have failed.
     */
    if (chipConfig->iop_base == (PortAddr) NULL) {
        ASC_DBG(1, "HwInitialize: iop_base is NULL\n");
        return FALSE;
    }

    if ((initstat = (USHORT)AdvInitAsc3550Driver(chipConfig)) != 0) {
        ASC_DBG1(1, "AdvInitAsc3550Driver: warning code 0x%x\n", initstat);

        /*
         * Log the warning only if the 'err_code' is zero. If the
         * 'err_code' is non-zero it will be logged below.
         */
        if (chipConfig->err_code == 0) {
            ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
                SP_INTERNAL_ADAPTER_ERROR,
                ADV_SPL_UNIQUEID(ADV_SPL_IWARN_CODE, initstat));
        }
    }

    if (chipConfig->err_code != 0) {
        ASC_DBG1(1, "AdvInitAsc3550Driver: err_code 0x%x\n",
            chipConfig->err_code);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_IERR_CODE, chipConfig->err_code));
        return FALSE;
    } else {
        ASC_DBG(2, "AdvInitAsc3550Driver: successful\n");
    }

    ASC_DBG(2, "HwInitialize: TRUE\n");
    return TRUE;
}

/*
 * Routine Description:
 * 
 *     This routine is called from the SCSI port driver to send a
 *     command to controller or target. 
 * 
 * Arguments:
 * 
 *     HwDeviceExtension - HBA miniport driver's adapter data storage
 *     Srb - IO request packet
 * 
 * Return Value:
 * 
 *     TRUE
 * 
 */
BOOLEAN
HwStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )
{
    PCHIP_CONFIG    chipConfig;
    asc_queue_t     *waitq;

    ASC_DBG(4, "HwStartIo: begin\n");

    ASC_DBG2(4, "HwStartIo: srb 0x%lx, SrbExtension 0x%lx\n",
        srb, srb->SrbExtension);

    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    waitq = &HDE2WAIT(HwDeviceExtension);
    
    switch (srb->Function) {

    case SRB_FUNCTION_ABORT_COMMAND:
        ASC_DBG1(1, "HwStartIo: Abort srb 0x%lx \n", srb->NextSrb);
        ASC_DBG1(1, "chipConfig 0x%lx\n", chipConfig);
        if (asc_rmqueue(waitq, srb->NextSrb) == ADV_TRUE) {
            ASC_DBG(2, "Abort success from waitq.\n");
            /* Complete the aborted SRB 'NextSrb'. */
            srb->NextSrb->SrbStatus = SRB_STATUS_ABORTED;
            ScsiPortNotification(RequestComplete, HwDeviceExtension,
                srb->NextSrb);
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else if (AdvAbortSRB(chipConfig, (ulong) srb->NextSrb)) {
            ASC_DBG(2, "Abort success.\n");
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else {
            ASC_DBG(1, "Abort failure.\n");
            /*
             * The aborted request may already be on the adapter
             * done list and will be completed below. But in case
             * it isn't set an error indicating that the abort
             * failed and continue.
             */
            srb->SrbStatus = SRB_STATUS_ERROR;
        }

        /*
         * Call AdvISR() to process all requests completed by the
         * microcode and then call AscCompleteRequest() to complete
         * these requests to the OS. If AdvAbortSRB() succeeded,
         * then one of the requests completed will include the
         * aborted SRB.
         */
        (void) AdvISR(chipConfig);
        AscCompleteRequest(HwDeviceExtension);

        /* Complete current SRB and ask for the next request. */
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_RESET_BUS:
        /*
         * Reset SCSI bus.
         */
        ASC_DBG(1, "HwStartIo: Reset Bus\n");
        HwResetBus (chipConfig, 0L);
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_EXECUTE_SCSI:

        ASC_DBG(4, "HwStartIo: Execute SCSI\n");
        /*
         * Set the srb's Device Extension pointer before attempting to start
         * the IO. It will be needed for any retrys and in DvcISRCallBack().
         */
        SRB2HDE(srb) = HwDeviceExtension;

        /* Execute any queued commands for the host adapter. */
        if (waitq->tidmask) {
            asc_execute_queue(waitq);
        }

        /*
         * If the target for the current command has any queued
         * commands or if trying to execute the command returns
         * BUSY, then enqueue the command.
         */
        if ((waitq->tidmask & ADV_TID_TO_TIDMASK(srb->TargetId)) ||
            (AscExecuteIO(srb) == ADV_BUSY)) {
            ASC_DBG1(2, "HwStartIO: put request to waitq srb 0x%lx\n", srb);
            asc_enqueue(waitq, srb, ASC_BACK);
        }

        return TRUE;

    case SRB_FUNCTION_RESET_DEVICE:
        ASC_DBG1(1, "HwStartIo: Reset device: %u\n", srb->TargetId);
        if (AdvResetDevice(chipConfig, srb->TargetId) == ADV_TRUE) {
            ASC_DBG(2, "Device Reset success.\n");
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        } else {
            ASC_DBG(2, "Device Reset failure.\n");
            srb->SrbStatus = SRB_STATUS_ERROR;
        }

        /*
         * Call AdvISR() to process all requests completed by the
         * microcode and then call AscCompleteRequest() to complete
         * these requests to the OS.
         */
        (void) AdvISR(chipConfig);
        AscCompleteRequest(HwDeviceExtension);

        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    case SRB_FUNCTION_SHUTDOWN:
        /*
         * Shutdown - HwAdapterControl() ScsiStopAdapter performs
         * all needed shutdown of the adapter.
         */
        ASC_DBG(1, "HwStartIo: SRB_FUNCTION_SHUTDOWN\n");
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    default:
        /*
         * Bad Function
         *
         * Set an error, complete the request, and signal ready for
         * next request.
         */
        ASC_DBG1(1, "HwStartIo: Function 0x%x: invalid request\n",
            srb->Function);
        srb->SrbStatus = SRB_STATUS_BAD_FUNCTION;

        ScsiPortLogError(HwDeviceExtension, srb,
            srb->PathId, srb->TargetId, srb->Lun,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_UNSUPP_REQ, srb->Function));

        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return TRUE;

    }
    /* NOTREACHED */
}

/*
 * Routine Description:
 * 
 *     This is the interrupt service routine for the SCSI adapter.
 *     It reads the interrupt register to determine if the adapter is indeed
 *     the source of the interrupt and clears the interrupt at the device.
 * 
 * Arguments:
 * 
 *     HwDeviceExtension - HBA miniport driver's adapter data storage
 * 
 * Return Value:
 *     Indicates where device generated an interrupt. 
 */
BOOLEAN
HwInterrupt(
    IN PVOID HwDeviceExtension
    )
{
    PCHIP_CONFIG        chipConfig;
    int                 retstatus;
    asc_queue_t         *waitq;

    ASC_DBG(3, "HwInterrupt: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    switch (retstatus = AdvISR(chipConfig)) {
    case ADV_TRUE:
       ASC_DBG(4, "HwInterrupt: AdvISR() TRUE\n");
       break;
    case ADV_FALSE:
       ASC_DBG(4, "HwInterrupt: AdvISR() FALSE\n");
        break;
    case ADV_ERROR:
    default:
        ASC_DBG2(1,
            "HwInterrupt: AdvISR() retsatus 0x%lx, err_code 0x%x\n",
            retstatus, chipConfig->err_code);
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_ERR_CODE, chipConfig->err_code));
        break;
    }

    /*
     * Execute any waiting requests.
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        asc_execute_queue(waitq);
    }

    /*
     * Complete all requests on the adapter done list.
     */
    AscCompleteRequest(HwDeviceExtension);

    ASC_DBG1(3, "HwInterrupt: retstatus 0x%x\n", retstatus);
    return (UCHAR)retstatus;
}

SCSI_ADAPTER_CONTROL_STATUS
HwAdapterControl(
    IN PVOID HwDeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
/*++

Routine Description:

    HwAdapterControl() interface added in NT 5.0 for
        Plug and Play/Power Management.

Arguments:

    DeviceExtension
    ControlType
        Parameters

Return Value:

    SCSI_ADAPTER_CONTROL_STATUS.

--*/
{
    PCHIP_CONFIG                chipConfig = &HDE2CONFIG(HwDeviceExtension);
    PHW_DEVICE_EXTENSION        deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST ControlTypeList;
    asc_queue_t                 *waitq;
    REQP                        reqp;
    int                         i;
    USHORT                      initstat;

    switch (ControlType)
    {
    //
    // Query Adapter.
    //
    case ScsiQuerySupportedControlTypes:
        ASC_DBG(2, "HwAdapterControl: ScsiQuerySupportControlTypes\n");

        ControlTypeList =
            (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;
        if (ControlTypeList->MaxControlType < ScsiStopAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 1\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiStopAdapter] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiSetRunningConfig)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 2\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiSetRunningConfig] = TRUE;

        if (ControlTypeList->MaxControlType < ScsiRestartAdapter)
        {
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 3\n");
            return ScsiAdapterControlUnsuccessful;
        }
        ControlTypeList->SupportedTypeList[ScsiRestartAdapter] = TRUE;

        ASC_DBG(1, "HwAdapterControl: ScsiAdapterControlSuccess\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Stop Adapter.
    //
    case ScsiStopAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiStopdapter\n");

        /*
         * Complete any waiting requests.
         */
        if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask)
        {
            for (i = 0; i <= ASC_MAX_TID; i++)
            {
                while ((reqp = asc_dequeue(waitq, i)) != NULL)
                {
                    reqp->SrbStatus = SRB_STATUS_ABORTED;
                    ScsiPortNotification(RequestComplete, HwDeviceExtension,
                        reqp);
                }
            }
        }

        //
        // Disable interrupts and halt the chip.
        //
        AscWriteByteRegister(chipConfig->iop_base, IOPB_INTR_ENABLES, 0);
        AscWriteWordRegister(chipConfig->iop_base, IOPW_RISC_CSR,
            ADV_RISC_CSR_STOP);


        ASC_DBG(2, "HwAdapterControl: ScsiStopAdapter Success\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // ScsiSetRunningConfig.
    //
    // Called before ScsiRestartAdapter. Can use ScsiPort[Get|Set]BusData.
    //
    case ScsiSetRunningConfig:
        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig\n");

        /*
         * Execute Adv Library initialization.
         */
        ASC_DBG(2, "SearchPCI: before AdvInitGetConfig\n");
        if ((initstat = (USHORT)AdvInitGetConfig(chipConfig)) != 0) {
            ASC_DBG1(1, "AdvInitGetConfig: warning code 0x%x\n",
                initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AdvInitGetConfig: err_code 0x%x\n",
                chipConfig->err_code);
            ASC_DBG(1, "HwAdapterControl: Unsuccessful 3\n");
            return ScsiAdapterControlUnsuccessful;
        }

        ASC_DBG(2, "HwAdapterControl: ScsiSetRunningConfig successful\n");
        return ScsiAdapterControlSuccess;
        /* NOTREACHED */

    //
    // Restart Adapter.
    //
    // Cannot use ScsiPort[Get|Set]BusData.
    //
    case ScsiRestartAdapter:
        ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter\n");

        if ((initstat = (USHORT)AdvInitAsc3550Driver(chipConfig)) != 0)
        {
            ASC_DBG1(1,
                "AdvInitAsc3550Driver: warning code %x\n", initstat);
        }

        if (chipConfig->err_code != 0) {
            ASC_DBG1(1, "AdvInitAsc3550Driver: err_code code %x\n",
                chipConfig->err_code);
            return ScsiAdapterControlUnsuccessful;
        } else {
            ASC_DBG(2, "HwAdapterControl: ScsiRestartAdapter success\n");
            return ScsiAdapterControlSuccess;
        }
        /* NOTREACHED */

    //
    // Unsupported Control Operation.
    //
    default:
        return ScsiAdapterControlUnsuccessful;
        /* NOTREACHED */
    }
    /* NOTREACHED */
}

/*
 * Routine Description:
 * 
 *     Reset SCSI bus.
 * 
 * Arguments:
 * 
 *     HwDeviceExtension - HBA miniport driver's adapter data storage
 * 
 * Return Value:
 * 
 *     Nothing.
 * 
 */
BOOLEAN
HwResetBus(
    IN PVOID HwDeviceExtension,
    IN ulong PathId
    )
{
    PCHIP_CONFIG        chipConfig;
    REQP                reqp;
    asc_queue_t         *waitq;
    int                 i;
#ifdef ASC_DEBUG
    int                 j;
#endif /* ASC_DEBUG */
    PSCB                pscb, tpscb;
    PSCSI_REQUEST_BLOCK srb;
    int                 status;
    
    ASC_DBG(1, "HwResetBus: begin\n");

    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    /*
     * Complete all requests that have not been sent to the microcode.
     *
     * Because these requests have not been sent to the microcode, they
     * may be completed prior to the Bus Reset. All of these requests must
     * be removed to clean up the driver queues before returning from
     * HwResetBus().
     */
    if ((waitq = &HDE2WAIT(HwDeviceExtension))->tidmask) {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            while ((reqp = asc_dequeue(waitq, i)) != NULL) {
                ASC_DBG1(1, "HwResetBus: completing waitq reqp 0x%lx\n", reqp);
                reqp->SrbStatus = SRB_STATUS_BUS_RESET;
                ScsiPortNotification(RequestComplete, HwDeviceExtension, reqp);
            }
        }
    }

    /*
     * Perform the bus reset.
     */
    status = AdvResetSB(chipConfig);

    /*
     * Call AdvISR() to process all requests completed by the
     * microcode and then call AscCompleteRequest() to complete
     * these requests to the OS.
     */
    (void) AdvISR(chipConfig);
    AscCompleteRequest(HwDeviceExtension);

    /*
     * Complete all pending requests to the OS.
     *
     * All requests that have been sent to the microcode should have been
     * completed by the call to AdvResetSB(). In case there were requests
     * that were misplaced by the microcode and not completed, use the
     * SRB_STATUS_BUS_RESET function with no TID and LUN to clear all
     * pending requests.
     */
    ScsiPortCompleteRequest(HwDeviceExtension,
            (UCHAR) PathId,
            SP_UNTAGGED,
            SP_UNTAGGED,
            SRB_STATUS_BUS_RESET);

    /*
     * Indicate that the adapter is ready for a new request.
     */
    ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);

    ASC_DBG1(2, "HwResetBus: AdvResetSB() status %ld\n", status);
    return (UCHAR)status;
}


/*
 * --- Driver Support Functions
 */

/*
 * AscExecuteIO()
 *
 * If ADV_BUSY is returned, the request was not executed and it
 * should be enqueued and tried later.
 *
 * For all other return values the request is active or has
 * been completed.
 */
int
AscExecuteIO(IN PSCSI_REQUEST_BLOCK srb)
{
    PVOID            HwDeviceExtension;
    PCHIP_CONFIG     chipConfig;
    PSCB             scb;
    UCHAR            PathId, TargetId, Lun;
    short            status;

    ASC_DBG1(4, "AscExecuteIO: srb 0x%lx\n", srb);
    HwDeviceExtension = SRB2HDE(srb);
    chipConfig = &HDE2CONFIG(HwDeviceExtension);

    /*
     * Build SCB.
     */
    if ((status = (SHORT)BuildScb(HwDeviceExtension, srb)) == ADV_FALSE) {
        ASC_DBG(1, "AscExecuteIO: BuildScb() failure\n");

        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_START_REQ, status));

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, RequestComplete\n", srb);
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);

        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
        return status;
    }
    scb = SRB2PSCB(srb);
    ASC_DBG1(3, "AscExecuteIO: scb 0x%lx\n", scb);

    /*
     * Save information about the request.
     *
     * After a request has been completed it can no longer be accessed.
     */
    PathId = srb->PathId;
    TargetId = srb->TargetId;
    Lun = srb->Lun;

    /*
     * Execute SCSI Command
     */
    status = (SHORT)AdvExeScsiQueue(chipConfig, scb);

    if (status == ADV_NOERROR) {
        /*
         * Request successfully started.
         *
         * If more requests can be sent to the Asc Library then
         * call NextRequest or NextLuRequest.
         *
         * NextRequest indicates that another request may be sent
         * to any non-busy target. Since a request was just issued
         * to the target 'TargetId' that target is now busy and won't
         * be sent another request until a RequestComplete is done.
         *
         * NextLuRequest indicates that another request may be sent
         * to any non-busy target as well as the specified target even
         * if the specified target is busy.
         */
        ASC_DBG1(4, "AdvExeScsiQueue: srb 0x%lx ADV_NOERROR\n", srb);
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextLuRequest\n", srb);
        ScsiPortNotification(NextLuRequest, HwDeviceExtension,
                        PathId, TargetId, Lun);
    } else if (status == ADV_BUSY) {
        ASC_DBG1(1, "AdvExeScsiQueue: srb 0x%lx ADV_BUSY\n", srb);
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    } else {
        /*
         * AdvExeScsiQueue() returned an error...
         */
        ASC_DBG2(1, "AdvExeScsiQueue: srb 0x%lx, error code 0x%x\n",
            srb, status);
        srb->SrbStatus = SRB_STATUS_BAD_FUNCTION;
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, RequestComplete\n", srb);
        ScsiPortNotification(RequestComplete, HwDeviceExtension, srb);
        ASC_DBG1(4, "AscExecuteIO: srb 0x%lx, NextRequest\n", srb);
        ScsiPortNotification(NextRequest, HwDeviceExtension, NULL);
    }

    ASC_DBG1(4, "AscExecuteIO: status %ld\n", status);
    return status;
}


/*
 * BuildScb()
 *
 * Routine Description:
 * 
 *     Build SCB for Library routines.
 * 
 * Arguments:
 * 
 *     DeviceExtension
 *     SRB
 * 
 * Return Value:
 * 
 *     ADV_TRUE - sucesss
 *     ADV_FALSE - faliure
 */
int
BuildScb(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK srb
    )
{
    PSCB            scb;
    PCHIP_CONFIG    chipConfig = &HDE2CONFIG(HwDeviceExtension);
    UCHAR           i;
    ulong           contig_len;
    
    // variables used for hibernation fix //
    ushort tidmask;
    ushort cfg_word;
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    
    /*
     * Initialize Adv Library reqeust and scatter-gather structures.
     * These structures are pre-allocated as a part of the 'srb'.
     */
    INITSRBEXT(srb);
    scb = SRB2PSCB(srb);
    AscZeroMemory((PUCHAR) scb, sizeof(SCB));
    PSCB2SRB(scb) = srb;

    ASC_ASSERT(SCB2HDE(scb) == HwDeviceExtension);

    /*
     * Set request target id and lun.
     */
    scb->target_id = srb->TargetId;
    scb->target_lun = srb->Lun;

    /*
     * If tag queueing is enabled for the request, set the specified
     * tag code. By default the driver will perform tag queuing.
     */
    if (srb->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) {
        scb->tag_code = srb->QueueAction;
    } else {
        scb->tag_code = M2_QTAG_MSG_SIMPLE ;
    }

    ASC_DBG3(4, "BuildSCB: target_id %lu, target_lun %lu, tag_code %lu\n",
          scb->target_id, scb->target_lun, scb->tag_code);

    /*
     * Set CDB length and copy it to the request structure.
     */
    scb->cdb_len = srb->CdbLength;
    for (i = 0; i < srb->CdbLength; i++) {
        scb->cdb[i] = srb->Cdb[i];
    }

    
    ////////////// Apply Hibernation Fix ////////////

    if (srb->CdbLength > 0)
    {
        // Check opcode
        if (srb->Cdb[0] == 0x1B)
        {
            // 0x1B is the SCSI Opcode command for the following
            // Dev_Type
            // 00 Disk drives           Start/Stop
            // 01 Tape drives           Load/Unload
            // 02 Printers              Stop Print
            // 03 Processor devices     n.a.
            // 04 WORM drives           Start/Stop
            // 05 CD-ROM                Start/Stop
            // 06 Scanners              Scan
            // 07 Optical storage       Start/Stop
            // 08 Medium changers       n.a.
            // 09 Communication devices n.a.
            // 1f unknown devices       n.a.
            
            if ( 0x00 == deviceExtension->dev_type[srb->TargetId] )
            {
                /* The assume this is applicable for all LUN for a TargetID.
                 * Q-tag on Start/Stop causes certain Quantum AtlasIII drives to
                 * respond with QueFull when hibernation is initiated under w2k.
                 * This causes the hibernation process to hang.
                 */
                ASC_DBG(1, "BuildScb: setting no tag que for 0x1B command: Start/Stop for disk drives.\n");
                
                tidmask = ADV_TID_TO_TIDMASK(srb->TargetId);
                
                cfg_word = AscReadWordLram( chipConfig->iop_base, ASC_MC_WDTR_DONE );
                cfg_word &= ~tidmask;
                AscWriteWordLram( chipConfig->iop_base, ASC_MC_WDTR_DONE, cfg_word );
            }
        }
    }

    ////////////// END Hibernation Fix ////////////


    /*
     * Set the data count.
     */
    scb->data_cnt = srb->DataTransferLength;
    ASC_DBG1(4, "BuildSCB: data_cnt 0x%lx\n", scb->data_cnt);

    /*
     * If there is a non-zero data transfer to be done, then check
     * if the data buffer is physically contiguous. If it isn't
     * physically contiguous, then a scatter-gather list will be
     * built.
     */
    if (scb->data_cnt > 0) {

        /*
         * Save the buffer virtual address.
         */
        scb->vdata_addr = (ulong) srb->DataBuffer;

        /*
         * Obtain physically contiguous length of 'DataBuffer'.
         */
        scb->data_addr = ScsiPortConvertPhysicalAddressToUlong(
                    ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                    srb->DataBuffer, &contig_len));

        /*
         * If the physically contiguous length of 'DataBuffer' is
         * less than the 'DataTransferLength', then a scatter-gather
         * list must be built.
         */
        if (contig_len < srb->DataTransferLength) {
            /*
             * Initialize scatter-gather list area.
             */
            scb->sg_list_ptr = (ASC_SG_BLOCK *) SRB2PSDL(srb);
            AscZeroMemory((PUCHAR) scb->sg_list_ptr, sizeof(SDL));

            /*
             * AscGetSGList() will build the SG blocks and set the
             * ASC_SCSI_REQ_Q 'sg_real_addr' field. It will reference
             * the 'vdata_addr' field.
             *
             * AdvExeScsiQueue() will call AscGetSGList() if 'sg_real_addr'
             * is non-NULL. Call AscGetSGList() prior to AdvExeScsiQueue()
             * for better error checking.
             */
            if (AscGetSGList(chipConfig, scb) == ADV_ERROR) {
                ASC_DBG(1, "BuildScb: AscGetSGList() failed\n");
                return ADV_FALSE;
            }
        }
    }

    /*
     * Convert sense buffer length and buffer into physical address.
     * The sense buffer length may be changed below by
     * ScsiPortGetPhysicalAddress() to reflect the amount of available
     * physically contiguous memory.
     */
    if ((srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) == 0) {
        ASC_DBG2(4,
            "BuildScb: SenseInfoBuffer 0x%lx, SenseInfoBufferLength 0x%lx\n",
            srb->SenseInfoBuffer, srb->SenseInfoBufferLength);
        scb->sense_len = srb->SenseInfoBufferLength;
        if (scb->sense_len > 0) {
            scb->vsense_addr = (ulong) srb->SenseInfoBuffer;
            scb->sense_addr = (ulong) ScsiPortConvertPhysicalAddressToUlong(
                        ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                            srb->SenseInfoBuffer, &contig_len));
            /*
             * If the contiguous length of the Sense Buffer is less
             * than 'sense_len', then set the Sense Buffer Length
             * to the contiguous length.
             */ 
            if (contig_len < scb->sense_len) {
                ASC_DBG(1, "Asc3550: sense buffer overflow to next page.\n");
                scb->sense_len = (uchar) contig_len;
            }
            ASC_DBG3(4,
              "BuildScb: vsense_addr 0x%lx, sense_addr 0x%lx, sense_len 0x%x\n",
              scb->vsense_addr, scb->sense_addr, scb->sense_len);
        }
    }
    return ADV_TRUE;
}

/*
 * Complete all requests on the adapter done list by
 * DvcISRCallBack().
 */
void
AscCompleteRequest(
    IN PVOID HwDeviceExtension
    )
{
    PSCB                pscb, tpscb;
    PSCSI_REQUEST_BLOCK srb;

    /*
     * Return if the done list is empty.
     */
    if ((pscb = HDE2DONE(HwDeviceExtension)) == NULL) {
        ASC_DBG(4, "AscCompleteRequest: adapter scb_done == NULL\n");
        return;
    }

    HDE2DONE(HwDeviceExtension) = NULL;

    /*
     * Interrupts could now be enabled during the SRB callback
     * without adversely affecting the driver.
     */

    while (pscb) {
        tpscb = SCB2NEXTSCB(pscb);
        SCB2NEXTSCB(pscb) = NULL;
        srb = PSCB2SRB(pscb);
        ASC_DBG2(4,
            "AscCompleteRequest: RequestComplete: srb 0x%lx, scb 0x%lx\n",
            srb, pscb);
        ASC_ASSERT(SRB2HDE(srb) != NULL);
        ScsiPortNotification(RequestComplete, SRB2HDE(srb), srb);
        pscb = tpscb;
    }
}

/*
 * Add a 'REQP' to the end of specified queue. Set 'tidmask'
 * to indicate a command is queued for the device.
 *
 * 'flag' may be either ASC_FRONT or ASC_BACK.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
void
asc_enqueue(asc_queue_t *ascq, REQP reqp, int flag)
{
    REQP    *reqpp;
    int        tid;

    ASC_DBG3(4, "asc_enqueue: ascq 0x%lx, reqp 0x%lx, flag 0x%lx\n",
        ascq, reqp, flag);
    tid = REQPTID(reqp);
    ASC_DASSERT(flag == ASC_FRONT || flag == ASC_BACK);
    if (flag == ASC_FRONT) {
        REQPNEXT(reqp) = ascq->queue[tid];
        ascq->queue[tid] = reqp;
    } else { /* ASC_BACK */
        for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
            ASC_DASSERT(ascq->tidmask & ADV_TID_TO_TIDMASK(tid));
            ;
        }
        *reqpp = reqp;
        REQPNEXT(reqp) = NULL;
    }
    /* The queue has at least one entry, set its bit. */
    ascq->tidmask |= ADV_TID_TO_TIDMASK(tid);
    ASC_DBG1(4, "asc_enqueue: reqp 0x%lx\n", reqp);
    return;
}

/*
 * Return first queued 'REQP' on the specified queue for
 * the specified target device. Clear the 'tidmask' bit for
 * the device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's next pointer.
 */
REQP
asc_dequeue(asc_queue_t *ascq, int tid)
{
    REQP    reqp;

    ASC_DBG2(4, "asc_dequeue: ascq 0x%lx, tid %lu\n", ascq, tid);
    if ((reqp = ascq->queue[tid]) != NULL) {
        ASC_DASSERT(ascq->tidmask & ADV_TID_TO_TIDMASK(tid));
        ascq->queue[tid] = REQPNEXT(reqp);
        /* If the queue is empty, clear its bit. */
        if (ascq->queue[tid] == NULL) {
            ascq->tidmask &= ~ADV_TID_TO_TIDMASK(tid);
        }
    }
    ASC_DBG1(4, "asc_dequeue: reqp 0x%lx\n", reqp);
    return reqp;
}

/*
 * Remove the specified 'REQP' from the specified queue for
 * the specified target device. Clear the 'tidmask' bit for the
 * device if no more commands are left queued for it.
 *
 * 'REQPNEXT(reqp)' returns reqp's the next pointer.
 *
 * Return ADV_TRUE if the command was found and removed,
 * otherwise return ADV_FALSE.
 */
int
asc_rmqueue(asc_queue_t *ascq, REQP reqp)
{
    REQP        *reqpp;
    int            tid;
    int            ret;

    ret = ADV_FALSE;
    tid = REQPTID(reqp);
    for (reqpp = &ascq->queue[tid]; *reqpp; reqpp = &REQPNEXT(*reqpp)) {
        ASC_DASSERT(ascq->tidmask & ADV_TID_TO_TIDMASK(tid));
        if (*reqpp == reqp) {
            ret = ADV_TRUE;
            *reqpp = REQPNEXT(reqp);
            REQPNEXT(reqp) = NULL;
            /* If the queue is now empty, clear its bit. */
            if (ascq->queue[tid] == NULL) {
                ascq->tidmask &= ~ADV_TID_TO_TIDMASK(tid);
            }
            break; /* Note: *reqpp may now be NULL; don't iterate. */
        }
    }
    ASC_DBG2(4, "asc_rmqueue: reqp 0x%lx, ret %ld\n", reqp, ret);
    return ret;
}

/*
 * Execute as many queued requests as possible for the specified queue.
 *
 * Calls AscExecuteIO() to execute a REQP.
 */
void
asc_execute_queue(asc_queue_t *ascq)
{
    ADV_SCSI_BIT_ID_TYPE    scan_tidmask;
    REQP                    reqp;
    int                        i;

    ASC_DBG1(4, "asc_execute_queue: ascq 0x%lx\n", ascq);
    /*
     * Execute queued commands for devices attached to
     * the current board in round-robin fashion.
     */
    scan_tidmask = ascq->tidmask;
    do {
        for (i = 0; i <= ASC_MAX_TID; i++) {
            if (scan_tidmask & ADV_TID_TO_TIDMASK(i)) {
                if ((reqp = asc_dequeue(ascq, i)) == NULL) {
                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
                } else if (AscExecuteIO(reqp) == ADV_BUSY) {
                    scan_tidmask &= ~ADV_TID_TO_TIDMASK(i);
                    /* Put the request back at front of the list. */
                    asc_enqueue(ascq, reqp, ASC_FRONT);
                }
            }
        }
    } while (scan_tidmask);
    return;
}

/*
 * ErrXlate()
 *
 * Routine Description:
 * 
 *   This routine translate Library status into 'SrbStatus' which
 *   is requried by Windows 95/NT.
 * 
 * Arguments:
 * 
 *   host_status - ASC_SCSI_REQ_Q 'host_status'
 * 
 * Return Value:
 * 
 *   Error code defined by Windows 95/NT SCSI port driver.
 *   If no appropriate SrbStatus value is found return 0.
 * 
 */
UCHAR
ErrXlate(UCHAR host_status)
{
    switch (host_status) {
    case QHSTA_M_SEL_TIMEOUT:
        return SRB_STATUS_SELECTION_TIMEOUT;

    case QHSTA_M_DATA_OVER_RUN:
        return SRB_STATUS_DATA_OVERRUN;

    case QHSTA_M_UNEXPECTED_BUS_FREE:
        return SRB_STATUS_UNEXPECTED_BUS_FREE;

    case QHSTA_M_SXFR_WD_TMO:
    case QHSTA_M_WTM_TIMEOUT:
        return SRB_STATUS_COMMAND_TIMEOUT;

    case QHSTA_M_QUEUE_ABORTED:
        return SRB_STATUS_ABORTED;

    case QHSTA_M_SXFR_DESELECTED:
    case QHSTA_M_SXFR_XFR_PH_ERR:
        return SRB_STATUS_PHASE_SEQUENCE_FAILURE;

    case QHSTA_M_SXFR_SXFR_PERR:
        return SRB_STATUS_PARITY_ERROR;

    case QHSTA_M_SXFR_OFF_UFLW:
    case QHSTA_M_SXFR_OFF_OFLW:
    case QHSTA_M_BAD_CMPL_STATUS_IN:
    case QHSTA_M_SXFR_SDMA_ERR:
    case QHSTA_M_SXFR_UNKNOWN_ERROR:
        return SRB_STATUS_ERROR;

    case QHSTA_M_INVALID_DEVICE:
        return SRB_STATUS_NO_DEVICE;

    case QHSTA_M_AUTO_REQ_SENSE_FAIL:
    case QHSTA_M_NO_AUTO_REQ_SENSE:
        ASC_DBG1(2,
            "ErrXlate: Unexpected Auto-Request Sense 'host_status' 0x%x.\n",
            host_status);
        return 0;

    default:
        ASC_DBG1(2, "ErrXlate: Unknown 'host_status' 0x%x\n", host_status);
        return 0;
    }
    /* NOTREACHED */
}

/*
 * Zero memory starting at 'cp' for 'length' bytes.
 */
VOID
AscZeroMemory(UCHAR *cp, ULONG length)
{
    ULONG i;

    for (i = 0; i < length; i++)
    {
        *cp++ = 0;
    }

}


/*
 * --- Adv Library Required Functions
 *
 * The following functions are called by the Adv Library.
 */

/*
 * Routine Description:
 * 
 *     Callback routine for interrupt handler.
 * 
 * Arguments:
 * 
 *     chipConfig - Pointer to chip configuration structure
 *     scb - Pointer to completed ASC_SCSI_REQ_Q
 * 
 * Return Value:
 *     void
 */
VOID
DvcISRCallBack(
    IN PCHIP_CONFIG chipConfig,
    IN ASC_SCSI_REQ_Q *scb
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = CONFIG2HDE(chipConfig);
    PSCSI_REQUEST_BLOCK srb = (PSCSI_REQUEST_BLOCK) scb->srb_ptr;
    PSCB *ppscb;
    uchar underrun = FALSE;

    ASC_DBG1(3, "DvcISRCallBack: scb 0x%lx\n", scb);
    ASC_DBG2(4, "DvcISRCallBack: chipConfig 0x%lx, srb 0x%lx\n",
        chipConfig, srb);

    if (srb == NULL) {
        ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
            SP_INTERNAL_ADAPTER_ERROR,
            ADV_SPL_UNIQUEID(ADV_SPL_PROC_INT, 0));
        ASC_DBG(1, "DvcISRCallBack: srb is NULL\n");
        return;
    }

#ifdef ASC_DEBUG
    if (srb->DataTransferLength > 0) {
        ASC_DBG2(4, "DvcISRCallBack: DataTransferLength %lu, data_cnt %lu\n",
            srb->DataTransferLength, scb->data_cnt);
    }
#endif /* ASC_DEBUG */

    /*
     * Check for a data underrun which is indicated by a non-zero
     * 'data_cnt' value. The microcode sets 'data_cnt' to the transfer
     * residual byte count. In the case of an underrun, the SRB
     * 'DataTransferLength' must indicate the actual number of bytes
     * tranferred.
     *
     * Note: The underrun check and possible adjustment must be made before
     * checking 'done_status', 'host_status', and 'scsi_status'. If the
     * original command returned with a Check Condition, it may have
     * performed a valid partial transfer prior to the Check Condition.
     */
    if (srb->DataTransferLength != 0 && scb->data_cnt != 0) {
        ASC_DBG2(2,
            "DvcISRCallBack: DataTransferLength %lu, data_cnt %lu\n",
            srb->DataTransferLength, scb->data_cnt);
        ASC_DBG1(2,
            "DvcISRCallBack: data underrun of %lu bytes\n",
            scb->data_cnt);

        srb->DataTransferLength -= scb->data_cnt;
        underrun = TRUE;
    }

    if (scb->done_status == QD_NO_ERROR) {
        /*
         * Command sucessfully completed
         */
        if (underrun == TRUE)
        {
            /*
             * If DataTransferlength is returned non-zero and the
             * SRB_STATUS_DATA_OVERRUN flag is set an Underrun condition
             * is indicated. There is no separate SrbStatus flag
             * to indicate an Underrun condition.
             */
            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
        } else
        {
            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
        srb->SrbStatus = SRB_STATUS_SUCCESS;
        srb->ScsiStatus = 0;
        ASC_DBG(4, "DvcISRCallBack: QD_NO_ERROR\n");

        /* Check if this successful command is a SCSI Inquiry.
         * If so, we want to record the dev_type using the
         * inquiry data returned.
         */
        if (srb->Cdb[0] == SCSICMD_Inquiry && srb->Lun == 0)
        {
            HwDeviceExtension->dev_type[srb->TargetId] = 
            *((PCHAR)srb->DataBuffer) & 0x1F ;
            ASC_DBG2(1,
                "DvcISRCallBack: HwDeviceExtension->dev_type[TID=0x%x] set to 0x%x.\n",
                srb->TargetId,
                HwDeviceExtension->dev_type[srb->TargetId]);
        }
    
    } else {

        ASC_DBG3(2,
            "DvcISRCallBack: tid %u, done_status 0x%x, scsi_status 0x%x\n",
            scb->target_id, scb->done_status, scb->scsi_status);
        ASC_DBG1(2,
            "DvcISRCallBack: host_status 0x%x\n",
            scb->host_status);

        if (scb->done_status == QD_ABORTED_BY_HOST) {
            /*
             * Command aborted by host.
             */
            ASC_DBG(2, "DvcISRCallBack: QD_ABORTED_BY_HOST\n");
            srb->SrbStatus = SRB_STATUS_ABORTED;
            srb->ScsiStatus = 0;
        } else if (scb->scsi_status != SS_GOOD) {
            ASC_DBG(1, "DvcISRCallBack: scsi_status != SS_GOOD\n");
            /*
             * Set 'ScsiStatus' for SRB.
             */
            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = scb->scsi_status;

            //
            // Treat a SCSI Status Byte of BUSY status as a special case
            // in setting the 'SrbStatus' field. STI (Still Image Capture)
            // drivers need this 'SrbStatus', because the STI interface does
            // not include the 'ScsiStatus' byte. These drivers must rely
            // on the 'SrbStatus' field to determine when the target device
            // returns BUSY.
            //
            if (scb->scsi_status == SS_TARGET_BUSY)
            {
                srb->SrbStatus = SRB_STATUS_BUSY;
            } else if (scb->scsi_status == SS_CHK_CONDITION)
            {
                if (scb->host_status == QHSTA_M_AUTO_REQ_SENSE_FAIL) {
                    ASC_DBG(2, "DvcISRCallBack: QHST_M_AUTO_REQ_SENSE_FAIL\n");
                } else if (scb->host_status == QHSTA_M_NO_AUTO_REQ_SENSE) {
                    ASC_DBG(2, "DvcISRCallBack: QHSTA_M_NO_AUTO_REQ_SENSE\n");
                } else {
                    srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
#ifdef ASC_DEBUG
                    if (scb->orig_sense_len != scb->sense_len)
                    {
                        ASC_DBG2(2,
                            "DvcISRCallBack: orig_sense_len %u, sense_len %u\n",
                            scb->orig_sense_len, scb->sense_len);
                        ASC_DBG1(2,
                            "DvcISRCallBack: sense underrun of %u bytes\n",
                            scb->orig_sense_len);
                    }
#endif /* ASC_DEBUG */
                }
            }
        } else {
            /*
             * SCSI status byte is OK, but 'host_status' is not.
             */
            if ((srb->SrbStatus = ErrXlate(scb->host_status)) == 0)
            {
                srb->SrbStatus = SRB_STATUS_ERROR;

                /*
                 * Because no appropriate 'SrbStatus' value was returned
                 * by ErrXlate(), log an error that includes the returned
                 * 'done_status' and 'host_status' values.
                 */
                ScsiPortLogError(HwDeviceExtension, NULL, 0, 0, 0,
                    SP_INTERNAL_ADAPTER_ERROR,
                    ADV_SPL_UNIQUEID(ADV_SPL_REQ_STAT,
                      ((scb->done_status << 8) | (scb->host_status & 0xFF))));
            }
        }
    }

#ifdef ASC_DEBUG
    /* Check the integrity of the done list. */
    if (*(ppscb = &HDE2DONE(HwDeviceExtension)) != NULL) {
        if (PSCB2SRB(*ppscb) == NULL) {
            ASC_DBG1(1, "DvcISRCallBack: PSCB2SRB() is NULL 1, *ppscb 0x%lx\n",
                *ppscb);
        }
        for (; *ppscb; ppscb = &SCB2NEXTSCB(*ppscb)) {
            if (PSCB2SRB(*ppscb) == NULL) {
                ASC_DBG1(1,
                    "DvcISRCallBack: PSCB2SRB() is NULL 2, *ppscb 0x%lx\n",
                    *ppscb);
            }
        }
    }
#endif /* ASC_DEBUG */

    /*
     * Add the SCB to end of the completion list. The request will be
     * completed in HwInterrupt().
     */
    for (ppscb = &HDE2DONE(HwDeviceExtension); *ppscb;
         ppscb = &SCB2NEXTSCB(*ppscb)) {
        ;
    }
    *ppscb = SRB2PSCB(srb);
    SRB2NEXTSCB(srb) = NULL;

    return;
}

/*
 * Routine Description:
 * 
 *     Callback routine for hardware detected SCSI Bus Reset.
 * 
 * Arguments:
 * 
 *     chipConfig - Pointer to chip configuration structure
 * 
 * Return Value:
 *     void
 */
VOID
DvcSBResetCallBack(
    IN PCHIP_CONFIG chipConfig
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = CONFIG2HDE(chipConfig);

    ASC_DBG1(2, "DvcSBResetCallBack: chipConfig 0x%lx\n", chipConfig);
    ScsiPortNotification(ResetDetected, HwDeviceExtension);
}

/*
 * This routine delays 'msec' as required by Asc Library.
 */
VOID
DvcSleepMilliSecond(
    ulong msec
    )
{
    ulong i;
    for (i = 0; i < msec; i++) {
        ScsiPortStallExecution(1000L);
    }
}

/*
 * Delay for specificed number of microseconds.
 */
void
DvcDelayMicroSecond(
    ASC_DVC_VAR *asc_dvc,
    ushort micro_sec
          )
{
    ScsiPortStallExecution((long) micro_sec);
}

/*
 * DvcGetPhyAddr()
 *
 * Return the physical address of 'vaddr' and set '*lenp' to the
 * number of physically bytes that follow the physical address.
 *
 * 'flag' indicates whether 'vaddr' points to a ASC_SCSI_REQ_Q
 * structure. It is currently unused.
 */
ulong
DvcGetPhyAddr(PCHIP_CONFIG chipConfig, PSCB scb,
        UCHAR *vaddr, LONG *lenp, int flag)
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = CONFIG2HDE(chipConfig);
    ulong                paddr;
    PSCSI_REQUEST_BLOCK  srb;

    /*
     * 'vaddr' may be 0! There used to be an assert here that 'vaddr' not
     * be NULL. It appears that the 'srb' combined with 'vaddr' produce a
     * valid virtual address space address for a 'vaddr' of 0.
     *
     * ASC_DASSERT(vaddr != NULL);
     */
    ASC_DASSERT(lenp != NULL);

    /*
     * If a non-NULL 'scb' was given as an argument, then it must
     * be converted to an 'srb' and passed to ScsiPortGetPhysicalAddress().
     */
    if (flag & ADV_ASCGETSGLIST_VADDR) {
        srb = PSCB2SRB(scb);
    } else {
        srb = NULL;
    }
    paddr = ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(HwDeviceExtension, srb,
                   (PVOID) vaddr, (ulong *) lenp));

    ASC_DBG4(4,
        "DvcGetPhyAddr: vaddr 0x%lx, lenp 0x%lx *lenp %lu, paddr 0x%lx\n", 
        vaddr, lenp, *((ulong *) lenp), paddr);
    return paddr;
}

/*
 * Input a PCI configuration byte.
 */
UCHAR 
DvcReadPCIConfigByte(
    ASC_DVC_VAR         *asc_dvc, 
    USHORT              offset
   )
{
    PCI_COMMON_CONFIG   pci_config;
    PCI_SLOT_NUMBER     pci_slot;
#ifdef ASC_DEBUG
    ulong               size;
#endif /* ASC_DEBUG */

    pci_slot.u.AsULONG = 0;
    pci_slot.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    pci_slot.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);

#ifdef ASC_DEBUG
    size =
#else /* ASC_DEBUG */
    (VOID)
#endif /* ASC_DEBUG */
    ScsiPortGetBusData(
        (PVOID) asc_dvc,            /* HwDeviceExtension */
        PCIConfiguration,           /* Bus Type */
        (ulong) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), /* Bus Number */
        pci_slot.u.AsULONG,         /* Device and Function Number */
        &pci_config,                /* Buffer */
        sizeof(PCI_COMMON_CONFIG)   /* Length */
        );

#ifdef ASC_DEBUG
        if (size != sizeof(PCI_COMMON_CONFIG)) {
            ASC_DBG1(1, "DvcReadPCIConfigByte: Bad PCI Config size: %lu\n",
                size);
        }
#endif /* ASC_DEBUG */

    return(*((PUCHAR)(&pci_config) + offset));
}

/*
 * Output a PCI configuration byte.
 */
void
DvcWritePCIConfigByte(
   ASC_DVC_VAR          *asc_dvc, 
   USHORT               offset, 
   UCHAR                byte_data
   )
{
    PCI_SLOT_NUMBER     pci_slot;

    pci_slot.u.AsULONG = 0;
    pci_slot.u.bits.DeviceNumber =
        ASC_PCI_ID2DEV(asc_dvc->cfg->pci_slot_info);
    pci_slot.u.bits.FunctionNumber =
        ASC_PCI_ID2FUNC(asc_dvc->cfg->pci_slot_info);

    /*
     * Write it out
     */
    (void) ScsiPortSetBusDataByOffset(
        (PVOID)asc_dvc,                      /* HwDeviceExtension */
        PCIConfiguration,                    /* Bus type */
        (ulong) ASC_PCI_ID2BUS(asc_dvc->cfg->pci_slot_info), /* Bus Number */
        pci_slot.u.AsULONG,                  /* Device and Function Number */
        &byte_data,                          /* Buffer */
        offset,                              /* Offset */
        1                                    /* Length */
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_condor.h ===
/*
 * a_condor.h - Main Hardware Include File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef __A_CONDOR_H_
#define __A_CONDOR_H_

#define ADV_PCI_VENDOR_ID               0x10CD
#define ADV_PCI_DEVICE_ID_REV_A         0x2300

#define ASC_EEP_DVC_CFG_BEGIN           (0x00)
#define ASC_EEP_DVC_CFG_END             (0x15)
#define ASC_EEP_DVC_CTL_BEGIN           (0x16)  /* location of OEM name */
#define ASC_EEP_MAX_WORD_ADDR           (0x1E)

#define ASC_EEP_DELAY_MS                100

/*
 * EEPROM bits reference by the RISC after initialization.
 */
#define ADV_EEPROM_BIG_ENDIAN          0x8000   /* EEPROM Bit 15 */
#define ADV_EEPROM_BIOS_ENABLE         0x4000   /* EEPROM Bit 14 */
#define ADV_EEPROM_TERM_POL            0x2000   /* EEPROM Bit 13 */

/*
 * EEPROM configuration format
 *
 * Field naming convention: 
 *
 *  *_enable indicates the field enables or disables the feature. The
 *  value is never reset.
 *
 *  *_able indicates both whether a feature should be enabled or disabled
 *  and whether a device isi capable of the feature. At initialization
 *  this field may be set, but later if a device is found to be incapable
 *  of the feature, the field is cleared.
 *
 * Default values are maintained in a_init.c in the structure
 * Default_EEPROM_Config.
 */
typedef struct asceep_config
{                              
                                /* Word Offset, Description */

  ushort cfg_lsw;               /* 00 power up initialization */
                                /*  bit 13 set - Term Polarity Control */
                                /*  bit 14 set - BIOS Enable */
                                /*  bit 15 set - Big Endian Mode */
  ushort cfg_msw;               /* 01 unused      */
  ushort disc_enable;           /* 02 disconect enable */         
  ushort wdtr_able;             /* 03 Wide DTR able */
  ushort sdtr_able;             /* 04 Synchronous DTR able */
  ushort start_motor;           /* 05 send start up motor */      
  ushort tagqng_able;           /* 06 tag queuing able */
  ushort bios_scan;             /* 07 BIOS device control */   
  ushort scam_tolerant;         /* 08 no scam */  
 
  uchar  adapter_scsi_id;       /* 09 Host Adapter ID */
  uchar  bios_boot_delay;       /*    power up wait */
 
  uchar  scsi_reset_delay;      /* 10 reset delay */
  uchar  bios_id_lun;           /*    first boot device scsi id & lun */
                                /*    high nibble is lun */  
                                /*    low nibble is scsi id */

  uchar  termination;           /* 11 0 - automatic */
                                /*    1 - low off / high off */
                                /*    2 - low off / high on */
                                /*    3 - low on  / high on */
                                /*    There is no low on  / high off */

  uchar  reserved1;             /*    resevered byte (not used) */                                  

  ushort bios_ctrl;             /* 12 BIOS control bits */
                                /*  bit 0  set: BIOS don't act as initiator. */
                                /*  bit 1  set: BIOS > 1 GB support */
                                /*  bit 2  set: BIOS > 2 Disk Support */
                                /*  bit 3  set: BIOS don't support removables */
                                /*  bit 4  set: BIOS support bootable CD */
                                /*  bit 5  set: BIOS scan enabled */
                                /*  bit 6  set: BIOS support multiple LUNs */
                                /*  bit 7  set: BIOS display of message */
                                /*  bit 8  set: */
                                /*  bit 9  set: Reset SCSI bus during init. */
                                /*  bit 10 set: */
                                /*  bit 11 set: No verbose initialization. */
                                /*  bit 12 set: SCSI parity enabled */
                                /*  bit 13 set: */
                                /*  bit 14 set: */
                                /*  bit 15 set: */
  ushort  ultra_able;           /* 13 ULTRA speed able */ 
  ushort  reserved2;            /* 14 reserved */
  uchar   max_host_qng;         /* 15 maximum host queueing */
  uchar   max_dvc_qng;          /*    maximum per device queuing */
  ushort  dvc_cntl;             /* 16 control bit for driver */
  ushort  bug_fix;              /* 17 control bit for bug fix */
  ushort  serial_number_word1;  /* 18 Board serial number word 1 */  
  ushort  serial_number_word2;  /* 19 Board serial number word 2 */  
  ushort  serial_number_word3;  /* 20 Board serial number word 3 */
  ushort  check_sum;            /* 21 EEP check sum */
  uchar   oem_name[16];         /* 22 OEM name */
  ushort  dvc_err_code;         /* 30 last device driver error code */
  ushort  adv_err_code;         /* 31 last uc and Adv Lib error code */
  ushort  adv_err_addr;         /* 32 last uc error address */
  ushort  saved_dvc_err_code;   /* 33 saved last dev. driver error code   */
  ushort  saved_adv_err_code;   /* 34 saved last uc and Adv Lib error code */
  ushort  saved_adv_err_addr;   /* 35 saved last uc error address         */  
  ushort  num_of_err;           /* 36 number of error */
} ASCEEP_CONFIG; 

/*
 * EEPROM Commands
 */
#define ASC_EEP_CMD_READ             0x0080
#define ASC_EEP_CMD_WRITE            0x0040
#define ASC_EEP_CMD_WRITE_ABLE       0x0030
#define ASC_EEP_CMD_WRITE_DISABLE    0x0000
#define ASC_EEP_CMD_DONE             0x0200
#define ASC_EEP_CMD_DONE_ERR         0x0001

/* cfg_word */
#define EEP_CFG_WORD_BIG_ENDIAN      0x8000

/* bios_ctrl */
#define BIOS_CTRL_BIOS               0x0001
#define BIOS_CTRL_EXTENDED_XLAT      0x0002
#define BIOS_CTRL_GT_2_DISK          0x0004
#define BIOS_CTRL_BIOS_REMOVABLE     0x0008
#define BIOS_CTRL_BOOTABLE_CD        0x0010
#define BIOS_CTRL_SCAN               0x0020
#define BIOS_CTRL_MULTIPLE_LUN       0x0040
#define BIOS_CTRL_DISPLAY_MSG        0x0080
#define BIOS_CTRL_NO_SCAM            0x0100
#define BIOS_CTRL_RESET_SCSI_BUS     0x0200
#define BIOS_CTRL_INIT_VERBOSE       0x0800
#define BIOS_CTRL_SCSI_PARITY        0x1000

/*
 * ASC 3550 Internal Memory Size - 8KB
 */
#define ADV_CONDOR_MEMSIZE   0x2000     /* 8 KB Internal Memory */

/*
 * ASC 3550 I/O Length - 64 bytes
 */
#define ADV_CONDOR_IOLEN     0x40       /* I/O Port Range in bytes */

/*
 * Byte I/O register address from base of 'iop_base'.
 */
#define IOPB_INTR_STATUS_REG    0x00
#define IOPB_CHIP_ID_1          0x01
#define IOPB_INTR_ENABLES       0x02
#define IOPB_CHIP_TYPE_REV      0x03
#define IOPB_RES_ADDR_4         0x04
#define IOPB_RES_ADDR_5         0x05
#define IOPB_RAM_DATA           0x06
#define IOPB_RES_ADDR_7         0x07
#define IOPB_FLAG_REG           0x08
#define IOPB_RES_ADDR_9         0x09
#define IOPB_RISC_CSR           0x0A
#define IOPB_RES_ADDR_B         0x0B
#define IOPB_RES_ADDR_C         0x0C
#define IOPB_RES_ADDR_D         0x0D
#define IOPB_RES_ADDR_E         0x0E
#define IOPB_RES_ADDR_F         0x0F
#define IOPB_MEM_CFG            0x10
#define IOPB_RES_ADDR_11        0x11
#define IOPB_RES_ADDR_12        0x12
#define IOPB_RES_ADDR_13        0x13
#define IOPB_FLASH_PAGE         0x14
#define IOPB_RES_ADDR_15        0x15
#define IOPB_RES_ADDR_16        0x16
#define IOPB_RES_ADDR_17        0x17
#define IOPB_FLASH_DATA         0x18
#define IOPB_RES_ADDR_19        0x19
#define IOPB_RES_ADDR_1A        0x1A
#define IOPB_RES_ADDR_1B        0x1B
#define IOPB_RES_ADDR_1C        0x1C
#define IOPB_RES_ADDR_1D        0x1D
#define IOPB_RES_ADDR_1E        0x1E
#define IOPB_RES_ADDR_1F        0x1F
#define IOPB_DMA_CFG0           0x20
#define IOPB_DMA_CFG1           0x21
#define IOPB_TICKLE             0x22
#define IOPB_DMA_REG_WR         0x23
#define IOPB_SDMA_STATUS        0x24
#define IOPB_SCSI_BYTE_CNT      0x25
#define IOPB_HOST_BYTE_CNT      0x26
#define IOPB_BYTE_LEFT_TO_XFER  0x27
#define IOPB_BYTE_TO_XFER_0     0x28
#define IOPB_BYTE_TO_XFER_1     0x29
#define IOPB_BYTE_TO_XFER_2     0x2A
#define IOPB_BYTE_TO_XFER_3     0x2B
#define IOPB_ACC_GRP            0x2C
#define IOPB_RES_ADDR_2D        0x2D
#define IOPB_DEV_ID             0x2E
#define IOPB_RES_ADDR_2F        0x2F
#define IOPB_SCSI_DATA          0x30
#define IOPB_RES_ADDR_31        0x31
#define IOPB_RES_ADDR_32        0x32
#define IOPB_SCSI_DATA_HSHK     0x33
#define IOPB_SCSI_CTRL          0x34
#define IOPB_RES_ADDR_35        0x35
#define IOPB_RES_ADDR_36        0x36
#define IOPB_RES_ADDR_37        0x37
#define IOPB_RES_ADDR_38        0x38
#define IOPB_RES_ADDR_39        0x39
#define IOPB_RES_ADDR_3A        0x3A
#define IOPB_RES_ADDR_3B        0x3B
#define IOPB_RFIFO_CNT          0x3C
#define IOPB_RES_ADDR_3D        0x3D
#define IOPB_RES_ADDR_3E        0x3E
#define IOPB_RES_ADDR_3F        0x3F

/*
 * Word I/O register address from base of 'iop_base'.
 */
#define IOPW_CHIP_ID_0          0x00  /* CID0  */
#define IOPW_CTRL_REG           0x02  /* CC    */
#define IOPW_RAM_ADDR           0x04  /* LA    */
#define IOPW_RAM_DATA           0x06  /* LD    */
#define IOPW_RES_ADDR_08        0x08
#define IOPW_RISC_CSR           0x0A  /* CSR   */
#define IOPW_SCSI_CFG0          0x0C  /* CFG0  */
#define IOPW_SCSI_CFG1          0x0E  /* CFG1  */
#define IOPW_RES_ADDR_10        0x10
#define IOPW_SEL_MASK           0x12  /* SM    */
#define IOPW_RES_ADDR_14        0x14
#define IOPW_FLASH_ADDR         0x16  /* FA    */
#define IOPW_RES_ADDR_18        0x18
#define IOPW_EE_CMD             0x1A  /* EC    */
#define IOPW_EE_DATA            0x1C  /* ED    */
#define IOPW_SFIFO_CNT          0x1E  /* SFC   */
#define IOPW_RES_ADDR_20        0x20
#define IOPW_Q_BASE             0x22  /* QB    */
#define IOPW_QP                 0x24  /* QP    */
#define IOPW_IX                 0x26  /* IX    */
#define IOPW_SP                 0x28  /* SP    */
#define IOPW_PC                 0x2A  /* PC    */
#define IOPW_RES_ADDR_2C        0x2C
#define IOPW_RES_ADDR_2E        0x2E
#define IOPW_SCSI_DATA          0x30  /* SD    */
#define IOPW_SCSI_DATA_HSHK     0x32  /* SDH   */
#define IOPW_SCSI_CTRL          0x34  /* SC    */
#define IOPW_HSHK_CFG           0x36  /* HCFG  */
#define IOPW_SXFR_STATUS        0x36  /* SXS   */
#define IOPW_SXFR_CNTL          0x38  /* SXL   */
#define IOPW_SXFR_CNTH          0x3A  /* SXH   */
#define IOPW_RES_ADDR_3C        0x3C
#define IOPW_RFIFO_DATA         0x3E  /* RFD   */

/*
 * Doubleword I/O register address from base of 'iop_base'.
 */
#define IOPDW_RES_ADDR_0         0x00
#define IOPDW_RAM_DATA           0x04
#define IOPDW_RES_ADDR_8         0x08
#define IOPDW_RES_ADDR_C         0x0C
#define IOPDW_RES_ADDR_10        0x10
#define IOPDW_RES_ADDR_14        0x14
#define IOPDW_RES_ADDR_18        0x18
#define IOPDW_RES_ADDR_1C        0x1C
#define IOPDW_SDMA_ADDR0         0x20
#define IOPDW_SDMA_ADDR1         0x24
#define IOPDW_SDMA_COUNT         0x28
#define IOPDW_SDMA_ERROR         0x2C
#define IOPDW_RDMA_ADDR0         0x30
#define IOPDW_RDMA_ADDR1         0x34
#define IOPDW_RDMA_COUNT         0x38
#define IOPDW_RDMA_ERROR         0x3C

#define ADV_CHIP_ID_BYTE         0x25
#define ADV_CHIP_ID_WORD         0x04C1

#define ADV_SC_SCSI_BUS_RESET    0x2000

#define ADV_INTR_ENABLE_HOST_INTR                   0x01
#define ADV_INTR_ENABLE_SEL_INTR                    0x02
#define ADV_INTR_ENABLE_DPR_INTR                    0x04
#define ADV_INTR_ENABLE_RTA_INTR                    0x08
#define ADV_INTR_ENABLE_RMA_INTR                    0x10
#define ADV_INTR_ENABLE_RST_INTR                    0x20
#define ADV_INTR_ENABLE_DPE_INTR                    0x40
#define ADV_INTR_ENABLE_GLOBAL_INTR                 0x80

#define ADV_INTR_STATUS_INTRA            0x01
#define ADV_INTR_STATUS_INTRB            0x02
#define ADV_INTR_STATUS_INTRC            0x04

#define ADV_RISC_CSR_STOP           (0x0000)
#define ADV_RISC_TEST_COND          (0x2000)
#define ADV_RISC_CSR_RUN            (0x4000)
#define ADV_RISC_CSR_SINGLE_STEP    (0x8000)

#define ADV_CTRL_REG_HOST_INTR      0x0100
#define ADV_CTRL_REG_SEL_INTR       0x0200
#define ADV_CTRL_REG_DPR_INTR       0x0400
#define ADV_CTRL_REG_RTA_INTR       0x0800
#define ADV_CTRL_REG_RMA_INTR       0x1000
#define ADV_CTRL_REG_RES_BIT14      0x2000
#define ADV_CTRL_REG_DPE_INTR       0x4000
#define ADV_CTRL_REG_POWER_DONE     0x8000
#define ADV_CTRL_REG_ANY_INTR       0xFF00

#define ADV_CTRL_REG_CMD_RESET             0x00C6
#define ADV_CTRL_REG_CMD_WR_IO_REG         0x00C5
#define ADV_CTRL_REG_CMD_RD_IO_REG         0x00C4
#define ADV_CTRL_REG_CMD_WR_PCI_CFG_SPACE  0x00C3
#define ADV_CTRL_REG_CMD_RD_PCI_CFG_SPACE  0x00C2

#define ADV_SCSI_CTRL_RSTOUT        0x2000

#define AdvIsIntPending(port)  \
    (AscReadWordRegister(port, IOPW_CTRL_REG) & ADV_CTRL_REG_HOST_INTR)

/*
 * SCSI_CFG0 Register bit definitions
 */
#define TIMER_MODEAB    0xC000  /* Watchdog, Second, and Select. Timer Ctrl. */
#define PARITY_EN       0x2000  /* Enable SCSI Parity Error detection */
#define EVEN_PARITY     0x1000  /* Select Even Parity */
#define WD_LONG         0x0800  /* Watchdog Interval, 1: 57 min, 0: 13 sec */
#define QUEUE_128       0x0400  /* Queue Size, 1: 128 byte, 0: 64 byte */
#define PRIM_MODE       0x0100  /* Primitive SCSI mode */
#define SCAM_EN         0x0080  /* Enable SCAM selection */
#define SEL_TMO_LONG    0x0040  /* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */
#define CFRM_ID         0x0020  /* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */
#define OUR_ID_EN       0x0010  /* Enable OUR_ID bits */
#define OUR_ID          0x000F  /* SCSI ID */

/*
 * SCSI_CFG1 Register bit definitions
 */
#define BIG_ENDIAN      0x8000  /* Enable Big Endian Mode MIO:15, EEP:15 */
#define TERM_POL        0x2000  /* Terminator Polarity Ctrl. MIO:13, EEP:13 */
#define SLEW_RATE       0x1000  /* SCSI output buffer slew rate */
#define FILTER_SEL      0x0C00  /* Filter Period Selection */
#define  FLTR_DISABLE    0x0000  /* Input Filtering Disabled */
#define  FLTR_11_TO_20NS 0x0800  /* Input Filtering 11ns to 20ns */          
#define  FLTR_21_TO_39NS 0x0C00  /* Input Filtering 21ns to 39ns */          
#define ACTIVE_DBL      0x0200  /* Disable Active Negation */
#define DIFF_MODE       0x0100  /* SCSI differential Mode (Read-Only) */
#define DIFF_SENSE      0x0080  /* 1: No SE cables, 0: SE cable (Read-Only) */
#define TERM_CTL_SEL    0x0040  /* Enable TERM_CTL_H and TERM_CTL_L */
#define TERM_CTL        0x0030  /* External SCSI Termination Bits */
#define  TERM_CTL_H      0x0020  /* Enable External SCSI Upper Termination */
#define  TERM_CTL_L      0x0010  /* Enable External SCSI Lower Termination */
#define CABLE_DETECT    0x000F  /* External SCSI Cable Connection Status */

#define CABLE_ILLEGAL_A 0x7
    /* x 0 0 0  | on  on | Illegal (all 3 connectors are used) */

#define CABLE_ILLEGAL_B 0xB
    /* 0 x 0 0  | on  on | Illegal (all 3 connectors are used) */

/*
   The following table details the SCSI_CFG1 Termination Polarity,
   Termination Control and Cable Detect bits.

   Cable Detect | Termination
   Bit 3 2 1 0  | 5   4  | Notes
   -------------|--------|--------------------
       1 1 1 0  | on  on | Internal wide only
       1 1 0 1  | on  on | Internal narrow only
       1 0 1 1  | on  on | External narrow only
       0 x 1 1  | on  on | External wide only
       1 1 0 0  | on  off| Internal wide and internal narrow
       1 0 1 0  | on  off| Internal wide and external narrow
       0 x 1 0  | off off| Internal wide and external wide
       1 0 0 1  | on  off| Internal narrow and external narrow
       0 x 0 1  | on  off| Internal narrow and external wide
       1 1 1 1  | on  on | No devices are attached
       x 0 0 0  | on  on | Illegal (all 3 connectors are used)
       0 x 0 0  | on  on | Illegal (all 3 connectors are used)
  
       x means don't-care (either '0' or '1')
  
       If term_pol (bit 13) is '0' (active-low terminator enable), then:
           'on' is '0' and 'off' is '1'.
  
       If term_pol bit is '1' (meaning active-hi terminator enable), then:
           'on' is '1' and 'off' is '0'.
 */

/*
 * MEM_CFG Register bit definitions
 */
#define BIOS_EN         0x40    /* BIOS Enable MIO:14,EEP:14 */
#define FAST_EE_CLK     0x20    /* Diagnostic Bit */
#define RAM_SZ          0x1C    /* Specify size of RAM to RISC */
#define  RAM_SZ_2KB      0x00    /* 2 KB */
#define  RAM_SZ_4KB      0x04    /* 4 KB */
#define  RAM_SZ_8KB      0x08    /* 8 KB */
#define  RAM_SZ_16KB     0x0C    /* 16 KB */
#define  RAM_SZ_32KB     0x10    /* 32 KB */
#define  RAM_SZ_64KB     0x14    /* 64 KB */

/*
 * DMA_CFG0 Register bit defintions
 *
 * This register is only accessible to the host.
 */
#define BC_THRESH_ENB   0x80    /* PCI DMA Start Conditions */
#define FIFO_THRESH     0x70    /* PCI DMA FIFO Threshold */
#define  FIFO_THRESH_16B  0x00   /* 16 bytes */
#define  FIFO_THRESH_32B  0x20   /* 32 bytes */
#define  FIFO_THRESH_48B  0x30   /* 48 bytes */
#define  FIFO_THRESH_64B  0x40   /* 64 bytes */
#define  FIFO_THRESH_80B  0x50   /* 80 bytes (default) */
#define  FIFO_THRESH_96B  0x60   /* 96 bytes */
#define  FIFO_THRESH_112B 0x70   /* 112 bytes */
#define START_CTL       0x0C    /* DMA start conditions */
#define  START_CTL_TH    0x00    /* Wait threshold level (default) */
#define  START_CTL_ID    0x04    /* Wait SDMA/SBUS idle */
#define  START_CTL_THID  0x08    /* Wait threshold and SDMA/SBUS idle */
#define  START_CTL_EMFU  0x0C    /* Wait SDMA FIFO empty/full */
#define READ_CMD        0x03    /* Memory Read Method */
#define  READ_CMD_MR     0x00    /* Memory Read */
#define  READ_CMD_MRL    0x02    /* Memory Read Long */
#define  READ_CMD_MRM    0x03    /* Memory Read Multiple (default) */

#endif /* __A_CONDOR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\asc3550.h ===
/*
 * AdvanSys 3550 Windows NT SCSI Miniport Driver - asc3550.h
 *
 * Copyright (c) 1994-1998  Advanced System Products, Inc.
 * All Rights Reserved.
 */

/*
 * Generalized request queuing defintions.
 */

/*
 * REQ and REQP are the generic name for a SCSI request block and pointer.
 * REQPNEXT(reqp) returns reqp's next pointer.
 * REQPTID(reqp) returns reqp's target id.
 */
typedef SCSI_REQUEST_BLOCK  REQ, *REQP;
#define REQPNEXT(reqp)      ((REQP) SRB2NEXTSCB((SCSI_REQUEST_BLOCK *) (reqp)))
#define REQPTID(reqp)       ((reqp)->TargetId)

/* asc_enqueue() flags */
#define ASC_FRONT        1
#define ASC_BACK         2

typedef struct asc_queue {
    ADV_SCSI_BIT_ID_TYPE    tidmask;              /* queue mask */
    REQP                    queue[ASC_MAX_TID+1]; /* queue linked list */
} asc_queue_t;

void                asc_enqueue(asc_queue_t *, REQP, int);
REQP                asc_dequeue(asc_queue_t *, int);
int                 asc_rmqueue(asc_queue_t *, REQP);
void                asc_execute_queue(asc_queue_t *);


/*
 * Hardware Device Extenstion Definition
 *
 * One structure is allocated for each adapter.
 */

typedef ASC_DVC_VAR     CHIP_CONFIG, *PCHIP_CONFIG;
typedef ASC_DVC_CFG     CHIP_INFO, *PCHIP_INFO;

/* Forward declarations */
typedef ASC_SCSI_REQ_Q SCB, *PSCB; /* Driver Structure needed per request. */
typedef struct _HW_DEVICE_EXTENSION *PHW_DEVICE_EXTENSION;

typedef struct _HW_DEVICE_EXTENSION {
    CHIP_CONFIG   chipConfig;  /* Aliased ASC_DVC_VAR */
    CHIP_INFO     chipInfo;    /* Aliased ASC_DVC_CFG */
    asc_queue_t   waiting;     /* Waiting command queue */
    PSCB          done;        /* Adapter done list pointer */

    uchar dev_type[ASC_MAX_TID + 1];  /* Hibernation fix (from ver. 3.3E) */

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


/* Macros for accessing HW Device Extension structure fields. */
#define HDE2CONFIG(hde)      (((PHW_DEVICE_EXTENSION) (hde))->chipConfig)
#define HDE2INFO(hde)        (((PHW_DEVICE_EXTENSION) (hde))->chipInfo)
#define HDE2WAIT(hde)        (((PHW_DEVICE_EXTENSION) (hde))->waiting)
#define HDE2DONE(hde)        (((PHW_DEVICE_EXTENSION) (hde))->done)
#ifdef ASC_DEBUG
#define HDE2DONECNT(hde)     (((PHW_DEVICE_EXTENSION) (hde))->done_cnt)
#endif /* ASC_DEBUG */

/* 'drv_ptr' is used to point to the adapter's hardware device extension. */
#define CONFIG2HDE(chipConfig)  ((PHW_DEVICE_EXTENSION) ((chipConfig)->drv_ptr))


/*
 * SRB Extension Definition
 *
 * One structure is allocated per request.
 */


/*
 * Scatter-Gather Limit Definitions
 */
#define ASC_PAGE_SIZE           4096 /* XXX - 95/NT definition for this? */
#define MAX_TRANSFER_SIZE       ((ADV_MAX_SG_LIST - NT_FUDGE) * ASC_PAGE_SIZE)

/*
 * Scatter-Gather Definitions per request.
 *
 * Because SG block memory is allocated in virtual memory but is
 * referenced by the microcode as phyical memory, we need to do
 * calculations to insure there will be enough physically contiguous
 * memory to support ADV_MAX_SG_LIST SG entries.
 */

/* Number of SG blocks needed. */
#define ASC_NUM_SG_BLOCK \
     ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK)

/* Total contiguous memory needed for SG blocks. */
#define ASC_SG_TOTAL_MEM_SIZE \
    (sizeof(ASC_SG_BLOCK) *  ASC_NUM_SG_BLOCK)

/*
 * Number of page crossings possible for the total contiguous virtual memory
 * needed for SG blocks.
 *
 * We need to allocate this many additional SG blocks in virtual memory to
 * insure there will be space for ASC_NUM_SG_BLOCK physically contiguous
 * SG blocks.
 */
#define ASC_NUM_PAGE_CROSSING \
    ((ASC_SG_TOTAL_MEM_SIZE + (ASC_PAGE_SIZE - 1))/ASC_PAGE_SIZE)

/* Scatter-gather Descriptor List */
typedef struct _SDL {
    ASC_SG_BLOCK          sg_block[ASC_NUM_SG_BLOCK + ASC_NUM_PAGE_CROSSING];
} SDL, *PSDL;

typedef struct _SRB_EXTENSION {
   PSCB                   scbptr;       /* Pointer to 4-byte aligned scb */
   PSDL                   sdlptr;       /* Pointer to 4-byte aligned sdl */
   SCB                    scb;          /* SCSI command block */
   uchar                  align1[4];    /* scb alignment padding */
   SDL                    sdl;          /* scatter gather descriptor list */
   uchar                  align2[4];    /* sdl alignment padding */
   PSCB                   nextscb;      /* next pointer for scb linked list */
   PHW_DEVICE_EXTENSION   hdep;         /* hardware device extension pointer */
} SRB_EXTENSION, *PSRB_EXTENSION;

/*
 * This macro must be called before using SRB2PSCB() and SRB2PSDL().
 * Both the SCB and SDL structures must be 4 byte aligned for the
 * asc3550 RISC DMA hardware.
 *
 * Under Windows 95 occasionally the SRB and therefore SRB Extension in
 * the SRB are not 4 byte aligned.
 */
#define INITSRBEXT(srb) \
    { \
        ((PSRB_EXTENSION) ((srb)->SrbExtension))->scbptr = \
           (PSCB) ADV_DWALIGN(&((PSRB_EXTENSION) ((srb)->SrbExtension))->scb); \
        ((PSRB_EXTENSION) ((srb)->SrbExtension))->sdlptr = \
           (PSDL) ADV_DWALIGN(&((PSRB_EXTENSION) ((srb)->SrbExtension))->sdl); \
    }

/* Macros for accessing SRB Extension structure fields. */
#define SRB2PSCB(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->scbptr)
#define SRB2PSDL(srb)    (((PSRB_EXTENSION) ((srb)->SrbExtension))->sdlptr)
#define SRB2NEXTSCB(srb) (((PSRB_EXTENSION) ((srb)->SrbExtension))->nextscb)
#define SRB2HDE(srb)     (((PSRB_EXTENSION) ((srb)->SrbExtension))->hdep)
#define PSCB2SRB(scb)    ((PSCSI_REQUEST_BLOCK) ((scb)->srb_ptr))
/* srb_ptr must be valid to use the following macros */
#define SCB2NEXTSCB(scb) (SRB2NEXTSCB(PSCB2SRB(scb)))
#define SCB2HDE(scb)     (SRB2HDE(PSCB2SRB(scb)))

/*
 * Maximum PCI bus number
 */
#define PCI_MAX_BUS                16

/*
 * Port Search structure:
 */
typedef struct _SRCH_CONTEXT              /* Port search context */
{
    PortAddr             lastPort;        /* Last port searched */
    ulong                PCIBusNo;        /* Last PCI Bus searched */
    ulong                PCIDevNo;        /* Last PCI Device searched */
} SRCH_CONTEXT, *PSRCH_CONTEXT;


/*
 * ScsiPortLogError() 'UniqueId' Argument Definitions
 *
 * The 'UniqueID' argument is separated into different parts to
 * report as much information as possible. It is assumed the driver
 * file will never grow beyond 4095 lines. Note: The ADV_ASSERT()
 * format for Bits 27-0 defined in d_os_dep.h differs from the format 
 * defined for all the other Error Types.
 *
 * Bit 31-28: Error Type                (4 bits)
 * Bit 27-16: Line Number               (12 bits)
 * Bit 15-0: Error Type Specific        (16 bits)
 */

/* Error Types - 16 (0x0-0xF) can be defined. */
#define ADV_SPL_BAD_TYPE    0x0  /* Error Type Unused */
#define ADV_SPL_IERR_CODE   0x1  /* Adv Library Init ASC_DVC_VAR 'err_code' */
#define ADV_SPL_IWARN_CODE  0x2  /* Adv Library Init function warning code */
#define ADV_SPL_PCI_CONF    0x3  /* Bad PCI Configuration Information */
#define ADV_SPL_BAD_IRQ     0x4  /* Bad PCI Configuration IRQ */
#define ADV_SPL_ERR_CODE    0x5  /* Adv Library ASC_DVC_VAR 'err_code' */
#define ADV_SPL_UNSUPP_REQ  0x6  /* Unsupported request */
#define ADV_SPL_START_REQ   0x7  /* Error starting a request */
#define ADV_SPL_PROC_INT    0x8  /* Error processing an interrupt */
#define ADV_SPL_REQ_STAT    0x9  /* Request done_status, host_status error */

#define ADV_SPL_ADV_ASSERT  0xF  /* ADV_ASSERT() failure, cf. d_os_dep.h */

/* Macro used to specify the 'UniqueId' argument. */
#define ADV_SPL_UNIQUEID(error_type, error_value) \
    (((ulong) (error_type) << 28) | \
     ((ulong) ((__LINE__) & 0xFFF) << 16) | \
     ((error_value) & 0xFFFF))
    

/*
 * Assertion Macro Definition
 *
 * ADV_ASSERT() is defined in d_os_dep.h, because it is used by both the
 * Windows 95/NT driver and the Adv Library.
 */

/*
 * Debug Macros
 */

#ifndef ASC_DEBUG

#define ASC_DBG(lvl, s)
#define ASC_DBG1(lvl, s, a1)
#define ASC_DBG2(lvl, s, a1, a2)
#define ASC_DBG3(lvl, s, a1, a2, a3)
#define ASC_DBG4(lvl, s, a1, a2, a3, a4)
#define ASC_DASSERT(a)
#define ASC_ASSERT(a)

#else /* ASC_DEBUG */

/*
 * Windows NT Debugging
 *
 * NT Debug Message Levels:
 *  1: Errors Only
 *  2: Information
 *  3: Function Tracing
 *  4: Arcane Information
 */

#define ASC_DBG(lvl, s) \
                    DebugPrint(((lvl), (s)))

#define ASC_DBG1(lvl, s, a1) \
                    DebugPrint(((lvl), (s), (a1)))

#define ASC_DBG2(lvl, s, a1, a2) \
                    DebugPrint(((lvl), (s), (a1), (a2)))

#define ASC_DBG3(lvl, s, a1, a2, a3) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3)))

#define ASC_DBG4(lvl, s, a1, a2, a3, a4) \
                    DebugPrint(((lvl), (s), (a1), (a2), (a3), (a4)))

#define ASC_ASSERT(a) \
    { \
        if (!(a)) { \
            DebugPrint((1, "ASC_ASSERT() Failure: file %s, line %d\n", \
                __FILE__, __LINE__)); \
        } \
    }

#define ASC_DASSERT(a)  ASC_ASSERT(a)

#endif /* ASC_DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_advlib.h ===
/*
 * a_advlib.h - Main Adv Library Include File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef __A_ADVLIB_H_
#define __A_ADVLIB_H_

/*
 * Adv Library Compile-Time Options
 *
 * Drivers must explicity define the following options to
 * 1 or 0 in in d_os_dep.h.
 *
 * The Adv Library also contains source code which is conditional
 * on the ADV_OS_* definition in d_os_dep.h.
 */

/* ADV_DISP_INQUIRY - include AscDispInquiry() function */
#if !defined(ADV_DISP_INQUIRY) || \
    (ADV_DISP_INQUIRY != 1 && ADV_DISP_INQUIRY != 0)
Forced Error: Driver must define ADV_DISP_INQUIRY to 1 or 0.
#endif /* ADV_DISP_INQUIRY */

/* ADV_GETSGLIST - include AscGetSGList() function */
#if !defined(ADV_GETSGLIST) || (ADV_GETSGLIST != 1 && ADV_GETSGLIST != 0)
Forced Error: Driver must define ADV_GETSGLIST to 1 or 0.
#endif /* ADV_GETSGLIST */

/* ADV_INITSCSITARGET - include AdvInitScsiTarget() function */
#if !defined(ADV_INITSCSITARGET) || \
    (ADV_INITSCSITARGET != 1 && ADV_INITSCSITARGET != 0)
Forced Error: Driver must define ADV_INITSCSITARGET to 1 or 0.
#endif /* ADV_INITSCSITARGET */

/*
 * ADV_PCI_MEMORY
 *
 * Only use PCI Memory accesses to read/write Condor registers. The
 * driver must set the ASC_DVC_VAR 'mem_base' field during initialization
 * to the mapped virtual address of Condor's registers.
 */
#if !defined(ADV_PCI_MEMORY) || (ADV_PCI_MEMORY != 1 && ADV_PCI_MEMORY != 0)
Forced Error: Driver must define ADV_PCI_MEMORY to 1 or 0.
#endif /* ADV_PCI_MEMORY */

/*
 * ADV_SCAM
 *
 * The SCAM function is not currently utilized and probably won't
 * be in the future. Leave a place holder here for it.
 */
#define ADV_SCAM        0
#if !defined(ADV_SCAM) || (ADV_SCAM != 1 && ADV_SCAM != 0)
Forced Error: Driver must define ADV_SCAM to 1 or 0.
#endif /* ADV_SCAM */

/*
 * ADV_CRITICAL
 *
 * If set to 1, driver supplies DvcEnterCritical() and DvcLeaveCritical()
 * functions. If set to 0, the driver guarantees that whenever it calls
 * Adv Library functions interrupts are disabled.
 */
#if !defined(ADV_CRITICAL) || (ADV_CRITICAL != 1 && ADV_CRITICAL != 0)
Forced Error: Driver must define ADV_CRITICAL to 1 or 0.
#endif /* ADV_CRITICAL */

/*
 * ADV_UCODEDEFAULT
 *
 * If ADV_UCODEDEFAULT is defined to 1 then certain microcode
 * operating variable default values are overridden, cf.
 * a_init.c:AdvInitAsc3550Driver().
 *
 * Only set this to 0 if the driver or BIOS needs to save space.
 */
#if !defined(ADV_UCODEDEFAULT) || (ADV_UCODEDEFAULT != 1 && ADV_UCODEDEFAULT != 0)
Forced Error: Driver must define ADV_UCODEDEFAULT to 1 or 0.
#endif /* ADV_UCODEDEFAULT */

/*
 * ADV_BIG_ENDIAN
 *
 * Choose to use big endian data orientation or little endian
 * data orientation. Currently Mac is the only OS using big
 * endian data orientation.
 */
#if !defined(ADV_BIG_ENDIAN) || (ADV_BIG_ENDIAN != 1 && ADV_BIG_ENDIAN != 0)
Forced Error: Driver must define ADV_BIG_ENDIAN to 1 or 0.
#endif /* ADV_BIG_ENDIAN */

/*
 * Adv Library Status Definitions
 */
#define ADV_TRUE        1
#define ADV_FALSE       0
#define ADV_NOERROR     1
#define ADV_SUCCESS     1
#define ADV_BUSY        0
#define ADV_ERROR       (-1)


/*
 * ASC_DVC_VAR 'warn_code' values
 */
#define ASC_WARN_EEPROM_CHKSUM          0x0002 /* EEP check sum error */
#define ASC_WARN_EEPROM_TERMINATION     0x0004 /* EEP termination bad field */
#define ASC_WARN_SET_PCI_CONFIG_SPACE   0x0080 /* PCI config space set error */
#define ASC_WARN_ERROR                  0xFFFF /* ADV_ERROR return */

#define ASC_MAX_TID                     15 /* max. target identifier */
#define ASC_MAX_LUN                     7  /* max. logical unit number */

#if ADV_INITSCSITARGET
/*
 * AscInitScsiTarget() structure definitions.
 */
typedef struct asc_dvc_inq_info
{
  uchar type[ASC_MAX_TID+1][ASC_MAX_LUN+1];
} ASC_DVC_INQ_INFO;

typedef struct asc_cap_info
{
  ulong lba;       /* the maximum logical block size */
  ulong blk_size;  /* the logical block size in bytes */
} ASC_CAP_INFO;

typedef struct asc_cap_info_array
{
  ASC_CAP_INFO  cap_info[ASC_MAX_TID+1][ASC_MAX_LUN+1];
} ASC_CAP_INFO_ARRAY;
#endif /* ADV_INITSCSITARGET */


/*
 * AscInitGetConfig() and AscInitAsc1000Driver() Definitions
 *
 * Error code values are set in ASC_DVC_VAR 'err_code'.
 */
#define ASC_IERR_WRITE_EEPROM       0x0001 /* write EEPROM error */
#define ASC_IERR_MCODE_CHKSUM       0x0002 /* micro code check sum error */
#define ASC_IERR_START_STOP_CHIP    0x0008 /* start/stop chip failed */
#define ASC_IERR_CHIP_VERSION       0x0040 /* wrong chip version */
#define ASC_IERR_SET_SCSI_ID        0x0080 /* set SCSI ID failed */
#define ASC_IERR_BAD_SIGNATURE      0x0200 /* signature not found */
#define ASC_IERR_ILLEGAL_CONNECTION 0x0400 /* Illegal cable connection */
#define ASC_IERR_SINGLE_END_DEVICE  0x0800 /* Single-end used w/differential */
#define ASC_IERR_REVERSED_CABLE     0x1000 /* Narrow flat cable reversed */
#define ASC_IERR_RW_LRAM            0x8000 /* read/write local RAM error */

/*
 * Fixed locations of microcode operating variables.
 */
#define ASC_MC_CODE_BEGIN_ADDR          0x0028 /* microcode start address */
#define ASC_MC_CODE_END_ADDR            0x002A /* microcode end address */
#define ASC_MC_CODE_CHK_SUM             0x002C /* microcode code checksum */
#define ASC_MC_STACK_BEGIN              0x002E /* microcode stack begin */
#define ASC_MC_STACK_END                0x0030 /* microcode stack end */
#define ASC_MC_VERSION_DATE             0x0038 /* microcode version */
#define ASC_MC_VERSION_NUM              0x003A /* microcode number */
#define ASCV_VER_SERIAL_W               0x003C /* used in dos_init */
#define ASC_MC_BIOSMEM                  0x0040 /* BIOS RISC Memory Start */
#define ASC_MC_BIOSLEN                  0x0050 /* BIOS RISC Memory Length */
#define ASC_MC_HALTCODE                 0x0094 /* microcode halt code */
#define ASC_MC_CALLERPC                 0x0096 /* microcode halt caller PC */
#define ASC_MC_ADAPTER_SCSI_ID          0x0098 /* one ID byte + reserved */
#define ASC_MC_ULTRA_ABLE               0x009C
#define ASC_MC_SDTR_ABLE                0x009E
#define ASC_MC_TAGQNG_ABLE              0x00A0
#define ASC_MC_DISC_ENABLE              0x00A2
#define ASC_MC_IDLE_CMD                 0x00A6
#define ASC_MC_IDLE_PARA_STAT           0x00A8
#define ASC_MC_DEFAULT_SCSI_CFG0        0x00AC
#define ASC_MC_DEFAULT_SCSI_CFG1        0x00AE
#define ASC_MC_DEFAULT_MEM_CFG          0x00B0
#define ASC_MC_DEFAULT_SEL_MASK         0x00B2
#define ASC_MC_RISC_NEXT_READY          0x00B4
#define ASC_MC_RISC_NEXT_DONE           0x00B5
#define ASC_MC_SDTR_DONE                0x00B6
#define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0
#define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100
#define ASC_MC_WDTR_ABLE                0x0120 /* Wide Transfer TID bitmask. */
#define ASC_MC_CONTROL_FLAG             0x0122 /* Microcode control flag. */
#define ASC_MC_WDTR_DONE                0x0124
#define ASC_MC_HOST_NEXT_READY          0x0128 /* Host Next Ready RQL Entry. */
#define ASC_MC_HOST_NEXT_DONE           0x0129 /* Host Next Done RQL Entry. */

/*
 * Microcode Control Flags
 *
 * Flags set by the Adv Library in RISC variable 'control_flag' (0x122)
 * and handled by the microcode.
 */
#define CONTROL_FLAG_IGNORE_PERR        0x0001 /* Ignore DMA Parity Errors */

/*
 * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format
 */
#define HSHK_CFG_WIDE_XFR       0x8000
#define HSHK_CFG_RATE           0x0F00
#define HSHK_CFG_OFFSET         0x001F

/*
 * LRAM RISC Queue Lists (LRAM addresses 0x1200 - 0x19FF)
 *
 * Each of the 255 Adv Library/Microcode RISC queue lists or mailboxes
 * starting at LRAM address 0x1200 is 8 bytes and has the following
 * structure. Only 253 of these are actually used for command queues.
 */

#define ASC_MC_RISC_Q_LIST_BASE         0x1200
#define ASC_MC_RISC_Q_LIST_SIZE         0x0008
#define ASC_MC_RISC_Q_TOTAL_CNT         0x00FF /* Num. queue slots in LRAM. */
#define ASC_MC_RISC_Q_FIRST             0x0001
#define ASC_MC_RISC_Q_LAST              0x00FF

#define ASC_DEF_MAX_HOST_QNG    0xFD /* Max. number of host commands (253) */
#define ASC_DEF_MIN_HOST_QNG    0x10 /* Min. number of host commands (16) */
#define ASC_DEF_MAX_DVC_QNG     0x3F /* Max. number commands per device (63) */
#define ASC_DEF_MIN_DVC_QNG     0x04 /* Min. number commands per device (4) */

/* RISC Queue List structure - 8 bytes */
#define RQL_FWD     0     /* forward pointer (1 byte) */
#define RQL_BWD     1     /* backward pointer (1 byte) */
#define RQL_STATE   2     /* state byte - free, ready, done, aborted (1 byte) */
#define RQL_TID     3     /* request target id (1 byte) */
#define RQL_PHYADDR 4     /* request physical pointer (4 bytes) */

/* RISC Queue List state values */
#define ASC_MC_QS_FREE                  0x00
#define ASC_MC_QS_READY                 0x01
#define ASC_MC_QS_DONE                  0x40
#define ASC_MC_QS_ABORTED               0x80

/* RISC Queue List pointer values */
#define ASC_MC_NULL_Q                   0x00            /* NULL_Q == 0   */
#define ASC_MC_BIOS_Q                   0xFF            /* BIOS_Q = 255  */

/* ASC_SCSI_REQ_Q 'cntl' field values */
#define ASC_MC_QC_START_MOTOR           0x02     /* Issue start motor. */
#define ASC_MC_QC_NO_OVERRUN            0x04     /* Don't report overrun. */
#define ASC_MC_QC_FIRST_DMA             0x08     /* Internal microcode flag. */
#define ASC_MC_QC_ABORTED               0x10     /* Request aborted by host. */
#define ASC_MC_QC_REQ_SENSE             0x20     /* Auto-Request Sense. */
#define ASC_MC_QC_DOS_REQ               0x80     /* Request issued by DOS. */


/*
 * ASC_SCSI_REQ_Q 'a_flag' definitions
 *
 * The Adv Library should limit use to the lower nibble (4 bits) of
 * a_flag. Drivers are free to use the upper nibble (4 bits) of a_flag.
 *
 * Note: ASPI uses the 0x04 definition and should change to 0x10.
 * Just check with ASPI before you really want to use 0x04 here.
 */
#define ADV_POLL_REQUEST                0x01   /* poll for request completion */
#define ADV_SCSIQ_DONE                  0x02   /* request done */
#define ADV_DONT_RETRY                  0x08   /* don't do retry */

/*
 * Adapter temporary configuration structure
 *
 * This structure can be discarded after initialization. Don't add
 * fields here needed after initialization.
 *
 * Field naming convention:
 *
 *  *_enable indicates the field enables or disables a feature. The
 *  value of the field is never reset.
 */
typedef struct asc_dvc_cfg {
  ushort disc_enable;       /* enable disconnection */
  uchar  chip_version;      /* chip version */
  uchar  termination;       /* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */
  ushort pci_device_id;     /* PCI device code number */
  ushort lib_version;       /* Adv Library version number */
  ushort control_flag;      /* Microcode Control Flag */
  ushort mcode_date;        /* Microcode date */
  ushort mcode_version;     /* Microcode version */
  ushort pci_slot_info;     /* high byte device/function number */
                            /* bits 7-3 device num., bits 2-0 function num. */
                            /* low byte bus num. */
#ifdef ADV_OS_BIOS
  ushort bios_scan;         /* BIOS device scan bitmask. */
  ushort bios_delay;        /* BIOS boot time initialization delay. */
  uchar  bios_id_lun;       /* BIOS Boot TID and LUN */
#endif /* ADV_OS_BIOS */
} ASC_DVC_CFG;

/*
 * Adatper operation variable structure.
 *
 * One structure is required per host adapter.
 *
 * Field naming convention:
 *
 *  *_able indicates both whether a feature should be enabled or disabled
 *  and whether a device isi capable of the feature. At initialization
 *  this field may be set, but later if a device is found to be incapable
 *  of the feature, the field is cleared.
 */
typedef struct asc_dvc_var {
  PortAddr iop_base;      /* I/O port address */
  ushort err_code;        /* fatal error code */
  ushort bios_ctrl;       /* BIOS control word, EEPROM word 12 */
  Ptr2Func isr_callback;  /* pointer to function, called in AdvISR() */
  Ptr2Func sbreset_callback;  /* pointer to function, called in AdvISR() */
  ushort wdtr_able;       /* try WDTR for a device */
  ushort sdtr_able;       /* try SDTR for a device */
  ushort ultra_able;      /* try SDTR Ultra speed for a device */
  ushort tagqng_able;     /* try tagged queuing with a device */
  uchar  max_dvc_qng;     /* maximum number of tagged commands per device */
  ushort start_motor;     /* start motor command allowed */
  uchar  scsi_reset_wait; /* delay in seconds after scsi bus reset */
  uchar  chip_no;         /* should be assigned by caller */
  uchar  max_host_qng;    /* maximum number of Q'ed command allowed */
  uchar  cur_host_qng;    /* total number of queue command */
  uchar  irq_no;          /* IRQ number */
  ushort no_scam;         /* scam_tolerant of EEPROM */
  ushort idle_cmd_done;   /* microcode idle command done set by AdvISR() */
  ulong  drv_ptr;         /* driver pointer to private structure */
  uchar  chip_scsi_id;    /* chip SCSI target ID */
 /*
  * Note: The following fields will not be used after initialization. The
  * driver may discard the buffer after initialization is done.
  */
  ASC_DVC_CFG WinBiosFar *cfg; /* temporary configuration structure  */
} ASC_DVC_VAR;

#define NO_OF_SG_PER_BLOCK              15

typedef struct asc_sg_block {
#ifdef ADV_OS_DOS
    uchar dos_ix;                     /* index for DOS phy addr array */
#else /* ADV_OS_DOS */
    uchar reserved1;
#endif /* ADV_OS_DOS */
    uchar reserved2;
    uchar first_entry_no;             /* starting entry number */
    uchar last_entry_no;              /* last entry number */
    struct asc_sg_block dosfar *sg_ptr; /* links to the next sg block */
    struct  {
        ulong sg_addr;                /* SG element address */
        ulong sg_count;               /* SG element count */
    } sg_list[NO_OF_SG_PER_BLOCK];
} ASC_SG_BLOCK;

/*
 * ASC_SCSI_REQ_Q - microcode request structure
 *
 * All fields in this structure up to byte 60 are used by the microcode.
 * The microcode makes assumptions about the size and ordering of fields
 * in this structure. Do not change the structure definition here without
 * coordinating the change with the microcode.
 */
typedef struct asc_scsi_req_q {
    uchar       cntl;           /* Ucode flags and state (ASC_MC_QC_*). */
    uchar       sg_entry_cnt;   /* SG element count. Zero for no SG. */
    uchar       target_id;      /* Device target identifier. */
    uchar       target_lun;     /* Device target logical unit number. */
    ulong       data_addr;      /* Data buffer physical address. */
    ulong       data_cnt;       /* Data count. Ucode sets to residual. */
    ulong       sense_addr;     /* Sense buffer physical address. */
    ulong       srb_ptr;        /* Driver request pointer. */
    uchar       a_flag;         /* Adv Library flag field. */
    uchar       sense_len;      /* Auto-sense length. Ucode sets to residual. */
    uchar       cdb_len;        /* SCSI CDB length. */
    uchar       tag_code;       /* SCSI-2 Tag Queue Code: 00, 20-22. */
    uchar       done_status;    /* Completion status. */
    uchar       scsi_status;    /* SCSI status byte. */
    uchar       host_status;    /* Ucode host status. */
    uchar       ux_sg_ix;       /* Ucode working SG variable. */
    uchar       cdb[12];        /* SCSI command block. */
    ulong       sg_real_addr;   /* SG list physical address. */
    struct asc_scsi_req_q dosfar *free_scsiq_link;
    ulong       ux_wk_data_cnt; /* Saved data count at disconnection. */
    struct asc_scsi_req_q dosfar *scsiq_ptr;
    ASC_SG_BLOCK dosfar *sg_list_ptr; /* SG list virtual address. */
    /*
     * End of microcode structure - 60 bytes. The rest of the structure
     * is used by the Adv Library and ignored by the microcode.
     */
    ulong       vsense_addr;    /* Sense buffer virtual address. */
    ulong       vdata_addr;     /* Data buffer virtual address. */
#ifdef ADV_OS_DOS
    ushort      vm_id;          /* Used by DOS to track VM ID. */
    uchar       dos_ix;         /* Index for DOS phy addr array. */
#endif /* ADV_OS_DOS */
#if ADV_INITSCSITARGET
    uchar       error_retry;    /* Retry counter, used by AdvISR(). */
    ulong       orig_data_cnt;  /* Original length of data buffer. */
#endif /* ADV_INITSCSITARGET */
    uchar       orig_sense_len; /* Original length of sense buffer. */
#ifdef ADV_OS_DOS
    /*
     * Pad the structure for DOS to a doubleword (4 byte) boundary.
     * DOS ASPI allocates an array of these structures and only aligns
     * the first structure. To ensure that all following structures in
     * the array are doubleword (4 byte) aligned the structure for DOS
     * must be a multiple of 4 bytes.
     */
    uchar       reserved1;
    uchar       reserved2;
    uchar       reserved3;
#endif /* ADV_OS_DOS */
} ASC_SCSI_REQ_Q; /* BIOS - 74 bytes, DOS - 80 bytes, W95, WNT - 69 bytes */

/*
 * Microcode idle loop commands
 */
#define IDLE_CMD_COMPLETED           0
#define IDLE_CMD_STOP_CHIP           0x0001
#define IDLE_CMD_STOP_CHIP_SEND_INT  0x0002
#define IDLE_CMD_SEND_INT            0x0004
#define IDLE_CMD_ABORT               0x0008
#define IDLE_CMD_DEVICE_RESET        0x0010
#define IDLE_CMD_SCSI_RESET          0x0020

/*
 * AscSendIdleCmd() flag definitions.
 */
#define ADV_NOWAIT     0x01

/*
 * Wait loop time out values.
 */
#define SCSI_WAIT_10_SEC             10         /* 10 seconds */
#define SCSI_MS_PER_SEC              1000       /* milliseconds per second */
#define SCSI_MAX_RETRY               10         /* retry count */

#if ADV_PCI_MEMORY

#ifndef ADV_MEM_READB
Forced Error: Driver must define ADV_MEM_READB macro.
#endif /* ADV_MEM_READB */

#ifndef ADV_MEM_WRITEB
Forced Error: Driver must define ADV_MEM_WRITEB macro.
#endif /* ADV_MEM_WRITEB */

#ifndef ADV_MEM_READW
Forced Error: Driver must define ADV_MEM_READW macro.
#endif /* ADV_MEM_READW */

#ifndef ADV_MEM_WRITEW
Forced Error: Driver must define ADV_MEM_WRITEW macro.
#endif /* ADV_MEM_WRITEW */

#else /* ADV_PCI_MEMORY */

#ifndef ADV_OS_NETWARE
/*
 * Device drivers must define the following macros:
 *   inp, inpw, outp, outpw
 */
#ifndef inp
Forced Error: Driver must define inp macro.
#endif /* inp */

#ifndef inpw
Forced Error: Driver must define inpw macro.
#endif /* inpw */

#ifndef outp
Forced Error: Driver must define outp macro.
#endif /* outp */

#ifndef outpw
Forced Error: Driver must define outpw macro.
#endif /* outpw */
#endif /* ADV_OS_NETWARE */

#endif /* ADV_PCI_MEMORY */


/*
 * Device drivers must define the following functions that
 * are called by the Adv Library.
 */
extern int   DvcEnterCritical(void);
extern void  DvcLeaveCritical(int);
extern uchar DvcReadPCIConfigByte(ASC_DVC_VAR WinBiosFar *, ushort);
extern void  DvcWritePCIConfigByte(ASC_DVC_VAR WinBiosFar *, ushort, uchar);
extern void  DvcSleepMilliSecond(ulong);
extern void  DvcDisplayString(uchar dosfar *);
extern ulong DvcGetPhyAddr(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *,
                uchar dosfar *, long dosfar *, int);
extern void  DvcDelayMicroSecond(ASC_DVC_VAR WinBiosFar *, ushort);
#ifdef ADV_OS_BIOS
extern void  BIOSDispInquiry(uchar, ASC_SCSI_INQUIRY dosfar *);
extern void  BIOSCheckControlDrive(ASC_DVC_VAR WinBiosFar*, uchar,
                ASC_SCSI_INQUIRY dosfar *, ASC_CAP_INFO dosfar *, uchar);
#endif /* ADV_OS_BIOS */
#if ADV_BIG_ENDIAN
extern int   AdvAdjEndianScsiQ( ASC_SCSI_REQ_Q * ) ;
#endif /* ADV_BIG_ENDIAN */

/*
 * Adv Library interface functions. These are functions called
 * by device drivers.
 *
 * The convention is that all external interface function
 * names begin with "Adv".
 */

int     AdvExeScsiQueue(ASC_DVC_VAR WinBiosFar *,
                         ASC_SCSI_REQ_Q dosfar *);
int     AdvISR(ASC_DVC_VAR WinBiosFar *);
int     AdvInitGetConfig(ASC_DVC_VAR WinBiosFar *);
int     AdvInitAsc3550Driver(ASC_DVC_VAR WinBiosFar *);
int     AdvResetSB(ASC_DVC_VAR WinBiosFar *);
ushort  AdvGetEEPConfig(PortAddr, ASCEEP_CONFIG dosfar *);
void    AdvSetEEPConfig(PortAddr, ASCEEP_CONFIG dosfar *);
void    AdvResetChip(ASC_DVC_VAR WinBiosFar *);
void    AscResetSCSIBus(ASC_DVC_VAR WinBiosFar *);
#if ADV_GETSGLIST
int     AscGetSGList(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);
#endif /* ADV_SGLIST */
#if ADV_INITSCSITARGET
int     AdvInitScsiTarget(ASC_DVC_VAR WinBiosFar *,
                           ASC_DVC_INQ_INFO dosfar *,
                           uchar dosfar *,
                           ASC_CAP_INFO_ARRAY dosfar *,
                           ushort);
#endif /* ADV_INITSCSITARGET */

/*
 * Internal Adv Library functions. These functions are not
 * supposed to be directly called by device drivers.
 *
 * The convention is these all internal interface function
 * names begin with "Asc".
 */
int     AscSendIdleCmd(ASC_DVC_VAR WinBiosFar *, ushort, ulong, int);
int     AscSendScsiCmd(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);
void    AdvInquiryHandling(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);

#if ADV_INITSCSITARGET
#if (OS_UNIXWARE || OS_SCO_UNIX)
int     AdvInitPollTarget(
#else
int     AscInitPollTarget(
#endif
            ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *,
            ASC_SCSI_INQUIRY dosfar *, ASC_CAP_INFO dosfar *,
            ASC_REQ_SENSE dosfar *);

int     AscScsiUrgentCmd(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *,
            uchar dosfar *, long , uchar dosfar *, long);
void    AscWaitScsiCmd(ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);
#endif /* ADV_INITSCSITARGET */
static   int     AscInitFromEEP(ASC_DVC_VAR WinBiosFar *);
static   void    AscWaitEEPCmd(PortAddr);
static   ushort  AscReadEEPWord(PortAddr, int);
#if ADV_DISP_INQUIRY
void    AscDispInquiry(uchar, uchar, ASC_SCSI_INQUIRY dosfar *);
#endif /* ADV_DISP_INQUIRY */

/*
 * PCI Bus Definitions
 */
#define AscPCICmdRegBits_BusMastering     0x0007
#define AscPCICmdRegBits_ParErrRespCtrl   0x0040

#define AscPCIConfigVendorIDRegister      0x0000
#define AscPCIConfigDeviceIDRegister      0x0002
#define AscPCIConfigCommandRegister       0x0004
#define AscPCIConfigStatusRegister        0x0006
#define AscPCIConfigCacheSize             0x000C
#define AscPCIConfigLatencyTimer          0x000D /* BYTE */
#define AscPCIIOBaseRegister              0x0010

#define ASC_PCI_ID2BUS(id)    ((id) & 0xFF)
#define ASC_PCI_ID2DEV(id)    (((id) >> 11) & 0x1F)
#define ASC_PCI_ID2FUNC(id)   (((id) >> 8) & 0x7)

#define ASC_PCI_MKID(bus, dev, func) \
      ((((dev) & 0x1F) << 11) | (((func) & 0x7) << 8) | ((bus) & 0xFF))


/*
 * Define macros for accessing Condor registers.
 *
 * Registers can be accessed using I/O space at the I/O address
 * specified by PCI Configuration Space Base Address Register #0
 * or using memory space at the memory address specified by
 * PCI Configuration Space Base Address Register #1.
 *
 * If a driver defines ADV_PCI_MEMORY to 1, then it will use
 * memory space to access Condor registers. The driver must
 * map the physical Base Address Register #1 to virtual memory
 * and set the ASC_DVC_VAR 'iop_base' field to this address
 * for the Adv Library to use. The 'PortAddr' type will also
 * have to be defined to be the size of the mapped virtual
 * address.
 */

#if ADV_PCI_MEMORY

/* Read byte from a register. */
#define AscReadByteRegister(iop_base, reg_off) \
     (ADV_MEM_READB((iop_base) + (reg_off)))

/* Write byte to a register. */
#define AscWriteByteRegister(iop_base, reg_off, byte) \
     (ADV_MEM_WRITEB((iop_base) + (reg_off), (byte)))

/* Read word (2 bytes) from a register. */
#define AscReadWordRegister(iop_base, reg_off) \
     (ADV_MEM_READW((iop_base) + (reg_off)))

/* Write word (2 bytes) to a register. */
#define AscWriteWordRegister(iop_base, reg_off, word) \
     (ADV_MEM_WRITEW((iop_base) + (reg_off), (word)))

/* Read byte from LRAM. */
#define AscReadByteLram(iop_base, addr) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (ADV_MEM_READB((iop_base) + IOPB_RAM_DATA)))

/* Write byte to LRAM. */
#define AscWriteByteLram(iop_base, addr, byte) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     ADV_MEM_WRITEB((iop_base) + IOPB_RAM_DATA, (byte)))

/* Read word (2 bytes) from LRAM. */
#define AscReadWordLram(iop_base, addr) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA)))

/* Write word (2 bytes) to LRAM. */
#define AscWriteWordLram(iop_base, addr, word) \
    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
     ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))

/* Write double word (4 bytes) to LRAM
 * Because of unspecified C language ordering don't use auto-increment.
 */
#define AscWriteDWordLram(iop_base, addr, dword) \
    ((ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \
      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \
                     (ushort) ((dword) & 0xFFFF))), \
     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \
      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \
                     (ushort) ((dword >> 16) & 0xFFFF))))

/* Read word (2 bytes) from LRAM assuming that the address is already set. */
#define AscReadWordAutoIncLram(iop_base) \
     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA))

/* Write word (2 bytes) to LRAM assuming that the address is already set. */
#define AscWriteWordAutoIncLram(iop_base, word) \
     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))

#else /* ADV_PCI_MEMORY */

/* Read byte from a register. */
#define AscReadByteRegister(iop_base, reg_off) \
     (inp((iop_base) + (reg_off)))

/* Write byte to a register. */
#define AscWriteByteRegister(iop_base, reg_off, byte) \
     (outp((iop_base) + (reg_off), (byte)))

/* Read word (2 bytes) from a register. */
#define AscReadWordRegister(iop_base, reg_off) \
     (inpw((iop_base) + (reg_off)))

/* Write word (2 bytes) to a register. */
#define AscWriteWordRegister(iop_base, reg_off, word) \
     (outpw((iop_base) + (reg_off), (word)))

/* Read byte from LRAM. */
#define AscReadByteLram(iop_base, addr) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (inp((iop_base) + IOPB_RAM_DATA)))

/* Write byte to LRAM. */
#define AscWriteByteLram(iop_base, addr, byte) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     outp((iop_base) + IOPB_RAM_DATA, (byte)))

/* Read word (2 bytes) from LRAM. */
#define AscReadWordLram(iop_base, addr) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     (inpw((iop_base) + IOPW_RAM_DATA)))

/* Write word (2 bytes) to LRAM. */
#define AscWriteWordLram(iop_base, addr, word) \
    (outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
     outpw((iop_base) + IOPW_RAM_DATA, (word)))

/* Write double word (4 bytes) to LRAM
 * Because of unspecified C language ordering don't use auto-increment.
 */
#define AscWriteDWordLram(iop_base, addr, dword) \
    ((outpw((iop_base) + IOPW_RAM_ADDR, (addr)), \
      outpw((iop_base) + IOPW_RAM_DATA, (ushort) ((dword) & 0xFFFF))), \
     (outpw((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \
      outpw((iop_base) + IOPW_RAM_DATA, (ushort) ((dword >> 16) & 0xFFFF))))

/* Read word (2 bytes) from LRAM assuming that the address is already set. */
#define AscReadWordAutoIncLram(iop_base) \
     (inpw((iop_base) + IOPW_RAM_DATA))

/* Write word (2 bytes) to LRAM assuming that the address is already set. */
#define AscWriteWordAutoIncLram(iop_base, word) \
     (outpw((iop_base) + IOPW_RAM_DATA, (word)))

#endif /* ADV_PCI_MEMORY */


/*
 * Define macro to check for Condor signature.
 *
 * Evaluate to ADV_TRUE if a Condor chip is found the specified port
 * address 'iop_base'. Otherwise evalue to ADV_FALSE.
 */
#define AdvFindSignature(iop_base) \
    (((AscReadByteRegister((iop_base), IOPB_CHIP_ID_1) == \
        ADV_CHIP_ID_BYTE) && \
     (AscReadWordRegister((iop_base), IOPW_CHIP_ID_0) == \
        ADV_CHIP_ID_WORD)) ?  ADV_TRUE : ADV_FALSE)

/*
 * Define macro to Return the version number of the chip at 'iop_base'.
 *
 * The second parameter 'bus_type' is currently unused.
 */
#define AdvGetChipVersion(iop_base, bus_type) \
    AscReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)

/*
 * Abort an SRB in the chip's RISC Memory. The 'srb_ptr' argument must
 * match the ASC_SCSI_REQ_Q 'srb_ptr' field.
 *
 * If the request has not yet been sent to the device it will simply be
 * aborted from RISC memory. If the request is disconnected it will be
 * aborted on reselection by sending an Abort Message to the target ID.
 *
 * Return value:
 *      ADV_TRUE(1) - Queue was successfully aborted.
 *      ADV_FALSE(0) - Queue was not found on the active queue list.
 */
#define AdvAbortSRB(asc_dvc, srb_ptr) \
    AscSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \
                (ulong) (srb_ptr), 0)

/*
 * Send a Bus Device Reset Message to the specified target ID.
 *
 * All outstanding commands will be purged if sending the
 * Bus Device Reset Message is successful.
 *
 * Return Value:
 *      ADV_TRUE(1) - All requests on the target are purged.
 *      ADV_FALSE(0) - Couldn't issue Bus Device Reset Message; Requests
 *                     are not purged.
 */
#define AdvResetDevice(asc_dvc, target_id) \
        AscSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET, \
                    (ulong) (target_id), 0)

/*
 * SCSI Wide Type definition.
 */
#define ADV_SCSI_BIT_ID_TYPE   ushort

/*
 * AdvInitScsiTarget() 'cntl_flag' options.
 */
#define ADV_SCAN_LUN           0x01
#define ADV_CAPINFO_NOLUN      0x02

/*
 * Convert target id to target id bit mask.
 */
#define ADV_TID_TO_TIDMASK(tid)   (0x01 << ((tid) & ASC_MAX_TID))

/*
 * ASC_SCSI_REQ_Q 'done_status' and 'host_status' return values.
 *
 * XXX - These constants are also defined in qswap.sas. The microcode
 * and Adv Library should instead share the same definitions. qswap.sas
 * should be changed to be able to use an include file.
 */

#define QD_NO_STATUS         0x00       /* Request not completed yet. */
#define QD_NO_ERROR          0x01
#define QD_ABORTED_BY_HOST   0x02
#define QD_WITH_ERROR        0x04
#if ADV_INITSCSITARGET
#define QD_DO_RETRY          0x08
#endif /* ADV_INITSCSITARGET */

#define QHSTA_NO_ERROR              0x00
#define QHSTA_M_SEL_TIMEOUT         0x11
#define QHSTA_M_DATA_OVER_RUN       0x12
#define QHSTA_M_UNEXPECTED_BUS_FREE 0x13
#define QHSTA_M_QUEUE_ABORTED       0x15
#define QHSTA_M_SXFR_SDMA_ERR       0x16 /* SXFR_STATUS SCSI DMA Error */
#define QHSTA_M_SXFR_SXFR_PERR      0x17 /* SXFR_STATUS SCSI Bus Parity Error */
#define QHSTA_M_RDMA_PERR           0x18 /* RISC PCI DMA parity error */
#define QHSTA_M_SXFR_OFF_UFLW       0x19 /* SXFR_STATUS Offset Underflow */
#define QHSTA_M_SXFR_OFF_OFLW       0x20 /* SXFR_STATUS Offset Overflow */
#define QHSTA_M_SXFR_WD_TMO         0x21 /* SXFR_STATUS Watchdog Timeout */
#define QHSTA_M_SXFR_DESELECTED     0x22 /* SXFR_STATUS Deselected */
/* Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */
#define QHSTA_M_SXFR_XFR_OFLW       0x12 /* SXFR_STATUS Transfer Overflow */
#define QHSTA_M_SXFR_XFR_PH_ERR     0x24 /* SXFR_STATUS Transfer Phase Error */
#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25 /* SXFR_STATUS Unknown Error */
#define QHSTA_M_WTM_TIMEOUT         0x41
#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42
#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43
#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44
#define QHSTA_M_INVALID_DEVICE      0x45 /* Bad target ID */

typedef int (dosfar * ASC_ISR_CALLBACK)
    (ASC_DVC_VAR WinBiosFar *, ASC_SCSI_REQ_Q dosfar *);

typedef int (dosfar * ASC_SBRESET_CALLBACK)
    (ASC_DVC_VAR WinBiosFar *);

/*
 * Default EEPROM Configuration structure defined in a_init.c.
 */
extern ASCEEP_CONFIG Default_EEPROM_Config;

/*
 * DvcGetPhyAddr() flag arguments
 */
#define ADV_IS_SCSIQ_FLAG       0x01 /* 'addr' is ASC_SCSI_REQ_Q pointer */
#define ADV_ASCGETSGLIST_VADDR  0x02 /* 'addr' is AscGetSGList() virtual addr */
#define ADV_IS_SENSE_FLAG       0x04 /* 'addr' is sense virtual pointer */
#define ADV_IS_DATA_FLAG        0x08 /* 'addr' is data virtual pointer */
#define ADV_IS_SGLIST_FLAG      0x10 /* 'addr' is sglist virtual pointer */

/* 'IS_SCSIQ_FLAG is now obsolete; Instead use ADV_IS_SCSIQ_FLAG. */
#define IS_SCSIQ_FLAG           ADV_IS_SCSIQ_FLAG


/* Return the address that is aligned at the next doubleword >= to 'addr'. */
#define ADV_DWALIGN(addr)       (((ulong) (addr) + 0x3) & ~0x3)

/*
 * Total contiguous memory needed for driver SG blocks.
 *
 * ADV_MAX_SG_LIST must be defined by a driver. It is the maximum
 * number of scatter-gather elements the driver supports in a
 * single request.
 */

#ifndef ADV_MAX_SG_LIST
Forced Error: Driver must define ADV_MAX_SG_LIST.
#endif /* ADV_MAX_SG_LIST */

#define ADV_SG_LIST_MAX_BYTE_SIZE \
         (sizeof(ASC_SG_BLOCK) * \
          ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))

/*
 * A driver may optionally define the assertion macro ADV_ASSERT() in
 * its d_os_dep.h file. If the macro has not already been defined,
 * then define the macro to a no-op.
 */
#ifndef ADV_ASSERT
#define ADV_ASSERT(a)
#endif /* ADV_ASSERT */



#endif /* __A_ADVLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_advlib.c ===
/*
 * a_advlib.c - Main Adv Library Source File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#include "a_ver.h"       /* Version */
#include "d_os_dep.h"    /* Driver */
#include "a_scsi.h"      /* SCSI */
#include "a_condor.h"    /* AdvanSys Hardware*/
#include "a_advlib.h"    /* Adv Library */

/*
 * Define a 12-bit unique file id which may by used by a driver for
 * debugging or tracing purposes. Each C source file must define a
 * different value.
 */
#define ADV_FILE_UNIQUE_ID           0xAD2   /* Adv Library C Source File #2 */

#ifndef ADV_OS_BIOS
/*
 * Description:
 *      Send a SCSI request to the ASC3550 chip
 *
 * If there is no SG list for the request, set 'sg_entry_cnt' to 0.
 *
 * If 'sg_real_addr' is non-zero on entry, AscGetSGList() will not be
 * called. It is assumed the caller has already initialized 'sg_real_addr'.
 *
 * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be
 * set to SCSI_MAX_RETRY.
 *
 * Return:
 *      ADV_SUCCESS(1) - the request is in the mailbox
 *      ADV_BUSY(0) - total request count > 253, try later
 *      ADV_ERROR(-1) - invalid scsi request Q
 */
int
AdvExeScsiQueue(ASC_DVC_VAR WinBiosFar *asc_dvc,
                ASC_SCSI_REQ_Q dosfar *scsiq)
{
    if (scsiq == (ASC_SCSI_REQ_Q dosfar *) 0L)
    {
        /* 'scsiq' should never be NULL. */
        ADV_ASSERT(0);
        return ADV_ERROR;
    }

#if ADV_GETSGLIST
    if ((scsiq->sg_list_ptr) &&        /* there is a SG list to be done */
        (scsiq->sg_real_addr == 0L) &&
        (scsiq->data_cnt != 0) &&
        (AscGetSGList(asc_dvc, scsiq) == 0))
    {
        /* AscGetSGList() should never fail. */
        ADV_ASSERT(0);
        return ADV_ERROR;
    }
#endif /* ADV_GETSGLIST */

#if ADV_INITSCSITARGET
    if (scsiq->done_status != QD_DO_RETRY)
    {
        scsiq->error_retry = SCSI_MAX_RETRY;        /* set retry count */
    }
#endif /* ADV_INITSCSITARGET */

    return AscSendScsiCmd(asc_dvc, scsiq);
}

/*
 * Reset SCSI Bus and purge all outstanding requests.
 *
 * Return Value:
 *      ADV_TRUE(1) - All requests are purged and SCSI Bus is reset.
 *
 * Note: Should always return ADV_TRUE.
 */
int
AdvResetSB(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    int         status;

    status = AscSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_SCSI_RESET, 0L, 0);

    AscResetSCSIBus(asc_dvc);

    return status;
}
#endif /* ADV_OS_BIOS */

/*
 * Reset SCSI Bus and delay.
 */
void
AscResetSCSIBus(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr    iop_base;
    ushort      scsi_ctrl;

    iop_base = asc_dvc->iop_base;

    /*
     * The microcode currently sets the SCSI Bus Reset signal while
     * handling the AscSendIdleCmd() IDLE_CMD_SCSI_RESET command above.
     * But the SCSI Bus Reset Hold Time in the microcode is not deterministic
     * (it may in fact be for less than the SCSI Spec. minimum of 25 us).
     * Therefore on return the Adv Library sets the SCSI Bus Reset signal
     * for ASC_SCSI_RESET_HOLD_TIME_US, which is defined to be greater
     * than 25 us.
     */
    scsi_ctrl = AscReadWordRegister(iop_base, IOPW_SCSI_CTRL);
    AscWriteWordRegister(iop_base, IOPW_SCSI_CTRL,
        scsi_ctrl | ADV_SCSI_CTRL_RSTOUT);
    DvcDelayMicroSecond(asc_dvc, (ushort) ASC_SCSI_RESET_HOLD_TIME_US);
    AscWriteWordRegister(iop_base, IOPW_SCSI_CTRL,
        scsi_ctrl & ~ADV_SCSI_CTRL_RSTOUT);

    DvcSleepMilliSecond((ulong) asc_dvc->scsi_reset_wait * 1000);
}

#if ADV_GETSGLIST
/*
 * Set up the SG List for a request
 * Return:
 *      ADV_SUCCESS(1) - SG List successfully created
 *      ADV_ERROR(-1) - SG List creation failed
 */
int
AscGetSGList(ASC_DVC_VAR WinBiosFar *asc_dvc,
             ASC_SCSI_REQ_Q dosfar *scsiq)
{
    ulong               xfer_len, virtual_addr;
    long                sg_list_len;            /* size of the SG list buffer */
    ASC_SG_BLOCK dosfar *sg_block;              /* virtual address of a SG */
    ulong               sg_block_next_addr;     /* block and its next */
    long                sg_count;
    ulong               sg_block_page_boundary; /* page boundary break */
    ulong               sg_block_physical_addr;
    int                 sg_block_index, i;      /* how many SG entries */

    sg_block = scsiq->sg_list_ptr;
    sg_block_next_addr = (ulong) sg_block;    /* allow math operation */
    sg_list_len = ADV_SG_LIST_MAX_BYTE_SIZE;
    sg_block_physical_addr = DvcGetPhyAddr(asc_dvc, scsiq,
        (uchar dosfar *) scsiq->sg_list_ptr, (long dosfar *) &sg_list_len,
        ADV_IS_SGLIST_FLAG);
    ADV_ASSERT(ADV_DWALIGN(sg_block_physical_addr) == sg_block_physical_addr);
    if (sg_list_len < sizeof(ASC_SG_BLOCK))
    {
        /* The caller should always provide enough contiguous memory. */
        ADV_ASSERT(0);
        return ADV_ERROR;
    }
    scsiq->sg_real_addr = sg_block_physical_addr;

    virtual_addr = scsiq->vdata_addr;
    xfer_len = scsiq->data_cnt;
    sg_block_index = 0;
    do
    {
        sg_block_page_boundary = (ulong) sg_block + sg_list_len;
        sg_block->first_entry_no = (UCHAR)sg_block_index;
        for (i = 0; i < NO_OF_SG_PER_BLOCK; i++)
        {
            sg_count = xfer_len; /* Set maximum request length. */
            sg_block->sg_list[i].sg_addr =
              DvcGetPhyAddr(asc_dvc, scsiq,
                  (uchar dosfar *) virtual_addr, &sg_count,
                  ADV_ASCGETSGLIST_VADDR | ADV_IS_DATA_FLAG);
#ifdef ADV_OS_WIN95
            if (sg_block->sg_list[i].sg_addr < 0x1000)
            {
                return ADV_ERROR;
            }
#endif /* ADV_OS_WIN95 */
            if (sg_count > (long) xfer_len)    /* last sg entry */
            {
                sg_count = xfer_len;    /* yes, the last */
            }
            sg_block->sg_list[i].sg_count = sg_count;
            virtual_addr += sg_count;
            xfer_len -= sg_count;
            if (xfer_len <= 0)
            {    /* last entry, get out */
                scsiq->sg_entry_cnt = sg_block_index + i + 1;
                sg_block->last_entry_no = sg_block_index + i;
                sg_block->sg_ptr = 0L;    /* next link = NULL */
                return ADV_SUCCESS;
            }
        }    /* we have go thru 15 entries */
        /* get another SG block */
        sg_list_len -= sizeof(ASC_SG_BLOCK);
        if (sg_list_len >= 0)
        {
            sg_block_next_addr += sizeof(ASC_SG_BLOCK);
            sg_block_physical_addr += sizeof(ASC_SG_BLOCK);
        } else
        {   /* crossing page boundary */
            sg_block_next_addr = sg_block_page_boundary;
            sg_list_len = ADV_SG_LIST_MAX_BYTE_SIZE;
            sg_block_physical_addr = (ulong)
              DvcGetPhyAddr(asc_dvc, scsiq,
                  (uchar dosfar *) sg_block_next_addr, &sg_list_len,
                  ADV_IS_SGLIST_FLAG);
            ADV_ASSERT(ADV_DWALIGN(sg_block_physical_addr) ==
                       sg_block_physical_addr);
            if (sg_list_len < sizeof(ASC_SG_BLOCK))
            {
                /* The caller should always provide enough contiguous memory. */
                ADV_ASSERT(0);
                return ADV_ERROR;
            }
        }
        sg_block_index += NO_OF_SG_PER_BLOCK;
        sg_block->sg_ptr = (ASC_SG_BLOCK dosfar *) sg_block_physical_addr;
        sg_block->last_entry_no = sg_block_index - 1;
        sg_block = (ASC_SG_BLOCK *) sg_block_next_addr; /* virtual addr */
    }
    while (1);
    /* NOTREACHED */
}
#endif /* ADV_GETSGLIST */

#ifndef ADV_OS_BIOS
/*
 * Adv Library Interrupt Service Routine
 *
 *  This function is called by a driver's interrupt service routine.
 *  The function disables and re-enables interrupts.
 *
 *  When a microcode idle command is completed, the ASC_DVC_VAR
 *  'idle_cmd_done' field is set to ADV_TRUE.
 *
 *  Note: AdvISR() can be called when interrupts are disabled or even
 *  when there is no hardware interrupt condition present. It will
 *  always check for completed idle commands and microcode requests.
 *  This is an important feature that shoudln't be changed because it
 *  allows commands to be completed from polling mode loops.
 *
 * Return:
 *   ADV_TRUE(1) - interrupt was pending
 *   ADV_FALSE(0) - no interrupt was pending
 */
int
AdvISR(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr                    iop_base;
    uchar                       int_stat;
    ushort                      next_done_loc, target_bit;
    int                         completed_q;
#if ADV_CRITICAL
    int                         flags;
#endif /* ADV_CRITICAL */
    ASC_SCSI_REQ_Q dosfar       *scsiq;
    ASC_REQ_SENSE dosfar        *sense_data;
    int                         ret;
#if ADV_INITSCSITARGET
    int                         retry;
    uchar                       sense_key, sense_code;
#endif /* ADV_INITSCSITARGET */

#if ADV_CRITICAL
    flags = DvcEnterCritical();
#endif /* ADV_CRITICAL */

    iop_base = asc_dvc->iop_base;

    if (AdvIsIntPending(iop_base))
    {
        ret = ADV_TRUE;
    } else
    {
        ret = ADV_FALSE;
    }

    /* Reading the register clears the interrupt. */
    int_stat = AscReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);

    if (int_stat & ADV_INTR_STATUS_INTRB)
    {
        asc_dvc->idle_cmd_done = ADV_TRUE;
    }

    /*
     * Notify the driver of a hardware detected SCSI Bus Reset.
     */
    if (int_stat & ADV_INTR_STATUS_INTRC)
    {
        if (asc_dvc->sbreset_callback != 0)
        {
            (*(ASC_SBRESET_CALLBACK) asc_dvc->sbreset_callback)(asc_dvc);
        }
    }

    /*
     * ASC_MC_HOST_NEXT_DONE (0x129) is actually the last completed RISC
     * Queue List request. Its forward pointer (RQL_FWD) points to the
     * current completed RISC Queue List request.
     */
    next_done_loc = ASC_MC_RISC_Q_LIST_BASE +
        (AscReadByteLram(iop_base, ASC_MC_HOST_NEXT_DONE) *
            ASC_MC_RISC_Q_LIST_SIZE) + RQL_FWD;

    completed_q = AscReadByteLram(iop_base, next_done_loc);

    /* Loop until all completed Q's are processed. */
    while (completed_q != ASC_MC_NULL_Q)
    {
        AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_DONE, completed_q);

        next_done_loc = ASC_MC_RISC_Q_LIST_BASE +
            (completed_q * ASC_MC_RISC_Q_LIST_SIZE);

        /*
         * Read the ASC_SCSI_REQ_Q virtual address pointer from
         * the RISC list entry. The microcode has changed the
         * ASC_SCSI_REQ_Q physical address to its virtual address.
         *
         * Refer to comments at the end of AscSendScsiCmd() for
         * more information on the RISC list structure.
         */
        {
            ushort lsw, msw;
            lsw = AscReadWordLram(iop_base, next_done_loc + RQL_PHYADDR);
            msw = AscReadWordLram(iop_base, next_done_loc + RQL_PHYADDR + 2);
#if ADV_BIG_ENDIAN
            scsiq = (ASC_SCSI_REQ_Q dosfar *)
                EndianSwap32Bit((((ulong) msw << 16) | lsw));
#else /* ADV_BIG_ENDIAN */
            scsiq = (ASC_SCSI_REQ_Q dosfar *) (((ulong) msw << 16) | lsw);
#endif /* ADV_BIG_ENDIAN */
        }
#if ADV_BIG_ENDIAN
        AdvAdjEndianScsiQ(scsiq);
        /*
         * Warning: The four fields in the scsiq structure data_addr,
         * data_cnt, sense_addr and srb_ptr have been changed to little
         * endian ordering.
         */
#endif /* ADV_BIG_ENDIAN */

        ADV_ASSERT(scsiq != NULL);
        target_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);

#if ADV_INITSCSITARGET
        retry = ADV_FALSE;
#endif /* ADV_INITSCSITARGET */

        /*
         * Clear request microcode control flag.
         */
        scsiq->cntl = 0;

        /*
         * Check Condition handling
         */
        if ((scsiq->done_status == QD_WITH_ERROR) &&
            (scsiq->scsi_status == SS_CHK_CONDITION) &&
            (sense_data = (ASC_REQ_SENSE dosfar *) scsiq->vsense_addr) != 0 &&
            (scsiq->orig_sense_len - scsiq->sense_len) >= ASC_MIN_SENSE_LEN)
        {
#if ADV_INITSCSITARGET
            sense_key = sense_data->sense_key;
            sense_code = sense_data->asc;
            switch(sense_key)
            {
                case SCSI_SENKEY_ATTENTION:
                    if (sense_code == SCSI_ASC_POWERUP)
                    {
                        retry = ADV_TRUE;
                    }
                    break;

                case SCSI_SENKEY_NOT_READY:
                    if ((sense_code == SCSI_ASC_NOTRDY) &&
                        (sense_data->ascq == SCSI_ASCQ_COMINGRDY))
                    {
                        /*
                         * If the device is "Coming Ready",
                         * then don't decrement 'error_retry'
                         * to try the command indefinitely.
                         */
                        retry = ADV_TRUE;
                    } else
                    {
                        if (sense_code != SCSI_ASC_NOMEDIA)
                        {
                            /*
                             * Perform at most one Start Motor command
                             * by checking whether 'error_retry' is at
                             * SCSI_MAX_RETRY.
                             *
                             * Note: One retry is burned here whether
                             * or not a Start Motor is done.
                             */
                            if ((scsiq->error_retry == SCSI_MAX_RETRY) &&
                                (asc_dvc->start_motor & target_bit))
                            {
                                scsiq->cntl |= ASC_MC_QC_START_MOTOR;
                            }
                            if (scsiq->error_retry > 0)
                            {
                                scsiq->error_retry--;
                                retry = ADV_TRUE;
                            }
                        }
                    }
                    break;

                case SCSI_SENKEY_MEDIUM_ERR:
                case SCSI_SENKEY_HW_ERR:
                    if (scsiq->error_retry > 0)
                    {
                        scsiq->error_retry--;
                        retry = ADV_TRUE;
                    }
                    break;

                case SCSI_SENKEY_NO_SENSE:
                case SCSI_SENKEY_BLANK:
                default:
                    /*
                     * Don't retry if the Sense Data has no Sense Key
                     * and the Sense Key is Blank Check.
                     */
                    break;
            } /* switch */
#endif /* ADV_INITSCSITARGET */
        }
        /*
         * If the command that completed was a SCSI INQUIRY and
         * LUN 0 was sent the command, then process the INQUIRY
         * command information for the device.
         */
        else if (scsiq->done_status == QD_NO_ERROR &&
                 scsiq->cdb[0] == SCSICMD_Inquiry &&
                 scsiq->target_lun == 0)
        {
            AdvInquiryHandling(asc_dvc, scsiq);
        }

        /* Change the RISC Queue List state to free. */
        AscWriteByteLram(iop_base, next_done_loc + RQL_STATE, ASC_MC_QS_FREE);

        /* Get the RISC Queue List forward pointer. */
        completed_q = AscReadByteLram(iop_base, next_done_loc + RQL_FWD);

#if ADV_INITSCSITARGET == 0
        /*
         * Notify the driver of the completed request by passing
         * the ASC_SCSI_REQ_Q pointer to its callback function.
         */
        ADV_ASSERT(asc_dvc->cur_host_qng > 0);
        asc_dvc->cur_host_qng--;
        scsiq->a_flag |= ADV_SCSIQ_DONE;
        (*(ASC_ISR_CALLBACK) asc_dvc->isr_callback)(asc_dvc, scsiq);
        /*
         * Note: After the driver callback function is called, 'scsiq'
         * can no longer be referenced.
         *
         * Fall through and continue processing other completed
         * requests...
         */
#else /* ADV_INITSCSITARGET == 0 */
        /*
         * Don't retry the command if driver sets ADV_DONT_RETRY flag
         * in the ASC_SCSI_REQ_Q 'a_flag' field.
         */
        if ((scsiq->a_flag & ADV_DONT_RETRY) == 0 && retry)
        {
            /*
             * The request needs to be retried.
             *
             * Depending on the ADV_POLL_REQUEST flag either return
             * QD_DO_RETRY status to the caller or retry the request.
             */
            if (scsiq->a_flag & ADV_POLL_REQUEST)
            {
                /*
                 * If ADV_POLL_REQUEST is set, the caller does not have an
                 * interrupt handler installed and is calling AdvISR()
                 * directly when it detects that an interrupt is pending,
                 * cf. AscScsiUrgentCmd().
                 *
                 * The caller is checking for 'scsiq' completion by polling
                 * the 'a_flag' field for the 'ADV_SCSIQ_DONE' flag and is
                 * responsible for retrying commands. After completion the
                 * caller must check scsiq 'done_status' for QD_DO_RETRY to
                 * determine whether the command should be re-issued.
                 */
                ADV_ASSERT(asc_dvc->cur_host_qng > 0);
                asc_dvc->cur_host_qng--;
                scsiq->a_flag |= ADV_SCSIQ_DONE;
                scsiq->done_status = QD_DO_RETRY;

               /*
                * Fall through and continue processing other completed
                * requests...
                */
            } else
            {
                /*
                 * If ADV_POLL_REQUEST is not set, then the caller has set
                 * an interrupt handler and is waiting for the request
                 * to completed via an interrupt. The caller is checking
                 * for the 'scsiq' completion by polling the 'a_flag' field
                 * for the 'ADV_SCSIQ_DONE' flag.
                 */
                ADV_ASSERT(asc_dvc->cur_host_qng > 0);
                asc_dvc->cur_host_qng--;

                /*
                 * Before re-issuing the command, restore the original
                 * data and sense buffer length and reset all status.
                 */
                scsiq->data_cnt = scsiq->orig_data_cnt;
                scsiq->sense_len = scsiq->orig_sense_len;
                scsiq->done_status = QD_DO_RETRY;
                scsiq->host_status = 0;
                scsiq->scsi_status = 0;

                /*
                 * If the command is re-issued successfully, then
                 * don't set 'a_flag' or 'done_status' yet for the 'scsiq'.
                 */
                if (AdvExeScsiQueue(asc_dvc, scsiq) != ADV_SUCCESS)
                {
                    /*
                     * Error re-issuing the command. Complete the 'scsiq'
                     * with an error in 'done_status'.
                     */
                    scsiq->a_flag |= ADV_SCSIQ_DONE;
                    scsiq->done_status = QD_WITH_ERROR;
                    if (asc_dvc->isr_callback != 0)
                    {
                        (*(ASC_ISR_CALLBACK)
                            asc_dvc->isr_callback)(asc_dvc, scsiq);
                    }
                    /*
                     * Note: After the driver callback function is called,
                     * 'scsiq' can no longer be referenced.
                     */
                }

                /*
                 * Fall through and continue processing other completed
                 * requests...
                 */
            }
        } else
        {
            ADV_ASSERT(asc_dvc->cur_host_qng > 0);
            asc_dvc->cur_host_qng--;
            scsiq->a_flag |= ADV_SCSIQ_DONE;
            if ((scsiq->a_flag & ADV_POLL_REQUEST) == 0 &&
                asc_dvc->isr_callback != 0)
            {
                (*(ASC_ISR_CALLBACK) asc_dvc->isr_callback)(asc_dvc, scsiq);
            }
            /*
             * Note: After the driver callback function is called, 'scsiq'
             * can no longer be referenced.
             *
             * Fall through and continue processing other completed
             * requests...
             */
        }
#endif /* ADV_INITSCSITARGET == 0 */
#if ADV_CRITICAL
        /*
         * Disable interrupts again in case the driver inadvertenly
         * enabled interrupts in its callback function.
         *
         * The DvcEnterCritical() return value is ignored, because
         * the 'flags' saved when AdvISR() was first entered will be
         * used to restore the interrupt flag on exit.
         */
        (void) DvcEnterCritical();
#endif /* ADV_CRITICAL */
    }
#if ADV_CRITICAL
    DvcLeaveCritical(flags);
#endif /* ADV_CRITICAL */
    return ret;
}

/*
 * Send an idle command to the chip and wait for completion.
 *
 * Interrupts do not have to be enabled on entry.
 *
 * Return Values:
 *   ADV_TRUE - command completed successfully
 *   ADV_FALSE - command failed
 */
int
AscSendIdleCmd(ASC_DVC_VAR WinBiosFar *asc_dvc,
               ushort idle_cmd,
               ulong idle_cmd_parameter,
               int flags)
{
#if ADV_CRITICAL
    int         last_int_level;
#endif /* ADV_CRITICAL */
    ulong       i;
    PortAddr    iop_base;

    asc_dvc->idle_cmd_done = 0;

#if ADV_CRITICAL
    last_int_level = DvcEnterCritical();
#endif /* ADV_CRITICAL */
    iop_base = asc_dvc->iop_base;

    /*
     * Write the idle command value after the idle command parameter
     * has been written to avoid a race condition. If the order is not
     * followed, the microcode may process the idle command before the
     * parameters have been written to LRAM.
     */
    AscWriteDWordLram(iop_base, ASC_MC_IDLE_PARA_STAT, idle_cmd_parameter);
    AscWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);
#if ADV_CRITICAL
    DvcLeaveCritical(last_int_level);
#endif /* ADV_CRITICAL */

    /*
     * If the 'flags' argument contains the ADV_NOWAIT flag, then
     * return with success.
     */
    if (flags & ADV_NOWAIT)
    {
        return ADV_TRUE;
    }
    for (i = 0; i < SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++)
    {
        /*
         * 'idle_cmd_done' is set by AdvISR().
         */
        if (asc_dvc->idle_cmd_done)
        {
            break;
        }
        DvcSleepMilliSecond(1);

        /*
         * If interrupts were disabled on entry to AscSendIdleCmd(),
         * then they will still be disabled here. Call AdvISR() to
         * check for the idle command completion.
         */
        (void) AdvISR(asc_dvc);
    }

#if ADV_CRITICAL
    last_int_level = DvcEnterCritical();
#endif /* ADV_CRITICAL */

    if (asc_dvc->idle_cmd_done == ADV_FALSE)
    {
        ADV_ASSERT(0); /* The idle command should never timeout. */
        return ADV_FALSE;
    } else
    {
        return AscReadWordLram(iop_base, ASC_MC_IDLE_PARA_STAT);
    }
}

/*
 * Send the SCSI request block to the adapter
 *
 * Each of the 255 Adv Library/Microcode RISC Lists or mailboxes has the
 * following structure:
 *
 * 0: RQL_FWD - RISC list forward pointer (1 byte)
 * 1: RQL_BWD - RISC list backward pointer (1 byte)
 * 2: RQL_STATE - RISC list state byte - free, ready, done, aborted (1 byte)
 * 3: RQL_TID - request target id (1 byte)
 * 4: RQL_PHYADDR - ASC_SCSI_REQ_Q physical pointer (4 bytes)
 *
 * Return:
 *      ADV_SUCCESS(1) - the request is in the mailbox
 *      ADV_BUSY(0) - total request count > 253, try later
 */
int
AscSendScsiCmd(
    ASC_DVC_VAR WinBiosFar *asc_dvc,
    ASC_SCSI_REQ_Q dosfar  *scsiq)
{
    ushort                 next_ready_loc;
    uchar                  next_ready_loc_fwd;
#if ADV_CRITICAL
    int                    last_int_level;
#endif /* ADV_CRITICAL */
    PortAddr               iop_base;
    long                   req_size;
    ulong                  q_phy_addr;

    /*
     * The ASC_SCSI_REQ_Q 'target_id' field should never be equal
     * to the host adapter ID or exceed ASC_MAX_TID.
     */
    if ((scsiq->target_id == asc_dvc->chip_scsi_id)
        ||  scsiq->target_id > ASC_MAX_TID)
    {
        scsiq->host_status = QHSTA_M_INVALID_DEVICE;
        scsiq->done_status = QD_WITH_ERROR;
        return ADV_ERROR;
    }

    iop_base = asc_dvc->iop_base;

#if ADV_CRITICAL
    last_int_level = DvcEnterCritical();
#endif /* ADV_CRITICAL */

    if (asc_dvc->cur_host_qng >= asc_dvc->max_host_qng)
    {
#if ADV_CRITICAL
        DvcLeaveCritical(last_int_level);
#endif /* ADV_CRITICAL */
        return ADV_BUSY;
    } else
    {
        ADV_ASSERT(asc_dvc->cur_host_qng < ASC_MC_RISC_Q_TOTAL_CNT);
        asc_dvc->cur_host_qng++;
    }

    /*
     * Clear the ASC_SCSI_REQ_Q done flag.
     */
    scsiq->a_flag &= ~ADV_SCSIQ_DONE;

#if ADV_INITSCSITARGET
    /*
     * Save the original data buffer length for re-issuing the command
     * in the AdvISR().
     */
    scsiq->orig_data_cnt = scsiq->data_cnt;
#endif /* ADV_INITSCSITARGET */

    /*
     * Save the original sense buffer length.
     *
     * After the request completes 'sense_len' will be set to the residual
     * byte count of the Auto-Request Sense if a command returns CHECK
     * CONDITION and the Sense Data is valid indicated by 'host_status' not
     * being set to QHSTA_M_AUTO_REQ_SENSE_FAIL. To determine the valid
     * Sense Data Length subtract 'sense_len' from 'orig_sense_len'.
     */
    scsiq->orig_sense_len = scsiq->sense_len;

    next_ready_loc = ASC_MC_RISC_Q_LIST_BASE +
        (AscReadByteLram(iop_base, ASC_MC_HOST_NEXT_READY) *
            ASC_MC_RISC_Q_LIST_SIZE);

    /*
     * Write the physical address of the Q to the mailbox.
     * We need to skip the first four bytes, because the microcode
     * uses them internally for linking Q's together.
     */
    req_size = sizeof(ASC_SCSI_REQ_Q);
    q_phy_addr = DvcGetPhyAddr(asc_dvc, scsiq,
        (uchar dosfar *) scsiq, &req_size, ADV_IS_SCSIQ_FLAG);

    ADV_ASSERT(ADV_DWALIGN(q_phy_addr) == q_phy_addr);
    ADV_ASSERT(req_size >= sizeof(ASC_SCSI_REQ_Q));

    scsiq->scsiq_ptr = (ASC_SCSI_REQ_Q dosfar *) scsiq;

#if ADV_BIG_ENDIAN
    AdvAdjEndianScsiQ(scsiq);
    /*
     * Warning: The four fields in the scsiq structure data_addr,
     * data_cnt, sense_addr and srb_ptr have been changed to little
     * endian ordering.
     */
#endif /* ADV_BIG_ENDIAN */

    /*
     * The RISC list structure, which 'next_ready_loc' is a pointer
     * to in microcode LRAM, has the format detailed in the comment
     * header for this function.
     *
     * Write the ASC_SCSI_REQ_Q physical pointer to 'next_ready_loc' request.
     */
    AscWriteDWordLram(iop_base, next_ready_loc + RQL_PHYADDR, q_phy_addr);

    /* Write target_id to 'next_ready_loc' request. */
    AscWriteByteLram(iop_base, next_ready_loc + RQL_TID, scsiq->target_id);

    /*
     * Set the ASC_MC_HOST_NEXT_READY (0x128) microcode variable to
     * the 'next_ready_loc' request forward pointer.
     *
     * Do this *before* changing the 'next_ready_loc' queue to QS_READY.
     * After the state is changed to QS_READY 'RQL_FWD' will be changed
     * by the microcode.
     *
     * NOTE: The temporary variable 'next_ready_loc_fwd' is required to
     * prevent some compilers from optimizing out 'AscReadByteLram()' if
     * it were used as the 3rd argument to 'AscWriteByteLram()'.
     */
    next_ready_loc_fwd = AscReadByteLram(iop_base, next_ready_loc + RQL_FWD);
    AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_READY, next_ready_loc_fwd);

    /*
     * Change the state of 'next_ready_loc' request from QS_FREE to
     * QS_READY which will cause the microcode to pick it up and
     * execute it.
     *
     * Can't reference 'next_ready_loc' after changing the request
     * state to QS_READY. The microcode now owns the request.
     */
    AscWriteByteLram(iop_base, next_ready_loc + RQL_STATE, ASC_MC_QS_READY);

#if ADV_CRITICAL
    DvcLeaveCritical(last_int_level);
#endif /* ADV_CRITICAL */

    return ADV_SUCCESS;
}
#endif /* ADV_OS_BIOS */

/*
 * Inquiry Information Byte 7 Handling
 *
 * Handle SCSI Inquiry Command information for a device by setting
 * microcode operating variables that affect WDTR, SDTR, and Tag
 * Queuing.
 */
void
AdvInquiryHandling(
    ASC_DVC_VAR WinBiosFar      *asc_dvc,
    ASC_SCSI_REQ_Q dosfar       *scsiq)
{
    PortAddr                    iop_base;
    uchar                       tid;
    ASC_SCSI_INQUIRY dosfar    *inq;
    ushort                      tidmask;
    ushort                      cfg_word;

     /*
     * AdvInquiryHandling() requires up to INQUIRY information Byte 7
     * to be available.
     *
     * If less than 8 bytes of INQUIRY information were requested or less
     * than 8 bytes were transferred, then return. cdb[4] is the request
     * length and the ASC_SCSI_REQ_Q 'data_cnt' field is set by the
     * microcode to the transfer residual count.
     */

    if (scsiq->cdb[4] < 8 || (scsiq->cdb[4] - scsiq->data_cnt) < 8)
    {
        return;
    }

    iop_base = asc_dvc->iop_base;
    tid = scsiq->target_id;

    inq = (ASC_SCSI_INQUIRY dosfar *) scsiq->vdata_addr;

    /*
     * WDTR, SDTR, and Tag Queuing cannot be enabled for old devices.
     */
    if (inq->rsp_data_fmt < 2 && inq->ansi_apr_ver < 2)
    {
        return;
    } else
    {
        /*
         * INQUIRY Byte 7 Handling
         *
         * Use a device's INQUIRY byte 7 to determine whether it
         * supports WDTR, SDTR, and Tag Queuing. If the feature
         * is enabled in the EEPROM and the device supports the
         * feature, then enable it in the microcode.
         */

        tidmask = ADV_TID_TO_TIDMASK(tid);

        /*
         * Wide Transfers
         *
         * If the EEPROM enabled WDTR for the device and the device
         * supports wide bus (16 bit) transfers, then turn on the
         * device's 'wdtr_able' bit and write the new value to the
         * microcode.
         */
        if ((asc_dvc->wdtr_able & tidmask) && inq->WBus16)
        {
            cfg_word = AscReadWordLram(iop_base, ASC_MC_WDTR_ABLE);
            if ((cfg_word & tidmask) == 0)
            {
                cfg_word |= tidmask;
                AscWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);

                /*
                 * Clear the microcode "WDTR negotiation" done indicator
                 * for the target to cause it to negotiate with the new
                 * setting set above.
                 */
                cfg_word = AscReadWordLram(iop_base, ASC_MC_WDTR_DONE);
                cfg_word &= ~tidmask;
                AscWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);
            }
        }

        /*
         * Synchronous Transfers
         *
         * If the EEPROM enabled SDTR for the device and the device
         * supports synchronous transfers, then turn on the device's
         * 'sdtr_able' bit. Write the new value to the microcode.
         */
        if ((asc_dvc->sdtr_able & tidmask) && inq->Sync)
        {
            cfg_word = AscReadWordLram(iop_base, ASC_MC_SDTR_ABLE);
            if ((cfg_word & tidmask) == 0)
            {
                cfg_word |= tidmask;
                AscWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);

                /*
                 * Clear the microcode "SDTR negotiation" done indicator
                 * for the target to cause it to negotiate with the new
                 * setting set above.
                 */
                cfg_word = AscReadWordLram(iop_base, ASC_MC_SDTR_DONE);
                cfg_word &= ~tidmask;
                AscWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);
            }
        }

#ifndef ADV_OS_BIOS
        /*
         * If the EEPROM enabled Tag Queuing for device and the
         * device supports Tag Queueing, then turn on the device's
         * 'tagqng_enable' bit in the microcode and set the microcode
         * maximum command count to the ASC_DVC_VAR 'max_dvc_qng'
         * value.
         *
         * Tag Queuing is disabled for the BIOS which runs in polled
         * mode and would see no benefit from Tag Queuing. Also by
         * disabling Tag Queuing in the BIOS devices with Tag Queuing
         * bugs will at least work with the BIOS.
         */
        if ((asc_dvc->tagqng_able & tidmask) && inq->CmdQue)
        {
            cfg_word = AscReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE);
            cfg_word |= tidmask;
            AscWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);

            AscWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,
                asc_dvc->max_dvc_qng);
        }
#endif /* ADV_OS_BIOS */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_init.c ===
/*
 * a_init.c - Adv Library Driver Initialization Source File
 *
 * Functions defined in this function are not used after driver
 * initialization.
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#include "a_ver.h"       /* Version */
#include "d_os_dep.h"    /* Driver */
#include "a_scsi.h"      /* SCSI */
#include "a_condor.h"    /* AdvanSys Hardware */
#include "a_advlib.h"    /* Adv Library */

/*
 * Define a 12-bit unique file id which may by used by a driver for
 * debugging or tracing purposes. Each C source file must define a
 * different value.
 */
#define ADV_FILE_UNIQUE_ID           0xAD1   /* Adv Library C Source File #1 */

extern ulong _adv_mcode_chksum;
extern ushort _adv_mcode_size;
extern uchar _adv_mcode_buf[];

/*
 * Default EEPROM Configuration.
 *
 * All drivers should use this structure to set the default EEPROM
 * configuration. The BIOS now uses this structure when it is built.
 * Additional structure information can be found in a_condor.h where
 * the structure is defined.
 */
ASCEEP_CONFIG
Default_EEPROM_Config = {
    ADV_EEPROM_BIOS_ENABLE,     /* cfg_msw */
    0x0000,                     /* cfg_lsw */
    0xFFFF,                     /* disc_enable */
    0xFFFF,                     /* wdtr_able */
    0xFFFF,                     /* sdtr_able */
    0xFFFF,                     /* start_motor */
    0xFFFF,                     /* tagqng_able */
    0xFFFF,                     /* bios_scan */
    0,                          /* scam_tolerant */
    7,                          /* adapter_scsi_id */
    0,                          /* bios_boot_delay */
    3,                          /* scsi_reset_delay */
    0,                          /* bios_id_lun */
    0,                          /* termination */
    0,                          /* reserved1 */
    0xFFE7,                     /* bios_ctrl */
    0xFFFF,                     /* ultra_able */
    0,                          /* reserved2 */
    ASC_DEF_MAX_HOST_QNG,       /* max_host_qng */
    ASC_DEF_MAX_DVC_QNG,        /* max_dvc_qng */
    0,                          /* dvc_cntl */
    0,                          /* bug_fix */
    0,                          /* serial_number_word1 */
    0,                          /* serial_number_word2 */
    0,                          /* serial_number_word3 */
    0,                          /* check_sum */
    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, /* oem_name[16] */
    0,                          /* dvc_err_code */
    0,                          /* adv_err_code */
    0,                          /* adv_err_addr */
    0,                          /* saved_dvc_err_code */
    0,                          /* saved_adv_err_code */
    0,                          /* saved_adv_err_addr */
    0                           /* num_of_err */
};

/*
 * Initialize the ASC_DVC_VAR structure.
 *
 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 */
int
AdvInitGetConfig(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    ushort      warn_code;
    PortAddr    iop_base;
#ifndef ADV_OS_MAC
    uchar       pci_cmd_reg;
#endif /* ADV_OS_MAC */
    int         status;

    warn_code = 0;
    asc_dvc->err_code = 0;
    iop_base = asc_dvc->iop_base;

    /*
     * PCI Command Register
     */
#ifndef ADV_OS_MAC
    if (((pci_cmd_reg = DvcReadPCIConfigByte(asc_dvc,
                            AscPCIConfigCommandRegister))
         & AscPCICmdRegBits_BusMastering)
        != AscPCICmdRegBits_BusMastering)
    {
        pci_cmd_reg |= AscPCICmdRegBits_BusMastering;

        DvcWritePCIConfigByte(asc_dvc,
                AscPCIConfigCommandRegister, pci_cmd_reg);

        if (((DvcReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister))
             & AscPCICmdRegBits_BusMastering)
            != AscPCICmdRegBits_BusMastering)
        {
            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
        }
    }

    /*
     * PCI Latency Timer
     *
     * If the "latency timer" register is 0x20 or above, then we don't need
     * to change it.  Otherwise, set it to 0x20 (i.e. set it to 0x20 if it
     * comes up less than 0x20).
     */
    if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20) {
        DvcWritePCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer, 0x20);
        if (DvcReadPCIConfigByte(asc_dvc, AscPCIConfigLatencyTimer) < 0x20)
        {
            warn_code |= ASC_WARN_SET_PCI_CONFIG_SPACE;
        }
    }
#endif /* ADV_OS_MAC */
    /*
     * Save the state of the PCI Configuration Command Register
     * "Parity Error Response Control" Bit. If the bit is clear (0),
     * in AdvInitAsc3550Driver() tell the microcode to ignore DMA
     * parity errors.
     */
    asc_dvc->cfg->control_flag = 0;
#ifndef ADV_OS_MAC
    if (((DvcReadPCIConfigByte(asc_dvc, AscPCIConfigCommandRegister)
         & AscPCICmdRegBits_ParErrRespCtrl)) == 0)
    {
        asc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;
    }
#endif /* ADV_OS_MAC */
    asc_dvc->cur_host_qng = 0;

    asc_dvc->cfg->lib_version = (ASC_LIB_VERSION_MAJOR << 8) |
      ASC_LIB_VERSION_MINOR;
    asc_dvc->cfg->chip_version =
      AdvGetChipVersion(iop_base, asc_dvc->bus_type);

    /*
     * Reset the chip to start and allow register writes.
     */
    if (AdvFindSignature(iop_base) == 0)
    {
        asc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;
        return ADV_ERROR;
    }
    else {

        AdvResetChip(asc_dvc);

        if ((status = AscInitFromEEP(asc_dvc)) == ADV_ERROR)
        {
            return ADV_ERROR;
        }
        warn_code |= status;

        /*
         * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus
         * Resets should be performed.
         */
        if (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS)
        {
            AscResetSCSIBus(asc_dvc);
        }
    }

    return warn_code;
}

/*
 * Initialize the ASC3550.
 *
 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 */
int
AdvInitAsc3550Driver(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr    iop_base;
    ushort      warn_code;
    ulong       sum;
    int         begin_addr;
    int         end_addr;
    int         code_sum;
    int         word;
    int         rql_addr;                   /* RISC Queue List address */
#if ADV_UCODEDEFAULT
    int         tid;
#endif /* ADV_UCODEDEFAULT */
    int         i;
    ushort      scsi_cfg1;
    uchar       biosmem[ASC_MC_BIOSLEN];    /* BIOS RISC Memory 0x40-0x8F. */

    /* If there is already an error, don't continue. */
    if (asc_dvc->err_code != 0)
    {
        return ADV_ERROR;
    }

    warn_code = 0;
    iop_base = asc_dvc->iop_base;

#if ADV_SCAM
    /*
     * Perform SCAM
     */
    if (!(asc_dvc->bios_ctrl & BIOS_CTRL_NO_SCAM))
    {
        AscSCAM(asc_dvc);
    }
#endif /* ADV_SCAM */

    /*
     * Save the RISC memory BIOS region before writing the microcode.
     * The BIOS may already be loaded and using its RISC LRAM region
     * so its region must be saved and restored.
     *
     * Note: This code makes the assumption, which is currently true,
     * that a chip reset does not clear RISC LRAM.
     */
    for (i = 0; i < ASC_MC_BIOSLEN; i++)
    {
        biosmem[i] = AscReadByteLram(iop_base, ASC_MC_BIOSMEM + i);
    }

    /*
     * Load the Microcode
     *
     * Write the microcode image to RISC memory starting at address 0.
     */
    AscWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
    for (word = 0; word < _adv_mcode_size; word += 2)
    {
#if ADV_BIG_ENDIAN
        outpw_noswap(iop_base, *((ushort *) (&_adv_mcode_buf[word])));
#else /* ADV_BIG_ENDIAN */
        AscWriteWordAutoIncLram(iop_base,
            *((ushort *) (&_adv_mcode_buf[word])));
#endif /* ADV_BIG_ENDIAN */
    }

    /*
     * Clear the rest of Condor's Internal RAM (8KB).
     */
    for (; word < ADV_CONDOR_MEMSIZE; word += 2)
    {
        AscWriteWordAutoIncLram(iop_base, 0);
    }

    /*
     * Verify the microcode checksum.
     */
    sum = 0;
    AscWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);
    for (word = 0; word < _adv_mcode_size; word += 2)
    {
        sum += AscReadWordAutoIncLram(iop_base);
    }

    if (sum != _adv_mcode_chksum)
    {
        asc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;
        return ADV_ERROR;
    }

    /*
     * Restore the RISC memory BIOS region.
     */
    for (i = 0; i < ASC_MC_BIOSLEN; i++)
    {
        AscWriteByteLram(iop_base, ASC_MC_BIOSMEM + i, biosmem[i]);
    }

    /*
     * Calculate and write the microcode code checksum to the microcode
     * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).
     */
    begin_addr = AscReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR);
    end_addr = AscReadWordLram(iop_base, ASC_MC_CODE_END_ADDR);
    code_sum = 0;
    for (word = begin_addr; word < end_addr; word += 2)
    {
#if ADV_BIG_ENDIAN
        code_sum += EndianSwap16Bit(*((ushort *) (&_adv_mcode_buf[word])));
#else /* ADV_BIG_ENDIAN */
        code_sum += *((ushort *) (&_adv_mcode_buf[word]));
#endif /* ADV_BIG_ENDIAN */
    }
    AscWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);

    /*
     * Read microcode version and date.
     */
    asc_dvc->cfg->mcode_date =
        AscReadWordLram(iop_base, ASC_MC_VERSION_DATE);

    asc_dvc->cfg->mcode_version =
        AscReadWordLram(iop_base, ASC_MC_VERSION_NUM);

    /*
     * Initialize microcode operating variables
     */
    AscWriteWordLram(iop_base, ASC_MC_ADAPTER_SCSI_ID,
                       asc_dvc->chip_scsi_id);

    /*
     * If the PCI Configuration Command Register "Parity Error Response
     * Control" Bit was clear (0), then set the microcode variable
     * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode
     * to ignore DMA parity errors.
     */
    if (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR)
    {
        /*
         * Note: Don't remove the use of a temporary variable in
         * the following code, otherwise the Microsoft C compiler
         * will turn the following lines into a no-op.
         */
        word = AscReadWordLram(iop_base, ASC_MC_CONTROL_FLAG);
        word |= CONTROL_FLAG_IGNORE_PERR;
        AscWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);
    }

    /*
     * Set default microcode operating variables for WDTR, SDTR, and
     * command tag queuing based on the EEPROM configuration values.
     *
     * These ASC_DVC_VAR fields and the microcode variables will be
     * changed in AdvInquiryHandling() if it is found a device is
     * incapable of a particular feature.
     */

#if ADV_UCODEDEFAULT
    /*
     * Set microcode WDTR target mask.
     *
     * Set the mask value initially to zero. If the EEPROM has
     * enabled WDTR for a target, then WDTR for that target may
     * be enabled after an Inquiry command for the target completes.
     *
     * The microcode manages the handshake configuration table
     * ASC_MC_DEVICE_HSHK_CFG_TABLE (0x100) based on the 'wdtr_able'.
     *
     * Note: The microcode image defaults to a value of zero.
     */
     AscWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, 0);
#endif /* ADV_UCODEDEFAULT */

#if ADV_UCODEDEFAULT
    /*
     * Set microcode SDTR target mask.
     *
     * Set the mask value initially to zero. If the EEPROM has
     * enabled SDTR for a target, then SDTR for that target may
     * be enabled after an Inquiry command for the target completes.
     *
     * Note: The microcode image defaults to a value of zero.
     */
    AscWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, 0);
#endif /* ADV_UCODEDEFAULT */

    /*
     * Set the microcode ULTRA target mask from EEPROM value. The
     * SDTR target mask overrides the ULTRA target mask in the
     * microcode so it is safe to set this value without determining
     * whether the device supports SDTR.
     *
     * Note: There is no way to know whether a device supports ULTRA
     * speed without attempting a SDTR ULTRA speed negotiation with
     * the device. The device will reject the speed if it does not
     * support it by responding with an SDTR message containing a
     * slower speed.
     */
    AscWriteWordLram(iop_base, ASC_MC_ULTRA_ABLE, asc_dvc->ultra_able);
#if ADV_UCODEDEFAULT
    /*
     * Set microcode Tag Queuing target mask.
     *
     * Set the mask value initially to zero. If the EEPROM has
     * enabled Tag Queuing for a target, then Tag Queuing for
     * that target may be enabled after an Inquiry command for
     * the target completes.
     *
     * Note: The microcode image defaults to a value of zero.
     */
    AscWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, 0);
#endif /* ADV_UCODEDEFAULT */

#if ADV_UCODEDEFAULT
    /*
     * Initially set all device command limits to 1. As with the
     * microcode Tag Queuing target mask if the EEPROM has
     * enabled Tag Queuing for a target, then the command limit
     * may be increased an Inquiry command for the target completes.
     * Note: The microcode image defaults to a value of zero.
     */
    for (tid = 0; tid <= ASC_MAX_TID; tid++)
    {
        AscWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid, 1);
    }
#endif /* ADV_UCODEDEFAULT */

    AscWriteWordLram(iop_base, ASC_MC_DISC_ENABLE, asc_dvc->cfg->disc_enable);


    /*
     * Set SCSI_CFG0 Microcode Default Value.
     *
     * The microcode will set the SCSI_CFG0 register using this value
     * after it is started below.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,
        PARITY_EN | SEL_TMO_LONG | OUR_ID_EN | asc_dvc->chip_scsi_id);

    /*
     * Determine SCSI_CFG1 Microcode Default Value.
     *
     * The microcode will set the SCSI_CFG1 register using this value
     * after it is started below.
     */

    /* Read current SCSI_CFG1 Register value. */
    scsi_cfg1 = AscReadWordRegister(iop_base, IOPW_SCSI_CFG1);

    /*
     * If all three connectors are in use, return an error.
     */
    if ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||
        (scsi_cfg1 & CABLE_ILLEGAL_B) == 0)
    {
#ifdef ADV_OS_DOS
        /*
         * For the Manufacturing Test DOS ASPI ignore illegal use of
         * the three connectors.
         */
        if (!m_opt)
        {
#endif /* ADV_OS_DOS */
        asc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;
#ifdef ADV_OS_DIAG
        /*
         * If all three connectors are in use, then display
         * error information and exit.
         */
        cprintf("\r\n   All three connectors are in use .......................ILLEGAL\r\n");
        HaltSystem(illegalerr);
#endif /* ADV_OS_DIAG */
        return ADV_ERROR;
#ifdef ADV_OS_DOS
        }
#endif /* ADV_OS_DOS */
    }

#ifdef ADV_OS_DIAG
   /*
    * Display information about connectors.
    */
   cprintf("\r\n      Connector information:\r\n");
   if ((scsi_cfg1 & 0x02) == 0 ) /* 0x0D internal narrow */
   {
       cprintf("      Internal narrow connector is in use\r\n");
   }else
   {
       cprintf("      Internal narrow connector is free\r\n");
   }

   if ((scsi_cfg1 & 0x04 )== 0) /* 0x0B External narrow */
   {
       cprintf("      External narrow connector is in use\r\n");
   } else
   {
       cprintf("      External narrow connector is free\r\n");
   }

   if ((scsi_cfg1 & 0x01 )== 0) /* 0x0E internal wide */
   {
       cprintf("      Internal wide connector is in use\r\n");
   }else
   {
        cprintf("      Internal wide connector is free\r\n");
        wideconnectorfree = 1;
   }
#endif /* ADV_OS_DIAG */
    /*
     * If the internal narrow cable is reversed all of the SCSI_CTRL
     * register signals will be set. Check for and return an error if
     * this condition is found.
     */
    if ((AscReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07)
    {
        asc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;
        return ADV_ERROR;
    }

    /*
     * If this is a differential board and a single-ended device
     * is attached to one of the connectors, return an error.
     */
    if ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0)
    {
        asc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;
        return ADV_ERROR;
    }

    /*
     * If automatic termination control is enabled, then set the
     * termination value based on a table listed in a_condor.h.
     *
     * If manual termination was specified with an EEPROM setting
     * then 'termination' was set-up in AscInitFromEEPROM() and
     * is ready to be 'ored' into SCSI_CFG1.
     */
    if (asc_dvc->cfg->termination == 0)
    {
        /*
         * The software always controls termination by setting TERM_CTL_SEL.
         * If TERM_CTL_SEL were set to 0, the hardware would set termination.
         */
        asc_dvc->cfg->termination |= TERM_CTL_SEL;

        switch(scsi_cfg1 & CABLE_DETECT)
        {
            /* TERM_CTL_H: on, TERM_CTL_L: on */
            case 0x3: case 0x7: case 0xB: case 0xD: case 0xE: case 0xF:
                asc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);
                break;

            /* TERM_CTL_H: on, TERM_CTL_L: off */
            case 0x1: case 0x5: case 0x9: case 0xA: case 0xC:
                asc_dvc->cfg->termination |= TERM_CTL_H;
                break;

            /* TERM_CTL_H: off, TERM_CTL_L: off */
            case 0x2: case 0x6:
                break;
        }
    }

    /*
     * Clear any set TERM_CTL_H and TERM_CTL_L bits.
     */
    scsi_cfg1 &= ~TERM_CTL;

    /*
     * Invert the TERM_CTL_H and TERM_CTL_L bits and then
     * set 'scsi_cfg1'. The TERM_POL bit does not need to be
     * referenced, because the hardware internally inverts
     * the Termination High and Low bits if TERM_POL is set.
     */
    scsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));

    /*
     * Set SCSI_CFG1 Microcode Default Value
     *
     * Set filter value and possibly modified termination control
     * bits in the Microcode SCSI_CFG1 Register Value.
     *
     * The microcode will set the SCSI_CFG1 register using this value
     * after it is started below.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,
                       FLTR_11_TO_20NS | scsi_cfg1);

#if ADV_UCODEDEFAULT
    /*
     * Set MEM_CFG Microcode Default Value
     *
     * The microcode will set the MEM_CFG register using this value
     * after it is started below.
     *
     * MEM_CFG may be accessed as a word or byte, but only bits 0-7
     * are defined.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,
                        BIOS_EN | RAM_SZ_8KB);
#endif /* ADV_UCODEDEFAULT */

    /*
     * Set SEL_MASK Microcode Default Value
     *
     * The microcode will set the SEL_MASK register using this value
     * after it is started below.
     */
    AscWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,
                        ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));

    /*
     * Link all the RISC Queue Lists together in a doubly-linked
     * NULL terminated list.
     *
     * Skip the NULL (0) queue which is not used.
     */
    for (i = 1, rql_addr = ASC_MC_RISC_Q_LIST_BASE + ASC_MC_RISC_Q_LIST_SIZE;
         i < ASC_MC_RISC_Q_TOTAL_CNT;
         i++, rql_addr += ASC_MC_RISC_Q_LIST_SIZE)
    {
        /*
         * Set the current RISC Queue List's RQL_FWD and RQL_BWD pointers
         * in a one word write and set the state (RQL_STATE) to free.
         */
        AscWriteWordLram(iop_base, rql_addr, ((i + 1) + ((i - 1) << 8)));
        AscWriteByteLram(iop_base, rql_addr + RQL_STATE, ASC_MC_QS_FREE);
    }

    /*
     * Set the Host and RISC Queue List pointers.
     *
     * Both sets of pointers are initialized with the same values:
     * ASC_MC_RISC_Q_FIRST(0x01) and ASC_MC_RISC_Q_LAST (0xFF).
     */
    AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_READY, ASC_MC_RISC_Q_FIRST);
    AscWriteByteLram(iop_base, ASC_MC_HOST_NEXT_DONE, ASC_MC_RISC_Q_LAST);

    AscWriteByteLram(iop_base, ASC_MC_RISC_NEXT_READY, ASC_MC_RISC_Q_FIRST);
    AscWriteByteLram(iop_base, ASC_MC_RISC_NEXT_DONE, ASC_MC_RISC_Q_LAST);

    /*
     * Finally, set up the last RISC Queue List (255) with
     * a NULL forward pointer.
     */
    AscWriteWordLram(iop_base, rql_addr, (ASC_MC_NULL_Q + ((i - 1) << 8)));
    AscWriteByteLram(iop_base, rql_addr + RQL_STATE, ASC_MC_QS_FREE);
#ifndef ADV_OS_MAC
    AscWriteByteRegister(iop_base, IOPB_INTR_ENABLES,
         (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
#endif /* ADV_OS_MAC */
    /*
     * Note: Don't remove the use of a temporary variable in
     * the following code, otherwise the Microsoft C compiler
     * will turn the following lines into a no-op.
     */
    word = AscReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR);
    AscWriteWordRegister(iop_base, IOPW_PC, word);

    /* finally, finally, gentlemen, start your engine */
    AscWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);

    return warn_code;
}

#if ADV_INITSCSITARGET
/*
 * Initialize SCSI target devices
 *
 * Returns two arrays: ASC_DVC_INQ_INFO and ASC_CAP_INFO_ARRAY. The
 * second array is optional.
 *
 * 'work_sp_buf' must point to enough space for a doubleword aligned
 * structure containing a ASC_SCSI_REQ_Q, ASC_SCSI_INQUIRY, and
 * ASC_REQ_SENSE structures.
 * Here's an example of a size definition that will guarantee enough
 * space for AdvInitScsiTarget()
 *
 * #define ADV_INITSCSITARGET_BUFFER_SIZE \
 *      (sizeof(ASC_SCSI_REQ_Q) + \
 *       sizeof(ASC_SCSI_INQUIRY) + \
 *       sizeof(ASC_REQ_SENSE) + \
 *       3 * (sizeof(ulong) - 1))
 *
 * If the ADV_SCAN_LUN flag is set in the 'cntl_flag' argument, LUN
 * scanning will be done.
 */
int
AdvInitScsiTarget(ASC_DVC_VAR WinBiosFar *asc_dvc,
                  ASC_DVC_INQ_INFO dosfar *target,
                  uchar dosfar *work_sp_buf,
                  ASC_CAP_INFO_ARRAY dosfar *cap_array,
                  ushort cntl_flag)
{
    int                         dvc_found;
    int                         sta;
    uchar                       tid, lun;
    uchar                       scan_tid;
#ifdef ADV_OS_BIOS
    uchar                       bios_tid;
#endif /* ADV_OS_BIOS */
    ASC_SCSI_REQ_Q dosfar       *scsiq;
    ASC_SCSI_INQUIRY dosfar     *inq;
    ASC_REQ_SENSE dosfar        *sense;
    ASC_CAP_INFO dosfar         *cap_info;
    uchar                       max_lun_scan;

    /* Align buffers on a double word boundary. */
    scsiq = (ASC_SCSI_REQ_Q dosfar *)
        ADV_DWALIGN(work_sp_buf);

    inq = (ASC_SCSI_INQUIRY dosfar *)
        ADV_DWALIGN((ulong) scsiq + sizeof(ASC_SCSI_REQ_Q));

    sense = (ASC_REQ_SENSE dosfar *)
        ADV_DWALIGN((ulong) inq + sizeof(ASC_SCSI_INQUIRY));

    for (tid = 0; tid <= ASC_MAX_TID; tid++)
    {
        for (lun = 0; lun <= ASC_MAX_LUN; lun++)
        {
            target->type[tid][lun] = SCSI_TYPE_NO_DVC;
        }
    }

    dvc_found = 0;
    if (cntl_flag & ADV_SCAN_LUN)
    {
        max_lun_scan = ASC_MAX_LUN;
    } else
    {
        max_lun_scan = 0;
    }

    for (tid = 0; tid <= ASC_MAX_TID; tid++)
    {
#ifdef ADV_OS_DOS
        /*
         * For the Manufacturing Test DOS ASPI only scan TIDs
         * 0, 1, and 2.
         */
        if (m_opt && tid > 2)
        {
            break;
        }
#endif /* ADV_OS_DOS */
        for (lun = 0; lun <= max_lun_scan; lun++)
        {
#ifdef ADV_OS_BIOS
            //
            // Default boot device is TID 0.
            //
            if ((bios_tid = (asc_dvc->cfg->bios_id_lun & ASC_MAX_TID)) == 0)
            {
                scan_tid = tid;
            } else
            {
                /*
                 * Re-order TID scanning so that the EEPROM
                 * specified bios_id_lun TID is scanned first.
                 * All other TIDs are moved down in the order
                 * by one.
                 */
                if (tid == 0)
                {
                    scan_tid = bios_tid; /* Scan 'bios_id_lun' TID first. */
                } else if (tid <= bios_tid)
                {
                    scan_tid = tid - 1;
                } else
                {
                    scan_tid = tid;
                }
            }
#else /* ADV_OS_BIOS */
            scan_tid = tid;
#endif /* !ADV_OS_BIOS */

            if (scan_tid == asc_dvc->chip_scsi_id)
            {
#ifdef ADV_OS_BIOS
                /*
                 * Indicate the chip SCSI ID to the BIOS scan function
                 * by passing the inquiry pointer as NULL.
                 */
                BIOSDispInquiry(scan_tid, (ASC_SCSI_INQUIRY dosfar *) NULL);
#endif /* ADV_OS_BIOS */
                continue;
            }

            scsiq->target_id = scan_tid;
            scsiq->target_lun = lun;

            if (cap_array != 0L)
            {
                /*
                 * ADV_CAPINFO_NOLUN indicates that 'cap_array'
                 * is not an ASC_CAP_INFO_ARRAY.
                 *
                 * Instead it is an array of ASC_CAP_INFO structures
                 * with ASC_MAX_TID elements which is much smaller
                 * than an ASC_CAP_INFO_ARRAY. The caller can provide
                 * a much smaller 'cap_array' buffer to
                 * AdvInitScsiTarget().
                 */
                if (cntl_flag & ADV_CAPINFO_NOLUN)
                {
                    cap_info = &((ASC_CAP_INFO dosfar *) cap_array)[scan_tid];
                } else
                {
                    cap_info = &cap_array->cap_info[scan_tid][lun];
                }
            } else
            {
                cap_info = (ASC_CAP_INFO dosfar *) 0L;
            }
#if (OS_UNIXWARE || OS_SCO_UNIX)
            sta = AdvInitPollTarget(asc_dvc, scsiq, inq, cap_info, sense);
#else
            sta = AscInitPollTarget(asc_dvc, scsiq, inq, cap_info, sense);
#endif

            if (sta == ADV_SUCCESS)
            {
#ifdef ADV_OS_BIOS
                if ((asc_dvc->cfg->bios_scan & ADV_TID_TO_TIDMASK(scan_tid))
                    == 0)
                {
                    break; /* Ignoring current TID; Try next TID. */
                } else
                {
#endif /* ADV_OS_BIOS */
                    dvc_found++;
                    target->type[scan_tid][lun] = inq->peri_dvc_type;
#ifdef ADV_OS_BIOS
                }
#endif /* ADV_OS_BIOS */
            } else
            {
#ifdef ADV_OS_DOS
                /*
                 * The manufacturing test needs to return immediately
                 * on any error.
                 */
                if (m_opt)
                {
                    return (dvc_found);
                }
#endif /* ADV_OS_DOS */
                break; /* TID/LUN Not Found; Try next TID. */
            }
        }
    }
#ifdef ADV_OS_MAC
    AscWriteByteRegister(asc_dvc->iop_base, IOPB_INTR_ENABLES,
                (ADV_INTR_ENABLE_HOST_INTR | ADV_INTR_ENABLE_GLOBAL_INTR));
#endif /* ADV_OS_MAC */
    return (dvc_found);
}

/*
 * Send initialization command to each target device
 *
 * Return Values:
 *   ADV_FALSE - inquiry failed for target
 *   ADV_SUCCESS - target found
 */
int
#if (OS_UNIXWARE || OS_SCO_UNIX)
AdvInitPollTarget(
#else
AscInitPollTarget(
#endif
                  ASC_DVC_VAR WinBiosFar *asc_dvc,
                  ASC_SCSI_REQ_Q dosfar *scsiq,
                  ASC_SCSI_INQUIRY dosfar *inq,
                  ASC_CAP_INFO dosfar *cap_info,
                  ASC_REQ_SENSE dosfar *sense)
{
    uchar       tid_no;
    uchar       dvc_type;
    int         support_read_cap;
#ifdef ADV_OS_BIOS
    uchar       status = ADV_SUCCESS;
#endif /* ADV_OS_BIOS */

    tid_no = scsiq->target_id;

    /*
     * Send an INQUIRY command to the device.
     */
    scsiq->cdb[0] = (uchar) SCSICMD_Inquiry;
    scsiq->cdb[1] = scsiq->target_lun << 5;        /* LUN */
    scsiq->cdb[2] = 0;
    scsiq->cdb[3] = 0;
    scsiq->cdb[4] = sizeof(ASC_SCSI_INQUIRY);
    scsiq->cdb[5] = 0;
    scsiq->cdb_len = 6;
    scsiq->sg_list_ptr = 0;             /* no sg work area */

    if (AscScsiUrgentCmd(asc_dvc, scsiq,
            (uchar dosfar *) inq, sizeof(ASC_SCSI_INQUIRY),
            (uchar dosfar *) sense, sizeof(ASC_REQ_SENSE)) != ADV_SUCCESS)
    {
        return ADV_FALSE;
    }

    dvc_type = inq->peri_dvc_type;

#ifdef ADV_OS_DIAG
     /*
      * check for narrow cable connected to wide device
      */
    if (wideconnectorfree == 1)
    {
        if (inq->WBus16 == 0x1)
        {
            cprintf("\r\n   Narrow cable connected to Wide device ..................ILLEGAL\r\n");
            return ADV_FALSE;
        }
    }
#endif /* ADV_OS_DIAG */
    if (inq->peri_qualifier == SCSI_QUAL_NODVC &&
        dvc_type == SCSI_TYPE_UNKNOWN)
    {
        return ADV_FALSE; /* TID/LUN not supported. */
    }

#if ADV_DISP_INQUIRY
    AscDispInquiry(tid_no, scsiq->target_lun, inq);
#endif /* ADV_DISP_INQUIRY */
#ifdef ADV_OS_BIOS
    BIOSDispInquiry(tid_no, inq);
#endif /* ADV_OS_BIOS */
#ifdef ADV_OS_DIAG
    DiagDispInquiry(tid_no, scsiq->target_lun, inq);
#endif /* ADV_OS_DIAG */


    /*
     * Only allow Start Motor and Read Capacity commands on certain
     * device types. Turn off the Start Motor bit for all other device
     * types.
     */
    if ((dvc_type != SCSI_TYPE_DASD)
        && (dvc_type != SCSI_TYPE_WORM)
        && (dvc_type != SCSI_TYPE_CDROM)
        && (dvc_type != SCSI_TYPE_OPTMEM))
    {
        asc_dvc->start_motor &= ~ADV_TID_TO_TIDMASK(tid_no);
        support_read_cap = ADV_FALSE;
    } else
    {
        support_read_cap = ADV_TRUE;
    }

    /*
     * Issue a Test Unit Ready.
     *
     * If the Test Unit Ready succeeds and a Read Capacity buffer
     * has been provided and the device supports the Read Capacity
     * command, then issue a Read Capacity.
     */
    scsiq->cdb[0] = (uchar) SCSICMD_TestUnitReady;
    scsiq->cdb[4] = 0;

    if ((AscScsiUrgentCmd(asc_dvc, scsiq,
            (uchar dosfar *) 0, 0,
            (uchar dosfar *) sense, sizeof(ASC_REQ_SENSE)) == ADV_SUCCESS)
        && (cap_info != 0L) && support_read_cap)
    {
        scsiq->cdb[0] = (uchar) SCSICMD_ReadCapacity;
        scsiq->cdb[6] = 0;
        scsiq->cdb[7] = 0;
        scsiq->cdb[8] = 0;
        scsiq->cdb[9] = 0;
        scsiq->cdb_len = 10;
        if (AscScsiUrgentCmd(asc_dvc, scsiq,
                (uchar dosfar *) cap_info, sizeof(ASC_CAP_INFO),
                (uchar dosfar *) sense, sizeof(ASC_REQ_SENSE)) != ADV_SUCCESS)
        {
#ifdef ADV_OS_BIOS
            status = ADV_ERROR; /* Read Capacity Failed. */
#endif /* ADV_OS_BIOS */
            cap_info->lba = 0L;
            cap_info->blk_size = 0x0000;
        }
    }
#ifdef ADV_OS_BIOS
    else
    {
        status = ADV_ERROR;     /* Test Unit Ready Failed. */
    }
    BIOSCheckControlDrive(asc_dvc, tid_no, inq, cap_info, status);
#endif /* ADV_OS_BIOS */
    return ADV_SUCCESS;
}

#ifndef ADV_OS_BIOS
/*
 * Set up an urgent SCSI request block and wait for completion.
 *
 * This routine currently is used during initialization.
 *
 * Return Values: ADV_SUCCESS/ADV_ERROR
 */
int
AscScsiUrgentCmd(ASC_DVC_VAR WinBiosFar *asc_dvc,
                 ASC_SCSI_REQ_Q dosfar *scsiq,
                 uchar dosfar *buf_addr, long buf_len,
                 uchar dosfar *sense_addr, long sense_len)
{
    long        phy_contig_len; /* physically contiguous length */

    scsiq->error_retry = SCSI_MAX_RETRY;

    /*
     * The 'cntl' flag may be modified, so initialize the value outside
     * of the retry loop.
     */
    scsiq->cntl = 0;

   /*
    * Wait for completion of the command.
    *
    * Don't do a driver callback. The caller of AscScsiUrgentCmd()
    * should handle return status not the driver callback function.
    */
    do
    {
        scsiq->a_flag |= ADV_POLL_REQUEST;

#ifdef ADV_OS_DOS
        /*
         * Set dos_ix to 0xFF for DOS ASPI to tell it this is a call
         * made during initialization.
         *
         * XXX - Instead of setting dos_ix DOS ASPI should set a global
         * variable when it is in initialization. The DOS ASPI driver
         * shouldn't depend on the Adv Library to tell it when inititialization
         * is being done.
         */
        scsiq->dos_ix = 0xFF;
#endif /* ADV_OS_DOS */

        scsiq->sg_entry_cnt = 0; /* No SG list. */
        scsiq->scsi_status = 0;
        scsiq->host_status = 0;
        scsiq->done_status = QD_NO_STATUS;
        scsiq->srb_ptr = (ulong) scsiq;

        /*
         * Set-up request data buffer.
         */
        if (buf_len != 0L)
        {
            /*
             * Save data buffer virtual address for possible use in AdvISR().
             */
            scsiq->vdata_addr = (ulong) buf_addr;

            /*
             * Set requested physically contiguous length. The returned
             * physically contiguous length will be set by DvcGetPhyAddr().
             */
            phy_contig_len = buf_len;

            scsiq->data_addr = DvcGetPhyAddr(asc_dvc,
                scsiq, buf_addr, (long WinBiosFar *) &phy_contig_len,
                ADV_IS_DATA_FLAG);
            ADV_ASSERT(phy_contig_len >= 0);

            /*
             * If the physically contiguous memory is greater than 'buf_len'
             * or the user has already built a scatter-gather list pointed
             * to by 'sg_real_addr', then set 'data_cnt' to 'buf_len'. It is
             * assumed the caller has created a valid scatter-gather list.
             */
            if (phy_contig_len >= buf_len || scsiq->sg_real_addr)
            {
                scsiq->data_cnt = buf_len;
            } else
            {
#if ADV_GETSGLIST
                /*
                 * Build a scatter-gather list for the request by calling
                 * AscGetSGList(). If AscGetSGList() fails set 'data_cnt' to
                 * 'phy_contig_len'.
                 *
                 * If the work area 'sg_list_ptr' is non-zero and AscGetSGList()
                 * succeeds set 'data_cnt' to the full buffer length. Otherwise
                 * truncate 'data_cnt' to the amount of physically contiguous
                 * memory.
                 */
                if (scsiq->sg_list_ptr && AscGetSGList(asc_dvc, scsiq))
                {
                    scsiq->data_cnt = buf_len;          /* full length */
                } else
#endif /* ADV_GETSGLIST */
                {
                    scsiq->data_cnt = phy_contig_len; /* truncate length */
                }
            }
        }
        else
        {
            scsiq->data_addr = scsiq->vdata_addr = 0L;
            scsiq->data_cnt = 0L;
        }

        /*
         * Set-up request sense buffer.
         */
        if (sense_len != 0)
        {
            scsiq->vsense_addr = (ulong) sense_addr;

            /*
             * Set requested physically contiguous length. The returned
             * physically contiguous length will be set by DvcGetPhyAddr().
             */
            phy_contig_len = sense_len;

            scsiq->sense_addr = DvcGetPhyAddr(asc_dvc,
                scsiq, sense_addr, (long WinBiosFar *) &phy_contig_len,
                ADV_IS_SENSE_FLAG);

            /*
             * If DvcGetPhyAddr() returned a physically contiguous length
             * less than 'sense_len', then set the data count to
             * 'phy_contig_len'.
             */
            ADV_ASSERT(phy_contig_len >= 0);
            ADV_ASSERT(sense_len <= 255);
            scsiq->sense_len = (uchar)
                ((phy_contig_len < sense_len) ? phy_contig_len : sense_len);
        } else
        {
            scsiq->sense_len = 0;
            scsiq->sense_addr = scsiq->vsense_addr = 0L;
        }

        if (AscSendScsiCmd(asc_dvc, scsiq) != ADV_SUCCESS)
        {
            /*
             * AscSendScsiCmd() should never fail in polled mode.
             * If it does fail, then set an error and break to cause
             * a return to the caller.
             */
            ADV_ASSERT(0);
            scsiq->done_status = QD_WITH_ERROR;
            break;
        }
        else
        {
            AscWaitScsiCmd(asc_dvc, scsiq);
            if (scsiq->done_status == QD_DO_RETRY)
            {
                /* Wait 100 ms before retrying the command. */
                DvcSleepMilliSecond(100);
            }
        }
    } while (scsiq->done_status == QD_DO_RETRY);
    scsiq->a_flag &= ~ADV_POLL_REQUEST;

    if (scsiq->done_status == QD_NO_ERROR)
    {
        return ADV_SUCCESS;
    } else
    {
        return ADV_ERROR;
    }
}

/*
 * Wait for request to complete up to 10 seconds.
 *
 * On return caller should refer to scsiq 'done_status' for
 * request completion status.
 */
void
AscWaitScsiCmd(ASC_DVC_VAR WinBiosFar *asc_dvc,
               ASC_SCSI_REQ_Q dosfar *scsiq)
{
    ulong       i;

    /*
     * Wait up to 60 seconds for the command to complete.
     *
     * A Start Unit command for some disk drives may take over
     * 30 seconds to complete.
     */
    for (i = 0; i < 6 * SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++)
    {
        /*
         * AdvISR() will set the 'scsiq' a_flag ADV_SCSIQ_DONE
         * flag when the request has been completed.
         */
        (void) AdvISR(asc_dvc);

        if (scsiq->a_flag & ADV_SCSIQ_DONE)
        {
            break;
        }
        DvcSleepMilliSecond(1);
    }

    /*
     * If the 'scsiq' a_flag ADV_SCSIQ_DONE is not set indicating
     * that the microcode has completed it, then abort the request
     * in the microcode and return. The abort operation will set
     * a scsiq 'done_status' error. If the abort fails set an error
     * here.
     */
    if ((scsiq->a_flag & ADV_SCSIQ_DONE) == 0)
    {
        ADV_ASSERT(0); /* The request should never timeout. */

        /*
         * Abort the request in the microcode.
         */
        AscSendIdleCmd(asc_dvc, (ushort) IDLE_CMD_ABORT,
                (ulong) scsiq, ADV_NOWAIT);

        /*
         * Wait for the microcode to acknowledge the abort.
         */
        for (i = 0; i < SCSI_WAIT_10_SEC * SCSI_MS_PER_SEC; i++)
        {
            /*
             * The ASC_DVC_VAR 'idle_cmd_done' field is set by AdvISR().
             */
            (void) AdvISR(asc_dvc);
            if (asc_dvc->idle_cmd_done == ADV_TRUE)
            {
                break;
            }
            DvcSleepMilliSecond(1);
        }

        /*
         * If the abort command was not acknowledged by the microcode,
         * then complete the request with an error.
         */
        if (asc_dvc->idle_cmd_done == ADV_FALSE)
        {
            ADV_ASSERT(0); /* Abort should never fail. */
            scsiq->done_status = QD_WITH_ERROR;
        }
    }
    return;
}
#endif /* ADV_OS_BIOS */
#endif /* ADV_INITSCSITARGET */

/*
 * Read the board's EEP