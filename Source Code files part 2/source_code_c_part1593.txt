ore releasing the spinlock so that a name
        // release done cannot free pAddrElement.
        //
        NBT_REFERENCE_ADDRESS (pAddrElement, REF_ADDR_NEW_CLIENT);

#ifndef VXD
        CTESpinFree(pAddrElement,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // check the shared access of the name - this check must be done
        // at Irl = 0, so no spin locks held
        //
        if (pIrp)
        {
            status = NTCheckSharedAccess (pContext, pIrp, (tADDRESSELE *)pNameAddr->pAddressEle);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        CTESpinLock(pAddrElement,OldIrq1);
#else
        //
        // For the Vxd, we don't allow multiple names in the local name table.
        // In NT, this is prevented on a per process basis by the Netbios
        // driver.  If the name is being deregistered (conflict) then allow
        // the client to reopen the name
        //
        if ( !(pNameAddr->NameTypeState & STATE_CONFLICT))
        {
            status = STATUS_UNSUCCESSFUL;
        }
#endif

        // multihomed hosts register the same unique name on several adapters.
        // NT DOES allow a client to share a unique name, so we must NOT
        // run this next code if the NT check has passed!!
        //
        if (!NT_SUCCESS(status))
        {
            //
            // if this is a unique name being registered on another adapter
            // then allow it to occur - the assumption is that the same
            // client is registering on more than one adapter all at once,
            // rather than two different clients.
            //
            if (NbtConfig.MultiHomed && (!(pNameAddr->AdapterMask & pContext->AdapterMask)))
            {
                status = STATUS_SUCCESS;
            }
            //
            // check if this is a client trying to add the permanent name,
            // since that name will fail the security check
            // We allow a single client to use the permanent name - since its
            // a unique name it will fail the Vxd check too.
            //
            else if (CTEMemEqu(&pNameAddr->Name[10], &pContext->MacAddress.Address[0], sizeof(tMAC_ADDRESS)))
            {
                // check if there is just one element on the client list.  If so
                // then the permanent name is not being used yet - i.e. it has
                // been opened once by the NBT code itself so the node will
                // answer Nodestatus requests to the name, but no client
                // has opened it yet
                //
                if (pAddrElement->ClientHead.Flink->Flink == &pAddrElement->ClientHead)
                {
                    status = STATUS_SUCCESS;
                }
            }
            else if ((pNameAddr->NameTypeState & STATE_CONFLICT))
            {
                // check if the name is in the process of being deregisterd -
                // STATE_CONFLICT - in this case allow it to carry on and take over
                // name.
                //
                status = STATUS_SUCCESS;
            }
        }

        if ((NT_SUCCESS(status)) &&
            (pNameAddr->NameTypeState & STATE_CONFLICT))
        {
            // this could either be a real conflict or a name being deleted on
            // the net, so stop any timer associated with the name release
            // and carry on
            //
            if (pTimer = pNameAddr->pTimer)
            {
                // this routine puts the timer block back on the timer Q, and
                // handles race conditions to cancel the timer when the timer
                // is expiring.
                pNameAddr->pTimer = NULL;
                status = StopTimer(pTimer,&pClientCompletion,&Context);

                // there is a client's irp waiting for the name release to finish
                // so complete that irp back to them
                if (pClientCompletion)
                {
                    //
                    // NOTE****
                    // We must clear the AdapterMask so that NameReleaseDone
                    // does not try to release the name on another net card
                    // for the multihomed case.
                    //
                    CHECK_PTR(pNameAddr);
                    CTESpinFree(pAddrElement,OldIrq1);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    (*pClientCompletion)(Context,STATUS_SUCCESS);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                    CTESpinLock(pAddrElement,OldIrq1);
                }
                CHECK_PTR(pNameAddr);
            }
            //
            // this allows another client to use a name almost immediately
            // after the first one releases the name on the net.  However
            // if the first client has not released the name yet, and is
            // still on the clienthead list, then the name will not be
            // reregistered, and this current registration will fail because
            // the name state is conflict. That check is done below.
            //
            if (IsListEmpty(&pAddrElement->ClientHead))
            {
                pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                pNameAddr->NameTypeState |= STATE_RESOLVED;
                status = STATUS_SUCCESS;
                MultiHomedReRegister = TRUE;

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtOpenAddress: Conflict State, re-registering name on net\n"));
            }
            else
            {
                // set status that indicates someone else has the name on the
                // network.
                //
                if (!IS_MESSENGER_NAME(pNameRslv))
                {
                    //
                    // We need to Q this event to a Worker thread since it
                    // requires the name to be converted to Unicode
                    //
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT);
                    status = CTEQueueForNonDispProcessing (DelayedNbtLogDuplicateNameEvent,
                                                           (PVOID) pNameAddr,
                                                           IntToPtr(IpAddress),
                                                           IntToPtr(0x106),
                                                           pContext,
                                                           TRUE);
                    if (!NT_SUCCESS(status))
                    {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, TRUE);
                        NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, IpAddress, 0x106);
                    }
                }
                status = STATUS_DUPLICATE_NAME;
            }
        }
        else if (NT_SUCCESS(status))
        {
            // name already exists - is open; allow only another client creating a
            // name of the same type
            //
            if ((uAddrType == NBT_UNIQUE) || ( uAddrType == NBT_QUICK_UNIQUE))
            {
                if (!(pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
                {
                    status = STATUS_SHARING_VIOLATION;
                }
            }
            else if (!(pNameAddr->NameTypeState & NAMETYPE_GROUP))
            {
                status = STATUS_SHARING_VIOLATION;
            }
        }
        else
        {
            status = STATUS_SHARING_VIOLATION;
        }

        // if everything is OK, create client block and link to addresslist
        // pass back the client block address as a handle for future reference
        // to the client
        if ((NT_SUCCESS(status)) &&
            (!(pClientEle = NbtAllocateClientBlock (pAddrElement, pContext))))
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // check for a failure, if so , then return
        //
        if (!NT_SUCCESS(status))
        {
            CHECK_PTR(pRequest);
            pRequest->Handle.AddressHandle = NULL;

            CTESpinFree(pAddrElement,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NBT_DEREFERENCE_ADDRESS (pAddrElement, REF_ADDR_NEW_CLIENT);
            CTEExReleaseResource(&NbtConfig.Resource);
            return(status);
        }

        // we need to track the Irp so that when the name registration
        // completes, we can complete the Irp.
        pClientEle->pIrp = pIrp;
        pClientEle->AddressType = TdiAddressType;

        pRequest->Handle.AddressHandle = (PVOID)pClientEle;

        // fill in the context values passed back to the client. These must
        // be done before the name is registered on the network because the
        // registration can succeed (or fail) before this routine finishes).
        // Since this routine can be called by NBT itself, there may not be an
        // irp to fill in, so check first.
        if (pIrp)
        {
#ifndef VXD
            NTSetFileObjectContexts( pClientEle->pIrp,(PVOID)pClientEle, (PVOID)(NBT_ADDRESS_TYPE));
#endif
        }

        //
        // See if this is not the first Client on this Device
        //
        pClientEntry = &pAddrElement->ClientHead;
        while ((pClientEntry = pClientEntry->Flink) != &pAddrElement->ClientHead)
        {
            pClientEleTemp = CONTAINING_RECORD (pClientEntry,tCLIENTELE,Linkage);
            if ((pClientEleTemp != pClientEle) &&
                (pClientEleTemp->pDeviceContext == pContext))
            {
                fFirstClientOnDevice = FALSE;
                break;
            }
        }

        if (fFirstClientOnDevice)
        {
            if (IsDeviceNetbiosless(pContext))
            {
                pNameAddr->NameFlags |= NAME_REGISTERED_ON_SMBDEV;
            }
            else
            {
                //
                // turn on the adapter's bit in the adapter Mask and set the
                // re-register flag (if the name is not resolving already) so
                // we register the name out the new adapter.
                //
                pNameAddr->AdapterMask |= pContext->AdapterMask;
                if (pNameAddr->NameTypeState & STATE_RESOLVED)
                {
                    MultiHomedReRegister = TRUE;
                }
            }
        }
        else
        {
            // the adapter bit is already on in the pAddressEle, so
            // this must be another client registering the same name,
            // therefore turn on the MultiClient boolean so that the DgramRcv
            // code will know to activate its multiple client rcv code.
            //
            pAddrElement->MultiClients = TRUE;
        }

        //
        // check the state of the entry in the table.  If the state is
        // resolved then complete the request now,otherwise we cannot complete
        // this request yet... i.e. we return Pending.
        //
        if (((pNameAddr->NameTypeState & STATE_RESOLVED) &&
            (!MultiHomedReRegister)))
        {
            // basically we are all done now, so just return status success
            // to the client
            //
            status = STATUS_SUCCESS;

            CHECK_PTR(pClientEle);
            pClientEle->pIrp = NULL;
            CTESpinFree(pAddrElement,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            pClientEle->WaitingForRegistration = FALSE;
        }
        else
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtOpenAddress: Waiting for prev registration- state=%x, ReRegister=%x\n",
                    pNameAddr->NameTypeState, MultiHomedReRegister));

            // we need to track the Irp so that when the name registration
            // completes, we can complete the Irp.
            pClientEle->pIrp = pIrp;

            CTESpinFree(pAddrElement,OldIrq1);
            if (MultiHomedReRegister)
            {
                // this flag is used by RegisterCompletion ( when true )
                pClientEle->WaitingForRegistration = FALSE;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtOpenAddress: Resolved State=%x, ReRegister=%x\n",
                        pNameAddr->NameTypeState, MultiHomedReRegister));

                // we need to re-register the name on the net because it is not
                // currently in the resolved state and there is no timer active
                // We do that by calling this routine with the IpAddress set to NULL
                // to signal that routine not to put the name in the hash table
                // since it is already there.
                //
                status = NbtRegisterName (NBT_LOCAL,
                                          0,        // set to zero to signify already in tbl
                                          pNameRslv,
                                          pNameAddr,
                                          pClientEle,
                                          (PVOID)NbtRegisterCompletion,
                                          uAddrType,
                                          pContext);

                if (!NT_SUCCESS(status))
                {
                    if (pIrp)
                    {
                        pClientEle->pIrp = NULL;
                        NTClearFileObjectContext(pIrp);
                    }

                    CTEExReleaseResource(&NbtConfig.Resource);
                    NBT_DEREFERENCE_CLIENT (pClientEle);
                    NbtTrace(NBT_TRACE_NAMESRV, ("Multi-homed re-register %!NBTNAME!<%02x> fails with %!status!",
                                        pNameRslv, (unsigned)pNameRslv[15], status));
                    return (status);
                } else {
                    NbtTrace(NBT_TRACE_NAMESRV, ("Client open address %!NBTNAME!<%02x> ClientEle=%p",
                                        pNameRslv, (unsigned)pNameRslv[15], pClientEle));
                }
            }
            else
            {
                NbtTrace(NBT_TRACE_NAMESRV, ("Client opent address %!NBTNAME!<%02x> ClientEle=%p waiting "
                                        "for multihomed re-registration",
                                    pNameRslv, (unsigned)pNameRslv[15], pClientEle));
                pClientEle->WaitingForRegistration = TRUE;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                // for multihomed, a second registration on a second adapter
                // at the same time as the first adapter is registering is
                // delayed until the first completes, then its registration
                // proceeds - See RegistrationCompletion below.
                //
                status = STATUS_PENDING;
            }
        }
    }

    CTEExReleaseResource(&NbtConfig.Resource);

#ifdef _PNP_POWER_
    //
    // See if we need to set the Wakeup pattern on this Device
    //
    if ((NT_SUCCESS(status)) &&
        (*pNameRslv != '*') &&
        (pNameRslv[NETBIOS_NAME_SIZE-1] == SPECIAL_SERVER_SUFFIX))
    {
        pContext->NumServers++;
        CheckSetWakeupPattern (pContext, pNameRslv, TRUE);
    }
#endif

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtRegisterCompletion(
    IN  tCLIENTELE *pClientEleIn,
    IN  NTSTATUS    status
    )

/*++

Routine Description

    This routine handles completing a name registration request. The namesrv.c
    Name server calls this routine when it has registered a name.  The address
    of this routine is passed to the Local Name Server in the NbtRegisterName
    request.

    The idea is to complete the irps that are waiting on the name registration,
    one per client element.

    When a DHCP reregister occurs there is no client irp so the name is
    not actually deleted from the table when a bad status is passed to this
    routine.  Hence the need for the DhcpRegister flag to change the code
    path for that case.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    LIST_ENTRY      *pHead;
    LIST_ENTRY      *pEntry;
    CTELockHandle   OldIrq;
    CTELockHandle   OldIrq1;
    tADDRESSELE     *pAddress;
    tDEVICECONTEXT  *pDeviceContext;
    tNAMEADDR       *pNameAddr;
    tCLIENTELE      *pClientEle;
    LIST_ENTRY      TempList;
    ULONG           Count=0;

    InitializeListHead(&TempList);

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    pAddress = pClientEleIn->pAddress;
    pDeviceContext = pClientEleIn->pDeviceContext;

    CTESpinLock(pAddress,OldIrq);

    // Several Clients can open the same address at the same time, so when the
    // name registration completes, it should complete all of them!!


    // increment the reference count so that the hash table entry cannot
    // disappear while we are using it.
    //
    NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_REG_COMPLETION);
    pNameAddr = pAddress->pNameAddr;

    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
    pNameAddr->pTimer = NULL;   // Bug #: 231693

    // if the registration failed or a previous registration failed for the
    // multihomed case, deny the client the name
    //
    if ((status == STATUS_SUCCESS) || (status == STATUS_TIMEOUT))
    {
        pNameAddr->NameTypeState |= STATE_RESOLVED;
    }
    else
    {
        pNameAddr->NameTypeState |= STATE_CONFLICT;
        pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
        status = STATUS_DUPLICATE_NAME;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // find all clients that are attached to the address and complete the
    // I/O requests, if they are on the same adapter that the name was
    // just registered against, if successful.  For failure cases complete
    // all irps with the failure code - i.e. failure to register a name on
    // one adapter fails all adapters.
    //
FailRegistration:
    pHead = &pAddress->ClientHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        // complete the I/O
        pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

        pEntry = pEntry->Flink;

        //
        // It is possible for the second registration  of a name to fail so
        // we do not want to attempt to return the irp on the first
        // registration, which has completed ok already.  Therefore
        // if the status is failure, then only complete those clients that
        // have the WaitingForReg... bit set
        //
        // if it is the client ele passed in, or one on the same device context
        // that is waiting for a name registration, or it is a failure...
        // AND the client IRP is still valid then return the Irp.
        //
        if ((pClientEle->pIrp) &&
            ((pClientEle == pClientEleIn) ||
             ((pClientEle->pDeviceContext == pDeviceContext) && (pClientEle->WaitingForRegistration)) ||
             ((status != STATUS_SUCCESS) && pClientEle->WaitingForRegistration)))
        {
            // for failed registrations, remove the client from the address list
            // since we are going to delete him below.
            if (!NT_SUCCESS(status))
            {
                // turn off the adapter bit so we know not to use this name with this
                // adapter - since it is a failure, turn off all adapter bits
                // since a single name registration failure means all registrations
                // fail.
                CHECK_PTR(pNameAddr);
                pNameAddr->AdapterMask = 0;

                // setting this to null prevents CloseAddress and CleanupAddress
                // from accessing pAddress and crashing.
                //
                CHECK_PTR(pClientEle);
                pClientEle->pAddress = NULL;

                // clear the ptr to the ClientEle that NbtRegisterName put into
                // the irp ( i.e. the context values are cleared )
                //
#ifndef VXD
                NTSetFileObjectContexts(pClientEle->pIrp,NULL,NULL);
#endif
                RemoveEntryList(&pClientEle->Linkage);
            }

            ASSERT(pClientEle->pIrp);

            pClientEle->WaitingForRegistration = FALSE;

#ifndef VXD
            // put all irps that have to be completed on a separate list
            // and then complete later after releaseing the spin lock.
            //
            InsertTailList(&TempList,&pClientEle->pIrp->Tail.Overlay.ListEntry);
#else
            //
            //  pAddress gets set in the name table for this NCB
            //
            Count++;
            CTESpinFree(pAddress,OldIrq1);
            CTEIoComplete( pClientEle->pIrp, status, (ULONG) pClientEle ) ;
            CTESpinLock(pAddress,OldIrq1);
#endif
            CHECK_PTR(pClientEle);
            pClientEle->pIrp = NULL ;

            // free the client object memory
            if (!NT_SUCCESS(status))
            {
                NbtFreeClientObj(pClientEle);
            }
        }
    }

    CTESpinFree(pAddress,OldIrq1);

#ifndef VXD
    //
    // for the NT case where MP - ness can disrupt the list at any
    // time, scan the whole list above without releasing the spin lock,
    // and then complete the irps collected here
    //
    while (!IsListEmpty(&TempList))
    {
        PIRP    pIrp;

        pEntry = RemoveHeadList(&TempList);
        pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

        CTEIoComplete(pIrp,status,0);
        Count++;
    }
#endif


    // if the registration failed, do one more dereference of the address
    // to remove the refcount added by this client.  This may cause a name
    // release on the network if there are no other clients registering
    // the name.
    //
    if (!NT_SUCCESS(status))
    {
        //
        // dereference the address the same number of times that we have
        // returned failed registrations since each reg. referenced pAddress
        // once
        //
        while (Count--)
        {
            NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_NEW_CLIENT);
        }
    }
    else
    {
        USHORT  uAddrType;

        CTESpinLock(pAddress,OldIrq1);

        // go through the clients and see if any are waiting to register
        // a name.  This happens in the multihomed case, but should not
        // happen in the single adapter case.
        //
        pHead = &pAddress->ClientHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            // complete the I/O
            pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

            pEntry = pEntry->Flink;

            if (pClientEle->WaitingForRegistration)
            {
                ULONG   SaveState;

                pClientEle->WaitingForRegistration = FALSE;

                if (pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
                {
                    uAddrType = NBT_UNIQUE;
                }
                else
                    uAddrType = NBT_GROUP;

                //
                // preserve the "QUICK"ness
                //
                if (pNameAddr->NameTypeState & NAMETYPE_QUICK)
                {
                    uAddrType |= NBT_QUICK_UNIQUE;
                }

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtRegisterCompletion: Registering next name state= %X,%15s<%X>\n",
                        pNameAddr->NameTypeState,pNameAddr->Name,pNameAddr->Name[15]));

                SaveState = pNameAddr->NameTypeState;

                CTESpinFree(pAddress,OldIrq1);

                // this may be a multihomed host, with another name registration
                // pending out another adapter, so start that registration.
                status = NbtRegisterName (NBT_LOCAL,
                                          0,        // set to zero to signify already in tbl
                                          pNameAddr->Name,
                                          pNameAddr,
                                          pClientEle,
                                          (PVOID)NbtRegisterCompletion,
                                          uAddrType,
                                          pClientEle->pDeviceContext);

                CTESpinLock(pAddress,OldIrq1);

                // since nbtregister will set the state to Resolving, when
                // it might be resolved already on one adapter.
                pNameAddr->NameTypeState = SaveState;
                if (!NT_SUCCESS(status))
                {
                    // if this fails for some reason, then fail any other name
                    // registrations pending. - the registername call should not
                    // fail unless we are out of resources.
                    pClientEle->WaitingForRegistration = TRUE;
                    goto FailRegistration;
                }
                // just register one name at a time, unless we get immediate success
                else if (status == STATUS_PENDING)
                {
                    break;
                }
                else    // SUCCESS
                {
                    CTESpinFree(pAddress,OldIrq1);
                    CTEIoComplete(pClientEle->pIrp,status,0);
                    pClientEle->pIrp = NULL;
                    CTESpinLock(pAddress,OldIrq1);
                }
            }
        }
        CTESpinFree(pAddress,OldIrq1);

    }

    if (!NT_SUCCESS(status))
    {
        //
        // Go through all the Clients still attached, and reset their
        // AdapterMasks since we could have removed them
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        CTESpinLock(pAddress,OldIrq1);

        pEntry = pHead = &pAddress->ClientHead;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            pClientEle = CONTAINING_RECORD (pEntry,tCLIENTELE,Linkage);
            if (!IsDeviceNetbiosless(pClientEle->pDeviceContext))
            {
                pNameAddr->AdapterMask |= pClientEle->pDeviceContext->AdapterMask;
            }
        }

        CTESpinFree(pAddress,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    // this decrements for the RefCount++ done in this routine.
    NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_REG_COMPLETION);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtOpenConnection(
    IN  TDI_REQUEST         *pRequest,
    IN  CONNECTION_CONTEXT  ConnectionContext,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description

    This routine handles creating a connection object for the client.  It
    passes back a ptr to the connection so that OS specific portions of the
    data structure can be filled in.

Arguments:


Return Values:

    pConnectEle - ptr to the allocated connection data structure
    TDI_STATUS - status of the request

--*/
{
    NTSTATUS            status = STATUS_SUCCESS ;
    tCONNECTELE         *pConnEle;

    CTEPagedCode();

    // Acquire this resource to co-ordinate with DHCP changing the IP address
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

    if ((!pDeviceContext->pSessionFileObject) ||
        (!(pConnEle = (tCONNECTELE *)NbtAllocMem(sizeof(tCONNECTELE),NBT_TAG('D')))))
    {
        CTEExReleaseResource(&NbtConfig.Resource);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtOpenConnection: pConnEle = <%x>\n",pConnEle));

    // This ensures that all BOOLEAN values begin with a FALSE value among other things.
    CTEZeroMemory(pConnEle,sizeof(tCONNECTELE));
    CTEInitLock(&pConnEle->LockInfo.SpinLock);
#if DBG
    pConnEle->LockInfo.LockNumber = CONNECT_LOCK;
#endif
    // initialize lists to empty
    InitializeListHead(&pConnEle->RcvHead);

    pConnEle->Verify = NBT_VERIFY_CONNECTION;
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_CREATE); // so we don't delete the connection
    SET_STATE_UPPER (pConnEle, NBT_IDLE);
    pConnEle->pDeviceContext = pDeviceContext;
    pConnEle->ConnectContext = ConnectionContext;   // used in various event calls (eg. Receive, Disconnect)

    //
    // for each connection the client(s) open, open a connection to the transport
    // so that we can accept one to one from the transport.
#ifndef VXD
    //
    // Allocate an MDL to be used for partial Mdls
    // The length of the Mdl is set to 64K(MAXUSHORT) so that there are enough
    // pfns in the  Mdl to map a large buffer.
    //
    // use pConnEle as the Virtual address, since it doesn't matter
    // because it will be overwritten when the partial Mdl is created.
    //
    if (pConnEle->pNewMdl = IoAllocateMdl ((PVOID)pConnEle, MAXUSHORT, FALSE, FALSE, NULL))
#endif
    {
        //
        // allocate memory for the lower connection block.
        //
        status = NbtOpenAndAssocConnection(pDeviceContext, NULL, NULL, '2');
        if (NT_SUCCESS(status))
        {
            // link on to list of open connections for this device so that we
            // know how many open connections there are at any time (if we need to know)
            // This linkage is only in place until the client does an associate, then
            // the connection is unlinked from here and linked to the client ConnectHead.
            //
            ExInterlockedInsertHeadList(&pDeviceContext->UpConnectionInUse,
                                        &pConnEle->Linkage,
                                        &NbtConfig.JointLock.LockInfo.SpinLock);

            // return the pointer to the block to the client as the connection id
            pRequest->Handle.ConnectionContext = (PVOID)pConnEle;

            CTEExReleaseResource(&NbtConfig.Resource);
            NbtTrace(NBT_TRACE_OUTBOUND, ("New connection Upper=%p Lower=%p Device=%p",
                            pConnEle, pConnEle->pLowerConnId, pConnEle->pDeviceContext));

            return(STATUS_SUCCESS);
        }
#ifndef VXD
        IoFreeMdl(pConnEle->pNewMdl);
#endif
    }
#ifndef VXD
    else
    {
        ASSERTMSG("Nbt:Unable to allocate a MDL!!\n",0);
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
#endif  // !VXD

    FreeConnectionObj(pConnEle);
    CTEExReleaseResource(&NbtConfig.Resource);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtOpenAndAssocConnection(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tCONNECTELE         *pConnEle,
    OUT tLOWERCONNECTION    **ppLowerConn,
    IN  UCHAR               Identifier
    )

/*++
Routine Description:

    This Routine handles associating a Net Bios name with an open connection.
    In order to coordinate with ZwClose(hSession) in CloseAddressesWithTransport/ntutil.c,
    this routine should be called with NbtConfig.Resource exclusively locked.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    NTSTATUS            Locstatus;
    BOOLEAN             Attached=FALSE;
    tLOWERCONNECTION    *pLowerConn;
    PDEVICE_OBJECT      pDeviceObject;
    HANDLE              hSession;
    ULONG               Id = 0;
    UCHAR               *Id1 = (UCHAR *) &Id;
    TCP_REQUEST_SET_INFORMATION_EX  *pTcpSetInfo;
    struct TCPSocketOption          *pSockOption;
    ULONG                           BufferLength;

    if (ppLowerConn)
    {
        *ppLowerConn = NULL;
    }

    Id1[1] = 'L';
    Id1[0] = Identifier;

    if (!(pLowerConn = (tLOWERCONNECTION *) NbtAllocMem(sizeof(tLOWERCONNECTION), NBT_TAG2(Id))))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    CHECK_PTR(pLowerConn);
    CTEZeroMemory((PVOID)pLowerConn,sizeof(tLOWERCONNECTION));
    CTEAttachFsp(&Attached, REF_FSP_CONN);

    status = NbtTdiOpenConnection(pLowerConn,pDeviceContext);
    if (!NT_SUCCESS(status))
    {
        KdPrint(("Nbt.NbtOpenAndAssocConnection: NbtTdiOpenConnection returned ERROR=%x\n", status));
        CTEDetachFsp(Attached, REF_FSP_CONN);
        CTEMemFree(pLowerConn);

        return(status);
    }

    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE);
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_ASSOC_CONNECTION);

    if (pConnEle)
    {
        //
        // Open an address object (aka port)
        //

        //
        // until the correct state proc is set (i.e.Outbound), reject any data
        // (in other words, don't let this field stay NULL!)
        //
        SetStateProc (pLowerConn, RejectAnyData);

        status = NbtTdiOpenAddress (&pLowerConn->AddrFileHandle,
                                    &pDeviceObject,         // dummy argument, not used here
                                    &pLowerConn->pAddrFileObject,
                                    pDeviceContext,
                                    (USHORT) 0,             // any port
                                    pDeviceContext->IpAddress,
                                    TCP_FLAG);

        hSession = pLowerConn->AddrFileHandle;
    }
    else
    {
#ifndef VXD
        hSession = pDeviceContext->hSession;
#else
        hSession = (HANDLE) pDeviceContext->pSessionFileObject);    // Address handle stored in pFileObjects
#endif
    }

    /*
     * hSession could be NULL if the IP address is being released.
     */
    if (hSession == NULL) {
        status = STATUS_UNSUCCESSFUL;
    }
    if (NT_SUCCESS(status))
    {
        // associate with 139 or 445 session address
        status = NbtTdiAssociateConnection (pLowerConn->pFileObject, hSession);
        if (NT_SUCCESS(status))
        {
            ASSERT(pLowerConn->RefCount == 2);

            //
            // Disable nagling on this connection
            //
            if (!pDeviceContext->EnableNagling) {
                NbtSetTcpInfo (pLowerConn->FileHandle, TCP_SOCKET_NODELAY, INFO_TYPE_CONNECTION, (ULONG)TRUE);
            }

            if (pConnEle)
            {
                pLowerConn->pUpperConnection = pConnEle;
                ExInterlockedInsertTailList (&pDeviceContext->LowerConnection,   // put on active connections Q
                                             &pLowerConn->Linkage,
                                             &pDeviceContext->LockInfo.SpinLock);
            }
            else
            {
                InterlockedIncrement (&pDeviceContext->NumFreeLowerConnections);
                ExInterlockedInsertTailList (&pDeviceContext->LowerConnFreeHead,    // put on free list
                                             &pLowerConn->Linkage,
                                             &pDeviceContext->LockInfo.SpinLock);
            }
            InterlockedIncrement (&pDeviceContext->TotalLowerConnections);

            CTEDetachFsp(Attached, REF_FSP_CONN);
            if (ppLowerConn)
            {
                *ppLowerConn = pLowerConn;
            }

            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_ASSOC_CONNECTION, FALSE);
            return status;
        }


        KdPrint(("Nbt.NbtOpenAndAssocConnection: NbtTdiAssociateConnection returned ERROR=%x\n", status));
    }
    else
    {
        KdPrint(("Nbt.NbtOpenAddress: NbtTdiOpenConnection returned ERROR=%x\n", status));
    }

    /*
     * NBT_DEREFERENCE_LOWERCONN will decrease the TotalLowerConnections
     * Without the following InterlockedIncrement, we could under-count
     * the actual # of Lower Connection.
     */
    InterlockedIncrement (&pDeviceContext->TotalLowerConnections);
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_ASSOC_CONNECTION, FALSE);
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, FALSE);

    CTEDetachFsp(Attached, REF_FSP_CONN);

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAssociateAddress(
    IN  TDI_REQUEST         *pRequest,
    IN  tCLIENTELE          *pClientHandle,
    IN  PVOID               pIrp
    )

/*++
Routine Description:

    This Routine handles associating a Net Bios name with an open connection.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    tCONNECTELE     *pConnEle;
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    CTELockHandle   OldIrq1;
    CTELockHandle   OldIrq2;
    CTELockHandle   OldIrq3;

    pConnEle = pRequest->Handle.ConnectionContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq3);
    // Need code here to check if the address has been registered on the net
    // yet and if not, then this could must wait till then , then to the
    // associate  *TODO*

    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status) // check connection for validity
    CTEVerifyHandle(pClientHandle,NBT_VERIFY_CLIENT,tCLIENTELE,&status) // check client for validity now!

    CTESpinLock(pClientHandle->pDeviceContext,OldIrq2);
    CTESpinLock(pClientHandle,OldIrq);
    CTESpinLock(pConnEle,OldIrq1);

    if ((pConnEle->state != NBT_IDLE) ||
        (!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION)) ||  // NBT_VERIFY_CONNECTION_DOWN if cleaned up
        (!NBT_VERIFY_HANDLE (pClientHandle, NBT_VERIFY_CLIENT)))   // NBT_VERIFY_CLIENT_DOWN if cleaned up
    {
        // the connection is in use, so reject the associate attempt
        CTESpinFree(pConnEle,OldIrq1);
        CTESpinFree(pClientHandle,OldIrq);
        CTESpinFree(pClientHandle->pDeviceContext,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq3);
        return(STATUS_INVALID_HANDLE);
    }

    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    // link the connection to the client so we can find the client, given
    // the connection.
    pConnEle->pClientEle = (PVOID)pClientHandle;
    NbtTrace(NBT_TRACE_OUTBOUND, ("New connection Upper=%p Lower=%p Device=%p Client=%p",
                    pConnEle, pConnEle->pLowerConnId, pConnEle->pDeviceContext, pConnEle->pClientEle));

    // there can be multiple connections hooked to each client block - i.e.
    // multiple connections per address per client.  This allows the client
    // to find its connections.
    //
    // first unlink from the device context UpconnectionsInUse, which was linked
    // when the connection was created.
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientHandle->ConnectHead,&pConnEle->Linkage);

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(pClientHandle,OldIrq);
    CTESpinFree(pClientHandle->pDeviceContext,OldIrq2);
    CTESpinFree(&NbtConfig.JointLock,OldIrq3);

    return(STATUS_SUCCESS);

}
//----------------------------------------------------------------------------
NTSTATUS
NbtDisassociateAddress(
    IN  TDI_REQUEST         *pRequest
    )

/*++
Routine Description:

    This Routine handles disassociating a Net Bios name with an open connection.
    The expectation is that the
    client will follow with a NtClose which will do the work in Cleanup and
    Close Connection.  Since not all clients call this it is duplicate work
    to put some code here to.  The Rdr always calls NtClose after calling
    this.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    tCONNECTELE     *pConnEle;
    tCLIENTELE      *pClientEle;
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    CTELockHandle   OldIrq1;
    CTELockHandle   OldIrq2;
    tDEVICECONTEXT  *pDeviceContext;
    TDI_REQUEST         Request;
    ULONG           Flags;
    LIST_ENTRY      TempList;
    PLIST_ENTRY     pHead,pEntry;
    tLISTENREQUESTS *pListen;

    pConnEle = pRequest->Handle.ConnectionContext;
    // check the connection element for validity
    CHECK_PTR(pConnEle);
    if (!NBT_VERIFY_HANDLE2(pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERT(0);
        return (STATUS_INVALID_HANDLE);
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDisassociateAddress: State = %X\n",pConnEle->state));

    Flags = TDI_DISCONNECT_RELEASE;

    switch (pConnEle->state)
    {
        case NBT_CONNECTING:
        case NBT_RECONNECTING:
        case NBT_SESSION_OUTBOUND:
        case NBT_SESSION_WAITACCEPT:
        case NBT_SESSION_INBOUND:
            // do abortive disconnects when the session is not up yet
            // to be sure the disconnect completes the client's irp.
            Flags = TDI_DISCONNECT_ABORT;
        case NBT_SESSION_UP:


            //
            // Call NbtDisconnect incase the connection has not disconnected yet
            //
            Request.Handle.ConnectionContext = (PVOID)pConnEle;
            status = NbtDisconnect(&Request, &DefaultDisconnectTimeout, Flags, NULL, NULL, NULL);

            //
            // NOTE: there is no BREAK here... the next case MUST be executed too.
            //
        case NBT_ASSOCIATED:
        case NBT_DISCONNECTING:
        case NBT_DISCONNECTED:

            CTESpinLock(&NbtConfig.JointLock,OldIrq2);

            CHECK_PTR(pConnEle);
            CTESpinLock(pConnEle,OldIrq);

            RemoveEntryList(&pConnEle->Linkage);
            InitializeListHead(&pConnEle->Linkage);
            SET_STATE_UPPER (pConnEle, NBT_IDLE);
            pConnEle->DiscFlag = 0;

            //
            // remove the connection from the client and put back on the
            // unassociated list
            //
            if (pClientEle = pConnEle->pClientEle)
            {
                pConnEle->pClientEle = NULL;

                CTESpinFree(pConnEle,OldIrq);
                CTESpinLock(pClientEle,OldIrq1);
                CTESpinLock(pConnEle,OldIrq);

                InitializeListHead (&TempList);
                pHead = &pClientEle->ListenHead;
                pEntry = pHead->Flink;
                while (pEntry != pHead)
                {
                    pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
                    pEntry = pEntry->Flink;     // Don't reference freed memory

                    if (pListen->pConnectEle == pConnEle)
                    {
                        RemoveEntryList(&pListen->Linkage);
                        InsertTailList (&TempList, &pListen->Linkage);
                    }
                }

                pDeviceContext = pClientEle->pDeviceContext;

                CTESpinFree(pConnEle,OldIrq);
                CTESpinFree(pClientEle,OldIrq1);

                //
                // Ensure that the connection has not been cleaned up in this interval
                // Bug# 237836
                //
                if (pConnEle->Verify == NBT_VERIFY_CONNECTION)
                {
                    ExInterlockedInsertTailList(&pDeviceContext->UpConnectionInUse,
                                                &pConnEle->Linkage,
                                                &pDeviceContext->LockInfo.SpinLock);
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq2);

                while ((pEntry = TempList.Flink) != &TempList)
                {
                    pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
                    RemoveEntryList(&pListen->Linkage);
                    CTEIoComplete (pListen->pIrp, STATUS_CANCELLED, 0);
                    CTEMemFree((PVOID)pListen);
                }
            }
            else
            {
                CTESpinFree(pConnEle,OldIrq);
                CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            }

            break;

        default:
            break;
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtCloseAddress(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp)

/*++

Routine Description

    This routine closes an address object for the client.  Any connections
    associated with the address object are immediately aborted and any requests
    pending on the connection associated with the address object are
    immediately completed with an appropriate error code.  Any event handlers
    that are registered are immediately deregistered and will not be called
    after this request completes.

    Note the the client actually passes a handle to the client object which is
    chained off the address object.  It is the client object that is closed,
    which represents this clients attachment to the address object.  Other
    clients can continue to use the address object.

Arguments:
    pRequest->Handle.AddressHandle - ptr to the ClientEle object.
    pRequestStatus - return status for asynchronous completions.
    pContext - the NBT device that this address is valid upon
    pIrp - ptr to track for NT compatibility.

Return Values:

    TDI_STATUS - status of the request

--*/
{
    tCLIENTELE      *pClientEle;
    NTSTATUS        status;
#ifndef VXD
    UCHAR           IrpFlags;
    PIO_STACK_LOCATION           pIrpsp;
#endif

    CTEPagedCode();

    pClientEle = (tCLIENTELE *)pRequest->Handle.ConnectionContext;
    if (!pClientEle->pAddress)
    {
        // the address has already been deleted.
        return(STATUS_SUCCESS);
    }

    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.NbtCloseAddress: Close Address Hit %16.16s<%X> %X\n",
            pClientEle->pAddress->pNameAddr->Name,
            pClientEle->pAddress->pNameAddr->Name[15],pClientEle));

    NbtTrace(NBT_TRACE_NAMESRV, ("%!FUNC! close address ClientEle=%p %!NBTNAME!<%02x>", pClientEle,
                                    pClientEle->pAddress->pNameAddr->Name,
                                    (unsigned)pClientEle->pAddress->pNameAddr->Name[15]));

#ifdef VXD
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);

    //
    // In NT-Land, closing connections is a two stage affair.  However in
    // the Vxd-Land, it is just a close, so call the other cleanup function
    // here to do most of the work. In the NT implementation it is called
    // from Ntisol.c, NTCleanupAddress.
    //
    pClientEle->pIrp = pIrp ;
    status = NbtCleanUpAddress(pClientEle,pClientEle->pDeviceContext);
#else
    // Note the special verifier  that is set during the cleanup phase.
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT_DOWN,tCLIENTELE,&status);

    //
    // clear the context value in the FileObject so that the client cannot
    // pass this to us again
    //
    (VOID)NTClearFileObjectContext(pIrp);
    pClientEle->pIrp = pIrp;

    pIrpsp = IoGetCurrentIrpStackLocation(((PIRP)pIrp));

    IrpFlags = pIrpsp->Control;
    IoMarkIrpPending(((PIRP)pIrp));

#endif

    NBT_DEREFERENCE_CLIENT(pClientEle);

    return(STATUS_PENDING);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCleanUpAddress(
    IN  tCLIENTELE      *pClientEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine handles the first stage of releasing an address object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    tLOWERCONNECTION    *pLowerConn;
    tCONNECTELE         *pConnEle;
    tCONNECTELE         *pConnEleToDeref = NULL;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    CTELockHandle       OldIrq3;
    PLIST_ENTRY         pHead,pEntry;
    PLIST_ENTRY         pEntryConn;
    tADDRESSELE         *pAddress;
    DWORD               i;
    LIST_ENTRY          TempList;

    // to prevent connections and datagram from the wire...remove from the
    // list of clients hooked to the address element
    //
    pAddress = pClientEle->pAddress;
    if (!pAddress)
    {
        // the address has already been deleted.
        return(STATUS_SUCCESS);
    }

    // lock the address to coordinate with receiving datagrams - to avoid
    // allowing the client to free datagram receive buffers in the middle
    // of DgramHndlrNotOs finding a buffer
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!IsListEmpty(&pClientEle->RcvDgramHead))
    {
        PLIST_ENTRY     pHead;
        PLIST_ENTRY     pEntry;
        tRCVELE         *pRcvEle;
        PCTE_IRP        pRcvIrp;

        pHead = &pClientEle->RcvDgramHead;
        pEntry = pHead->Flink;

        // prevent any datagram from the wire seeing this list
        //
        InitializeListHead(&pClientEle->RcvDgramHead);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        while (pEntry != pHead)
        {
            pRcvEle   = CONTAINING_RECORD(pEntry,tRCVELE,Linkage);
            pRcvIrp   = pRcvEle->pIrp;

            CTEIoComplete(pRcvIrp,STATUS_NETWORK_NAME_DELETED,0);

            pEntry = pEntry->Flink;

            CTEMemFree(pRcvEle);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    // lock the client and the device context till we're done
    CTESpinLock(pClientEle,OldIrq2);

#ifndef VXD
    //
    // set to prevent reception of datagrams
    // (Vxd doesn't use this handler)
    //
    pClientEle->evRcvDgram = TdiDefaultRcvDatagramHandler;
#endif

    // so no one else can access the client element, set state to down. Therefore
    // the verify checks will fail anywhere the client is accessed in the code,
    // except in the NbtCloseAddress code which checks for this verifier value.
    //
    pClientEle->Verify = NBT_VERIFY_CLIENT_DOWN;

    //
    //  Disassociate all Connections from this address object, first starting
    //  with any active connections, then followup with any idle connections.
    //
    pDeviceContext = pClientEle->pDeviceContext;
    while ( !IsListEmpty( &pClientEle->ConnectActive ))
    {
        pEntry = RemoveHeadList( &pClientEle->ConnectActive ) ;
        InitializeListHead(pEntry);

        pConnEle = CONTAINING_RECORD( pEntry, tCONNECTELE, Linkage ) ;
        CTESpinLock(pConnEle,OldIrq3);
        NBT_REFERENCE_CONNECTION(pConnEle, REF_CONN_CLEANUP_ADDR); // Ensure conn stays around releasing lock below
        CTESpinFree(pConnEle,OldIrq3);

        CTESpinFree(pClientEle,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // if we had a connection in partial rcv state, make sure to remove it from
        // the list
        //
#ifdef VXD
        pLowerConn = pConnEle->pLowerConnId;

        if ( pLowerConn->StateRcv == PARTIAL_RCV &&
            (pLowerConn->fOnPartialRcvList == TRUE) )
        {
            RemoveEntryList( &pLowerConn->PartialRcvList ) ;
            pLowerConn->fOnPartialRcvList = FALSE;
            InitializeListHead(&pLowerConn->PartialRcvList);
        }
#endif

        //
        // Deref any connections referenced earlier if necessary
        //
        if (pConnEleToDeref)
        {
            NBT_DEREFERENCE_CONNECTION(pConnEleToDeref, REF_CONN_CLEANUP_ADDR);
        }
        pConnEleToDeref = pConnEle;

        status = NbtCleanUpConnection(pConnEle,pDeviceContext);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        CTESpinLock(pClientEle,OldIrq2);
        CTESpinLock(pConnEle,OldIrq3);
        //
        // remove from this list again incase SessionSetupContinue has put it
        // back on the list - if no one has put it back on this list this
        // call is a no op since we initialized the list head above
        //
        RemoveEntryList(&pConnEle->Linkage);
        InitializeListHead (&pConnEle->Linkage);
        CHECK_PTR(pConnEle);
        SET_STATE_UPPER (pConnEle, NBT_IDLE);
        pConnEle->pClientEle = NULL;

        CTESpinFree(pConnEle,OldIrq3);
        CTESpinFree(pClientEle,OldIrq2);
        PUSH_LOCATION(0x80);

        //
        // put on the idle connection list, to wait for a close connection
        // to come down.
        // Bug # 405699
        // Do this only if the NTCleanupConnection did not run in the interim.
        //
        ASSERT(pConnEle->RefCount >= 1);
        if (!pConnEle->ConnectionCleanedUp)
        {
            ExInterlockedInsertTailList (&pDeviceContext->UpConnectionInUse,
                                         &pConnEle->Linkage,
                                         &pDeviceContext->LockInfo.SpinLock);
        }


        CTESpinLock(pClientEle,OldIrq2);
    }

    CTESpinFree(pClientEle,OldIrq2);
    CTESpinLock(pDeviceContext,OldIrq1);
    CTESpinLock(pClientEle,OldIrq2);
    // We are now holding the JointLock + DeviceLock + ClientLock

    //
    // each idle connection creates a lower connection to the transport for
    // inbound calls, therefore close a transport connection for each
    // connection in this list and then "dissassociate" the connection from
    // the address.
    //
    // make the list look empty so no connections will be serviced inbound
    // from the wire
    //
    while (!IsListEmpty(&pClientEle->ConnectHead))
    {
        pEntry = pClientEle->ConnectHead.Flink;
        RemoveEntryList (pEntry);
        pConnEle = CONTAINING_RECORD(pEntry,tCONNECTELE,Linkage);
        CHECK_PTR(pConnEle);
        ASSERT ((pConnEle->Verify==NBT_VERIFY_CONNECTION) || (pConnEle->Verify==NBT_VERIFY_CONNECTION_DOWN));

        CTESpinLock(pConnEle,OldIrq3);

        //
        // The Connection Element could be currently being cleaned up in NbtCleanUpConnection, so verify
        //
        if (pConnEle->Verify != NBT_VERIFY_CONNECTION)
        {
            InitializeListHead (&pConnEle->Linkage);
            CTESpinFree(pConnEle,OldIrq3);
            continue;
        }

        InsertTailList(&pDeviceContext->UpConnectionInUse,&pConnEle->Linkage);

        // disassociate the connection from the address by changing its state
        // to idle and linking it to the pDeviceContext list of unassociated
        // connections
        //
        ASSERT(pConnEle->RefCount == 1);
        SET_STATE_UPPER (pConnEle, NBT_IDLE);
        pConnEle->Verify = NBT_VERIFY_CONNECTION_DOWN;
        pConnEle->pClientEle = NULL;

        CTESpinFree(pConnEle,OldIrq3);

        //
        // Get a free connection to the transport and close it
        // for each free connection on this list.  It is possible that this
        // free list could be empty if an inbound connection was occurring
        // right at this moment.  In which case we would leave an extra connection
        // object to the transport lying around... not a problem.
        if (!IsListEmpty(&pDeviceContext->LowerConnFreeHead))
        {
            pEntryConn = RemoveHeadList(&pDeviceContext->LowerConnFreeHead);
            pLowerConn = CONTAINING_RECORD(pEntryConn,tLOWERCONNECTION,Linkage);
            InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.NbtCleanUpAddress: Closing Handle %p->%X\n",pLowerConn,pLowerConn->FileHandle));

            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
        }
    }

    // check for any datagrams still outstanding. These could be waiting on
    // name queries to complete, so there could be timers associated with them
    //
    //  Complete any outstanding listens not on an active connection
    //
    //
    // make the list look empty so no connections will be serviced inbound
    // from the wire
    //
    //
    // Move all of the Listen requests onto a temporary list
    //
    InitializeListHead (&TempList);
    while (!IsListEmpty(&pClientEle->ListenHead))
    {
        pEntry = pClientEle->ListenHead.Flink;

        RemoveEntryList (pEntry);
        InsertTailList (&TempList, pEntry);
    }

    CTESpinFree(pClientEle, OldIrq2);
    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    while ((pEntry = TempList.Flink) != &TempList)
    {
        tLISTENREQUESTS  * pListen ;

        pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
        RemoveEntryList(&pListen->Linkage);

        CTEIoComplete( pListen->pIrp, STATUS_NETWORK_NAME_DELETED, 0);
        CTEMemFree( pListen );
    }

    //
    // Deref any connections referenced earlier if necessary
    //
    if (pConnEleToDeref)
    {
        NBT_DEREFERENCE_CONNECTION(pConnEleToDeref, REF_CONN_CLEANUP_ADDR);
    }

#ifdef VXD
    //
    //  Complete any outstanding ReceiveAnys on this client element
    //
    DbgPrint("NbtCleanupAddress: Completing all RcvAny NCBs\r\n") ;
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pClientEle,OldIrq2);

    pHead = &pClientEle->RcvAnyHead;
    pEntry = pHead->Flink;
    //
    // make the list look empty so no connections will be serviced inbound
    // from the wire
    //
    InitializeListHead(pHead);

    CTESpinFree(pClientEle, OldIrq2);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    while (pEntry != pHead )
    {
        PRCV_CONTEXT pRcvContext ;

        pRcvContext = CONTAINING_RECORD(pEntry,RCV_CONTEXT,ListEntry);
        pEntry = pEntry->Flink;

        CTEIoComplete( pRcvContext->pNCB, STATUS_NETWORK_NAME_DELETED, TRUE );

        FreeRcvContext( pRcvContext );
    }
#endif

    // *TODO the code above only removes names that are being resolved, and
    // leaves any datagram sends that are currently active with the
    // transport... these should be cancelled too by cancelling the irp..
    // Put this code in when the Irp cancelling code is done.

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCloseConnection(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pIrp)

/*++

Routine Description

    This routine closes a connection object for the client.  Closing is
    different than disconnecting.  A disconnect breaks a connection with a
    peer whereas the close removes this connection endpoint from the local
    NBT only.  NtClose causes NTCleanup to be called first which does the
    session close.  This routine then does frees memory associated with the
    connection elements.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tCONNECTELE         *pConnEle;
    NTSTATUS            status;

    CTEPagedCode();

    pConnEle = pRequest->Handle.ConnectionContext;
    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.NbtCloseConnection: Hit!! state = %X pConnEle %X\n",pConnEle->state,pConnEle));

#ifndef VXD
    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION_DOWN,tCONNECTELE,&status);
    IoMarkIrpPending((PIRP)pIrp);     // Bug 261575: to make driver verifier happy
#else
    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);
    //
    // Call the Cleanup function, which NT calls from ntisol, NtCleanupConnection
    //
    status = NbtCleanUpConnection(pConnEle,pDeviceContext );
#endif

    // NOTE:
    // the NBtDereference routine will complete the irp and return pending
    //
    NbtTrace(NBT_TRACE_DISCONNECT, ("Close connection Irp=%p Upper=%p Lower=%p Client=%p Device=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle, pConnEle->pDeviceContext));

    pConnEle->pIrpClose = pIrp;
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CREATE);

    return (STATUS_PENDING);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCleanUpConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    )
/*++
Routine Description:

    This Routine handles running down a connection in preparation for a close
    that will come in next.  NtClose hits this entry first, and then it hits
    the NTCloseConnection next. If the connection was outbound, then the
    address object must be closed as well as the connection.  This routine
    mainly deals with the pLowerconn connection to the transport whereas
    NbtCloseConnection deals with closing pConnEle, the connection to the client.

    If DisassociateConnection is called by the client then it will do most of
    this cleanup.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;
    NTSTATUS            Locstatus;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    tLOWERCONNECTION    *pLowerConn;
    PLIST_ENTRY         pEntry;
    BOOLEAN             Originator = TRUE;
    ULONG               LowerState = NBT_IDLE;
    TDI_REQUEST         Request;
    tLISTENREQUESTS     *pListen;
    tCLIENTELE          *pClientEle;
    PLIST_ENTRY         pHead;
    LIST_ENTRY          TempList;
    BOOLEAN             QueueCleanupBool=FALSE;
    BOOLEAN             DoDisconnect=TRUE;
    BOOLEAN             FreeLower;

    NbtTrace(NBT_TRACE_DISCONNECT, ("Cleanup connection Upper=%p Lower=%p Client=%p Device=%p",
                            pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle, pConnEle->pDeviceContext));
    //
    // save the lower connection origination flag for later
    //
    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        Originator = pLowerConn->bOriginator;
    }

    // the connection has not been associated so there is no further work to
    // do here.
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    //
    // If the state is NBT_IDLE, the connection has already been disassociated,
    // and the next action will be a close, so change the verifier to allow
    // the close to complete
    //
    if (pConnEle->state != NBT_IDLE)
    {
        BOOLEAN     DoCleanup = FALSE;

        CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);


        //
        // check if there is an outstanding name query going on and if so
        // then cancel the timer and call the completion routine.
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq2);
        CTESpinLock(pConnEle,OldIrq);

        if ((pConnEle->state == NBT_CONNECTING) ||
            (pConnEle->state == NBT_RECONNECTING))
        {
            status = CleanupConnectingState(pConnEle,pDeviceContext,&OldIrq,&OldIrq2);
            //
            // Pending means that the connection is currently being setup
            // by TCP, so do a disconnect, below.
            //
            if (status != STATUS_PENDING)
            {
                //
                // Since the connection is not setup with the transport yet
                // there is no need to call nbtdisconnect
                //
                DoDisconnect = FALSE;
           }
        }


        //
        // all other states of the connection are handled by NbtDisconnect
        // which will send a disconnect down the to transport and then
        // cleanup things.
        //

        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);

        CTEExReleaseResource(&NbtConfig.Resource);
        Request.Handle.ConnectionContext = (PVOID)pConnEle;

        if (DoDisconnect)
        {
            NbtTrace(NBT_TRACE_DISCONNECT, ("Abort connection ==> ConnEle %p", pConnEle));
            status = NbtDisconnect(
                                &Request,
                                &DefaultDisconnectTimeout,
                                TDI_DISCONNECT_ABORT,
                                NULL,
                                NULL,
                                NULL
                                );
            NbtTrace(NBT_TRACE_DISCONNECT, ("NbtDisconnect returns %!status!", status));
        }

        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

        // we don't want to return Invalid connection if we disconnect an
        // already disconnected connection.
        if (status == STATUS_CONNECTION_INVALID)
        {
            status = STATUS_SUCCESS;
        }
    }

    CTESpinLock(pConnEle,OldIrq);

    //
    // if the verify value is already set to connection down then we have
    // been through here already and do not want to free a lower connection.
    // i.e. when the client calls close address then calls close connection.
    //
    if (pConnEle->Verify == NBT_VERIFY_CONNECTION)
    {
        FreeLower = TRUE;
    }
    else
    {
        FreeLower = FALSE;
    }

    pConnEle->Verify = NBT_VERIFY_CONNECTION_DOWN;

    //
    // Free any posted Rcv buffers that have not been filled
    //

    FreeRcvBuffers(pConnEle,&OldIrq);

    // check if any listens have been setup for this connection, and
    // remove them if so
    //
    pClientEle = pConnEle->pClientEle;
    CTESpinFree(pConnEle,OldIrq);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);

    InitializeListHead (&TempList);
    if (pClientEle)
    {
        CTESpinLock(pClientEle,OldIrq2);

        pHead = &pClientEle->ListenHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
            pEntry = pEntry->Flink;     // Don't reference freed memory

            if (pListen->pConnectEle == pConnEle)
            {
                RemoveEntryList(&pListen->Linkage);
                InsertTailList(&TempList, &pListen->Linkage);
            }
        }
        CTESpinFree(pClientEle,OldIrq2);
    }

    CTESpinLock(pConnEle,OldIrq2);

    //
    // Unlink the connection element from the client's list or the device context
    // if its not associated yet.
    //
    CHECK_PTR(pConnEle);
    if (pConnEle->state > NBT_IDLE)
    {
        // do the disassociate here
        //
        SET_STATE_UPPER (pConnEle, NBT_IDLE);
        pConnEle->pClientEle = NULL;
    }

    RemoveEntryList(&pConnEle->Linkage);
    InitializeListHead(&pConnEle->Linkage);

    CTESpinFree(pConnEle,OldIrq2);
    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    while ((pEntry = TempList.Flink) != &TempList)
    {
        pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);

        RemoveEntryList(&pListen->Linkage);
        CTEIoComplete (pListen->pIrp, STATUS_CANCELLED, 0);
        CTEMemFree (pListen);
    }

    // this could be status pending from NbtDisconnect...
    //
    return(status);
}
//----------------------------------------------------------------------------
extern
VOID
FreeRcvBuffers(
    tCONNECTELE     *pConnEle,
    CTELockHandle   *pOldIrq
    )
/*++
Routine Description:

    This Routine handles freeing any recv buffers posted by the client.
    The pConnEle lock could be held prior to calling this routine.

Arguments:

    pListHead
    pTracker

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    PLIST_ENTRY             pHead;

    pHead = &pConnEle->RcvHead;
    while (!IsListEmpty(pHead))
    {
        PLIST_ENTRY            pRcvEntry;
        PVOID                  pRcvElement ;

        KdPrint(("Nbt.FreeRcvBuffers: ***Freeing Posted Rcvs on Connection Cleanup!\n"));
        pRcvEntry = RemoveHeadList(pHead);
        CTESpinFree(pConnEle,*pOldIrq);

#ifndef VXD
        pRcvElement = CONTAINING_RECORD(pRcvEntry,IRP,Tail.Overlay.ListEntry);
        CTEIoComplete( (PIRP) pRcvElement, STATUS_CANCELLED,0);
#else
        pRcvElement = CONTAINING_RECORD(pRcvEntry, RCV_CONTEXT, ListEntry ) ;
        CTEIoComplete( ((PRCV_CONTEXT)pRcvEntry)->pNCB, STATUS_CANCELLED, 0);
#endif

        CTESpinLock(pConnEle,*pOldIrq);
    }

}



//----------------------------------------------------------------------------
NTSTATUS
FindPendingRequest(
    IN  tLMHSVC_REQUESTS        *pLmHRequests,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    OUT NBT_WORK_ITEM_CONTEXT   **pContextRet
    )
{
    PLIST_ENTRY             pEntry;
    NBT_WORK_ITEM_CONTEXT   *pWiContext = NULL;

    pWiContext = (NBT_WORK_ITEM_CONTEXT *) pLmHRequests->Context;
    if (pWiContext && (pWiContext->pTracker == pTracker))
    {
        pLmHRequests->Context = NULL;
        NTClearContextCancel (pWiContext);
        *pContextRet = pWiContext;

        return(STATUS_SUCCESS);
    }
    else
    {
        //
        // check the list for this tracker
        //
        pEntry = pLmHRequests->ToResolve.Flink;
        while (pEntry != &pLmHRequests->ToResolve)
        {
            pWiContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Item.List);
            pEntry = pEntry->Flink;

            if (pTracker == pWiContext->pTracker)
            {
                RemoveEntryList(pEntry);
                *pContextRet = pWiContext;
                return(STATUS_SUCCESS);
            }
        }
    }

    return (STATUS_UNSUCCESSFUL);
}


//----------------------------------------------------------------------------
NTSTATUS
CleanupConnectingState(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  CTELockHandle   *OldIrq,        // pConnEle lock
    IN  CTELockHandle   *OldIrq2        // joint lock
    )
/*++
Routine Description:

    This Routine handles running down a connection in the NBT_CONNECTING
    state since that connection could be doing a number of things such as:
        1)  Broadcast or WINS name Query
        2)  LmHosts name query
        3)  DNS name query
        4)  Tcp Connection setup

    The JointLock and the pConnEle lock are held when calling this routine.

Arguments:

    pConnEle        - ptr to the connection
    pDeviceContext  - the device context

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    tDGRAM_SEND_TRACKING    *pTrackerName = NULL;
    tDGRAM_SEND_TRACKING    *pTrackerConnect = NULL;
    tNAMEADDR               *pNameAddr = NULL;
    NBT_WORK_ITEM_CONTEXT   *pWiContext = NULL;
    tLOWERCONNECTION        *pLowerConn;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   Context;
    NTSTATUS                Locstatus;

    //
    // save the lower connection origination flag for later
    //
    pLowerConn = pConnEle->pLowerConnId;
    pTrackerConnect = (tDGRAM_SEND_TRACKING *) pConnEle->pIrpRcv;
    //CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&Locstatus);

    if (pConnEle->state == NBT_CONNECTING)
    {
        if ((pLowerConn) &&     // The LowerConnection could have gone away if it was deleted
            (pLowerConn->State == NBT_CONNECTING))
        {
            LOCATION(0x6E)
            //
            // We are setting up the TCP connection to the transport Now
            // so it is safe to call NbtDisconnect on this connection and
            // let that cleanup the mess - use this retcode to signify that.
            //
            return(STATUS_PENDING);

        }

        //
        // check if the name query is held up in doing a LmHost or DNS
        // Name Query
        //

        // check if there is an outstanding name query going on and if so
        // then cancel the timer and call the completion routine.
        //
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.CleanupConnectingState: Cleanup in the Connecting State %X\n",pConnEle));

        pTrackerName = pTrackerConnect->pTrackerWorker;  // QueryNameOnNet tracker
        if (NBT_VERIFY_HANDLE (pTrackerName, NBT_VERIFY_TRACKER) && pTrackerConnect->pDestName)
        {
            status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                     pTrackerConnect->pDestName,
                                     NbtConfig.pScope,
                                     &pNameAddr);

            //
            // if there is a timer, then the connection setup is still
            // waiting on the name query.  If no timer, then we could be
            // waiting on an LmHosts or DNS name query or we
            // are waiting on the TCP connection setup - stopping the timer
            // should cleanup the tracker.
            //
            if (NT_SUCCESS(status))
            {
                tTIMERQENTRY    *pTimer;

                CHECK_PTR(pNameAddr);
                if (pNameAddr->NameTypeState & STATE_RESOLVED)
                {
                    //
                    // the name has resolved, but not started setting up the
                    // session yet, so return this status to tell the caller
                    // to cancel the tracker.
                    //
                    return(STATUS_UNSUCCESSFUL);
                }
                else if (pTimer = pNameAddr->pTimer)
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt.CleanupConnectingState: Cleanup During NameQuery: pConnEle=%X\n",
                                pConnEle));

                    pNameAddr->pTimer = NULL;
                    status = StopTimer(pTimer,&pClientCompletion,&Context);

#ifdef DEAD_CODE
                    //
                    // remove the name from the hash table, since it did not resolve
                    //
                    pNameAddr->NameTypeState &= ~STATE_RESOLVING;
                    pNameAddr->NameTypeState |= STATE_RELEASED;
                    pNameAddr->pTracker = NULL;
                    if (pClientCompletion)
                    {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, TRUE);
                    }
#endif  // DEAD_CODE

                    pTrackerName = NULL;    // since StopTimer should have cleaned up the tracker, null it out
                }
                else
                {
                    //
                    // check if the name is waiting on an LmHost name Query
                    // or a DNS name query
                    //
                    status = FindPendingRequest (&LmHostQueries, pTrackerName, &pWiContext);
                    if (!NT_SUCCESS(status))
                    {
#ifndef VXD
                        status = FindPendingRequest (&DnsQueries, pTrackerName, &pWiContext);
                        if (!NT_SUCCESS(status))
                        {
                            status = FindPendingRequest (&CheckAddr, pTrackerName, &pWiContext);
                        }
#endif
                    }

                    if (NT_SUCCESS(status))
                    {
                        IF_DBG(NBT_DEBUG_NAMESRV)
                            KdPrint(("Nbt.CleanupConnectingState: Found pending NameQuery for pConnEle %X\n",
                                pConnEle));
                    }
                }
            }
            // ...else....
            // the completion routine has already run, so we are
            // in the state of starting a Tcp Connection, so
            // let nbtdisconnect handle it. (below).
            //
        }
    } // connnecting state
    else if (pConnEle->state == NBT_RECONNECTING)
    {
        LOCATION(0x77);
        //
        // this should signal NbtConnect not to do the reconnect
        //
        pTrackerConnect->pTrackerWorker->Flags = TRACKER_CANCELLED;
    }

    if (NT_SUCCESS(status))
    {
        // for items on the LmHost or Dns queues, get the completion routine
        // out of the Work Item context first
        //
        if (pWiContext)
        {
            LOCATION(0x78);
            pClientCompletion = pWiContext->ClientCompletion;
            Context = pWiContext->pClientContext;

            // for DNS and LmHosts, the tracker needs to be freed and the name
            // removed from the hash table
            //
            if (pTrackerName)
            {
                LOCATION(0x79);
                CTESpinFree(pConnEle,*OldIrq);
                CTESpinFree(&NbtConfig.JointLock,*OldIrq2);
                //
                // remove the name from the hash table, since it did not resolve
                //
                SetNameState (pTrackerName->pNameAddr, NULL, FALSE);
                NBT_DEREFERENCE_TRACKER(pTrackerName, FALSE);

                CTESpinLock(&NbtConfig.JointLock,*OldIrq2);
                CTESpinLock(pConnEle,*OldIrq);
            }

            CTEMemFree(pWiContext);
        }

        if (pClientCompletion)
        {
            LOCATION(0x7A);
            CTESpinFree(pConnEle,*OldIrq);
            CTESpinFree(&NbtConfig.JointLock,*OldIrq2);

            //
            // The completion routine is SessionSetupContinue
            // and it will cleanup the lower connection and
            // return the client's irp
            //
            status = STATUS_SUCCESS;
            CompleteClientReq(pClientCompletion, Context,STATUS_CANCELLED);

            CTESpinLock(&NbtConfig.JointLock,*OldIrq2);
            CTESpinLock(pConnEle,*OldIrq);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
        }
    }

    return(status);
}

NTSTATUS
CheckConnect(
    IN tCONNECTELE  *pConnEle,
    IN tCLIENTELE   *pClientEle,
    IN tDEVICECONTEXT *pDeviceContext
    )
/*++
    This function should be called with the following locks held.
            NbtConfig.Resource
            NbtConfig.JointLock     SpinLock
            pClientEle              SpinLock
            pConnEle                SpinLock
 --*/
{
    /*
     * The state can be NBT_DISCONNECTING if this ConnectionElement
     * is being reused to setup a connection to a different Endpoint
     */
    if ((pConnEle->state != NBT_ASSOCIATED) &&
        (pConnEle->state != NBT_DISCONNECTING) &&
        (pConnEle->state != NBT_DISCONNECTED)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (pClientEle->Verify != NBT_VERIFY_CLIENT ) {
        return  (pClientEle->Verify == NBT_VERIFY_CLIENT_DOWN)? STATUS_CANCELLED: STATUS_INVALID_HANDLE;
    }

    /*
     * be sure the name is in the correct state for a connection
     */
    if ((!IsDeviceNetbiosless(pDeviceContext)) &&
        (pClientEle->pAddress->pNameAddr->NameTypeState & STATE_CONFLICT)) {
        return STATUS_DUPLICATE_NAME;
    }

    /*
     * this code handles the case when DHCP has not assigned an IP address yet
     */
    if (pDeviceContext->IpAddress == 0) {
        return STATUS_BAD_NETWORK_PATH;
    }
    return STATUS_SUCCESS;

/*
    //
    // this code handles the case when DHCP has not assigned an IP address yet
    //
    ASSERT (pDeviceContext->IpAddress == 0 || !pDeviceContext->pSessionFileObject);
    if (pDeviceContext->IpAddress == 0 || !pDeviceContext->pSessionFileObject) {
        return STATUS_BAD_NETWORK_PATH;
    }
    return STATUS_SUCCESS;
*/
}

NTSTATUS
NbtReConnect(
    IN tDGRAM_SEND_TRACKING    *pTracker,
    IN tIPADDRESS               DestIp
    )
{
    tCONNECTELE             *pConnEle;
    tCLIENTELE              *pClientEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    tIPADDRESS              IpAddress;
    tNAMEADDR               *pNameAddr;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;

#ifdef _PNP_POWER_
    if (NbtConfig.Unloading) {
        KdPrint (("Nbt.NbtReConnect: --> ERROR New Connect request while Unloading!!!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#endif  // _PNP_POWER_

    /*
     * Only NETBIOS name can hit requery or retarget
     */
    ASSERT(pTracker->RemoteNameLength <= NETBIOS_NAME_SIZE);
    pConnEle = pTracker->pConnEle;

    //
    // Acquire this resource to co-ordinate with DHCP changing the IP
    // address
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    if ((!(NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION))) || (!(pClientEle = pConnEle->pClientEle))) {
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    CTESpinLock(pClientEle,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);
    pDeviceContext = pClientEle->pDeviceContext;
    ASSERT(!IsDeviceNetbiosless(pDeviceContext));       // NetbiosLess device cannot hit reconnect or retarget case

    status = CheckConnect(pConnEle, pClientEle, pDeviceContext);
    if (status != STATUS_SUCCESS) {
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        NbtTrace(NBT_TRACE_OUTBOUND, ("CheckConnect returns %!status! for %!NBTNAME!<%02x>",
                                status, pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
        return status;
    }

    //
    // check if the Reconnect got cancelled
    //
    pTracker->pTrackerWorker = NULL;
    if (pTracker->Flags & TRACKER_CANCELLED) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Connection Request is cancelled for %!NBTNAME!<%02x>",
                pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
        //
        // if SessionSetupContinue has run, it has set the refcount to zero
        //
        if (pTracker->RefConn == 0) {
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        } else {
            pTracker->RefConn--;
        }
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return STATUS_CANCELLED;
    }

    SET_STATE_UPPER (pConnEle, NBT_CONNECTING);

    // Increment the ref count so that a cleanup cannot remove
    // the pConnEle till the session is setup - one of these is removed when
    // the session is setup and the other is removed when it is disconnected.
    //
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    ASSERT(pConnEle->RefCount >= 3);
    //
    // unlink the connection from the idle connection list and put on active list
    //
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientEle->ConnectActive,&pConnEle->Linkage);

    // this field is used to hold a disconnect irp if it comes down during
    // NBT_CONNECTING or NBT_SESSION_OUTBOUND states
    //
    pConnEle->pIrpDisc = NULL;

    // if null then this is being called to reconnect and the tracker is already
    // setup.
    //
    // for the reconnect case we must skip most of the processing since
    // the tracker is all set up already.  All we need to do is
    // retry the connection.
    pTracker->RefConn++;
    pTracker->SendBuffer.pBuffer = pTracker->pRemoteName;

    // store the tracker in the Irp Rcv ptr so it can be used by the
    // session setup code in hndlrs.c in the event the destination is
    // between posting listens and this code should re-attempt the
    // session setup.  The code in hndlrs.c returns the tracker to its
    // free list and frees the session hdr memory too.
    //
    // We need to set this while holding the ConnEle lock because the client
    // can call NbtDisconnect while we are opening a Tcp handle and try to
    // set the Tracker's flag to TRACKER_CANCELLED
    //
    pConnEle->pIrpRcv = (PIRP)pTracker;

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(pClientEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    // open a connection with the transport for this session
    status = NbtOpenAndAssocConnection (pDeviceContext, pConnEle, &pConnEle->pLowerConnId, '3'); 
    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("NbtOpenAndAssocConnection return %!status! for %!NBTNAME!<%02x>",
                status, pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
        goto NbtConnect_Check;
    }

    // We need to track that this side originated the call so we discard this
    // connection at the end
    //
    pConnEle->pLowerConnId->bOriginator = TRUE;

    // set this state to associated so that the cancel irp routine
    // can differentiate the name query stage from the setupconnection
    // stage since pConnEle is in the Nbtconnecting state for both.
    //
    SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_ASSOCIATED);

    // if this routine is called to do a reconnect, DO NOT close another
    // Lower Connection since one was closed the on the first
    // connect attempt.
    // the original "ToName" was stashed in this unused
    // ptr! - for the Reconnect case
    // the pNameAddr part of pTracker(pDestName) needs to pt. to
    // the name so that SessionSetupContinue can find the name
    pTracker->pDestName  = pTracker->pConnEle->RemoteName;
    pTracker->UnicodeDestName = NULL;       // We don't need unicode for NetBIOS name queries

    //
    // For a ReQuery request, DestIp is 0, otherwise for the ReTarget
    // case, DestIp is the new destination address
    //
    if (DestIp) {
        //
        // Retarget
        //
        status = FindNameOrQuery(pTracker->pConnEle->RemoteName,
                                pDeviceContext,
                                SessionSetupContinue,
                                pTracker,
                                (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                                &IpAddress,
                                &pNameAddr,
                                REF_NAME_CONNECT,
                                FALSE);
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NbtReConnect: name=<%16.16s:%x>, Status=%lx (%d of %s)\n",
                pConnEle->RemoteName, pConnEle->RemoteName[15], status, __LINE__, __FILE__));
    } else {
        //
        // This is the ReQuery attempt
        //
        BOOLEAN fNameReferenced = TRUE;

        status = ContinueQueryNameOnNet (pTracker,
                                         pTracker->pConnEle->RemoteName,
                                         pDeviceContext,
                                         SessionSetupContinue,
                                         &fNameReferenced);

        pNameAddr = pTracker->pNameAddr;
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NbtReConnect: name=<%16.16s:%x>, Status=%lx (%d of %s)\n",
                pConnEle->RemoteName, pConnEle->RemoteName[15], status, __LINE__, __FILE__));
    }

NbtConnect_Check:
    if ((status == STATUS_SUCCESS) && (!IpAddress)) {
        ASSERT (0);
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        NbtTrace(NBT_TRACE_OUTBOUND, ("%!FUNC! returns %!status! for %!NBTNAME!<%02x>",
                                status, pTracker->pConnEle->RemoteName, pTracker->pConnEle->RemoteName[15]));
        status = STATUS_BAD_NETWORK_PATH;
    }

    if (status == STATUS_SUCCESS &&
        IsDeviceNetbiosless(pTracker->pDeviceContext) &&
        !IsSmbBoundToOutgoingInterface(IpAddress)) {

        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        NbtTrace(NBT_TRACE_OUTBOUND,
                    ("Fail requests on unbound SmbDevice %!NBTNAME!<%02x>",
                    pTracker->pConnEle->RemoteName, (unsigned)pTracker->pConnEle->RemoteName[15]));
        status = STATUS_BAD_NETWORK_PATH;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // be sure that a close or disconnect has not come down and
    // cancelled the tracker
    //
    if (status == STATUS_PENDING) {
        // i.e. pending was returned rather than success
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        CTEExReleaseResource(&NbtConfig.Resource);
        return(status);
    }

    if (status == STATUS_SUCCESS) {
        if (DestIp) {
            IpAddress = DestIp;
        }
        if ((pTracker->Flags & TRACKER_CANCELLED)) {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, TRUE);
            status = STATUS_CANCELLED;
        } else {
            // set the session state to NBT_CONNECTING
            CHECK_PTR(pTracker->pConnEle);
            SET_STATE_UPPER (pTracker->pConnEle, NBT_CONNECTING);
            pTracker->pConnEle->BytesRcvd = 0;;
            pTracker->pConnEle->ReceiveIndicated = 0;

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtReConnect: Setting Up Session(cached entry!!) to %16.16s <%X>, %p\n",
                    pNameAddr->Name,pNameAddr->Name[15], pConnEle));

            CHECK_PTR(pConnEle);
            // keep track of the other end's ip address
            // There may be a valid name address to use or it may have been
            // nulled out to signify "Do Another Name Query"

            pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);
            SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_CONNECTING);

            pTracker->pTrackerWorker = NULL;

            //
            // We need to keep the pNameAddr data available for RAS
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL);

            pTracker->RemoteIpAddress = IpAddress;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            status = TcpSessionStart(pTracker,
                                     IpAddress,
                                     (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                     SessionStartupContinue,
                                     pTracker->DestPort);

            CTEExReleaseResource(&NbtConfig.Resource);

            //
            // if TcpSessionStart fails for some reason it will still
            // call the completion routine which will look after
            // cleaning up
            //

#ifdef RASAUTODIAL
            //
            // Notify the automatic connection driver
            // of the successful connection.
            //
            if (fAcdLoadedG && NT_SUCCESS(status))
            {
                CTELockHandle adirql;
                BOOLEAN fEnabled;

                CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                if (fEnabled) {
                    NbtNoteNewConnection(pNameAddr, pDeviceContext->IpAddress);
                }
            }
#endif // RASAUTODIAL

            //
            // pNameAddr was referenced above for RAS, so deref it now!
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL, FALSE);
            return(status);
        }
    }

    //
    // *** Error Handling Here ***
    //
    // ** We are still holding the JointLock **
    // unlink from the active connection list and put on idle list
    //
    CHECK_PTR(pConnEle);
    RelistConnection(pConnEle);
    CTESpinLock(pConnEle,OldIrq1);

    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    pConnEle->pIrp = NULL;

    if (pLowerConn = pConnEle->pLowerConnId) {
        CHECK_PTR(pLowerConn);
        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

        // need to increment the ref count for DelayedCleanupAfterDisconnect to
        // work correctly since it assumes the connection got fully connected
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        ASSERT(pLowerConn->RefCount == 2);
        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT)) {
            pDeviceContext = pLowerConn->pDeviceContext;
        } else {
            pDeviceContext = NULL;
        }

        CTEQueueForNonDispProcessing (DelayedCleanupAfterDisconnect,
                                      NULL,
                                      pLowerConn,
                                      NULL,
                                      pDeviceContext,
                                      TRUE);
    }

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    //
    // Undo the two references done above
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

    return(status);
}

//----------------------------------------------------------------------------
extern
VOID
DelayedReConnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   DestAddr,
    IN  PVOID                   pUnused1,
    IN  tDEVICECONTEXT          *pUnused2
    )

/*++
Routine Description:

    This Routine handles seting up a DPC to send a session pdu so that the stack
    does not get wound up in multiple sends for the keep alive timeout case.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/
{
    NTSTATUS                status;
    tCONNECTELE             *pConnEle;
    CTELockHandle           OldIrq;
    PCTE_IRP                pIrp;

    CHECK_PTR(pTracker);
    // for retarget this is the destination address to connect to.

    pConnEle = pTracker->pConnEle;
    pTracker->pTimer = NULL;
    if (pTracker->Flags & TRACKER_CANCELLED)
    {
        CTELockHandle           OldIrq1;

        //
        // the connection setup got cancelled, return the connect irp
        //
        CTESpinLock(pConnEle,OldIrq1);
        if (pIrp = pConnEle->pIrp)
        {
            pConnEle->pIrp = NULL;
            CTESpinFree(pConnEle,OldIrq1);
            CTEIoComplete(pIrp,STATUS_CANCELLED,0);
        }
        else
        {
            CTESpinFree(pConnEle,OldIrq1);
        }

        //
        // if SessionSetupContinue has run, it has set the refcount to zero
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        if (pTracker->RefConn == 0)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        }
        else
        {
            pTracker->RefConn--;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        return;

    }

    PUSH_LOCATION(0x85);
    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    status = NbtReConnect(pTracker, PtrToUlong(DestAddr));


    if (!NT_SUCCESS(status))
    {
        // Reset the Irp pending flag
        // No need to do this - pending has already be returned.
        //CTEResetIrpPending(pConnEle->pIrp);

        //
        // tell the client that the session setup failed
        //
        CTELockHandle           OldIrq1;

        CTESpinLock(pConnEle,OldIrq1);
        if (pIrp = pConnEle->pIrp)
        {
            pConnEle->pIrp = NULL;
            CTESpinFree(pConnEle,OldIrq1);

            CTEIoComplete( pIrp, STATUS_REMOTE_NOT_LISTENING, 0 ) ;
        } else {
            CTESpinFree(pConnEle,OldIrq1);
        }
    }
}

//----------------------------------------------------------------------------
NTSTATUS
NbtConnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    )

/*++
Routine Description:

    This Routine handles setting up a connection (netbios session) to
    destination. This routine is also called by the Reconnect code when
    doing a Retarget or trying to reach a destination that does not have
    a listen currently posted.  In this case the parameters mean different
    things.  pIrp could be a new Ipaddress to use (Retarget) and pCallinfo
    will be null.

Arguments:


Return Value:

    TDI_STATUS - status of the request

--*/

{
    tCONNECTELE             *pConnEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    BOOLEAN                 fNoIpAddress;

    pConnEle = pRequest->Handle.ConnectionContext;
    if (!pConnEle->pClientEle) {
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    ASSERT(pCallInfo);

    //
    // this code handles the When DHCP has not assigned an IP address yet
    //
    fNoIpAddress = (!pConnEle->pClientEle->pDeviceContext->pSessionFileObject) ||
         (pConnEle->pClientEle->pDeviceContext->IpAddress == 0);
#ifdef RASAUTODIAL
    if (fNoIpAddress && fAcdLoadedG) {
        CTELockHandle adirql;
        BOOLEAN fEnabled;

        //
        // There is no IP address assigned to the interface,
        // attempt to create an automatic connection.
        //
        CTEGetLock(&AcdDriverG.SpinLock, &adirql);
        fEnabled = AcdDriverG.fEnabled;
        CTEFreeLock(&AcdDriverG.SpinLock, adirql);
        if (fEnabled)
        {
            //
            // Set a special cancel routine on the irp
            // in case we get cancelled during the
            // automatic connection.
            //
            (VOID)NbtSetCancelRoutine( pIrp, NbtCancelPreConnect, pConnEle->pClientEle->pDeviceContext);
            if (NbtAttemptAutoDial(
                  pConnEle,
                  pTimeout,
                  pCallInfo,
                  pIrp,
                  0,
                  NbtRetryPreConnect))
            {
                return STATUS_PENDING;
            }
            //
            // We did not enqueue the irp on the
            // automatic connection driver, so
            // clear the cancel routine we set
            // above.
            //
            (VOID)NbtCancelCancelRoutine(pIrp);
        }
    }
#endif // RASAUTODIAL

    if (fNoIpAddress) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("%!FUNC! returns STATUS_BAD_NETWORK_PATH"));
        return(STATUS_BAD_NETWORK_PATH);
    }

    // check the connection element for validity
    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status)
    return NbtConnectCommon(pRequest, pTimeout, pCallInfo, pIrp);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtConnectCommon(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    )

/*++
Routine Description:

    This Routine handles setting up a connection (netbios session) to
    destination. This routine is also called by the DelayedReconnect code when
    doing a Retarget or trying to reach a destination that does not have
    a listen currently posted.  In this case the parameters mean different
    things.  pIrp could be a new Ipaddress to use (Retarget) and pCallinfo
    will be null.

Arguments:


Return Value:

    TDI_STATUS - status of the request

--*/

{
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
    tCONNECTELE             *pConnEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    tIPADDRESS              IpAddress;
    PCHAR                   pToName;
    USHORT                  sLength;
    tSESSIONREQ             *pSessionReq = NULL;
    PUCHAR                  pCopyTo;
    tCLIENTELE              *pClientEle;
    ULONG                   NameLen;
    tDGRAM_SEND_TRACKING    *pTracker, *pQueryTracker;
    tNAMEADDR               *pNameAddr;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    tIPADDRESS              RemoteIpAddress;
    tLOWERCONNECTION        *pLowerDump;
    PLIST_ENTRY             pEntry;
    PCHAR                   pSessionName;
    tDEVICECONTEXT          *pDeviceContextOut = NULL;

#ifdef _PNP_POWER_
    if (NbtConfig.Unloading) {
        KdPrint (("Nbt.NbtConnectCommon: --> ERROR New Connect request while Unloading!!!\n"));
        NbtTrace(NBT_TRACE_OUTBOUND, ("ERROR New Connect request while Unloading!!!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#endif  // _PNP_POWER_

#ifdef DBG
    {
        PIO_STACK_LOCATION pIrpSp;
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        ASSERT(pIrpSp && pIrpSp->CompletionRoutine == NbtpConnectCompletionRoutine);
    }
#endif

    ASSERT (pCallInfo);

    /* If it is from local Irp, we always send an internal address format */
    if (pCallInfo->RemoteAddressLength < sizeof (TA_NETBT_INTERNAL_ADDRESS)) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    ASSERT(((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
    CTEMemCopy(&TdiAddr,
            (PTDI_ADDRESS_NETBT_INTERNAL)((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].Address,
            sizeof(TdiAddr));

    pToName = TdiAddr.OEMRemoteName.Buffer;
    NameLen = TdiAddr.OEMRemoteName.Length;

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.NbtConnectCommon: Remote Name: %*.*s, Length=%d\n", NameLen, NameLen, pToName, NameLen));

    pConnEle = pRequest->Handle.ConnectionContext;

    if (RemoteIpAddress = Nbt_inet_addr(pToName, SESSION_SETUP_FLAG)) {
        pDeviceContextOut = GetDeviceFromInterface (htonl(RemoteIpAddress), TRUE);
    }

    //
    // Acquire this resource to co-ordinate with DHCP changing the IP
    // address
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    NbtTrace(NBT_TRACE_OUTBOUND, ("Connecting to %!NBTNAME!<%02x> pConnEle=<%p> pIrp=%p",
                pToName, (unsigned)pToName[15], pConnEle, pIrp));
    if ((!(NBT_VERIFY_HANDLE(pConnEle, NBT_VERIFY_CONNECTION))) || (!(pClientEle = pConnEle->pClientEle))) {
        KdPrint (("Nbt.NbtConnectCommon: --> ERROR Address not associated for pConnEle=<%p>\n", pConnEle));
        NbtTrace(NBT_TRACE_OUTBOUND, ("ERROR Address not associated for %!NBTNAME!<%02x> pConnEle=<%p>",
                    pToName, (unsigned)pToName[15], pConnEle));
        if (pDeviceContextOut) {
            NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return(STATUS_INVALID_ADDRESS);
    }

    CTESpinLock(pClientEle,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);
    pDeviceContext = pClientEle->pDeviceContext;

    status = CheckConnect(pConnEle, pClientEle, pDeviceContext);
    if (status != STATUS_SUCCESS) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("CheckConnect return %!status! for %!NBTNAME!<%02x>",
                    status, pToName, (unsigned)pToName[15]));
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        if (pDeviceContextOut) {
            NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return status;
    }

    if (RemoteIpAddress && NbtConfig.ConnectOnRequestedInterfaceOnly &&
            !IsDeviceNetbiosless(pDeviceContext) && pDeviceContext != pDeviceContextOut) {
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        if (pDeviceContextOut) {
            NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        NbtTrace(NBT_TRACE_OUTBOUND, ("Fail for %!ipaddr! because Outgoing interface != RequestedInterface",
                    RemoteIpAddress));
        return STATUS_BAD_NETWORK_PATH;
    }

    SET_STATE_UPPER (pConnEle, NBT_CONNECTING);

    // Increment the ref count so that a cleanup cannot remove
    // the pConnEle till the session is setup - one of these is removed when
    // the session is setup and the other is removed when it is disconnected.
    //
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    ASSERT(pConnEle->RefCount >= 3);
    //
    // unlink the connection from the idle connection list and put on active list
    //
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientEle->ConnectActive,&pConnEle->Linkage);

    // this field is used to hold a disconnect irp if it comes down during
    // NBT_CONNECTING or NBT_SESSION_OUTBOUND states
    //
    pConnEle->pIrpDisc = NULL;

    // we must store the client's irp in the connection element so that when
    // the session sets up, we can complete the Irp.
    ASSERT (pIrp);
    pConnEle->pIrp = (PVOID) pIrp;
    pConnEle->Orig = TRUE;
    pConnEle->SessionSetupCount = NBT_SESSION_SETUP_COUNT-1; // -1 for this attempt
    pConnEle->pClientEle->AddressType = TdiAddr.AddressType;
    pConnEle->AddressType = TdiAddr.AddressType;
    //
    //  Save the remote name while we still have it
    //
    CTEMemCopy (pConnEle->RemoteName, pToName, NETBIOS_NAME_SIZE);
    if (TdiAddr.OEMEndpointName.Buffer) {
        CTEMemCopy (pConnEle->pClientEle->EndpointName, TdiAddr.OEMEndpointName.Buffer, NETBIOS_NAME_SIZE);
    }

    // get a buffer for tracking Session setup
    status = GetTracker(&pTracker, NBT_TRACKER_CONNECT);
    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Out of memory (no-Tracker) for %!NBTNAME!<%02x>", pToName, (unsigned)pToName[15]));
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitProc;
    }

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.NbtConnectCommon: Tracker %lx\n",pTracker));

    // the length of the Session Request Pkt is the 4 byte session hdr length + the
    // half ascii calling and called names + the scope length times 2, one for each name
    //
    sLength = (USHORT) (sizeof(tSESSIONREQ) + (NETBIOS_NAME_SIZE << 2) + (NbtConfig.ScopeLength <<1));

    pTracker->pNetbiosUnicodeEX = TdiAddr.pNetbiosUnicodeEX;
    pTracker->UnicodeRemoteName = NULL;
    if (TdiAddr.pNetbiosUnicodeEX) {
        pTracker->ucRemoteName = TdiAddr.pNetbiosUnicodeEX->RemoteName;
        ASSERT((pTracker->ucRemoteName.MaximumLength % sizeof(WCHAR)) == 0);
        ASSERT((pTracker->ucRemoteName.Length % sizeof(WCHAR)) == 0);

        if (TdiAddr.pNetbiosUnicodeEX->NameBufferType != NBT_WRITEONLY) {
            pTracker->UnicodeRemoteName = NbtAllocMem(pTracker->ucRemoteName.MaximumLength, NBT_TAG('F'));
            if (pTracker->UnicodeRemoteName) {
                pTracker->UnicodeRemoteNameLength = pTracker->ucRemoteName.Length;
                CTEMemCopy(pTracker->UnicodeRemoteName, pTracker->ucRemoteName.Buffer,
                        pTracker->ucRemoteName.Length+sizeof(WCHAR));
            }
        }
        // we ignore the failure because it isn't a critical feature. This failure only cause us not able to
        // take advantage of the UNICODE information and return the resolved DNS name to RDR.
    } else {
        pTracker->ucRemoteName.Buffer = NULL;
        pTracker->ucRemoteName.Length = 0;
        pTracker->ucRemoteName.MaximumLength = 0;
    }

    /*
     * Other netbt routines always assume that we have at least 16 bytes
     * for remote name.
     */
    if (NameLen < NETBIOS_NAME_SIZE) {
        pTracker->pRemoteName = NbtAllocMem(NETBIOS_NAME_SIZE, NBT_TAG('F'));
    } else {
        pTracker->pRemoteName = NbtAllocMem(NameLen, NBT_TAG('F'));
    }
    pSessionReq = (tSESSIONREQ *)NbtAllocMem(sLength,NBT_TAG('G'));

    if (pTracker->pRemoteName == NULL || pSessionReq == NULL) {
        if (pTracker->pRemoteName) {
            CTEMemFree(pTracker->pRemoteName);
            pTracker->pRemoteName = NULL;
        }
        if (pTracker->UnicodeRemoteName) {
            CTEMemFree(pTracker->UnicodeRemoteName);
            pTracker->UnicodeRemoteName = NULL;
        }
        if (pSessionReq) {
            CTEMemFree(pSessionReq);
            pSessionReq = NULL;
        }
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        status = STATUS_INSUFFICIENT_RESOURCES;
        NbtTrace(NBT_TRACE_OUTBOUND, ("Out of memory for %!NBTNAME!<%02x>", pToName, (unsigned)pToName[15]));
        goto ExitProc;
    }

    CTEMemCopy (pTracker->pRemoteName, pToName, NameLen);
    pTracker->RemoteNameLength      = NameLen;      // May be needed for Dns Name resolution
    pTracker->pDestName             = pTracker->pRemoteName;
    pTracker->UnicodeDestName       = pTracker->UnicodeRemoteName;   // bug #20697, #95241
    pTracker->SendBuffer.pBuffer    = pTracker->pRemoteName;
    pTracker->SendBuffer.Length     = 0;
    pTracker->SendBuffer.pDgramHdr  = pSessionReq;

    // this is a ptr to the name in the client's, Irp, so that address must
    // remain valid until this completes.  It should be valid, because we
    // do not complete the Irp until the transaction completes.  This ptr
    // is overwritten when the name resolves, so that it points the the
    // pNameAddr in the hash table.
    //
    pTracker->RefCount              = 1;
    pTracker->RefConn               = 1;
    pTracker->pClientIrp            = pIrp;
    pTracker->pTimeout              = pTimeout; // the timeout value is passed on through to the transport
    pTracker->Flags                 = SESSION_SETUP_FLAG;
    pTracker->pDeviceContext        = pDeviceContext;
    pTracker->pConnEle              = pConnEle;
#ifdef _NETBIOSLESS
    pTracker->DestPort              = pDeviceContext->SessionPort; // Port to Send to
#else
    pTracker->DestPort              = NBT_SESSION_TCP_PORT;
#endif

#ifndef VXD
    if (pConnEle->pClientEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
    {
       pSessionName = pConnEle->pClientEle->EndpointName;
    }
    else
#endif
    {
       pSessionName = pToName;
    }

    pSessionReq->Hdr.Type   = NBT_SESSION_REQUEST;
    pSessionReq->Hdr.Flags  = NBT_SESSION_FLAGS;
    pSessionReq->Hdr.Length = (USHORT)htons(sLength-(USHORT)sizeof(tSESSIONHDR));  // size of called and calling NB names.

    pTracker->SendBuffer.HdrLength = (ULONG)sLength;

    // put the Dest HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii ((PCHAR)&pSessionReq->CalledName.NameLength,
                                  pSessionName,
                                  NbtConfig.pScope,
                                  NbtConfig.ScopeLength);

    // put the Source HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii (pCopyTo,
                                  ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name,
                                  NbtConfig.pScope,
                                  NbtConfig.ScopeLength);

    // store the tracker in the Irp Rcv ptr so it can be used by the
    // session setup code in hndlrs.c in the event the destination is
    // between posting listens and this code should re-attempt the
    // session setup.  The code in hndlrs.c returns the tracker to its
    // free list and frees the session hdr memory too.
    //
    // We need to set this while holding the ConnEle lock because the client
    // can call NbtDisconnect while we are opening a Tcp handle and try to
    // set the Tracker's flag to TRACKER_CANCELLED
    //
    pConnEle->pIrpRcv = (PIRP)pTracker;

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(pClientEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    // open a connection with the transport for this session
    status = NbtOpenAndAssocConnection (pDeviceContext, pConnEle, &pConnEle->pLowerConnId, '3'); 
    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("NbtOpenAndAssocConnection return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
                status, pToName, (unsigned)pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
        goto NbtConnect_Check;
    }

    // We need to track that this side originated the call so we discard this
    // connection at the end
    //
    pConnEle->pLowerConnId->bOriginator = TRUE;

    // set this state to associated so that the cancel irp routine
    // can differentiate the name query stage from the setupconnection
    // stage since pConnEle is in the Nbtconnecting state for both.
    //
    SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_ASSOCIATED);

    // if this routine is called to do a reconnect, DO NOT close another
    // Lower Connection since one was closed the on the first
    // connect attempt.
    //
    // remove a lower connection from the free list attached to the device
    // context since when this pConnEle was created, a lower connectin
    // was created then incase inbound calls were to be accepted on the
    // connection.  But since it is an outbound call, remove a lower
    // connection.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);  // Need this for DerefLowerConn
    CTESpinLock(pDeviceContext,OldIrq1);
    if (!pConnEle->LowerConnBlockRemoved &&
        !IsListEmpty(&pDeviceContext->LowerConnFreeHead))
    {
        pEntry = RemoveHeadList(&pDeviceContext->LowerConnFreeHead);
        pLowerDump = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

        pConnEle->LowerConnBlockRemoved = TRUE;

        //
        // close the lower connection with the transport
        //
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtConnectCommon: On Connect, close handle for pLower=<%p>\n", pLowerDump));
        NBT_DEREFERENCE_LOWERCONN (pLowerDump, REF_LOWC_CREATE, TRUE);
    }

    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    //
    // Check if the destination name is an IP address
    //
#ifndef VXD
    if (RemoteIpAddress)
    {
        //
        // Tell Outbound() not to schedule a re-connect attempt when a negative response is received.
        // Otherwise, we may end up with indefinitely loop
        //
        pTracker->ResolutionContextFlags = 0xFF;

        //
        // If the Address type is TDI_ADDRESS_TYPE_NETBIOS_EX, we have
        // been given a specific endpoint to use, so try to setup the
        // session using that Endpoint only
        //
        if (pConnEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
        {
            //
            // add this IP address to the remote hashtable
            //
            status = LockAndAddToHashTable(NbtConfig.pRemoteHashTbl,
                                           pToName,
                                           NbtConfig.pScope,
                                           RemoteIpAddress,
                                           NBT_UNIQUE,
                                           NULL,
                                           NULL,
                                           pDeviceContextOut,
                                           NAME_RESOLVED_BY_IP);
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NbtConnectCommon: AddRecordToHashTable <%-16.16s:%x>, Status %x\n",
                    pToName, pToName[15], status));

            if (NT_SUCCESS (status))    // SUCCESS if added first time, PENDING if name already existed!
            {
                SessionSetupContinue(pTracker, STATUS_SUCCESS);
                status = STATUS_PENDING;
            } else {
                NbtTrace(NBT_TRACE_OUTBOUND, ("LockAndAddToHashTable return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
                    status, pToName, pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
            }
        }
        //
        // Address type is TDI_ADDRESS_TYPE_NETBIOS
        // The endpoint name is the same as the IP address, so send a NodeStatus
        // request to the remote machine to get a proper Endpoint name
        //
        else
        {
            //
            // NbtSendNodeStatus will either return Pending or error -- it
            // should never return success!
            //
            pTracker->CompletionRoutine = SessionSetupContinue;
            status = NbtSendNodeStatus(pDeviceContext,
                                       pToName,
                                       NULL,
                                       pTracker,
                                       ExtractServerNameCompletion);
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("NbtSendNodeStatus return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
                    status, pToName, pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
            }
        }
    }
    else    // the name is not an IP address!
#endif
    {
        if (NameLen <= NETBIOS_NAME_SIZE) {
           status = FindNameOrQuery(pToName,
                                    pDeviceContext,
                                    SessionSetupContinue,
                                    pTracker,
                                    (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                                    &IpAddress,
                                    &pNameAddr,
                                    REF_NAME_CONNECT,
                                    FALSE);
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NbtConnectCommon: name=<%*.*s:%x>, Len=%d, Status=%lx (%d of %s)\n",
                    NameLen, NameLen, pConnEle->RemoteName,
                    pConnEle->RemoteName[15], NameLen, status, __LINE__, __FILE__));
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("FindNameOrQuery return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
                    status, pToName, pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
            } else if (NULL != pNameAddr && NULL != pNameAddr->FQDN.Buffer &&
                    pTracker->pNetbiosUnicodeEX &&
                    (pTracker->pNetbiosUnicodeEX->NameBufferType == NBT_READWRITE ||
                    pTracker->pNetbiosUnicodeEX->NameBufferType == NBT_WRITEONLY)) {

                USHORT  NameLength, MaxLength;

                NameLength = pNameAddr->FQDN.Length;
                MaxLength = pTracker->pNetbiosUnicodeEX->RemoteName.MaximumLength;
                if ((SHORT)NameLength > (SHORT)(MaxLength - sizeof(WCHAR))) {
                    NameLength = MaxLength - sizeof(WCHAR);
                }
                if ((SHORT)NameLength >= 0) {
                    CTEMemCopy(pTracker->pNetbiosUnicodeEX->RemoteName.Buffer,
                            pNameAddr->FQDN.Buffer, NameLength);
                    pTracker->pNetbiosUnicodeEX->RemoteName.Buffer[NameLength/sizeof(WCHAR)] = L'\0';
                    pTracker->pNetbiosUnicodeEX->RemoteName.Length = NameLength;
                    pTracker->pNetbiosUnicodeEX->NameBufferType    = NBT_WRITTEN;
                }
            }
        }

        //
        // if the name is longer than 16 bytes, it's not a netbios name.
        // skip wins, broadcast etc. and go straight to dns resolution
        // Also, we would go to DNS if the request came over the SmbDevice
        //
#ifdef _NETBIOSLESS
        if ((NameLen > NETBIOS_NAME_SIZE) ||
            ((IsDeviceNetbiosless(pDeviceContext)) && (!NT_SUCCESS(status))))
#else
        if (NameLen > NETBIOS_NAME_SIZE)
#endif
        {
            pTracker->AddressType = pConnEle->AddressType;
#ifndef VXD
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NbtConnectCommon: $$$$$ DNS for NETBIOS name=<%*.*s:%x>, Len=%d, Status=%lx (%d of %s)\n",
                    NameLen, NameLen, pConnEle->RemoteName,
                    pConnEle->RemoteName[15], NameLen, status, __LINE__, __FILE__));
#endif

            if (pContext = (NBT_WORK_ITEM_CONTEXT *)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG('H'))) {
                pContext->pTracker = NULL;              // no query tracker
                pContext->pClientContext = pTracker;    // the client tracker
                pContext->ClientCompletion = SessionSetupContinue;
                pContext->pDeviceContext = pDeviceContext;

                //
                // Start the timer so that the request does not hang waiting for Dns!
                //
                StartLmHostTimer(pContext, FALSE);
                status = NbtProcessLmhSvcRequest (pContext, NBT_RESOLVE_WITH_DNS);
                if (!NT_SUCCESS (status)) {
                    NbtTrace(NBT_TRACE_OUTBOUND, ("NbtProcessLmhSvcRequest return %!status! for "
                                                "%!NBTNAME!<%02x> %Z %!ipaddr!",
                                status, pToName, pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
                    CTEMemFree(pContext);
                }
            } else {
                KdPrint(("Nbt.NbtConnectCommon: Couldn't alloc mem for pContext\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;
                NbtTrace(NBT_TRACE_OUTBOUND, ("Out of memory for %!NBTNAME!<%02x>", pToName, (unsigned)pToName[15]));
            }
        }
    }

NbtConnect_Check:
    if ((status == STATUS_SUCCESS) && (!IpAddress)) {
        ASSERT(0);
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        NbtTrace(NBT_TRACE_OUTBOUND, ("Unexpected success: %!ipaddr!", IpAddress));
        status = STATUS_BAD_NETWORK_PATH;
    }

    if (status == STATUS_SUCCESS &&
        IsDeviceNetbiosless(pTracker->pDeviceContext) &&
        !IsSmbBoundToOutgoingInterface(IpAddress)) {

        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        NbtTrace(NBT_TRACE_OUTBOUND, ("Fail requests on unbound SmbDevice %!NBTNAME!<%02x>",
                        pToName, (unsigned)pToName[15]));
        status = STATUS_BAD_NETWORK_PATH;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pDeviceContextOut) {
        NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        pDeviceContextOut = NULL;
    }

    //
    // be sure that a close or disconnect has not come down and
    // cancelled the tracker
    //
    if (status == STATUS_PENDING) {
        // i.e. pending was returned rather than success
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        CTEExReleaseResource(&NbtConfig.Resource);
        return(status);
    }

    if (status == STATUS_SUCCESS)
    {
        if ((pTracker->Flags & TRACKER_CANCELLED))
        {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, TRUE);
            status = STATUS_CANCELLED;
        }
        else    // connect as long as we have an IP address (even to group names)
        {
            // set the session state to NBT_CONNECTING
            CHECK_PTR(pTracker->pConnEle);
            SET_STATE_UPPER (pTracker->pConnEle, NBT_CONNECTING);
            pTracker->pConnEle->BytesRcvd = 0;;
            pTracker->pConnEle->ReceiveIndicated = 0;

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtConnectCommon: Setting Up Session(cached entry!!) to %16.16s <%X>, %p\n",
                    pNameAddr->Name,pNameAddr->Name[15], pConnEle));

            CHECK_PTR(pConnEle);
            // keep track of the other end's ip address
            // There may be a valid name address to use or it may have been
            // nulled out to signify "Do Another Name Query"

            pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);
            SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_CONNECTING);

            pTracker->pTrackerWorker = NULL;

            //
            // We need to keep the pNameAddr data available for RAS
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL);

            pTracker->RemoteIpAddress = IpAddress;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            status = TcpSessionStart(pTracker,
                                     IpAddress,
                                     (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                     SessionStartupContinue,
                                     pTracker->DestPort);

            CTEExReleaseResource(&NbtConfig.Resource);
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("TcpSessionStart return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
                        status, pToName, (unsigned)pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
            }

            //
            // if TcpSessionStart fails for some reason it will still
            // call the completion routine which will look after
            // cleaning up
            //

#ifdef RASAUTODIAL
            //
            // Notify the automatic connection driver
            // of the successful connection.
            //
            if (fAcdLoadedG && NT_SUCCESS(status))
            {
                CTELockHandle adirql;
                BOOLEAN fEnabled;

                CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                if (fEnabled)
                {
                    NbtNoteNewConnection(pNameAddr, pDeviceContext->IpAddress);
                }
            }
#endif // RASAUTODIAL

            //
            // pNameAddr was referenced above for RAS, so deref it now!
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL, FALSE);
            return(status);
        }
    }

    //
    // *** Error Handling Here ***
    //
    // ** We are still holding the JointLock **
    // unlink from the active connection list and put on idle list
    //
    CHECK_PTR(pConnEle);
    RelistConnection(pConnEle);
    CTESpinLock(pConnEle,OldIrq1);

    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    pConnEle->pIrp = NULL;

    if (pLowerConn = pConnEle->pLowerConnId)
    {
        CHECK_PTR(pLowerConn);
        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

        // need to increment the ref count for DelayedCleanupAfterDisconnect to
        // work correctly since it assumes the connection got fully connected
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        ASSERT(pLowerConn->RefCount == 2);
        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }
        else
        {
            pDeviceContext = NULL;
        }

        CTEQueueForNonDispProcessing (DelayedCleanupAfterDisconnect,
                                      NULL,
                                      pLowerConn,
                                      NULL,
                                      pDeviceContext,
                                      TRUE);
    }

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    //
    // Undo the two references done above
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    NbtTrace(NBT_TRACE_OUTBOUND, ("NbtConnectCommon return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
            status, pToName, (unsigned)pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));

    return(status);


ExitProc:
    pConnEle->pIrp = NULL;

    //
    // Put the connection back on the idle connection list
    //
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientEle->ConnectHead,&pConnEle->Linkage);

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(pClientEle,OldIrq1);

    if (pDeviceContextOut) {
        NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        pDeviceContextOut = NULL;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq2);
    CTEExReleaseResource(&NbtConfig.Resource);

    //
    // Undo the two references done above
    //
    NBT_DEREFERENCE_CONNECTION(pConnEle, REF_CONN_SESSION);
    NBT_DEREFERENCE_CONNECTION(pConnEle, REF_CONN_CONNECT);

    NbtTrace(NBT_TRACE_OUTBOUND, ("NbtConnectCommon return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
            status, pToName, (unsigned)pToName[15], &pDeviceContext->BindName, pDeviceContext->IpAddress));
    return(status);
}

//----------------------------------------------------------------------------
VOID
CleanUpPartialConnection(
    IN NTSTATUS             status,
    IN tCONNECTELE          *pConnEle,
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN PIRP                 pClientIrp,
    IN CTELockHandle        irqlJointLock,
    IN CTELockHandle        irqlConnEle
    )
{
    CTELockHandle OldIrq;
    CTELockHandle OldIrq1;
    PIRP pIrpDisc;

    if (pConnEle->state != NBT_IDLE)
    {
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    }

    //
    // If the tracker is cancelled then NbtDisconnect has run and there is
    // a disconnect irp waiting to be returned.
    //
    pIrpDisc = NULL;

    if (pTracker->Flags & TRACKER_CANCELLED)
    {
        //
        // Complete the disconnect irp now too
        //
        pIrpDisc = pConnEle->pIrpDisc;
        status = STATUS_CANCELLED;
    }

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    //
    // this will close the lower connection and dereference pConnEle once.
    //
    QueueCleanup (pConnEle, &irqlJointLock, &irqlConnEle);

    CTESpinFree(pConnEle,irqlConnEle);

    //
    // If the state is IDLE it means that NbtCleanupConnection has run and
    // the connection has been removed from the  list so don't add it to
    // the list again
    //
    if (pConnEle->state != NBT_IDLE)
    {
        RelistConnection(pConnEle);
    }
    CTESpinFree(&NbtConfig.JointLock,irqlJointLock);

    //
    // remove the last reference added in nbt connect.  The refcount will be 2
    // if nbtcleanupconnection has not run and 1, if it has.  So this call
    // could free pConnEle.
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);

    if (status == STATUS_TIMEOUT)
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("%!FUNC! returns STATUS_BAD_NETWORK_PATH"));
        status = STATUS_BAD_NETWORK_PATH;
    }

    CTEIoComplete(pClientIrp,status,0L);

    //
    // This is a disconnect irp that has been queued till the name query
    // completed
    //
    if (pIrpDisc)
    {
        CTEIoComplete(pIrpDisc,STATUS_SUCCESS,0L);
    }
}

//----------------------------------------------------------------------------
VOID
SessionSetupContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        )
/*++

Routine Description

    This routine handles setting up a session after a name has been resolved
    to an IP address.

    This routine is given as the completion routine to the "QueryNameOnNet" call
    in NbtConnect, above.  When a name query response comes in or the
    timer times out after N retries, this routine is called passing STATUS_TIMEOUT
    for a failure.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    tNAMEADDR               *pNameAddr = NULL;
    ULONG                   lNameType;
    PIRP                    pClientIrp;
    PIRP                    pIrpDisc;
    ULONG                   IpAddress;
    tCONNECTELE             *pConnEle;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pConnEle = pTracker->pConnEle;
    CHECK_PTR(pConnEle);

    if (NT_SUCCESS(status)) {
        /*
         * Find the NameAddr and reference it
         */
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        CTESpinLock(pConnEle,OldIrq);
        lNameType = NAMETYPE_UNIQUE;
        pNameAddr = FindNameRemoteThenLocal(pTracker, &IpAddress, &lNameType);
        if (pNameAddr) {
            // increment so the name cannot disappear and to be consistent
            // with FindNameOrQuery , which increments the refcount, so
            // we always need to deref it when the connection is setup.
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT);
            // DEBUG
            ASSERT(pNameAddr->RefCount >= 2);
        } else {
            NbtTrace(NBT_TRACE_OUTBOUND, ("FindNameRemoteThenLocal return %!status! for %!NBTNAME!<%02x>",
                    status, pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
            status = STATUS_BAD_NETWORK_PATH;
        }
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    } else {
        NbtTrace(NBT_TRACE_OUTBOUND, ("SessionSetupContinue is called with %!status! for %!NBTNAME!<%02x>",
                    status, pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
    }

    /*
     * IsSmbBoundToOutgoingInterface won't work with JointLock held
     */
    if (NT_SUCCESS(status) &&
        IsDeviceNetbiosless(pTracker->pDeviceContext) &&
        !IsSmbBoundToOutgoingInterface(IpAddress)) {

        /* This status may be changed into STATUS_CANCELLED below */
        status = STATUS_BAD_NETWORK_PATH;
        NbtTrace(NBT_TRACE_OUTBOUND, ("Fail requests on unbound SmbDevice %!NBTNAME!<%02x>",
                        pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);

    if ((pTracker->Flags & TRACKER_CANCELLED) ||
        (!(pLowerConn = pConnEle->pLowerConnId)) ||     // The lower connection could have been cleaned up!
        (!NBT_VERIFY_HANDLE(pTracker->pDeviceContext, NBT_VERIFY_DEVCONTEXT)))
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Tracker is cancelled for %!NBTNAME!<%02x>",
                    pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
        status = STATUS_CANCELLED;
    }

    // this is the QueryOnNet Tracker ptr being cleared rather than the
    // session setup tracker.
    //
    pTracker->pTrackerWorker = NULL;

    if (status == STATUS_SUCCESS)
    {
        // check the Remote table and then the Local table
        // a session can only be started with a unique named destination
        //
        if (lNameType & (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP))
        {
            // set the session state, initialize a few things and setup a
            // TCP connection, calling SessionStartupContinue when the TCP
            // connection is up
            //
            CHECK_PTR(pConnEle);
            SET_STATE_LOWER (pLowerConn, NBT_CONNECTING);

            SET_STATE_UPPER (pConnEle, NBT_CONNECTING);
            pConnEle->BytesRcvd = 0;;
            pConnEle->ReceiveIndicated = 0;
            CHECK_PTR(pTracker);
            pTracker->pNameAddr = pNameAddr;

            if (NULL == pNameAddr->FQDN.Buffer && pTracker->pNetbiosUnicodeEX &&
                pTracker->pNetbiosUnicodeEX->NameBufferType == NBT_WRITTEN) {
                //
                // FQDN is available
                //  Save it into the pNameAddr
                //
                pNameAddr->FQDN.Buffer = NbtAllocMem(
                        pTracker->pNetbiosUnicodeEX->RemoteName.Length + sizeof(WCHAR),
                        NBT_TAG('F'));
                if (NULL != pNameAddr->FQDN.Buffer) {
                    pNameAddr->FQDN.Length = pTracker->pNetbiosUnicodeEX->RemoteName.Length;
                    pNameAddr->FQDN.MaximumLength = pNameAddr->FQDN.Length + sizeof(WCHAR);
                    CTEMemCopy(pNameAddr->FQDN.Buffer,
                        pTracker->pNetbiosUnicodeEX->RemoteName.Buffer,
                        pNameAddr->FQDN.Length
                        );
                    pNameAddr->FQDN.Buffer[pNameAddr->FQDN.Length/sizeof(WCHAR)] = L'\0';
                }
            }

            // keep track of the other end's ip address
            pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);

            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.SessionSetupContinue: Setting Up Session(after Query) to %16.16s <%X>, %p\n",
                            pNameAddr->Name,pNameAddr->Name[15],
                            pTracker->pConnEle));

            ASSERT(pNameAddr->RefCount >= 2);
            //
            // increment pNameAddr once more since we may need to access
            // it below for RAS sessions
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL);

            pDeviceContext = pTracker->pDeviceContext;
            pTracker->RemoteIpAddress = IpAddress;

            CTESpinFree(pConnEle,OldIrq);
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            // start the session...
            status = TcpSessionStart (pTracker,
                                      IpAddress,
                                      (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                      SessionStartupContinue,
                                      pTracker->DestPort);
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("TcpSessionStart return %!status! for %!NBTNAME!<%02x> %Z %!ipaddr!",
                        status, pTracker->pDestName, (unsigned)pTracker->pDestName[15],
                        &pTracker->pDeviceContext->BindName, pTracker->pDeviceContext->IpAddress));
            }


            //
            // the only failure that could occur is if the pLowerConn
            // got separated from pConnEle, in which case some other
            // part of the code has disconnected and cleanedup, so
            // just return
            //

#ifdef RASAUTODIAL
            //
            // Notify the automatic connection driver
            // of the successful connection.
            //
            if (fAcdLoadedG && NT_SUCCESS(status))
            {
                CTELockHandle adirql;
                BOOLEAN fEnabled;

                CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                if (fEnabled)
                {
                    NbtNoteNewConnection(pNameAddr, pDeviceContext->IpAddress);
                }
            }
#endif // RASAUTODIAL

            //
            // pNameAddr was referenced above for RAS, so deref it now!
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL, FALSE);
            return;
        }
        status = STATUS_BAD_NETWORK_PATH;
    }
    if (pNameAddr) {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, TRUE);
    }

    pClientIrp = pConnEle->pIrp;
    pConnEle->pIrp = NULL;

    if (STATUS_REMOTE_NOT_LISTENING != status)      // set in ExtractServerNameCompletion
    {
        status = STATUS_HOST_UNREACHABLE;
    }

    CleanUpPartialConnection(status, pConnEle, pTracker, pClientIrp, OldIrq1, OldIrq);
}

//----------------------------------------------------------------------------
VOID
QueueCleanup(
    IN  tCONNECTELE     *pConnEle,
    IN  CTELockHandle   *pOldIrqJointLock,
    IN  CTELockHandle   *pOldIrqConnEle
    )
/*++
Routine Description

    This routine handles Queuing a request to a worker thread to cleanup
    a connection(which basically closes the connection).

    This routine is called with the JointLock + ConnEle locks held
    and returns with them held

Arguments:

    pConnEle   - ptr to the upper connection

Return Values:

    VOID

--*/

{
    NTSTATUS            status;
    CTELockHandle       OldIrq;
    ULONG               State;
    BOOLEAN             DerefConnEle;
    tLOWERCONNECTION    *pLowerConn;
    tDEVICECONTEXT      *pDeviceContext = NULL;

    // to coordinate with RejectSession in hndlrs.c we are holding the spin lock
    // so we don't disconnect twice.
    //
    if ((pLowerConn = pConnEle->pLowerConnId) &&
        (pLowerConn->Verify == NBT_VERIFY_LOWERCONN) &&
        (pLowerConn->State > NBT_IDLE) &&
        (pLowerConn->State < NBT_DISCONNECTING))
    {

        CTESpinLock(pLowerConn,OldIrq);

        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
        if (pLowerConn->Verify != NBT_VERIFY_LOWERCONN)
        {
            //
            // The lower connection block has already been cleaned up
            // or is waiting to be cleaned up, so just return!
            //
// MALAM_FIX: Fix this so that we don't have to dereference the LowerConn to find this out.
// One scenario where this happens is if the device gets destroyed in DelayedNbtDeleteDevice
// and we end up dereferencing the lowerconn which causes it to get deleted!
//            ASSERT(0);
            CTESpinFree(pLowerConn,OldIrq);

            return;
        }

        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.QueueCleanup: State=%X, Lower=%X Upper=%X\n",
                pLowerConn->State, pLowerConn,pLowerConn->pUpperConnection));

        CHECK_PTR(pLowerConn);
        State = pLowerConn->State;

        SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);

        if (pConnEle->state != NBT_IDLE)
        {
            SET_STATE_UPPER (pConnEle, NBT_DISCONNECTED);
        }

        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

        //
        // need to increment the ref count for DelayedCleanupAfterDisconnect to
        // work correctly since it assumes the connection got fully connected
        // Note: if this routine is called AFTER the connection is fully
        // connected such as in SessionStartupTimeout, then RefCount must
        // be decremented there to account for this increment.
        //
        if (State < NBT_SESSION_OUTBOUND)
        {
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        }

        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
        ASSERT (pLowerConn->RefCount > 1);

        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pConnEle,*pOldIrqConnEle);

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }

        status = CTEQueueForNonDispProcessing (DelayedCleanupAfterDisconnect,
                                               NULL,
                                               pLowerConn,
                                               NULL,
                                               pDeviceContext,
                                               TRUE);

        CTESpinFree(&NbtConfig.JointLock,*pOldIrqJointLock);

        //
        // when the lower no longer points to the upper undo the reference
        // done in NbtConnect, or InBound.
        //
        NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

        CTESpinLock(&NbtConfig.JointLock,*pOldIrqJointLock);
        CTESpinLock(pConnEle,*pOldIrqConnEle);
    }
}

//----------------------------------------------------------------------------
extern
NTSTATUS
StartSessionTimer(
    tDGRAM_SEND_TRACKING    *pTracker,
    tCONNECTELE             *pConnEle
    )

/*++
Routine Description

    This routine handles setting up a timer to time the connection setup.
    JointLock Spin Lock is held before calling this routine.

Arguments:

    pConnEle - ptr to the connection structure

Return Values:

    VOID

--*/

{
    NTSTATUS        status;
    ULONG           Timeout = 0;
    CTELockHandle   OldIrq;

    CTESpinLock(pConnEle,OldIrq);

    if (pTracker->pTimeout)
    {
        CTEGetTimeout(pTracker->pTimeout,&Timeout);
    }

    // now start a timer to time the return of the session setup
    // message
    //
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.StartSessionTimer: TimeOut = %X\n",Timeout));

    if (Timeout < NBT_SESSION_RETRY_TIMEOUT)
    {
        Timeout = NBT_SESSION_RETRY_TIMEOUT;
    }
    status = StartTimer(SessionStartupTimeout,
                        Timeout,
                        (PVOID)pTracker,       // context value
                        NULL,                  // context2 value
                        pTracker,
                        SessionStartupTimeoutCompletion,
                        pConnEle->pDeviceContext,
                        &pTracker->pTimer,
                        0,
                        TRUE);

    if (!NT_SUCCESS(status))
    {
        // we failed to get a timer, but the timer is only used
        // to handle the destination not responding to it is
        // not critical to get a timer... so carry on
        //
        CHECK_PTR(pTracker);
        pTracker->pTimer = NULL;
    }

    CTESpinFree(pConnEle,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
VOID
SessionStartupContinue(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles sending the session request PDU after the TCP
    connection has been setup to the destination IP address.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING        *pTracker;
    tCONNECTELE                 *pConnEle;
    ULONG                       lSentLength;
    TDI_REQUEST                 TdiRequest;
    PIRP                        pClientIrp;
    PIRP                        pIrpDisc = NULL;
    tLOWERCONNECTION            *pLowerConn;
    CTELockHandle               OldIrq;
    CTELockHandle               OldIrq1;
    BOOLEAN                     fNameReferenced = TRUE; // In FindNameOrQuery or SessionSetupContinue
    tNAMEADDR                   *pNameAddr;
    tDEVICECONTEXT              *pDeviceContext;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pConnEle = (tCONNECTELE *)pTracker->pConnEle;
    pDeviceContext = pTracker->pDeviceContext;

    ASSERT (pTracker->Verify == NBT_VERIFY_TRACKER);
    CHECK_PTR (pConnEle);

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);

    if (pTracker->Flags & TRACKER_CANCELLED)
    {
        status = STATUS_CANCELLED;
        pIrpDisc = pConnEle->pIrpDisc;  // Complete the Disconnect Irp that is pending too
        NbtTrace(NBT_TRACE_OUTBOUND, ("Tracker is cancelled for %!NBTNAME!<%02x>",
                    pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
    } else if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("SessionStartupContinue is called with %!status! for %!NBTNAME!<%02x> %Z",
                    status, pTracker->pDestName, (unsigned)pTracker->pDestName[15],
                    &pTracker->pDeviceContext->BindName));
    }

#ifdef MULTIPLE_WINS
    //
    // If we failed to establish a connection and we still have
    // not finished querying all the Name Servers, then continue
    // the Query process
    //
    if (NbtConfig.TryAllNameServers &&
#ifdef _NETBIOSLESS
        (!IsDeviceNetbiosless(pDeviceContext)) &&
#endif
        (pConnEle->pLowerConnId) &&
        (status != STATUS_CANCELLED) &&
        (!NT_SUCCESS(status)) &&
        (pTracker->ResolutionContextFlags != NAME_RESOLUTION_DONE))
    {
        SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_ASSOCIATED);

        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        //
        // See if we can get another IP address and re-try!
        //
        if (STATUS_PENDING == ContinueQueryNameOnNet (pTracker,
                                                      pTracker->pConnEle->RemoteName,
                                                      pDeviceContext,
                                                      SessionSetupContinue,
                                                      &fNameReferenced))
        {
            // i.e. pending was returned
            return;
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        CTESpinLock(pConnEle,OldIrq);
        NbtTrace(NBT_TRACE_OUTBOUND, ("ContinueQueryNameOnNet return something "
                    "other than STATUS_PENDING for %!NBTNAME!<%02x> %Z",
                    pTracker->pDestName, (unsigned)pTracker->pDestName[15], &pTracker->pDeviceContext->BindName));
    }
#endif

    //
    // Set the pBuffer ptr = NULL so that we don't try to
    // set it as the Mdl->Next ptr in TdiSend!
    //
    if (pTracker->SendBuffer.pBuffer)
    {
        pTracker->SendBuffer.pBuffer = NULL;
    }

    pLowerConn = pConnEle->pLowerConnId;
    if ((NT_SUCCESS(status)) &&
        (!pLowerConn))
    {
        // in case the connection got disconnected during the setup phase,
        // check the lower conn value
        NbtTrace(NBT_TRACE_OUTBOUND, ("The connection is reset during setup phase, %!NBTNAME!<%02x>, %Z",
                    pTracker->pDestName, (unsigned)pTracker->pDestName[15], &pTracker->pDeviceContext->BindName));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    // NbtDisconnect can cancel the tracker if a disconnect comes in during
    // the connecting phase.
    //
    if (NT_SUCCESS(status))
    {
#ifdef _NETBIOSLESS
        // *****************************************************************
        //
        // Skip session setup for message only mode
        //
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
               KdPrint(("Nbt.SessionStartupContinue: skipping session setup\n"));

            // Here is where we fake out the data structures to move to the SESSION_UP state
            // We enter holding jointLock and pConnEle lock

            // zero out the number of bytes received so far, since this is a new connection
            pConnEle->BytesRcvd = 0;
            pConnEle->pIrpRcv = NULL;
            pClientIrp = pConnEle->pIrp;
            pConnEle->pIrp = NULL;
            SET_STATE_UPPER (pConnEle, NBT_SESSION_UP);

            CTESpinFree(pConnEle,OldIrq);

            if (fNameReferenced)
            {
                //
                // remove the reference done when FindNameOrQuery was called, or when
                // SessionSetupContinue ran
                //
                NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
            }

            //
            // Increment the reference count on a connection while it is connected
            // so that it cannot be deleted until it disconnects.
            //
            CTESpinLock(pLowerConn,OldIrq);

            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
            ASSERT(pLowerConn->RefCount == 2);
            SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
            SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);

            CTESpinFree(pLowerConn,OldIrq);
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);

            // remove the reference added in nbt connect
            NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);

            // NOTE: the last reference done on pConnEle in NbtConnect is NOT undone
            // until the pLowerConn no longer points to pConnEle!!

            // the assumption is that if the connect irp was cancelled then the
            // client should be doing a disconnect or close shortly thereafter, so
            // there is no error handling code here.
            if (pClientIrp)
            {
                //
                // complete the client's connect request Irp
                //
#ifndef VXD
                CTEIoComplete (pClientIrp, STATUS_SUCCESS, 0 ) ;
#else
                CTEIoComplete (pClientIrp, STATUS_SUCCESS, (ULONG)pConnEle ) ;
#endif
            }

            return;
        }
        // *****************************************************************
#endif  // _NETBIOSLESS

        // set the session state to NBT_SESSION_OUTBOUND
        //
        SET_STATE_UPPER (pConnEle, NBT_SESSION_OUTBOUND);

        //
        // Increment the reference count on a connection while it is connected
        // so that it cannot be deleted until it disconnects.
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        ASSERT(pLowerConn->RefCount == 2);

        SET_STATE_LOWER (pLowerConn, NBT_SESSION_OUTBOUND);
        SET_STATERCV_LOWER (pLowerConn, NORMAL, Outbound);

        // we need to pass the file handle of the connection to TCP.
        TdiRequest.Handle.AddressHandle = pLowerConn->pFileObject;

        // the completion routine is setup to free the pTracker memory block
        TdiRequest.RequestNotifyObject = SessionStartupCompletion;
        TdiRequest.RequestContext = (PVOID)pTracker;

        CTESpinFree(pConnEle,OldIrq);

        //
        // failure to get a timer causes the connection setup to fail
        //
        status = StartSessionTimer(pTracker,pConnEle);
        if (NT_SUCCESS(status))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            status = NbtSetCancelRoutine(pConnEle->pIrp, NbtCancelSession, pDeviceContext);
            if (!NT_SUCCESS(status))
            {
                //
                // We have closed down the connection by failing the call to
                // setup up the cancel routine - it ended up calling the
                // cancel routine.
                //
                //
                // remove the second reference added in nbtconnect
                //
                NbtTrace(NBT_TRACE_OUTBOUND, ("NbtSetCancelRoutine return %!status! for %!NBTNAME!<%02x> %Z",
                        status, pTracker->pDestName, (unsigned)pTracker->pDestName[15],
                        &pTracker->pDeviceContext->BindName));
                NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
                return;
            }

            // the only data sent is the session request buffer which is in the pSendinfo
            // structure.
            status = TdiSend (&TdiRequest,
                              0,                  // send flags are not set
                              pTracker->SendBuffer.HdrLength,
                              &lSentLength,
                              &pTracker->SendBuffer,
                              0);
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("TdiSend return %!status! for %!NBTNAME!<%02x> %Z",
                        status, pTracker->pDestName, (unsigned)pTracker->pDestName[15],
                        &pTracker->pDeviceContext->BindName));
            }

            //
            // the completion routine will get called with the errors and
            // handle them appropriately, so just return here
            //
            return;
        } else {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Out resources (timer) %!status! for %!NBTNAME!<%02x> %Z",
                    status, pTracker->pDestName, (unsigned)pTracker->pDestName[15],
                    &pTracker->pDeviceContext->BindName));
        }
    }
    else
    {
        // if the remote station does not have a connection to receive the
        // session pdu on , then we will get back this status.  We may also
        // get this if the destination does not have NBT running at all. This
        // is a short timeout - 250 milliseconds, times 3.
        //
    }
    NbtTrace(NBT_TRACE_OUTBOUND, ("Cleanup connection with %!status! for %!NBTNAME!<%02x> %Z",
            status, pTracker->pDestName, (unsigned)pTracker->pDestName[15],
            &pTracker->pDeviceContext->BindName));

    //
    // this branch is taken if the TCP connection setup fails or the
    // tracker has been cancelled.
    //

    CHECK_PTR(pConnEle);

    pClientIrp = pConnEle->pIrp;
    pConnEle->pIrp = NULL;

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.SessionStartupContinue: Failed, State=%X,TrackerFlags=%X pConnEle=%X\n",
            pConnEle->state, pTracker->Flags, pConnEle));

    //
    // remove the name from the hash table since  we did not connect
    // (only if the request was not cancelled)!
    //
    //
    // if it is in the remote table and still active...
    // and no one else is referencing the name, then delete it from
    // the hash table.
    //
    if (fNameReferenced)
    {
        if ((status != STATUS_CANCELLED) &&
            (pTracker->pNameAddr->Verify == REMOTE_NAME) &&
            (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
            (pTracker->pNameAddr->RefCount == 2))
        {
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
        }
        //
        // remove the reference done when FindNameOrQuery was called, or when
        // SessionSetupContinue ran
        //
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
    }

    // Either the connection failed to get setup or the send on the
    // connection failed, either way, don't mess with disconnects, just
    // close the connection... If the Tracker was cancelled then it means
    // someother part of the code has done the disconnect already.
    //
    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    if (pConnEle->state != NBT_IDLE)
    {
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    }

    // Cache the fact that an attempt to set up a TDI connection failed. This will enable us to
    // weed out repeated attempts on the same remote address. The only case that is exempt is a
    // NETBIOS name which we let it pass through because it adopts a different name resolution
    // mechanism.

#ifndef VXD
    if (pConnEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
    {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
           KdPrint(("Nbt.SessionStartupContinue: Will avoid repeated attempts on a nonexistent address\n"));
        pConnEle->RemoteNameDoesNotExistInDNS = TRUE;
    }

    if (status == STATUS_IO_TIMEOUT)
    {
        status = STATUS_HOST_UNREACHABLE;
    }
    else if (status == STATUS_CONNECTION_REFUSED)
    {
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            status = STATUS_REMOTE_NOT_LISTENING;
        }
        else
        {
            status = STATUS_BAD_NETWORK_PATH;
        }
    }
#else
    if (status == TDI_CONN_REFUSED || status == TDI_TIMED_OUT)
    {
        status = STATUS_BAD_NETWORK_PATH;
    }
#endif

    QueueCleanup (pConnEle, &OldIrq1, &OldIrq);

    CTESpinFree(pConnEle,OldIrq);


    //
    // put back on the idle connection list if nbtcleanupconnection has not
    // run and taken pconnele off the list (setting the state to Idle).
    //
    if (pConnEle->state != NBT_IDLE)
    {
        RelistConnection(pConnEle);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    //
    // remove the last reference added in nbt connect.  The refcount will be 2
    // if nbtcleanupconnection has not run and 1, if it has.  So this call
    // could free pConnEle.
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);

    // the cancel irp routine in Ntisol.c sets the irp to NULL if it cancels
    // it.
    if (pClientIrp)
    {
        CTEIoComplete(pClientIrp,status,0L);
    }

    if (pIrpDisc)
    {
        CTEIoComplete(pIrpDisc,STATUS_SUCCESS,0L);
    }
}

//----------------------------------------------------------------------------
extern
VOID
SessionStartupCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles the completion of sending the session request pdu.
    It completes the Irp back to the client indicating the outcome of the
    transaction if there is an error otherwise it keeps the irp till the
    session setup response is heard.
    Tracker block is put back on its free Q and the
    session header is freed back to the non-paged pool.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    tCONNECTELE             *pConnEle;
    tLOWERCONNECTION        *pLowerConn;
    COMPLETIONCLIENT        CompletionRoutine = NULL;
    ULONG                   state;
    PCTE_IRP                pClientIrp;
    PCTE_IRP                pIrpDisc;
    tTIMERQENTRY            *pTimer;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pConnEle = (tCONNECTELE *)pTracker->pConnEle;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pLowerConn = pConnEle->pLowerConnId;

    //
    // if OutBound or the SessionStartupTimeoutCompletion have run,
    // they have set the refcount to zero, so just cleanup!
    //
    if (pTracker->RefConn == 0)
    {
        //
        // remove the reference done when FindNameOrQuery was called, or when
        // SessionSetupContinue ran
        //
        NbtTrace(NBT_TRACE_OUTBOUND, ("Free tracker with %!status! for %!NBTNAME!<%02x>",
                status, pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
    else
    {
        pTracker->RefConn--;

        //
        // a failure status means that the transport could not send the
        // session startup pdu - if this happens, then disconnect the
        // connection and return the client's irp with the status code
        //
        if ((!NT_SUCCESS(status)))
        {
            // we must check the status first since it is possible that the
            // lower connection has disappeared already due to a disconnect/cleanup
            // in the VXD case anyway.  Only for a bad status can we be sure
            // that pConnEle is still valid.
            //
            CHECK_PTR(pTracker);
            if (pTimer = pTracker->pTimer)
            {
                pTracker->pTimer = NULL;
                StopTimer(pTimer,&CompletionRoutine,NULL);
            }

            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.SessionStartupCompletion: Failed, State=%X,TrackerFlags=%X CompletionRoutine=%X,pConnEle=%X\n",
                    pConnEle->state, pTracker->Flags, CompletionRoutine, pConnEle));
            NbtTrace(NBT_TRACE_OUTBOUND, ("SessionStartupCompletion is called with %!status! State=%X"
                                        " TrackerFlags=%X for %!NBTNAME!<%02x>",
                    status, pConnEle->state, pTracker->Flags, pTracker->pDestName,
                    (unsigned)pTracker->pDestName[15]));

            //
            // Only if the timer has not expired yet do we kill off the connection
            // since if the timer has expired, it has already done this in
            // SessionStartupTimeout.
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (CompletionRoutine)
            {
                (*CompletionRoutine) (pTracker, status);
            }
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
    }

    //
    // remove the last reference added in nbt connect.  The refcount
    // will be 2 if nbtcleanupconnection has not run and 1, if it has.  So this call
    // could free pConnEle.
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
}


//----------------------------------------------------------------------------
VOID
SessionStartupTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles timing out a connection setup request.  The timer
    is started when the connection is started and the session setup
    message is about to be sent.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tDGRAM_SEND_TRACKING     *pTracker;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    // if pTimerQEntry is null then the timer is being cancelled, so do nothing
    if (!pTimerQEntry)
    {
        pTracker->pTimer = NULL;
        return;
    }

    SessionStartupTimeoutCompletion (pTracker, STATUS_IO_TIMEOUT);
}


//----------------------------------------------------------------------------
VOID
SessionStartupTimeoutCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status
    )
{
    CTELockHandle            OldIrq;
    CTELockHandle            OldIrq1;
    CTELockHandle            OldIrq2;
    tCONNECTELE              *pConnEle;
    tLOWERCONNECTION         *pLowerConn;
    CTE_IRP                  *pIrp;
    enum eSTATE              State;

    // kill the connection
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pTracker->pTimer = NULL;

    if (!(pConnEle = pTracker->pConnEle) ||
        !(pLowerConn = pConnEle->pLowerConnId) ||
        !(pTracker == (tDGRAM_SEND_TRACKING *) pConnEle->pIrpRcv))
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("SessionStartupTimeoutCompletion is called with %!status! "
                                "Flags=%x for %!NBTNAME!<%02x>",
                    status, pTracker->Flags, pTracker->pDestName, (unsigned)pTracker->pDestName[15]));
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("SessionStartupTimeoutCompletion is called with %!status! "
                                "state=%x flags=%x for %!NBTNAME!<%02x>",
                    status, pConnEle->state, pTracker->Flags, pTracker->pDestName,
                    (unsigned)pTracker->pDestName[15]));

    CHECK_PTR(pConnEle);
    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.SessionStartupTimeout: pConnEle=<%x>-->State=<%x>\n", pConnEle, pConnEle->state));

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.SessionStartupTimeout: pLowerConn=<%x>-->State=<%x>, TrackerFlags=<%x>\n",
            pLowerConn, pLowerConn->State, pTracker->Flags));

    CTESpinLock(pConnEle,OldIrq2);
    CTESpinLock(pLowerConn,OldIrq1);

    if ((pConnEle->state != NBT_SESSION_OUTBOUND) ||
        (!(pIrp = pConnEle->pIrp)))
    {
        CTESpinFree(pLowerConn,OldIrq1);
        CTESpinFree(pConnEle,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    pConnEle->pIrp = NULL;

    State = pConnEle->state;
    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION_TIMEOUT);
    pLowerConn->pUpperConnection = NULL;    // So that any response for this in Outbound does not succeed
    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

    CTESpinFree(pLowerConn,OldIrq1);

    QueueCleanup (pConnEle, &OldIrq, &OldIrq2);

    CTESpinFree(pConnEle,OldIrq2);

    //
    // Nbt_idle means that nbtcleanupConnection has run and the
    // connection is about to be deleted, so don't relist.
    //
    if (State != NBT_IDLE)
    {
        RelistConnection(pConnEle);
    }

    //
    // if SessionStartupCompletion has run, it has set the refcount to zero
    //
    if (pTracker->RefConn == 0)
    {
        if ((pTracker->pNameAddr->Verify == REMOTE_NAME) && // Remote names only!
            (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
            (pTracker->pNameAddr->RefCount == 2))
        {
            //
            // If no one else is referencing the name, then delete it from
            // the hash table.
            //
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
        }

        //
        // remove the reference done when FindNameOrQuery was called, or when
        // SessionSetupContinue ran
        //
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
    }
    else
    {
        pTracker->RefConn--;
    }

    //
    // remove the reference done when FindNameOrQuery was called, or when
    // SessionSetupContinue ran
    //
    pConnEle->pIrpRcv = NULL;   // So that SessionStartupCompletion does not also try to cleanup!

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION_TIMEOUT);

    CTEIoComplete(pIrp, status, 0);
}

//----------------------------------------------------------------------------
extern
VOID
RelistConnection(
    IN  tCONNECTELE *pConnEle
        )
/*++

Routine Description

    This routine unlinks the ConnEle from the ConnectActive list and puts it
    back on the Connecthead.  It is used when a connection goes to
    NBT_ASSOCIATED state.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    tCLIENTELE          *pClientEle = pConnEle->pClientEle;

    //
    // If pClientEle is NULL, it means the client was most probably
    // cleaned up, and the connection should now be on the Device's
    // UpConnectionInUse list
    //
    ASSERT (NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN));
    if (pClientEle)
    {
        CTESpinLock(pClientEle,OldIrq);
        CTESpinLock(pConnEle,OldIrq1);
        ASSERT (NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN));
        //
        // if the state is NBT_IDLE it means that NbtCleanupConnection has run
        // and removed the connection from its list in preparation for
        // freeing the memory, so don't put it back on the list
        //
        if (pConnEle->state != NBT_IDLE)
        {
            SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
            RemoveEntryList(&pConnEle->Linkage);
            InsertTailList(&pConnEle->pClientEle->ConnectHead,&pConnEle->Linkage);
        }
        CTESpinFree(pConnEle,OldIrq1);
        CTESpinFree(pClientEle,OldIrq);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSend(
        IN  TDI_REQUEST     *pRequest,
        IN  USHORT          Flags,
        IN  ULONG           SendLength,
        OUT LONG            *pSentLength,
        IN  PVOID           *pBuffer,
        IN  tDEVICECONTEXT  *pContext,
        IN  PIRP            pIrp
        )
/*++

Routine Description

    ... does nothing now....

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    //
    // This routine is never hit since the NTISOL.C routine NTSEND actually
    // bypasses this code and passes the send directly to the transport
    //
    ASSERT(0);

    return(STATUS_SUCCESS);

}


//----------------------------------------------------------------------------
NTSTATUS
NbtListen(
    IN  TDI_REQUEST                 *pRequest,
    IN  ULONG                       Flags,
    IN  TDI_CONNECTION_INFORMATION  *pRequestConnectInfo,
    OUT TDI_CONNECTION_INFORMATION  *pReturnConnectInfo,
    IN  PVOID                       pIrp)

/*++
Routine Description:

    This Routine posts a listen on an open connection allowing a client to
    indicate that is prepared to accept inbound connections.  The ConnectInfo
    may contain an address to specify which remote clients may connect to
    the connection although we don't currently look at that info.

Arguments:


Return Value:

    ReturnConnectInfo - status of the request

--*/

{
    tCLIENTELE         *pClientEle;
    tCONNECTELE         *pConnEle;
    NTSTATUS            status;
    tLISTENREQUESTS     *pListenReq;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;

    pListenReq = NbtAllocMem(sizeof(tLISTENREQUESTS),NBT_TAG('I'));
    if (!pListenReq)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("Out of memory"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // now find the connection object to link this listen record to
    pConnEle = ((tCONNECTELE *)pRequest->Handle.ConnectionContext);

    //
    // Find the client record associated with this connection
    //
    if ((!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION)) ||  // NBT_VERIFY_CONNECTION_DOWN if cleaned up
        (!NBT_VERIFY_HANDLE ((pClientEle = pConnEle->pClientEle), NBT_VERIFY_CLIENT)))
    {
        CTEMemFree(pListenReq);
        NbtTrace(NBT_TRACE_INBOUND, ("Invalid Handle pConnEle<%p> pClientEle<%p>", pConnEle, pClientEle));
        return(STATUS_INVALID_HANDLE);
    }

    CTESpinLock(pClientEle,OldIrq);
    CTESpinLock(pConnEle,OldIrq1);

    //
    // Now reverify the Client and Connection handles, and ensure the Connection state is correct!
    //
    if ((!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION)) ||
        (!NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT)) ||
        (pConnEle->state != NBT_ASSOCIATED))
    {
        CTESpinFree(pConnEle,OldIrq1);
        CTESpinFree(pClientEle,OldIrq);
        CTEMemFree(pListenReq);
        NbtTrace(NBT_TRACE_INBOUND, ("Invalid state %x", pConnEle->state));
        return(STATUS_INVALID_HANDLE);
    }

    //
    // Fill in the Listen request
    //

    pListenReq->pIrp = pIrp;
    pListenReq->Flags = Flags;
    pListenReq->pConnectEle = pConnEle;
    pListenReq->pConnInfo = pRequestConnectInfo;
    pListenReq->pReturnConnInfo = pReturnConnectInfo;
    pListenReq->CompletionRoutine = pRequest->RequestNotifyObject;
    pListenReq->Context = pRequest->RequestContext;

    // queue the listen request on the client object
    InsertTailList(&pClientEle->ListenHead,&pListenReq->Linkage);

    status = NTCheckSetCancelRoutine(pIrp,(PVOID)NbtCancelListen,0);
    NbtTrace(NBT_TRACE_INBOUND, ("NTCheckSetCancelRoutine return %!status! for %!NBTNAME!<%02x>",
                status, pClientEle->pAddress->pNameAddr->Name,
                (unsigned)pClientEle->pAddress->pNameAddr->Name[15]));

    if (!NT_SUCCESS(status))
    {
        RemoveEntryList(&pListenReq->Linkage);
        status = STATUS_CANCELLED;
    }
    else
    {
        status = STATUS_PENDING;
    }

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(pClientEle,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDisconnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  ULONG                       Flags,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PTDI_CONNECTION_INFORMATION pReturnInfo,
    IN  PIRP                        pIrp)

/*++
Routine Description:

    This Routine handles taking down a connection (netbios session).

Arguments:


Return Value:

    TDI_STATUS - status of the request

--*/

{
    tCONNECTELE             *pConnEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq2;
    CTELockHandle           OldIrq3;
    tLOWERCONNECTION        *pLowerConn;
    ULONG                   LowerState = NBT_IDLE;
    ULONG                   StateRcv;
    BOOLEAN                 Originator = TRUE;
    PCTE_IRP                pClientIrp = NULL;
    BOOLEAN                 RelistIt = FALSE;
    BOOLEAN                 Wait;
    PCTE_IRP                pIrpDisc;

    pConnEle = pRequest->Handle.ConnectionContext;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDisconnect: state %X %X\n",pConnEle->state,pConnEle));

    // check the connection element for validity
    //CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status)

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pConnEle->state <= NBT_ASSOCIATED) ||
        (pConnEle->state >= NBT_DISCONNECTING))
    {
        // the connection is not connected so reject the disconnect attempt
        // ( with an Invalid Connection return code ) - unless there is a
        // value stored in the flag
        // DiscFlag field which will be the status of a previous
        // disconnect indication from the transport.
        //
        if ((pConnEle->DiscFlag))
        {
            if (Flags == TDI_DISCONNECT_WAIT)
            {
                if (pConnEle->DiscFlag == TDI_DISCONNECT_ABORT)
                {
                    status = STATUS_CONNECTION_RESET;
                }
                else
                {
                    status = STATUS_GRACEFUL_DISCONNECT;
                }
            }
            else
            {
                status = STATUS_SUCCESS;
            }

            // clear the flag now.
            CHECK_PTR(pConnEle);
            pConnEle->DiscFlag = 0;
        }
        else
        {
            status = STATUS_CONNECTION_INVALID;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(status);
    }

    // to link and unlink upper and lower connections the Joint lock must
    // be held.  This allows coordination from the lower side and from
    // the upper side. - i.e. once the joint lock is held, the upper and lower
    // connections cannot become unlinked.
    //
    CTESpinLock(pConnEle,OldIrq2);

    // Do this check with the spin lock held to avoid a race condition
    // with a disconnect coming in from the transport at the same time.
    //

    pLowerConn = pConnEle->pLowerConnId;

    //
    // a disconnect wait is not really a disconnect, it is just there so that
    // when a disconnect occurs, the transport will complete it, and indicate
    // to the client there is a disconnect (instead of having a disconnect
    // indication handler) - therefore, for Disc Wait, do NOT change state.
    //
    CHECK_PTR(pConnEle);
    pIrpDisc = pConnEle->pIrpDisc;
    pConnEle->pIrpDisc  = NULL;
    if (Flags == TDI_DISCONNECT_WAIT)
    {

        //
        // save the Irp here and wait for a disconnect to return it
        // to the client.
        //
        if ((pConnEle->state == NBT_SESSION_UP) &&
            (!pConnEle->pIrpClose))
        {
            pConnEle->pIrpClose = pIrp;
            status = STATUS_PENDING;

            //
            // call this routine to check if the cancel flag has been
            // already set and therefore we must return the irp now
            //
            status = NbtSetCancelRoutine(pIrp, NbtCancelDisconnectWait,pLowerConn->pDeviceContext);
            //
            // change the ret status so if the irp has been cancelled,
            // driver.c will not also return it, since NbtSetCancelRoutine
            // will call the cancel routine and return the irp.
            //
            status = STATUS_PENDING;
        }
        else
        {
            status = STATUS_CONNECTION_INVALID;
        }


        CTESpinFree(pConnEle,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(status);
    }
    else
    {
        if (pLowerConn)
        {
            if (pConnEle->state > NBT_ASSOCIATED)
            {
                ULONG                   state = pConnEle->state;
                tDGRAM_SEND_TRACKING    *pTracker;

                pTracker = (tDGRAM_SEND_TRACKING *)pConnEle->pIrpRcv;

                switch (state)
                {
                    case NBT_RECONNECTING:
                    {
                        //
                        // the connection is waiting on the Exworker Q to run
                        // nbtreconnect. When that runs the connect irp is
                        // returned.
                        //
                        pTracker->Flags |= TRACKER_CANCELLED;

                        CTESpinFree(pConnEle,OldIrq2);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        CTESpinLock(pConnEle,OldIrq);
                        FreeRcvBuffers(pConnEle,&OldIrq);
                        CTESpinFree(pConnEle,OldIrq);

                        return(STATUS_SUCCESS);
                    }

                    case NBT_SESSION_OUTBOUND:
                    {
                        tTIMERQENTRY            *pTimerEntry;

                        LOCATION(0x66)
                        if (pTimerEntry = pTracker->pTimer)
                        {
                            COMPLETIONCLIENT  ClientRoutine;
                            PVOID             pContext;

                            //
                            // the Session Setup Message has been sent
                            // so stop the SessionSetup Timer.
                            //
                            LOCATION(0x67)
                            CHECK_PTR(pTracker);
                            pTracker->pTimer = NULL;
                            CTESpinFree(pConnEle,OldIrq2);

                            StopTimer(pTimerEntry,&ClientRoutine,&pContext);

                            CTESpinFree(&NbtConfig.JointLock,OldIrq);
                            if (ClientRoutine)
                            {
                                (* ClientRoutine) (pContext, STATUS_CANCELLED);
                            }
                            // else...
                            // the timer has completed and called QueueCleanup
                            // so all we need to do is return here.
                        }
                        else
                        {
                            ASSERTMSG("Nbt:In outbound state, but no timer.../n",0);
                            pTracker->Flags |= TRACKER_CANCELLED;
                            CTESpinFree(pConnEle,OldIrq2);
                            CTESpinFree(&NbtConfig.JointLock,OldIrq);
                        }

                        return(STATUS_SUCCESS);
                    }

                    case NBT_CONNECTING:
                    {
                        //
                        // This searchs for timers outstanding on name queries
                        // and name queries held up on Lmhosts or Dns Qs
                        //
                        LOCATION(0x69)
                        status = CleanupConnectingState(pConnEle,pLowerConn->pDeviceContext,&OldIrq2,&OldIrq);
                        if (status == STATUS_UNSUCCESSFUL)
                        {
                            LOCATION(0x6A)
                            //
                            // set this flag to tell sessionsetupcontinue  or
                            // SessionStartupContinue not to process
                            // anything, except to free the tracker
                            //
                            pTracker->Flags = TRACKER_CANCELLED;

                            //
                            // failed to cancel the name query so do not deref
                            // pConnEle yet.
                            //
                            //
                            // hold on to disconnect irp here - till name query is done
                            // then complete both the connect and disconnect irp
                            //
                            if (pIrpDisc)
                            {
                                status = STATUS_CONNECTION_INVALID;
                            }
                            else
                            {
                                pConnEle->pIrpDisc = pIrp;
                            }

                            status = STATUS_PENDING;
                        }
                        else if (status == STATUS_PENDING)
                        {
                            LOCATION(0x6B)
                            // the connection is being setup with the transport
                            // so disconnect below
                            //

                            pTracker->Flags = TRACKER_CANCELLED;
                            //
                            // DelayedCleanupAfterDisconnect expects this ref count
                            // to be 2, meaning that it got connected, so increment
                            // here
                            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
                            break;
                        }

                        CTESpinFree(pConnEle,OldIrq2);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        return(status);
                    }
                }   // switch

                CTESpinLock(pLowerConn,OldIrq3);

                if (pConnEle->state != NBT_SESSION_UP)
                {   //
                    // do an abortive disconnect to be sure it completes now.
                    //
                    Flags = TDI_DISCONNECT_ABORT;
                }

                LOCATION(0x6C)
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtDisconnect: LowerConn,state %X,Src %X %X\n",
                        pLowerConn->State,pLowerConn->SrcIpAddr,pLowerConn));

                ASSERT(pConnEle->RefCount > 1);

                Originator = pLowerConn->bOriginator;

                //
                // the upper connection is going to be put back on its free
                // list, and the lower one is going to get a Disconnect
                // request, so put the upper back in associated, and separate
                // the upper and lower connections
                //
                SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
                CHECK_PTR(pConnEle);
                CHECK_PTR(pLowerConn);
                NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

                LowerState = pLowerConn->State;
                StateRcv = pLowerConn->StateRcv;

//
// if we had a connection in partial rcv state, make sure to remove it from
// the list
//
#ifdef VXD
                if ((pLowerConn->StateRcv == PARTIAL_RCV) &&
                    (pLowerConn->fOnPartialRcvList == TRUE))
                {
                    RemoveEntryList (&pLowerConn->PartialRcvList);
                    pLowerConn->fOnPartialRcvList = FALSE;
                    InitializeListHead(&pLowerConn->PartialRcvList);
                }
#endif

                SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
                SetStateProc (pLowerConn, RejectAnyData);

                if (!pConnEle->pIrpDisc)
                {
                    pLowerConn->pIrp  = pIrp ;
                }

                CTESpinFree(pLowerConn,OldIrq3);

                PUSH_LOCATION(0x84);
                CTESpinFree(pConnEle,OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                // remove the reference added to pConnEle when pLowerConn pointed
                // to it, since that pointer link was just removed.
                // if the state is not disconnecting...
                //
                NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

                RelistIt = TRUE;
            }
            else
            {
                LOCATION(0x6D)
                PUSH_LOCATION(0x83);
                CHECK_PTR(pConnEle);
                CHECK_PTR(pLowerConn);
                NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
                StateRcv = NORMAL;

                CTESpinFree(pConnEle,OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }

            //
            // check for any RcvIrp that may be still around
            //
            CTESpinLock(pLowerConn,OldIrq);
            if (StateRcv == FILL_IRP)
            {
                if (pConnEle->pIrpRcv)
                {
                    PCTE_IRP    pIrp;

                    IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.NbtDisconnect: Cancelling RcvIrp on Disconnect!!!\n"));
                    pIrp = pConnEle->pIrpRcv;
                    CHECK_PTR(pConnEle);
                    pConnEle->pIrpRcv = NULL;

                    CTESpinFree(pLowerConn,OldIrq);
#ifndef VXD
                    IoCancelIrp(pIrp);
#else
                    CTEIoComplete(pIrp,STATUS_CANCELLED,0);
#endif

                    CHECK_PTR(pConnEle);
                    pConnEle->pIrpRcv = NULL;
                }
                else
                {
                    CTESpinFree(pLowerConn,OldIrq);
                }

                //
                // when the disconnect irp is returned we will close the connection
                // to avoid any peculiarities. This also lets the other side
                // know that we did not get all the data.
                //
                Flags = TDI_DISCONNECT_ABORT;
            }
            else
            {
                CTESpinFree(pLowerConn,OldIrq);
            }

            //
            // check if there is still data waiting in the transport for this end point
            // and if so do an abortive disconnect to let the other side know that something
            // went wrong
            //
            if (pConnEle->BytesInXport)
            {
                PUSH_LOCATION(0xA0);
                IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.NbtDisconnect: Doing ABORTIVE disconnect, dataInXport = %X\n",
                    pConnEle->BytesInXport));
                Flags = TDI_DISCONNECT_ABORT;
            }
        }
        else
        {
            CTESpinFree(pConnEle,OldIrq2);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

        }
    }

    ASSERT(pConnEle->RefCount > 0);

    CTESpinLock (pConnEle,OldIrq);
    FreeRcvBuffers (pConnEle,&OldIrq);
    CTESpinFree (pConnEle,OldIrq);

    if (RelistIt)
    {
        //
        // put the upper connection back on its free list
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        RelistConnection (pConnEle);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    //
    // disconnect (and delete) the lower connection
    //
    // when nbtdisconnect is called from cleanup connection it does not
    // have an irp and it wants a synchronous disconnect, so set wait
    // to true in this case
    //
    if (!pIrp)
    {
        Wait = TRUE;
    }
    else
    {
        Wait = FALSE;
    }

    status = DisconnectLower(pLowerConn,LowerState,Flags,pTimeout,Wait);

    if ((pConnEle->pIrpDisc) &&
        (status != STATUS_INSUFFICIENT_RESOURCES))
    {
        // don't complete the disconnect irp yet if we are holding onto
        // it
        status = STATUS_PENDING;
    }

    return(status);

}
//----------------------------------------------------------------------------
NTSTATUS
DisconnectLower(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                 state,
    IN  ULONG                 Flags,
    IN  PVOID                 Timeout,
    IN  BOOLEAN               Wait
    )

/*++
Routine Description:

    This Routine handles disconnecting the lower half of a connection.


Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                status=STATUS_SUCCESS;
    tDGRAM_SEND_TRACKING    *pTracker;

    if (pLowerConn)
    {
        //
        // no need to disconnect a connection in the connecting state since it
        // hasn't connected yet...i.e. one where the destination refuses to
        // accept the tcp connection.... hmmmm maybe we do need to disconnect
        // a connection in the connecting state, since the transport is
        // actively trying to connect the connection, and we need to stop
        // that activity - so the Upper connection is connecting during
        // name resolution, but the lower one isn't connecting until the
        // tcp connection phase begins.
        //
        if ((state >= NBT_CONNECTING) && (state <= NBT_SESSION_UP))
        {
            //
            // got a cleanup for an active connection, so send a disconnect down
            // to the transport
            //
            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.DisconnectLower: Waiting for disconnect...\n"));

            status = GetTracker(&pTracker, NBT_TRACKER_DISCONNECT_LOWER);
            if (NT_SUCCESS(status))
            {
                ULONG   TimeVal;

                // this should return status pending and the irp will be completed
                // in DelayedCleanupAfterDisconnect in hndlrs.c
                pTracker->pConnEle = (PVOID)pLowerConn;

#if DBG
                if (Timeout)
                {
                    TimeVal = ((PTIME)Timeout)->LowTime;
                }
                else
                {
                    TimeVal = 0;
                }
                IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.DisconnectLower: Disconnect Timout = %X,Flags=%X\n",
                        TimeVal,Flags));
#endif

                // in the case where CleanupAddress calls cleanupConnection
                // which calls nbtdisconnect, we do not have an irp to wait
                // on so pass a flag down to TdiDisconnect to do a synchronous
                // disconnect.
                //
                status = TcpDisconnect (pTracker, Timeout, Flags, Wait);

#ifndef VXD
                if (Wait)
                {
                    // we need to call disconnect done now
                    // to free the tracker and cleanup the connection
                    //
                    DisconnectDone(pTracker,status,0);
                }
#else
                //
                // if the disconnect is abortive, transport doesn't call us
                // back so let's call DisconnectDone so that the lowerconn gets
                // cleaned up properly! (Wait parm is of no use in vxd)
                //
                if (Flags == TDI_DISCONNECT_ABORT)
                {
                    // we need to call disconnect done now
                    // to free the tracker and cleanup the connection
                    //
                    DisconnectDone(pTracker,STATUS_SUCCESS,0);
                }
#endif
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return status ;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAccept(
        TDI_REQUEST                     *pRequest,
        IN  TDI_CONNECTION_INFORMATION  *pAcceptInfo,
        OUT TDI_CONNECTION_INFORMATION  *pReturnAcceptInfo,
        IN  PIRP                        pIrp)

/*++

Routine Description

    This routine handles accepting an inbound connection by a client.
    The client calls this routine after it has been alerted
    by a Listen completing back to the client.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tCONNECTELE  *pConnectEle;
    NTSTATUS     status;
    CTELockHandle OldIrq;

    // get the client object associated with this connection
    pConnectEle = (tCONNECTELE *)pRequest->Handle.ConnectionContext;

    CTEVerifyHandle(pConnectEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);

    //
    // a Listen has completed
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pConnectEle);
    if (pConnectEle->state == NBT_SESSION_WAITACCEPT)
    {
        tLOWERCONNECTION    *pLowerConn;

        //
        // We need to send a session response PDU here, since a Listen has
        // has completed back to the client, and the session is not yet up
        //
        SET_STATE_UPPER (pConnectEle, NBT_SESSION_UP);

        pLowerConn = (tLOWERCONNECTION *)pConnectEle->pLowerConnId;
        SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
        SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);

        CTESpinFreeAtDpc(pConnectEle);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        status = TcpSendSessionResponse(
                    pLowerConn,
                    NBT_POSITIVE_SESSION_RESPONSE,
                    0L);

        if (NT_SUCCESS(status))
        {
            status = STATUS_SUCCESS;
        }

    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
        CTESpinFreeAtDpc(pConnectEle);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NbtReceiveDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pReceiveInfo,
        IN  PTDI_CONNECTION_INFORMATION pReturnedInfo,
        IN  LONG                        ReceiveLength,
        IN  LONG                        *pReceivedLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface.  It is mostly a pass through routine for the data
    except that this code must create a datagram header and pass that
    header back to the calling routine.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{

    NTSTATUS                status;
    tCLIENTELE              *pClientEle;
    CTELockHandle           OldIrq;
    tRCVELE                 *pRcvEle;
    tADDRESSELE             *pAddressEle;

    pClientEle = (tCLIENTELE *)pRequest->Handle.AddressHandle;
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);
    pAddressEle = pClientEle->pAddress;
    *pReceivedLength = 0;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtReceiveDatagram: RcvDgram posted (pIrp) %X \n",pIrp));

    pRcvEle = (tRCVELE *)NbtAllocMem(sizeof(tRCVELE),NBT_TAG('J'));
    if (!pRcvEle)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pRcvEle->pIrp = pIrp;
    pRcvEle->ReceiveInfo = pReceiveInfo;
    pRcvEle->ReturnedInfo = pReturnedInfo;
    pRcvEle->RcvLength = ReceiveLength;
    pRcvEle->pRcvBuffer = pBuffer;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // tack the receive on to the client element for later use
    //
    InsertTailList(&pClientEle->RcvDgramHead,&pRcvEle->Linkage);

    status = NTCheckSetCancelRoutine(pIrp,(PVOID)NbtCancelRcvDgram,pDeviceContext);
    if (!NT_SUCCESS(status))
    {
        RemoveEntryList(&pRcvEle->Linkage);
    }
    else
    {
        status = STATUS_PENDING;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
FindNameOrQuery(
    IN  PUCHAR                  pName,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   QueryCompletion,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  ULONG                   NameFlags,
    OUT tIPADDRESS              *pIpAddress,
    OUT tNAMEADDR               **ppNameAddr,
    IN  ULONG                   NameReferenceContext,
    IN  BOOLEAN                 DgramSend
    )
/*++

Routine Description

    This routine handles finding a name in the local or remote table or doing
    a name query on the network.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{

    tNAMEADDR               *pNameAddr;
    CTELockHandle           OldIrq2;
    NTSTATUS                status=STATUS_UNSUCCESSFUL;
    BOOLEAN                 FoundInLocalTable = FALSE;
    tDEVICECONTEXT          *pThisDeviceContext;
    LIST_ENTRY              *pHead, *pEntry;
    ULONG                   Index;

    //
    // this saves the client threads security context so we can
    // open remote lmhost files later.- it is outside the Spin locks
    // so it can be pageable
    //
    CTESaveClientSecurity(pTracker);

    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    pTracker->pTrackerWorker = NULL;    // Initialize the NameQuery Tracker

#ifdef MULTIPLE_WINS
    if (ppNameAddr)
    {
        *ppNameAddr = NULL;
    }
#endif

    //
    // Fail all connect attempts to 1C names.
    //
    if ((pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c) &&
        (pTracker->Flags & SESSION_SETUP_FLAG))
    {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            DELETE_CLIENT_SECURITY(pTracker);

            KdPrint(("Nbt.FindNameOrQuery: Session setup -- p1CNameAddr was NULL\n"));
            return(STATUS_UNEXPECTED_NETWORK_ERROR);
    }

    // send to the NetBios Broadcast name, so use the subnet broadcast
    // address - also - a
    // Kludge to keep the browser happy - always broadcast sends to
    // 1d, however NodeStatus's are sent to the node owning the 1d name now.
    //
    if ((pName[0] == '*') || ((pName[NETBIOS_NAME_SIZE-1] == 0x1d) && (DgramSend)))
    {
        // this 'fake' pNameAddr has to be setup carefully so that the memory
        // is released when NbtDeferenceName is called from SendDgramCompletion
        // Note that this code does not apply to NbtConnect since these names
        // are group names, and NbtConnect will not allow a session to a group
        // name.
        status = STATUS_INSUFFICIENT_RESOURCES ;
        if (pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('K')))
        {
            CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));
            CTEMemCopy( pNameAddr->Name, pName, NETBIOS_NAME_SIZE ) ;
            pNameAddr->IpAddress     = pDeviceContext->BroadcastAddress;
            pNameAddr->NameTypeState = NAMETYPE_GROUP | STATE_RESOLVED;

            // gets incremented below, and decremented when NBT_DEREFERENCE_NAMEADDR
            // is called
            CHECK_PTR(pNameAddr);
            pNameAddr->RefCount = 0;
            pNameAddr->Verify = LOCAL_NAME;
            pNameAddr->AdapterMask = pDeviceContext->AdapterMask;
            pNameAddr->ReleaseMask = (CTEULONGLONG) 0;

            // adjust the linked list ptr to fool the RemoveEntry routine
            // so it does not do anything wierd in NbtDeferenceName
            //
            pNameAddr->Linkage.Flink = pNameAddr->Linkage.Blink = &pNameAddr->Linkage;

            status = STATUS_SUCCESS;
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            DELETE_CLIENT_SECURITY(pTracker);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }
    else
    {
        // The pdu is all made up and ready to go except that we don't know
        // the destination IP address yet, so check in the local then remote
        // table for the ip address.
        //
        pNameAddr = NULL;

        //
        // Dont check local cache for 1C names, to force a WINS query; so we find other
        // DCs even if we have a local DC running.
        //
        if ((pName[NETBIOS_NAME_SIZE-1] != 0x1c) )
        {
            status = FindInHashTable (NbtConfig.pLocalHashTbl, pName, NbtConfig.pScope, &pNameAddr);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
        }

        // check the remote table now if not found, or if it was found in
        // conflict in the local table, or if it was found and its a group name
        // or if it was found to be resolving in the local table.  When the
        // remote query timesout, it will check the local again to see if
        // it is resolved yet.
        // Going to the remote table for group names
        // allows special Internet group names to be registered as
        // as group names in the local table and still prompt this code to go
        // to the name server to check for an internet group name. Bnodes do
        // not understand internet group names as being different from
        // regular group names, - they just broadcast to both. (Note: this
        // allows Bnodes to resolve group names in the local table and do
        // a broadcast to them without a costly broadcast name query for a
        // group name (where everyone responds)). Node Status uses this routine too
        // and it always wants to find the singular address of the destination,
        // since it doesn't make sense doing a node status to the broadcast
        // address.
        // DgramSend is a flag to differentiate Connect attempts from datagram
        // send attempts, so the last part of the If says that if it is a
        // group name and not a Bnode, and not a Dgram Send, then check the
        // remote table.
        //
        if ((!NT_SUCCESS(status)) ||
            (pNameAddr->NameTypeState & STATE_CONFLICT) ||
            (pNameAddr->NameTypeState & STATE_RESOLVING))
        {
            pNameAddr = NULL;
            status = FindInHashTable (NbtConfig.pRemoteHashTbl, pName, NbtConfig.pScope, &pNameAddr);

            if (NT_SUCCESS(status) &&
                NbtConfig.SmbDisableNetbiosNameCacheLookup &&
                IsDeviceNetbiosless(pDeviceContext) &&
                !(pNameAddr->NameTypeState & PRELOADED) &&
                NULL == pNameAddr->FQDN.Buffer) {
                status = STATUS_UNSUCCESSFUL;
            }

            //
            // See if we have an address resolved on this device
            //
            if (NT_SUCCESS(status))
            {
                ASSERT (!(pNameAddr->NameTypeState & STATE_RELEASED));
                status = PickBestAddress (pNameAddr, pDeviceContext, pIpAddress);
            }
        }
        else if (((IsDeviceNetbiosless (pDeviceContext)) &&
                  (pNameAddr->NameFlags & NAME_REGISTERED_ON_SMBDEV)) ||
                 ((!IsDeviceNetbiosless(pDeviceContext)) &&
                  ((pDeviceContext->IpAddress) &&
                   (pNameAddr->AdapterMask & pDeviceContext->AdapterMask))))
        {
            FoundInLocalTable = TRUE;
            *pIpAddress = pDeviceContext->IpAddress;
            pNameAddr->IpAddress = pDeviceContext->IpAddress;
        }
        else
        {
            //
            // This is a Local name, so find the first device this name is registered on
            //
            if (!IsDeviceNetbiosless (pDeviceContext)) {
                pHead = pEntry = &NbtConfig.DeviceContexts;
                while ((pEntry = pEntry->Flink) != pHead)
                {
                    pThisDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                    if ((pThisDeviceContext->IpAddress) &&
                        (pThisDeviceContext->AdapterMask & pNameAddr->AdapterMask))
                    {
                        pNameAddr->IpAddress = pThisDeviceContext->IpAddress;
                        *pIpAddress = pThisDeviceContext->IpAddress;
                        FoundInLocalTable = TRUE;
                        break;
                    }
                }
            }
            /*
             * The name is in local name table. However, we cannot find a device which has an IP address.
             */
            if (!FoundInLocalTable) {
                CTESpinFree(&NbtConfig.JointLock,OldIrq2);
                DELETE_CLIENT_SECURITY(pTracker);
                return STATUS_BAD_NETWORK_PATH;
            }
        }

        //
        // If we found the name, but the name does not match
        // what we were looking for, return error!
        //
        if ((status == STATUS_SUCCESS) &&
            (!(pNameAddr->NameTypeState & NameFlags)))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            DELETE_CLIENT_SECURITY(pTracker);

            KdPrint(("Nbt.FindNameOrQuery: NameFlags=<%x> != pNameAddr->NameTypeState=<%x>\n",
                NameFlags, pNameAddr->NameTypeState));
            return(STATUS_UNEXPECTED_NETWORK_ERROR);
        }
    }

    // The proxy puts name in the released state, so we need to ignore those
    // and do another name query
    // If the name is not resolved on this adapter then do a name query.
    //
    // MAlam: 2/4/97
    // Added fix for Local Cluster Name Resolution:  If the name is in the Local
    // Names Cache, we do not need to check the adapter it's registered on.  This
    // is mainly to facilitate names registered on pseudo-devices which have to
    // be made visible locally.
    //
    if (!NT_SUCCESS(status))
    {
        // fill in some tracking values so we can complete the send later
        InitializeListHead(&pTracker->TrackerList);

#if _NETBIOSLESS
        // Query on the Net only if this request is not on a Netbiosless Device
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            status = STATUS_UNSUCCESSFUL;
        }
        else
#endif
        {
            // this will query the name on the network and call a routine to
            // finish sending the datagram when the query completes.
            status = QueryNameOnNet (pName,
                                     NbtConfig.pScope,
                                     NBT_UNIQUE,      //use this as the default
                                     pTracker,
                                     QueryCompletion,
                                     NodeType & NODE_MASK,
                                     NULL,
                                     pDeviceContext,
                                     &OldIrq2);

            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        }
    }
    else
    {
        // check the name state and if resolved, send to it
        if (pNameAddr->NameTypeState & STATE_RESOLVED)
        {
            //
            // found the name in the remote hash table, so send to it
            //
            // increment refcount so the name does not disappear out from under us
            NBT_REFERENCE_NAMEADDR (pNameAddr, NameReferenceContext);
            if (DgramSend)
            {
                pTracker->p1CNameAddr = NULL;
                //
                // check if it is a 1C name and if there is a name in
                // the domainname list
                //
                if (pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c)
                {
                    //
                    // If the 1CNameAddr field is NULL here, we overwrite the pConnEle element (which is
                    // a union in the tracker). We check for NULL here and fail the request.
                    //
                    if (pTracker->p1CNameAddr = FindInDomainList(pTracker->pDestName,&DomainNames.DomainList))
                    {
                        NBT_REFERENCE_NAMEADDR (pTracker->p1CNameAddr, NameReferenceContext);
                    } 
                }
            }

            //
            // overwrite the pDestName field with the pNameAddr value
            // so that SendDgramContinue can send to Internet group names
            //
            pTracker->pNameAddr = pNameAddr;
            if (ppNameAddr)
            {
                *ppNameAddr = pNameAddr;
            }

            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        }
        else if (pNameAddr->NameTypeState & STATE_RESOLVING)
        {

            ASSERTMSG("A resolving name in the name table!",0);

            status = SendToResolvingName(pNameAddr,
                                         pName,
                                         OldIrq2,
                                         pTracker,
                                         QueryCompletion);

        }
        else
        {
            //
            // Name neither in the RESOLVED nor RESOLVING state
            //
            NBT_PROXY_DBG(("FindNameOrQuery: STATE of NAME %16.16s(%X) is %d\n",
                pName, pName[15], pNameAddr->NameTypeState & NAME_STATE_MASK));
            status = STATUS_UNEXPECTED_NETWORK_ERROR;
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        }
    }

    if (status != STATUS_PENDING)
    {
        DELETE_CLIENT_SECURITY(pTracker);
    }
    return(status);
}
//----------------------------------------------------------------------------
tNAMEADDR *
FindNameRemoteThenLocal(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    OUT PULONG                  plNameType
    )
/*++

Routine Description

    This routine Queries the remote hash table then the local one for a name.

Arguments:

Return Values:

    NTSTATUS    - completion status

--*/
{
    tNAMEADDR   *pNameAddr;
    tIPADDRESS  IpAddress = 0;
    tIPADDRESS  *pIpNbtGroupList = NULL;

    if (pNameAddr = FindName (NBT_REMOTE, pTracker->pDestName, NbtConfig.pScope, plNameType)) {
        pNameAddr->TimeOutCount = NbtConfig.RemoteTimeoutCount;
    } else {
        pNameAddr = FindName (NBT_LOCAL, pTracker->pDestName, NbtConfig.pScope, plNameType);
    }

    if ((pNameAddr) &&
        (!NT_SUCCESS (PickBestAddress (pNameAddr, pTracker->pDeviceContext, &IpAddress))))
    {
        pNameAddr = NULL;
    }

    
    if (pIpAddress)
    {
        *pIpAddress = IpAddress;
    }

    return(pNameAddr);
}

//----------------------------------------------------------------------------
NTSTATUS
SendToResolvingName(
    IN  tNAMEADDR               *pNameAddr,
    IN  PCHAR                   pName,
    IN  CTELockHandle           OldIrq,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   QueryCompletion
        )
/*++

Routine Description

    This routine handles the situation where a session send or a datagram send
    is made WHILE the name is still resolving.  The idea here is to hook this
    tracker on to the one already doing the name query and when the first completes
    this tracker will be completed too.

Arguments:

Return Values:

    NTSTATUS    - completion status

--*/
{
    tDGRAM_SEND_TRACKING    *pTrack;
    tTIMERQENTRY            *pTimer;


    KdPrint(("Nbt.SendToResolvingName: Two Name Queries for the same Resolving name %15.15s <%X>\n",
                pNameAddr->Name,pNameAddr->Name[NETBIOS_NAME_SIZE-1]));

#ifdef PROXY_NODE
    //
    // Check if the query outstanding was sent by the PROXY code.
    // If yes, we stop the timer and send the query ourselves.
    //
    if (pNameAddr->ProxyReqType != NAMEREQ_REGULAR)
    {
        NTSTATUS    status;
        //
        // Stop the proxy timer.  This will result in
        // cleanup of the tracker buffer
        //
        NBT_PROXY_DBG(("SendToResolvingName: STOPPING PROXY TIMER FOR NAME %16.16s(%X)\n", pName, pName[15]));

        // **** TODO ****** the name may be resolving with LMhosts or
        // DNS so we can't just stop the timer and carry on!!!.
        //
        CHECK_PTR(pNameAddr);
        if (pTimer = pNameAddr->pTimer)
        {
            pNameAddr->pTimer = NULL;
            status = StopTimer(pTimer,NULL,NULL);
        }

        pNameAddr->NameTypeState = STATE_RELEASED;

        //
        // this will query the name on the network and call a
        // routine to finish sending the datagram when the query
        // completes.
        //
        status = QueryNameOnNet (pName,
                                 NbtConfig.pScope,
                                 NBT_UNIQUE,      //use this as the default
                                 pTracker,
                                 QueryCompletion,
                                 NodeType & NODE_MASK,
                                 pNameAddr,
                                 pTracker->pDeviceContext,
                                 &OldIrq);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(status);

        //
        // NOTE: QueryNameOnNet frees the pNameAddr by calling NBT_DEREFERENCE_NAMEADDR
        // if that routine fails for some reason.
        //

    }
    else
#endif
    {
        ASSERT(pNameAddr->pTracker);

        // there is currently a name query outstanding so just hook
        // our tracker to the tracker already there.. use the
        // list entry TrackerList for this.
        //
        pTrack = pNameAddr->pTracker;

        //
        // save the completion routine for this tracker since it may
        // be different than the tracker currently doing the query
        //
        pTracker->CompletionRoutine = QueryCompletion;

        InsertTailList(&pTrack->TrackerList,&pTracker->TrackerList);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);


        // we don't want to complete the Irp, so return pending status
        //
        return(STATUS_PENDING);
    }
}



//----------------------------------------------------------------------------
extern
USHORT
GetTransactId(
    )
/*++
Routine Description:

    This Routine increments the transaction id with the spin lock held.
    It uses NbtConfig.JointLock.

Arguments:

Return Value:


--*/

{
    USHORT                  TransactId;
    CTELockHandle           OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    TransactId = NbtConfig.TransactionId++;
#ifndef VXD
    if (TransactId == 0xFFFF)
    {
        NbtConfig.TransactionId = WINS_MAXIMUM_TRANSACTION_ID +1;
    }
#else
    if (TransactId == (DIRECT_DNS_NAME_QUERY_BASE - 1))
    {
        NbtConfig.TransactionId = 0;
    }
#endif

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (TransactId);
}

//----------------------------------------------------------------------------
extern
VOID
CTECountedAllocMem(
        PVOID   *pBuffer,
        ULONG   Size
        )
/*++
Routine Description:

    This Routine allocates memory and counts the amount allocated so that it
    will not allocate too much - generally this is used in datagram sends
    where the send datagram is buffered.

Arguments:

    Size - the number of bytes to allocate
    PVOID - a pointer to the memory or NULL if a failure

Return Value:


--*/

{
    CTELockHandle           OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (NbtMemoryAllocated > NbtConfig.MaxDgramBuffering)
    {
        *pBuffer = NULL;
    }
    else
    {
        NbtMemoryAllocated += Size;
        *pBuffer = NbtAllocMem(Size,NBT_TAG('L'));
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
extern
VOID
CTECountedFreeMem(
    PVOID   pBuffer,
    ULONG   Size,
    BOOLEAN fJointLockHeld
    )
/*++
Routine Description:

    This Routine frees memory and decrements the global count of acquired
    memory.

Arguments:

    PVOID - a pointer to the memory to free
    Size - the number of bytes to free

Return Value:


--*/

{
    CTELockHandle           OldIrq;

    if (!fJointLockHeld)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    ASSERT(NbtMemoryAllocated >= Size);
    if (NbtMemoryAllocated >= Size)
    {
        NbtMemoryAllocated -= Size;
    }
    else
    {
        NbtMemoryAllocated = 0;
    }

    if (!fJointLockHeld)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    CTEMemFree(pBuffer);

}


//----------------------------------------------------------------------------
NTSTATUS
BuildSendDgramHdr(
        IN  ULONG                   SendLength,
        IN  tDEVICECONTEXT          *pDeviceContext,
        IN  PCHAR                   pSourceName,
        IN  PCHAR                   pDestName,
        IN  ULONG                   NameLength,
        IN  PVOID                   pBuffer,
        OUT tDGRAMHDR               **ppDgramHdr,
        OUT tDGRAM_SEND_TRACKING    **ppTracker
        )
/*++

Routine Description

    This routine builds a datagram header necessary for sending datagrams.
    It include the to and from Netbios names and ip addresses.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    NTSTATUS                status;
    PCHAR                   pCopyTo;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAMHDR               *pDgramHdr;
    ULONG                   HdrLength;
    ULONG                   HLength;
    ULONG                   TotalLength;
    PVOID                   pSendBuffer;
    PVOID                   pNameBuffer;
    ULONG                   BytesCopied;
    USHORT                  TransactId;

    CTEPagedCode();

    HdrLength = DGRAM_HDR_SIZE + (NbtConfig.ScopeLength <<1);
    HLength = ((HdrLength + 3) / 4 ) * 4; // 4 byte aligned the hdr size
    TotalLength = HLength + NameLength + SendLength;
    CTECountedAllocMem ((PVOID *)&pDgramHdr,TotalLength);
    if (!pDgramHdr)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *ppDgramHdr = pDgramHdr;

    // fill in the Dgram header
    pDgramHdr->Flags    = FIRST_DGRAM | (NbtConfig.PduNodeType >> 11);
    TransactId  = GetTransactId();
    pDgramHdr->DgramId  = htons(TransactId);
#ifdef _NETBIOSLESS
    pDgramHdr->SrcPort  = htons(pDeviceContext->DatagramPort);
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        // We don't know which adapter will be used, so use ANY
        pDgramHdr->SrcIpAddr = htonl(IP_ANY_ADDRESS);
    }
    else
    {
        pDgramHdr->SrcIpAddr = htonl(pDeviceContext->IpAddress);
    }
#else
    pDgramHdr->SrcPort  = htons(NBT_DATAGRAM_UDP_PORT);
    pDgramHdr->SrcIpAddr = htonl(pDeviceContext->IpAddress);
#endif
    //
    // the length is the standard datagram length (dgram_hdr_size + 2* scope)
    // minus size of the header that comes before the SourceName
    //
    pDgramHdr->DgramLength = htons( (USHORT)SendLength + (USHORT)DGRAM_HDR_SIZE
                               - (USHORT)(&((tDGRAMHDR *)0)->SrcName.NameLength)
                               + ( (USHORT)(NbtConfig.ScopeLength << 1) ));
    pDgramHdr->PckOffset   = 0; // not fragmented for now!

    pCopyTo = (PVOID)&pDgramHdr->SrcName.NameLength;
    pCopyTo = ConvertToHalfAscii(pCopyTo, pSourceName, NbtConfig.pScope, NbtConfig.ScopeLength);

    //
    // copy the destination name and scope to the pdu - we use this node's
    //
    ConvertToHalfAscii (pCopyTo, pDestName, NbtConfig.pScope, NbtConfig.ScopeLength);

    //
    // copy the name in to the buffer since we are completing the client's irp
    // and we will lose his buffer with the dest name in it.
    //
    pNameBuffer = (PVOID)((PUCHAR)pDgramHdr + HLength);
    CTEMemCopy (pNameBuffer, pDestName, NameLength);

    //
    // copy the client's send buffer to our buffer so the send dgram can
    // complete immediately.
    //
    pSendBuffer = (PVOID) ((PUCHAR)pDgramHdr + NameLength + HLength);
    if (SendLength)
    {
#ifdef VXD
        CTEMemCopy(pSendBuffer,pBuffer,SendLength);
#else
        status = TdiCopyMdlToBuffer(pBuffer,
                                    0,
                                    pSendBuffer,
                                    0,
                                    SendLength,
                                    &BytesCopied);

        if (!NT_SUCCESS(status) || (BytesCopied != SendLength))
        {
            CTECountedFreeMem ((PVOID)pDgramHdr, TotalLength, FALSE);
            return(STATUS_UNSUCCESSFUL);
        }
#endif
    }
    else
    {
        pSendBuffer = NULL;
    }

    //
    // get a buffer for tracking Dgram Sends
    //
    status = GetTracker(&pTracker, NBT_TRACKER_BUILD_SEND_DGRAM);
    if (NT_SUCCESS(status))
    {

        CHECK_PTR(pTracker);
        pTracker->SendBuffer.pBuffer   = pSendBuffer;
        pTracker->SendBuffer.Length    = SendLength;
        pTracker->SendBuffer.pDgramHdr = pDgramHdr;
        pTracker->SendBuffer.HdrLength = HdrLength;

        pTracker->pClientIrp           = NULL;
        pTracker->pDestName            = pNameBuffer;
        pTracker->UnicodeDestName      = NULL;
        pTracker->pNameAddr            = NULL;
        pTracker->RemoteNameLength     = NameLength;      // May be needed for Dns Name resolution
        pTracker->pClientEle           = NULL;
        pTracker->AllocatedLength      = TotalLength;

        *ppTracker = pTracker;

        status = STATUS_SUCCESS;
    }
    else
    {
        CTECountedFreeMem((PVOID)pDgramHdr,TotalLength, FALSE);

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


//----------------------------------------------------------------------------
VOID
DgramSendCleanupTracker(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  BOOLEAN                 fJointLockHeld
    )

/*++
Routine Description

    This routine cleans up after a data gram send.

Arguments:

    pTracker
    status
    Length

Return Values:

    VOID

--*/

{
    tNAMEADDR               *pNameAddr=NULL;

    //
    // Undo the nameAddr increment done before the send started - if we have
    // actually resolved the name - when the name does not resolve pNameAddr
    // is set to NULL before calling this routine.
    //
    if (pTracker->pNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_SEND_DGRAM, fJointLockHeld);
    }

    if (pTracker->p1CNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->p1CNameAddr, REF_NAME_SEND_DGRAM, fJointLockHeld);
        pTracker->p1CNameAddr = NULL;
    }

    //
    // free the buffer used for sending the data and free
    // the tracker
    //
    CTECountedFreeMem((PVOID)pTracker->SendBuffer.pDgramHdr, pTracker->AllocatedLength, fJointLockHeld);

    if (pTracker->pGroupList)
    {
        CTEMemFree(pTracker->pGroupList);
        pTracker->pGroupList = NULL;
    }

    FreeTracker (pTracker,RELINK_TRACKER);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSendDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pSendInfo,
        IN  LONG                        SendLength,
        IN  LONG                        *pSentLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface.  It is mostly a pass through routine for the data
    except that this code must create a datagram header and pass that
    header back to the calling routine.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
    tCLIENTELE              *pClientEle;
    tDGRAMHDR               *pDgramHdr;
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    PCHAR                   pName, pEndpointName;
    ULONG                   NameLen;
    ULONG                   NameType;
    ULONG                   SendCount;
    tIPADDRESS              RemoteIpAddress;
    tDEVICECONTEXT          *pDeviceContextOut = NULL;
    PIO_STACK_LOCATION      pIrpSp;
    PUCHAR                  pCopyTo;
    NBT_WORK_ITEM_CONTEXT   *pContext;

    CTEPagedCode();

    //
    // Check for valid address on this Device + valid ClientElement
    if ((pDeviceContext->IpAddress == 0) ||
        (pDeviceContext->pFileObjects == NULL))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    pClientEle = (tCLIENTELE *)pRequest->Handle.AddressHandle;
    if ( pClientEle->Verify != NBT_VERIFY_CLIENT )
    {
        if ( pClientEle->Verify == NBT_VERIFY_CLIENT_DOWN )
        {
            status = STATUS_CANCELLED;
        }
        else
        {
            status = STATUS_INVALID_HANDLE;
        }
        return status;
    }

    //
    // Check for valid destination name and for whether it is an IP address
    //
    status = GetNetBiosNameFromTransportAddress (
            (PTRANSPORT_ADDRESS)pSendInfo->RemoteAddress, pSendInfo->RemoteAddressLength, &TdiAddr);
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NbtSendDatagram: Unable to get dest name from address in dgramsend\n"));
        return(STATUS_INVALID_PARAMETER);
    }
    pName = TdiAddr.OEMRemoteName.Buffer;
    NameLen = TdiAddr.OEMRemoteName.Length;
    NameType = TdiAddr.NameType;
    if (TdiAddr.OEMEndpointName.Buffer) {
        CTEMemCopy (pClientEle->EndpointName, TdiAddr.OEMEndpointName.Buffer, NETBIOS_NAME_SIZE);
    }

    pClientEle->AddressType = TdiAddr.AddressType;
    if (RemoteIpAddress = Nbt_inet_addr(pName, DGRAM_SEND_FLAG))
    {
        pDeviceContextOut = GetDeviceFromInterface (htonl(RemoteIpAddress), TRUE);
        if ((NbtConfig.ConnectOnRequestedInterfaceOnly) &&
            (!IsDeviceNetbiosless(pDeviceContext)) &&
            (pDeviceContext != pDeviceContextOut))
        {
            status = STATUS_BAD_NETWORK_PATH;
            goto NbtSendDatagram_Exit;
        }
    }

#ifndef VXD
    if (pClientEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
    {
        pEndpointName = pClientEle->EndpointName;
    }
    else
#endif  // !VXD
    {
        pEndpointName = pName;
    }

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.NbtSendDatagram: Dgram Send to = %16.16s<%X>\n",pName,pName[15]));

    status = BuildSendDgramHdr (SendLength,
                                pDeviceContext,
                                ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name, // Source name
                                pEndpointName,
                                NameLen,
                                pBuffer,
                                &pDgramHdr,
                                &pTracker);

    if (!NT_SUCCESS(status))
    {
        goto NbtSendDatagram_Exit;
    }

    //
    // save the devicecontext that the client is sending on.
    //
    pTracker->pDeviceContext = (PVOID)pDeviceContext;
    pTracker->Flags = DGRAM_SEND_FLAG;
    pTracker->pClientIrp = pIrp;
    pTracker->AddressType = pClientEle->AddressType;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.Others.Argument4 = pTracker;
    status = NTCheckSetCancelRoutine(pIrp, NbtCancelDgramSend, pDeviceContext);
    if (STATUS_CANCELLED == status)
    {
        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NbtSendDatagram: Request was cancelled!\n"));
        pTracker->pClientIrp = NULL;
        pIrpSp->Parameters.Others.Argument4 = NULL;
        DgramSendCleanupTracker(pTracker,status,FALSE);
        goto NbtSendDatagram_Exit;
    }

    if (RemoteIpAddress)
    {
        //
        // add this address to the remote hashtable
        //
        status = LockAndAddToHashTable (NbtConfig.pRemoteHashTbl,
                                        pName,
                                        NbtConfig.pScope,
                                        RemoteIpAddress,
                                        NBT_UNIQUE,
                                        NULL,
                                        NULL,
                                        pDeviceContextOut,
                                        NAME_RESOLVED_BY_IP);

        if (NT_SUCCESS (status))    // SUCCESS if added first time, PENDING if name already existed!
        {
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        //
        // if the name is longer than 16 bytes, it's not a netbios name.
        // skip wins, broadcast etc. and go straight to dns resolution
        //
        status = STATUS_UNSUCCESSFUL;
        if (NameLen <= NETBIOS_NAME_SIZE)
        {
            status = FindNameOrQuery(pName,
                                     pDeviceContext,
                                     SendDgramContinue,
                                     pTracker,
                                     (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                                     &pTracker->RemoteIpAddress,
                                     &pTracker->pNameAddr,
                                     REF_NAME_SEND_DGRAM,
                                     TRUE);
        }

        if ((NameLen > NETBIOS_NAME_SIZE) ||
            ((IsDeviceNetbiosless(pDeviceContext)) && (!NT_SUCCESS(status))))
        {
            if (pContext = (NBT_WORK_ITEM_CONTEXT*)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG('H')))
            {
                pContext->pTracker = NULL;              // no query tracker
                pContext->pClientContext = pTracker;    // the client tracker
                pContext->ClientCompletion = SendDgramContinue;
                pContext->pDeviceContext = pDeviceContext;

                //
                // Start the timer so that the request does not hang waiting for Dns!
                //
                StartLmHostTimer(pContext, FALSE);
                status = NbtProcessLmhSvcRequest (pContext, NBT_RESOLVE_WITH_DNS);
                if (!NT_SUCCESS (status))
                {
                    CTEMemFree(pContext);
                }
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (status == STATUS_SUCCESS)   // If the name was an IP address or was present in the cache
    {
        SendDgramContinue (pTracker, STATUS_SUCCESS);
        status = STATUS_PENDING;    // SendDgramContinue will cleanup and complete the Irp
    }
    else if (status != STATUS_PENDING)
    {
        *pSentLength = 0;
        NTClearFindNameInfo (pTracker, &pIrp, pIrp, pIrpSp);
        if (!pIrp)
        {
            status = STATUS_PENDING; // irp is already completed: return pending so we don't complete again
        }

        pTracker->pNameAddr = NULL;
        DgramSendCleanupTracker(pTracker,status,FALSE);
    }

NbtSendDatagram_Exit:

    if (pDeviceContextOut)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, FALSE);
    }

    //
    // return the status to the client.
    //
    return(status);
}

//----------------------------------------------------------------------------
VOID
SendDgramContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface after the destination name has resolved to an IP address.
    This routine is given as the completion routine to the "QueryNameOnNet" call
    in NbtSendDatagram, above.  When a name query response comes in or the
    timer times out after N retries.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    CTELockHandle           OldIrq;
    ULONG                   lNameType;
    tNAMEADDR               *pNameAddr = NULL;
    tNAMEADDR               *p1CNameAddr = NULL;
    tDGRAM_SEND_TRACKING    *pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    tDEVICECONTEXT          *pDeviceContext = pTracker->pDeviceContext;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;

    CHECK_PTR(pTracker);
    DELETE_CLIENT_SECURITY(pTracker);

    //
    // The Tracker can get cleaned up somewhere and reassigned if we fail below
    // causing the pClientIrp ptr to get lost.  We need to save the Irp here
    //
    IoAcquireCancelSpinLock(&OldIrq);
    if (pIrp = pTracker->pClientIrp)
    {
        pTracker->pClientIrp = NULL;
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        ASSERT (pIrpSp->Parameters.Others.Argument4 == pTracker);
        pIrpSp->Parameters.Others.Argument4 = NULL;

        IoSetCancelRoutine(pIrp, NULL);
    }
    IoReleaseCancelSpinLock(OldIrq);

    //
    // We have to reference the Device here for the calls to FindNameRemoteThenLocal,
    // and also for SendDgram
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pIrp) &&
        (NBT_REFERENCE_DEVICE(pDeviceContext, REF_DEV_DGRAM, TRUE)))
    {
        //
        // attempt to find the destination name in the remote hash table.  If its
        // there, then send to it. For 1c names, this node may be the only node
        // with the 1c name registered, so check the local table, since we skipped
        // it if the name ended in 1c.
        //
        if ((status == STATUS_SUCCESS) ||
            (pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c))
        {
            if (pTracker->pNameAddr)
            {
                pNameAddr = pTracker->pNameAddr;
            }
            else
            {
                //
                // Find and reference the Names if they were resolved
                //
                //
                // check if it is a 1C name and if there is a name in the domain list
                // If pNameAddr is not null, then the send to the domainlist will
                // send to the p1CNameAddr after sending to pNameAddr
                //
                if ((pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c) &&
                    (p1CNameAddr = FindInDomainList(pTracker->pDestName,&DomainNames.DomainList)))
                {
                    NBT_REFERENCE_NAMEADDR (p1CNameAddr, REF_NAME_SEND_DGRAM);
                }

                if (pNameAddr = FindNameRemoteThenLocal(pTracker,&pTracker->RemoteIpAddress,&lNameType))
                {
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM);
                }
                else
                {
                    //
                    // if there is no pNameAddr then just make the domain list
                    // name the only pNameAddr to send to.
                    //
                    pNameAddr = p1CNameAddr;
                    p1CNameAddr = NULL;
                }

                pTracker->pNameAddr = pNameAddr;
                pTracker->p1CNameAddr = p1CNameAddr;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // check if the name resolved or we have a list of domain names
        // derived from the lmhosts file and it is a 1C name send.
        //
        if (pNameAddr)
        {
            // send the first datagram queued to this name
            status = SendDgram(pNameAddr,pTracker);
        }
        else
        {
            status = STATUS_BAD_NETWORK_PATH;
        }

        NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_DGRAM, FALSE);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = STATUS_INVALID_DEVICE_STATE;
    }

    //
    // set this so that the cleanup routine does not try to dereference
    // the nameAddr

    if (status == STATUS_TIMEOUT)
    {
        status = STATUS_BAD_NETWORK_PATH;
    }

    if (pIrp)
    {
        if (NT_SUCCESS(status))
        {
            NTIoComplete (pIrp, STATUS_SUCCESS,((PTDI_REQUEST_KERNEL_SENDDG)&pIrpSp->Parameters)->SendLength);
        }
        else
        {
            // this is the ERROR handling if something goes wrong with the send
            CTEIoComplete(pIrp,status,0L);
        }
    }

    // a failure ret code means the send failed, so cleanup the tracker etc.
    if (!NT_SUCCESS(status))
    {
        DgramSendCleanupTracker(pTracker,status,FALSE);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
SendDgram(
    IN  tNAMEADDR               *pNameAddr,
    IN  tDGRAM_SEND_TRACKING    *pTracker
    )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface after the destination name has resolved to an IP address. The
    routine specifically handles sending to internet group names where the destination
    is a list of ip addresses.

    The Device must be referenced before calling this routine!

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    ULONG                   IpAddress;
    NTSTATUS                status;
    PFILE_OBJECT            pFileObject;

    CHECK_PTR(pTracker);

    if (pNameAddr->NameTypeState & NAMETYPE_UNIQUE )
    {
        ((tDGRAMHDR *)pTracker->SendBuffer.pDgramHdr)->MsgType = DIRECT_UNIQUE;
    }
    else if (pNameAddr->Name[0] == '*')
    {
        ((tDGRAMHDR *)pTracker->SendBuffer.pDgramHdr)->MsgType = BROADCAST_DGRAM;
    }
    else
    {
        // must be group, -
        ((tDGRAMHDR *)pTracker->SendBuffer.pDgramHdr)->MsgType = DIRECT_GROUP;
    }

    //
    // if it is an internet group name, then send to the list of addresses
    //
    if (pNameAddr->NameTypeState & NAMETYPE_INET_GROUP)
    {
        status = DatagramDistribution(pTracker,pNameAddr);
        return(STATUS_PENDING);     // DatagramDistribution will cleanup if it failed!
    }

    if (pNameAddr->NameTypeState & NAMETYPE_GROUP)
    {
        IpAddress = 0;
    }
    else if (pNameAddr->Verify == REMOTE_NAME)
    {
        IpAddress = pTracker->RemoteIpAddress;
    }
    // LOCAL_NAME   Unique
    else if (IsDeviceNetbiosless(pTracker->pDeviceContext)) // use any non-zero value for local address
    {
        IpAddress = LOOP_BACK;
    }
    else
    {
        IpAddress = pTracker->pDeviceContext->IpAddress;
    }

    pTracker->p1CNameAddr = NULL;
    pTracker->IpListIndex = 0; // flag that there are no more addresses in the list

    /*
     * Strict source routing,
     *  1. The machine should be multi-homed.
     *  2. It is not turned off by the registry key.
     *  3. It is a regular device (not cluster device or SMB device).
     */
    if (!IsLocalAddress(IpAddress) && NbtConfig.MultiHomed && NbtConfig.SendDgramOnRequestedInterfaceOnly &&
            pTracker->pDeviceContext->IPInterfaceContext != (ULONG)(-1) &&
            (!IsDeviceNetbiosless(pTracker->pDeviceContext))) {
        ULONG   Interface, Metric;

        pTracker->pDeviceContext->pFastQuery(htonl(IpAddress), &Interface, &Metric); 
        if (Interface != pTracker->pDeviceContext->IPInterfaceContext) {
            SendDgramCompletion(pTracker, STATUS_SUCCESS, 0);
            return STATUS_PENDING;
        }
    }

    // send the Datagram...
    status = UdpSendDatagram( pTracker,
                              IpAddress,
                              SendDgramCompletion,
                              pTracker,               // context for completion
                              pTracker->pDeviceContext->DatagramPort,
                              NBT_DATAGRAM_SERVICE);

    // the irp will be completed via SendDgramCompletion
    // so don't complete it by the caller too
    return(STATUS_PENDING);
}


//----------------------------------------------------------------------------
extern
VOID
SendDgramCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo
    )
{
    CTELockHandle           OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTracker->IpListIndex)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        SendNextDgramToGroup(pTracker, status);     // Further processing will be done here for Group sends
    }
    else
    {
        //
        // Datagram send to a unique name!
        //
        DgramSendCleanupTracker(pTracker,status,TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
VOID
DelayedSendDgramDist (
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused1,
    IN  tDEVICECONTEXT          *Unused2
    )

/*++

Routine Description:

    This function is called by the Executive Worker thread to send another
    datagram for the 1C name datagram distribution function.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    NTSTATUS                status;
    tDEVICECONTEXT          *pDeviceContext = pTracker->pDeviceContext;

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.DelayedSendDgramDist: To name %15.15s<%X>:Ip %X, \n",
            pTracker->pNameAddr->Name,pTracker->pNameAddr->Name[15],pClientContext));

    // send the Datagram...
    if (NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DGRAM, FALSE))
    {
        status = UdpSendDatagram (pTracker,
                                  (tIPADDRESS) PtrToUlong(pClientContext),
                                  SendDgramCompletion,
                                  pTracker,
#ifdef _NETBIOSLESS
                                  pTracker->pDeviceContext->DatagramPort,
#else
                                  NBT_DATAGRAM_UDP_PORT,
#endif
                                  NBT_DATAGRAM_SERVICE);

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DGRAM, FALSE);
    }
    else
    {
        SendNextDgramToGroup (pTracker, STATUS_BAD_NETWORK_PATH);
    }
}



//----------------------------------------------------------------------------
extern
VOID
SendNextDgramToGroup(
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN  NTSTATUS            status
    )
/*++
Routine Description

    This routine is hit when the
    datagram has been sent by the transport and it completes the request back
    to us ( may not have actually sent on the wire though ).

    This routine also handles sending multiple datagrams for the InternetGroup name
    case.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tIPADDRESS              IpAddress;
    CTELockHandle           OldIrq;

    // if this an Internet group send, then there may be more addresses in
    // the list to send to.  So check the IpListIndex.  For single
    // sends, this value is set to 0 and the code will jump to the bottom
    // where the client's irp will be completed.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    ASSERT (pTracker->RCount);  // RCount is still referenced from the last send
    // The SendCompletion can happen after the Device has been unbound,
    // so check for that also!

    if ((NT_SUCCESS(status)) &&
        (pTracker->IpListIndex < END_DGRAM_DISTRIBUTION))
    {
        IpAddress = pTracker->pGroupList[pTracker->IpListIndex++];

        if (IpAddress != (tIPADDRESS) -1) // The list ends in a -1 ipaddress, so stop when we see that
        {
            //
            // We already have an RCount reference, so no need to do another one here!
            if (NT_SUCCESS (CTEQueueForNonDispProcessing( DelayedSendDgramDist,
                                                          pTracker,
                                                          ULongToPtr(IpAddress),
                                                          NULL,
                                                          pTracker->pDeviceContext,
                                                          TRUE)))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                return;
            }
        }
    }

    pTracker->RCount--; // decrement the ref count done during the last send
    pTracker->IpListIndex = END_DGRAM_DISTRIBUTION;

    //
    // Either we failed, or we are done, so if the Timer is running, let it cleanup!
    //

    if (!(pTracker->pTimer) &&
        (pTracker->RCount == 0))
    {
        DgramSendCleanupTracker(pTracker,status,TRUE);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
extern
VOID
DgramDistTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles a short timeout on a datagram distribution.  It
    checks if the dgram send is hung up in the transport doing an ARP and
    then it does the next dgram send if the first is still hung up.

Arguments:


Return Value:

    none

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        pTracker->pTimer = NULL;
        if ((pTracker->IpListIndex == END_DGRAM_DISTRIBUTION) &&
            (pTracker->RCount == 0))
        {
            DgramSendCleanupTracker(pTracker,STATUS_SUCCESS,TRUE);
        }
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // After the last dgram has completed the iplistindex will be set
    // to this and it is time to cleanup
    //
    if (pTracker->IpListIndex == END_DGRAM_DISTRIBUTION)
    {
        if (pTracker->RCount == 0)
        {
            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.DgramDistTimeout: Cleanup After DgramDistribution %15.15s<%X> \n",
                            pTracker->pNameAddr->Name,pTracker->pNameAddr->Name[15]));

            pTracker->pTimer = NULL;
            DgramSendCleanupTracker(pTracker,STATUS_SUCCESS,TRUE);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return;
        }
        else
        {
            //
            // Wait for the dgram that has not completed yet - which may not
            // be the last dgram , since ARP could hold one up much long
            // than all the rest if the destination is dead. so start the timer
            // again....
            //
        }
    }
    else
    {
        if (pTracker->IpListIndex == pTracker->SavedListIndex)
        {
            //
            // The dgram send is hung up in the transport, so do the
            // next one now
            //
            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.DgramDistTimeout: DgramDistribution hung up on ARP forcing next send\n"));

            pTracker->RCount++;     // Reference it here since SendDgramToGroup expects this to be ref'ed

            pTimerQEntry->Flags |= TIMER_RESTART;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            SendNextDgramToGroup(pTracker,STATUS_SUCCESS);
            return;
        }
        else
        {

            //
            // Save the current index so we can check it the next time the timer
            // expires
            //
            pTracker->SavedListIndex = pTracker->IpListIndex;
        }

    }

    pTimerQEntry->Flags |= TIMER_RESTART;
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
NTSTATUS
DatagramDistribution(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  tNAMEADDR               *pNameAddr
    )

/*++
Routine Description

    This routine sends a single datagram for a 1C name.  It then sends
    the next one when this one completes.  This is done so that if
    multiple sends go to the gateway, one does not cancel the next
    when an Arp is necessary to resolve the gateway.

Arguments:

    pTracker
    pNameAddr

Return Values:

    VOID

--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    NTSTATUS                Locstatus;
    tIPADDRESS              *pIpList;
    ULONG                   Index;
    tIPADDRESS              IpAddress;
    tDEVICECONTEXT          *pDeviceContext;
    CTELockHandle           OldIrq;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    status = GetListOfAllAddrs (pTracker->pNameAddr, pTracker->p1CNameAddr, &pIpList, &Index);

    if (pTracker->p1CNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->p1CNameAddr, REF_NAME_SEND_DGRAM, TRUE);
        pTracker->p1CNameAddr = NULL;
    }

    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_SEND_DGRAM, TRUE);
    pTracker->pNameAddr = NULL;
    pTracker->RCount = 1;   // Send RefCount == 0 when last send completes
    pDeviceContext = pTracker->pDeviceContext;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    if (STATUS_SUCCESS == status)
    {
        FilterIpAddrsForDevice (pIpList, pTracker->pDeviceContext, &Index);

        pTracker->pGroupList = pIpList;

        //
        // When the proxy calls this routine the allocated length is set to
        // zero.  In that case we do not want to broadcast again since it
        // could setup an infinite loop with another proxy on the same
        // subnet.
        //
        if (pTracker->AllocatedLength == 0)
        {
            Index = 1;
        }
        else
        {
            Index = 0;
        }

        IpAddress = pIpList[Index];

        pTracker->SavedListIndex = (USHORT) (Index);    // For the next send in SendNextDgramToGroup
        pTracker->IpListIndex = pTracker->SavedListIndex + 1;    // For the next send in SendNextDgramToGroup

        if (IpAddress == (ULONG)-1)
        {
            status = STATUS_INVALID_ADDRESS;
        }
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((NT_SUCCESS(status)) &&
        (NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DGRAM, FALSE)))
    {
        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.DgramDistribution: To name %15.15s<%X>: %X, pTracker=<%p>\n",
                    pNameAddr->Name,pNameAddr->Name[15],IpAddress, pTracker));

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        Locstatus = StartTimer(DgramDistTimeout,
                               DGRAM_SEND_TIMEOUT,
                               pTracker,
                               NULL,
                               pTracker,
                               NULL,
                               pDeviceContext,
                               &pTracker->pTimer,
                               1,
                               TRUE);

        if (!NT_SUCCESS(Locstatus))
        {
            CHECK_PTR(pTracker);
            pTracker->pTimer = NULL;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // send the Datagram...
        status = UdpSendDatagram (pTracker,
                                  IpAddress,
                                  SendDgramCompletion,
                                  pTracker,
#ifdef _NETBIOSLESS
                                  pTracker->pDeviceContext->DatagramPort,
#else
                                  NBT_DATAGRAM_UDP_PORT,
#endif
                                  NBT_DATAGRAM_SERVICE);

        NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_DGRAM, FALSE);
    }

    if (!NT_SUCCESS(status))
    {
        //
        // we failed to send probably because of a lack of free memory
        //
        IoAcquireCancelSpinLock(&OldIrq);
        //
        // Make sure is still there!
        //
        if (pIrp = pTracker->pClientIrp)
        {
            pTracker->pClientIrp = NULL;
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            ASSERT (pIrpSp->Parameters.Others.Argument4 == pTracker);
            pIrpSp->Parameters.Others.Argument4 = NULL;
            IoSetCancelRoutine(pIrp, NULL);
            IoReleaseCancelSpinLock(OldIrq);
            if (NT_SUCCESS(status))
            {
                CTEIoComplete(pIrp, STATUS_SUCCESS, 0xFFFFFFFF);
            }
            else
            {
                CTEIoComplete(pIrp, status, 0L);
            }
        }
        else
        {
            IoReleaseCancelSpinLock(OldIrq);
        }

        pTracker->RCount--;
        DgramSendCleanupTracker(pTracker,STATUS_SUCCESS,FALSE);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSetEventHandler(
    tCLIENTELE  *pClientEle,
    int         EventType,
    PVOID       pEventHandler,
    PVOID       pEventContext
    )
/*++

Routine Description

    This routine sets the event handler specified to the clients event procedure
    and saves the corresponding context value to return when that event is signaled.
Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS            status;
    CTELockHandle       OldIrq;

    // first verify that the client element is valid
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status)

    if (!pClientEle->pAddress)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    CTESpinLock(pClientEle,OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtSetEventHandler: Handler <%x> set for Event <%x>, on name %16.16s<%X>\n",
                pEventHandler, EventType,
                ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name,
                ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name[15]));

    status = STATUS_SUCCESS;        // by default;

    if (pEventHandler)
    {
        switch (EventType)
        {
            case TDI_EVENT_CONNECT:
                pClientEle->evConnect = pEventHandler;
                pClientEle->ConEvContext = pEventContext;
                break;
            case TDI_EVENT_DISCONNECT:
                pClientEle->evDisconnect = pEventHandler;
                pClientEle->DiscEvContext = pEventContext;
                break;
            case TDI_EVENT_ERROR:
                pClientEle->evError = pEventHandler;
                pClientEle->ErrorEvContext = pEventContext;
                break;
            case TDI_EVENT_RECEIVE:
                pClientEle->evReceive = pEventHandler;
                pClientEle->RcvEvContext = pEventContext;
                break;
            case TDI_EVENT_RECEIVE_DATAGRAM:
                pClientEle->evRcvDgram = pEventHandler;
                pClientEle->RcvDgramEvContext = pEventContext;
                break;
            case TDI_EVENT_RECEIVE_EXPEDITED:
                pClientEle->evRcvExpedited = pEventHandler;
                pClientEle->RcvExpedEvContext = pEventContext;
                break;
            case TDI_EVENT_SEND_POSSIBLE:
                pClientEle->evSendPossible = pEventHandler;
                pClientEle->SendPossEvContext = pEventContext;
                break;

            case TDI_EVENT_CHAINED_RECEIVE:
            case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
            case TDI_EVENT_ERROR_EX:
                status = STATUS_UNSUCCESSFUL;
                break;

            default:
                ASSERTMSG("Invalid Event Type passed to SetEventHandler\n", (PVOID)0L);
                status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {   //
        // the event handlers are set to point to the TDI default event handlers
        // and can only be changed to another one, but not to a null address,
        // so if null is passed in, set to default handler.
        //
        switch (EventType)
        {
            case TDI_EVENT_CONNECT:
#ifndef VXD
                pClientEle->evConnect = TdiDefaultConnectHandler;
#else
                pClientEle->evConnect = NULL;
#endif
                pClientEle->ConEvContext = NULL;
                break;
            case TDI_EVENT_DISCONNECT:
#ifndef VXD
                pClientEle->evDisconnect = TdiDefaultDisconnectHandler;
#else
                pClientEle->evDisconnect = NULL;
#endif
                pClientEle->DiscEvContext = NULL;
                break;
            case TDI_EVENT_ERROR:
#ifndef VXD
                pClientEle->evError = TdiDefaultErrorHandler;
#else
                pClientEle->evError = NULL;
#endif
                pClientEle->ErrorEvContext = NULL;
                break;
            case TDI_EVENT_RECEIVE:
#ifndef VXD
                pClientEle->evReceive = TdiDefaultReceiveHandler;
#else
                pClientEle->evReceive = NULL;
#endif
                pClientEle->RcvEvContext = NULL;
                break;
            case TDI_EVENT_RECEIVE_DATAGRAM:
#ifndef VXD
                pClientEle->evRcvDgram = TdiDefaultRcvDatagramHandler;
#else
                pClientEle->evRcvDgram = NULL;
#endif
                pClientEle->RcvDgramEvContext = NULL;
                break;
            case TDI_EVENT_RECEIVE_EXPEDITED:
#ifndef VXD
                pClientEle->evRcvExpedited = TdiDefaultRcvExpeditedHandler;
#else
                pClientEle->evRcvExpedited = NULL;
#endif
                pClientEle->RcvExpedEvContext = NULL;
                break;
            case TDI_EVENT_SEND_POSSIBLE:
#ifndef VXD
                pClientEle->evSendPossible = TdiDefaultSendPossibleHandler;
#else
                pClientEle->evSendPossible = NULL;
#endif
                pClientEle->SendPossEvContext = NULL;
                break;

            case TDI_EVENT_CHAINED_RECEIVE:
            case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
            case TDI_EVENT_ERROR_EX:
                status = STATUS_UNSUCCESSFUL;
                break;

            default:
                ASSERTMSG("Invalid Event Type passed to SetEventHandler\n", (PVOID)0L);
                status = STATUS_UNSUCCESSFUL;
        }
    }

    CTESpinFree(pClientEle,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSendNodeStatus(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PCHAR           pName,
    IN  tIPADDRESS      *pIpAddrs,
    IN  PVOID           ClientContext,
    IN  PVOID           CompletionRoutine
    )
/*++

Routine Description

    This routine sends a node status message to another node.
    It's called for two reasons:
    1) in response to nbtstat -a (or -A).  In this case, CompletionRoutine that's
       passed in is CopyNodeStatusResponse, and ClientContext is the Irp to be completed
    2) in response to "net use \\foobar.microsoft.com" (or net use \\11.1.1.3)
       In this case, CompletionRoutine that's passed in is ExtractServerName,
       and ClientContext is the tracker that correspondes to session setup.

    The ip addr(s) s of the destination can be passed in (pIpAddrsList) when we
    want to send an adapter status to a particular host. (case 2 above and
    nbtstat -A pass in the ip address(es) since they don't know the name)

    Note for netbiosless.  In this case, the name server file object will be null, and the
    status request will be looped back in UdpSendDatagram.

Arguments:
Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    ULONG                   Length;
    PUCHAR                  pHdr;
    tNAMEADDR               *pNameAddr;
    PCHAR                   pName0;
    tIPADDRESS              IpAddress;
    tIPADDRESS UNALIGNED    *pAddress;
    tIPADDRESS              pIpAddress[2];
    tIPADDRESS              *pIpAddrsList = pIpAddrs;
    tDEVICECONTEXT          *pDeviceContextOut = NULL;
    DWORD                   i = 0;

    pName0 = pName;
    if ((pIpAddrsList) ||
        (IpAddress = Nbt_inet_addr (pName, REMOTE_ADAPTER_STAT_FLAG)))
    {
        if (!pIpAddrs)
        {
            pIpAddress[0] = IpAddress;
            pIpAddress[1] = 0;
            pIpAddrsList = pIpAddress;
        }

        if ((*pIpAddrsList == 0) ||
            (*pIpAddrsList == DEFAULT_BCAST_ADDR) ||
            (*pIpAddrsList == pDeviceContext->BroadcastAddress))
        {
            //
            // Can't do a remote adapter status to a 0 IP address or a BCast address
            return(STATUS_INVALID_ADDRESS);
        }

        // caller is expected to make sure list terminates in 0 and is
        // not bigger than MAX_IPADDRS_PER_HOST elements
        while(pIpAddrsList[i])
        {
            i++;
        }

        ASSERT(i<MAX_IPADDRS_PER_HOST);
        i++;                            // for the trailing 0


        IpAddress = pIpAddrsList[0];
        pDeviceContextOut = GetDeviceFromInterface (htonl(IpAddress), FALSE);
        if ((NbtConfig.ConnectOnRequestedInterfaceOnly) &&
            (!IsDeviceNetbiosless(pDeviceContext)) &&
            (pDeviceContext != pDeviceContextOut))
        {
            return (STATUS_BAD_NETWORK_PATH);
        }
        pName0 = NBT_BROADCAST_NAME;
    }

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.NbtSendNodeStatus: <%16.16s:%x>, IP=<%x>, Completion=<%p>, Context=<%p>\n",
            pName0, pName0[15], IpAddress, CompletionRoutine, ClientContext));

    status = GetTracker(&pTracker, NBT_TRACKER_SEND_NODE_STATUS);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    // fill in the tracker data block
    // note that the passed in transport address must stay valid till this
    // send completes
    pTracker->SendBuffer.pDgramHdr  = NULL;
    pTracker->SendBuffer.pBuffer    = NULL;
    pTracker->SendBuffer.Length     = 0;
    pTracker->Flags                 = REMOTE_ADAPTER_STAT_FLAG;
    pTracker->RefCount              = 2;     // 1 for the send completion + 1 for the node status completion
    pTracker->pDestName             = pName0;
    pTracker->UnicodeDestName       = NULL;
    pTracker->RemoteNameLength      = NETBIOS_NAME_SIZE; // May be needed for Dns Name resolution
    pTracker->pDeviceContext        = pDeviceContext;
    pTracker->pNameAddr             = NULL;
    pTracker->ClientCompletion      = CompletionRoutine;    // FindNameO.. may use CompletionRoutine!
    pTracker->ClientContext         = ClientContext;
    pTracker->p1CNameAddr           = NULL;

    // the node status is almost identical with the query pdu so use it
    // as a basis and adjust it .
    //
    pAddress = (ULONG UNALIGNED *)CreatePdu(pName0,
                                            NbtConfig.pScope,
                                            0L,
                                            0,
                                            eNAME_QUERY,
                                            (PVOID)&pHdr,
                                            &Length,
                                            pTracker);
    if (!pAddress)
    {
        FreeTracker(pTracker,RELINK_TRACKER);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    ((PUSHORT)pHdr)[1] &= ~(FL_RECURDESIRE|FL_BROADCAST);  // clear the recursion desired and broadcast bit
    pHdr[Length-3] = (UCHAR)QUEST_STATUS;   // set the NBSTAT field to 21 rather than 20

    pTracker->SendBuffer.pDgramHdr = (PVOID)pHdr;
    pTracker->SendBuffer.HdrLength  = Length;

    if (IpAddress)
    {
        // this 'fake' pNameAddr has to be setup carefully so that the memory
        // is released when NbtDeferenceName is called from SendDgramCompletion
        // Note that this code does not apply to NbtConnect since these names
        // are group names, and NbtConnect will not allow a session to a group
        // name.
        status = STATUS_INSUFFICIENT_RESOURCES;
        if (!(pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('K'))))
        {
            FreeTracker(pTracker,RELINK_TRACKER);
            CTEMemFree(pHdr);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));
        InitializeListHead (&pNameAddr->Linkage);
        CTEMemCopy (pNameAddr->Name, pName0, NETBIOS_NAME_SIZE ) ;
        pNameAddr->IpAddress        = IpAddress;
        pNameAddr->NameTypeState    = NAMETYPE_GROUP | STATE_RESOLVED;
        pNameAddr->Verify           = LOCAL_NAME;
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_NODE_STATUS);
        if (pDeviceContextOut)
        {
            pNameAddr->AdapterMask = pDeviceContextOut->AdapterMask;
        }
        pNameAddr->TimeOutCount     = NbtConfig.RemoteTimeoutCount;

        if (!(pNameAddr->pIpAddrsList = NbtAllocMem(i*sizeof(ULONG),NBT_TAG('M'))))
        {
            FreeTracker(pTracker,RELINK_TRACKER);
            CTEMemFree(pHdr);
            CTEMemFree(pNameAddr);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        i = 0;
        do
        {
            pNameAddr->pIpAddrsList[i] = pIpAddrsList[i];
        } while(pIpAddrsList[i++]);
 
        status = STATUS_SUCCESS;
    }
    else
    {
        status = FindNameOrQuery(pName,
                                 pDeviceContext,
                                 SendNodeStatusContinue,
                                 pTracker,
                                 (ULONG) NAMETYPE_UNIQUE,
                                 &IpAddress,
                                 &pNameAddr,
                                 REF_NAME_NODE_STATUS,
                                 FALSE);
    }

    if (status == STATUS_SUCCESS)
    {
        pTracker->RemoteIpAddress   = IpAddress;

        pTracker->p1CNameAddr   = pNameAddr;    // Since we have already Ref'ed
        pNameAddr->IpAddress    = IpAddress;

        SendNodeStatusContinue (pTracker, STATUS_SUCCESS);
        status = STATUS_PENDING;    // SendNodeStatusContinue will cleanup
    }
    else if (!NT_SUCCESS(status))   // i.e not pending
    {
        FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);
    }

    return(status);
}


//----------------------------------------------------------------------------
VOID
SendNodeStatusContinue(
    IN  PVOID       pContext,
    IN  NTSTATUS    status
    )
/*++

Routine Description

    This routine handles sending a node status request to a node after the
    name has been resolved on the net.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq, OldIrq1;
    tNAMEADDR               *pNameAddr = NULL;
    ULONG                   lNameType;
    tTIMERQENTRY            *pTimerEntry;
    ULONG                   IpAddress;
    PCTE_IRP                pIrp;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;

    pTracker = (tDGRAM_SEND_TRACKING *) pContext;
    ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
    ASSERT (pTracker->TrackerType == NBT_TRACKER_SEND_NODE_STATUS);

    DELETE_CLIENT_SECURITY(pTracker);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // attempt to find the destination name in the remote hash table.  If its
    // there, then send to it.
    //
    lNameType = NAMETYPE_UNIQUE;
    if ((status == STATUS_SUCCESS) &&
        ((pTracker->p1CNameAddr) ||
         (pNameAddr = FindNameRemoteThenLocal(pTracker, &IpAddress, &lNameType))))
    {
        //
        // found the name in the remote hash table, so send to it after
        // starting a timer to be sure we really do get a response
        //
        status = StartTimer(NodeStatusTimeout,
                            NbtConfig.uRetryTimeout,
                            pTracker,                       // Timer context value
                            NULL,                           // Timer context2 value
                            pTracker->ClientContext,        // ClientContext
                            pTracker->ClientCompletion,     // ClientCompletion
                            pTracker->pDeviceContext,
                            &pTimerEntry,
                            NbtConfig.uNumRetries,
                            TRUE);

        if (NT_SUCCESS(status))
        {
            if (pNameAddr)
            {
                // increment refcount so the name does not disappear
                // dereference when we get the response or timeout
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_NODE_STATUS);
                pTracker->RemoteIpAddress = IpAddress;
            }
            else
            {
                //
                // This name was already Referenced either in NbtSendNodeStatus
                // or FindNameOrQuery
                //
                pNameAddr = pTracker->p1CNameAddr;
                pTracker->p1CNameAddr = NULL;
                IpAddress = pTracker->RemoteIpAddress;
            }

            pTracker->pNameAddr = pNameAddr;
            pTracker->pTimer = pTimerEntry;

            // send the Datagram...
            // the tracker block is put on a global Q in the Config
            // data structure to keep track of it.
            //
            ExInterlockedInsertTailList(&NbtConfig.NodeStatusHead,
                                        &pTracker->Linkage,
                                        &NbtConfig.LockInfo.SpinLock);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            status = UdpSendDatagram (pTracker,
                                      IpAddress,
                                      NameDgramSendCompleted,
                                      pTracker,                 // context
#ifdef _NETBIOSLESS
                                      pTracker->pDeviceContext->NameServerPort,
#else
                                      NBT_NAMESERVICE_UDP_PORT,
#endif
                                      NBT_NAME_SERVICE);

            if (!(NT_SUCCESS(status)))
            {
                //
                // this undoes one of two ref's added in NbtSendNodeStatus
                //
                CTESpinLock(&NbtConfig.JointLock,OldIrq);

                CTEMemFree(pTracker->SendBuffer.pDgramHdr);
                pTracker->SendBuffer.pDgramHdr = NULL;
                NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }

            // if the send fails, the timer will resend it...so no need
            // to check the return code here.
            return;
        }
    }

    if (pTracker->p1CNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->p1CNameAddr, REF_NAME_NODE_STATUS, TRUE);
        pTracker->p1CNameAddr = NULL;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // this is the ERROR handling if we failed to resolve the name
    // or the timer did not start
    pClientCompletion = pTracker->ClientCompletion;
    pClientContext = pTracker->ClientContext;

    if (pClientCompletion)
    {
        (*pClientCompletion) (pClientContext, STATUS_UNSUCCESSFUL);
    }

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);
}


//----------------------------------------------------------------------------
VOID
NodeStatusTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles the NodeStatus timeouts on packets sent to nodes
    that do not respond in a timely manner to node status.  This routine will
    resend the request.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq, OldIrq1;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;
    PCHAR                   pName0;
    PUCHAR                  pHdr;
    ULONG                   Length;
    ULONG UNALIGNED         *pAddress;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
    ASSERT (pTracker->TrackerType == NBT_TRACKER_SEND_NODE_STATUS);

    if (!pTimerQEntry)
    {
        //
        // Do not dereference here since  Node Status Done will do
        // the dereference
        //
        CTESpinLock(&NbtConfig,OldIrq1);
        RemoveEntryList(&pTracker->Linkage);
        InitializeListHead(&pTracker->Linkage);
        CTESpinFree(&NbtConfig,OldIrq1);

        pTracker->pTimer = NULL;
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_NODE_STATUS, TRUE);
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

        return;
    }

    CHECK_PTR(pTimerQEntry);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTracker->SendBuffer.pDgramHdr)
    {
        //
        // The timer has expired before the original Datagram
        // could be sent, so just restart the timer!
        //
        pTimerQEntry->Flags |= TIMER_RESTART;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        return;
    }

    if ((--pTimerQEntry->Retries) == 0)
    {
        pClientCompletion = pTimerQEntry->ClientCompletion;
        pClientContext = pTimerQEntry->ClientContext;
        pTimerQEntry->ClientCompletion = NULL;
        pTracker->pTimer = NULL;

        // if the client routine has not yet run, run it now.
        if (pClientCompletion)
        {
            // unlink the tracker from the node status Q if we successfully
            // called the completion routine. Note, remove from the
            // list before calling the completion routine to coordinate
            // with DecodeNodeStatusResponse in inbound.c
            //
            CTESpinLock(&NbtConfig,OldIrq1);
            RemoveEntryList(&pTracker->Linkage);
            InitializeListHead(&pTracker->Linkage);
            CTESpinFree(&NbtConfig,OldIrq1);

            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_NODE_STATUS, TRUE);
            NBT_DEREFERENCE_TRACKER (pTracker, TRUE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            (*pClientCompletion) (pClientContext, STATUS_TIMEOUT);

        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        return;
    }

    // send the Datagram...increment ref count
    NBT_REFERENCE_TRACKER (pTracker);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // the node status is almost identical with the query pdu so use it
    // as a basis and adjust it . We always rebuild the Node status
    // request since the datagram gets freed when the irp is returned
    // from the transport.
    //

    if (pTracker->p1CNameAddr)
    {
        pName0 = pTracker->p1CNameAddr->Name;
    }
    else
    {
        pName0 = pTracker->pNameAddr->Name;
    }

    pAddress = (ULONG UNALIGNED *)CreatePdu(pName0,
                                            NbtConfig.pScope,
                                            0L,
                                            0,
                                            eNAME_QUERY,
                                            (PVOID)&pHdr,
                                            &Length,
                                            pTracker);
    if (pAddress)
    {
        // clear the recursion desired bit
        //
        ((PUSHORT)pHdr)[1] &= ~FL_RECURDESIRE;

        // set the NBSTAT field to 21 rather than 20
        pHdr[Length-3] = (UCHAR)QUEST_STATUS;


        // fill in the tracker data block
        // the passed in transport address must stay valid till this send completes
        pTracker->SendBuffer.pDgramHdr = (PVOID)pHdr;
        status = UdpSendDatagram (pTracker,
                                  pTracker->pNameAddr->IpAddress,
                                  NameDgramSendCompleted,
                                  pTracker,
#ifdef _NETBIOSLESS
                                  pTracker->pDeviceContext->NameServerPort,
#else
                                  NBT_NAMESERVICE_UDP_PORT,
#endif
                                  NBT_NAME_SERVICE);

    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (!(NT_SUCCESS(status)))
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        if (pTracker->SendBuffer.pDgramHdr)
        {
            CTEMemFree(pTracker->SendBuffer.pDgramHdr);
            pTracker->SendBuffer.pDgramHdr = NULL;
        }
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    // always restart even if the above send fails, since it might succeed
    // later.
    pTimerQEntry->Flags |= TIMER_RESTART;
}


//----------------------------------------------------------------------------
#ifndef VXD
VOID
NTClearFindNameInfo(
    tDGRAM_SEND_TRACKING    *pTracker,
    PIRP                    *ppClientIrp,
    PIRP                    pIrp,
    PIO_STACK_LOCATION      pIrpSp
    )
/*++

Routine Description

    This routine clears the Find Name information from the Tracker
    within the Cancel SpinLock -- since NbtQueryFindNameInfo is a
    pageable function, we have to do this in non-pageable code

Arguments:


Return Values:

    none

--*/
{
    CTELockHandle           OldIrq1;

    IoAcquireCancelSpinLock(&OldIrq1);
    *ppClientIrp = pTracker->pClientIrp;
    if (*ppClientIrp == pIrp)
    {
        pTracker->pClientIrp = NULL;
    }
    pIrpSp->Parameters.Others.Argument4 = NULL;
    IoReleaseCancelSpinLock(OldIrq1);
}
#endif  // !VXD



NTSTATUS
NbtQueryFindName(
    IN  PTDI_CONNECTION_INFORMATION     pInfo,
    IN  tDEVICECONTEXT                  *pDeviceContext,
    IN  PIRP                            pIrp,
    IN  BOOLEAN                         IsIoctl
    )
/*++

Routine Description

    This routine handles a Client's query to find a netbios name.  It
    ultimately returns the IP address of the destination.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    PCHAR                   pName;
    ULONG                   lNameType;
    tNAMEADDR               *pNameAddr;
    PIRP                    pClientIrp = 0;
    ULONG                   NameLen;
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;

#ifndef VXD
    PIO_STACK_LOCATION      pIrpSp;
#endif

    CTEPagedCode();

    // this routine gets a ptr to the netbios name out of the wierd
    // TDI address syntax.
    if (!IsIoctl)
    {
        ASSERT(pInfo->RemoteAddressLength);
        status = GetNetBiosNameFromTransportAddress((PTRANSPORT_ADDRESS) pInfo->RemoteAddress,
                                                    pInfo->RemoteAddressLength, &TdiAddr);
        pName = TdiAddr.OEMRemoteName.Buffer;
        NameLen = TdiAddr.OEMRemoteName.Length;
        lNameType = TdiAddr.NameType;

        if ((!NT_SUCCESS(status)) ||
            (lNameType != TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) ||
            (NameLen > NETBIOS_NAME_SIZE))
        {
            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.NbtQueryFindName: Unable to get dest name from address in QueryFindName\n"));
            return(STATUS_INVALID_PARAMETER);
        }
    }
#ifndef VXD
    else
    {
        pName = ((tIPADDR_BUFFER *)pInfo)->Name;
        NameLen = NETBIOS_NAME_SIZE;
    }
#endif

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.NbtQueryFindName: For  = %16.16s<%X>\n",pName,pName[15]));

    //
    // this will query the name on the network and call a routine to
    // finish sending the datagram when the query completes.
    //
    status = GetTracker(&pTracker, NBT_TRACKER_QUERY_FIND_NAME);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    pTracker->pClientIrp      = pIrp;
    pTracker->pDestName       = pName;
    pTracker->UnicodeDestName = NULL;
    pTracker->pDeviceContext  = pDeviceContext;
    pTracker->RemoteNameLength = NameLen;       // May be needed for Dns Name resolution

    //
    // Set the FIND_NAME_FLAG here to indicate to the DNS name resolution code that
    // this is not a session setup attempt so it can avoid the call to
    // ConvertToHalfAscii (where pSessionHdr is NULL).
    //
    if (IsIoctl)
    {
        // Do not do DNS query for this name since this is from GetHostByName!
        pTracker->Flags = REMOTE_ADAPTER_STAT_FLAG|FIND_NAME_FLAG|NO_DNS_RESOLUTION_FLAG;
    }
    else
    {
        pTracker->Flags = REMOTE_ADAPTER_STAT_FLAG|FIND_NAME_FLAG;
    }

#ifndef VXD
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.Others.Argument4 = (PVOID)pTracker;
    status = NTCheckSetCancelRoutine( pIrp, NbtCancelFindName,pDeviceContext );

    if (status == STATUS_CANCELLED )
    {
        FreeTracker(pTracker,RELINK_TRACKER);
        return(status);
    }
#endif

    status = FindNameOrQuery(pName,
                             pDeviceContext,
                             QueryNameCompletion,
                             pTracker,
                             (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                             &pTracker->RemoteIpAddress,
                             &pNameAddr,
                             REF_NAME_FIND_NAME,
                             FALSE);

    if ((status == STATUS_SUCCESS) || (!NT_SUCCESS(status)))
    {
#ifndef VXD
        NTClearFindNameInfo (pTracker, &pClientIrp, pIrp, pIrpSp);
#else
        pClientIrp = pTracker->pClientIrp;
#endif
        if (pClientIrp)
        {
            ASSERT( pClientIrp == pIrp );

            if (status == STATUS_SUCCESS)
            {
                status = CopyFindNameData(pNameAddr, pIrp, pTracker);
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_FIND_NAME, FALSE);
            }
        }

        //
        // irp is already completed: return pending so we don't complete again
        //
        else
        {
            if (status == STATUS_SUCCESS)
            {
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_FIND_NAME, FALSE);
            }
            status = STATUS_PENDING;
        }


        FreeTracker(pTracker, RELINK_TRACKER);
    }

    return(status);
}

//----------------------------------------------------------------------------
VOID
QueryNameCompletion(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        )
/*++

Routine Description

    This routine handles a name query completion that was requested by the
    client.  If successful the client is returned the ip address of the name
    passed in the original request.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq1;
    tNAMEADDR               *pNameAddr;
    ULONG                   lNameType;
    PIRP                    pClientIrp;
#ifndef VXD
    PIO_STACK_LOCATION      pIrpSp;

    //
    // We now use Cancel SpinLocks to check the validity of our Irps
    // This is to prevent a race condition in between the time that
    // the Cancel routine (NbtCancelFindName) releases the Cancel SpinLock
    // and acquires the joint lock and we complete the Irp over here
    //
    IoAcquireCancelSpinLock(&OldIrq1);
#endif

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pClientIrp = pTracker->pClientIrp;
    pTracker->pClientIrp = NULL;

#ifndef VXD
    //
    // Make sure all parameters are valid for the Irp processing
    //
    if (! ((pClientIrp) &&
           (pIrpSp = IoGetCurrentIrpStackLocation(pClientIrp)) &&
           (pIrpSp->Parameters.Others.Argument4 == pTracker)     ) )
    {
        IoReleaseCancelSpinLock(OldIrq1);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:QueryNameCompletion: Irp=<%p> was cancelled\n", pClientIrp));

        FreeTracker( pTracker,RELINK_TRACKER );
        return;
    }

    pIrpSp->Parameters.Others.Argument4 = NULL;
    IoSetCancelRoutine(pClientIrp, NULL);
    IoReleaseCancelSpinLock(OldIrq1);
#endif

    //
    // attempt to find the destination name in the local/remote hash table.
    //
    if ((status == STATUS_SUCCESS) &&
        (NT_SUCCESS(status = CopyFindNameData (NULL, pClientIrp, pTracker))))
    {
        CTEIoComplete(pClientIrp,status,0xFFFFFFFF);
    }
    else
    {
        // this is the ERROR handling if something goes wrong with the send
        CTEIoComplete(pClientIrp,STATUS_IO_TIMEOUT,0L);
    }

    FreeTracker(pTracker,RELINK_TRACKER);
}


//----------------------------------------------------------------------------
NTSTATUS
CopyFindNameData(
    IN  tNAMEADDR              *pNameAddr,
    IN  PIRP                   pIrp,
    IN  tDGRAM_SEND_TRACKING   *pTracker
    )
/*++
Routine Description:

    This Routine copies data received from the net node status response to
    the client's irp.


Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    PFIND_NAME_HEADER   pFindNameHdr;
    PFIND_NAME_BUFFER   pFindNameBuffer;
    tIPADDRESS          *pIpAddr = NULL;
    ULONG               BuffSize;
    ULONG               DataLength;
    ULONG               NumNames;
    ULONG               i;
    ULONG               lNameType;
    CTELockHandle       OldIrq;
    tIPADDRESS          SrcAddress, DestIpAddress;
    tIPADDRESS          *pIpAddrBuffer;
    tDEVICECONTEXT      *pDeviceContext = pTracker->pDeviceContext;

    SrcAddress = htonl(pDeviceContext->IpAddress);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (!pNameAddr)
    {
        if (pNameAddr = FindNameRemoteThenLocal (pTracker, &DestIpAddress, &lNameType))
        {
            pNameAddr->IpAddress = DestIpAddress;
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return (STATUS_IO_TIMEOUT);
        }
    }

    status = GetListOfAllAddrs(pNameAddr, NULL, &pIpAddr, &NumNames);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (STATUS_SUCCESS != status)
    {
        return (STATUS_IO_TIMEOUT);
    }

#ifdef VXD
    DataLength = ((NCB*)pIrp)->ncb_length ;
#else
    DataLength = MmGetMdlByteCount( pIrp->MdlAddress ) ;
#endif

    BuffSize = sizeof(FIND_NAME_HEADER) + NumNames*sizeof(FIND_NAME_BUFFER);

    //
    //  Make sure we don't overflow our buffer
    //
    if (BuffSize > DataLength)
    {
        if (DataLength <= sizeof(FIND_NAME_HEADER))
        {
            NumNames = 0 ;
        }
        else
        {
            NumNames = (DataLength - sizeof(FIND_NAME_HEADER)) / sizeof(FIND_NAME_BUFFER) ;
        }

        BuffSize = sizeof(FIND_NAME_HEADER) + NumNames*sizeof(FIND_NAME_BUFFER);
    }

    // sanity check that we are not allocating more than 64K for this stuff
    if (BuffSize > 0xFFFF)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    else if ((NumNames == 0) ||
             (!(pFindNameHdr = NbtAllocMem ((USHORT)BuffSize, NBT_TAG('N')))))
    {
        if (pIpAddr)
        {
            CTEMemFree((PVOID)pIpAddr);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Fill out the find name structure with zeros first
    CTEZeroMemory((PVOID)pFindNameHdr,BuffSize);
    pFindNameBuffer = (PFIND_NAME_BUFFER)((PUCHAR)pFindNameHdr + sizeof(FIND_NAME_HEADER));
    pFindNameHdr->node_count = (USHORT)NumNames;
    pFindNameHdr->unique_group = (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? UNIQUE_NAME : GROUP_NAME;

    for (i=0;i < NumNames ;i++)
    {
        // Note: the source and destination address appear to be
        // reversed since they are supposed to be the source and
        // destination of the response to the findname query, hence
        // the destination of the response is this node and the
        // source is the other node.
        *(tIPADDRESS UNALIGNED *) &pFindNameBuffer->source_addr[2]      = htonl(pIpAddr[i]);
        *(tIPADDRESS UNALIGNED *) &pFindNameBuffer->destination_addr[2] = SrcAddress;
        pFindNameBuffer++;
    }

#ifdef VXD
    CTEMemCopy (((NCB*)pIrp)->ncb_buffer, pFindNameHdr, BuffSize);
    ASSERT( ((NCB*)pIrp)->ncb_length >= BuffSize ) ;
    ((NCB*)pIrp)->ncb_length = BuffSize ;
    status = STATUS_SUCCESS ;
#else
    //
    // copy the buffer to the client's MDL
    //
    status = TdiCopyBufferToMdl (pFindNameHdr, 0, BuffSize, pIrp->MdlAddress, 0, &DataLength);

    pIrp->IoStatus.Information = DataLength;
    pIrp->IoStatus.Status = status;
#endif

    if (pIpAddr)
    {
        CTEMemFree((PVOID)pIpAddr);
    }
    CTEMemFree((PVOID)pFindNameHdr);

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAddEntryToRemoteHashTable(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN USHORT           NameAddFlag,
    IN PUCHAR           Name,
    IN ULONG            IpAddress,
    IN ULONG            Ttl,            // in seconds
    IN UCHAR            name_flags
    )
{
    NTSTATUS        status;
    tNAMEADDR       *pNameAddr;
    CTELockHandle   OldIrq;

    CTESpinLock (&NbtConfig.JointLock, OldIrq);

    //
    // We need only the name, IpAddress, name_flags, and Ttl fields
    //
    if (STATUS_SUCCESS == FindInHashTable (NbtConfig.pRemoteHashTbl,
                                           Name, NbtConfig.pScope, &pNameAddr))
    {
        status = STATUS_DUPLICATE_NAME;
    }
    else if (pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('8')))
    {
        CTEZeroMemory (pNameAddr,sizeof(tNAMEADDR));
        InitializeListHead (&pNameAddr->Linkage);
        pNameAddr->Verify = REMOTE_NAME;
        if (NameAddFlag & NAME_RESOLVED_BY_CLIENT)
        {
            pNameAddr->AdapterMask = (CTEULONGLONG)-1;
        }
        else if (pDeviceContext)
        {
            pNameAddr->AdapterMask = pDeviceContext->AdapterMask;
        }

        //
        // Now copy the user-supplied data
        //
        CTEMemCopy (pNameAddr->Name,Name,NETBIOS_NAME_SIZE);
        pNameAddr->TimeOutCount = (USHORT) (Ttl / (REMOTE_HASH_TIMEOUT/1000)) + 1;
        pNameAddr->IpAddress = IpAddress;
        if (name_flags & GROUP_STATUS)
        {
            pNameAddr->NameTypeState = STATE_RESOLVED | NAMETYPE_GROUP;
        }
        else
        {
            pNameAddr->NameTypeState = STATE_RESOLVED | NAMETYPE_UNIQUE;
        }

        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE);
        status = AddToHashTable(NbtConfig.pRemoteHashTbl,
                                pNameAddr->Name,
                                NbtConfig.pScope,
                                IpAddress,
                                0,
                                pNameAddr,
                                NULL,
                                pDeviceContext,
                                NameAddFlag);

        //
        // If AddToHashTable fails, it will free the pNameAddr structure
        // within itself, so no need to cleanup here!
        //
        if (NT_SUCCESS (status))    // SUCCESS if added first time, PENDING if name already existed!
        {
            status = STATUS_SUCCESS;
        }
        if (status == STATUS_SUCCESS && NameAddFlag & NAME_RESOLVED_BY_CLIENT) {
            //
            // this prevents the name from being deleted by the Hash Timeout code
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED);
            pNameAddr->Ttl = 0xFFFFFFFF;
            pNameAddr->NameTypeState |= PRELOADED | STATE_RESOLVED;
            pNameAddr->NameTypeState &= ~STATE_CONFLICT;
            pNameAddr->AdapterMask = (CTEULONGLONG)-1;
        }
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CTESpinFree (&NbtConfig.JointLock, OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtAddEntryToRemoteHashTable: Name=<%16.16s:%x>, status=<%x>\n",
            Name, Name[15], status));

    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtQueryAdapterStatus(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppAdapterStatus,
    IN OUT PLONG        pSize,
    enum eNbtLocation   Location
    )
/*++

Routine Description

    This routine creates a list of netbios names that are registered and
    returns a pointer to the list in pAdapterStatus.

    This routine can be called with a Null DeviceContext meaning, get the
    remote hash table names, rather than the local hash table names.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS            status;
    CTELockHandle       OldIrq1;
    LONG                ActualCount, AllocatedCount;
    LONG                j;
    LONG                BuffSize;
    PADAPTER_STATUS     pAdapterStatus;
    PLIST_ENTRY         pEntry;
    PLIST_ENTRY         pHead;
    PNAME_BUFFER        pNameBuffer;
    tADDRESSELE         *pAddressEle;
    tNAMEADDR           *pNameAddr;
    tHASHTABLE          *pHashTable;
    ULONG               NameSize;
    USHORT              MaxAllowed;
    PUCHAR              pMacAddr;
    tIPADDRESS          IpAddress;
    tIPADDRESS          *pIpNbtGroupList;
    ULONG               Ttl;

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    AllocatedCount = 0;
    if (Location == NBT_LOCAL)      // ==> Local Hash table
    {
        pHashTable = NbtConfig.pLocalHashTbl;
        NameSize = sizeof(NAME_BUFFER);
    }
    else                            // ==> Remote Hash table
    {
        // get the list of addresses for this device - remote hash table
        pHashTable = NbtConfig.pRemoteHashTbl;
        NameSize = sizeof(tREMOTE_CACHE);
    }

    for (j=0;j < pHashTable->lNumBuckets ;j++ )
    {
        pHead = &pHashTable->Bucket[j];
        pEntry = pHead;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            AllocatedCount++;
        }
    }

    // Allocate Memory for the adapter status
    BuffSize = sizeof(ADAPTER_STATUS) + AllocatedCount*NameSize;

#ifdef VXD
    //
    // The max BuffSize for Win9x is limited by a UShort,
    // so see if we are going to overflow that
    //
    if (BuffSize > MAXUSHORT)   // Make sure BuffSize fits in a USHORT
    {
        BuffSize = MAXUSHORT;   // Recalculate BuffSize and AllocatedCount
        AllocatedCount = (BuffSize - sizeof(ADAPTER_STATUS)) / NameSize;
    }
#endif  // VXD

#ifdef VXD
    pAdapterStatus = NbtAllocMem((USHORT)BuffSize,NBT_TAG('O'));
#else
    pAdapterStatus = NbtAllocMem(BuffSize,NBT_TAG('O'));
#endif

    if (!pAdapterStatus)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Fill out the adapter status structure with zeros first
    CTEZeroMemory((PVOID)pAdapterStatus,BuffSize);

    //
    // Fill in the  MAC address
    //
    pMacAddr = &pDeviceContext->MacAddress.Address[0];
    CTEMemCopy(&pAdapterStatus->adapter_address[0], pMacAddr, sizeof(tMAC_ADDRESS));

    pAdapterStatus->rev_major = 0x03;
    pAdapterStatus->adapter_type = 0xFE;    // pretend it is an ethernet adapter

    //
    // in the VXD land limit the number of Ncbs to 64
    //
#ifndef VXD
    MaxAllowed = 0xFFFF;
    pAdapterStatus->max_cfg_sess = (USHORT)MaxAllowed;
    pAdapterStatus->max_sess = (USHORT)MaxAllowed;
#else
    MaxAllowed = 64;
    pAdapterStatus->max_cfg_sess = pDeviceContext->cMaxSessions;
    pAdapterStatus->max_sess = pDeviceContext->cMaxSessions;
#endif

    pAdapterStatus->free_ncbs = (USHORT)MaxAllowed;
    pAdapterStatus->max_cfg_ncbs = (USHORT)MaxAllowed;
    pAdapterStatus->max_ncbs = (USHORT)MaxAllowed;

    pAdapterStatus->max_dgram_size    = MAX_NBT_DGRAM_SIZE;
    pAdapterStatus->max_sess_pkt_size = 0xffff;

    // get the address of the name buffer at the end of the adapter status
    // structure so we can copy the names into this area.
    pNameBuffer = (PNAME_BUFFER)((ULONG_PTR)pAdapterStatus + sizeof(ADAPTER_STATUS));

    ActualCount = 0;
    j = 0;
    if (Location == NBT_LOCAL)
    {
        pEntry = pHead = &NbtConfig.AddressHead;
    }
    else
    {
        pEntry = pHead = &pHashTable->Bucket[0];
    }

    while (AllocatedCount)
    {
        if (Location == NBT_LOCAL)
        {
            // ***** LOCAL HASH TABLE QUERY *****

            // get out of while if we reach the end of the list
            if ((pEntry = pEntry->Flink) == pHead)
            {
                break;
            }

            pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);
            pNameAddr = pAddressEle->pNameAddr;

            //
            // skip the broadcast name and any permanent names that are
            // registered as quick names(i.e. not registered on the net).
            //
            if ((pAddressEle->pNameAddr->Name[0] == '*') ||
                (pAddressEle->pNameAddr->NameTypeState & NAMETYPE_QUICK) ||
                (!(pAddressEle->pNameAddr->AdapterMask & pDeviceContext->AdapterMask)))  // This Device only
            {
                continue;
            }
        }
        else
        {
            // ***** REMOTE HASH TABLE QUERY *****

            //
            // See if we have reached the end of the HashTable
            //
            if (j == pHashTable->lNumBuckets)
            {
                break;
            }

            //
            // See if we have reached the last entry in the HashBucket
            //
            if ((pEntry = pEntry->Flink) == pHead)
            {
                pEntry = pHead = &pHashTable->Bucket[++j];
                continue;
            }

            // for the remote table, skip over scope records.
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

            // don't return scope records or resolving records
            //
            if ((pNameAddr->NameTypeState & NAMETYPE_SCOPE) ||
                (!(pNameAddr->NameTypeState & STATE_RESOLVED)) ||
                (!(pNameAddr->AdapterMask & pDeviceContext->AdapterMask)))
            {
                continue;
            }
            //
            // the remote cache query has a different structure that includes
            // the ip address. Return the ip address to the caller.
            //
            IpAddress = 0;
            PickBestAddress (pNameAddr, pDeviceContext, &IpAddress);
            ((tREMOTE_CACHE *)pNameBuffer)->IpAddress = IpAddress;

            // preloaded entries do not timeout
            //
            if (pNameAddr->NameTypeState & PRELOADED)
            {
                Ttl = 0xFFFFFFFF;
            }
            else
            {
                Ttl = ((pNameAddr->TimeOutCount+1) * REMOTE_HASH_TIMEOUT)/1000;
            }

            ((tREMOTE_CACHE *)pNameBuffer)->Ttl = Ttl;
        }

        pNameBuffer->name_flags = (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? UNIQUE_NAME : GROUP_NAME;
        switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
        {
            default:
            case STATE_RESOLVED:
                pNameBuffer->name_flags |= REGISTERED;
                break;

            case STATE_CONFLICT:
                pNameBuffer->name_flags |= DUPLICATE;
                break;

            case STATE_RELEASED:
                pNameBuffer->name_flags |= DEREGISTERED;
                break;

            case STATE_RESOLVING:
                pNameBuffer->name_flags |= REGISTERING;
                break;
        }

        //
        // name number 0 corresponds to perm.name name, so start from 1
        //
        pNameBuffer->name_num = (UCHAR) (ActualCount+1);
        CTEMemCopy(pNameBuffer->name,pNameAddr->Name,NETBIOS_NAME_SIZE);

        if (Location == NBT_LOCAL)
        {
            pNameBuffer++;
        }
        else
        {
            ((tREMOTE_CACHE *)pNameBuffer)++;
        }

        AllocatedCount--;
        ActualCount++;
    }

    //
    // ReCalculate the new BuffSize based on the number of names
    // we actually copied
    //
    BuffSize = sizeof(ADAPTER_STATUS) + ActualCount*NameSize;

    //
    // Is our status buffer size greater then the user's buffer?
    // If the user buffer is expected to overflow, then
    // set the name_count to the maximum number of valid names
    // in the buffer
    //
    if (BuffSize > *pSize)
    {
        //
        //  Recalc how many names will fit
        //
        if (*pSize <= sizeof(ADAPTER_STATUS))
        {
            ActualCount = 0;
        }
        else
        {
            ActualCount = (*pSize - sizeof(ADAPTER_STATUS)) / NameSize;
        }
    }

    pAdapterStatus->name_count = (USHORT)ActualCount;

    //
    // return the ptr to this wonderful structure of goodies
    //
    *ppAdapterStatus = (PVOID)pAdapterStatus;
    *pSize = BuffSize;

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return (STATUS_SUCCESS);

}
//----------------------------------------------------------------------------
NTSTATUS
NbtQueryConnectionList(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppConnList,
    IN OUT PLONG         pSize
    )
/*++

Routine Description

    This routine creates a list of netbios connections and returns them to the
    client.  It is used by the "NbtStat" console application.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    CTELockHandle       OldIrq3;
    LONG                Count;
    LONG                i;
    LONG                BuffSize;
    PLIST_ENTRY         pEntry;
    PLIST_ENTRY         pEntry1;
    PLIST_ENTRY         pEntry2;
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pHead1;
    PLIST_ENTRY         pHead2;
    ULONG               NameSize;
    tCONNECTIONS        *pCons;
    tCONNECTION_LIST    *pConnList;
    tADDRESSELE         *pAddressEle;
    tLOWERCONNECTION    *pLowerConn;
    tCONNECTELE         *pConnEle;
    tCLIENTELE          *pClient;
    NTSTATUS            status = STATUS_SUCCESS;    // default

    // locking the joint lock is enough to prevent new addresses from being
    // added to the list while we count the list.
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    // go through the list of addresses, then the list of clients on each
    // address and then the list of connection that are in use and those that
    // are currently Listening.
    //
    Count = 0;
    pHead = &NbtConfig.AddressHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        CTESpinLock(pAddressEle,OldIrq2);
        pHead1 = &pAddressEle->ClientHead;
        pEntry1 = pHead1->Flink;
        while (pEntry1 != pHead1)
        {
            pClient = CONTAINING_RECORD(pEntry1,tCLIENTELE,Linkage);
            pEntry1 = pEntry1->Flink;

            CTESpinLock(pClient,OldIrq3);
            pHead2 = &pClient->ConnectActive;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                // count the connections in use
                pEntry2 = pEntry2->Flink;
                Count++;
            }
            pHead2 = &pClient->ListenHead;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                // count the connections listening
                pEntry2 = pEntry2->Flink;
                Count++;
            }
            CTESpinFree(pClient,OldIrq3);
        }
        CTESpinFree(pAddressEle,OldIrq2);
        pEntry = pEntry->Flink;
    }
    NameSize = sizeof(tCONNECTIONS);

    // Allocate Memory for the adapter status
    BuffSize = sizeof(tCONNECTION_LIST) + Count*NameSize;

    pConnList = NbtAllocMem(BuffSize,NBT_TAG('P'));
    if (!pConnList)
    {
        CTESpinFree(&NbtConfig.JointLock, OldIrq1);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the adapter status structure
    //
    CTEZeroMemory ((PVOID)pConnList, BuffSize);
    pConnList->ConnectionCount = Count;
    *ppConnList = (PVOID)pConnList;

    if (Count == 0)
    {
        //
        // We are done!
        //
        *pSize = BuffSize;
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return status;
    }

    // get the address of the Connection List buffer at the end of the
    // structure so we can copy the Connection info into this area.
    pCons = pConnList->ConnList;

    pHead = &NbtConfig.AddressHead;
    pEntry = pHead->Flink;
    i = 0;
    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        pEntry = pEntry->Flink;

        CTESpinLock(pAddressEle,OldIrq2);
        pHead1 = &pAddressEle->ClientHead;
        pEntry1 = pHead1->Flink;
        while (pEntry1 != pHead1)
        {
            pClient = CONTAINING_RECORD(pEntry1,tCLIENTELE,Linkage);
            pEntry1 = pEntry1->Flink;

            CTESpinLock(pClient,OldIrq3);
            pHead2 = &pClient->ConnectActive;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                // count the connections in use
                pConnEle = CONTAINING_RECORD(pEntry2,tCONNECTELE,Linkage);

                if (pConnEle->pDeviceContext == pDeviceContext)
                {
                    CTEMemCopy(pCons->LocalName,
                              pConnEle->pClientEle->pAddress->pNameAddr->Name,
                              NETBIOS_NAME_SIZE);

                    pLowerConn = pConnEle->pLowerConnId;
                    if (pLowerConn)
                    {
                        pCons->SrcIpAddr = pLowerConn->SrcIpAddr;
                        pCons->Originator = (UCHAR)pLowerConn->bOriginator;
#ifndef VXD
                        pCons->BytesRcvd = *(PLARGE_INTEGER)&pLowerConn->BytesRcvd;
                        pCons->BytesSent = *(PLARGE_INTEGER)&pLowerConn->BytesSent;
#else
                        pCons->BytesRcvd = pLowerConn->BytesRcvd;
                        pCons->BytesSent = pLowerConn->BytesSent;
#endif
                        CTEMemCopy(pCons->RemoteName,pConnEle->RemoteName,NETBIOS_NAME_SIZE);
                    }

                    pCons->State = pConnEle->state;
                    i++;
                    pCons++;

                    if (i >= Count)
                    {
                        break;
                    }
                }

                pEntry2 = pEntry2->Flink;
            }
            if (i >= Count)
            {
                CTESpinFree(pClient,OldIrq3);
                break;
            }

            //
            // now for the Listens
            //
            pHead2 = &pClient->ListenHead;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                tLISTENREQUESTS  *pListenReq;

                // count the connections listening on this Device
                pListenReq = CONTAINING_RECORD(pEntry2,tLISTENREQUESTS,Linkage);
                pConnEle = (tCONNECTELE *)pListenReq->pConnectEle;
                pEntry2 = pEntry2->Flink;

                if (pConnEle->pDeviceContext == pDeviceContext)
                {
                    CTEMemCopy(pCons->LocalName,
                              pConnEle->pClientEle->pAddress->pNameAddr->Name,
                              NETBIOS_NAME_SIZE);

                    pCons->State = LISTENING;

                    i++;
                    pCons++;

                    if (i >= Count)
                    {
                        break;
                    }
                }
            }
            CTESpinFree(pClient,OldIrq3);
            if (i >= Count)
            {
                break;
            }
        }

        CTESpinFree(pAddressEle,OldIrq2);
        if (i >= Count)
        {
            break;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    //
    // return the ptr to this wonderful structure of goodies
    //
    Count = i;
    BuffSize = sizeof(tCONNECTION_LIST) + Count*NameSize;

    //
    //  Is our status buffer size greater then the user's buffer?
    //  Set the Count value based on the number of connections
    //  actually being returned
    //
    if (BuffSize > *pSize)
    {
        //
        //  Recalc how many names will fit
        //  tCONNECTION_LIST already contains space for 1 tCONNECTION
        //  structure, but we will not include it in our calculations
        //  -- rather we will leave it as an overflow check
        //
        if (*pSize <= sizeof(tCONNECTION_LIST))
        {
            Count = 0 ;
        }
        else
        {
            Count = (*pSize - sizeof(tCONNECTION_LIST)) / NameSize ;
        }
    }

    pConnList->ConnectionCount = Count;
    *pSize = BuffSize;

    return status;
}
//----------------------------------------------------------------------------
VOID
DelayedNbtResyncRemoteCache(
    IN  PVOID                   Unused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    )
/*++

Routine Description

    This routine creates a list of netbios connections and returns them to the
    client.  It is used by the "NbtStat" console application.
    It cannot be called with any lock or NbtConfig.Resource held!

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tTIMERQENTRY        TimerEntry = {0};
    LONG                i;
    LONG                lRetcode;
    PUCHAR              LmHostsPath;

    CTEPagedCode();
    //
    // calling this routine N+1 times should remove all names from the remote
    // hash table - N to count down the TimedOutCount to zero and then
    // one more to remove the name
    //
    RemoteHashTimeout(NbtConfig.pRemoteHashTbl,NULL,&TimerEntry);
    RemovePreloads();           // now remove any preloaded entries

    // now reload the preloads
#ifndef VXD
    //
    // The NbtConfig.pLmHosts path can change if the registry is
    // read during this interval
    // We cannot acquire the ResourceLock here since reading the
    // LmHosts file might result in File operations + network reads
    // that could cause a deadlock (Worker threads / ResourceLock)!
    // Best solution at this time is to copy the path onto a local
    // buffer under the Resource lock, and then try to read the file!
    // Bug # 247429
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    if ((!NbtConfig.pLmHosts) ||
        (!(LmHostsPath = NbtAllocMem ((strlen(NbtConfig.pLmHosts)+1), NBT_TAG2('23')))))
    {
        CTEExReleaseResource(&NbtConfig.Resource);
        return;
    }

    CTEMemCopy (LmHostsPath, NbtConfig.pLmHosts, (strlen(NbtConfig.pLmHosts)+1));
    CTEExReleaseResource(&NbtConfig.Resource);

    lRetcode = PrimeCache(LmHostsPath, NULL, MAX_RECURSE_DEPTH, NULL);

    CTEMemFree(LmHostsPath);

    return;
#else
    lRetcode = PrimeCache(NbtConfig.pLmHosts, NULL, MAX_RECURSE_DEPTH, NULL);
    //
    // check if things didn't go well (InDos was set etc.)
    //
    if (lRetcode == -1)
    {
        return (STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
#endif  // !VXD
}
//----------------------------------------------------------------------------
NTSTATUS
NbtQueryBcastVsWins(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppBuffer,
    IN OUT PLONG         pSize
    )
/*++

Routine Description

    This routine creates a list of netbios names that have been resolved
    via broadcast and returns them along with the count of names resolved
    via WINS and via broadcast.  It lets a user know which names are not
    in WINS and the relative frequency of "misses" with WINS that resort
    to broadcast.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tNAMESTATS_INFO     *pStats;
    LONG                Count;
    tNAME               *pDest;
    tNAME               *pSrc;
    LONG                Index;

    //
    //  Is our status buffer size greater then the user's buffer?
    //
    if ( sizeof(tNAMESTATS_INFO) > *pSize )
    {
        return (STATUS_BUFFER_TOO_SMALL);
    }

    pStats = NbtAllocMem(sizeof(tNAMESTATS_INFO),NBT_TAG('Q'));
    if ( !pStats )
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    // Fill out the adapter status structure with zeros first
    CTEZeroMemory((PVOID)pStats,sizeof(tNAMESTATS_INFO));
    CTEMemCopy(pStats,&NameStatsInfo,FIELD_OFFSET(tNAMESTATS_INFO,NamesReslvdByBcast) );

    //
    // re-order the names so that names are returned in a list of newest to
    // oldest down the list.
    //
    Count = 0;
    Index = NameStatsInfo.Index;
    pDest = &pStats->NamesReslvdByBcast[SIZE_RESOLVD_BY_BCAST_CACHE-1];

    while (Count < SIZE_RESOLVD_BY_BCAST_CACHE)
    {
        pSrc = &NameStatsInfo.NamesReslvdByBcast[Index++];

        CTEMemCopy(pDest,pSrc,NETBIOS_NAME_SIZE);

        pDest--;
        if (Index >= SIZE_RESOLVD_BY_BCAST_CACHE)
        {
            Index = 0;
            pSrc = NameStatsInfo.NamesReslvdByBcast;
        }
        else
        {
            pSrc++;
        }

        Count++;
    }

    //
    // return the ptr to this wonderful structure of goodies
    //
    *ppBuffer = (PVOID)pStats;
    *pSize = sizeof(tNAMESTATS_INFO);

    return STATUS_SUCCESS;
}


ULONG
RemoveCachedAddresses(
    tDEVICECONTEXT  *pDeviceContext
    )
{
    LONG                    i;
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    tHASHTABLE              *pHashTable;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    ULONG   Count = 0;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // go through the Remote table removing addresses resolved on this interface
    //
    pHashTable = NbtConfig.pRemoteHashTbl;
    for (i=0; i < pHashTable->lNumBuckets; i++)
    {
        pHead = &pHashTable->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;
            //
            // do not delete scope entries, and do not delete names that
            // that are still resolving, and do not delete names that are
            // being used by someone (refcount > 1)
            //
            if (pNameAddr->RemoteCacheLen > pDeviceContext->AdapterNumber)
            {
                pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].IpAddress = 0;
                if (pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs)
                {
                    CTEMemFree(pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs);
                    pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs = NULL;
                }
                pNameAddr->AdapterMask &= ~pDeviceContext->AdapterMask;

#if DBG
/*
// MALAM_FIX -- Preloaded entries have 2 References!
                if ((!pNameAddr->AdapterMask) &&
                    (!(pNameAddr->NameTypeState & NAMETYPE_SCOPE)))
                {
                    RemoveEntryList (&pNameAddr->Linkage);
                    InsertTailList(&NbtConfig.StaleRemoteNames, &pNameAddr->Linkage);
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
*/
#endif  // DBG
                Count++;
            }
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (Count);
}

VOID
NbtAddressChangeResyncCacheTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
{
    if (!pTimerQEntry)
    {
        return;
    }

    CTEQueueForNonDispProcessing (DelayedNbtResyncRemoteCache, NULL, NULL, NULL, NULL, FALSE);

    return;
}


#ifndef VXD
//----------------------------------------------------------------------------
VOID
NbtCheckSetNameAdapterInfo(
    tDEVICECONTEXT  *pDeviceContext,
    ULONG           IpAddress
    )
{
    LONG                i;
    CTELockHandle       OldIrq;
    tTIMERQENTRY        *pTimerEntry;
    tNAMEADDR           *pNameAddr;
    tHASHTABLE          *pHashTable;
    PLIST_ENTRY         pHead, pEntry;
    BOOLEAN             fStartRefresh = FALSE;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pWinsInfo)
    {
        if (IpAddress)
        {
            //
            // If there is no IP address, or the new IP address is the one Wins had preferred,
            // use it
            //
            if (((IpAddress == pWinsInfo->IpAddress) || (!pWinsInfo->pDeviceContext)) &&
                (NBT_VERIFY_HANDLE (pDeviceContext, NBT_VERIFY_DEVCONTEXT)))
            {
                pWinsInfo->pDeviceContext = pDeviceContext;
            }
        }
        else
        {
            if (pDeviceContext == pWinsInfo->pDeviceContext)
            {
                pWinsInfo->pDeviceContext = GetDeviceWithIPAddress(pWinsInfo->IpAddress);
            }
        }
    }

    //
    // For a Netbiosless device notification, we are done!
    //
    if (pDeviceContext->DeviceType == NBT_DEVICE_NETBIOSLESS)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    if (IpAddress == 0)
    {
        //
        // See if there were any names in conflict which we need to refresh!
        //
        pHashTable = NbtConfig.pLocalHashTbl;
        for (i=0; i < pHashTable->lNumBuckets; i++)
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                pEntry = pEntry->Flink;

                if (pNameAddr->ConflictMask & pDeviceContext->AdapterMask)
                {
                    //
                    // Zero out the Conflicting adapter mask
                    // Restart Refreshing this name if there are no more
                    // adapters on which the name went into conflict
                    //
                    pNameAddr->ConflictMask &= (~pDeviceContext->AdapterMask);
                    if (!(pNameAddr->ConflictMask))
                    {
                        pNameAddr->RefreshMask = 0;
                        fStartRefresh = TRUE;
                    }
                }
            }
        }
    }
    else
    {
        if (NodeType & BNODE)
        {
            //
            // Stop the RefreshTimer if it is running!
            //
            if (pTimerEntry = NbtConfig.pRefreshTimer)
            {
                NbtConfig.pRefreshTimer = NULL;
                StopTimer (pTimerEntry, NULL, NULL);
            }
        }
        else
        {
            fStartRefresh = TRUE;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (fStartRefresh)
    {
        //
        // ReRegister all the local names on this device with the WINS server
        //
        ReRegisterLocalNames(pDeviceContext, FALSE);
    }

}
#endif  // !VXD

#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
//----------------------------------------------------------------------------
VOID
DelayedNbtProcessDhcpRequests(
    PVOID   Unused1,
    PVOID   Unused2,
    PVOID   Unused3,
    PVOID   pDevice)
/*++
Routine Description:

    Process each DHCP requests queued by NbtNewDhcpAddress

Arguments:

Return Value:
    NONE
--*/
{
    tDEVICECONTEXT          *pDeviceContext;
    CTELockHandle           OldIrq;
    enum eTDI_ACTION        action;

    pDeviceContext = (tDEVICECONTEXT*)pDevice;

    CTESpinLock(pDeviceContext, OldIrq);
    action = pDeviceContext->DelayedNotification;
    ASSERT(action == NBT_TDI_REGISTER || action == NBT_TDI_NOACTION);
    if (action != NBT_TDI_NOACTION) {
        pDeviceContext->DelayedNotification = NBT_TDI_BUSY;
    }
    CTESpinFree(pDeviceContext, OldIrq);

    if (action != NBT_TDI_NOACTION) {
        NbtNotifyTdiClients (pDeviceContext, action);
        CTESpinLock(pDeviceContext, OldIrq);
        pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
        CTESpinFree(pDeviceContext, OldIrq);
        KeSetEvent(&pDeviceContext->DelayedNotificationCompleteEvent, 0, FALSE);
    }

    //
    // Call this routine at PASSIVE_LEVEL
    //
    NbtDownBootCounter();
}

VOID
StartProcessNbtDhcpRequests(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
{
    /*
     * if pTimerQEntry == NULL, we are being called from StopTimer which is called by NbtDestroyDevice
     * DelayedNbtDeleteDevice will take care of notifying the clients and proper cleanup.
     */
    if (pTimerQEntry) {
        tDEVICECONTEXT          *pDeviceContext;

        pDeviceContext = (tDEVICECONTEXT*)(pTimerQEntry->pDeviceContext);
        if (!NT_SUCCESS(CTEQueueForNonDispProcessing (DelayedNbtProcessDhcpRequests,
                    NULL, NULL, NULL, (tDEVICECONTEXT*)pTimerQEntry->pDeviceContext, FALSE))) {
            pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
            KeSetEvent(&pDeviceContext->DelayedNotificationCompleteEvent, 0, FALSE);

            NbtDownBootCounter();
        }

    } else {

        NbtDownBootCounter();

    }
}

//----------------------------------------------------------------------------
NTSTATUS
NbtQueueTdiNotification (
    tDEVICECONTEXT  *pDeviceContext,
    enum eTDI_ACTION action
    )
/*++
Routine Description:

    1. Queue the DHCP address notifications into NbtConfig.DhcpNewAddressQList.
    2. Start the worker thread if needed.

Arguments:

Return Value:
    NTSTATUS
--*/

{
    NTSTATUS        status;
    CTELockHandle   OldIrq1, OldIrq2;

    if (NbtConfig.DhcpProcessingDelay == 0) {
        NbtNotifyTdiClients (pDeviceContext, action);
        return STATUS_SUCCESS;
    }

    if (action == NBT_TDI_DEREGISTER) {
        /*
         * This should be done synchronously
         */
        CTESpinLock(&NbtConfig.JointLock, OldIrq1);
        CTESpinLock(pDeviceContext, OldIrq2);
        if (pDeviceContext->DelayedNotification != NBT_TDI_BUSY) {
            pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
            KeSetEvent(&pDeviceContext->DelayedNotificationCompleteEvent, 0, FALSE);
        } else {
            ASSERT(!KeReadStateEvent(&pDeviceContext->DelayedNotificationCompleteEvent));
        }
        CTESpinFree(pDeviceContext, OldIrq2);
        CTESpinFree(&NbtConfig.JointLock, OldIrq1);
        status = KeWaitForSingleObject(
                        &pDeviceContext->DelayedNotificationCompleteEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
        ASSERT(status == STATUS_WAIT_0);
        NbtNotifyTdiClients (pDeviceContext, NBT_TDI_DEREGISTER);
        return STATUS_SUCCESS;
    }

    /*
     * Queue NBT_TDI_REGISTER
     */
    ASSERT(action == NBT_TDI_REGISTER);

    CTESpinLock(&NbtConfig.JointLock, OldIrq1);
    CTESpinLock(pDeviceContext, OldIrq2);
    if (pDeviceContext->DelayedNotification != NBT_TDI_NOACTION) {
        /*
         * Do nothing because another indication is going on
         */
        ASSERT(pDeviceContext->DelayedNotification == NBT_TDI_REGISTER ||
                pDeviceContext->DelayedNotification == NBT_TDI_BUSY);
        CTESpinFree(pDeviceContext, OldIrq2);
        CTESpinFree(&NbtConfig.JointLock, OldIrq1);
        return STATUS_SUCCESS;
    }

    status = StartTimer (StartProcessNbtDhcpRequests, NbtConfig.DhcpProcessingDelay,
                    NULL, NULL, NULL, NULL, pDeviceContext, NULL, 0, TRUE);
    if (NT_SUCCESS(status)) {
        KeResetEvent(&pDeviceContext->DelayedNotificationCompleteEvent);
        pDeviceContext->DelayedNotification = action;
        NbtUpBootCounter();
    }
    CTESpinFree(pDeviceContext, OldIrq2);
    CTESpinFree(&NbtConfig.JointLock, OldIrq1);

    if (!NT_SUCCESS(status)) {
        NbtNotifyTdiClients (pDeviceContext, action);
    }

    return STATUS_SUCCESS;
}
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

//----------------------------------------------------------------------------
NTSTATUS
NbtNewDhcpAddress(
    tDEVICECONTEXT  *pDeviceContext,
    ULONG           IpAddress,
    ULONG           SubnetMask)

/*++

Routine Description:

    This routine processes a DHCP request to set a new ip address
    for this node.  Dhcp may pass in a zero for the ip address first
    meaning that it is about to change the IP address, so all connections
    should be shut down.
    It closes all connections with the transport and all addresses.  Then
    It reopens them at the new ip address.

Note for NETBIOSLESS:
    I have modeled a disabled adapter after an adapter with no address.  I considered
    not creating the device, but then, without the device, there is no handle
    for setup to contact the driver in order to enable it again.

Arguments:

Return Value:

    none

--*/

{
    NTSTATUS            status;
    BOOLEAN             Attached;
    ULONG               Count, i;

    CTEPagedCode();

    CHECK_PTR(pDeviceContext);
#ifdef _NETBIOSLESS
    if ( (!pDeviceContext->NetbiosEnabled) && (IpAddress != 0) )
    {
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("NbtNewDhcpAddr: %wZ disabling address\n",&pDeviceContext->ExportName));
        IpAddress = 0;
        SubnetMask = 0;
    }
#endif

    // grab the resource that synchronizes opening addresses and connections.
    // to prevent the client from doing anything for a while
    //
    IF_DBG(NBT_DEBUG_PNP_POWER)
    {
        KdPrint(("Nbt.NbtNewDhcpAddress: %d.%d.%d.%d\n",
                                        (IpAddress)     & 0xFF,
                                        (IpAddress>>8)  & 0xFF,
                                        (IpAddress>>16) & 0xFF,
                                        (IpAddress>>24) & 0xFF));
    }

    if (IpAddress == 0)
    {
        if (pDeviceContext->IpAddress)
        {
            NbtTrace(NBT_TRACE_PNP, ("%!FUNC! remove %!ipaddr! from device %p %Z",
                                    pDeviceContext->IpAddress, pDeviceContext, &pDeviceContext->BindName));
#ifdef VXD
            //
            // The permanent name is a function of the MAC address so remove
            // it since the Adapter is losing its Ip address
            //
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
            NbtRemovePermanentName(pDeviceContext);
#else
            CloseAddressesWithTransport(pDeviceContext);
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
#endif  // VXD

            //
            // Dhcp is has passed down a null IP address meaning that it has
            // lost the lease on the previous address, so close all connections
            // to the transport - pLowerConn.
            //
            DisableInboundConnections (pDeviceContext);

#ifndef VXD
            CTEExReleaseResource(&NbtConfig.Resource);
            NbtCheckSetNameAdapterInfo (pDeviceContext, IpAddress);

            if (pDeviceContext->DeviceType == NBT_DEVICE_REGULAR)
            {

                NbtUpBootCounter();

#ifdef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
                NbtNotifyTdiClients (pDeviceContext, NBT_TDI_DEREGISTER);
#else
                NbtQueueTdiNotification (pDeviceContext, NBT_TDI_DEREGISTER);
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

                NbtDownBootCounter();

            }
#endif
            //
            // Resync the cache since we may need to reset the outgoing interface info
            //
            StartTimer (NbtAddressChangeResyncCacheTimeout, ADDRESS_CHANGE_RESYNC_CACHE_TIMEOUT,
                        NULL, NULL, NULL, NULL, NULL, NULL, 0, FALSE);
        }

        status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT((signed)(pDeviceContext->TotalLowerConnections) >= 0);

        NbtTrace(NBT_TRACE_PNP, ("%!FUNC! new %!ipaddr! for device %p %Z",
                                    IpAddress, pDeviceContext, &pDeviceContext->BindName));
        CloseAddressesWithTransport(pDeviceContext);
        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

        // these are passed into here in the reverse byte order
        //
        IpAddress = htonl(IpAddress);
        SubnetMask = htonl(SubnetMask);
        //
        // must be a new IP address, so open up the connections.
        //
        // get the ip address and open the required address
        // objects with the underlying transport provider

        CTEAttachFsp(&Attached, REF_FSP_NEWADDR);
        Count = CountUpperConnections(pDeviceContext);
        Count += NbtConfig.MinFreeLowerConnections;

        for (i=0; i<2; i++)     // Retry once!
        {
            status = NbtCreateAddressObjects (IpAddress, SubnetMask, pDeviceContext);
            if (NT_SUCCESS(status))
            {
                // Allocate and set up connections with the transport provider.
                while ((NT_SUCCESS(status)) && (Count--))
                {
                    status = NbtOpenAndAssocConnection(pDeviceContext, NULL, NULL, '4');
                }

                if (!NT_SUCCESS(status))
                {
                    NbtLogEvent (EVENT_NBT_CREATE_CONNECTION, status, Count);
                    KdPrint(("Nbt.NbtNewDhcpAddress: NbtOpenAndAssocConnection Failed <%x>\n",status));
                }

                break;
            }

            //
            // Log an event only if it is a retry
            //
            if (i > 0)
            {
                NbtLogEvent (EVENT_NBT_CREATE_ADDRESS, status, i);
            }
            KdPrint(("Nbt.NbtNewDhcpAddress[i]: NbtCreateAddressObjects Failed, status=<%x>\n",i,status));
            KdPrint(("Nbt.NbtNewDhcpAddress: IpAddress: %x, SubnetMask: %x, pDeviceContext: %x\n",
                IpAddress, SubnetMask, pDeviceContext));
        }

        CTEDetachFsp(Attached, REF_FSP_NEWADDR);

        CTEExReleaseResource(&NbtConfig.Resource);

#ifdef VXD
        //
        // Add the "permanent" name to the local name table.  This is the IP
        // address of the node padded out to 16 bytes with zeros.
        //
        NbtAddPermanentName(pDeviceContext);
#else
        NbtCheckSetNameAdapterInfo (pDeviceContext, IpAddress);
        if (pDeviceContext->DeviceType == NBT_DEVICE_REGULAR)
        {
            //
            // Register this Device for our clients
            //
            NbtUpBootCounter();

#ifdef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
            NbtNotifyTdiClients (pDeviceContext, NBT_TDI_REGISTER);
#else
            NbtQueueTdiNotification (pDeviceContext, NBT_TDI_REGISTER);
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

            NbtDownBootCounter();
        }

        //
        // Resync the cache since we may need to reset the outgoing interface info
        //
        StartTimer (NbtAddressChangeResyncCacheTimeout, ADDRESS_CHANGE_RESYNC_CACHE_TIMEOUT,
                    NULL, NULL, NULL, NULL, NULL, NULL, 0, FALSE);
#endif  // VXD
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDeleteLowerConn(
    IN tLOWERCONNECTION   *pLowerConn
    )
/*++
Routine Description:

    This Routine attempts to delete a lower connection by closing it with the
    transport and dereferencing it.

Arguments:

Return Value:

     NONE

--*/

{
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    tDEVICECONTEXT  *pDeviceContext;

    status = STATUS_SUCCESS;

    if ((pLowerConn->Verify != NBT_VERIFY_LOWERCONN) ||
        (pLowerConn->RefCount > 500))
    {
        ASSERT (0);
        return status;
    }

    // remove the lower connection from the active queue and then delete it
    //
    pDeviceContext = pLowerConn->pDeviceContext;
    CTESpinLock(pDeviceContext,OldIrq);

    //
    // The lower conn can get removed from the inactive list in OutOfRsrcKill (when we queue it on
    // the OutofRsrc.ConnectionHead). Check the flag that indicates this connection was dequed then.
    //
    if (!pLowerConn->OutOfRsrcFlag)
    {
        RemoveEntryList(&pLowerConn->Linkage);
    }

    pLowerConn->Linkage.Flink = pLowerConn->Linkage.Blink = (PLIST_ENTRY)0x00009789;

    CTESpinFree(pDeviceContext,OldIrq);

    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, FALSE);

    return(status);

}

//----------------------------------------------------------------------------
VOID
DelayedWipeOutLowerconn(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *Unused3
    )
/*++
Routine Description:

    This routine does all the file close etc. that we couldn't do at dpc level
    and then frees the memory.

Arguments:

    pLowerConn - the lower connection to be wiped out

Return Value:

     NONE

--*/

{
    tLOWERCONNECTION    *pLowerConn = (tLOWERCONNECTION*) pClientContext;

    ASSERT(pLowerConn->Verify == NBT_VERIFY_LOWERCONN); // Verify LowerConn structure

    // dereference the fileobject ptr
    NTDereferenceObject((PVOID *)pLowerConn->pFileObject);

    // close the lower connection with the transport
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.DelayedWipeOutLowerconn: Closing Handle %X -> %X\n",pLowerConn,pLowerConn->FileHandle));

    NbtTdiCloseConnection(pLowerConn);

    // Close the Address object too since outbound connections use unique
    // addresses for each connection, whereas inbound connections all use
    // the same address  ( and we don't want to close that address ever ).
    if (pLowerConn->pAddrFileObject)
    {
        // dereference the fileobject ptr
        NTDereferenceObject((PVOID *)pLowerConn->pAddrFileObject);
        NbtTdiCloseAddress(pLowerConn);
    }

#ifndef VXD
    // free the indicate buffer and the mdl that holds it
    //
    CTEMemFree(MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl));
    IoFreeMdl(pLowerConn->pIndicateMdl);
#endif

    pLowerConn->Verify += 10;
    // now free the memory block tracking this connection
    CTEMemFree((PVOID)pLowerConn);
}

//----------------------------------------------------------------------------
VOID
NbtDereferenceClient(
    IN  tCLIENTELE    *pClientEle
    )
/*++

Routine Description

    This routine deletes a client element record (which points to a name
    in the local hash table.  If this is the last client element hooked to that
    name then the name is deleted too - causing a name release to be sent out.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    tADDRESSELE         *pAddress;
    PIRP                pIrp;
    NTSTATUS            status;
    tNAMEADDR           *pNameAddr;
    tTIMERQENTRY        *pTimer;
    tDGRAM_SEND_TRACKING *pTracker;
    COMPLETIONCLIENT    pClientCompletion = NULL;
    PVOID               Context;
    LIST_ENTRY          *pClientEntry;
    tDEVICECONTEXT      *pDeviceContext;
    tCLIENTELE          *pClientEleTemp;
    BOOLEAN             fLastClientOnDevice = TRUE;

    // lock the JointLock
    // so we can delete the client knowing that no one has a spin lock
    // pending on the client - basically use the Joint spin lock to
    // coordinate access to the AddressHead - NbtConnectionList also locks
    // the JointLock to scan the AddressHead list
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    ASSERT(pClientEle->RefCount);
    ASSERT ((pClientEle->Verify==NBT_VERIFY_CLIENT) || (pClientEle->Verify==NBT_VERIFY_CLIENT_DOWN)); 

    if (--pClientEle->RefCount)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        // return pending because we haven't been able to close the client
        // completely yet
        //
        return;
    }

    //
    // Unlink the Client in this routine after the reference count has
    // gone to zero since the DgramRcv code may need to find the client in
    // the Address client list when it is distributing a single received
    // dgram to several clients.
    //
    pIrp            = pClientEle->pIrp;
    pDeviceContext  = pClientEle->pDeviceContext;
    pAddress        = pClientEle->pAddress;
    pNameAddr       = pAddress->pNameAddr;

    CTESpinLock(pAddress,OldIrq1); // Need to acquire AddressEle lock -- Bug#: 231853
    RemoveEntryList(&pClientEle->Linkage);

    //
    // If there is no other client registered on this device, then
    // clear the adapter mask, and mark the release mask
    //
    pClientEntry = &pAddress->ClientHead;
    while ((pClientEntry = pClientEntry->Flink) != &pAddress->ClientHead)
    {
        pClientEleTemp = CONTAINING_RECORD (pClientEntry,tCLIENTELE,Linkage);
        if (pClientEleTemp->pDeviceContext == pDeviceContext)
        {
            fLastClientOnDevice = FALSE;
            break;
        }
    }
    CTESpinFree(pAddress,OldIrq1);

    if (pNameAddr)
    {
        //
        // If there is any timer running on this Client's device,
        // stop it now!
        //
        if ((pTimer = pNameAddr->pTimer) &&
            (pTracker = pTimer->Context) &&
            (pTracker->pDeviceContext == pDeviceContext))
        {
            pNameAddr->pTimer = NULL;
            StopTimer(pTimer,&pClientCompletion,&Context);
        }

        if (fLastClientOnDevice)
        {
            if (IsDeviceNetbiosless(pDeviceContext))
            {
                pNameAddr->NameFlags &= ~NAME_REGISTERED_ON_SMBDEV;
            }
            else
            {
                pNameAddr->AdapterMask &= ~pDeviceContext->AdapterMask;
                pNameAddr->ConflictMask &= ~pDeviceContext->AdapterMask;    // in case there was a conflict
                pNameAddr->ReleaseMask |= pDeviceContext->AdapterMask;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

#ifdef _PNP_POWER_
        //
        // Remove this name from the Adapter's Wakeup Pattern list (if set)
        //
        if ((pNameAddr->Name[0] != '*') &&
            (pNameAddr->Name[NETBIOS_NAME_SIZE-1] == SPECIAL_SERVER_SUFFIX))
        {
            pDeviceContext->NumServers--;
            CheckSetWakeupPattern (pDeviceContext, pNameAddr->Name, FALSE);
        }
#endif  // _PNP_POWER_
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    if (pClientCompletion)
    {
        (*pClientCompletion)(Context, STATUS_TIMEOUT);
    }
    //
    // The Connection Q Should be Empty otherwise we shouldn't get to this routine
    //
    ASSERT(IsListEmpty(&pClientEle->ConnectActive));
    ASSERT(IsListEmpty(&pClientEle->ConnectHead));
    ASSERT(IsListEmpty(&pClientEle->ListenHead));
    ASSERT(IsListEmpty(&pClientEle->SndDgrams));    // the Datagram Q should also be empty

    // check if there are more clients attached to the address, or can we
    // delete the address too.
    //
    NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_NEW_CLIENT);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceClient: Delete Client Object %X\n",pClientEle));
    //
    // if their is a client irp, complete now.  When the permanent name is
    // released there is no client irp.
    //
    // CHANGED:
    // Do not hold up the client's irp until the name has released on the
    // net.  It is simpler to just complete it now
    //
    if (pIrp)
    {
        // complete the client's close address irp
        CTEIoComplete(pIrp,STATUS_SUCCESS,0);
    }

    //
    // free the memory associated with the client element
    //
    pClientEle->Verify += 10;
    CTEMemFree((PVOID)pClientEle);

    return;
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDereferenceAddress(
    IN  tADDRESSELE *pAddress,
    IN  ULONG       Context
    )
/*++

Routine Description

    This routine deletes an Address element record (which points to a name
    in the local hash table).  A name release is sent on the wire for this name.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    COMPLETIONCLIENT        pClientCompletion = NULL;
    PVOID                   pTimerContext;
    ULONG                   SaveState;
    tDEVICECONTEXT          *pDeviceContext;
    tTIMERQENTRY            *pTimer;

    // lock the hash table so another client cannot add a reference to this
    // name before we delete it.  We need the JointLock to keep the name
    // refresh mechanism from finding the name in the list just as
    // we are about to remove it (i.e. to synchronize with the name refresh
    // code).
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pAddress,OldIrq);

    ASSERT(pAddress->RefCount);
    ASSERT (NBT_VERIFY_HANDLE (pAddress, NBT_VERIFY_ADDRESS));
    if (pAddress->pNameAddr)
    {
        ASSERT (NBT_VERIFY_HANDLE (pAddress->pNameAddr, LOCAL_NAME));
    }

    if (--pAddress->RefCount)
    {
        CTESpinFree(pAddress,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return(STATUS_SUCCESS);
    }

    //
    // remove the address object from the list of addresses tied to the
    // device context for the adapter
    //
    RemoveEntryList(&pAddress->Linkage);
    ASSERT(IsListEmpty(&pAddress->ClientHead));     // The ClientHead should be empty

    CTESpinFree(pAddress,OldIrq);

    if (pAddress->pNameAddr)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtDereferenceAddress: Freeing address object for <%-16.16s:%x>\n",
                pAddress->pNameAddr->Name,pAddress->pNameAddr->Name[NETBIOS_NAME_SIZE-1] ));

        pAddress->pNameAddr->pAddressEle = NULL;

        //
        // Release name on the network
        // change the name state in the hash table since it is being released
        //
        SaveState = pAddress->pNameAddr->NameTypeState;
        pAddress->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pAddress->pNameAddr->NameTypeState |= STATE_CONFLICT;
        pAddress->pNameAddr->ReleaseMask |= pAddress->pNameAddr->AdapterMask;
        pAddress->pNameAddr->AdapterMask = 0;

        //
        // check for any timers outstanding against the hash table entry - there shouldn't
        // be any timers though
        //
        if (pTimer = pAddress->pNameAddr->pTimer)
        {
            pAddress->pNameAddr->pTimer = NULL;
            status = StopTimer(pTimer, &pClientCompletion, &pTimerContext);

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDereferenceAddress: StopTimer returned Context <%x>\n", pTimerContext));

            if (pClientCompletion)
            {
                ASSERT (pClientCompletion != NameReleaseDone);

                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                (*pClientCompletion) (pTimerContext, STATUS_TIMEOUT);
                CTESpinLock(&NbtConfig.JointLock,OldIrq1);
            }
        }

        // only release the name on the net if it was not in conflict first
        // This prevents name releases going out for names that were not actually
        // claimed. Also, quick add names are not released on the net either.
        //
        if (!(SaveState & (STATE_CONFLICT | NAMETYPE_QUICK)) &&
            (pAddress->pNameAddr->Name[0] != '*') &&
            (pDeviceContext = GetAndRefNextDeviceFromNameAddr (pAddress->pNameAddr)))
        {
            //
            // The pNameAddr has to stay around until the NameRelease has completed
            //
            NBT_REFERENCE_NAMEADDR (pAddress->pNameAddr, REF_NAME_RELEASE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            status = ReleaseNameOnNet (pAddress->pNameAddr,
                                       NbtConfig.pScope,
                                       NameReleaseDone,
                                       NodeType,
                                       pDeviceContext);

            CTESpinLock(&NbtConfig.JointLock,OldIrq1);

#ifndef VXD
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_GET_REF, TRUE);
#endif  // !VXD

            if (!NT_SUCCESS(status))
            {
                NBT_DEREFERENCE_NAMEADDR (pAddress->pNameAddr, REF_NAME_RELEASE, TRUE);
            }
        }

        NBT_DEREFERENCE_NAMEADDR (pAddress->pNameAddr, REF_NAME_LOCAL, TRUE);
    }

    //
    // Now, cleanup the Address info (we are still holding the JointLock)
    //

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    // free the memory associated with the address element
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("NBt: Deleteing Address Obj after name release on net %X\n",pAddress));
    NbtFreeAddressObj(pAddress);

    //
    // the name has been deleted, so return success
    //
    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
NbtDereferenceName(
    IN  tNAMEADDR   *pNameAddr,
    IN  ULONG       RefContext,
    IN  BOOLEAN     fLocked
    )
/*++

Routine Description

    This routine dereferences and possibly deletes a name element record by first unlinking from the
    list it is in, and then freeing the memory if it is a local name.  Remote
    names remain in a circular list for reuse.
    The JOINTLOCK may have been taken before calling this routine.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/

{
    CTELockHandle   OldIrq;
    ULONG           i;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    ASSERT (NBT_VERIFY_HANDLE2 (pNameAddr, LOCAL_NAME, REMOTE_NAME));
    ASSERT (pNameAddr->RefCount);
    ASSERT (pNameAddr->References[RefContext]--);

    if (--pNameAddr->RefCount)
    {
        if (!fLocked)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        return;
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceName[%s]: Freeing Name=<%16.16s:%x> %x\n",
            (pNameAddr->Verify == REMOTE_NAME ? "Remote" : "Local"),
            pNameAddr->Name, pNameAddr->Name[15], pNameAddr));

    //
    // remove from the hash table, could be set to NULL by DestroyHashTable
    //
    if (pNameAddr->Linkage.Flink && pNameAddr->Linkage.Blink) {
        RemoveEntryList(&pNameAddr->Linkage);
    } else {
        // Both should be NULL
        ASSERT(pNameAddr->Linkage.Flink == pNameAddr->Linkage.Blink);
    }

    if (pNameAddr->Verify == LOCAL_NAME)
    {
        ASSERT(!pNameAddr->pTimer);
        ASSERT(NULL == pNameAddr->FQDN.Buffer);
        ASSERT(0 == pNameAddr->FQDN.Length);
    }
    //
    // if it is an internet group name it has a list of ip addresses and that
    // memory block must be deleted
    //
    else if (pNameAddr->Verify == REMOTE_NAME)
    {
        if (pNameAddr->NameAddFlags == (NAME_RESOLVED_BY_LMH_P | NAME_ADD_INET_GROUP))
        {
            if (pNameAddr->pLmhSvcGroupList)
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtDereferenceName: Freeing Pre-loaded Internet Group Name Memory = <%p>\n",
                        pNameAddr->pLmhSvcGroupList));
                CTEMemFree((PVOID)pNameAddr->pLmhSvcGroupList);
            }
        }
        if (pNameAddr->pRemoteIpAddrs)
        {
            for (i=0; i<pNameAddr->RemoteCacheLen; i++)
            {
                if (pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs)
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt.NbtDereferenceName: Freeing Internet Group Name Memory = <%p>\n",
                            pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs));
                    CTEMemFree((PVOID)pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs);
                }
            }
            CTEMemFree ((PVOID)pNameAddr->pRemoteIpAddrs);
        }
    }

    if (pNameAddr->pIpAddrsList)
    {
        CTEMemFree((PVOID)pNameAddr->pIpAddrsList);
    }
    if (NULL != pNameAddr->FQDN.Buffer) {
        CTEMemFree((PVOID)pNameAddr->FQDN.Buffer);
        pNameAddr->FQDN.Buffer = NULL;
        pNameAddr->FQDN.Length = 0;
        pNameAddr->FQDN.MaximumLength = 0;
    }

    //
    // free the memory now
    //
// #if   DBG
    pNameAddr->Verify += 10;
// #endif    // DBG
    CTEMemFree((PVOID)pNameAddr);

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

//----------------------------------------------------------------------------
VOID
NbtDereferenceConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  ULONG           RefContext
    )
/*++

Routine Description

    This routine dereferences and possibly deletes a connection element record.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    PCTE_IRP            pIrp;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    tDEVICECONTEXT      *pDeviceContext;
    tLOWERCONNECTION    *pLowerConn;
    PLIST_ENTRY         pEntry;

    CHECK_PTR(pConnEle);

    // grab the lock of the item that contains the one we are trying to
    // dereference and possibly delete.  This prevents anyone from incrementing
    // the count in between decrementing it and checking it for zero and deleting
    // it if it is zero.

    CTESpinLock(pConnEle,OldIrq);

    ASSERT (pConnEle->RefCount > 0) ;      // Check for too many derefs
    ASSERT ((pConnEle->Verify==NBT_VERIFY_CONNECTION) || (pConnEle->Verify==NBT_VERIFY_CONNECTION_DOWN));
    ASSERT (pConnEle->References[RefContext]--);

    if (--pConnEle->RefCount)
    {
        CTESpinFree(pConnEle,OldIrq);
        return;
    }

    ASSERT ((pConnEle->state <= NBT_CONNECTING) || (pConnEle->state > NBT_DISCONNECTING));
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceConnection: Delete Connection Object %X\n",pConnEle));

#ifndef VXD
    IoFreeMdl(pConnEle->pNewMdl);
    //
    // Clear the context value in the Fileobject so that if this connection
    // is used again (erroneously) it will not pass the VerifyHandle test
    //
    if (pIrp = pConnEle->pIrpClose)     // the close irp should be held in here
    {
        NTClearFileObjectContext(pConnEle->pIrpClose);
    }
#endif

    pDeviceContext = pConnEle->pDeviceContext;

    CTESpinFree(pConnEle,OldIrq);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);

    // For outbound connections the lower connection is deleted in hndlrs.c
    // For inbound connections, the lower connection is put back on the free
    // list in hndlrs.c and one from that list is deleted here.  Therefore
    // delete a lower connection in this list if the connection is inbound.
    //
    if ((pDeviceContext->NumFreeLowerConnections > NbtConfig.MinFreeLowerConnections) &&
        (pDeviceContext->NumFreeLowerConnections > (pDeviceContext->TotalLowerConnections/2)))
    {
        // get a lower connection from the free list and close it with the
        // transport.
        //
        pEntry = RemoveHeadList(&pConnEle->pDeviceContext->LowerConnFreeHead);
        pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

        // close the lower connection with the transport
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtDereferenceConnection: Closing LowerConn %X -> %X\n",
                pLowerConn,pLowerConn->FileHandle));
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
    }
    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    FreeConnectionObj(pConnEle);    // free the memory block associated with the conn element

    //
    // The client may have sent down a close before NBT was done with the
    // pConnEle, so Pending was returned and the irp stored in the pCOnnEle
    // structure.  Now that the structure is fully dereferenced, we can complete the irp.
    //
    if (pIrp)
    {
        CTEIoComplete(pIrp,STATUS_SUCCESS,0);
    }

    return;
}

//----------------------------------------------------------------------------
VOID
NbtDereferenceLowerConnection(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               RefContext,
    IN  BOOLEAN             fJointLockHeld
    )
/*++
Routine Description:

    This Routine decrements the reference count on a Lower Connection element and
    if the value is zero, deletes the connection.

Arguments:

Return Value:

     NONE

--*/

{
    CTELockHandle   OldIrq1;
    tCONNECTELE     *pConnEle;
    NTSTATUS        status;

    CTESpinLock(pLowerConn,OldIrq1);

    ASSERT (pLowerConn->Verify == NBT_VERIFY_LOWERCONN); // Verify LowerConn structure
    ASSERT (pLowerConn->References[RefContext]--);
    if(--pLowerConn->RefCount)
    {
        CTESpinFree(pLowerConn,OldIrq1);
        return;
    }
    InterlockedDecrement (&pLowerConn->pDeviceContext->TotalLowerConnections);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceLowerConnection: Delete Lower Connection Object %p\n",pLowerConn));

    //
    // it's possible that transport may indicate before we run the code
    // in DelayedWipeOutLowerconn.  If that happens, we don't want to run this
    // code again ( which will queue this to worker thread again!)
    // So, bump it up to some large value
    //
    pLowerConn->RefCount = 1000;

    if (NBT_VERIFY_HANDLE2((pConnEle = pLowerConn->pUpperConnection), NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        //
        // We still have a linked UpperConnection block, so unlink it,
        //
        SET_STATE_UPPER (pLowerConn->pUpperConnection, NBT_DISCONNECTED);
        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
    }

    CTESpinFree(pLowerConn,OldIrq1);

    //
    // let's come back and do this later since we may be at dpc now
    //
    CTEQueueForNonDispProcessing (DelayedWipeOutLowerconn,
                                  NULL,
                                  pLowerConn,
                                  NULL,
                                  NULL,
                                  fJointLockHeld);
}


//----------------------------------------------------------------------------
VOID
NbtDereferenceTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN BOOLEAN                  fLocked
    )
/*++

Routine Description:

    This routine cleans up a Tracker block and puts it back on the free
    queue.  The JointLock Spin lock should be held before calling this
    routine to coordinate access to the tracker ref count.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    CTELockHandle   OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    if (--pTracker->RefCount == 0)
    {
        // the datagram header may have already been freed
        //
        FreeTracker(pTracker, RELINK_TRACKER);
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

BOOL
IsLocalAddress(
    tIPADDRESS  IpAddress
    )
{
    tDEVICECONTEXT  *pDeviceContext = NULL;
    ULONG           IPInterfaceContext = 0xffff, Metric = 0;
    ULONG           LoopbackIPInterfaceContext = 0xffff;
    CTELockHandle   OldIrq = 0;
    PIPFASTQUERY    pFastQuery;

    if (0 == IpAddress) {
        return TRUE;
    }
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (IsListEmpty(&NbtConfig.DeviceContexts)) {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return FALSE;
    }

    pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink, tDEVICECONTEXT, Linkage);
    pFastQuery = pDeviceContext->pFastQuery;
    NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    /*
     * Hack!!!
     */
    if (NbtConfig.LoopbackIfContext == 0xffff) {
        (pFastQuery)(htonl(INADDR_LOOPBACK), &LoopbackIPInterfaceContext, &Metric);
        if (LoopbackIPInterfaceContext != 0xffff) {
            NbtConfig.LoopbackIfContext = LoopbackIPInterfaceContext;
        }
    }
    (pFastQuery)(htonl(IpAddress), &IPInterfaceContext, &Metric);

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);

    if (NbtConfig.LoopbackIfContext == 0xffff || IPInterfaceContext == 0xffff) {
        return FALSE;
    }
    return (IPInterfaceContext == NbtConfig.LoopbackIfContext);
}

BOOL
IsSmbBoundToOutgoingInterface(
    IN  tIPADDRESS      IpAddress
    )
/*++

Routine Description:

    This routine returns TRUE if the destionation can be reached through
    an interface to which the SmbDevice is bound. Otherwise it returns FALSE


Arguments:

    IpAddress   The address of destination

Return Value:

    TRUE/FALSE

--*/
{
    tDEVICECONTEXT  *pDeviceContext;
    BOOL            bBind;

    if (IpAddress == INADDR_LOOPBACK) {
        return TRUE;
    }

    /*
     * First check if this is a local address
     * return TRUE if it is a local address
     */
    if (IsLocalAddress(IpAddress)) {
        return TRUE;
    }

    /*
     * This is not a local IP. Check with TCP
     */
    pDeviceContext = GetDeviceFromInterface (htonl(IpAddress), TRUE);
    bBind = (pDeviceContext && (pDeviceContext->AdapterMask & NbtConfig.ClientMask));
    if (!bBind) {
        NbtTrace(NBT_TRACE_OUTBOUND,
                        ("SmbDevice is not bound. %!ipaddr! Device=%p %I64x %I64x",
                        IpAddress, pDeviceContext,
                        (pDeviceContext?pDeviceContext->AdapterMask:0),
                        NbtConfig.ClientMask
                        ));
    }
    if (pDeviceContext) {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
    }

    return bBind;
}

// ========================================================================
// End of file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\ctestuff.c ===
//
//
//  CTESTUFF.C
//
//  This file contains Common Transport Environment code to handle
//  OS dependent functions such as allocating memory etc.
//
//
#include "precomp.h"

// to convert a millisecond to a 100ns time
//
#define MILLISEC_TO_100NS   10000


//----------------------------------------------------------------------------
PVOID
CTEStartTimer(
    IN  CTETimer        *pTimerIn,
    IN  ULONG           DeltaTime,
    IN  CTEEventRtn     TimerExpiry,
    IN  PVOID           Context OPTIONAL
        )
/*++
Routine Description:

    This Routine starts a timer.

Arguments:

    Timer       - Timer structure
    TimerExpiry - completion routine

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

{
    LARGE_INTEGER   Time;

    //
    // initialize the DPC to have the correct completion routine and context
    //
    KeInitializeDpc(&pTimerIn->t_dpc,
                    (PVOID)TimerExpiry,     // completion routine
                    Context);               // context value

    //
    // convert to 100 ns units by multiplying by 10,000
    //
    Time.QuadPart = UInt32x32To64(DeltaTime,(LONG)MILLISEC_TO_100NS);

    //
    // to make a delta time, negate the time
    //
    Time.QuadPart = -(Time.QuadPart);

    ASSERT(Time.QuadPart < 0);

    (VOID)KeSetTimer(&pTimerIn->t_timer,Time,&pTimerIn->t_dpc);

    return(NULL);
}
//----------------------------------------------------------------------------
VOID
CTEInitTimer(
    IN  CTETimer        *pTimerIn
        )
/*++
Routine Description:

    This Routine initializes a timer.

Arguments:

    Timer       - Timer structure
    TimerExpiry - completion routine

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

{
    KeInitializeTimer(&pTimerIn->t_timer);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\autodial.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    autodial.c

Abstract:

    This file provides routines for interacting
    with the automatic connection driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  9-6-95

Revision History:

--*/
#include "precomp.h"   // procedure headings

#ifdef RASAUTODIAL

#ifndef VXD
#include <acd.h>
#include <acdapi.h>
#endif

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, NbtAcdBind)
#pragma CTEMakePageable(PAGE, NbtAcdUnbind)
#endif
//*******************  Pageable Routine Declarations ****************


//
// Automatic connection global variables.
//
BOOLEAN fAcdLoadedG;
ACD_DRIVER AcdDriverG;
ULONG ulDriverIdG = 'Nbt ';

//
// Imported routines.
//
VOID
CleanUpPartialConnection(
    IN NTSTATUS             status,
    IN tCONNECTELE          *pConnEle,
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN PIRP                 pClientIrp,
    IN CTELockHandle        irqlJointLock,
    IN CTELockHandle        irqlConnEle
    );

NTSTATUS
NbtConnectCommon(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    );

NTSTATUS
NbtpConnectCompletionRoutine(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           pCompletionContext
    );


VOID
NbtRetryPreConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    )

/*++

Routine Description:

    This routine is called indirectly by the automatic
    connection driver to continue the connection process
    after an automatic connection has been made.

Arguments:

    fSuccess - TRUE if the connection attempt was successful.

    pArgs - a pointer to the argument vector

Return Value:

    None.

--*/

{
    NTSTATUS                    status;
    tCONNECTELE                 *pConnEle = pArgs[0];
    PVOID                       pTimeout = pArgs[1];
    PTDI_CONNECTION_INFORMATION pCallInfo = pArgs[2];
    PIRP                        pIrp = pArgs[3];
    TDI_REQUEST                 request;
    KIRQL                       irql;
    CTELockHandle               OldIrq;
    tDEVICECONTEXT              *pDeviceContext = pConnEle->pDeviceContext;

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("Nbt.NbtRetryPreConnect: fSuccess=%d, pIrp=0x%x, pIrp->Cancel=%d, pConnEle=0x%x\n",
            fSuccess, pIrp, pIrp->Cancel, pConnEle));

    request.Handle.ConnectionContext = pConnEle;
    status = NbtCancelCancelRoutine (pIrp);
    if (status != STATUS_CANCELLED)
    {
        //
        // We're done with the connection progress,
        // so clear the fAutoConnecting flag.  We
        // set the fAutoConnected flag to prevent us
        // from re-attempting another automatic
        // connection on this connection.
        //
        CTESpinLock(pConnEle,OldIrq);
        pConnEle->fAutoConnecting = FALSE;
        pConnEle->fAutoConnected = TRUE;
        CTESpinFree(pConnEle,OldIrq);

        status = fSuccess ? NbtConnectCommon (&request, pTimeout, pCallInfo, pIrp) :
                            STATUS_BAD_NETWORK_PATH;
        //
        // We are responsible for completing
        // the irp.
        //
        if (status != STATUS_PENDING)
        {
            //
            // Clear out the Irp pointer in the Connection object so that we dont try to
            // complete it again when we clean up the connection. Do this under the connection
            // lock.
            //
            CTESpinLock(pConnEle,OldIrq);
            pConnEle->pIrp = NULL;
            CTESpinFree(pConnEle,OldIrq);

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_AUTODIAL, FALSE);
    }
} // NbtRetryPreConnect



BOOLEAN
NbtCancelAutoDialRequest(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )
{
    if (nArgs != 5)
        return FALSE;

    return (pArgs[4] == pArg);
} // NbtCancelAutoDialRequest



BOOLEAN
NbtCancelPreConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp;
    tCONNECTELE         *pConnEle;
    KIRQL               irql;
    ACD_ADDR            *pAddr;
    BOOLEAN             fCancelled;
    CTELockHandle       OldIrq;

    UNREFERENCED_PARAMETER(pDeviceObject);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *) pIrpSp->FileObject->FsContext;
    if ((!pConnEle) ||
        (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!(pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A')))))
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        ASSERTMSG ("Nbt.NbtCancelPreConnect: ERROR - Invalid Connection Handle\n", 0);
        return FALSE;
    }

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("NbtCancelPreConnect: pIrp=0x%x, pConnEle=0x%x\n", pIrp, pConnEle));
    //
    // Get the address of the connection.
    //
    pAddr->fType = ACD_ADDR_NB;
    RtlCopyMemory(&pAddr->cNetbios, pConnEle->RemoteName, 16);
    //
    // Cancel the autodial request.
    //
    fCancelled = (*AcdDriverG.lpfnCancelConnection) (ulDriverIdG, pAddr, NbtCancelAutoDialRequest, pIrp);
    if (fCancelled)
    {
        IoSetCancelRoutine(pIrp, NULL);
    }
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTEMemFree(pAddr);

    //
    // If the request could not be found
    // in the driver, then it has already
    // been completed, so we simply return.
    //
    if (!fCancelled)
    {
        return FALSE;
    }

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    NBT_DEREFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE);

    //
    // Clear out the Irp pointer in the Connection object so that we dont try to
    // complete it again when we clean up the connection. Do this under the connection
    // lock.
    //
    // This should not be needed since before we call NbtConnectCommon, the Cancel routine
    // is NULLed out, so it cannot happen that the pIrp ptr in the connection is set to the
    // Irp, and this cancel routine is called.
    //

    CTESpinLock(pConnEle,OldIrq);
    pConnEle->pIrp = NULL;
    CTESpinFree(pConnEle,OldIrq);

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    KeLowerIrql(irql);

    return TRUE;
} // NbtCancelPreConnect


BOOLEAN
NbtCancelPostConnect(
    IN PIRP pIrp
    )
{
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    tCONNECTELE         *pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
    ACD_ADDR            *pAddr;
    BOOLEAN             fCancelled;

    if ((!pConnEle) ||
        (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!(pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A')))))
    {
        ASSERTMSG ("Nbt.NbtCancelPostConnect: ERROR - Invalid Connection Handle\n", 0);
        return FALSE;
    }

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("Nbt.NbtCancelPostConnect: pIrp=0x%x, pConnEle=0x%x\n", pIrp, pConnEle));
    //
    // Get the address of the connection.
    //
    pAddr->fType = ACD_ADDR_NB;
    RtlCopyMemory(&pAddr->cNetbios, pConnEle->RemoteName, 15);

    //
    // Cancel the autodial request.
    //
    fCancelled = (*AcdDriverG.lpfnCancelConnection) (ulDriverIdG, pAddr, NbtCancelAutoDialRequest, pIrp);
    if (fCancelled)
    {
        NBT_DEREFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE);
    }

    CTEMemFree(pAddr);
    return (fCancelled);
} // NbtCancelPostConnect



BOOLEAN
NbtAttemptAutoDial(
    IN  tCONNECTELE                 *pConnEle,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp,
    IN  ULONG                       ulFlags,
    IN  ACD_CONNECT_CALLBACK        pProc
    )

/*++

Routine Description:

    Call the automatic connection driver to attempt an
    automatic connection.  The first five parameters are
    used in the call to NbtConnect after the connection
    completes successfully.

Arguments:

    ...

    ulFlags - automatic connection flags

    pProc - callback procedure when the automatic connection completes

Return Value:

    TRUE if the automatic connection was started successfully,
    FALSE otherwise.

--*/

{
    NTSTATUS    status;
    BOOLEAN     fSuccess;
    ACD_ADDR    *pAddr = NULL;
    KIRQL       irql;
    PVOID       pArgs[4];
    PCHAR       pName;
    ULONG       ulcbName;
    LONG        lNameType;
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
    PIO_STACK_LOCATION pIrpSp;

    ASSERT(pCallInfo);

    //
    // If this connection has already been through the
    // automatic connection process, don't do it again.
    //
    if ((pConnEle->fAutoConnected)) {
        return FALSE;
    }

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    if (pIrpSp->CompletionRoutine != NbtpConnectCompletionRoutine) {
        status = GetNetBiosNameFromTransportAddress((PTRANSPORT_ADDRESS) pCallInfo->RemoteAddress,
                                                          pCallInfo->RemoteAddressLength, &TdiAddr);
    } else {
        ASSERT(((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
        CTEMemCopy(&TdiAddr,
                (PTDI_ADDRESS_NETBT_INTERNAL)((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].Address,
                sizeof(TdiAddr));
        status = STATUS_SUCCESS;
    }
    if (status != STATUS_SUCCESS || (!NBT_REFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE)) ||
        (!(pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A'))))) {
        if (pAddr) {
            CTEMemFree(pAddr);
        }

        return FALSE;
    }

    pName = TdiAddr.OEMRemoteName.Buffer;
    ulcbName = TdiAddr.OEMRemoteName.Length;
    lNameType = TdiAddr.NameType;

    //
    // Save the address for pre-connect attempts,
    // because if we have to cancel this irp,
    // it is not saved anywhere else.
    //
    CTESpinLock(pConnEle, irql);
    pConnEle->fAutoConnecting = TRUE;
    CTEMemCopy(pConnEle->RemoteName, pName, NETBIOS_NAME_SIZE);
    CTESpinFree(pConnEle, irql);
    pAddr->fType = ACD_ADDR_NB;
    RtlCopyMemory(&pAddr->cNetbios, pName, NETBIOS_NAME_SIZE);

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("Nbt.NbtAttemptAutodial: szAddr=%-15.15s\n", pName));
    //
    // Enqueue this request on the network
    // connection pending queue.
    //
    pArgs[0] = pConnEle;
    pArgs[1] = pTimeout;
    pArgs[2] = pCallInfo;
    pArgs[3] = pIrp;
    fSuccess = (*AcdDriverG.lpfnStartConnection) (ulDriverIdG, pAddr, ulFlags, pProc, 4, pArgs);

    //
    // If fSuccess is TRUE, then it means that the NetBT proc has
    // already been called to setup the connection, and hence the
    // data in pConnEle may not be valid now
    //
    // In the case it is FALSE, then pProc has not been called, and
    // we should set the fAutoConnecting flag to FALSE also
    //
    if (!fSuccess)
    {
        NBT_DEREFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE);
        CTESpinLock(pConnEle, irql);
        pConnEle->fAutoConnecting = FALSE;
        CTESpinFree(pConnEle, irql);
    }

    CTEMemFree(pAddr);
    return fSuccess;
} // NbtAttemptAutoDial



VOID
NbtNoteNewConnection(
    IN tNAMEADDR    *pNameAddr,
    IN  ULONG       IpAddress
    )

/*++

Routine Description:

    Inform the automatic connection driver of a
    successful new connection.

Arguments:

    pNameAddr - a pointer to the remote name
    IpAddress - Source IP address of the connection

Return Value:
    None.

--*/

{
    ACD_ADDR        *pAddr = NULL;
    ACD_ADAPTER     *pAdapter = NULL;

    //
    // Notify the AcdDriver only if we have a valid Source address
    //
    // We can end up blowing the stack if we pre-allocate ACD_ADDR
    // and ACD_ADAPTER on the stack -- so allocate them dynamically!
    //
    if ((IpAddress) &&
        (pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A'))) &&
        (pAdapter = (ACD_ADAPTER *) NbtAllocMem(sizeof(ACD_ADAPTER),NBT_TAG('A'))))
    {
        pAddr->fType = ACD_ADDR_NB;
        RtlCopyMemory(&pAddr->cNetbios, pNameAddr->Name, 15);

        pAdapter->fType = ACD_ADAPTER_IP;
        pAdapter->ulIpaddr = htonl(IpAddress);  // Get the source IP address of the connection.

        (*AcdDriverG.lpfnNewConnection) (pAddr, pAdapter);
    }

    if (pAddr)
    {
        CTEMemFree(pAddr);
    }

    if (pAdapter)
    {
        CTEMemFree(pAdapter);
    }
} // NbtNoteNewConnection



VOID
NbtAcdBind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Initialize our part of the ACD_DRIVER
    // structure.
    //
    KeInitializeSpinLock(&AcdDriverG.SpinLock);
    AcdDriverG.ulDriverId = ulDriverIdG;
    AcdDriverG.fEnabled = FALSE;
    //
    // Build a request to get the automatic
    // connection driver entry points.
    //
    pIrp = IoBuildDeviceIoControlRequest (IOCTL_INTERNAL_ACD_BIND,
                                          pAcdDeviceObject,
                                          (PVOID)&pDriver,
                                          sizeof (pDriver),
                                          NULL,
                                          0,
                                          TRUE,
                                          NULL,
                                          &ioStatusBlock);
    if (pIrp == NULL)
    {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    fAcdLoadedG = (status == STATUS_SUCCESS);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbtAcdBind



VOID
NbtAcdUnbind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Don't bother to unbind if we
    // didn't successfully bind in the
    // first place.
    //
    if (!fAcdLoadedG)
    {
        return;
    }

    fAcdLoadedG = FALSE;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer (&nameString,
                                       SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
                                       &pAcdFileObject,
                                       &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        return;
    }

    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Build a request to unbind from
    // the automatic connection driver.
    //
    pIrp = IoBuildDeviceIoControlRequest (IOCTL_INTERNAL_ACD_UNBIND,
                                          pAcdDeviceObject,
                                          (PVOID)&pDriver,
                                          sizeof (pDriver),
                                          NULL,
                                          0,
                                          TRUE,
                                          NULL,
                                          &ioStatusBlock);
    if (pIrp == NULL)
    {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }

    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbtAcdUnbind

#endif // RASAUTODIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\driver.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Driver.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    NBT Transport and other routines that are specific to the NT implementation
    of a driver.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/


#include "precomp.h"
#include <nbtioctl.h>

#include "driver.tmh"

#if DBG
// allocate storage for the global debug flag NbtDebug
//ULONG   NbtDebug = NBT_DEBUG_KDPRINTS| NBT_DEBUG_NETBIOS_EX;
ULONG   NbtDebug = 0;
#endif // DBG

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
NbtDispatchCleanup(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchClose(
    IN PDEVICE_OBJECT   device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchCreate(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchDevCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchInternalCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             pIrp
    );

#ifdef _PNP_POWER_
VOID
NbtUnload(
    IN PDRIVER_OBJECT   device
    );
#endif  // _PNP_POWER_

NTSTATUS
NbtDispatchPnP(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

PFILE_FULL_EA_INFORMATION
FindInEA(
    IN PFILE_FULL_EA_INFORMATION    start,
    IN PCHAR                        wanted
    );

VOID
ReturnIrp(
    IN PIRP     pIrp,
    IN int      status
    );

VOID
MakePending(
    IN PIRP     pIrp
    );

NTSTATUS
NbtCreateAdminSecurityDescriptor(
    IN PDEVICE_OBJECT dev
    );

#ifdef _PNP_POWER_DBG_
//
//Debug Stuff for DbgBreakPoint -- REMOVE
//
NTSTATUS
NbtOpenRegistry(
    IN HANDLE       NbConfigHandle,
    IN PWSTR        String,
    OUT PHANDLE     pHandle
    );
#endif  // _PNP_POWER_DBG_

#ifdef _PNP_POWER_
HANDLE      TdiClientHandle     = NULL;
HANDLE      TdiProviderHandle   = NULL;
extern      tTIMERQ TimerQ;
#endif  // _PNP_POWER_

#ifdef _NETBIOSLESS
tDEVICECONTEXT       *pNbtSmbDevice = NULL;
#endif  // _NETBIOSLESS

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, DriverEntry)
#pragma CTEMakePageable(PAGE, NbtDispatchCleanup)
#pragma CTEMakePageable(PAGE, NbtDispatchClose)
#pragma CTEMakePageable(PAGE, NbtDispatchCreate)
#pragma CTEMakePageable(PAGE, NbtDispatchDevCtrl)
#pragma CTEMakePageable(PAGE, FindInEA)
#pragma CTEMakePageable(PAGE, NbtUnload)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
VOID
CleanupDriverEntry(
    ULONG   CleanupStage
    )
{
    PSINGLE_LIST_ENTRY      pSingleListEntry;
    PMDL                    pMdl;
    PVOID                   pBuffer;
    LIST_ENTRY              *pListEntry;
    tDGRAM_SEND_TRACKING    *pTracker;

    switch (CleanupStage)
    {
        case (6):
            NbtDestroyDevice (pWinsDeviceContext, FALSE);

#ifdef RASAUTODIAL
            //
            // Unbind fron the RAS driver if we were bound
            //
            NbtAcdUnbind ();
#endif  // RASAUTODIAL

            // Fall through

        case (5):
            if (pNbtSmbDevice)
            {
                NbtDestroyDevice (pNbtSmbDevice, FALSE);
                pNbtSmbDevice = NULL;
            }

            if (NbtConfig.OutOfRsrc.pDpc)
            {
                CTEMemFree (NbtConfig.OutOfRsrc.pDpc);
            }
            if (NbtConfig.OutOfRsrc.pIrp)
            {
                IoFreeIrp (NbtConfig.OutOfRsrc.pIrp);
            }

            // Fall through

        case (4):
            while (NbtConfig.SessionMdlFreeSingleList.Next)
            {
                pSingleListEntry = PopEntryList(&NbtConfig.SessionMdlFreeSingleList);
                pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                pBuffer = MmGetMdlVirtualAddress (pMdl);
                CTEMemFree (pBuffer);
                IoFreeMdl (pMdl);
            }

            while (NbtConfig.DgramMdlFreeSingleList.Next)
            {
                pSingleListEntry = PopEntryList(&NbtConfig.DgramMdlFreeSingleList);
                pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                pBuffer = MmGetMdlVirtualAddress (pMdl);
                CTEMemFree (pBuffer);
                IoFreeMdl (pMdl);
            }

            // Fall through

        case (3):
            //
            // InitNotOs has been called
            //

            DestroyTimerQ();

            while (!IsListEmpty(&NbtConfig.DgramTrackerFreeQ))
            {
                pListEntry = RemoveHeadList(&NbtConfig.DgramTrackerFreeQ);
                pTracker = CONTAINING_RECORD(pListEntry,tDGRAM_SEND_TRACKING,Linkage);
                CTEMemFree (pTracker);
            }

            DestroyHashTables ();
            ExDeleteResourceLite (&NbtConfig.Resource);  // Delete the resource

            // Fall through

        case (2):
            //
            // Read registry has been called!
            //
            CTEMemFree (NbtConfig.pLmHosts);
            CTEMemFree (NbtConfig.pScope);
            if (NbtConfig.pTcpBindName)
            {
                CTEMemFree (NbtConfig.pTcpBindName);
            }

            // Fall through

        case (1):
            CTEMemFree (NbtConfig.pRegistry.Buffer);

        default:
            break;
    }
}

//----------------------------------------------------------------------------
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the NBT device driver.
    This routine creates the device object for the NBT
    device and calls a routine to perform other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status;
    tDEVICES            *pBindDevices=NULL;
    tDEVICES            *pExportDevices=NULL;
    tADDRARRAY          *pAddrArray=NULL;
    PMDL                pMdl;
    PSINGLE_LIST_ENTRY  pSingleListEntry;

    UNICODE_STRING      ucWinsDeviceBindName;
    UNICODE_STRING      ucWinsDeviceExportName;
    UNICODE_STRING      ucSmbDeviceBindName;
    UNICODE_STRING      ucSmbDeviceExportName;
    UNICODE_STRING      ucNetBTClientName;
    UNICODE_STRING      ucNetBTProviderName;

    TDI_CLIENT_INTERFACE_INFO   TdiClientInterface;

#ifdef _PNP_POWER_DBG_
    //
    //Debug Stuff for DbgBreakPoint
    //
    OBJECT_ATTRIBUTES   TmpObjectAttributes;
    HANDLE              NbtConfigHandle;
    ULONG               Disposition;
    PWSTR               ParametersString = L"Parameters";
    HANDLE              ParametersHandle;
#endif  // _PNP_POWER_DBG_

    CTEPagedCode();

#ifdef _NBT_WMI_SOFTWARE_TRACING_
	WPP_INIT_TRACING(DriverObject, RegistryPath);
#endif

#ifdef _PNP_POWER_DBG_
    InitializeObjectAttributes (&TmpObjectAttributes,
                                RegistryPath,               // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
                                NULL,                       // root
                                NULL);                      // security descriptor

    status = ZwCreateKey (&NbtConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    if (!NT_SUCCESS(status))
    {
        NbtLogEvent (EVENT_NBT_CREATE_DRIVER, status, 0x109);
        return STATUS_UNSUCCESSFUL;
    }

    status = NbtOpenRegistry (NbtConfigHandle, ParametersString, &ParametersHandle);
    if (!NT_SUCCESS(status))
    {
        ZwClose(NbtConfigHandle);
        return (status);
    }

    if (CTEReadSingleIntParameter(ParametersHandle, ANSI_IF_VXD("Break"), 0, 0))  // disabled by default
    {
        KdPrint (("Nbt.DriverEntry: Registry-set Break!\n"));
        DbgBreakPoint();
    }

    ZwClose(ParametersHandle);
    ZwClose(NbtConfigHandle);
#endif  // _PNP_POWER_DBG_

    TdiInitialize();

    //
    // get the file system process for NBT since we need to know this for
    // allocating and freeing handles
    //
    NbtFspProcess =(PEPROCESS)PsGetCurrentProcess();

    //
    // Initialize the Configuration data structure
    //
    CTEZeroMemory(&NbtConfig,sizeof(tNBTCONFIG));

    NbtConfig.LoopbackIfContext = 0xffff;

    // save the driver object for event logging purposes
    //
    NbtConfig.DriverObject = DriverObject;

    // save the registry path for later use when DHCP asks us
    // to re-read the registry.
    //
    NbtConfig.pRegistry.MaximumLength = (USHORT) RegistryPath->MaximumLength;
    if (NbtConfig.pRegistry.Buffer = NbtAllocMem (RegistryPath->MaximumLength, NBT_TAG2('17')))
    {
        RtlCopyUnicodeString(&NbtConfig.pRegistry,RegistryPath);
    }
    else
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = (PDRIVER_DISPATCH)NbtDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = (PDRIVER_DISPATCH)NbtDispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = (PDRIVER_DISPATCH)NbtDispatchInternalCtrl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = (PDRIVER_DISPATCH)NbtDispatchCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = (PDRIVER_DISPATCH)NbtDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH)NbtDispatchPnP;
    DriverObject->DriverUnload                                  = NbtUnload;

    //
    // read in registry configuration data
    //
    status = NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry, so
        // we will not load!
        //
        DbgPrint ("Nbt.DriverEntry[1]: Not loading because of failure to read registry = <%x>\n", status);

        CleanupDriverEntry (1);
        return(status);
    }

    //
    // Cleanup Allocated memory
    //
    NbtReadRegistryCleanup (&pBindDevices, &pExportDevices, &pAddrArray);

    //
    // Initialize NBT global data.
    //
    status = InitNotOs();
    if (!NT_SUCCESS(status))
    {
        NbtLogEvent (EVENT_NBT_NON_OS_INIT, status, 0x110);

        DbgPrint ("Nbt.DriverEntry[3]: Not loading because of failure to Initialize = <%x>\n",status);
        CleanupDriverEntry (3);     // We may have done some partial initialization!
        return (status);
    }

    // create some MDLs, for session sends to speed up the sends.
    status = NbtInitMdlQ (&NbtConfig.SessionMdlFreeSingleList, eNBT_FREE_SESSION_MDLS);
    if (!NT_SUCCESS(status))
    {
        DbgPrint ("Nbt.DriverEntry[4]: Not loading because of failure to init Session MDL Q = <%x>\n",status);
        CleanupDriverEntry (4);
        return (status);
    }

    // create some MDLs for datagram sends
    status = NbtInitMdlQ( &NbtConfig.DgramMdlFreeSingleList, eNBT_DGRAM_MDLS);
    if (!NT_SUCCESS(status))
    {
        DbgPrint ("Nbt.DriverEntry[4]: Not loading because of failure to init Dgram MDL Q = <%x>\n", status);
        CleanupDriverEntry (4);
        return (status);
    }

    //---------------------------------------------------------------------------------------
    //
    // Create the SmbDevice object for Rdr/Srv
    //
    if ((NbtConfig.SMBDeviceEnabled) &&
        (!(pNbtSmbDevice = NbtCreateSmbDevice())))
    {
        KdPrint (("Nbt.DriverEntry: Failed to create SmbDevice!\n"));
        //
        // Allow the initialization to succeed even if this fails!
        //
    }

    //---------------------------------------------------------------------------------------

    //
    // Create the NBT device object for WINS to use
    //
    RtlInitUnicodeString (&ucWinsDeviceBindName, WC_WINS_DEVICE_BIND_NAME);
    ucWinsDeviceBindName.MaximumLength = sizeof (WC_WINS_DEVICE_BIND_NAME);
    RtlInitUnicodeString (&ucWinsDeviceExportName, WC_WINS_DEVICE_EXPORT_NAME);
    ucWinsDeviceExportName.MaximumLength = sizeof (WC_WINS_DEVICE_EXPORT_NAME);

    //
    // Try to export a DeviceObject for Wins, but do not add it to the list
    // of devices which we notify TDI about
    // Do not care about status because we want to continue even if we fail
    //
    status = NbtAllocAndInitDevice (&ucWinsDeviceBindName,
                                    &ucWinsDeviceExportName,
                                    &pWinsDeviceContext,
                                    NBT_DEVICE_WINS);

    if (!NT_SUCCESS(status))
    {
        DbgPrint ("Nbt.DriverEntry[5]: Not loading because of failure to create pWinsDevContext = <%x>\n",
            status);
        CleanupDriverEntry (5);
        return (status);
    }
    status = NbtCreateAdminSecurityDescriptor(&pWinsDeviceContext->DeviceObject);
    ASSERT(NT_SUCCESS(status));

    pWinsDeviceContext->IpAddress = 0;
    pWinsDeviceContext->DeviceRegistrationHandle = NULL;
    pWinsDeviceContext->NetAddressRegistrationHandle = NULL;
    pWinsDeviceContext->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;

    //---------------------------------------------------------------------------------------

#ifdef RASAUTODIAL
    //
    // Get the automatic connection driver
    // entry points.
    //
    NbtAcdBind();
#endif

    //---------------------------------------------------------------------------------------

    //
    // Register ourselves as a Provider with Tdi
    //
    RtlInitUnicodeString(&ucNetBTProviderName, WC_NETBT_PROVIDER_NAME);
    ucNetBTProviderName.MaximumLength = sizeof (WC_NETBT_PROVIDER_NAME);
    status = TdiRegisterProvider (&ucNetBTProviderName, &TdiProviderHandle);
    if (NT_SUCCESS (status))
    {
        //
        // Register our Handlers with TDI
        //
        RtlInitUnicodeString(&ucNetBTClientName, WC_NETBT_CLIENT_NAME);
        ucNetBTClientName.MaximumLength = sizeof (WC_NETBT_CLIENT_NAME);
        RtlZeroMemory(&TdiClientInterface, sizeof(TdiClientInterface));

        TdiClientInterface.MajorTdiVersion      = MAJOR_TDI_VERSION;
        TdiClientInterface.MinorTdiVersion      = MINOR_TDI_VERSION;
        TdiClientInterface.ClientName           = &ucNetBTClientName;
        TdiClientInterface.AddAddressHandlerV2  = TdiAddressArrival;
        TdiClientInterface.DelAddressHandlerV2  = TdiAddressDeletion;
        TdiClientInterface.BindingHandler       = TdiBindHandler;
        TdiClientInterface.PnPPowerHandler      = TdiPnPPowerHandler;

        status = TdiRegisterPnPHandlers (&TdiClientInterface, sizeof(TdiClientInterface), &TdiClientHandle);
        if (!NT_SUCCESS (status))
        {
            TdiDeregisterProvider (TdiProviderHandle);
            TdiProviderHandle = NULL;
        }
    }
    else
    {
        TdiProviderHandle = NULL;
    }

    if (!NT_SUCCESS (status))
    {
        DbgPrint ("Nbt.DriverEntry[6]: Not loading because of error = <%x>\n", status);
        CleanupDriverEntry (6);
    }

    //
    // Return to the caller.
    //
    return (status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchCleanup(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for IRP_MJ_CLEANUP
    requests.

    This function is called when the last reference to the handle is closed.
    Hence, an NtClose() results in an IRP_MJ_CLEANUP first, and then an
    IRP_MJ_CLOSE.  This function runs down all activity on the object, and
    when the close comes in the object is actually deleted.

Arguments:

    device    - ptr to device object for target device
    pIrp       - ptr to I/O request packet

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp;
    tDEVICECONTEXT   *pDeviceContext;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_CLEANUP);

    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchCleanup: Short-Ckt request --Device=<%x>, Context=<%x>, Context2=<%x>\n",
                pDeviceContext, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2));

        status = STATUS_SUCCESS;

        pIrp->IoStatus.Status = status;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (status);
    }

    // look at the context value that NBT put into the FSContext2 value to
    // decide what to do
    switch ((USHORT)pIrpSp->FileObject->FsContext2)
    {
        case NBT_ADDRESS_TYPE:
            // the client is closing the address file, so we must cleanup
            // and memory blocks associated with it.
            status = NTCleanUpAddress(pDeviceContext,pIrp);
            break;

        case NBT_CONNECTION_TYPE:
            // the client is closing a connection, so we must clean up any
            // memory blocks associated with it.
            status = NTCleanUpConnection(pDeviceContext,pIrp);
            break;

        case NBT_WINS_TYPE:
            //
            // This is synchronous with the Wins NtClose operation
            //
            status = NTCleanUpWinsAddr (pDeviceContext, pIrp);
            break;

        case NBT_CONTROL_TYPE:
            // there is nothing to do here....
            status = STATUS_SUCCESS;
            break;

        default:
            /*
             * complete the i/o successfully.
             */
            status = STATUS_SUCCESS;
            break;
    }

    //
    // Complete the Irp
    //
    ReturnIrp(pIrp, status);

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
} // DispatchCleanup


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchClose(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for IRP_MJ_CLOSE
    requests.  This is called after Cleanup (above) is called.

Arguments:

    device  - ptr to device object for target device
    pIrp     - ptr to I/O request packet

Return Value:

    an NT status code.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;
    tDEVICECONTEXT   *pDeviceContext;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_CLOSE);

    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchClose: Short-Ckt request -- Device=<%x>, Context=<%x>, Context2=<%x>\n",
                pDeviceContext, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2));

        status = STATUS_SUCCESS;

        pIrp->IoStatus.Status = status;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (status);
    }

    //
    // close operations are synchronous.
    //
    pIrp->IoStatus.Status      = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    switch (PtrToUlong(pIrpSp->FileObject->FsContext2))
        {
        case NBT_ADDRESS_TYPE:
            status = NTCloseAddress(pDeviceContext,pIrp);
            break;

        case NBT_CONNECTION_TYPE:
            status = NTCloseConnection(pDeviceContext,pIrp);
            break;

        case NBT_WINS_TYPE:
            //
            // We don't need to set the DeviceContext here since we had
            // already saved it in pWinsInfo
            // This is an Asynchronous operation wrt the Wins server, hence
            // we should do only minimal work in this routine -- the
            // major cleanup should be in the DispatchCleanup routine
            //
            status = NTCloseWinsAddr(pDeviceContext,pIrp);
            break;

        case NBT_CONTROL_TYPE:
            // the client is closing the Control Object...
            // there is nothing to do here....
            status = STATUS_SUCCESS;
            break;

        default:
            KdPrint(("Nbt:Close Received for unknown object type = %X\n",
                                         pIrpSp->FileObject->FsContext2));
            status = STATUS_SUCCESS;
            break;
        }

    // NTCloseAddress can return Pending until the ref count actually gets
    // to zero.
    //
    if (status != STATUS_PENDING)
    {
        ReturnIrp(pIrp, status);
    }

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
} // DispatchClose


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchCreate(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for IRP_MJ_CREATE
    requests.  It is called as a consequence of one of the following:

        a. TdiOpenConnection("\Device\Nbt_Elnkii0"),
        b. TdiOpenAddress("\Device\Nbt_Elnkii0"),

Arguments:

    Device - ptr to device object being opened
    pIrp    - ptr to I/O request packet
    pIrp->Status => return status
    pIrp->MajorFunction => IRP_MD_CREATE
    pIrp->MinorFunction => not used
    pIpr->FileObject    => ptr to file obj created by I/O system. NBT fills in FsContext
    pIrp->AssociatedIrp.SystemBuffer => ptr to EA buffer with address of obj to open(Netbios Name)
    pIrp->Parameters.Create.EaLength => length of buffer specifying the Xport Addr.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING

--*/

{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          pIrpSp;
    PFILE_FULL_EA_INFORMATION   ea, eabuf;
    tDEVICECONTEXT              *pDeviceContext;
    UCHAR                       IrpFlags;
    tIPADDRESS UNALIGNED        *pIpAddressU;
    tIPADDRESS                  IpAddress;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_CREATE);

    //
    // If this device was destroyed, then reject all opens on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchCreate: Short-Ckt request -- Device=<%x>, CtrlCode=<%x>\n",
                pDeviceContext, pIrpSp->Parameters.DeviceIoControl.IoControlCode));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    IrpFlags = pIrpSp->Control;

    //
    // set the pending flag here so that it is sure to be set BEFORE the
    // completion routine gets hit.
    //
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    /*
     * was this a TdiOpenConnection() or TdiOpenAddress()?
     * Get the Extended Attribute pointer and look at the text
     * value passed in for a match with "TransportAddress" or
     * "ConnectionContext" (in FindEa)
     */
    ea = (PFILE_FULL_EA_INFORMATION) pIrp->AssociatedIrp.SystemBuffer;

    IF_DBG(NBT_DEBUG_DRIVER)
        KdPrint(("Nbt.NbtDispatchCreate: Major:Minor=<%x:%x>, PFILE_FULL_EA_INFORMATION = <%x>\n",
            pIrpSp->MajorFunction, pIrpSp->MinorFunction, ea));

    if (!ea)
    {
        // a null ea means open the control object
        status = NTOpenControl(pDeviceContext,pIrp);
    }
    else if (eabuf = FindInEA(ea, TdiConnectionContext))
    {
        // not allowed to pass in both a Connect Request and a Transport Address
        ASSERT(!FindInEA(ea, TdiTransportAddress));
        status = NTOpenConnection(pDeviceContext, pIrp, eabuf);
    }
    else if (eabuf = FindInEA(ea, TdiTransportAddress))
    {
        status = NTOpenAddr(pDeviceContext, pIrp, eabuf);
    }
    else if (eabuf = FindInEA(ea, WINS_INTERFACE_NAME))
    {
        pIpAddressU = (tIPADDRESS UNALIGNED *) &ea->EaName[ea->EaNameLength+1];
        if (IpAddress = *pIpAddressU)
        {
            status = NTOpenWinsAddr(pDeviceContext, pIrp, IpAddress);
        }
        else
        {
            status = STATUS_INVALID_ADDRESS;
        }
    }
    else
    {
        status = STATUS_INVALID_EA_NAME;
    }

    // complete the irp if the status is anything EXCEPT status_pending
    // since the name query completion routine NTCompletIO completes pending
    // open addresses

    if (status != STATUS_PENDING)
    {

#if DBG
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDispatchCreate: Returning Error status = %X\n",status));
        }
#endif
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        ReturnIrp(pIrp,status);

    }

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchDevCtrl(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for all
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION  pIrpSp;
    tDEVICECONTEXT      *pDeviceContext;
    ULONG               IoControlCode;
    PULONG_PTR          pEntryPoint;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

    //
    // If this device was destroyed, then reject all requests on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchDevCtrl: Short-Ckt request -- Device=<%x>, CtrlCode=<%x>\n",
                pDeviceContext, pIrpSp->Parameters.DeviceIoControl.IoControlCode));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    /*
     * Initialize the I/O status block.
     */
    pIrp->IoStatus.Status      = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;
    IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode; // Save the IoControl code

    IF_DBG(NBT_DEBUG_DRIVER)
    KdPrint(("Nbt.NbtDispatchDevCtrl: IoControlCode = <%x>\n",
        pIrpSp->Parameters.DeviceIoControl.IoControlCode));

    /*
     * if possible, convert the (external) device control into internal
     * format, then treat it as if it had arrived that way.
     */
    if (STATUS_SUCCESS == TdiMapUserRequest(Device, pIrp, pIrpSp))
    {
        status = NbtDispatchInternalCtrl (Device, pIrp);
    }
#if FAST_DISP
    // Check if upper layer is querying for fast send path
    else if (pIrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER)
    {
        if (pEntryPoint = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer)
        {
            if (pIrp->RequestorMode != KernelMode) // Bug# 120649:  Make sure data + the Address type are good
            {
                try
                {
                    ProbeForWrite (pEntryPoint, sizeof(PVOID *), sizeof(BYTE));
                    *pEntryPoint = (ULONG_PTR) NTSend;
                    status = STATUS_SUCCESS;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // status = STATUS_UNSUCCESSFUL by default
                }
            }
            else
            {
                *pEntryPoint = (ULONG_PTR) NTSend;
                status = STATUS_SUCCESS;
            }
        }

        IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchDevCtrl: direct send handler query %x\n", pEntryPoint));

        ReturnIrp(pIrp, status);
    }
#endif
    else
    {
        status = DispatchIoctls (pDeviceContext, pIrp, pIrpSp);
    }

    //
    // Dereference this DeviceContext, unless it was to destroy the Device!
    //
    if (IoControlCode != IOCTL_NETBT_DELETE_INTERFACE)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    }

    return (status);
} // NbtDispatchDevCtrl


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchInternalCtrl(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the driver's dispatch function for all
    IRP_MJ_INTERNAL_DEVICE_CONTROL requests.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    tDEVICECONTEXT      *pDeviceContext;
    PIO_STACK_LOCATION  pIrpSp;
    NTSTATUS            status;
    UCHAR               IrpFlags;

    pDeviceContext = (tDEVICECONTEXT *)Device;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    //
    // this check is first to optimize the Send path
    //
    if (pIrpSp->MinorFunction ==TDI_SEND)
    {
        //
        // this routine decides if it should complete the pIrp or not
        // It never returns status pending, so we can turn off the
        // pending bit
        //
        status = NTSend (pDeviceContext,pIrp);
        return status;
    }

    //
    // If this device was destroyed, then reject all operations on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchInternalCtrl: Short-Ckt request -- Device=<%x>, CtrlCode=<%x>\n",
                pDeviceContext, pIrpSp->Parameters.DeviceIoControl.IoControlCode));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    IrpFlags = pIrpSp->Control;

    IF_DBG(NBT_DEBUG_DRIVER)
        KdPrint(("Nbt.NbtDispatchInternalCtrl: MajorFunction:MinorFunction = <%x:%x>\n",
            pIrpSp->MajorFunction, pIrpSp->MinorFunction));

    switch (pIrpSp->MinorFunction)
    {
        case TDI_ACCEPT:
            MakePending(pIrp);
            status = NTAccept(pDeviceContext,pIrp);
            break;

        case TDI_ASSOCIATE_ADDRESS:
            MakePending(pIrp);
            status = NTAssocAddress(pDeviceContext,pIrp);
            break;

        case TDI_DISASSOCIATE_ADDRESS:
            MakePending(pIrp);
            status = NTDisAssociateAddress(pDeviceContext,pIrp);
            break;

        case TDI_CONNECT:
            MakePending(pIrp);
            status = NTConnect(pDeviceContext,pIrp);
            break;

        case TDI_DISCONNECT:
            MakePending(pIrp);
            status = NTDisconnect(pDeviceContext,pIrp);
            break;

        case TDI_LISTEN:
            status = NTListen(pDeviceContext,pIrp);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(status);
            break;

        case TDI_QUERY_INFORMATION:
            status = NTQueryInformation(pDeviceContext,pIrp);
#if DBG
            if (!NT_SUCCESS(status))
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDispatchInternalCtrl: Bad status from NTQueryInformation = %x\n",status));
            }
#endif
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(status);
            break;

        case TDI_RECEIVE:
            status = NTReceive(pDeviceContext,pIrp);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(status);

            break;

        case TDI_RECEIVE_DATAGRAM:
            status = NTReceiveDatagram(pDeviceContext,pIrp);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(status);
            break;


    case TDI_SEND_DATAGRAM:

            status = NTSendDatagram(pDeviceContext,pIrp);
#if DBG
            if (!NT_SUCCESS(status))
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDispatchInternalCtrl: Bad status from NTSendDatagram = %x\n",status));
            }
#endif
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(status);
            break;

        case TDI_SET_EVENT_HANDLER:
            MakePending(pIrp);
            status = NTSetEventHandler(pDeviceContext,pIrp);
            break;

        case TDI_SET_INFORMATION:
            MakePending(pIrp);
            status = NTSetInformation(pDeviceContext,pIrp);
            break;

    #if DBG
        //
        // 0x7f is a request by the redirector to put a "magic bullet" out on
        // the wire, to trigger the Network General Sniffer.
        //
        case 0x7f:
            KdPrint(("NBT.DispatchInternalCtrl: - 07f minor function code\n"));
            ReturnIrp(pIrp, STATUS_NOT_SUPPORTED);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(STATUS_NOT_SUPPORTED);

    #endif /* DBG */

        default:
            KdPrint(("Nbt.DispatchInternalCtrl: Invalid minor function %X\n",
                            pIrpSp->MinorFunction));
            ReturnIrp(pIrp, STATUS_INVALID_DEVICE_REQUEST);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(STATUS_INVALID_DEVICE_REQUEST);
    }

    // if the returned status is pending, then we do not complete the IRP
    // here since it will be completed elsewhere in the code...
    //
    if (status != STATUS_PENDING)
    {
#if DBG
        // *TODO* for debug...
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtDispatchInternalCtrl: Returning Error status = %X,MinorFunc = %X\n",
                status,pIrpSp->MinorFunction));
//            ASSERTMSG("An error Status reported from NBT",0L);
        }
#endif
        pIrpSp->Control = IrpFlags;
        ReturnIrp(pIrp,status);
    }

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
} // NbtDispatchInternalCtrl


//----------------------------------------------------------------------------

ULONG
CompleteTimerAndWorkerRequests(
    )
{
    CTELockHandle               OldIrq;
    tDEVICECONTEXT              *pDeviceContext;
    LIST_ENTRY                  *pTimerQEntry;
    tTIMERQENTRY                *pTimer;
    LIST_ENTRY                  *pWorkerQEntry;
    NBT_WORK_ITEM_CONTEXT       *pContext;
    PNBT_WORKER_THREAD_ROUTINE  pCompletionRoutine;
    ULONG                       NumTimerRequests = 0;
    ULONG                       NumDelayedRequests = 0;
    NTSTATUS   status;

    //
    // First remove any active Device Contexts if they are still present
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    while (!IsListEmpty(&NbtConfig.DeviceContexts))
    {
        pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink, tDEVICECONTEXT, Linkage);
        NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtDestroyDevice (pDeviceContext, FALSE);   // Don't wait since the Worker threads will not fire
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (pNbtSmbDevice)
    {
        NbtDestroyDevice (pNbtSmbDevice, FALSE);   // Don't wait since the Worker threads will not fire
        pNbtSmbDevice = NULL;
    }

    NbtDestroyDevice (pWinsDeviceContext, FALSE);   // Don't wait since the Worker threads will not fire

    StopInitTimers();
    KeClearEvent (&NbtConfig.TimerQLastEvent);

    //
    // if any other timers are active, stop them
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    while (!IsListEmpty(&TimerQ.ActiveHead))
    {
        pTimerQEntry = RemoveHeadList(&TimerQ.ActiveHead);
        pTimer = CONTAINING_RECORD(pTimerQEntry,tTIMERQENTRY,Linkage);
        InitializeListHead (&pTimer->Linkage);      // in case the Linkage is touched again

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("CompleteTimerAndWorkerRequests[%d]: Completing request <%x>\n",
                NumTimerRequests, pTimer));

        StopTimer (pTimer, NULL, NULL);

        NumTimerRequests++;
    }

    //
    // See if there are any Timers currently executing, and if so, wait for
    // them to complete
    //
    if (NbtConfig.NumTimersRunning)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = KeWaitForSingleObject(&NbtConfig.TimerQLastEvent,  // Object to wait on.
                                       Executive,            // Reason for waiting
                                       KernelMode,           // Processor mode
                                       FALSE,                // Alertable
                                       NULL);                // Timeout
        ASSERT(status == STATUS_SUCCESS);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    //
    // See if there are any worker threads currently executing, and if so, wait for
    // them to complete
    //
    KeClearEvent (&NbtConfig.WorkerQLastEvent);
    CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
    if (NbtConfig.NumWorkerThreadsQueued)
    {
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);

        status = KeWaitForSingleObject(&NbtConfig.WorkerQLastEvent,  // Object to wait on.
                                       Executive,            // Reason for waiting
                                       KernelMode,           // Processor mode
                                       FALSE,                // Alertable
                                       NULL);                // Timeout
        ASSERT(status == STATUS_SUCCESS);
    }
    else
    {
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);
    }

    //
    // Dequeue each of the requests in the Worker Queue and complete them
    //
    CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
    while (!IsListEmpty(&NbtConfig.WorkerQList))
    {
        pWorkerQEntry = RemoveHeadList(&NbtConfig.WorkerQList);
        pContext = CONTAINING_RECORD(pWorkerQEntry, NBT_WORK_ITEM_CONTEXT, NbtConfigLinkage);
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);             // To get back to non-raised Irql!

        pCompletionRoutine = pContext->WorkerRoutine;

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("CompleteTimerAndWorkerRequests[%d]: Completing request <%x>\n",
                NumDelayedRequests, pCompletionRoutine));

        (*pCompletionRoutine) (pContext->pTracker,
                               pContext->pClientContext,
                               pContext->ClientCompletion,
                               pContext->pDeviceContext);

        CTEMemFree ((PVOID) pContext);

        NumDelayedRequests++;
        //
        // Acquire Lock again to check if we have completed all the requests
        //
        CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
    }
    CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);

    //
    // Now destroy the Devices queued on the Free'ed list since there are no more Worker threads or
    // Timers pending!
    //
    while (!IsListEmpty(&NbtConfig.DevicesAwaitingDeletion))
    {
        pDeviceContext = CONTAINING_RECORD(NbtConfig.DevicesAwaitingDeletion.Flink, tDEVICECONTEXT, Linkage);
        ASSERT (pDeviceContext->RefCount == 0);

        KdPrint(("Nbt.CompleteTimerAndWorkerRequests: *** Destroying Device *** \n\t%wZ\n",
            &pDeviceContext->ExportName));

        RemoveEntryList (&pDeviceContext->Linkage); // Remove the Device from the to-be-free'ed list

        CTEMemFree (pDeviceContext->ExportName.Buffer);
        IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);
    }

    ASSERT (IsListEmpty(&NbtConfig.AddressHead));
    KdPrint(("Nbt.CompleteTimerAndWorkerRequests:  Completed <%d> Timer and <%d> Delayed requests\n",
        NumTimerRequests, NumDelayedRequests));

    return (NumTimerRequests + NumDelayedRequests);
}



//----------------------------------------------------------------------------
VOID
NbtUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for Unload requests

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/

{
    NTSTATUS                status;

    CTEPagedCode();

    KdPrint(("Nbt.NbtUnload: Unloading ...\n"));

    //
    // After setting the following flag, no new requests should be queued on to
    // the WorkerQ NbtConfig.WorkerQLastEvent will be set when all the current
    // requests have finished executing
    //
    NbtConfig.Unloading = TRUE;

    //
    // Unbind fron the RAS driver if we were bound
    //
    NbtAcdUnbind ();

    status = TdiDeregisterPnPHandlers(TdiClientHandle);
    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("NbtUnload: TdiDeregisterPnPHandlers returned <%x>\n", status));

    status = TdiDeregisterProvider (TdiProviderHandle);
    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("NbtUnload: TdiDeregisterProvider returned <%x>\n", status));

    //
    // Dequeue each of the requests in the Timer and NbtConfigWorker Queues and complete them
    //
    CompleteTimerAndWorkerRequests();

    //
    // Now cleanup the rest of the static allocations
    //
    CleanupDriverEntry (5);

    ASSERT (IsListEmpty (&NbtConfig.PendingNameQueries));

    if (NbtConfig.pServerBindings) {
        CTEFreeMem (NbtConfig.pServerBindings);
        NbtConfig.pServerBindings = NULL;
    }

    if (NbtConfig.pClientBindings) {
        CTEFreeMem (NbtConfig.pClientBindings);
        NbtConfig.pClientBindings = NULL;
    }

#ifdef _NBT_WMI_SOFTWARE_TRACING_
    WPP_CLEANUP(DriverObject);
#endif
}


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchPnP(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )
{
    tDEVICECONTEXT      *pDeviceContext;
    PIO_STACK_LOCATION  pIrpSp, pIrpSpNext;
    NTSTATUS            status = STATUS_INVALID_DEVICE_REQUEST;
    tCONNECTELE         *pConnectEle;
    tLOWERCONNECTION    *pLowerConn;
    KIRQL               OldIrq1, OldIrq2;
    PDEVICE_OBJECT      pTcpDeviceObject;
    PFILE_OBJECT        pTcpFileObject;
    tFILE_OBJECTS       *pFileObjectsContext;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // If this device was destroyed, then reject all operations on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchPnP: Short-Ckt request -- Device=<%x>\n", pDeviceContext));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
            if (pIrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation)
            {
                if (PtrToUlong(pIrpSp->FileObject->FsContext2) == NBT_CONNECTION_TYPE)
                {
                    // pass to transport to get the PDO
                    //
                    pConnectEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
                    if (NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
                    {
                        CTESpinLock(pConnectEle, OldIrq1);

                        pLowerConn = (tLOWERCONNECTION *)pConnectEle->pLowerConnId;
                        if (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN))
                        {
                            CTESpinLock(pLowerConn, OldIrq2);
                            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_DEVICE_REL);
                            CTESpinFree(pLowerConn, OldIrq2);
                            CTESpinFree(pConnectEle, OldIrq1);

                            if ((pTcpFileObject = pLowerConn->pFileObject) &&
                                (pTcpDeviceObject = IoGetRelatedDeviceObject (pLowerConn->pFileObject)))
                            {
                                //
                                // Simply pass the Irp on by to the Transport, and let it
                                // fill in the info
                                //
                                pIrpSpNext = IoGetNextIrpStackLocation (pIrp);
                                *pIrpSpNext = *pIrpSp;

                                IoSetCompletionRoutine (pIrp, NULL, NULL, FALSE, FALSE, FALSE);
                                pIrpSpNext->FileObject = pTcpFileObject;
                                pIrpSpNext->DeviceObject = pTcpDeviceObject;

                                status = IoCallDriver(pTcpDeviceObject, pIrp);

                                NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
                                return status;
                            }
                            else
                            {
                                status =  STATUS_INVALID_HANDLE;
                            }
                            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_DEVICE_REL, FALSE);
                        }
                        else
                        {
                            status = STATUS_CONNECTION_INVALID;
                            CTESpinFree(pConnectEle, OldIrq1);
                        }
                    }
                    else
                    {
                        status =  STATUS_INVALID_HANDLE;
                    }
                }
                else if ( PtrToUlong(pIrpSp->FileObject->FsContext2) == NBT_ADDRESS_TYPE)
                {
                    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

                    if ((pDeviceContext->IpAddress) &&
                        (pFileObjectsContext = pDeviceContext->pFileObjects) &&
                        (pTcpFileObject = pFileObjectsContext->pDgramFileObject) &&
                        (pTcpDeviceObject = pFileObjectsContext->pDgramDeviceObject))
                    {
                        pFileObjectsContext->RefCount++;        // Dereferenced after the Query has completed

                        //
                        // pass the Irp to transport to get the PDO
                        //
                        pIrpSpNext = IoGetNextIrpStackLocation (pIrp);
                        *pIrpSpNext = *pIrpSp;

                        IoSetCompletionRoutine (pIrp, NULL, NULL, FALSE, FALSE, FALSE);
                        pIrpSpNext->FileObject = pTcpFileObject;
                        pIrpSpNext->DeviceObject = pTcpDeviceObject;

                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        status = IoCallDriver(pTcpDeviceObject, pIrp);

                        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                        if (--pFileObjectsContext->RefCount == 0)
                        {
                            CTEQueueForNonDispProcessing(DelayedNbtCloseFileHandles,
                                                         NULL,
                                                         pFileObjectsContext,
                                                         NULL,
                                                         NULL,
                                                         TRUE);
                        }

                        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, TRUE);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                        return status;
                    }
                    else
                    {
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        status =  STATUS_INVALID_DEVICE_REQUEST;
                    }
                }
                else
                {
                    ASSERT (0);
                }
            }

            break;
        }

        default:
        {
            break;
        }
    }

    ReturnIrp(pIrp, status);
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);

    return status;
}


//----------------------------------------------------------------------------
PFILE_FULL_EA_INFORMATION
FindInEA(
    IN PFILE_FULL_EA_INFORMATION    start,
    IN PCHAR                        wanted
    )

/*++

Routine Description:

    This function check for the "Wanted" string in the Ea structure and
    returns a pointer to the extended attribute structure
    representing the given extended attribute name.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    pointer to the extended attribute structure, or NULL if not found.

--*/

{
    PFILE_FULL_EA_INFORMATION eabuf;

    CTEPagedCode();

    //
    // Bug # 225668: advance eabug ptr by typecasting it to UCHAR
    //
    for (eabuf = start; eabuf; eabuf =  (PFILE_FULL_EA_INFORMATION) ((PUCHAR)eabuf + eabuf->NextEntryOffset))
    {
        if (strncmp(eabuf->EaName,wanted,eabuf->EaNameLength) == 0)
        {
           return eabuf;
        }

        if (eabuf->NextEntryOffset == 0)
        {
            return((PFILE_FULL_EA_INFORMATION) NULL);
        }
    }
    return((PFILE_FULL_EA_INFORMATION) NULL);

} // FindEA



//----------------------------------------------------------------------------
VOID
ReturnIrp(
    IN PIRP     pIrp,
    IN int      status
    )

/*++

Routine Description:

    This function completes an IRP, and arranges for return parameters,
    if any, to be copied.

    Although somewhat a misnomer, this function is named after a similar
    function in the SpiderSTREAMS emulator.

Arguments:

    pIrp     -  pointer to the IRP to complete
    status  -  completion status of the IRP

Return Value:

    number of bytes copied back to the user.

--*/

{
    KIRQL oldlevel;
    CCHAR priboost;

    //
    // pIrp->IoStatus.Information is meaningful only for STATUS_SUCCESS
    //

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    IoAcquireCancelSpinLock(&oldlevel);
    IoSetCancelRoutine(pIrp,NULL);
    IoReleaseCancelSpinLock(oldlevel);

    pIrp->IoStatus.Status      = status;

    priboost = (CCHAR) ((status == STATUS_SUCCESS) ?
                        IO_NETWORK_INCREMENT : IO_NO_INCREMENT);

    IoCompleteRequest(pIrp, priboost);

    return;

}
//----------------------------------------------------------------------------
VOID
MakePending(
    IN PIRP     pIrp
    )

/*++

Routine Description:

    This function marks an irp pending and sets the correct status.

Arguments:

    pIrp     -  pointer to the IRP to complete
    status  -  completion status of the IRP

Return Value:


--*/

{
    IoMarkIrpPending(pIrp);
    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

}

#ifdef _NBT_WMI_SOFTWARE_TRACING_
int nbtlog_strnlen(char *p, int n)
{
    int i;

    for (i = 0; (i < n) && *p; i++, p++) {
    }

    return i;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\fileio.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fileio.c

Abstract:

    This source implements a stdio-like facility.

Author:

    Jim Stewart     June 1993

Revision History:

--*/

#include "precomp.h"
#include "hosts.h"
#include <string.h>


//
// Private Definitions
//



//
// Local Variables
//



//
// Local (Private) Functions
//
PUCHAR
LmpMapFile (
    IN HANDLE handle,
    IN OUT int *pnbytes
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, LmCloseFile)
#pragma CTEMakePageable(PAGE, LmFgets)
#pragma CTEMakePageable(PAGE, LmpMapFile)
#pragma CTEMakePageable(PAGE, LmOpenFile)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------

NTSTATUS
LmCloseFile (
    IN PLM_FILE pfile
    )

/*++

Routine Description:

    This function closes a file opened via LmOpenFile(), and frees its
    LM_FILE object.

Arguments:

    pfile  -  pointer to the LM_FILE object

Return Value:

    An NTSTATUS value.

--*/


{
    NTSTATUS status;

    CTEPagedCode();
    CTEMemFree(pfile->f_buffer);

    status = ZwClose(pfile->f_handle);

    ASSERT(status == STATUS_SUCCESS);

    CTEMemFree(pfile);

    return(status);

} // LmCloseFile



//----------------------------------------------------------------------------

PUCHAR
LmFgets (
    IN PLM_FILE pfile,
    OUT int *nbytes
    )

/*++

Routine Description:

    This function is vaguely similar to fgets(3).

    Starting at the current seek position, it reads through a newline
    character, or the end of the file. If a newline is encountered, it
    is replaced with a NULL character.

Arguments:

    pfile   -  file to read from
    nbytes  -  the number of characters read, excluding the NULL character

Return Value:

    A pointer to the beginning of the line, or NULL if we are at or past
    the end of the file.

--*/


{
    PUCHAR endOfLine;
    PUCHAR startOfLine;
    size_t maxBytes;

    CTEPagedCode();
    startOfLine = pfile->f_current;

    if (startOfLine >= pfile->f_limit)
    {

        return((PUCHAR) NULL);
    }

    maxBytes  = (size_t)(pfile->f_limit - pfile->f_current);
    endOfLine = (PUCHAR) memchr(startOfLine, (UCHAR) '\n', maxBytes);

    if (!endOfLine)
    {
        IF_DBG(NBT_DEBUG_LMHOST)
        KdPrint(("NBT: lmhosts file doesn't end in '\\n'"));
        endOfLine = pfile->f_limit;
    }

    *endOfLine = (UCHAR) NULL;

    pfile->f_current = endOfLine + 1;
    (pfile->f_lineno)++;
    ASSERT(pfile->f_current <= pfile->f_limit+1);

    *nbytes = (int)(endOfLine - startOfLine);

    return(startOfLine);

} // LmFgets



//----------------------------------------------------------------------------

PUCHAR
LmpMapFile (
    IN HANDLE handle,
    IN OUT int *pnbytes
    )

/*++

Routine Description:

    This function reads an entire file into memory.

Arguments:

    handle  -  file handle
    pnbytes -  size of the whole file


Return Value:

    the buffer allocated, or NULL if unsuccessful.

--*/


{
    PUCHAR                     buffer;
    NTSTATUS                   status;
    IO_STATUS_BLOCK            iostatus;
    FILE_STANDARD_INFORMATION  stdInfo;
    LARGE_INTEGER offset ={0, 0};
    LARGE_INTEGER length ={0x7fffffff, 0x7fffffff};

    CTEPagedCode();


    status = ZwQueryInformationFile(
                handle,                         // FileHandle
                &iostatus,                      // IoStatusBlock
                (PVOID) &stdInfo,               // FileInformation
                sizeof(stdInfo),                // Length
                FileStandardInformation);       // FileInformationClass

    if (status != STATUS_SUCCESS)
    {
        IF_DBG(NBT_DEBUG_LMHOST)
        KdPrint(("NBT: ZwQueryInformationFile(std) = %X\n", status));
        return(NULL);
    }

    length = stdInfo.EndOfFile;                 // structure copy

    if (length.HighPart)
    {
        return(NULL);
    }

    buffer = NbtAllocMem (length.LowPart+2, NBT_TAG2('18'));

    if (buffer != NULL)
    {

        status = ZwReadFile(
                    handle,                         // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &iostatus,                      // IoStatusBlock
                    buffer,                         // Buffer
                    length.LowPart,                 // Length
                    &offset,                        // ByteOffset
                    NULL);                          // Key

        if (status != STATUS_SUCCESS)
        {
            IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("NBT: ZwReadFile(std) = %X\n", status));
        }

        ASSERT(status != STATUS_PENDING);

        if (iostatus.Status != STATUS_SUCCESS || status != STATUS_SUCCESS)
        {
            CTEMemFree(buffer);
            return(NULL);
        }

        *pnbytes = length.LowPart;
    }
    return(buffer);

} // LmpMapFile



//----------------------------------------------------------------------------

PLM_FILE
LmOpenFile (
    IN PUCHAR path
    )

/*++

Routine Description:

    This function opens a file for use by LmFgets().

Arguments:

    path    -  a fully specified, complete path to the file.

Return Value:

    A pointer to an LM_FILE object, or NULL if unsuccessful.

--*/


{
    NTSTATUS                   status;
    HANDLE                     handle;
    PLM_FILE                   pfile;
    IO_STATUS_BLOCK            iostatus;
    OBJECT_ATTRIBUTES          attributes;
    UNICODE_STRING             ucPath;
    PUCHAR                     start;
    int                        nbytes;
    OEM_STRING                 String;
    PUCHAR                     LongerPath;


    CTEPagedCode();
    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    status = LmGetFullPath(path,&LongerPath);

    if (NT_SUCCESS(status))
    {
        RtlInitString(&String,LongerPath);

        status = RtlAnsiStringToUnicodeString(&ucPath,&String,TRUE);

        if (NT_SUCCESS(status))
        {

#ifdef HDL_FIX
            InitializeObjectAttributes (&attributes,                                // POBJECT_ATTRIBUTES
                                        &ucPath,                                    // ObjectName
                                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // Attributes
                                        (HANDLE) NULL,                              // RootDirectory
                                        (PSECURITY_DESCRIPTOR) NULL);               // SecurityDescriptor
#else
            InitializeObjectAttributes (&attributes,                                // POBJECT_ATTRIBUTES
                                        &ucPath,                                    // ObjectName
                                        OBJ_CASE_INSENSITIVE,                       // Attributes
                                        (HANDLE) NULL,                              // RootDirectory
                                        (PSECURITY_DESCRIPTOR) NULL);               // SecurityDescriptor
#endif  // HDL_FIX

            status = ZwCreateFile (&handle,                            // FileHandle
                                   SYNCHRONIZE | FILE_READ_DATA,       // DesiredAccess
                                   &attributes,                        // ObjectAttributes
                                   &iostatus,                          // IoStatusBlock
                                   0,                                  // AllocationSize
                                   FILE_ATTRIBUTE_NORMAL,              // FileAttributes
                                   FILE_SHARE_READ | FILE_SHARE_WRITE, // ShareAccess
                                   FILE_OPEN,                          // CreateDisposition
                                   FILE_SYNCHRONOUS_IO_NONALERT,       // OpenOptions
                                   NULL,                               // EaBuffer
                                   0);                                 // EaLength

            if (NT_SUCCESS(status))
            {
                start = LmpMapFile(handle, &nbytes);

                if (start)
                {
                    pfile = (PLM_FILE) NbtAllocMem (sizeof(LM_FILE), NBT_TAG2('19'));
                    if (pfile)
                    {
                        KeInitializeSpinLock(&(pfile->f_lock));

                        pfile->f_refcount            = 1;
                        pfile->f_handle              = handle;
                        pfile->f_lineno              = 0;
                        pfile->f_fileOffset.HighPart = 0;
                        pfile->f_fileOffset.LowPart  = 0;

                        pfile->f_current = start;
                        pfile->f_buffer  = start;
                        pfile->f_limit   = pfile->f_buffer + nbytes;

                        RtlFreeUnicodeString(&ucPath);
                        CTEMemFree(LongerPath);

                        return(pfile);
                    }

                    CTEMemFree(start);
                }

                ZwClose(handle);
            }

            RtlFreeUnicodeString(&ucPath);

            IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("Nbt.LmOpenFile: ZwOpenFile(std) = %X\n", status));

        }

        CTEMemFree(LongerPath);
    }

    return((PLM_FILE) NULL);

} // LmOpenFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\timer.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Timer.c

Abstract:


    This file contains the code to implement timer functions.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "timer.h"
#include "ntddndis.h"

// the timer Q
tTIMERQ TimerQ;


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, InitTimerQ)
#pragma CTEMakePageable(PAGE, DestroyTimerQ)
#pragma CTEMakePageable(PAGE, DelayedNbtStopWakeupTimer)
#endif
// #pragma CTEMakePageable(PAGE, WakeupTimerExpiry)
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------
NTSTATUS
InterlockedCallCompletion(
    IN  tTIMERQENTRY    *pTimer,
    IN  NTSTATUS        status
    )
/*++

Routine Description:

    This routine calls the completion routine if it hasn't been called
    yet, by first getting the JointLock spin lock and then getting the
    Completion routine ptr. If the ptr is null then the completion routine
    has already been called. Holding the Spin lock interlocks this
    with the timer expiry routine to prevent more than one call to the
    completion routine.

Arguments:

Return Value:

    there is no return value


--*/
{
    CTELockHandle       OldIrq;
    COMPLETIONCLIENT    pClientCompletion;

    // to synch. with the the Timer completion routines, Null the client completion
    // routine so it gets called just once, either from here or from the
    // timer completion routine setup when the timer was started.(in namesrv.c)
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pClientCompletion = pTimer->ClientCompletion;
    pTimer->ClientCompletion = NULL;
    if (pClientCompletion)
    {
        // remove the link from the name table to this timer block
        CHECK_PTR(((tNAMEADDR *)pTimer->pCacheEntry));
        ((tNAMEADDR *)pTimer->pCacheEntry)->pTimer = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        (*pClientCompletion) (pTimer->ClientContext, status);
        return(STATUS_SUCCESS);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(STATUS_UNSUCCESSFUL);
}

//----------------------------------------------------------------------------
NTSTATUS
InitTimerQ(
    IN  int     NumInQ
    )
/*++

Routine Description:

    This routine sets up the timer Q to have NumInQ entries to start with.
    These are blocks allocated for timers so that ExAllocatePool does not
    need to be done later.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tTIMERQENTRY    *pTimerEntry;

    CTEPagedCode();

    InitializeListHead(&TimerQ.ActiveHead);
    InitializeListHead(&TimerQ.FreeHead);

    // allocate memory for the free list
    while(NumInQ--)
    {
        pTimerEntry = (tTIMERQENTRY *) NbtAllocMem (sizeof(tTIMERQENTRY), NBT_TAG2('15'));
        if (!pTimerEntry)
        {
            KdPrint(("Nbt.InitTimerQ: Unable to allocate memory!! - for the timer Q\n"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        else
        {
            pTimerEntry->Verify = NBT_VERIFY_TIMER_DOWN;
            InsertHeadList(&TimerQ.FreeHead, &pTimerEntry->Linkage);
        }
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
DestroyTimerQ(
    )
/*++

Routine Description:

    This routine clears up the TimerQEntry structures allocated

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tTIMERQENTRY    *pTimer;
    PLIST_ENTRY     pEntry;

    CTEPagedCode();

    while (!IsListEmpty (&TimerQ.FreeHead))
    {
        pEntry = RemoveHeadList(&TimerQ.FreeHead);
        pTimer = CONTAINING_RECORD(pEntry, tTIMERQENTRY, Linkage);
        CTEMemFree(pTimer);
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
GetTimerEntry(
    OUT tTIMERQENTRY    **ppTimerEntry
    )
/*++

Routine Description:

    This routine gets a free block from the &TimerQ.FreeHead, and if the
    list is empty it allocates another memory block for the queue.
    NOTE: this function is called with the JointLock held.

Arguments:

Return Value:

    The function value is the status of the operation.


--*/
{
    PLIST_ENTRY     pEntry;
    tTIMERQENTRY    *pTimerEntry;

    if (!IsListEmpty(&TimerQ.FreeHead))
    {
        pEntry = RemoveHeadList(&TimerQ.FreeHead);
        pTimerEntry = CONTAINING_RECORD(pEntry,tTIMERQENTRY,Linkage);
        ASSERT (pTimerEntry->Verify == NBT_VERIFY_TIMER_DOWN);
    }
    else if (!(pTimerEntry = (tTIMERQENTRY *) NbtAllocMem (sizeof(tTIMERQENTRY), NBT_TAG2('16'))))
    {
        KdPrint(("Unable to allocate memory!! - for the timer Q\n"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    *ppTimerEntry = pTimerEntry;
    pTimerEntry->Verify = NBT_VERIFY_TIMER_ACTIVE;
    NbtConfig.NumTimersRunning++;

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
ReturnTimerToFreeQ(
    tTIMERQENTRY    *pTimerEntry,
    BOOLEAN         fLocked
    )
{
    CTELockHandle   OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    // return the timer block
    ASSERT (pTimerEntry->Verify == NBT_VERIFY_TIMER_ACTIVE);
    pTimerEntry->Verify = NBT_VERIFY_TIMER_DOWN;
    InsertTailList(&TimerQ.FreeHead,&pTimerEntry->Linkage);
    if (!--NbtConfig.NumTimersRunning)
    {
        KeSetEvent(&NbtConfig.TimerQLastEvent, 0, FALSE);
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
CleanupCTETimer(
    IN  tTIMERQENTRY     *pTimerEntry
    )
/*++

Routine Description:

    This routine cleans up the timer. Called with the JointLock held.

Arguments:


Return Value:

    returns the reference count after the decrement

--*/
{
    COMPLETIONROUTINE   TimeoutRoutine;
    PVOID               Context;
    PVOID               Context2;

    pTimerEntry->RefCount = 0;

    // the expiry routine is not currently running so we can call the
    // completion routine and remove the timer from the active timer Q

    TimeoutRoutine = (COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine;
    pTimerEntry->TimeoutRoutine = NULL;
    Context = pTimerEntry->Context;
    Context2 = pTimerEntry->Context2;

    if (pTimerEntry->pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE ((tDEVICECONTEXT *) pTimerEntry->pDeviceContext, REF_DEV_TIMER, TRUE);
        pTimerEntry->pDeviceContext = NULL;
    }

    // release any tracker block hooked to the timer entry.. This could
    // be modified to not call the completion routine if there was
    // no context value... ie. for those timers that do not have anything
    // to cleanup ...however, for now we require all completion routines
    // to have a if (pTimerQEntry) if around the code so when it gets hit
    // from this call it does not access any part of pTimerQEntry.
    //
    if (TimeoutRoutine)
    {
        // call the completion routine so it can clean up its own buffers
        // the routine that called this one will call the client's completion
        // routine.  A NULL timerEntry value indicates to the routine that
        // cleanup should be done.

        (VOID)(*TimeoutRoutine) (Context, Context2, NULL);
    }

    // move to the free list
    RemoveEntryList(&pTimerEntry->Linkage);
    ReturnTimerToFreeQ (pTimerEntry, TRUE);

    return(STATUS_SUCCESS);
}



//----------------------------------------------------------------------------
NTSTATUS
StartTimer(
    IN  PVOID           TimeoutRoutine,
    IN  ULONG           DeltaTime,
    IN  PVOID           Context,
    IN  PVOID           Context2,
    IN  PVOID           ContextClient,
    IN  PVOID           CompletionClient,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tTIMERQENTRY    **ppTimerEntry,
    IN  USHORT          Retries,
    BOOLEAN             fLocked)
/*++

Routine Description:

    This routine starts a timer.
    It has to be called with the JointLock held!

Arguments:

    The value passed in is in milliseconds - must be converted to 100ns
    so multiply to 10,000

Return Value:
    The function value is the status of the operation.


--*/
{
    tTIMERQENTRY    *pTimerEntry;
    NTSTATUS        status;
    CTELockHandle   OldIrq;

    //
    // Do not allow any timers to be started if we are currently
    // Unloading!
    //
    if (NbtConfig.Unloading)
    {
        return STATUS_UNSUCCESSFUL;
    }

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    if ((!pDeviceContext) ||
        (NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_TIMER, TRUE)))
    {
        // get a free timer block
        status = GetTimerEntry (&pTimerEntry);
        if (NT_SUCCESS(status))
        {
            pTimerEntry->DeltaTime = DeltaTime;
            pTimerEntry->RefCount = 1;
            //
            // this is the context value and routine called when the timer expires,
            // called by TimerExpiry below.
            //
            pTimerEntry->Context = Context;
            pTimerEntry->Context2 = Context2;
            pTimerEntry->TimeoutRoutine = TimeoutRoutine;
            pTimerEntry->Flags = 0; // no flags

            // now fill in the client's completion routines that ultimately get called
            // after one or more timeouts...
            pTimerEntry->ClientContext = (PVOID)ContextClient;
            pTimerEntry->ClientCompletion = (COMPLETIONCLIENT)CompletionClient;
            pTimerEntry->Retries = Retries;

            pTimerEntry->pDeviceContext = (PVOID) pDeviceContext;

            CTEInitTimer(&pTimerEntry->VxdTimer);
            CTEStartTimer(&pTimerEntry->VxdTimer,
                           pTimerEntry->DeltaTime,
                           (CTEEventRtn)TimerExpiry,
                           (PVOID)pTimerEntry);

            // check if there is a ptr to return
            if (ppTimerEntry)
            {
                *ppTimerEntry = pTimerEntry;
            }

            // put on list
            InsertHeadList(&TimerQ.ActiveHead, &pTimerEntry->Linkage);
        }
        else if (pDeviceContext)
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_TIMER, TRUE);
        }
    }
    else
    {
        status = STATUS_INVALID_DEVICE_STATE;
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
StopTimer(
    IN  tTIMERQENTRY     *pTimerEntry,
    OUT COMPLETIONCLIENT *ppClientCompletion,
    OUT PVOID            *ppContext)
/*++

Routine Description:

    This routine stops a timer.  Must be called with the Joint lock held.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS            status;
    COMPLETIONROUTINE   TimeoutRoutine;

    // null the client completion routine and Context so that it can't be called again
    // accidently
    if (ppClientCompletion)
    {
        *ppClientCompletion = NULL;
    }
    if (ppContext)
    {
        *ppContext = NULL;
    }

    // it is possible that the timer expiry routine has just run and the timer
    // has not been restarted, so check the refcount, it will be zero if the
    // timer was not restarted and 2 if the timer expiry is currently running.
    if (pTimerEntry->RefCount == 1)
    {
        // this allows the caller to call the client's completion routine with
        // the context value.
        if (ppClientCompletion)
        {
            *ppClientCompletion = pTimerEntry->ClientCompletion;
        }
        if (ppContext)
        {
            *ppContext = pTimerEntry->ClientContext;
        }

        pTimerEntry->ClientCompletion = NULL;

        if (!(pTimerEntry->Flags & TIMER_NOT_STARTED))
        {
            if (!CTEStopTimer((CTETimer *)&pTimerEntry->VxdTimer ))
            {
                //
                // It means the TimerExpiry routine is waiting to run,
                // so let it return this timer block to the free Q
                // Bug # 229535
                //
                // Before returning from here, we should do the cleanup since
                // the CompletionRoutine (if any) can result in some data
                // that is required for cleanup to be cleaned up (Bug # 398730)
                //
                if (TimeoutRoutine = (COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine)
                {
                    // call the completion routine so it can clean up its own buffers
                    // the routine that called this one will call the client's completion
                    // routine.  A NULL timerEntry value indicates to the routine that
                    // cleanup should be done.
            
                    pTimerEntry->TimeoutRoutine = NULL;
                    (VOID)(*TimeoutRoutine) (pTimerEntry->Context, pTimerEntry->Context2, NULL);
                }
                pTimerEntry->RefCount = 2;
                return (STATUS_SUCCESS);
            }
        }

        status = STATUS_SUCCESS;
        status = CleanupCTETimer(pTimerEntry);
    }
    else if (pTimerEntry->RefCount == 2)
    {
        // the timer expiry completion routines must set this routine to
        // null with the spin lock held to synchronize with this stop timer
        // routine.  Likewise that routine checks this value too, to synchronize
        // with this routine.
        //
        if (pTimerEntry->ClientCompletion)
        {
            // this allows the caller to call the client's completion routine with
            // the context value.
            if (ppClientCompletion)
            {
                *ppClientCompletion = pTimerEntry->ClientCompletion;
            }
            if (ppContext)
            {
                *ppContext = pTimerEntry->ClientContext;
            }
            // so that the timer completion routine cannot also call the client
            // completion routine.
            pTimerEntry->ClientCompletion = NULL;

        }

        // signal the TimerExpiry routine that the timer has been cancelled
        //
        pTimerEntry->RefCount++;
        status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    return(status);
}


//----------------------------------------------------------------------------
VOID
TimerExpiry(
#ifndef VXD
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
#else
    IN  CTEEvent * pCTEEvent,
    IN  PVOID   DeferredContext
#endif
    )
/*++

Routine Description:

    This routine is the timer expiry completion routine.  It is called by the
    kernel when the timer expires.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tTIMERQENTRY    *pTimerEntry;
    CTELockHandle   OldIrq1;

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    // get the timer Q list entry from the context passed in
    pTimerEntry = (tTIMERQENTRY *)DeferredContext;

    if (pTimerEntry->RefCount == 0)
    {
        // the timer has been cancelled already!
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }
    else if (pTimerEntry->RefCount >= 2)    // Bug #: 229535
    {
        // the timer has been cancelled already!
        // Bug # 324655
        // If the Timer has been cancelled, we still need to do cleanup,
        // so do not NULL the TimeoutRoutine!
        //
//        pTimerEntry->TimeoutRoutine = NULL;
        ASSERT ((pTimerEntry->RefCount == 2) || (pTimerEntry->TimeoutRoutine == NULL));
        CleanupCTETimer (pTimerEntry);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }

    // increment the reference count because we are handling a timer completion
    // now
    pTimerEntry->RefCount++;

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    // call the completion routine passing the context value
    pTimerEntry->Flags &= ~TIMER_RESTART;   // incase the clients wants to restart the timer
    (*(COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine)(
                pTimerEntry->Context,
                pTimerEntry->Context2,
                pTimerEntry);

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    pTimerEntry->RefCount--;
    if (pTimerEntry->Flags & TIMER_RESTART)
    {
        if (pTimerEntry->RefCount == 2)
        {
            // the timer was stopped during the expiry processing, so call the
            // deference routine
            //
            CleanupCTETimer(pTimerEntry);
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            return;
        }
        else
        {
            CTEStartTimer (&pTimerEntry->VxdTimer,
                           pTimerEntry->DeltaTime,
                           (CTEEventRtn)TimerExpiry,
                           (PVOID)pTimerEntry);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }
    else
    {
        // move to the free list after setting the reference count to zero
        // since this timer block is no longer active.
        //
        pTimerEntry->TimeoutRoutine = NULL;
        CleanupCTETimer (pTimerEntry);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
}

//----------------------------------------------------------------------------
VOID
ExpireTimer(
    IN  tTIMERQENTRY    *pTimerEntry,
    IN  CTELockHandle   *OldIrq1
    )
/*++

Routine Description:

    This routine causes the timer to be stopped (if it hasn't already)
    and if successful, calls the Completion routine.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    //
    // Reset the Number of retries
    //
    pTimerEntry->Retries = 1;

    //
    // RefCount == 0    =>  Timer was stopped, but not restarted
    // RefCount == 1    =>  Timer is still running                  *
    // RefCount == 2    =>  TimerExpiry is currently running
    //
    if ((pTimerEntry->RefCount == 1) &&
        (!(pTimerEntry->Flags & TIMER_NOT_STARTED)) &&
        (CTEStopTimer( (CTETimer *)&pTimerEntry->VxdTimer)))
    {
        // increment the reference count because we are handling a timer completion
        // now
        pTimerEntry->RefCount++;

        CTESpinFree(&NbtConfig.JointLock, *OldIrq1);

        // call the completion routine passing the context value
        pTimerEntry->Flags &= ~TIMER_RESTART;   // incase the clients wants to restart the timer
        (*(COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine) (pTimerEntry->Context,
                                                           pTimerEntry->Context2,
                                                           pTimerEntry);

        CTESpinLock(&NbtConfig.JointLock, *OldIrq1);

        pTimerEntry->RefCount--;
        if (pTimerEntry->Flags & TIMER_RESTART)
        {
            if (pTimerEntry->RefCount == 2)
            {
                // the timer was stopped during the expiry processing, so call the
                // deference routine
                //
                CleanupCTETimer(pTimerEntry);
            }
            else
            {
                CTEStartTimer(&pTimerEntry->VxdTimer,
                               pTimerEntry->DeltaTime,
                               (CTEEventRtn)TimerExpiry,
                               (PVOID)pTimerEntry);
            }
        }
        else
        {
            // move to the free list after setting the reference count to zero
            // since this tierm block is no longer active.
            //
            pTimerEntry->TimeoutRoutine = NULL;
            CleanupCTETimer (pTimerEntry);
        }
    }

    CTESpinFree(&NbtConfig.JointLock, *OldIrq1);
}



//----------------------------------------------------------------------------
//
// Wakeup Timer routines
//
//----------------------------------------------------------------------------


VOID
WakeupTimerExpiry(
    PVOID           DeferredContext,
    ULONG           LowTime,
    LONG            HighTime
    )
{
    BOOLEAN         fAttached = FALSE;
    CTELockHandle   OldIrq;
    tTIMERQENTRY    *pTimerEntry = (tTIMERQENTRY *)DeferredContext;

    //
    // Call the TimerExpiry function while holding the NbtConfig.Resource
    //
    CTEExAcquireResourceExclusive (&NbtConfig.Resource,TRUE);
    if (pTimerEntry->RefCount > 1)
    {
        //
        // The timer is waiting to be cleaned up on a Worker thread,
        // so let it cleanup!
        //
        CTEExReleaseResource (&NbtConfig.Resource);
        return;
    }

    //
    // The Timeout routine has to ensure that it cleans up
    // properly since this pTimerEntry + handle will not be valid
    // at the end of this routine!
    //
    (*(COMPLETIONROUTINE) pTimerEntry->TimeoutRoutine) (pTimerEntry->Context,
                                                        pTimerEntry->Context2,
                                                        pTimerEntry);

    //
    // Close the timer handle
    //
    CTEAttachFsp(&fAttached, REF_FSP_WAKEUP_TIMER_EXPIRY);
    //
    // The Expiry routine should always be called in the context
    // of the system process
    //
    ASSERT (fAttached == FALSE);
    ZwClose (pTimerEntry->WakeupTimerHandle);
    CTEDetachFsp(fAttached, REF_FSP_WAKEUP_TIMER_EXPIRY);
    CTEExReleaseResource (&NbtConfig.Resource);

    ReturnTimerToFreeQ (pTimerEntry, FALSE);
}


//----------------------------------------------------------------------------
VOID
DelayedNbtStopWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *Unused3
    )
/*++
Routine Description:

    This Routine stops a timer.
    This function has to be called after ensuring that the TimerExpiry has not
    yet cleaned up (while holding the NbtConfig.Resource)
    The NbtConfig.Resource has to be held while this routine is called

Arguments:

    Timer       - Timer structure

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/
{
    NTSTATUS        Status;
    BOOLEAN         CurrentState = FALSE;
    BOOLEAN         fAttached = FALSE;
    tTIMERQENTRY    *pTimerEntry = (tTIMERQENTRY *) pClientContext;

    CTEPagedCode();

    ASSERT (pTimerEntry->fIsWakeupTimer);

    CTEAttachFsp(&fAttached, REF_FSP_STOP_WAKEUP_TIMER);
    Status = ZwCancelTimer (pTimerEntry->WakeupTimerHandle, &CurrentState);
    ZwClose (pTimerEntry->WakeupTimerHandle);
    CTEDetachFsp(fAttached, REF_FSP_STOP_WAKEUP_TIMER);

    ReturnTimerToFreeQ (pTimerEntry, FALSE);

    return;
}


//----------------------------------------------------------------------------
VOID
DelayedNbtStartWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    )
/*++

Routine Description:

    This routine starts a Wakeup timer.
    NbtConfig.Resource may be held on entry into this routine!

Arguments:

    The value passed in is in milliseconds - must be converted to 100ns
    so multiply to 10,000
Return Value:

    The function value is the status of the operation.


--*/
{
    NTSTATUS            Status = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    BOOLEAN             fAttached = FALSE;
    LARGE_INTEGER       Time;
    tTIMERQENTRY        *pTimerEntry;
    CTELockHandle       OldIrq;
    ULONG               TimerInterval = 0;
    ULONG               MilliSecsLeftInTtl = 0;
    LIST_ENTRY          *pEntry;
    LIST_ENTRY          *pHead;
    tDEVICECONTEXT      *pDeviceContext;
    BOOLEAN             fValidDevice = FALSE;

    CTEAttachFsp(&fAttached, REF_FSP_START_WAKEUP_TIMER);
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    ASSERT (!NbtConfig.pWakeupRefreshTimer);

    //  
    // Verify that at least 1 WOL-enabled device has an Ip + Wins address!
    //
    pHead = pEntry = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContext = CONTAINING_RECORD (pEntry,tDEVICECONTEXT,Linkage);
        if ((pDeviceContext->WOLProperties & NDIS_DEVICE_WAKE_UP_ENABLE) &&
            (pDeviceContext->IpAddress) &&
            (pDeviceContext->lNameServerAddress != LOOP_BACK))
        {
            fValidDevice = TRUE;
            break;
        }
    }

    if ((NbtConfig.Unloading) ||                                    // Problem!!!
        (!fValidDevice) ||                                          // No valid device ?
        !(NbtConfig.GlobalRefreshState & NBT_G_REFRESH_SLEEPING))   // check if request was cancelled!
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        KdPrint (("Nbt.NbtStartWakeupTimer: FAIL: Either: Unloading=<%x>, fValidDevice=<%x>, RefreshState=<%x>\n",
            NbtConfig.Unloading, fValidDevice, NbtConfig.GlobalRefreshState));
    }
    else if (!NT_SUCCESS (Status = GetTimerEntry (&pTimerEntry)))    // get a free timer block
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        KdPrint (("Nbt.NbtStartWakeupTimer: ERROR: GetTimerEntry returned <%x>\n", Status));
    }
    else
    {
        pTimerEntry->RefCount = 1;
        pTimerEntry->TimeoutRoutine = WakeupRefreshTimeout;
        pTimerEntry->Context = NULL;
        pTimerEntry->Context2 = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

#ifdef HDL_FIX
        InitializeObjectAttributes (&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
#else
        InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);
#endif  // HDL_FIX
        Status = ZwCreateTimer (&pTimerEntry->WakeupTimerHandle,
                                TIMER_ALL_ACCESS,
                                &ObjectAttributes,
                                NotificationTimer);

        if (NT_SUCCESS (Status))
        {
            //
            // Set the machine to Wakeup at 1/2 the time between now and Ttl
            // This should not be less than the configured MinimumRefreshSleepTimeout
            // (default = 6 hrs)
            //
            MilliSecsLeftInTtl = NbtConfig.MinimumTtl
                                 - (ULONG) (((ULONGLONG) NbtConfig.sTimeoutCount * NbtConfig.MinimumTtl)
                                            / NbtConfig.RefreshDivisor);

            if ((MilliSecsLeftInTtl/2) < NbtConfig.MinimumRefreshSleepTimeout)
            {
                TimerInterval = NbtConfig.MinimumRefreshSleepTimeout;
            }
            else
            {
                TimerInterval = MilliSecsLeftInTtl/2;
            }
            pTimerEntry->DeltaTime = TimerInterval;

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.DelayedNbtStartWakeupTimer: TimerInterval=<%d:%d> (h:m), Currently: <%d/%d>\n",
                    TimerInterval/(3600000), ((TimerInterval/60000)%60),
                    NbtConfig.sTimeoutCount, NbtConfig.RefreshDivisor));

            //
            // convert to 100 ns units by multiplying by 10,000
            //
            Time.QuadPart = UInt32x32To64(pTimerEntry->DeltaTime,(LONG)MILLISEC_TO_100NS);
            Time.QuadPart = -(Time.QuadPart);   // to make a delta time, negate the time
            pTimerEntry->fIsWakeupTimer = TRUE;
            ASSERT(Time.QuadPart < 0);
    
            Status = ZwSetTimer(pTimerEntry->WakeupTimerHandle,
                                &Time,
                                (PTIMER_APC_ROUTINE) WakeupTimerExpiry,
                                pTimerEntry,
                                TRUE,
                                0,
                                NULL);
    
            if (!NT_SUCCESS (Status))
            {
                KdPrint (("Nbt.NbtStartWakeupTimer: ERROR: ZwSetTimer returned <%x>, TimerHandle=<%x>\n",
                    Status, pTimerEntry->WakeupTimerHandle));
                ZwClose (pTimerEntry->WakeupTimerHandle);
            }
        }
        else
        {
            KdPrint (("Nbt.NbtStartWakeupTimer: ERROR: ZwCreateTimer returned <%x>\n", Status));
        }

        if (NT_SUCCESS (Status))
        {
            NbtConfig.pWakeupRefreshTimer = pTimerEntry;
        }
        else
        {
            ReturnTimerToFreeQ (pTimerEntry, FALSE);
        }
    }

    CTEExReleaseResource(&NbtConfig.Resource);
    CTEDetachFsp(fAttached, REF_FSP_START_WAKEUP_TIMER);

    KeSetEvent (&NbtConfig.WakeupTimerStartedEvent, 0, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\udpsend.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Udpsend.c

Abstract:


    This file handles building udp(and Tcp) requests, formated to the Tdi specification
    to pass to Tdiout.  Tdiout formats the request in an Os specific manner and
    passes it on to the transport.

    This file handles name service type functions such as query name or
    register name, datagram sends.  It also handles building Tcp packets.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/


#include "precomp.h"   // procedure headings
#include <ipinfo.h>


VOID
SessionRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);
VOID
NDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    );

//----------------------------------------------------------------------------
NTSTATUS
UdpSendNSBcast(
    IN tNAMEADDR             *pNameAddr,
    IN PCHAR                 pScope,
    IN tDGRAM_SEND_TRACKING  *pTrackerRequest,
    IN PVOID                 pTimeoutRoutine,
    IN PVOID                 pClientContext,
    IN PVOID                 pClientCompletion,
    IN ULONG                 Retries,
    IN ULONG                 Timeout,
    IN enum eNSTYPE          eNsType,
	IN BOOL					 SendFlag
    )
/*++

Routine Description:

    This routine sends a name registration or a name query
    as a broadcast on the subnet or directed to the name server.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    tNAMEHDR                    *pNameHdr;
    ULONG                       uLength;
    CTELockHandle               OldIrq;
    ULONG   UNALIGNED           *pHdrIpAddress;
    ULONG                       IpAddress;
    USHORT                      Port;
    USHORT                      NameType;
    tDGRAM_SEND_TRACKING        *pTrackerDgram;
    tTIMERQENTRY                *pTimerQEntry;
    PFILE_OBJECT                pFileObject;
    tDEVICECONTEXT              *pDeviceContext = pTrackerRequest->pDeviceContext;
    COMPLETIONCLIENT            pOldCompletion;
    PVOID                       pOldContext;


    if (pNameAddr->NameTypeState & (NAMETYPE_GROUP | NAMETYPE_INET_GROUP))
    {
        NameType = NBT_GROUP;
    }
    else
    {
        NameType = NBT_UNIQUE;
    }

    // build the correct type of pdu depending on the request type

    status = GetTracker (&pTrackerDgram, NBT_TRACKER_SEND_NSBCAST);
    if (!NT_SUCCESS(status))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pHdrIpAddress = (ULONG UNALIGNED *)CreatePdu(pNameAddr->Name,
                                                 pScope,
                                                 0L,     // we don't know the IP address yet
                                                 NameType,
                                                 eNsType,
                                                 (PVOID)&pNameHdr,
                                                 &uLength,
                                                 pTrackerRequest);

    if (!pHdrIpAddress)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:Failed to Create Pdu to send to WINS PduType= %X\n", eNsType));

        FreeTracker (pTrackerDgram, RELINK_TRACKER);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // change the dgram header for name refreshes
    //
    if (eNsType == eNAME_REFRESH)
    {
        pNameHdr->OpCodeFlags = NbtConfig.OpRefresh;
    }
    else
    if (   (eNsType == eNAME_QUERY)
#ifdef VXD
        || (eNsType == eDNS_NAME_QUERY)
#endif
       )
    {
        pHdrIpAddress = NULL;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);


    // fill in the Datagram hdr info in the tracker structure.
    // There is never a client buffer to send.
    //
    // Set the fields here instead of after the timer is started
    // since they may be accessed by the Timer completion function
    //
    pTrackerRequest->pNameAddr          = pNameAddr;
    pTrackerRequest->TransactionId      = pNameHdr->TransactId; // save for response checks.
    pTrackerDgram->SendBuffer.pDgramHdr = NULL;                 // to catch erroneous free's

    pTrackerDgram->SendBuffer.pDgramHdr = pNameHdr;
    pTrackerDgram->SendBuffer.HdrLength = uLength;
    pTrackerDgram->SendBuffer.pBuffer   = NULL;
    pTrackerDgram->SendBuffer.Length    = 0;
    pTrackerDgram->pNameAddr            = pNameAddr;
    pTrackerDgram->pDeviceContext       = pDeviceContext;

    // start the timer now...We didn't start it before because it could
    // have expired during the dgram setup, perhaps before the Tracker was
    // fully setup.
    //
    if (Timeout)
    {
        //
        // Before we over-write the current pTimer field in pNameAddr below,
        // we need to check if there is any timer running, and if so, we will
        // have to stop it right now
        //
        while (pTimerQEntry = pNameAddr->pTimer)
        {
            pNameAddr->pTimer = NULL;
            status = StopTimer(pTimerQEntry, &pOldCompletion, &pOldContext);
            if (pOldCompletion)
            {
                CTESpinFree(&NbtConfig.JointLock, OldIrq);
                (*pOldCompletion) (pOldContext, STATUS_TIMEOUT);
                CTESpinLock(&NbtConfig.JointLock, OldIrq);
            }
        }

        status = StartTimer(pTimeoutRoutine,
                            Timeout,
                            (PVOID)pTrackerRequest,       // context value
                            NULL,
                            pClientContext,
                            pClientCompletion,
                            pDeviceContext,
                            &pTimerQEntry,
                            (USHORT)Retries,
                            TRUE);

        if (!NT_SUCCESS(status))
        {
            // we need to differentiate the timer failing versus lack
            // of resources
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            CTEMemFree(pNameHdr);

            FreeTracker(pTrackerDgram,RELINK_TRACKER);

            return(STATUS_INVALID_PARAMETER_6);
        }
        //
        // Cross link the nameaddr and the timer so we can stop the timer
        // when the name query response occurs
        //
        pTimerQEntry->pCacheEntry = pNameAddr;
        pNameAddr->pTimer = pTimerQEntry;
    }

    //
    // Check the Flag value in the tracker and see if we should do a broadcast
    // or a directed send to the name server
    //
    if (pTrackerRequest->Flags & NBT_BROADCAST)
    {
        //
        // set the broadcast bit in the header to be ON since this may be
        // an M or MS node that is changing to broadcast from directed sends.
        //
        ((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[3] |= FL_BROADCAST_BYTE;

        Port = NBT_NAMESERVICE_UDP_PORT;

        IpAddress = pDeviceContext->BroadcastAddress;
    }
    else
    {
        //
        // turn off the broadcast bit in the header since this may be
        // an M or MS node that is changing to directed sends from broadcasts.
        //
        ((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[3] &= ~FL_BROADCAST_BYTE;

        // check for a zero first byte in the name passed to the name server
        ASSERT(((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[12]);

        //
        // for Multihomed hosts, UNIQUE name registrations use a special new
        // code (0x0F) to tell the name server this is a multihomed name that
        // will have several ip addresses
        //
        if (NbtConfig.MultiHomed && ((eNsType == eNAME_REGISTRATION) && (NameType == NBT_UNIQUE)))
        {
            //
            // if it is a multihomed host, then use a new special registration opcode (0xF)
            //
            ((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[2] |= OP_REGISTER_MULTI;
        }

        Port = NbtConfig.NameServerPort;

           // name srvr, backup name srvr, dns srvr, backup dnr srvr:which one?

        if (pTrackerRequest->Flags & NBT_NAME_SERVER)
        {
            IpAddress = pDeviceContext->lNameServerAddress;
        }
#ifdef MULTIPLE_WINS
        //
        // IMPORTANT: Check for NAME_SERVER_OTHERS flag has to be before check
        // for NAME_SERVER_BACKUP flag, since both flags will be set when we
        // we are querying "other" servers
        //
        else if (pTrackerRequest->Flags & NBT_NAME_SERVER_OTHERS)  // Try "other" servers
        {
            if (0 == pTrackerRequest->NSOthersLeft)        // Do LOOP_BACK
            {
                IpAddress = LOOP_BACK;
            }
            else
            {
                IpAddress = pTrackerRequest->pDeviceContext->lOtherServers[pTrackerRequest->NSOthersIndex];
            }
        }
#endif
        else
#ifndef VXD
        {
            IpAddress = pDeviceContext->lBackupServer;
        }
#else
        if (pTrackerRequest->Flags & NBT_NAME_SERVER_BACKUP)
        {
            IpAddress = pDeviceContext->lBackupServer;
        }
        else
        if (pTrackerRequest->Flags & NBT_DNS_SERVER)
        {
            IpAddress = pDeviceContext->lDnsServerAddress;
            Port = NbtConfig.DnsServerPort;
        }
        else  // ----- if (pTrackerRequest->Flags & NBT_DNS_SERVER_BACKUP) ----
        {
            IpAddress = pDeviceContext->lDnsBackupServer;
            Port = NbtConfig.DnsServerPort;
        }
#endif


        //
        // is it is a send to WINS on this machine
        //
        if (pNameHdr->AnCount == (UCHAR)WINS_SIGNATURE)
        {
            //
            // on RAS links, we don't want to register with the local wins
            // but with the wins that RAS told us about.
            // (of course, if RAS didn't give us a wins address, at least
            // register with the local guy!)
            //
            if ((pDeviceContext->IpInterfaceFlags & IP_INTFC_FLAG_P2P) &&  // Check for PointToPoint
                (pDeviceContext->lNameServerAddress != LOOP_BACK))
            {
                // Don't do anything;
            }
            else
            {
                IpAddress = pDeviceContext->IpAddress;
            }
        }
    }

    ASSERT(pTrackerRequest->Flags);

    // each adapter has a different source Ip address for registrations
    // pHdrIpAddress will be NULL for NameQueries
    if (pHdrIpAddress)
    {
        // If the Source IP address is to be different from the device we are
        // sending the Datagram on, fill it in!
        if (pTrackerRequest->Flags & NBT_USE_UNIQUE_ADDR)
        {
            *pHdrIpAddress = htonl(pTrackerRequest->RemoteIpAddress);
        }
        else
        {
            *pHdrIpAddress = htonl(pDeviceContext->IpAddress);
        }
    }

    //
    // in the event that DHCP has just removed the IP address, use a null
    // FileObject to signal UdpSendDatagram not to do the send
    // Also, if the device has been destroyed, dont send anything.
    //
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    status = UdpSendDatagram(pTrackerDgram,
                             IpAddress,
                             NDgramSendCompleted,
                             pTrackerDgram,
                             Port,
                             (SendFlag ? NBT_NAME_SERVICE : 0));

    if (!NT_SUCCESS(status))
    {
        //
        // Since pTrackerDgram is associated only with the Datagram send,
        // it should be free'ed here only!
        //
        FreeTracker (pTrackerDgram, FREE_HDR | RELINK_TRACKER);
    }

    return(status);
}
//----------------------------------------------------------------------------
PVOID
CreatePdu(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  ULONG                   IpAddress,
    IN  USHORT                  NameType,
    IN  enum eNSTYPE            eNsType,
    OUT PVOID                   *pHdrs,
    OUT PULONG                  pLength,
    IN  tDGRAM_SEND_TRACKING    *pTrackerRequest
    )
/*++

Routine Description:

    This routine builds a registration pdu

Arguments:


Return Value:

    PULONG  - a ptr to the ip address in the pdu so it can be filled in later

--*/
{
    tNAMEHDR        *pNameHdr;
    ULONG           uLength;
    ULONG           uScopeSize;
    tGENERALRR      *pGeneral;
    CTELockHandle   OldIrq;


#ifdef VXD
    if ( (eNsType == eDNS_NAME_QUERY) || (eNsType == eDIRECT_DNS_NAME_QUERY) )
    {
        uScopeSize = domnamelen(pTrackerRequest->pchDomainName) + 1;   // +1 for len byte
        if (uScopeSize > 1)
        {
            uScopeSize++;        // for the null byte
        }
    }
    else
#endif
    uScopeSize = strlen(pScope) +1; // +1 for null too


    // size is size of the namehdr structure -1 for the NetbiosName[1]
    // + the 32 bytes for the half ascii name +
    // scope + size of the General RR structure
    uLength = sizeof(tNAMEHDR) - 1
                            + (NETBIOS_NAME_SIZE << 1)
                            + uScopeSize;

    if (eNsType == eNAME_QUERY)
    {
        uLength = uLength + sizeof(ULONG);
    }
#ifdef VXD
    // there is no half-ascii conversion in DNS.  we added 32 bytes above, but
    // we need only 16.  so, subtract 16.
    else if (eNsType == eDNS_NAME_QUERY)
    {
        uLength = uLength - NETBIOS_NAME_SIZE + sizeof(ULONG);
    }
	// This is a "raw" DNS name query.  Substitute raw string length of pName
	// for NETBIOS_NAME_SIZE.
    else if (eNsType == eDIRECT_DNS_NAME_QUERY)
    {
        uLength = uLength - (NETBIOS_NAME_SIZE << 1) + sizeof(ULONG) + strlen(pName) + 1;
    }
#endif
	else
	{
	    uLength += sizeof(tGENERALRR);
	}

    // Note that this memory must be deallocated when the send completes in
    // tdiout.DgramSendCompletion
    pNameHdr = NbtAllocMem((USHORT)uLength ,NBT_TAG('X'));

    if (!pNameHdr)
    {
        return(NULL);
    }

    CTEZeroMemory((PVOID)pNameHdr,uLength);

    //
    // for resends of the same name query or name registration, do not increment
    // the transaction id
    //
    if (pTrackerRequest->TransactionId)
    {
        pNameHdr->TransactId = pTrackerRequest->TransactionId;
    }
    else
    {
        pNameHdr->TransactId = htons(GetTransactId());
    }

    pNameHdr->QdCount = 1;
    pNameHdr->AnCount = 0;
    pNameHdr->NsCount = 0;


#ifdef VXD
    if ((eNsType != eDNS_NAME_QUERY)&&(eNsType != eDIRECT_DNS_NAME_QUERY))
    {
#endif
        // Convert the name to half ascii and copy!! ... adding the scope too
        pGeneral = (tGENERALRR *)ConvertToHalfAscii(
                        (PCHAR)&pNameHdr->NameRR.NameLength,
                        pName,
                        pScope,
                        uScopeSize);

        pGeneral->Question.QuestionTypeClass = htonl(QUEST_NBINTERNET);
#ifdef VXD
    }
#endif

    *pHdrs = (PVOID)pNameHdr;
    *pLength = uLength;

    switch (eNsType)

    {

#ifdef VXD
    case eDNS_NAME_QUERY:
    case eDIRECT_DNS_NAME_QUERY:

        // copy the netbios name ... adding the scope too
        pGeneral = (tGENERALRR *)DnsStoreName(
                        (PCHAR)&pNameHdr->NameRR.NameLength,
                        pName,
                        pTrackerRequest->pchDomainName,
                        eNsType);

        pGeneral->Question.QuestionTypeClass = htonl(QUEST_DNSINTERNET);

        pNameHdr->OpCodeFlags = (FL_RECURDESIRE);

        pNameHdr->ArCount = 0;

        // we just need to return something non-null to succeed.
        return((PULONG)pNameHdr);
#endif

    case eNAME_QUERY:

        if (NodeType & BNODE)
        {
            pNameHdr->OpCodeFlags = (FL_BROADCAST | FL_RECURDESIRE);
        }
        else
            pNameHdr->OpCodeFlags = (FL_RECURDESIRE);

        pNameHdr->ArCount = 0;

        // we just need to return something non-null to succeed.
        return((PULONG)pNameHdr);
        break;

    case eNAME_REGISTRATION_OVERWRITE:
    case eNAME_REFRESH:
    case eNAME_REGISTRATION:
        //
        // The broadcast bit is set in UdpSendNSBcast so we don't
        // need to set it here. - just set the op code, since the broadcast
        // bit is a function of whether we are talking to the nameserver or doing
        // a broadcast.  This code handles the multi-homed case with a new
        // opcode for registration, and that opcode is set in the routine that
        //
        // The final name registration in Broadcast is called an Overwrite request
        // and it does not have the FL_RECURSION Desired bit set.
        //
        if (eNsType == eNAME_REGISTRATION_OVERWRITE)
        {
            pNameHdr->OpCodeFlags = (OP_REGISTRATION);
        }
        else
        {
            pNameHdr->OpCodeFlags = (FL_RECURDESIRE | OP_REGISTRATION);
        }

        pGeneral->Ttl = htonl(DEFAULT_TTL);

        // *** NOTE: There is no BREAK here by DESIGN!!

    case eNAME_RELEASE:

        // this code sets the Broadcast bit based on the node type rather than the
        // type of send....UdpSendNSBcast, resets the code according to the type of
        // name, so this code may not need to set the Broadcast bit
        //
        if (eNsType == eNAME_RELEASE)
        {
            pNameHdr->OpCodeFlags = OP_RELEASE;
            //
            // TTL for release is zero
            //
            pGeneral->Ttl = 0;
        }

        pNameHdr->ArCount = 1;  // 1 additional resource record included
        //
        // If WINS is on the same machine adjust the PDU to be able to tell
        // WINS that this pdu came from the local machine
        //
#ifndef VXD
        if (pWinsInfo && (pTrackerRequest->Flags & NBT_NAME_SERVER))
        {
            pNameHdr->AnCount = (UCHAR)WINS_SIGNATURE;
        }
#endif

        pGeneral->RrName.uSizeLabel = PTR_TO_NAME;  // set top two bits to signify ptr

        // the offset ptr to the name added above
        pGeneral->RrName.pLabel[0] = sizeof(tNAMEHDR) - sizeof(tNETBIOS_NAME);
        pGeneral->RrTypeClass = htonl(QUEST_NBINTERNET);


        pGeneral->Length = htons(6);
        pGeneral->Flags = htons((USHORT)((NameType << 15) | NbtConfig.PduNodeType));
        pGeneral->IpAddress = htonl(IpAddress);

        break;
    }

    // return the ptr to the IP address so this can be filled in later if necessary
    return((PVOID)&pGeneral->IpAddress);
}


//----------------------------------------------------------------------------
VOID
NameDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    )
/*++

Routine Description:

    This routine frees the name service datagram that was allocated for
    this name query or name registration in UdpSendNsBcast.

Arguments:

    pContext = ptr to datagram header

Return Value:


--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTEMemFree(pTracker->SendBuffer.pDgramHdr);
    pTracker->SendBuffer.pDgramHdr = NULL;
    NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}
//----------------------------------------------------------------------------
VOID
NDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    )
/*++

Routine Description:

    This routine frees the name service datagram that was allocated for
    this name query or name registration in UdpSendNsBcast.

Arguments:

    pContext = ptr to datagram header

Return Value:


--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    FreeTracker(pTracker, FREE_HDR | RELINK_TRACKER);
}

//----------------------------------------------------------------------------
NTSTATUS
UdpSendResponse(
    IN  ULONG                   lNameSize,
    IN  tNAMEHDR   UNALIGNED    *pNameHdrIn,
    IN  tNAMEADDR               *pNameAddr,
    IN  PTDI_ADDRESS_IP         pDestIpAddress,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  ULONG                   Rcode,
    IN  enum eNSTYPE            NsType,
    IN  CTELockHandle           OldIrq
    )
/*++

Routine Description:

    This routine builds a Name Release/Registration/Query response pdu and
    sends it with the specified Rcode.

Arguments:

    lSize       - number of bytes in the name including scope in half ascii

Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    tNAMEHDR                    *pNameHdr;
    ULONG                       uLength;
    tDGRAM_SEND_TRACKING        *pTracker;
    tQUERYRESP                  *pQuery;
    ULONG                       ToCopy;
    LONG                        i;
    BOOLEAN                     RespondWithOneAddr = TRUE;
    ULONG                       MultiHomedSize = 0;
    ULONG                       in_addr;
    USHORT                      in_port;
    ULONG                       IpAddress = 0;
    USHORT                      NameType = 0;   // Assume we are Unique by default!
    BOOLEAN                     DoNonProxyCode = TRUE;

    in_addr = ntohl(pDestIpAddress->in_addr);
    in_port = ntohs(pDestIpAddress->sin_port);

    // a  multihomed node can have the SingleResponse registry value set so
    // that it never returns a list of ip addresses. This allows multihoming
    // in disjoint WINS server domains. - for name Query responses only
    //

    if ((NbtConfig.MultiHomed) && (!pNameAddr || pNameAddr->Verify != REMOTE_NAME) &&
        (!NbtConfig.SingleResponse) &&
        (NsType == eNAME_QUERY_RESPONSE))
    {
//        if (SrcIsNameServer(in_addr,in_port))
        {
            RespondWithOneAddr = FALSE;
            MultiHomedSize = (NbtConfig.AdapterCount-1)*sizeof(tADDSTRUCT);
        }
    }

    // size is size of the namehdr structure -1 for NetBiosName[1]
    // + the 32 bytes for the half ascii name + the Query response record
    // + any scope size (including the null on the end of the name)
    // ( part of the lNameSize) + the number of extra adapters * the size
    // of the address structure (multihomed case).
    uLength = sizeof(tNAMEHDR)
                            + sizeof(tQUERYRESP)
                            + lNameSize
                            - 1
                            + MultiHomedSize;

    // Note that this memory must be deallocated when the send completes in
    // tdiout.DgramSendCompletion
    pNameHdr = NbtAllocMem((USHORT)uLength ,NBT_TAG('Y'));
    if (!pNameHdr)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CTEZeroMemory((PVOID)pNameHdr,uLength);

    pNameHdr->QdCount = 0;
    pNameHdr->AnCount = 1;

    //
    // fill in the rest of the PDU explicitly
    //
    pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];

    pQuery->RrTypeClass = htonl(QUEST_NBINTERNET);
    pQuery->Ttl = 0;
    pQuery->Length = htons(sizeof(tADDSTRUCT));
    pQuery->Flags = htons((USHORT)(NbtConfig.PduNodeType));

    // set the name type to 1 if it is a group so we can shift the 1 to the 16th
    // bit position
    // pNameAddr may not be set if we are sending a -ve NameQuery response, in which case, the field
    // is never looked at, or if we are sending a release response, which holds sends only  
    // for a unique name, in which case we have already initialized the value to 0
    //
    if (pNameAddr != NULL)
    {
        NameType = (pNameAddr->NameTypeState & (NAMETYPE_GROUP | NAMETYPE_INET_GROUP)) ? 1 : 0;
    }
    pQuery->Flags = htons((USHORT)((NameType << 15) | NbtConfig.PduNodeType));

    // convert Rcode to network order
    Rcode = htons(Rcode);

    switch (NsType)
    {

    case eNAME_RELEASE:
    case eNAME_REGISTRATION_RESPONSE:

        // copy the source name and the 12 bytes preceeding it to complete the
        // response pdu
        //
        ToCopy = sizeof(tNAMEHDR) + lNameSize -1;
        CTEMemCopy((PVOID)pNameHdr,
                   (PVOID)pNameHdrIn,
                   ToCopy);

        if (NsType == eNAME_RELEASE)
        {
            // setup the fields in the response.
            pNameHdr->OpCodeFlags = (USHORT)(OP_RESPONSE | OP_RELEASE
                                    | FL_AUTHORITY
                                    | Rcode);

        }
        else
        {
            // setup the fields in the response.
            pNameHdr->OpCodeFlags = (USHORT)(OP_RESPONSE | OP_REGISTRATION |
                                    FL_RECURDESIRE | FL_RECURAVAIL | FL_AUTHORITY
                                    | Rcode);

        }

        // these two lines must be here because the memcopy above sets
        // them to wrong values.
        pNameHdr->QdCount = 0;
        pNameHdr->AnCount = 1;
        pNameHdr->ArCount = 0;
        pNameHdr->NsCount = 0;

        // this code will run in the proxy case where another node does a
        // registration of a unique name that conflicts with an internet
        // group name in the remote table.  There are never any internet group
        // names in the local table - at least if there are, they are flagged
        // as simple groups.
        //
        if (pNameAddr)
        {
            if (pNameAddr->NameTypeState & NAMETYPE_INET_GROUP)
            {
                if (pNameAddr->pLmhSvcGroupList)
                {
                    IpAddress = pNameAddr->pLmhSvcGroupList[0];
                }
                else
                {
                    IpAddress = 0;
                }
            }
            else
            {
                // an ipaddress of 0 and a group name means it is a local name
                // table entry, where the 0 ipaddress should be switched to the
                // ipaddress of this adapter.
                //
                if ((pNameAddr->IpAddress == 0) &&
                   (pNameAddr->NameTypeState & NAMETYPE_GROUP))
                {
                    IpAddress = pDeviceContext->IpAddress;
                }
                else
                {
                    IpAddress = pNameAddr->IpAddress;
                }
            }
        }
        else
        {
            IpAddress = 0;
        }
        break;

    case eNAME_QUERY_RESPONSE:

        pNameHdr->OpCodeFlags = ( OP_RESPONSE | FL_AUTHORITY | FL_RECURDESIRE );

        pNameHdr->TransactId = pNameHdrIn->TransactId;

        // add 1 for the name length byte on the front of the name - scope is already
        // included in lNameSize
        //
        CTEMemCopy(&pNameHdr->NameRR.NameLength, (PVOID)&pNameHdrIn->NameRR.NameLength, lNameSize+1);

        if (pNameAddr == NULL)
        {
            // this is a negative query response record since there is no
            // local name to be found
            //
            pNameHdr->OpCodeFlags |= htons(NAME_ERROR);
            pQuery->Length = 0;
            IpAddress = 0;
        }
        else
        {
            tDEVICECONTEXT  *pDevContext;
            PLIST_ENTRY     pHead;
            PLIST_ENTRY     pEntry;

            // do not send name query responses for names not registered on
            // this net card, unless it is the name server for that net
            // card requesting the name query, since for Multihomed nodes
            // when it registers a name, WINS will do a query, which may
            // come in on the other net card that the name is not active on
            // yet - so we want to respond to this sort of query. Do not do
            // this check for a proxy since it is responding for a name
            // in the remote name table and it is not bound to an adapter.
            //
            if (!(NodeType & PROXY) &&
                !(pNameAddr->AdapterMask & pDeviceContext->AdapterMask) &&
                (!((in_port == NbtConfig.NameServerPort) &&
                (pDeviceContext->lNameServerAddress == in_addr) ||
                (pDeviceContext->lBackupServer == in_addr))))
            {
                //
                // Only return an address to the requestor if the
                // name is registered on that adapter
                //
                CTEMemFree(pNameHdr);

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                return(STATUS_UNSUCCESSFUL);
            }

            pQuery->Ttl = htonl(DEFAULT_TTL);
            //
            // In case of PROXY, we send one IP address as response to an
            // internet group query. Note: there should not be any INET_GROUP
            // names in the local hash table, hence a non-proxy should not execute
            // this code
            //
#ifdef PROXY_NODE
            //
            // When the proxy responds, the source node will see that it is a
            // group name and convert it to a broadcast, so the Ip address doesn't
            // really matter since the sender will not use it.  Note that the
            // source node send may not actually reach any members of the
            // internet group since they may all be off the local subnet.
            //
            IF_PROXY(NodeType)
            {
                DoNonProxyCode = FALSE;

                if (pNameAddr->NameTypeState & (NAMETYPE_INET_GROUP))
                {
                    IpAddress = 0;
                    PickBestAddress (pNameAddr, pDeviceContext, &IpAddress);
                }
                else if (pNameAddr->Verify == LOCAL_NAME)
                {
                    //
                    // if this name is local and if this is a multihomed machine
                    // we should treat it like a regular multihomed machine, even
                    // though this is a Proxy node
                    //
                    DoNonProxyCode = TRUE;
                }
                else
                {
                    IpAddress = pNameAddr->IpAddress;
                }

                if (IpAddress == 0)
                {
                    // don't return 0, return the broadcast address
                    //
                    IpAddress = pDeviceContext->BroadcastAddress;
                }

            }

            if (DoNonProxyCode)
#endif
            {
                // the node could be multihomed, but we are saying, only
                // respond with one address when this flag is set.
                if (RespondWithOneAddr)
                {
                    // for multihomed hosts, SelectAdapter can be set to TRUE
                    //
                    if (NbtConfig.SelectAdapter)
                    {
                        CTESystemTime   TimeValue;
                        LONG            Index;
                        ULONG           Count=0;

                        // we are only going to return one address, but we
                        // can randomly select it from the available adapters
                        // Try to find a valid ip address 5 times.
                        //
                        IpAddress = 0;
                        while ((IpAddress == 0) && (Count < 5))
                        {
                            Count++;
                            CTEQuerySystemTime(TimeValue);
                            Index = RandomizeFromTime( TimeValue, NbtConfig.AdapterCount ) ;

                            pHead = &NbtConfig.DeviceContexts;
                            pEntry = pHead->Flink;

                            for (i = 0;i< Index;i++)
                                pEntry = pEntry->Flink;

                            pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                            IpAddress = pDevContext->IpAddress;
                        }

                        //
                        // if this adapter still has a null IpAddress then respond
                        // with the adapter the request came in on, since the
                        // other adapters could be idle RAS or waiting for a DHCP
                        // address just now...
                        //
                        if (IpAddress == 0)
                        {
                            IpAddress = pDeviceContext->IpAddress;
                        }
                    }
                    else
                    {
                        IpAddress = pDeviceContext->IpAddress;
                    }
                }
                else
                {
                    tADDSTRUCT      *pAddStruct;
                    USHORT          Flags;
                    ULONG           Count = 0;

                    // multihomed case - go through all the adapters making
                    // up a structure of all adapters that the name is
                    // registered against.  Enough memory was allocated up
                    // front to have the name registered against all adapeters
                    // on this node.
                    //
                    Flags = pQuery->Flags;

                    // set to zero so we don't try to set pQuery->IpAddress
                    // below
                    IpAddress = 0;

                    pAddStruct = (tADDSTRUCT *)&pQuery->Flags;
                    pHead = &NbtConfig.DeviceContexts;
                    pEntry = pHead->Flink;
                    while (pEntry != pHead)
                    {
                        pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);

                        //
                        // only pass back addresses registered on this adapter
                        // that are not null(i.e. not RAS adapters after a disconnect)
                        //
                        if ((pDevContext->AdapterMask & pNameAddr->AdapterMask) &&
                            (pDevContext->IpAddress))
                        {
                            pAddStruct->NbFlags = Flags;
                            pAddStruct->IpAddr = htonl(pDevContext->IpAddress);
                            Count++;
                            pAddStruct++;
                        }
                        pEntry = pEntry->Flink;

                    }
                    // re-adjust the length of the pdu if the name is not registered
                    // against all adapters...
                    //
                    if (Count != NbtConfig.AdapterCount)
                    {
                        uLength -= (NbtConfig.AdapterCount - Count)*sizeof(tADDSTRUCT);
                    }
                    pQuery->Length = (USHORT)htons(Count*sizeof(tADDSTRUCT));
                }
            }
        }
    }

    if (IpAddress)
    {
        pQuery->IpAddress = htonl(IpAddress);
    }

    // get a tracker structure, which has a SendInfo structure in it
    status = GetTracker(&pTracker, NBT_TRACKER_SEND_RESPONSE_DGRAM);
    if (!NT_SUCCESS(status))
    {
        CTEMemFree((PVOID)pNameHdr);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // fill in the connection information
    pTracker->SendBuffer.HdrLength  = uLength;
    pTracker->SendBuffer.pDgramHdr = (PVOID)pNameHdr;
    pTracker->SendBuffer.Length  = 0;
    pTracker->SendBuffer.pBuffer = NULL;
    pTracker->pDeviceContext = pDeviceContext;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    status = UdpSendDatagram (pTracker,
                              in_addr,
                              QueryRespDone,
                              pTracker,
                              in_port,
                              NBT_NAME_SERVICE);

    return(status);
}

//----------------------------------------------------------------------------
VOID
QueryRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles cleaning up various data blocks used in conjunction
    with the sending the Query response.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);
}

//----------------------------------------------------------------------------
NTSTATUS
UdpSendDatagram(
    IN  tDGRAM_SEND_TRACKING       *pDgramTracker,
    IN  ULONG                      IpAddress,
    IN  PVOID                      pCompletionRoutine,
    IN  PVOID                      CompletionContext,
    IN  USHORT                     Port,
    IN  ULONG                      Service
    )
/*++

Routine Description:

    This routine sends a datagram across the TDI to be sent by Udp.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    ULONG                       uSentSize;
    TDI_CONNECTION_INFORMATION  *pSendInfo;
    PTRANSPORT_ADDRESS          pTransportAddr;
    ULONG                       Length;
    PFILE_OBJECT                TransportFileObject = NULL;
    CTELockHandle               OldIrq;
    tDEVICECONTEXT              *pDeviceContext = NULL;
    tFILE_OBJECTS               *pFileObjectsContext;

    status = STATUS_SUCCESS;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (NBT_REFERENCE_DEVICE (pDgramTracker->pDeviceContext, REF_DEV_UDP_SEND, TRUE))
    {
        pDeviceContext = pDgramTracker->pDeviceContext; // Assigned => referenced!

        if ((pDgramTracker->pDeviceContext->IpAddress) &&
            (pFileObjectsContext = pDgramTracker->pDeviceContext->pFileObjects))
        {
            switch (Service)
            {
                case (NBT_NAME_SERVICE):
                    TransportFileObject = pDgramTracker->pDeviceContext->pFileObjects->pNameServerFileObject;
                    break;

                case (NBT_DATAGRAM_SERVICE):
                    TransportFileObject = pDgramTracker->pDeviceContext->pFileObjects->pDgramFileObject;
                    break;

                default:
                    ;
            }

            //
            // an address of 0 means do a broadcast.  When '1C' internet group
            // names are built either from the Lmhost file or from the network
            // the broadcast address is inserted in the list as 0.
            //
            if (IpAddress == 0)
            {
                IpAddress = pDgramTracker->pDeviceContext->BroadcastAddress;
            }

            // when there is no WINS server set in the registry we set the WINS
            // ip address to LOOP_BACK, so if it is set to that here, do not send
            // the datagram.  If There is no Ip Address then the Transport Handle
            // will be null and we do not do the send in that case either.
            //
            if (IpAddress == LOOP_BACK)
            {
                TransportFileObject = NULL ;
            }
        }

        //
        // Dereference the Device if the request is going to fail, or
        // there is no completion routine!
        //
        if ((!TransportFileObject) || (!pCompletionRoutine))
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_UDP_SEND, TRUE);
        }
    }

    if (!TransportFileObject)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        if (pCompletionRoutine)
        {
            (*(NBT_COMPLETION) pCompletionRoutine) (CompletionContext, STATUS_UNSUCCESSFUL, 0);
        }
        return(status);
    }

    pFileObjectsContext->RefCount++;        // Dereferenced after the Send has completed
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // the completion routine is setup to free the pDgramTracker memory block
    TdiRequest.Handle.AddressHandle = (PVOID)TransportFileObject;
    TdiRequest.RequestNotifyObject = pCompletionRoutine;
    TdiRequest.RequestContext = (PVOID)CompletionContext;

    // the send length is the client dgram length + the size of the dgram header
    Length = pDgramTracker->SendBuffer.HdrLength + pDgramTracker->SendBuffer.Length;

    // fill in the connection information
    pSendInfo = pDgramTracker->pSendInfo;
    pSendInfo->RemoteAddressLength = sizeof(TRANSPORT_ADDRESS) -1 + pNbtGlobConfig->SizeTransportAddress;

    // fill in the remote address
    pTransportAddr = (PTRANSPORT_ADDRESS)pSendInfo->RemoteAddress;
    pTransportAddr->TAAddressCount = 1;
    pTransportAddr->Address[0].AddressLength = pNbtGlobConfig->SizeTransportAddress;
    pTransportAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->sin_port = htons(Port);
    ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->in_addr  = htonl(IpAddress);

    status = TdiSendDatagram (&TdiRequest, pSendInfo, Length, &uSentSize, pDgramTracker);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (--pFileObjectsContext->RefCount == 0)
    {
        CTEQueueForNonDispProcessing(DelayedNbtCloseFileHandles,
                                     NULL,
                                     pFileObjectsContext,
                                     NULL,
                                     NULL,
                                     TRUE);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
TcpSessionStart(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  ULONG                      IpAddress,
    IN  tDEVICECONTEXT             *pDeviceContext,
    IN  PVOID                      pCompletionRoutine,
    IN  ULONG                      Port
    )
/*++

Routine Description:

    This routine sets up a tcp connection by passing a connect through TDI to
    TCP.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    TDI_CONNECTION_INFORMATION  *pSendInfo;
    PTRANSPORT_ADDRESS          pTransportAddr;
    tCONNECTELE                 *pConnEle;
    CTELockHandle               OldIrq;
    tLOWERCONNECTION            *pLowerConn;

    pSendInfo = pTracker->pSendInfo;

    // we need to pass the file handle of the connection to TCP.
    pConnEle = (tCONNECTELE *)pTracker->pConnEle;

    CTESpinLock(pConnEle,OldIrq);
    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        TdiRequest.Handle.AddressHandle = (PVOID)((tLOWERCONNECTION *)pConnEle->pLowerConnId)->pFileObject;

        // the completion routine is setup to free the pTracker memory block
        TdiRequest.RequestNotifyObject = pCompletionRoutine;
        TdiRequest.RequestContext = (PVOID)pTracker;

        // fill in the connection information
        pSendInfo->RemoteAddressLength = sizeof(TRANSPORT_ADDRESS) -1 + pNbtGlobConfig->SizeTransportAddress;

        pTransportAddr = (PTRANSPORT_ADDRESS)pSendInfo->RemoteAddress;

        // fill in the remote address
        pTransportAddr->TAAddressCount = 1;
        pTransportAddr->Address[0].AddressLength = pNbtGlobConfig->SizeTransportAddress;
        pTransportAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->sin_port = htons((USHORT)Port);
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->in_addr  = htonl(IpAddress);

        CTESpinFree(pConnEle,OldIrq);

        // pass through the TDI I/F on the bottom of NBT, to the transport
        // pass in the original irp from the client so that the client can
        // cancel it ok...rather than use one of NBT's irps
        //
        status = TdiConnect (&TdiRequest, (ULONG_PTR)pTracker->pTimeout, pSendInfo, pConnEle->pIrp);
    }
    else
    {
        CTESpinFree(pConnEle,OldIrq);
        //
        // Complete the request through the completion routine so it
        // cleans up correctly
        //
        (*(NBT_COMPLETION)pCompletionRoutine)( (PVOID)pTracker, STATUS_CANCELLED, 0L );
        status = STATUS_CANCELLED;
    }

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
TcpSendSessionResponse(
    IN  tLOWERCONNECTION           *pLowerConn,
    IN  ULONG                      lStatusCode,
    IN  ULONG                      lSessionStatus
    )
/*++

Routine Description:

    This routine sends a session PDU corresponding to the lStatusCode. This
    could be a KeepAlive, PositiveSessionResponse, NegativeSessionResponse or
    a Retarget (not implemented yet).  For the Keep Alive case the completion
    routine passed in is used rather than SessionRespDone, as is the case
    for all other messages.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    tDGRAM_SEND_TRACKING        *pTracker;
    tSESSIONERROR               *pSessionHdr;

    pSessionHdr = (tSESSIONERROR *)NbtAllocMem(sizeof(tSESSIONERROR),NBT_TAG('Z'));
    if (!pSessionHdr)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // get a tracker structure, which has a SendInfo structure in it
    status = GetTracker(&pTracker, NBT_TRACKER_SEND_RESPONSE_SESSION);
    if (NT_SUCCESS(status))
    {
        pTracker->SendBuffer.pDgramHdr = (PVOID)pSessionHdr;
        pTracker->SendBuffer.pBuffer = NULL;
        pTracker->SendBuffer.Length = 0;

        pSessionHdr->Flags = NBT_SESSION_FLAGS;
        pSessionHdr->Type = (UCHAR)lStatusCode;

        switch (lStatusCode)
        {
            case NBT_NEGATIVE_SESSION_RESPONSE:
                pTracker->SendBuffer.HdrLength = sizeof(tSESSIONERROR);
                // this length is one byte longer for the error code - different type used here
                pSessionHdr->Length = htons(1);    // one error code byte
                pSessionHdr->ErrorCode = (UCHAR)lSessionStatus;
                break;

            case NBT_POSITIVE_SESSION_RESPONSE:
                pTracker->SendBuffer.HdrLength = sizeof(tSESSIONHDR);
                pSessionHdr->Length = 0;        // no data following the length byte
                break;

        }

        status = TcpSendSession(pTracker,
                                pLowerConn,
                                SessionRespDone);
    }
    else
    {
        CTEMemFree((PVOID)pSessionHdr);
    }

    return(status);

}


//----------------------------------------------------------------------------
NTSTATUS
TcpSendSession(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  tLOWERCONNECTION           *pLowerConn,
    IN  PVOID                      pCompletionRoutine
    )
/*++

Routine Description:

    This routine sends a message on a tcp connection.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    ULONG                       lSentLength;

    // we need to pass the file handle of the connection to TCP.
    TdiRequest.Handle.AddressHandle = (PVOID)pLowerConn->pFileObject;

    // the completion routine is setup to free the pTracker memory block
    TdiRequest.RequestContext = (PVOID)pTracker;

    // this completion routine just puts the tracker back on its list and
    // frees the memory associated with the UserData buffer.
    TdiRequest.RequestNotifyObject = pCompletionRoutine;

    // pass through the TDI I/F on the bottom of NBT, to the transport
    status = TdiSend(
                &TdiRequest,
                0,                           // no send flags
                (ULONG)pTracker->SendBuffer.HdrLength +
                (ULONG)pTracker->SendBuffer.Length ,
                &lSentLength,
                &pTracker->SendBuffer,
                0);     // no send flags set

    return(status);

}

//----------------------------------------------------------------------------
VOID
SessionRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles cleaning up various data blocks used in conjunction
    sending a session response at session startup time.  If the session
    response was negative, then kill the connection.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);

}


//----------------------------------------------------------------------------
NTSTATUS
SendTcpDisconnect(
    IN  tLOWERCONNECTION  *pLowerConnId
    )
/*++
Routine Description

    This routine disconnects a TCP connection in a graceful manner which
    insures that any data still in the pipe gets to the other side. Mostly
    it calls TcpDisconnect which does the work. This routine just gets a
    tracker for the send.

Arguments:

    pLowerConnID    - ptr to the lower connection that has the file object in it

Return Values:
    NTSTATUS    - completion status

    VOID

--*/

{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;

    status = GetTracker(&pTracker, NBT_TRACKER_SEND_DISCONNECT);
    if (NT_SUCCESS(status))
    {
        pTracker->pConnEle = (PVOID)pLowerConnId;

        status = TcpDisconnect(pTracker,NULL,TDI_DISCONNECT_RELEASE,FALSE);
    }
    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
TcpDisconnect(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  PVOID                      Timeout,
    IN  ULONG                      Flags,
    IN  BOOLEAN                    Wait
    )
/*++
Routine Description

    This routine disconnects a TCP connection in a graceful manner which
    insures that any data still in the pipe gets to the other side.

Arguments:

    pTracker    - ptr to the DGRAM_TRACKER block

Return Values:
    NTSTATUS    - completion status

    VOID

--*/

{
    TDI_REQUEST             TdiRequest;
    NTSTATUS                status;

    // we need to pass the file handle of the connection to TCP.
    TdiRequest.Handle.AddressHandle =
       (PVOID)((tLOWERCONNECTION *)pTracker->pConnEle)->pFileObject;

    // the completion routine is setup to free the pTracker memory block
    TdiRequest.RequestContext = (PVOID)pTracker;

    // this completion routine just puts the tracker back on its list and
    // frees the memory associated with the UserData buffer.
    TdiRequest.RequestNotifyObject = DisconnectDone;
    pTracker->Flags = (USHORT)Flags;

    status = TdiDisconnect(&TdiRequest,
                  Timeout,
                  Flags,
                  pTracker->pSendInfo,
                  ((tLOWERCONNECTION *)pTracker->pConnEle)->pIrp,
                  Wait);


    return(status);

}

//----------------------------------------------------------------------------
VOID
DisconnectDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles cleaning up after a disconnect is sent to the transport.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;
    tLOWERCONNECTION        *pLowerConn;
    CTELockHandle           OldIrq;
    PCTE_IRP                pIrp;
    BOOLEAN                 CleanupLower = FALSE;
    NTSTATUS                DiscWaitStatus;
    tCONNECTELE             *pConnEle;
    PCTE_IRP                pIrpClose;
    tDEVICECONTEXT          *pDeviceContext = NULL;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pLowerConn = (tLOWERCONNECTION *)pTracker->pConnEle;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pLowerConn);

    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.DisconnectDone: Disconnect Irp has been returned...pLowerConn %X,state %X\n",
            pLowerConn,pLowerConn->State));
    //
    // if the state is disconnected, then a disconnect indication
    // has come from the transport.. . if still disconnecting,
    // then we have not had a disconnect indication yet, so
    // wait for the indication to go through DisconnectHndlrNotOs which
    // will do the cleanup.
    //

    //  Streams TCP always indicates before completing the disconnect request,
    //  so we always cleanup here for the Streams stack.
    //
    //
    //  If the disconnect was abortive, then there will not be a disconnect
    //  indication, so do the cleanup now.
    //
    if ((!StreamsStack) &&
        (NT_SUCCESS (status)) &&
        (pTracker->Flags == TDI_DISCONNECT_RELEASE) &&
        (pLowerConn->State == NBT_DISCONNECTING))
    {
        SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
    }
    else if (pLowerConn->State != NBT_IDLE)
    {
        //
        // change the state to idle so that the Disconnect handler will
        // not attempt to do anything with it if for some reason the transport
        // indicates a disconnect after this point.
        //
        ASSERT((pLowerConn->State == NBT_DISCONNECTED) || (pLowerConn->State == NBT_DISCONNECTING));
        SET_STATE_LOWER (pLowerConn, NBT_IDLE);

        CleanupLower = TRUE;
    }

    //
    // there may be a disconnect wait irp, so return that first if there
    // is one waiting around.
    //
    pConnEle = pLowerConn->pUpperConnection;
    if (pConnEle && pConnEle->pIrpClose)
    {
        pIrpClose = pConnEle->pIrpClose;
        CHECK_PTR(pConnEle);
        pConnEle->pIrpClose = NULL ;
        if (pConnEle->DiscFlag == TDI_DISCONNECT_ABORT)
        {
            DiscWaitStatus = STATUS_CONNECTION_RESET;
        }
        else
        {
            DiscWaitStatus = STATUS_GRACEFUL_DISCONNECT;
        }
    }
    else
    {
        pIrpClose = NULL;
    }

    //
    // This is the disconnect requesting Irp
    //
    if (pLowerConn->pIrp)
    {
        pIrp = pLowerConn->pIrp;
        pLowerConn->pIrp = NULL ;
    }
    else
    {
        pIrp = NULL;
    }

    CTESpinFreeAtDpc(pLowerConn);

    if (CleanupLower)
    {
        ASSERT(pLowerConn->RefCount > 1);

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }

        // this either puts the lower connection back on its free
        // queue if inbound, or closes the connection with the transport
        // if out bound. (it can't be done at dispatch level).
        //
        status = CTEQueueForNonDispProcessing( DelayedCleanupAfterDisconnect,
                                               NULL,
                                               pLowerConn,
                                               NULL,
                                               pDeviceContext,
                                               TRUE);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    FreeTracker(pTracker,RELINK_TRACKER);

    if (pIrpClose)
    {
        CTEIoComplete( pIrpClose, DiscWaitStatus, 0 ) ;
    }

    if (pIrp)
    {
        CTEIoComplete( pIrp, status, 0 ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\precomp.h ===
/*
 * stddef.h define offsetof without checking if it is already defined or not.
 * Prevent Windows Event Tracing from including stddef.h again.
 */
#include <stddef.h>

#include "nbtprocs.h"

#include <wmikm.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\tdiaddr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Tdihndlr.c

Abstract:

    This file contains code relating to manipulation of address objects
    that is specific to the NT operating system.  It creates address endpoints
    with the transport provider.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtTdiOpenAddress)
#pragma CTEMakePageable(PAGE, NbtTdiOpenControl)
#pragma CTEMakePageable(PAGE, SetEventHandler)
#pragma CTEMakePageable(PAGE, SubmitTdiRequest)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiOpenAddress (
    OUT PHANDLE             pHandle,
    OUT PDEVICE_OBJECT      *ppDeviceObject,
    OUT PFILE_OBJECT        *ppFileObject,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT               PortNumber,
    IN  ULONG               IpAddress,
    IN  ULONG               Flags
    )
/*++

Routine Description:

    Note: This synchronous call may take a number of seconds. It runs in
    the context of the caller.  The code Opens an Address object with the
    transport provider and then sets up event handlers for Receive,
    Disconnect, Datagrams and Errors.

    THIS ROUTINE MUST BE CALLED IN THE CONTEXT OF THE FSP (I.E.
    PROBABLY AN EXECUTIVE WORKER THREAD).

    The address data structures are found in tdi.h , but they are rather
    confusing since the definitions have been spread across several data types.
    This section shows the complete data type for Ip address:

    typedef struct
    {
        int     TA_AddressCount;
        struct _TA_ADDRESS
        {
            USHORT  AddressType;
            USHORT  AddressLength;
            struct _TDI_ADDRESS_IP
            {
                USHORT  sin_port;
                USHORT  in_addr;
                UCHAR   sin_zero[8];
            } TDI_ADDRESS_IP

        } TA_ADDRESS[AddressCount];

    } TRANSPORT_ADDRESS

    An EA buffer is allocated (for the IRP), with an EA name of "TransportAddress"
    and value is a structure of type TRANSPORT_ADDRESS.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{


    OBJECT_ATTRIBUTES           AddressAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    NTSTATUS                    status, locstatus;
    PWSTR                       pNameTcp=L"Tcp";
    PWSTR                       pNameUdp=L"Udp";
    UNICODE_STRING              ucDeviceName;
    PTRANSPORT_ADDRESS          pTransAddressEa;
    PTRANSPORT_ADDRESS          pTransAddr;
    TDI_ADDRESS_IP              IpAddr;
    BOOLEAN                     Attached = FALSE;
    PFILE_OBJECT                pFileObject;
    HANDLE                      FileHandle;
    ULONG                       i, NumAddresses, EaBufferSize;

    CTEPagedCode();
    *ppFileObject = NULL;
    *ppDeviceObject = NULL;
    // copy device name into the unicode string - either Udp or Tcp
    //
    if (Flags & TCP_FLAG)
    {
        status = CreateDeviceString(pNameTcp,&ucDeviceName);
    }
    else
    {
        status = CreateDeviceString(pNameUdp,&ucDeviceName);
    }

    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    NumAddresses = 1 + pDeviceContext->NumAdditionalIpAddresses;
    EaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                    sizeof(TRANSPORT_ADDRESS) +
                    NumAddresses*sizeof(TDI_ADDRESS_IP);

    EaBuffer = NbtAllocMem (EaBufferSize, NBT_TAG('j'));
    if (EaBuffer == NULL)
    {
        DbgPrint ("Nbt.NbtTdiOpenAddress: FAILed to allocate memory for Eabuffer");
        CTEMemFree(ucDeviceName.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // allocate Memory for the transport address
    //
    pTransAddr = NbtAllocMem (sizeof(TRANSPORT_ADDRESS)+NumAddresses*sizeof(TDI_ADDRESS_IP),NBT_TAG('k'));
    if (pTransAddr == NULL)
    {
        CTEMemFree(ucDeviceName.Buffer);
        CTEMemFree(EaBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = (USHORT)(sizeof(TRANSPORT_ADDRESS) -1 + NumAddresses*sizeof(TDI_ADDRESS_IP));
    RtlMoveMemory (EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength+1); // "TransportAddress"

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("EaValueLength = %d\n",EaBuffer->EaValueLength));

    // fill in the IP address and Port number
    //
    pTransAddressEa = (TRANSPORT_ADDRESS *)&EaBuffer->EaName[EaBuffer->EaNameLength+1];

#ifdef _NETBIOSLESS
    //
    // For message-mode, open the ANY address regardless of what is passed in
    // This gives us an adapter independent handle
    //
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        IpAddress = IP_ANY_ADDRESS;
    }
#endif

    IpAddr.sin_port = htons(PortNumber);    // put in network order
    IpAddr.in_addr = htonl(IpAddress);

    // zero fill the  last component of the IP address
    //
    RtlFillMemory((PVOID)&IpAddr.sin_zero, sizeof(IpAddr.sin_zero), 0);

    // copy the ip address to the end of the structure
    //
    RtlMoveMemory(pTransAddr->Address[0].Address, (CONST PVOID)&IpAddr, sizeof(IpAddr));
    pTransAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTransAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    for (i=0; i<pDeviceContext->NumAdditionalIpAddresses; i++)
    {
        IpAddr.sin_port = htons(PortNumber);    // put in network order
        IpAddr.in_addr = htonl(pDeviceContext->AdditionalIpAddresses[i]);

        // copy the ip address to the structure
        RtlMoveMemory(pTransAddr->Address[i+1].Address, (CONST PVOID)&IpAddr, sizeof(IpAddr));
        pTransAddr->Address[i+1].AddressLength = sizeof(TDI_ADDRESS_IP);
        pTransAddr->Address[i+1].AddressType = TDI_ADDRESS_TYPE_IP;
    }

    pTransAddr->TAAddressCount = NumAddresses;

    // copy the ip address to the end of the name in the EA structure
    //
    RtlMoveMemory((PVOID)pTransAddressEa,
                  (CONST PVOID)pTransAddr,
                  NumAddresses*sizeof(TDI_ADDRESS_IP) + sizeof(TRANSPORT_ADDRESS)-1);


    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("creating Address named %ws\n",ucDeviceName.Buffer));

#ifdef HDL_FIX
    InitializeObjectAttributes (&AddressAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
#else
    InitializeObjectAttributes (&AddressAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
#endif  // HDL_FIX

    status = ZwCreateFile (&FileHandle,
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           &AddressAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           (PortNumber)? 0: FILE_SHARE_READ | FILE_SHARE_WRITE, // bug 296639: allow sharing for port 0
                           FILE_OPEN_IF,
                           0,
                           (PVOID)EaBuffer,
                           sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                               EaBuffer->EaNameLength + 1 +
                               EaBuffer->EaValueLength);

    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t===><%x>\tNbtTdiOpenAddress->ZwCreateFile, Status = <%x>\n", FileHandle, status));

    CTEMemFree((PVOID)pTransAddr);
    CTEMemFree((PVOID)EaBuffer);
    CTEMemFree(ucDeviceName.Buffer);

    if (NT_SUCCESS(status))
    {
        // if the ZwCreate passed set the status to the IoStatus
        status = IoStatusBlock.Status;
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Nbt.NbtTdiOpenAddress:  Failed to Open the Address to the transport, status = %X\n",
                            status));

            return(status);
        }

        // dereference the file object to keep the device ptr around to avoid
        // this dereference at run time
        //
        status = ObReferenceObjectByHandle (FileHandle,
                                            (ULONG)0,
                                            0,
                                            KernelMode,
                                            (PVOID *)&pFileObject,
                                            NULL);

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  ++<%x>====><%x>\tNbtTdiOpenAddress->ObReferenceObjectByHandle, Status = <%x>\n", FileHandle, pFileObject, status));

        if (NT_SUCCESS(status))
        {
            // return the handle to the caller
            //
            *pHandle = FileHandle;
            //
            // return the parameter to the caller
            //
            *ppFileObject = pFileObject;
	        *ppDeviceObject = IoGetRelatedDeviceObject(*ppFileObject);

            status = SetEventHandler (*ppDeviceObject,
                                      *ppFileObject,
                                      TDI_EVENT_ERROR,
                                      (PVOID)TdiErrorHandler,
                                      (PVOID)pDeviceContext);

            if (NT_SUCCESS(status))
            {
                // if this is a TCP address being opened, then create different
                // event handlers for connections
                //
                if (Flags & TCP_FLAG)
                {
                    status = SetEventHandler (*ppDeviceObject,
                                              *ppFileObject,
                                              TDI_EVENT_RECEIVE,
                                              (PVOID)TdiReceiveHandler,
                                              (PVOID)pDeviceContext);

                    if (NT_SUCCESS(status))
                    {
                        status = SetEventHandler (*ppDeviceObject,
                                                  *ppFileObject,
                                                  TDI_EVENT_DISCONNECT,
                                                  (PVOID)TdiDisconnectHandler,
                                                  (PVOID)pDeviceContext);

                        if (NT_SUCCESS(status))
                        {
                            // only set a connect handler if the session flag is set.
                            // In this case the address being opened is the Netbios session
                            // port 139
                            //
                            if (Flags & SESSION_FLAG)
                            {
                                status = SetEventHandler (*ppDeviceObject,
                                                          *ppFileObject,
                                                          TDI_EVENT_CONNECT,
                                                          (PVOID)TdiConnectHandler,
                                                          (PVOID)pDeviceContext);

                                if (NT_SUCCESS(status))
                                {
                                     return(status);
                                }
                            }
                            else
                                return(status);
                        }
                    }
                }
                else
                {
                    // Datagram ports only need this event handler
#ifdef _NETBIOSLESS
                    if (PortNumber == pDeviceContext->DatagramPort)
#else
                    if (PortNumber == NBT_DATAGRAM_UDP_PORT)
#endif
                    {
                        // Datagram Udp Handler
                        status = SetEventHandler (*ppDeviceObject,
                                                  *ppFileObject,
                                                  TDI_EVENT_RECEIVE_DATAGRAM,
                                                  (PVOID)TdiRcvDatagramHandler,
                                                  (PVOID)pDeviceContext);
                        if (NT_SUCCESS(status))
                        {
                            return(status);
                        }
                    }
                    else
                    {
                        // Name Service Udp handler
                        status = SetEventHandler (*ppDeviceObject,
                                                  *ppFileObject,
                                                  TDI_EVENT_RECEIVE_DATAGRAM,
                                                  (PVOID)TdiRcvNameSrvHandler,
                                                  (PVOID)pDeviceContext);

                        if (NT_SUCCESS(status))
                        {
                            return(status);
                        }
                    }
                }

                //
                // ERROR Case
                //
                ObDereferenceObject(pFileObject);
                IF_DBG(NBT_DEBUG_HANDLES)
                    KdPrint (("\t  --<   ><====<%x>\tNbtTdiOpenAddress->ObDereferenceObject\n", pFileObject));

                locstatus = ZwClose(FileHandle);
                IF_DBG(NBT_DEBUG_HANDLES)
                    KdPrint (("\t<===<%x>\tNbtTdiOpenAddress1->ZwClose, status = <%x>\n", FileHandle, locstatus));

                return(status);
            }

        }
        else
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Failed Open Address (Dereference Object) status = %X\n", status));

            locstatus = ZwClose(FileHandle);
            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t<===<%x>\tNbtTdiOpenAddress2->ZwClose, status = <%x>\n", FileHandle, locstatus));
        }

    }
    else
    {
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.NbtTdiOpenAddress:  ZwCreateFile Failed, status = %X\n", status));
    }


    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiOpenControl (
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine opens a control object with the transport.  It is very similar
    to opening an address object, above.

Arguments:



Return Value:

    Status of the operation.

--*/
{
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status, locstatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PWSTR                       pName=L"Tcp";
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    UNICODE_STRING              DeviceName;
    BOOLEAN                     Attached = FALSE;


    CTEPagedCode();
    // copy device name into the unicode string
    Status = CreateDeviceString(pName,&DeviceName);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

#ifdef HDL_FIX
    InitializeObjectAttributes (&ObjectAttributes,
                                &DeviceName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
#else
    InitializeObjectAttributes (&ObjectAttributes,
                                &DeviceName,
                                0,
                                NULL,
                                NULL);
#endif  // HDL_FIX

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("Nbt.NbtTdiOpenControl: Tcp device to open = %ws\n", DeviceName.Buffer));

    EaBuffer = NULL;

    Status = ZwCreateFile ((PHANDLE)&pDeviceContext->hControl,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,     // object attributes.
                           &IoStatusBlock,        // returned status information.
                           NULL,                  // block size (unused).
                           FILE_ATTRIBUTE_NORMAL, // file attributes.
                           0,
                           FILE_CREATE,
                           0,                     // create options.
                           (PVOID)EaBuffer,       // EA buffer.
                           0); // Ea length


    CTEMemFree(DeviceName.Buffer);

    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t===><%x>\tNbtTdiOpenControl->ZwCreateFile, Status = <%x>\n", pDeviceContext->hControl, Status));

    if ( NT_SUCCESS( Status ))
    {
        // if the ZwCreate passed set the status to the IoStatus
        Status = IoStatusBlock.Status;

        if (!NT_SUCCESS(Status))
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Nbt:Failed to Open the control connection to the transport, status = %X\n",Status));

        }
        else
        {
            // get a reference to the file object and save it since we can't
            // dereference a file handle at DPC level so we do it now and keep
            // the ptr around for later.
            Status = ObReferenceObjectByHandle (pDeviceContext->hControl,
                                                0L,
                                                NULL,
                                                KernelMode,
                                                (PVOID *)&pDeviceContext->pControlFileObject,
                                                NULL);

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  ++<%x>====><%x>\tNbtTdiOpenControl->ObReferenceObjectByHandle, Status = <%x>\n", pDeviceContext->hControl, pDeviceContext->pControlFileObject, Status));

            if (!NT_SUCCESS(Status))
            {
                locstatus = ZwClose(pDeviceContext->hControl);
                IF_DBG(NBT_DEBUG_HANDLES)
                    KdPrint (("\t<===<%x>\tNbtTdiOpenControl->ZwClose, status = <%x>\n", pDeviceContext->hControl, locstatus));
                pDeviceContext->hControl = NULL;
            }
            else
            {
                pDeviceContext->pControlDeviceObject =
			       IoGetRelatedDeviceObject(pDeviceContext->pControlFileObject);
            }
        }

    }
    else
    {
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt:Failed to Open the control connection to the transport, status1 = %X\n", Status));

        // set control file object ptr to null so we know that we didnot open
        // the control point.
        //
        pDeviceContext->pControlFileObject = NULL;
    }

    return Status;

} /* NbtTdiOpenControl */


//----------------------------------------------------------------------------
NTSTATUS
NbtTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the NBT driver that it can proceed (i.e.
    to allow some code that is waiting on a "KeWaitForSingleObject" to
    proceeed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint( ("Nbt.NbtTdiCompletionRoutine: CompletionEvent: %X, Irp: %X, DeviceObject: %X\n",
                Context, Irp, DeviceObject));

    KeSetEvent((PKEVENT )Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

//----------------------------------------------------------------------------
NTSTATUS
SetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.
    IN PVOID Context - Supplies the context passed into the event handler when it runs

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    CTEPagedCode();
    Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE);

    if (Irp == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, Context);

    Status = SubmitTdiRequest(FileObject, Irp);

    IoFreeIrp(Irp);

    return Status;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtProcessIPRequest(
    IN ULONG        IOControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    )

/*++

Routine Description:

    This routine performs iIOCTL queries into IP

Arguments:

    IOControlCode   - Ioctl to be made into IP
    pInBuffer       - Buffer containing data to be passed into IP
    InBufferLen     - Length of Input Buffer data
    pOutBuffer      - Returned information
    pOutBufferLen   - Initial expected length of Output Buffer + final length

Return Value:

    NTSTATUS - Final status of the operation

--*/

{
    NTSTATUS                Status;
    HANDLE                  hIP;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          ucDeviceName;
    PWSTR                   pNameIP = L"IP";
    IO_STATUS_BLOCK         IoStatusBlock;
    UCHAR                   *pIPInfo = NULL;
    ULONG                   OutBufferLen = 0;
    BOOLEAN                 fAttached = FALSE;
    HANDLE                  Event = NULL;

    CTEPagedCode();

    ucDeviceName.Buffer = NULL;
    Status = CreateDeviceString (pNameIP, &ucDeviceName);
    if (!NT_SUCCESS (Status))
    {
        KdPrint (("Nbt.NbtProcessIPRequest: ERROR <%x> -- CreateDeviceString\n", Status));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    if (pOutBuffer)
    {
        ASSERT (pOutBufferLen);
        OutBufferLen = *pOutBufferLen;  // Save the initial buffer length
        *pOutBuffer = NULL;
        *pOutBufferLen = 0;     // Initialize the return parameter in case we fail below

        if (!OutBufferLen ||
            !(pIPInfo = NbtAllocMem (OutBufferLen, NBT_TAG2('a9'))))
        {
            if (ucDeviceName.Buffer)
            {
                CTEMemFree (ucDeviceName.Buffer);
            }
            KdPrint (("Nbt.NbtProcessIPRequest: ERROR <STATUS_INSUFFICIENT_RESOURCES>\n"));
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

#ifdef HDL_FIX
    InitializeObjectAttributes (&ObjectAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);
#else
    InitializeObjectAttributes (&ObjectAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
#endif  // HDL_FIX

    CTEAttachFsp(&fAttached, REF_FSP_PROCESS_IP_REQUEST);

    Status = ZwCreateFile (&hIP,
                           SYNCHRONIZE | GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN,
                           0,
                           NULL,
                           0);

    CTEMemFree(ucDeviceName.Buffer);

    //
    // If we succeeded above, let us also try to create the Event handle
    //
    if ((NT_SUCCESS (Status)) &&
        (!NT_SUCCESS (Status = ZwCreateEvent(&Event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE))))
    {
        ZwClose (hIP);
    }

    if (!NT_SUCCESS (Status))
    {
        CTEDetachFsp(fAttached, REF_FSP_PROCESS_IP_REQUEST);
        KdPrint (("Nbt.NbtProcessIPRequest: ERROR <%x> -- ZwCreate\n", Status));
        if (pIPInfo)
        {
            CTEMemFree (pIPInfo);
        }
        return (Status);
    }

    //
    // At this point, we have succeeded in creating the hIP and Event handles,
    // and possibly also the output buffer memory (pIPInfo)
    //
    do
    {
        Status = ZwDeviceIoControlFile(hIP,                 // g_hIPDriverHandle
                                       Event,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOControlCode,       // Ioctl
                                       pInBuffer,
                                       InBufferLen,
                                       pIPInfo,
                                       OutBufferLen);

        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (Event,  FALSE, NULL);
            ASSERT(Status == STATUS_SUCCESS);
        }

        Status = IoStatusBlock.Status;
        if (Status == STATUS_BUFFER_OVERFLOW)
        {
            if (!OutBufferLen)
            {
                KdPrint (("Nbt.NbtProcessIPRequest: <%x> => overflow when no data expected\n",IOControlCode));
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            CTEMemFree (pIPInfo);
            OutBufferLen *=2;
            if (NULL == (pIPInfo = NbtAllocMem (OutBufferLen, NBT_TAG2('b0'))))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    } while (Status == STATUS_BUFFER_OVERFLOW);

    ZwClose (Event);
    ZwClose (hIP);
    CTEDetachFsp(fAttached, REF_FSP_PROCESS_IP_REQUEST);

    if (NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtProcessIPRequest: Success, Ioctl=<%x>\n", IOControlCode));

        if ((pOutBuffer) && (pOutBufferLen))
        {
            *pOutBuffer = pIPInfo;
            *pOutBufferLen = OutBufferLen;
        }
        else if (pIPInfo)
        {
            CTEMemFree (pIPInfo);
        }
    }
    else
    {
        KdPrint(("Nbt.NbtProcessIPRequest: IOCTL <%x> FAILed <%x>\n", IOControlCode, Status));

        if (pIPInfo)
        {
            CTEMemFree (pIPInfo);
        }
    }

    return (Status);
}



#if FAST_DISP
//----------------------------------------------------------------------------
NTSTATUS
NbtQueryIpHandler(
    IN  PFILE_OBJECT    FileObject,
    IN  ULONG           IOControlCode,
    OUT PVOID           *EntryPoint
    )
/*++

Routine Description:

    This routine iIOCTL queries for fast send entry

Arguments:

    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN PLONG EntryPoint  - Holder of fast send address

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK iosb;

    CTEPagedCode();

    if (!(Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE)))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //Build IRP for sync io.

    Irp->MdlAddress = NULL;

    Irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    Irp->RequestorMode = KernelMode;
    Irp->PendingReturned = FALSE;

    Irp->UserIosb = &iosb;

    Irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    Irp->AssociatedIrp.SystemBuffer = NULL;
    Irp->UserBuffer = NULL;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;


    irpSp = IoGetNextIrpStackLocation( Irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = IoGetRelatedDeviceObject(FileObject);

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOControlCode;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = EntryPoint;

    // Now submit the Irp to know if tcp supports fast path

    Status = SubmitTdiRequest(FileObject, Irp);
    if (!NT_SUCCESS(Status))
    {
        *EntryPoint = NULL;
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.NbtQueryDirectSendEntry: Query failed status %x \n", Status));
    }

    Irp->UserIosb = NULL;
    IoFreeIrp(Irp);

    return Status;
}
#endif

//----------------------------------------------------------------------------
NTSTATUS
SubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT Event;
    NTSTATUS Status;


    CTEPagedCode();
    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    // set the address of the routine to be executed when the IRP
    // finishes.  This routine signals the event and allows the code
    // below to continue (i.e. KeWaitForSingleObject)
    //
    IoSetCompletionRoutine(Irp,
                (PIO_COMPLETION_ROUTINE)NbtTdiCompletionRoutine,
                (PVOID)&Event,
                TRUE, TRUE, TRUE);

    CHECK_COMPLETION(Irp);
    Status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.SubmitTdiRequest: Failed to Submit Tdi Request, status = %X\n",Status));
        return Status;
    }

    if (Status == STATUS_PENDING)
    {

        Status = KeWaitForSingleObject ((PVOID)&Event, // Object to wait on.
                                        Executive,  // Reason for waiting
                                        KernelMode, // Processor mode
                                        FALSE,      // Alertable
                                        NULL);      // Timeout
        ASSERT(Status == STATUS_SUCCESS);
        if (!NT_SUCCESS(Status))
        {
            IF_DBG(NBT_DEBUG_TDIADDR)
                KdPrint(("Nbt.SubmitTdiRequest: Failed on return from KeWaitForSingleObj, status = %X\n",
                    Status));
            return Status;
        }

        Status = Irp->IoStatus.Status;

        IF_DBG(NBT_DEBUG_TDIADDR)
            KdPrint(("Nbt.SubmitTdiRequest: Io Status from setting event = %X\n",Status));
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\tdicnct.c ===
//
//
//  NBTCONNCT.C
//
//  This file contains code relating to opening connections with the transport
//  provider.  The Code is NT specific.

#include "precomp.h"

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtTdiOpenConnection)
#pragma CTEMakePageable(PAGE, NbtTdiAssociateConnection)
#pragma CTEMakePageable(PAGE, NbtTdiCloseConnection)
#pragma CTEMakePageable(PAGE, CreateDeviceString)
#pragma CTEMakePageable(PAGE, NbtTdiCloseAddress)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiOpenConnection (
    IN tLOWERCONNECTION     *pLowerConn,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine opens a connection with the transport provider.

Arguments:

    pLowerConn - Pointer to where the handle to the Transport for this virtual
        connection should be stored.

    pNbtConfig - the name of the adapter to connect to is in this structure

Return Value:

    Status of the operation.

--*/
{
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    Status, Status1;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PWSTR                       pName=L"Tcp";
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    UNICODE_STRING              RelativeDeviceName = {0,0,NULL};
    PMDL                        pMdl;
    PVOID                       pBuffer;
    BOOLEAN                     Attached = FALSE;

    CTEPagedCode();
    // zero out the connection data structure
    CTEZeroMemory(pLowerConn,sizeof(tLOWERCONNECTION));
    SET_STATE_LOWER (pLowerConn, NBT_IDLE);
    pLowerConn->pDeviceContext = pDeviceContext;
    CTEInitLock(&pLowerConn->LockInfo.SpinLock);
#if DBG
    pLowerConn->LockInfo.LockNumber = LOWERCON_LOCK;
#endif
    pLowerConn->Verify = NBT_VERIFY_LOWERCONN;

    //
    // Allocate an MDL for the Indication buffer since we may need to buffer
    // up to 128 bytes
    //
    pBuffer = NbtAllocMem(NBT_INDICATE_BUFFER_SIZE,NBT_TAG('l'));
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pMdl = IoAllocateMdl(pBuffer,NBT_INDICATE_BUFFER_SIZE,FALSE,FALSE,NULL);

    if (pMdl)
    {

        MmBuildMdlForNonPagedPool(pMdl);

        pLowerConn->pIndicateMdl = pMdl;

#ifdef HDL_FIX
        InitializeObjectAttributes (&ObjectAttributes,
                                    &RelativeDeviceName,
                                    OBJ_KERNEL_HANDLE,
                                    pDeviceContext->hSession,   // Use a relative File Handle
                                    NULL);
#else
        InitializeObjectAttributes (&ObjectAttributes,
                                    &RelativeDeviceName,
                                    0,
                                    pDeviceContext->hSession,   // Use a relative File Handle
                                    NULL);
#endif  // HDL_FIX

        // Allocate memory for the address info to be passed to the transport
        EaBuffer = (PFILE_FULL_EA_INFORMATION)NbtAllocMem (
                        sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                        TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                        sizeof(CONNECTION_CONTEXT),NBT_TAG('m'));

        if (EaBuffer)
        {
            EaBuffer->NextEntryOffset = 0;
            EaBuffer->Flags = 0;
            EaBuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
            EaBuffer->EaValueLength = sizeof (CONNECTION_CONTEXT);

            // TdiConnectionContext is a macro that = "ConnectionContext" - so move
            // this text to EaName
            RtlMoveMemory( EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1 );

            // put the context value into the EaBuffer too - i.e. the value that the
            // transport returns with each indication on this connection
            RtlMoveMemory (
                (PVOID)&EaBuffer->EaName[EaBuffer->EaNameLength + 1],
                (CONST PVOID)&pLowerConn,
                sizeof (CONNECTION_CONTEXT));

            {

                Status = ZwCreateFile (&pLowerConn->FileHandle,
                                       GENERIC_READ | GENERIC_WRITE,
                                       &ObjectAttributes,     // object attributes.
                                       &IoStatusBlock,        // returned status information.
                                       NULL,                  // block size (unused).
                                       FILE_ATTRIBUTE_NORMAL, // file attributes.
                                       0,
                                       FILE_CREATE,
                                       0,                     // create options.
                                       (PVOID)EaBuffer,       // EA buffer.
                                       sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                                          TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                                          sizeof(CONNECTION_CONTEXT));
            }

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t===><%x>\tNbtTdiOpenConnection->ZwCreateFile, Status = <%x>\n", pLowerConn->FileHandle, Status));

            IF_DBG(NBT_DEBUG_TDICNCT)
                KdPrint( ("Nbt.NbtTdiOpenConnection: CreateFile Status:%X, IoStatus:%X\n", Status, IoStatusBlock.Status));

            CTEMemFree((PVOID)EaBuffer);

            if ( NT_SUCCESS( Status ))
            {

                // if the ZwCreate passed set the status to the IoStatus
                //
                Status = IoStatusBlock.Status;

                if (NT_SUCCESS(Status))
                {
                    // get a reference to the file object and save it since we can't
                    // dereference a file handle at DPC level so we do it now and keep
                    // the ptr around for later.
                    Status = ObReferenceObjectByHandle (pLowerConn->FileHandle,
                                                        0L,
                                                        NULL,
                                                        KernelMode,
                                                        (PVOID *)&pLowerConn->pFileObject,
                                                        NULL);

            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  ++<%x>====><%x>\tNbtTdiOpenConnection->ObReferenceObjectByHandle, Status = <%x>\n", pLowerConn->FileHandle, pLowerConn->pFileObject, Status));

                    if (NT_SUCCESS(Status))
                    {
#if FAST_DISP
                        // Go ahead and query transport for fast dispath path.
                        IF_DBG(NBT_DEBUG_TDICNCT)
                        KdPrint(("Nbt.NbtTdiOpenConnection: Querying for TCPSendData File object %x\n",pLowerConn->pFileObject ));

                        pLowerConn->FastSend = pDeviceContext->pFastSend;
#endif
                        return(Status);
                    }

                    Status1 = ZwClose(pLowerConn->FileHandle);
                    IF_DBG(NBT_DEBUG_HANDLES)
                        KdPrint (("\t<===<%x>\tNbtTdiOpenConnection->ZwClose, status = <%x>\n", pLowerConn->FileHandle, Status1));
                }

            }

        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }


        IoFreeMdl(pMdl);
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CTEMemFree(pBuffer);

    return Status;

} /* NbtTdiOpenConnection */

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiAssociateConnection(
    IN  PFILE_OBJECT        pFileObject,
    IN  HANDLE              Handle
    )
/*++

Routine Description:

    This routine associates an open connection with the address object.

Arguments:


    pFileObject - the connection file object
    Handle      - the address object to associate the connection with

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS        status;
    PIRP            pIrp;
    KEVENT          Event;
    BOOLEAN         Attached = FALSE;

    CTEPagedCode();

    KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

    pIrp = NTAllocateNbtIrp(IoGetRelatedDeviceObject(pFileObject));

    if (!pIrp)
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint(("Nbt.NbtTdiAssociateConnection: Failed to build internal device Irp\n"));
        return(STATUS_UNSUCCESSFUL);
    }

    TdiBuildAssociateAddress (pIrp,
                              pFileObject->DeviceObject,
                              pFileObject,
                              NbtTdiCompletionRoutine,
                              &Event,
                              Handle);

    status = SubmitTdiRequest(pFileObject,pIrp);
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint (("Nbt.NbtTdiAssociateConnection:  ERROR -- SubmitTdiRequest returned <%x>\n", status));
    }

    IoFreeIrp(pIrp);
    return status;
}
//----------------------------------------------------------------------------
NTSTATUS
CreateDeviceString(
    IN  PWSTR               AppendingString,
    IN OUT PUNICODE_STRING  pucDeviceName
    )
/*++

Routine Description:

    This routine creates a string name for the transport device such as
    "\Device\Streams\Tcp"

Arguments:


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS            status;
    ULONG               Len;
    PVOID               pBuffer;
    PWSTR               pTcpBindName = NbtConfig.pTcpBindName;

    CTEPagedCode();

    if (!pTcpBindName)
    {
        pTcpBindName = NBT_TCP_BIND_NAME;
    }

    // copy device name into the unicode string - either Udp or Tcp
    //
    Len = (wcslen(pTcpBindName) + wcslen(AppendingString) + 1) * sizeof(WCHAR);
    if (pBuffer = NbtAllocMem(Len,NBT_TAG('n')))
    {
        pucDeviceName->MaximumLength = (USHORT)Len;
        pucDeviceName->Length = 0;
        pucDeviceName->Buffer = pBuffer;

        // this puts \Device\Streams into the string
        //
        if ((NT_SUCCESS (status = RtlAppendUnicodeToString (pucDeviceName, pTcpBindName))) &&
            (NT_SUCCESS (status = RtlAppendUnicodeToString (pucDeviceName, AppendingString))))
        {
            return(status);
        }

        CTEMemFree(pBuffer);
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Error case -- cleanup!
    //
    pucDeviceName->MaximumLength = 0;
    pucDeviceName->Length = 0;
    pucDeviceName->Buffer = NULL;

    return(status);
}

//----------------------------------------------------------------------------

NTSTATUS
NbtTdiCloseConnection(
    IN tLOWERCONNECTION * pLowerConn
    )
/*++

Routine Description:

    This routine closes a TDI connection

Arguments:


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    BOOLEAN     Attached= FALSE;

    CTEPagedCode();
    ASSERT( pLowerConn != NULL ) ;

    CTEAttachFsp(&Attached, REF_FSP_CLOSE_CONNECTION);

    if (pLowerConn->FileHandle)
    {
        status = ZwClose(pLowerConn->FileHandle);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tNbtTdiCloseConnection->ZwClose, status = <%x>\n", pLowerConn->FileHandle, status));
        pLowerConn->FileHandle = NULL;
    }

#if DBG
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint(("Nbt.NbtTdiCloseConnection: Failed to close LowerConn FileHandle pLower %X, status %X\n",
                pLowerConn,status));
    }
#endif

    CTEDetachFsp(Attached, REF_FSP_CLOSE_CONNECTION);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtTdiCloseAddress(
    IN tLOWERCONNECTION * pLowerConn
    )
/*++

Routine Description:

    This routine closes a TDI address

Arguments:


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS    status;
    BOOLEAN     Attached= FALSE;

    CTEPagedCode();

    ASSERT( pLowerConn != NULL ) ;

    CTEAttachFsp(&Attached, REF_FSP_CLOSE_ADDRESS);

    status = ZwClose(pLowerConn->AddrFileHandle);
    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t<===<%x>\tNbtTdiCloseAddress->ZwClose, status = <%x>\n", pLowerConn->AddrFileHandle, status));
#if DBG
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDICNCT)
            KdPrint(("Nbt.NbtTdiCloseAddress: Failed to close Address FileHandle pLower %X,status %X\n",
                pLowerConn,status));
    }
#endif

    CTEDetachFsp(Attached, REF_FSP_CLOSE_ADDRESS);

    return(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\ntisol.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Ntisol.h

Abstract:


    This file contains the interface between the TDI interface on the top
    of NBT and the OS independent code.  It takes the parameters out of the
    irps and puts in into procedure calls for the OS independent code (which
    is mostly in name.c).


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

Notes:

    The Nbt routines have been modified to include an additional parameter, i.e,
    the transport type. This transport type is used primarily to distinguish the
    NETBIOS over TCP/IP implementation from the Messaging Over TCP/IP implementation.

    The primary difference between the two being that the later uses the NETBT framing
    without the associated NETBIOS name registartion/resolution. It primarily uses
    DNS for name resolution. All the names that are registered for the new transport
    are local names and are not defended on the network.

    The primary usage is in conjuntion with an extended NETBIOS address type defined
    in tdi.h. The NETBIOS name resolution/registration traffic occurs in two phases.
    The first phase contains all the broadcast traffic that ensues during NETBIOS
    name registration. Subsequently the NETBT implementation queries the remote
    adapter status to choose the appropriate called name. This approach results in
    additional traffic for querying the remote adapter status. The new address type
    defined in tdi.h enables the client of netbt to supply the name to be used in
    NETBT session setup. This avoids the network traffic for querying the adapter
    status.

    The original design which has not been fully implemented involved exposing two
    device objects from the NetBt driver -- the NetBt device object which would be
    the full implementation of NETBIOS over TCP/IP and the MoTcp device object which
    would be the implementation of Messaging over TCP/IP. The MoTcp device object
    would use the same port address as NetBt and use the same session setup protocol
    to talk to remote machines running old NetBt drivers and machines running new
    NetBt drivers.

    The transport type variations combined with the address type changes present us
    with four different cases which need to be handled -- the NetBt transport being
    presented with a TDI_ADDRESS_NETBIOS_EX structure, the NetBt transport being
    prsented with a TDI_ADDRESS_NETBIOS structure and the same two cases for the
    MoTcp transport.

--*/

#include "precomp.h"
#include "ntprocs.h"
#include <ipinfo.h>
#include <ntddtcp.h>    // for IOCTL_TCP_SET_INFORMATION_EX
#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#endif // RASAUTODIAL
#include <tcpinfo.h>
#include <tdiinfo.h>

#include "ntisol.tmh"

#if BACK_FILL
#define SESSION_HDR_SIZE   sizeof(tSESSIONHDR)
#endif

NTSTATUS
SendCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
NTSendCleanupConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  PVOID           pCompletionRoutine,
    IN  PVOID           Context,
    IN  PIRP            pIrp);

VOID
DpcSendSession(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );

NBT_WORK_ITEM_CONTEXT *
FindLmhSvcRequest(
    IN PDEVICE_OBJECT   DeviceContext,
    IN PIRP             pIrp,
    IN tLMHSVC_REQUESTS *pLmhRequest
    );

NTSTATUS
NbtCancelCancelRoutine(
    IN  PIRP            pIrp
    );

#ifdef RASAUTODIAL
extern ACD_DRIVER AcdDriverG;

BOOLEAN
NbtCancelPostConnect(
    IN PIRP pIrp
    );
#endif // RASAUTODIAL

NTSTATUS
NbtQueryGetAddressInfo(
    IN PIO_STACK_LOCATION   pIrpSp,
    OUT PVOID               *ppBuffer,
    OUT ULONG               *pSize
    );

VOID
NbtCancelConnect(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    );

VOID
NbtCancelReceive(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
GetIpAddrs(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp
    );

typedef struct
{
    struct _DeviceContext       *pDeviceContext;
    PIRP                        pClientIrp;
    PIRP                        pLocalIrp;
    PTA_NETBT_INTERNAL_ADDRESS  pTransportAddress;
    TDI_CONNECTION_INFORMATION  LocalConnectionInformation;
    BOOLEAN                     ProcessingDone;
    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pUnicodeAddress;   // First Readable buffer in the transport address list
    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pReturnBuffer;     // First writable buffer in the transport address list

    LONG                        CurrIndex, NumberOfAddresses;
    LONG                        TaAddressLength, RemainingAddressLength;
    PUCHAR                      pTaAddress;
} NBT_DELAYED_CONNECT_CONTEXT, *PNBT_DELAYED_CONNECT_CONTEXT;

extern POBJECT_TYPE *IoFileObjectType;

NTSTATUS
InitDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NTOpenControl)
#pragma CTEMakePageable(PAGE, NTOpenAddr)
#pragma CTEMakePageable(PAGE, NTCloseAddress)
#pragma CTEMakePageable(PAGE, NTOpenConnection)
#pragma CTEMakePageable(PAGE, NTAssocAddress)
#pragma CTEMakePageable(PAGE, NTCloseConnection)
#pragma CTEMakePageable(PAGE, NTSetSharedAccess)
#pragma CTEMakePageable(PAGE, NTCheckSharedAccess)
#pragma CTEMakePageable(PAGE, NTCleanUpConnection)
#pragma CTEMakePageable(PAGE, NTCleanUpAddress)
#pragma CTEMakePageable(PAGE, NTDisAssociateAddress)
#pragma CTEMakePageable(PAGE, NTListen)
#pragma CTEMakePageable(PAGE, DelayedNbtProcessConnect)
#pragma CTEMakePageable(PAGE, InitDelayedNbtProcessConnect)
#pragma CTEMakePageable(PAGE, DispatchIoctls)
#pragma CTEMakePageable(PAGE, NTSendDatagram)
#pragma CTEMakePageable(PAGE, NTSetInformation)
#pragma CTEMakePageable(PAGE, NTSetEventHandler)
//
// Should not be pageable since AFD can call us at raised Irql in case of AcceptEx.
//
// #pragma CTEMakePageable(PAGE, NTQueryInformation)
#endif
//*******************  Pageable Routine Declarations ****************

int check_unicode_string(IN PUNICODE_STRING str);

//----------------------------------------------------------------------------
NTSTATUS
NTOpenControl(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)
/*++
Routine Description:

    This Routine handles opening the control object, which represents the
    driver itself.  For example QueryInformation uses the control object
    as the destination of the Query message.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pIrpSp->FileObject->FsContext2 = (PVOID)(NBT_CONTROL_TYPE);

    // return a ptr the control endpoint
    pIrpSp->FileObject->FsContext = (PVOID)pNbtGlobConfig->pControlObj;

    //
    // the following call opens a control object with the transport below since
    // several of the query information calls are passed directly on to the
    // transport below.
    //
    if (!pDeviceContext->pControlFileObject)
    {
        status = NbtTdiOpenControl(pDeviceContext);
    }
    else
        status = STATUS_SUCCESS;


    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTOpenAddr(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea)
/*++
Routine Description:

    This Routine handles converting an Open Address Request from an IRP to
    a procedure call so that NbtOpenAddress can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    TDI_REQUEST                         Request;
    PVOID                               pSecurityDesc;
    TA_ADDRESS                          *pAddress;
    int                                 j;
    NTSTATUS                            status=STATUS_INVALID_ADDRESS_COMPONENT;
    ULONG                               BufferLength, MinBufferLength;
    TRANSPORT_ADDRESS UNALIGNED         *pTransportAddr; // structure containing counted array of TA_ADDRESS
    PTDI_ADDRESS_NETBIOS                pNetbiosAddress;
    PTDI_ADDRESS_NETBIOS_EX             pNetbiosExAddress;


    CTEPagedCode();

    // make up the Request data structure from the IRP info
    Request.Handle.AddressHandle = NULL;

    //
    // Verify Minimum Buffer length!
    // Bug#: 120683
    //
    BufferLength = ea->EaValueLength;
    if (BufferLength < sizeof(TA_NETBIOS_ADDRESS))
    {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NTOpenAddr[1]: ...Rejecting Open Address request -- BufferLength<%d> < Min<%d>\n",
                BufferLength, sizeof(TA_NETBIOS_ADDRESS)));
        NbtTrace(NBT_TRACE_LOCALNAMES, ("Rejecting Open Address request -- BufferLength<%d> < Min<%d>",
                BufferLength, sizeof(TA_NETBIOS_ADDRESS)));
        return (status);
    }
    MinBufferLength = FIELD_OFFSET(TRANSPORT_ADDRESS,Address);  // Set for Address[0]

    pTransportAddr = (PTRANSPORT_ADDRESS)&ea->EaName[ea->EaNameLength+1];
    pAddress = (TA_ADDRESS *) &pTransportAddr->Address[0]; // this includes the address type + the actual address

    //
    // The Transport Address information is packed as follows:
    //  Field:                              Length:
    //  ------                              -------
    //  TAAddressCount                  --> LONG
    //
    //      Address[0].AddressLength    --> USHORT
    //      Address[0].AddressType      --> USHORT
    //      Address[0].Address..        --> Address[0].AddressLength
    //
    //      Address[1].AddressLength    --> USHORT
    //      Address[1].AddressType      --> USHORT
    //      Address[1].Address..        --> Address[1].AddressLength
    //          :
    //


    // loop through the addresses passed in until ONE is successfully used
    // *TODO* do we need this loop or can we just assume the name is at the start of the address buffer...
    // *TODO* does this need to handle multiple names??
    for (j=0; j<pTransportAddr->TAAddressCount ;j++ )
    {
        //
        // We support only 2 address types:
        //
        if (pAddress->AddressType == TDI_ADDRESS_TYPE_NETBIOS)
        {
            pNetbiosAddress = (PTDI_ADDRESS_NETBIOS) pAddress->Address;

            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NTOpenAddr: ...Opening NETBIOS Address=<%-16.16s:%x>, Device=<%p>, pIrp=<%p>\n",
                    pNetbiosAddress->NetbiosName, pNetbiosAddress->NetbiosName[15], pDeviceContext, pIrp));

            if (pAddress->AddressLength != 0)
            {
                status = STATUS_SUCCESS;
                break;
            }

            ASSERT(0);      // AddressLength should not be 0!
        }
        else if (pAddress->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
        {
            //
            // In our test earlier we had verified Buffer space for only TDI_NETBIOS_ADDRESS,
            // not TDI_NETBIOS_EX_ADDRESS, so verify that now!
            //
            if (BufferLength < (MinBufferLength +
                                (sizeof(TA_NETBIOS_EX_ADDRESS)-FIELD_OFFSET(TRANSPORT_ADDRESS,Address))))
            {
                ASSERT(0);
                return (STATUS_INVALID_ADDRESS_COMPONENT);
            }

            pNetbiosExAddress = (PTDI_ADDRESS_NETBIOS_EX)pAddress->Address;
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NTOpenAddr: ...Opening NETBIOS_EX Address:Endpoint=<%16.16s:%x>:<%16.16s:%x>\n",
                    pNetbiosExAddress->NetbiosAddress.NetbiosName,
                    pNetbiosExAddress->NetbiosAddress.NetbiosName[15],
                    pNetbiosExAddress->EndpointName, pNetbiosExAddress->EndpointName[15]));

            if (pAddress->AddressLength != 0)
            {
                status = STATUS_SUCCESS;
                break;
            }

            ASSERT(0);      // AddressLength should not be 0!
        }

        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NTOpenAddr[2]: ...Rejecting Open Address request for AddressType=<%d>\n",
                pAddress->AddressType));

        //
        // Verify that we have enough Buffer space to read in next address
        // Bug#: 120683
        //
        MinBufferLength += pAddress->AddressLength + FIELD_OFFSET(TA_ADDRESS,Address);
        if (BufferLength < (MinBufferLength +
                            (sizeof(TA_NETBIOS_ADDRESS)-FIELD_OFFSET(TRANSPORT_ADDRESS,Address))))
        {
            return (status);
        }

        //
        // Set pAddress to point to the next address
        //
        pAddress = (TA_ADDRESS *) ((PUCHAR)pAddress
                                 + FIELD_OFFSET(TA_ADDRESS,Address)
                                 + pAddress->AddressLength);
    }

    if (status == STATUS_SUCCESS)       // We found a valid address type!
    {
        // call the non-NT specific function to open an address
        status = NbtOpenAddress(&Request,
                                pAddress,
                                pDeviceContext->IpAddress,
                                &pSecurityDesc,
                                pDeviceContext,
                                (PVOID)pIrp);
        if (status != STATUS_SUCCESS) {
            NbtTrace(NBT_TRACE_NAMESRV, ("NbtOpenAddress returns %!status!", status));
        }
    }

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTCloseAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles converting a Close Address Request from an IRP to
    a procedure call so that NbtCloseAddress can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                 Request;
    TDI_REQUEST_STATUS          RequestStatus;
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    tCLIENTELE                  *pClientEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pClientEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.NTCloseAddress: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtCloseAddress (&Request, &RequestStatus, pDeviceContext, (PVOID)pIrp);
    NbtTrace(NBT_TRACE_NAMESRV, ("NbtCloseAddress returns %!status! for ClientEle=%p", status, pClientEle));

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NTOpenConnection(
    IN  tDEVICECONTEXT              *pDeviceContext,
    IN  PIRP                        pIrp,
    IN  PFILE_FULL_EA_INFORMATION   ea)

/*++
Routine Description:

    This Routine handles converting an Open Connection Request from an IRP to
    a procedure call so that NbtOpenConnection can be called in an OS independent
    manner.  The connection must be associated with an address before it
    can be used, except for in inbound call where the client returns the
    connection ID in the accept.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                 Request;
    PIO_STACK_LOCATION          pIrpSp;
    CONNECTION_CONTEXT          ConnectionContext;
    NTSTATUS                    status;
    PFILE_OBJECT                pFileObject;
    ULONG                       BufferLength;
    tCONNECTELE                 *pConnEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // make up the Request data structure from the IRP info
    Request.Handle.ConnectionContext = NULL;

    //
    // Verify Minimum Buffer length!
    // Bug#: 120682
    //
    BufferLength = ea->EaValueLength;
    if (BufferLength < sizeof(CONNECTION_CONTEXT))
    {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NTOpenConnection: ERROR -- Open Connection request -- (BufferLength=%d < Min=%d)\n",
                BufferLength, sizeof(CONNECTION_CONTEXT)));
        ASSERT(0);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    // the connection context value is stored in the string just after the
    // name "connectionContext", and it is most likely unaligned, so just
    // copy it out.( 4 bytes of copying ).
    CTEMemCopy(&ConnectionContext,
               (CONNECTION_CONTEXT)&ea->EaName[ea->EaNameLength+1],
               sizeof(CONNECTION_CONTEXT));

    // call the non-NT specific function to open an address
    status = NbtOpenConnection (&Request, ConnectionContext, pDeviceContext);

    pFileObject = pIrpSp->FileObject;

    if (!NT_SUCCESS(status))
    {
        pFileObject->FsContext = NULL;
        NbtTrace(NBT_TRACE_OUTBOUND, ("NbtOpenConnection returns %!status!", status));
    }
    else if (Request.Handle.ConnectionContext)
    {

        // fill the IRP with successful completion information so we can
        // find the connection object given the fileObject later.
        pConnEle = pFileObject->FsContext = Request.Handle.ConnectionContext;
        if (!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION))
        {
            ASSERTMSG ("Nbt.NTOpenConnection: ERROR - Invalid Connection Handle\n", 0);
            return (STATUS_UNSUCCESSFUL);
        }
        pFileObject->FsContext2 = (PVOID)(NBT_CONNECTION_TYPE);
        pConnEle->pClientFileObject = pFileObject;
        NbtTrace(NBT_TRACE_OUTBOUND, ("New connection %p", pConnEle));

        status = STATUS_SUCCESS;
    }

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NTAssocAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles converting an Associate Address Request from an IRP to
    a procedure call so that NbtAssociateAddress can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                   Request;
    PIO_STACK_LOCATION            pIrpSp;
    PFILE_OBJECT                  fileObject;
    PTDI_REQUEST_KERNEL_ASSOCIATE parameters;   // holds address handle
    NTSTATUS                      status;
    tCONNECTELE                   *pConnEle;
    tCLIENTELE                    *pClientEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION))
    {
        ASSERTMSG ("Nbt.NTAssocAddress: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // the address handle is buried in the Irp...
    parameters = (PTDI_REQUEST_KERNEL_ASSOCIATE)&pIrpSp->Parameters;

    // now get a pointer to the file object, which points to the address
    // element by calling a kernel routine to convert this filehandle into
    // a file pointer.

    status = ObReferenceObjectByHandle (parameters->AddressHandle,
                                        FILE_READ_DATA,
                                        *IoFileObjectType,
                                        pIrp->RequestorMode,
                                        (PVOID *)&fileObject,
                                        NULL);

    IF_DBG(NBT_DEBUG_HANDLES)
        KdPrint (("\t  ++<%x>====><%x>\tNTAssocAddress->ObReferenceObject, Status = <%x>\n", parameters->AddressHandle, fileObject, status));

    if ((NT_SUCCESS(status)) &&
        (fileObject->DeviceObject->DriverObject == NbtConfig.DriverObject) &&   // Bug# 202349
        NBT_VERIFY_HANDLE(((tDEVICECONTEXT*)fileObject->DeviceObject), NBT_VERIFY_DEVCONTEXT) &&  // Bug# 202349
        (PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE))
    {
        pClientEle = fileObject->FsContext;
        if (NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT))
        {
            // call the non-NT specific function to associate the address with
            // the connection
            status = NbtAssociateAddress (&Request, pClientEle, (PVOID)pIrp);
            NbtTrace(NBT_TRACE_OUTBOUND, ("NbtAssociateAddress returns %!status!", status));
        }
        else
        {
            ASSERTMSG ("Nbt.NTAssocAddress: ERROR - Invalid Address Handle\n", 0);
            status = STATUS_INVALID_HANDLE;
        }

        // we are done with the file object, so release the reference
        ObDereferenceObject((PVOID)fileObject);

        return(status);
    }
    else
    {
        return(STATUS_INVALID_HANDLE);
    }

}

//----------------------------------------------------------------------------
NTSTATUS
NTCloseConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles converting a Close Connection Request from an IRP to
    a procedure call so that NbtCloseConnection can be called in an OS independent
    manner.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    TDI_REQUEST                   Request;
    TDI_REQUEST_STATUS            RequestStatus;
    PIO_STACK_LOCATION            pIrpSp;
    NTSTATUS                      status;
    tCONNECTELE                   *pConnEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTCloseConnection: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtCloseConnection(
                    &Request,
                    &RequestStatus,
                    pDeviceContext,
                    (PVOID)pIrp);
    NbtTrace(NBT_TRACE_OUTBOUND, ("Close connection %p returns %!status!", pConnEle, status));

    return(status);
}

//----------------------------------------------------------------------------
VOID
NTSetFileObjectContexts(
    IN  PIRP            pIrp,
    IN  PVOID           FsContext,
    IN  PVOID           FsContext2)

/*++
Routine Description:

    This Routine handles fills in two context values in the Irp stack location,
    that has to be done in an OS-dependent manner.  This routine is called
    from NbtOpenAddress() when a name is being registered on the network( i.e.
    as a result of OpenAddress).

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION            pIrpSp;
    PFILE_OBJECT                  pFileObject;

    //
    // fill the IRP with context information so we can
    // find the address object given the fileObject later.
    //
    // This must be done here, rather than after the call to NbtOpenAddress
    // because that call can complete the Irp before it returns.  Soooo,
    // in the complete routine for the Irp, if the completion code is not
    // good, it Nulls these two context values.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileObject = pIrpSp->FileObject;
    pFileObject->FsContext = FsContext;
    pFileObject->FsContext2 =FsContext2;
}


//----------------------------------------------------------------------------
VOID
NTClearFileObjectContext(
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine clears the context value in the file object when an address
    object is closed.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    none

--*/

{

    PIO_STACK_LOCATION            pIrpSp;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    CHECK_PTR(pIrpSp->FileObject);
    pIrpSp->FileObject->FsContext = NULL;

}

//----------------------------------------------------------------------------
NTSTATUS
NTSetSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress)

/*++
Routine Description:

    This Routine handles setting the shared access on the file object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    PACCESS_STATE       AccessState;
    ULONG               DesiredAccess;
    PIO_STACK_LOCATION  pIrpSp;
    NTSTATUS            status;
    static GENERIC_MAPPING AddressGenericMapping = { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    if ((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                (pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE))
    {
        DesiredAccess  = (ULONG)FILE_SHARE_READ;
    }
    else
    {
        DesiredAccess = (ULONG)0;
    }

    IoSetShareAccess (FILE_READ_DATA, DesiredAccess, pIrpSp->FileObject, &pAddress->ShareAccess);

    // assign the security descriptor ( need to to do this with the spinlock
    // released because the descriptor is not mapped.  Assign and CheckAccess
    // are synchronized using a Resource.

    AccessState = pIrpSp->Parameters.Create.SecurityContext->AccessState;
    status = SeAssignSecurity (NULL,           // Parent Descriptor
                               AccessState->SecurityDescriptor,
                               &pAddress->SecurityDescriptor,
                               FALSE,          // is a directory
                               &AccessState->SubjectSecurityContext,
                               &AddressGenericMapping,
                               NonPagedPool);

    if (!NT_SUCCESS(status))
    {
        IoRemoveShareAccess (pIrpSp->FileObject, &pAddress->ShareAccess);
    }

    return status;
}

//----------------------------------------------------------------------------
NTSTATUS
NTCheckSharedAccess(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tADDRESSELE     *pAddress)

/*++
Routine Description:

    This Routine handles setting the shared access on the file object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    PACCESS_STATE       AccessState;
    ACCESS_MASK         GrantedAccess;
    BOOLEAN             AccessAllowed;
    ULONG               DesiredAccess;
    PIO_STACK_LOCATION  pIrpSp;
    BOOLEAN             duplicate=FALSE;
    NTSTATUS            status;
    ULONG               DesiredShareAccess;
    static GENERIC_MAPPING AddressGenericMapping =
           { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };


    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);


    if ((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                (pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE))
        DesiredAccess  = (ULONG)FILE_SHARE_READ;
    else
        DesiredAccess = (ULONG)0;


    //
    // The address already exists.  Check the ACL and see if we
    // can access it.  If so, simply use this address as our address.
    //

    AccessState = pIrpSp->Parameters.Create.SecurityContext->AccessState;

    status = STATUS_SUCCESS;

    // *TODO* check that this routine is doing the right thing...
    //
    AccessAllowed = SeAccessCheck(
                        pAddress->SecurityDescriptor,
                        &AccessState->SubjectSecurityContext,
                        FALSE,                   // tokens locked
                        pIrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                        (ACCESS_MASK)0,             // previously granted
                        NULL,                    // privileges
                        &AddressGenericMapping,
                        pIrp->RequestorMode,
                        &GrantedAccess,
                        &status);


    // use the status from the IoCheckShareAccess as the return access
    // event if SeAccessCheck fails....

    //
    // Hmmm .... Compare DesiredAccess to GrantedAccess?
    //

    //
    // Now check that we can obtain the desired share
    // access. We use read access to control all access.
    //

    DesiredShareAccess = (ULONG)
        (((pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
          (pIrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                FILE_SHARE_READ : 0);

    //ACQUIRE_SPIN_LOCK (&pDeviceContext->SpinLock, &oldirql);

    status = IoCheckShareAccess(
                 FILE_READ_DATA,
                 DesiredAccess,
                 pIrpSp->FileObject,
                 &pAddress->ShareAccess,
                 TRUE);


    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTCleanUpAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles the first stage of releasing an address object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    tCLIENTELE          *pClientEle;
    PIO_STACK_LOCATION  pIrpSp;

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTCleanUpAddress: Cleanup Address Hit ***\n"));

    //
    // Disconnect any active connections, and for each connection that is not
    // in use, remove one from the free list to the transport below.
    //

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *) pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT))
    {
        ASSERTMSG ("Nbt.NTCleanUpAddress: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);
    status = NbtCleanUpAddress(pClientEle,pDeviceContext);
    NbtTrace(NBT_TRACE_NAMESRV, ("Cleanup address %p returns %!status!", pClientEle, status));

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NTCleanUpConnection(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles running down a connection in preparation for a close
    that will come in next.  NtClose hits this entry first, and then it hits
    the NTCloseConnection next. If the connection was outbound, then the
    address object must be closed as well as the connection.  This routine
    mainly deals with the pLowerconn connection to the transport whereas
    NbtCloseConnection deals with closing pConnEle, the connection to the client.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp;
    tCONNECTELE         *pConnEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pConnEle = (tCONNECTELE *) pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTCleanUpConnection: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    //CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTCleanUpConnection: Cleanup Connection Hit state= %X\n",pConnEle->state));

    pConnEle->ConnectionCleanedUp = TRUE;
    status = NbtCleanUpConnection(pConnEle,pDeviceContext);
    NbtTrace(NBT_TRACE_NAMESRV, ("Cleanup connection %p returns %!status!", pConnEle, status));

    return(status);

}
//----------------------------------------------------------------------------
NTSTATUS
NTAccept(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles passing an accept for an inbound connect indication to
    the OS independent code.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_ACCEPT  pRequest;
    tCONNECTELE                 *pConnEle;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTAccept: ** Got an Accept from the Client **\n"));

    // pull the junk out of the Irp and call the non-OS specific routine.
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // the Parameters value points to a Request structure...
    pRequest = (PTDI_REQUEST_KERNEL_ACCEPT)&pIrpSp->Parameters;

    // the pConnEle ptr was stored in the FsContext value when the connection
    // was initially created.
    pConnEle = TdiRequest.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTAccept: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtAccept(
                    &TdiRequest,
                    pRequest->RequestConnectionInformation,
                    pRequest->ReturnConnectionInformation,
                    pIrp);

    return(status);

}


//----------------------------------------------------------------------------
NTSTATUS
NTDisAssociateAddress(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/


{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_ACCEPT  pRequest;
    tCONNECTELE                 *pConnEle;

    CTEPagedCode();

    // pull the junk out of the Irp and call the non-OS specific routine.
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    // the Parameters value points to a Request structure...
    pRequest = (PTDI_REQUEST_KERNEL_ACCEPT)&pIrpSp->Parameters;

    // the pConnEle ptr was stored in the FsContext value when the connection
    // was initially created.
    pConnEle = TdiRequest.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTCloseAddress: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    status = NbtDisassociateAddress(&TdiRequest);

    return(status);
}

LONG
NextTransportAddress(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    )
/*++
    Move the pointer to the next address.
--*/
{
    pDelConnCtx->RemainingAddressLength -= (pDelConnCtx->TaAddressLength + FIELD_OFFSET(TRANSPORT_ADDRESS,Address));
    pDelConnCtx->pTaAddress += pDelConnCtx->TaAddressLength + FIELD_OFFSET(TRANSPORT_ADDRESS,Address);
    RtlCopyMemory(&pDelConnCtx->TaAddressLength,
                (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressLength)), sizeof(USHORT));
    pDelConnCtx->CurrIndex++;
    /*
     * make sure we don't overrun the buffer
     */
    if(pDelConnCtx->RemainingAddressLength < (pDelConnCtx->TaAddressLength + FIELD_OFFSET(TRANSPORT_ADDRESS,Address))) {
        KdPrint(("netbt!NextTransportAddress: insufficient TaAddress buffer size\n"));
        pDelConnCtx->CurrIndex = pDelConnCtx->NumberOfAddresses;
    }
    return pDelConnCtx->CurrIndex;
}

NTSTATUS
InitDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    )
/*++
    Reset the NBT_DELAYED_CONNECT_CONTEXT
    Find the first readable unicode address and writable buffer. In compound address case, NetBT will first try
    to establish the connection using the first readable unicode address. If this fails, it will attempt to use
    OEM address, ie. only one readable unicode address is effective. If DNS name resolution is used, NetBT will
    return the result in the first writable buffer and update the NameBufferType to NBT_WRITTEN.
--*/
{
    PTDI_REQUEST_KERNEL  pRequestKernel;
    PIO_STACK_LOCATION   pIrpSp;
    PTRANSPORT_ADDRESS   pRemoteAddress;
    PUCHAR               pTaAddress;
    enum eNameBufferType NameBufferType, UnicodeAddressNameBufferType;
    NTSTATUS             status;

    CTEPagedCode();

    pIrpSp          = IoGetCurrentIrpStackLocation(pDelConnCtx->pClientIrp);
    pRequestKernel  = (PTDI_REQUEST_KERNEL) &pIrpSp->Parameters;
    pRemoteAddress  = pRequestKernel->RequestConnectionInformation->RemoteAddress;

    pDelConnCtx->NumberOfAddresses = pRemoteAddress->TAAddressCount;
    pDelConnCtx->RemainingAddressLength = pRequestKernel->RequestConnectionInformation->RemoteAddressLength;
    pDelConnCtx->pTaAddress       = (PCHAR)&pRemoteAddress->Address[0];
    RtlCopyMemory(&pDelConnCtx->TaAddressLength,
                (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressLength)), sizeof(USHORT));
    pDelConnCtx->CurrIndex = 0;

    /*
     * Find the first writable buffer and readable unicode address
     */
    pDelConnCtx->pReturnBuffer = NULL;
    pDelConnCtx->pUnicodeAddress = NULL;
    for (pDelConnCtx->CurrIndex = 0; pDelConnCtx->CurrIndex < pDelConnCtx->NumberOfAddresses; 
                        NextTransportAddress(pDelConnCtx)) {
        USHORT               TaAddressType;
        
        RtlCopyMemory(&TaAddressType, (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressType)), sizeof(USHORT));
        if (TaAddressType != TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX) {
            continue;
        }
        RtlCopyMemory(&NameBufferType,
                        pDelConnCtx->pTaAddress +
                        FIELD_OFFSET(TA_ADDRESS,Address)+
                        FIELD_OFFSET(TDI_ADDRESS_NETBIOS_UNICODE_EX,NameBufferType),
                        sizeof(NameBufferType));
        if (NameBufferType != NBT_READONLY && NameBufferType != NBT_WRITEONLY &&
            NameBufferType != NBT_READWRITE && NameBufferType != NBT_WRITTEN) {
            return STATUS_INVALID_ADDRESS;
        }
        if (NameBufferType == NBT_READONLY || NameBufferType == NBT_READWRITE) {
            if (pDelConnCtx->pUnicodeAddress == NULL) {
                pDelConnCtx->pUnicodeAddress = (TDI_ADDRESS_NETBIOS_UNICODE_EX*)
                        (pDelConnCtx->pTaAddress + FIELD_OFFSET(TA_ADDRESS,Address));
                UnicodeAddressNameBufferType = NameBufferType;
            }
        }
        if (NameBufferType == NBT_WRITEONLY) {
            pDelConnCtx->pReturnBuffer = (TDI_ADDRESS_NETBIOS_UNICODE_EX*)
                        (pDelConnCtx->pTaAddress + FIELD_OFFSET(TA_ADDRESS,Address));
            break;
        }
        if (NameBufferType == NBT_READWRITE) {
            pDelConnCtx->pReturnBuffer = (TDI_ADDRESS_NETBIOS_UNICODE_EX*)
                        (pDelConnCtx->pTaAddress + FIELD_OFFSET(TA_ADDRESS,Address));
            /*
             * Only when no WRITEONLY buffer is presented, can we use a READWRITE buffer. So continue searching.
             */
        }
    }
    pDelConnCtx->NumberOfAddresses = pRemoteAddress->TAAddressCount;
    pDelConnCtx->RemainingAddressLength = pRequestKernel->RequestConnectionInformation->RemoteAddressLength;
    pDelConnCtx->pTaAddress       = (PCHAR)&pRemoteAddress->Address[0];
    RtlCopyMemory(&pDelConnCtx->TaAddressLength,
                (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressLength)), sizeof(USHORT));
    pDelConnCtx->CurrIndex = 0;

    /*
     * Setup the first local transport address
     */
    if (pDelConnCtx->pUnicodeAddress != NULL) {
        pTaAddress = ((PUCHAR)pDelConnCtx->pUnicodeAddress - FIELD_OFFSET(TA_ADDRESS,Address));
    } else {
        pTaAddress = pDelConnCtx->pTaAddress;
    }
    status = NewInternalAddressFromTransportAddress(
                (PTRANSPORT_ADDRESS) (pTaAddress-FIELD_OFFSET(TRANSPORT_ADDRESS,Address)),
                pDelConnCtx->RemainingAddressLength, &pDelConnCtx->pTransportAddress);

    if (status != STATUS_SUCCESS) {
        ASSERT(pDelConnCtx->pTransportAddress == NULL);
        return status;
    }
    if (pDelConnCtx->pUnicodeAddress == NULL || UnicodeAddressNameBufferType != NBT_READWRITE) {
        pDelConnCtx->pTransportAddress->Address[0].Address[0].pNetbiosUnicodeEX = pDelConnCtx->pReturnBuffer;
    }

    ASSERT(pDelConnCtx->pTransportAddress);
    return STATUS_SUCCESS;
}

NTSTATUS
NextDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx
    )
/*++
    Move the pointer to the next address.
--*/
{
    USHORT  TaAddressType;
    enum eNameBufferType        NameBufferType;
    PTA_NETBT_INTERNAL_ADDRESS  pTransportAddress = NULL;
    TDI_ADDRESS_NETBT_INTERNAL  *pAddr;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;
    NTSTATUS                    status;

    pIrpSp   = IoGetCurrentIrpStackLocation(pDelConnCtx->pClientIrp);
    pConnEle = pIrpSp->FileObject->FsContext;
    ASSERT (pConnEle->pIrp == NULL);
    ASSERT(pDelConnCtx->pTransportAddress);
    status = STATUS_SUCCESS;
    while(1) {
        /*
         * Free memory allocated in previous loop
         */
        if (pTransportAddress) {
            DeleteInternalAddress(pTransportAddress);
            pTransportAddress = NULL;
        }

        if (pDelConnCtx->pUnicodeAddress == NULL) {
            NextTransportAddress(pDelConnCtx);
        } else {
            pDelConnCtx->pUnicodeAddress = NULL;
        }
        if (pDelConnCtx->CurrIndex >= pDelConnCtx->NumberOfAddresses) {
            break;
        }

        /*
         * Skip UNICODE address.
         * UNICODE address is always done first, ie. just after InitDelayedNbtProcessConnect gets called.
         */
        RtlCopyMemory(&TaAddressType, (pDelConnCtx->pTaAddress+FIELD_OFFSET(TA_ADDRESS,AddressType)), sizeof(USHORT));
        if (TaAddressType != TDI_ADDRESS_TYPE_NETBIOS && TaAddressType != TDI_ADDRESS_TYPE_NETBIOS_EX) {
            continue;
        }

        /*
         * Since we only do OEM address, we can safely call NewInternalAddressFromTransportAddress (this guy will
         * call Rtl* to convert UNICODE to OEM in UNICODE address case so that we may hit bug check.)
         */
        status = NewInternalAddressFromTransportAddress(
                (PTRANSPORT_ADDRESS) (pDelConnCtx->pTaAddress-FIELD_OFFSET(TRANSPORT_ADDRESS,Address)),
                pDelConnCtx->RemainingAddressLength, &pTransportAddress);
        if (status != STATUS_SUCCESS) {
            ASSERT(pTransportAddress == NULL);
            continue;
        }
        ASSERT(pTransportAddress);
        pAddr = pTransportAddress->Address[0].Address;

        /*
         * Always attach a writable buffer in OEM address case
         */
        pAddr->pNetbiosUnicodeEX = pDelConnCtx->pReturnBuffer;

        /*
         * Skip any address which is same as previous one.
         *    Since the previous one fails, there is no point to use it again.
         */
        if (IsDeviceNetbiosless(pDelConnCtx->pDeviceContext) ||
                (pDelConnCtx->pLocalIrp->IoStatus.Status == STATUS_HOST_UNREACHABLE)) {
            OEM_STRING  RemoteName, PreviouseRemoteName;

            CTEMemCopy (&RemoteName, &pAddr->OEMRemoteName, sizeof(OEM_STRING));
            CTEMemCopy (&PreviouseRemoteName,
                &pDelConnCtx->pTransportAddress->Address[0].Address[0].OEMRemoteName, sizeof(OEM_STRING));
            if ((RemoteName.Length) && (RemoteName.Length == PreviouseRemoteName.Length) &&
                (CTEMemEqu (RemoteName.Buffer, PreviouseRemoteName.Buffer, RemoteName.Length))) {
                IF_DBG(NBT_DEBUG_NETBIOS_EX)
                    KdPrint(("Nbt.DelayedNbtProcessConnect: Irp=<%x>, Names match!<%16.16s:%x>, Types=<%x:%x>\n",
                        pDelConnCtx->pClientIrp, pAddr->OEMRemoteName.Buffer, pAddr->OEMRemoteName.Buffer[15],
                        pAddr->AddressType, pDelConnCtx->pTransportAddress->Address[0].Address[0].AddressType));
                continue;
            }
        }

        if (pConnEle->RemoteNameDoesNotExistInDNS) {
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("netbt!DelayedNbtProcessConnect: Skipping address type %lx length %lx\n"
                        "\t\tfor nonexistent name, pIrp %lx, pLocalIrp %lx\n",
                            TaAddressType, pDelConnCtx->TaAddressLength,
                            pDelConnCtx->pClientIrp, pDelConnCtx->pLocalIrp));

            // If the address type is such that we rely on DNS name resolution and
            // if a prior attempt failed, there is no point in reissuing the request.
            // We can fail them without having to go on the NET.
            if (TaAddressType == TDI_ADDRESS_TYPE_NETBIOS_EX) {
                status = STATUS_BAD_NETWORK_PATH;
                continue;
            } else if (pDelConnCtx->TaAddressLength != TDI_ADDRESS_LENGTH_NETBIOS) {
                ASSERT(TaAddressType == TDI_ADDRESS_TYPE_NETBIOS);
                status = STATUS_INVALID_ADDRESS_COMPONENT;
                continue;
            }
        }

        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("netbt!DelayedNbtProcessConnect: Sending local irp=%lx, %lx of %lx\n"
                    "\t\t\t\tTA=%lx Length=%lx\n",
                    pDelConnCtx->pLocalIrp, pDelConnCtx->CurrIndex+1, pDelConnCtx->NumberOfAddresses,
                    pDelConnCtx->pTaAddress, pDelConnCtx->TaAddressLength));

        DeleteInternalAddress(pDelConnCtx->pTransportAddress);
        pDelConnCtx->pTransportAddress = pTransportAddress;
        pTransportAddress = NULL;

        break;
    }
    if (pTransportAddress) {
        DeleteInternalAddress(pTransportAddress);
        pTransportAddress = NULL;
    }
    return status;
}

VOID
DoneDelayedNbtProcessConnect(
    IN PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx,
    NTSTATUS    status
    )
/*++
    1. Complete the client IRP
    2. Cleanup everything
--*/
{
    ASSERT(pDelConnCtx->pLocalIrp);
    ASSERT(pDelConnCtx->pClientIrp);

    NbtCancelCancelRoutine(pDelConnCtx->pClientIrp);

    ASSERT(status != STATUS_PENDING);
    if (pDelConnCtx->pLocalIrp) {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("netbt!DoneDelayedNbtProcessConnect: Freeing Local Irp=<%x>\n", pDelConnCtx->pLocalIrp));
        IoFreeIrp(pDelConnCtx->pLocalIrp);
    }
    if (pDelConnCtx->pTransportAddress) {
        DeleteInternalAddress(pDelConnCtx->pTransportAddress);
    }

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("netbt!DoneDelayed...: Connect Complete, LocalIrp=<%x>, ClientIrp=<%x>, Status=<%x>\n",
            pDelConnCtx->pLocalIrp, pDelConnCtx->pClientIrp, status));

    NbtTrace(NBT_TRACE_OUTBOUND, ("Complete connection request pIrp=%p pLocalIrp=%p with %!status!",
                            pDelConnCtx->pClientIrp, pDelConnCtx->pLocalIrp, status));
    NTIoComplete (pDelConnCtx->pClientIrp, status, 0);

    pDelConnCtx->pLocalIrp = NULL;
    pDelConnCtx->pClientIrp = NULL;
    pDelConnCtx->pTransportAddress = NULL;

    CTEFreeMem(pDelConnCtx);
}


//----------------------------------------------------------------------------

NTSTATUS
NbtpConnectCompletionRoutine(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           pCompletionContext
    )
/*++
Routine Description:

    This Routine is the completion routine for local IRPS that are generated
    to handle compound transport addresses

Arguments:

    pDeviceObject - the device object

    pIrp - a  ptr to an IRP

    pCompletionContext - the completion context

Return Value:

    NTSTATUS - status of the request

--*/

{
    PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx;
    NTSTATUS                        Status, Status2;
    PIRP                            pLocalIrp;
    tDEVICECONTEXT                  *pDeviceContext;

    pDelConnCtx = pCompletionContext;
    pDeviceContext = pDelConnCtx->pDeviceContext;
    pLocalIrp = pDelConnCtx->pLocalIrp;
    ASSERT (pIrp == pLocalIrp);

    Status = pLocalIrp->IoStatus.Status;
    ASSERT(Status != STATUS_PENDING);

    pDelConnCtx->ProcessingDone = TRUE;

    /*
     * Let's move to next address
     */
    Status2 = NextDelayedNbtProcessConnect(pDelConnCtx);

    /*
     * Are we done
     */
    if (Status == STATUS_CANCELLED || Status == STATUS_SUCCESS || Status2 != STATUS_SUCCESS ||
            pDelConnCtx->CurrIndex >= pDelConnCtx->NumberOfAddresses) {
        if (Status2 != STATUS_SUCCESS) {
            Status = Status2;
        }
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NbtpC...:==>Connect Complete, LocalIrp=<%x>, ClientIrp=<%x>, Status=<%x> <==\n",
                pIrp,pDelConnCtx->pClientIrp, Status));

        if (Status == STATUS_HOST_UNREACHABLE) {
            Status = STATUS_BAD_NETWORK_PATH;
        }
        DoneDelayedNbtProcessConnect(pDelConnCtx, Status);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    /*
     * Start worker thread to process the Connect request on the next address
     */
    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("NbtpConnectCompletionRoutine: queuing worker item, local irp=%lx, previous status=%lx\n",
                            pIrp, Status));

    if (STATUS_SUCCESS != CTEQueueForNonDispProcessing (DelayedNbtProcessConnect,
                                                        NULL,
                                                        pDelConnCtx,
                                                        NULL,
                                                        pDeviceContext,
                                                        FALSE))
    {
        KdPrint(("Nbt.NbtpConnectCompletionRoutine: Failed to Enqueue Worker thread\n"));
        DoneDelayedNbtProcessConnect(pDelConnCtx, STATUS_INSUFFICIENT_RESOURCES);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//----------------------------------------------------------------------------
NTSTATUS
DelayedNbtProcessConnect(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )

/*++
Routine Description:

    This Routine is the worker thread for processing Connect Requests.

Arguments:

    pContext

Return Value:

    NONE

--*/

{
    PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx;
    PIRP                        pIrp, pLocalIrp;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;
    NTSTATUS                    Status;
    PTDI_REQUEST_KERNEL         pRequestKernel;


    CTEPagedCode();

    pDelConnCtx     = (PNBT_DELAYED_CONNECT_CONTEXT) pClientContext;
    pIrp            = pDelConnCtx->pClientIrp;
    pLocalIrp       = pDelConnCtx->pLocalIrp;

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("netbt!DelayedNbtProcessConnect: Enter with local irp=%lx, %lx of %lx\n"
                    "\t\t\t\tTA=%lx Length=%lx\n",
                    pLocalIrp, pDelConnCtx->CurrIndex+1, pDelConnCtx->NumberOfAddresses,
                    pDelConnCtx->pTaAddress, pDelConnCtx->TaAddressLength));

    pIrpSp   = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) {
        DbgPrint ("Nbt.DelayedNbtProcessConnect: ERROR - Invalid Connection Handle\n");
        DoneDelayedNbtProcessConnect(pDelConnCtx,
            (pDelConnCtx->ProcessingDone)? pLocalIrp->IoStatus.Status: STATUS_UNSUCCESSFUL);
        return STATUS_UNSUCCESSFUL;
    }
    CHECK_PTR (pConnEle);

    Status = STATUS_UNSUCCESSFUL;

    /*
     * Set the Cancel routine and ensure that the original IRP was not cancelled before continuing.
     */
    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint (("Nbt.DelayedNbtProcessConnect: Setting Cancel=<NbtCancelConnect> for Irp:Device <%x:%x>\n",
            pIrp, pDelConnCtx->pDeviceContext));

    if (STATUS_CANCELLED == NTCheckSetCancelRoutine(pIrp, NbtCancelConnect, pDelConnCtx->pDeviceContext)) {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.DelayedNbtProcessConnect: Irp <%x> was cancelled\n", pIrp));
        pConnEle->pIrp = NULL;
        DoneDelayedNbtProcessConnect(pDelConnCtx, STATUS_CANCELLED);
        return STATUS_CANCELLED;
    }

    /*
     * InitDelayedNbtProcessConnect/NextDelayedNbtProcessConnect has set up pDelConnCtx->pTransportAddress properly
     */
    ASSERT(pDelConnCtx->pTransportAddress);

    pConnEle->AddressType = pDelConnCtx->pTransportAddress->Address[0].Address[0].AddressType;
    pRequestKernel  = (PTDI_REQUEST_KERNEL) &pIrpSp->Parameters;
    pDelConnCtx->LocalConnectionInformation = *(pRequestKernel->RequestConnectionInformation);
    pDelConnCtx->LocalConnectionInformation.RemoteAddress = pDelConnCtx->pTransportAddress;
    pDelConnCtx->LocalConnectionInformation.RemoteAddressLength = pDelConnCtx->pTransportAddress->Address[0].AddressLength;

    //
    // Save the thread info for debugging purposes!
    //
    pLocalIrp->Tail.Overlay.Thread = PsGetCurrentThread();

    TdiBuildConnect (pLocalIrp,
                     &pDelConnCtx->pDeviceContext->DeviceObject,
                     pIrpSp->FileObject,
                     NbtpConnectCompletionRoutine,
                     pDelConnCtx,
                     pRequestKernel->RequestSpecific,
                     &pDelConnCtx->LocalConnectionInformation,
                     pRequestKernel->ReturnConnectionInformation);

    Status = IoCallDriver(&pDelConnCtx->pDeviceContext->DeviceObject,pLocalIrp);

    if (Status != STATUS_PENDING) {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.DelayedNbtProcessConnect: IoCallDriver returned %lx for irp %lx (%lx)\n",
                Status,pIrp,pLocalIrp));

        // ASSERT(0);
    }
    return STATUS_PENDING;
}

//----------------------------------------------------------------------------
NTSTATUS
NTConnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles calling the non OS specific code to open a session
    connection to a destination.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    PTRANSPORT_ADDRESS              pRemoteAddress;
    PTDI_REQUEST_KERNEL             pRequestKernel;
    PIRP                            pLocalIrp;
    PNBT_DELAYED_CONNECT_CONTEXT    pDelConnCtx;
    NTSTATUS                        Status;

    pIrpSp          = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel  = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;

    try
    {
        pRemoteAddress  = pRequestKernel->RequestConnectionInformation->RemoteAddress;

        if (pRequestKernel->RequestConnectionInformation->RemoteAddressLength < sizeof(TRANSPORT_ADDRESS)) {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Incorrect address length %d, required %d",
                pRequestKernel->RequestConnectionInformation->RemoteAddressLength, sizeof(TRANSPORT_ADDRESS)));
            return STATUS_INVALID_ADDRESS_COMPONENT;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        KdPrint (("Nbt.NTConnect: Exception <0x%x> trying to access Connection info\n", GetExceptionCode()));
        NbtTrace(NBT_TRACE_OUTBOUND, ("Exception <0x%x> trying to access Connection info\n", GetExceptionCode()));
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    if (pIrpSp->CompletionRoutine != NbtpConnectCompletionRoutine) {
        pDelConnCtx = NbtAllocMem(sizeof(NBT_DELAYED_CONNECT_CONTEXT),NBT_TAG('e'));
        if (!pDelConnCtx) {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Out of memory"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        CTEZeroMemory(pDelConnCtx, sizeof(NBT_DELAYED_CONNECT_CONTEXT));
        pLocalIrp = IoAllocateIrp(pDeviceContext->DeviceObject.StackSize,FALSE);
        if (!pLocalIrp) {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Out of memory"));
            CTEFreeMem(pDelConnCtx);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        pDelConnCtx->pDeviceContext = pDeviceContext;
        pDelConnCtx->pClientIrp = pIrp;
        pDelConnCtx->pLocalIrp  = pLocalIrp;
        pDelConnCtx->pTransportAddress = NULL;
        pDelConnCtx->ProcessingDone = FALSE;

        Status = InitDelayedNbtProcessConnect(pDelConnCtx);
        if (!NT_SUCCESS(Status)) {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Out of memory status=%!status!", Status));
            CTEFreeMem(pDelConnCtx);
            IoFreeIrp(pLocalIrp);
            return Status;
        }
        NbtTrace(NBT_TRACE_OUTBOUND, ("Connection request pIrp=%p pLocalIrp=%p", pIrp, pLocalIrp));

        //return (DelayedNbtProcessConnect (NULL, pDelConnCtx, NULL, NULL));
        DelayedNbtProcessConnect (NULL, pDelConnCtx, NULL, NULL);
        // Ignore the return from DelayedNbtProcessConnect and always return STATUS_PENDING;
        // our client completion routine will take care of completing the IRP
        // Otherwise, we will complete the IRP twice.
        return STATUS_PENDING;
    }
    else
    {
        TDI_REQUEST     Request;
        tCONNECTELE     *pConnEle;

        // call the non-NT specific function to setup the connection
        pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
        if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            ASSERTMSG ("Nbt.NTConnect: ERROR - Invalid Connection Handle\n", 0);
            NbtTrace(NBT_TRACE_OUTBOUND, ("Invalid pConnEle %p", pConnEle));
            return (STATUS_INVALID_HANDLE);
        }

        /*
         * A user mode process may send us a faked request with a completion routine
         * equal to NbtpConnectCompletionRoutine.
         * Never let it pass through.
         */
        if (pIrp->RequestorMode != KernelMode) {
            ASSERTMSG ("Nbt.NTConnect: ERROR - Invalid request\n", 0);
            NbtTrace(NBT_TRACE_OUTBOUND, ("Invalid requestor mode"));
            return (STATUS_INVALID_PARAMETER);
        }
        return NbtConnect(&Request,
                          pRequestKernel->RequestSpecific, // Ulong
                          pRequestKernel->RequestConnectionInformation,
                          pIrp);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NTDisconnect(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles calling the Non OS specific code to disconnect a
    session.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    TDI_REQUEST                   Request;
    PIO_STACK_LOCATION            pIrpSp;
    NTSTATUS                      status;
    PTDI_REQUEST_KERNEL           pRequestKernel;
    tCONNECTELE                   *pConnEle;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTDisconnect: ERROR - Invalid Connection Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // call the non-NT specific function to setup the connection
    status = NbtDisconnect(
                        &Request,
                        pRequestKernel->RequestSpecific, // Large Integer
                        (ULONG) pRequestKernel->RequestFlags,
                        pRequestKernel->RequestConnectionInformation,
                        pRequestKernel->ReturnConnectionInformation,
                        pIrp
                        );

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTListen(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{

    NTSTATUS                    status;
    TDI_REQUEST                 Request;
    PTDI_REQUEST_KERNEL         pRequestKernel;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTListen: Got a LISTEN !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pRequestKernel = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;

    pConnEle = Request.Handle.ConnectionContext = pIrpSp->FileObject->FsContext;
    if (NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        try
        {
            PCHAR                   pName;
            ULONG                   lNameType;
            ULONG                   NameLen;

            // Initialize Request data (may be needed by Vxd)
            Request.RequestNotifyObject = NULL;
            Request.RequestContext = NULL;
            // call the non-NT specific function to setup the connection
            status = NbtListen (&Request,
                                (ULONG) pRequestKernel->RequestFlags, // Ulong
                                pRequestKernel->RequestConnectionInformation,
                                pRequestKernel->ReturnConnectionInformation,
                                pIrp);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
           KdPrint (("Nbt.NTListen: Exception <0x%x> trying to access buffer\n", GetExceptionCode()));
           status = STATUS_INVALID_ADDRESS;
        }
    }
    else
    {
        ASSERTMSG ("Nbt.NTListen: ERROR - Invalid Connection Handle\n", 0);
        status = STATUS_INVALID_HANDLE; // Bug# 202340:  Have to complete Irp here!
    }

    if (status != STATUS_PENDING)
    {
        NTIoComplete(pIrp,status,0);
    }
    return(status);

}
//----------------------------------------------------------------------------
NBT_WORK_ITEM_CONTEXT *
FindLmhSvcRequest(
    IN PDEVICE_OBJECT   DeviceContext,
    IN PIRP             pIrp,
    IN tLMHSVC_REQUESTS *pLmhRequest
    )
/*++

Routine Description:

    This routine handles the cancelling a Query to LmHost, so that the client's
    irp can be returned to the client.  This cancellation is instigated
    by the client (i.e. RDR).

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    NBT_WORK_ITEM_CONTEXT   *Context;
    BOOLEAN                 FoundIt = FALSE;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;

    if (pLmhRequest->ResolvingNow && pLmhRequest->Context)
    {
        // this is the session setup tracker
        //
        Context = (NBT_WORK_ITEM_CONTEXT *) pLmhRequest->Context;
        pTracker = (tDGRAM_SEND_TRACKING *) Context->pClientContext;
        if (pTracker->pClientIrp == pIrp)
        {
            pLmhRequest->Context = NULL;
            FoundIt = TRUE;
        }
    }
    else
    {
        //
        // go through the list of Queued requests to find the correct one
        // and cancel it
        //
        pHead = pEntry = &pLmhRequest->ToResolve;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            Context = CONTAINING_RECORD (pEntry,NBT_WORK_ITEM_CONTEXT,Item.List);

            // this is the session setup tracker
            //
            pTracker = (tDGRAM_SEND_TRACKING *)Context->pClientContext;
            if (pTracker->pClientIrp == pIrp)
            {
                RemoveEntryList(pEntry);
                FoundIt = TRUE;
                break;
            }
        }
    }

    return (FoundIt ? Context : NULL);
}

//----------------------------------------------------------------------------
NTSTATUS
QueryProviderCompletion(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query Provider
    Information completes.  This routine must decrement the MaxDgramSize
    and max send size by the respective NBT header sizes.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - not used

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PTDI_PROVIDER_INFO   pProvider;
    ULONG                HdrSize;
    ULONG                SubnetAddr;
    ULONG                ThisSubnetAddr;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    tDEVICECONTEXT       *pDeviceContext;
    tDEVICECONTEXT       *pDevContext;
    CTELockHandle        OldIrq;

    if (NT_SUCCESS(Irp->IoStatus.Status))
    {
        pDeviceContext = (tDEVICECONTEXT *)DeviceContext;
        pProvider = (PTDI_PROVIDER_INFO)MmGetMdlVirtualAddress(Irp->MdlAddress);

        //
        // Set the correct service flags to indicate what Netbt supports.
        //
        pProvider->ServiceFlags = TDI_SERVICE_MESSAGE_MODE |
                                  TDI_SERVICE_CONNECTION_MODE |
                                  TDI_SERVICE_CONNECTIONLESS_MODE |
                                  TDI_SERVICE_ERROR_FREE_DELIVERY |
                                  TDI_SERVICE_BROADCAST_SUPPORTED |
                                  TDI_SERVICE_MULTICAST_SUPPORTED |
                                  TDI_SERVICE_DELAYED_ACCEPTANCE |
                                  TDI_SERVICE_ROUTE_DIRECTED |
                                  TDI_SERVICE_FORCE_ACCESS_CHECK;

        pProvider->MinimumLookaheadData = 128;

        if (pProvider->MaxSendSize > sizeof(tSESSIONHDR))
        {
            //
            // Nbt has just a two byte + 1 bit session message length, so it
            // can't have a send size larger than 1ffff
            //
            if (pProvider->MaxSendSize > (0x1FFFF + sizeof(tSESSIONHDR)))
            {
                pProvider->MaxSendSize = 0x1FFFF;
            }
            else
            {
                pProvider->MaxSendSize -= sizeof(tSESSIONHDR);
            }
        }
        else
        {
            pProvider->MaxSendSize = 0;
        }

        // subtract the datagram hdr size and the scope size (times 2)
        HdrSize = DGRAM_HDR_SIZE + (NbtConfig.ScopeLength << 1);
        if ((!IsDeviceNetbiosless (pDeviceContext)) &&
            (pProvider->MaxDatagramSize > HdrSize))
        {
            pProvider->MaxDatagramSize -= HdrSize;
            if (pProvider->MaxDatagramSize > MAX_NBT_DGRAM_SIZE)
            {
                pProvider->MaxDatagramSize = MAX_NBT_DGRAM_SIZE;
            }
        }
        else
        {
            pProvider->MaxDatagramSize = 0;
        }

        //
        // We need to hold the JointLock before we traverse
        // the list of Devices
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        //
        // Check if any of the adapters with the same subnet address have
        // the PointtoPoint bit set - and if so set it in the response.
        //
        SubnetAddr = pDeviceContext->IpAddress & pDeviceContext->SubnetMask;
        pEntry = pHead = &NbtConfig.DeviceContexts;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            ThisSubnetAddr = pDevContext->IpAddress & pDevContext->SubnetMask;

            if ((SubnetAddr == ThisSubnetAddr) &&
                (pDevContext->IpInterfaceFlags & IP_INTFC_FLAG_P2P))
            {
                pProvider->ServiceFlags |= TDI_SERVICE_POINT_TO_POINT;
                break;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back into the users buffer.
    //
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NTQueryInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION                      pIrpSp;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   Query;
    NTSTATUS                                status = STATUS_UNSUCCESSFUL;
    NTSTATUS                                Locstatus;
    PVOID                                   pBuffer = NULL;
    LONG                                    Size ;
    PTA_NETBIOS_ADDRESS                     BroadcastAddress;
    ULONG                                   AddressLength;
    ULONG                                   BytesCopied = 0;
    PDEVICE_OBJECT                          pDeviceObject;

    //
    // Should not be pageable since AFD can call us at raised Irql in case of AcceptEx.
    //
    // CTEPagedCode();

    if (pDeviceContext == pWinsDeviceContext)
    {
        NTIoComplete(pIrp, STATUS_INVALID_DEVICE_REQUEST, 0);
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    pIrpSp   = IoGetCurrentIrpStackLocation(pIrp);
    Query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&pIrpSp->Parameters;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTQueryInformation: Query type = %X\n",Query->QueryType));

    switch (Query->QueryType)
    {
        case TDI_QUERY_BROADCAST_ADDRESS:
        {
            // the broadcast address is the netbios name "*0000000..."
            if ((!pIrp->MdlAddress) ||
                (!(BroadcastAddress = (PTA_NETBIOS_ADDRESS)NbtAllocMem(sizeof(TA_NETBIOS_ADDRESS),NBT_TAG('b')))))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            AddressLength = sizeof(TA_NETBIOS_ADDRESS);

            BroadcastAddress->TAAddressCount = 1;
            BroadcastAddress->Address[0].AddressLength = NETBIOS_NAME_SIZE +
                                                                sizeof(USHORT);
            BroadcastAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            BroadcastAddress->Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;

            // the broadcast address to NetBios is "* 000000...", an * followed
            // by 15 zeroes.
            CTEZeroMemory(BroadcastAddress->Address[0].Address[0].NetbiosName,
                            NETBIOS_NAME_SIZE);
            BroadcastAddress->Address[0].Address[0].NetbiosName[0] = '*';


            status = TdiCopyBufferToMdl (
                            (PVOID)BroadcastAddress,
                            0,
                            AddressLength,
                            pIrp->MdlAddress,
                            0,
                            (PULONG)&pIrp->IoStatus.Information);

            BytesCopied = (ULONG) pIrp->IoStatus.Information;
            CTEMemFree((PVOID)BroadcastAddress);

            break;
        }

        case TDI_QUERY_PROVIDER_INFO:
        {
            //
            // Simply pass the Irp on by to the Transport, and let it
            // fill in the provider info
            //
            if (!pDeviceContext->IpAddress)
            {
                status = STATUS_INVALID_DEVICE_STATE;
                break;
            }

            if (StreamsStack)
            {
                TdiBuildQueryInformation(pIrp,
                                        pDeviceContext->pFileObjects->pDgramDeviceObject,
                                        pDeviceContext->pFileObjects->pDgramFileObject,
                                        QueryProviderCompletion,
                                        NULL,
                                        TDI_QUERY_PROVIDER_INFO,
                                        pIrp->MdlAddress);
            }
            else
            {
                TdiBuildQueryInformation(pIrp,
                                        pDeviceContext->pControlDeviceObject,
                                        pDeviceContext->pControlFileObject,
                                        QueryProviderCompletion,
                                        NULL,
                                        TDI_QUERY_PROVIDER_INFO,
                                        pIrp->MdlAddress);
            }

            CHECK_COMPLETION(pIrp);
            status = IoCallDriver(pDeviceContext->pControlDeviceObject,pIrp);
            //
            // we must return the next drivers ret code back to the IO subsystem
            //
            return(status);
        }

        case TDI_QUERY_ADAPTER_STATUS:
        {
            if (!pIrp->MdlAddress)
            {
                break;
            }

            Size = MmGetMdlByteCount (pIrp->MdlAddress);

            //
            // check if it is a remote or local adapter status
            //
            if (Query->RequestConnectionInformation &&
                Query->RequestConnectionInformation->RemoteAddress)
            {
                PCHAR                   pName;
                ULONG                   lNameType;
                ULONG                   NameLen;
                tDGRAM_SEND_TRACKING    *pTracker;
                TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;

                //
                //
                // in case the call results in a name query on the wire...
                //
                IoMarkIrpPending(pIrp);

                status = STATUS_SUCCESS;
                if (pIrp->RequestorMode != KernelMode) {
                    try
                    {
                        ProbeForRead(Query->RequestConnectionInformation->RemoteAddress,
                                 Query->RequestConnectionInformation->RemoteAddressLength,
                                 sizeof(BYTE));
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                }
                if (NT_SUCCESS(status) && NT_SUCCESS (status = GetNetBiosNameFromTransportAddress(
                                    (PTRANSPORT_ADDRESS) Query->RequestConnectionInformation->RemoteAddress,
                                    Query->RequestConnectionInformation->RemoteAddressLength, &TdiAddr)))
                {
                    pName = TdiAddr.OEMRemoteName.Buffer;
                    NameLen = TdiAddr.OEMRemoteName.Length;
                    lNameType = TdiAddr.NameType;
                    if ((lNameType == TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) &&
                        (NameLen == NETBIOS_NAME_SIZE) &&
                        (NT_SUCCESS (status = GetTracker(&pTracker, NBT_TRACKER_ADAPTER_STATUS))))
                    {
                        pTracker->ClientContext = pIrp;
                        status = NbtSendNodeStatus (pDeviceContext,
                                                    pName,
                                                    NULL,
                                                    pTracker,
                                                    CopyNodeStatusResponseCompletion);

                        // only complete the irp (below) for failure status's
                        if (status == STATUS_PENDING)
                        {
                            return(status);
                        }

                        //
                        // We cannot have a Success status returned here!
                        //
                        if (status == STATUS_SUCCESS)
                        {
                            ASSERT (0);
                            status = STATUS_UNSUCCESSFUL;
                        }

                        FreeTracker (pTracker, RELINK_TRACKER);
                    }
                    else if (NT_SUCCESS(status))
                    {
                        status = STATUS_INVALID_PARAMETER;  // The NameType or NameLen must be wrong!
                    }
                }

                // the request has been satisfied, so unmark the pending
                // since we will return the irp below
                //
                pIrpSp->Control &= ~SL_PENDING_RETURNED;
            }
            else
            {
                // return an array of netbios names that are registered
                status = NbtQueryAdapterStatus(pDeviceContext,
                                               &pBuffer,
                                               &Size,
                                               NBT_LOCAL);

            }
            break;
        }

        case TDI_QUERY_CONNECTION_INFO:
        {
            tCONNECTELE         *pConnectEle;
            tLOWERCONNECTION    *pLowerConn;
            KIRQL               OldIrq1, OldIrq2;

            // pass to transport to get the current throughput, delay and
            // reliability numbers
            //

            pConnectEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
            if (!NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
            {
                ASSERTMSG ("Nbt.NTQueryInformation: ERROR - Invalid Connection Handle\n", 0);
                status =  STATUS_INVALID_HANDLE;
                break;
            }

            CTESpinLock(pConnectEle, OldIrq1);

            pLowerConn = (tLOWERCONNECTION *)pConnectEle->pLowerConnId;
            if (!NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN))
            {
                status = STATUS_CONNECTION_INVALID;
                CTESpinFree(pConnectEle, OldIrq1);
                break;
            }

            CTESpinLock(pLowerConn, OldIrq2);
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_INFO);   // Bug # 212632
            CTESpinFree(pLowerConn, OldIrq2);
            CTESpinFree(pConnectEle, OldIrq1);

            //
            // Simply pass the Irp on by to the Transport, and let it
            // fill in the info
            //
            pDeviceObject = IoGetRelatedDeviceObject( pLowerConn->pFileObject );

            TdiBuildQueryInformation(pIrp,
                                    pDeviceObject,
                                    pLowerConn->pFileObject,
                                    NULL, NULL,
                                    TDI_QUERY_CONNECTION_INFO,
                                    pIrp->MdlAddress);


            status = IoCallDriver(pDeviceObject,pIrp);

            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_INFO, FALSE);
            //
            // we must return the next drivers ret code back to the IO subsystem
            //
            return(status);
        }

        case TDI_QUERY_FIND_NAME:
        {
            //
            //
            // in case the call results in a name query on the wire...
            //
            if (pIrp->MdlAddress)
            {
                //
                // Verify the request address space
                //
                try
                {
                    status = STATUS_INVALID_ADDRESS_COMPONENT;

                    if (pIrp->RequestorMode == KernelMode)
                    {
                        //
                        // Since the TdiBuildQueryInformation macro NULLs out the
                        // RequestConnectionInformation field, we need to dereference
                        // it under Try/Except to ensure that the caller has filled
                        // the fields in properly
                        //
                        PTRANSPORT_ADDRESS  pRemoteAddress=Query->RequestConnectionInformation->RemoteAddress;

                        if ((Query->RequestConnectionInformation->RemoteAddressLength
                                < sizeof(TRANSPORT_ADDRESS)) ||
                            (pRemoteAddress->TAAddressCount < 1) ||
                            (pRemoteAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_NETBIOS))
                        {
                            break;
                        }
                    }
                    else    // User-mode client
                    {
                        ProbeForRead(Query->RequestConnectionInformation->RemoteAddress,
                                     Query->RequestConnectionInformation->RemoteAddressLength,
                                     sizeof(BYTE));
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    KdPrint (("Nbt.TDI_QUERY_FIND_NAME: Exception <0x%x> during Probe\n",
                        GetExceptionCode()));
                    break;
                }

                IoMarkIrpPending(pIrp);
                status = NbtQueryFindName(Query->RequestConnectionInformation, pDeviceContext, pIrp, FALSE);

                if (status == STATUS_PENDING)
                {
                    return(status);
                }

                // the request has been satisfied, so unmark the pending
                // since we will return the irp below
                //
                pIrpSp->Control &= ~SL_PENDING_RETURNED;
            }

            break;
        }

        case TDI_QUERY_ADDRESS_INFO:
        {
            if (pIrp->MdlAddress)
            {
                status = NbtQueryGetAddressInfo (pIrpSp, &pBuffer, &Size);
            }
            break;
        }

        case TDI_QUERY_SESSION_STATUS:
        default:
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt Query Info NOT SUPPORTED = %X\n",Query->QueryType));
            status = STATUS_NOT_SUPPORTED;
            break;
        }
    }   // switch

    if (!NT_ERROR(status) &&        // allow buffer overflow to pass by
        ((Query->QueryType == TDI_QUERY_ADAPTER_STATUS) ||
        (Query->QueryType == TDI_QUERY_ADDRESS_INFO)))
    {
        status = TdiCopyBufferToMdl (pBuffer, 0, Size, pIrp->MdlAddress, 0, &BytesCopied);
        CTEMemFree((PVOID)pBuffer);
    }
    //
    // either Success or an Error
    // so complete the irp
    //

    NTIoComplete(pIrp,status,BytesCopied);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtQueryGetAddressInfo(
    IN PIO_STACK_LOCATION   pIrpSp,
    OUT PVOID               *ppBuffer,
    OUT ULONG               *pSize
    )
{
    NTSTATUS            status;
    BOOLEAN             IsGroup;
    PLIST_ENTRY         p;
    tADDRESSELE         *pAddressEle;
    tNAMEADDR           *pNameAddr;
    tADDRESS_INFO       *pAddressInfo;
    tCLIENTELE          *pClientEle;
    tCONNECTELE         *pConnectEle;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    PNBT_ADDRESS_PAIR_INFO pAddressPairInfo;

    //
    // We are not sure whether this is a ConnectionContext or a ClientContext!
    //
    pConnectEle = (tCONNECTELE *) pClientEle = pIrpSp->FileObject->FsContext;
    if (NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        //
        // We crashed here since the pLowerConn was NULL below.
        // Check the state of the connection, since it is possible that the connection
        // was aborted and the disconnect indicated, but this query came in before the client
        // got the disconnect indication.
        // If the state is idle (in case of TDI_DISCONNECT_ABORT) or DISCONNECTED
        // (TDI_DISCONNECT_RELEASE), error out.
        // Also check for NBT_ASSOCIATED.
        //
        // NOTE: If NbtOpenConnection is unable to allocate the lower conn block (say, if the session fileobj
        // has not been created yet), the state will be still be IDLE, so we are covered here.
        //
        CTESpinLock(pConnectEle,OldIrq);

        if (pConnectEle->Verify != NBT_VERIFY_CONNECTION)
        {
            CTESpinFree(pConnectEle,OldIrq);
            return (STATUS_INVALID_HANDLE);
        }
        else if ((pConnectEle->state <= NBT_ASSOCIATED) ||   // includes NBT_IDLE
                 (pConnectEle->state == NBT_DISCONNECTED))
        {
            CTESpinFree(pConnectEle,OldIrq);
            return (STATUS_CONNECTION_DISCONNECTED);
        }

        //
        // A TdiQueryInformation() call requesting TDI_QUERY_ADDRESS_INFO
        // on a connection.  Fill in a TDI_ADDRESS_INFO containing both the
        // NetBIOS address and the IP address of the remote.  Some of the
        // fields are fudged.
        //
        if (pAddressPairInfo = NbtAllocMem(sizeof (NBT_ADDRESS_PAIR_INFO), NBT_TAG('c')))
        {
            memset ( pAddressPairInfo, 0, sizeof(NBT_ADDRESS_PAIR_INFO) );

            pAddressPairInfo->ActivityCount = 1;
            pAddressPairInfo->AddressPair.TAAddressCount = 2;
            pAddressPairInfo->AddressPair.AddressIP.AddressType = TDI_ADDRESS_TYPE_IP;
            pAddressPairInfo->AddressPair.AddressIP.AddressLength = TDI_ADDRESS_LENGTH_IP;
            pAddressPairInfo->AddressPair.AddressNetBIOS.AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            pAddressPairInfo->AddressPair.AddressNetBIOS.AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
            pAddressPairInfo->AddressPair.AddressNetBIOS.Address.NetbiosNameType =
                TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            memcpy( &pAddressPairInfo->AddressPair.AddressNetBIOS.Address.NetbiosName[0],
                    &pConnectEle->RemoteName[0],
                    NETBIOS_NAME_SIZE);

            //
            // Check for NULL (should not be NULL here since we check for states above).
            //
            if (pConnectEle->pLowerConnId)
            {
                pAddressPairInfo->AddressPair.AddressIP.Address.in_addr =
                    pConnectEle->pLowerConnId->SrcIpAddr;

                *ppBuffer = (PVOID)pAddressPairInfo;
                *pSize = sizeof(NBT_ADDRESS_PAIR_INFO);
                status = STATUS_SUCCESS;
            }
            else
            {
                DbgPrint("pLowerConn NULL in pConnEle%lx, state: %lx\n", pConnectEle, pConnectEle->state);
                CTEMemFree ((PVOID)pAddressPairInfo);
                status = STATUS_CONNECTION_DISCONNECTED;
            }
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        CTESpinFree(pConnectEle,OldIrq);
    }
    else if (NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        pAddressInfo = NbtAllocMem(sizeof(tADDRESS_INFO),NBT_TAG('c'));
        if (pAddressInfo)
        {
            //
            // count the clients attached to this address
            // We need to spinlock the address element, which
            // is why this routine is not pageable
            //
            pAddressInfo->ActivityCount = 0;
            pAddressEle = pClientEle->pAddress;

            //
            // The Client can be removed from the AddressEle only under the JointLock,
            // so we need to hold that while counting the Clients on htis address
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            CTESpinLock(pAddressEle,OldIrq1);

            for (p = pAddressEle->ClientHead.Flink; p != &pAddressEle->ClientHead; p = p->Flink)
            {
                ++pAddressInfo->ActivityCount;
            }

            CTESpinFree(pAddressEle,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            pNameAddr = pAddressEle->pNameAddr;
            IsGroup = (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? FALSE : TRUE;
            TdiBuildNetbiosAddress((PUCHAR)pNameAddr->Name, IsGroup, &pAddressInfo->NetbiosAddress);

            *ppBuffer = (PVOID)pAddressInfo;
            *pSize = sizeof(tADDRESS_INFO);
            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else    // neither a client nor a connection context!
    {
        ASSERTMSG ("Nbt.NbtQueryGetAddressInfo: ERROR - Invalid Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtGetInterfaceInfo(
    IN PIRP pIrp
    )
/*++
Routine Description:

    gets the interface to index mapping info
    for all the interfaces


Arguments:

    Irp          - Pointer to I/O request packet to cancel.
    IrpSp        - pointer to current stack

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NTSTATUS                LocStatus, Status = STATUS_SUCCESS;
    ULONG                   InfoBufferLen, MaxSize, i=0;
    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    KIRQL                   OldIrq;
    PLIST_ENTRY             pEntry,pHead;
    tDEVICECONTEXT          *pDeviceContext;
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtGetInterfaceInfo: AdapterCount=<%x>\n", NbtConfig.AdapterCount));

    InfoBufferLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    MaxSize = (NbtConfig.AdapterCount+1)*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG);
    if (MaxSize <= InfoBufferLen)
    {
        if (pInterfaceInfo = NbtAllocMem (MaxSize,NBT_TAG('P')))
        {
            pEntry = pHead = &NbtConfig.DeviceContexts;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                pDeviceContext = CONTAINING_RECORD(pEntry, tDEVICECONTEXT, Linkage);
                CTEMemCopy (&pInterfaceInfo->Adapter[i].Name,
                            pDeviceContext->ExportName.Buffer,
                            pDeviceContext->ExportName.Length);
                pInterfaceInfo->Adapter[i].Name[pDeviceContext->ExportName.Length/2] = 0;
                pInterfaceInfo->Adapter[i].Index = i;
                i++;
            }
            pInterfaceInfo->NumAdapters = i;

            Status = TdiCopyBufferToMdl (pInterfaceInfo,
                                         0,
                                         i*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG),
                                         pIrp->MdlAddress,
                                         0,
                                         (PULONG)&pIrp->IoStatus.Information);

            CTEMemFree (pInterfaceInfo);
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        //KdPrint(("GetInterfaceInfo Buffer Overflow %x\n", pIrp));
        //pIrp->IoStatus.Information = sizeof(ULONG);
        Status = STATUS_BUFFER_OVERFLOW;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //KdPrint(("GetInterfaceInfo exit status %x\n", Status));
    return Status;
}



//----------------------------------------------------------------------------
NTSTATUS
NbtFlushEntryFromRemoteHashTable(
    tNAME   *pRemoteName
    )
{
    NTSTATUS    status;
    KIRQL       OldIrq;
    tNAMEADDR   *pNameAddr = NULL;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    status = FindInHashTable (NbtConfig.pRemoteHashTbl, pRemoteName->Name, NbtConfig.pScope, &pNameAddr);
    if (NT_SUCCESS (status))
    {
        if (pNameAddr->RefCount <= 1)
        {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        status = STATUS_RESOURCE_NAME_NOT_FOUND;
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
SetTcpInfo(
    IN HANDLE       FileHandle,
    IN PVOID        pInfoBuffer,
    IN ULONG        InfoBufferLength
    )
{
    IO_STATUS_BLOCK     IoStatus;
    HANDLE              event;
    BOOLEAN             fAttached = FALSE;
    NTSTATUS            status;

    CTEAttachFsp(&fAttached, REF_FSP_SET_TCP_INFO);

    status = ZwCreateEvent (&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (NT_SUCCESS(status))
    {
        //
        // Make the actual TDI call
        //
        status = ZwDeviceIoControlFile (FileHandle,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_SET_INFORMATION_EX,
                                        pInfoBuffer,
                                        InfoBufferLength,
                                        NULL,
                                        0);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if (status == STATUS_PENDING)
        {
            status = NtWaitForSingleObject (event, FALSE, NULL);

            ASSERT(status == STATUS_SUCCESS);
        }

        status = ZwClose (event);
        ASSERT (NT_SUCCESS(status));

        status = IoStatus.Status;
    }

    CTEDetachFsp(fAttached, REF_FSP_SET_TCP_INFO);

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtClientSetTcpInfo(
    IN tCONNECTELE  *pConnEle,
    IN PVOID        pInfoBuffer,
    IN ULONG        InfoBufferLength
    )
/*++
Routine Description:

    Sets the Tcp connection information as requested
    by the client

Arguments:

    pConnEle        - NetBT's Connection object
    pInfoBuffer     - pointer to  TCP_REQUEST_SET_INFORMATION_EX structure
    pInfoBufferLength   - length of pInfoBuffer

Return Value:

    NTSTATUS Indicates status success or failure

Notes:

    Function does not pend.

--*/
{
    NTSTATUS            status;
    tLOWERCONNECTION    *pLowerConn;
    KIRQL               OldIrq1, OldIrq2;

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        return STATUS_INVALID_HANDLE;
    }

    CTESpinLock(pConnEle, OldIrq1);

    if ((!NBT_VERIFY_HANDLE ((pLowerConn = pConnEle->pLowerConnId), NBT_VERIFY_LOWERCONN)) ||
        (pLowerConn->RefCount > 500))                               // if queued for WipeOutLowerConn
    {
        CTESpinFree(pConnEle, OldIrq1);
        return STATUS_BAD_NETWORK_PATH;
    }

    CTESpinLock(pLowerConn, OldIrq2);

    //
    // We have verified that the lower connection is up -- reference it
    // so that the FileObject does not get Dereferenced by some disconnect
    // from the transport
    //
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SET_TCP_INFO);

    CTESpinFree(pLowerConn, OldIrq2);
    CTESpinFree(pConnEle, OldIrq1);

    status = SetTcpInfo (pLowerConn->FileHandle, pInfoBuffer, InfoBufferLength);

    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SET_TCP_INFO, FALSE);

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN ULONG        ToiType,
    IN ULONG        InfoBufferValue
    )
{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    TCP_REQUEST_SET_INFORMATION_EX  *pTcpInfo;
    TCPSocketOption                 *pSockOption;

    BufferLength = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(TCPSocketOption);
    if (!(pTcpInfo = (TCP_REQUEST_SET_INFORMATION_EX *) NbtAllocMem (BufferLength,NBT_TAG2('22'))))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    CTEZeroMemory(pTcpInfo, BufferLength);
    pSockOption = (TCPSocketOption *) (&pTcpInfo->Buffer[0]);

    pTcpInfo->ID.toi_entity.tei_entity  = CO_TL_ENTITY;
    pTcpInfo->ID.toi_class              = INFO_CLASS_PROTOCOL;
    pTcpInfo->BufferSize                = sizeof (TCPSocketOption);

    //
    // Set the Configured values
    //
    pTcpInfo->ID.toi_id                 = ToiId;
    pTcpInfo->ID.toi_type               = ToiType;
    pSockOption->tso_value              = InfoBufferValue;

    Status = SetTcpInfo (FileHandle, pTcpInfo, BufferLength);
    if (!NT_SUCCESS(Status))
    {
        KdPrint (("Nbt.NbtSetTcpInfo: SetTcpInfo FAILed <%x>, Id=<0x%x>, Type=<0x%x>, Value=<%x>\n",
            Status, ToiId, ToiType, InfoBufferValue));
    }

    CTEMemFree (pTcpInfo);

    return (Status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSetSmbBindingInfo2(
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  NETBT_SMB_BIND_REQUEST  *pSmbRequest
    )
{
    ULONG                   i, Operation;
    PLIST_ENTRY             pEntry,pHead;
    KIRQL                   OldIrq;
    ULONG                   NumBindings = 0;
    CTEULONGLONG            AddedAdapterMask = 0;
    CTEULONGLONG            DeletedAdapterMask = 0;
    CTEULONGLONG            BindListAdapterMask = 0;
    CTEULONGLONG            OriginalMask;
    tDEVICECONTEXT          *pDeviceContextBind = NULL;
    if (!IsDeviceNetbiosless (pDeviceContext)) {
        return (STATUS_UNSUCCESSFUL);
    }

    if (NULL == pSmbRequest) {
        return STATUS_INVALID_PARAMETER;
    }

    if (pSmbRequest->RequestType == SMB_SERVER) {
        OriginalMask = NbtConfig.ServerMask;
    } else if (pSmbRequest->RequestType == SMB_CLIENT) {
        OriginalMask = NbtConfig.ClientMask;
    } else {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }
    if (pSmbRequest->MultiSZBindList)
    {
        NTSTATUS    status;
        tDEVICES    *pBindings = NULL;
        ULONG       MaxBindings;

        MaxBindings = NBT_MAXIMUM_BINDINGS;
        while (MaxBindings < 5000) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            MaxBindings *= 2;
            pBindings = NbtAllocMem ((sizeof(tDEVICES)+MaxBindings*sizeof(UNICODE_STRING)), NBT_TAG2('26'));
            if (pBindings == NULL) {
                break;
            }
            NumBindings = 0;
            status = NbtParseMultiSzEntries (pSmbRequest->MultiSZBindList, (PVOID)(-1), MaxBindings, pBindings, &NumBindings);

            if (status != STATUS_BUFFER_OVERFLOW) {
                break;
            }

            CTEMemFree (pBindings);
            pBindings = NULL;
        }

        if (status != STATUS_SUCCESS) {
            if (pBindings) {        // NbtParseMultiSzEntries can return failure other than STATUS_BUFFER_OVERFLOW
                CTEMemFree (pBindings);
            }
            KdPrint(("Nbt.NbtSetSmbBindingInfo[STATUS_INSUFFICIENT_RESOURCES]: MaxBindings = <%d>\n",
                MaxBindings));
            return status;
        }
        ASSERT(pBindings);

        //
        // First, get the complete list of all bindings
        //
        for (i=0; i<NumBindings; i++)
        {
            if (pDeviceContextBind = NbtFindAndReferenceDevice (&pBindings->Names[i], FALSE))
            {
                BindListAdapterMask |= pDeviceContextBind->AdapterMask;
                NBT_DEREFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, FALSE);
            }
        }

        CTEMemFree (pBindings);
    }
    else if (pSmbRequest->pDeviceName)
    {
        KdPrint (("Nbt.NbtSetSmbBindingInfo[WARNING]: NULL MultiSZBindList string!\n"));
        BindListAdapterMask = OriginalMask;

        if (pDeviceContextBind = NbtFindAndReferenceDevice (pSmbRequest->pDeviceName, FALSE))
        {
            switch (pSmbRequest->PnPOpCode)
            {
                case (TDI_PNP_OP_ADD):
                {
                    BindListAdapterMask |= pDeviceContextBind->AdapterMask;

                    break;
                }

                case (TDI_PNP_OP_DEL):
                {
                    BindListAdapterMask &= (~pDeviceContextBind->AdapterMask);
                    break;
                }

                default:
                {
                    break;
                }
            }

            NBT_DEREFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, FALSE);
        }
        else
        {
            return (STATUS_SUCCESS);
        }
    }
    else
    {
        ASSERTMSG ("Nbt.NbtSetSmbBindingInfo[ERROE]: NULL MultiSZBindList and NULL pDeviceName!\n", 0);
        return (STATUS_UNSUCCESSFUL);
    }

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("Nbt.NbtSetSmbBindingInfo: PnPOpCode=<%x>, Bindings=<%d>, BindMask=[%lx:%lx]==>[%lx:%lx]\n",
            pSmbRequest->PnPOpCode, NumBindings, OriginalMask, BindListAdapterMask));

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    AddedAdapterMask = BindListAdapterMask & (~OriginalMask);   // Devices Added
    DeletedAdapterMask = OriginalMask & (~BindListAdapterMask); // Devices Removed

    if ((!AddedAdapterMask) && (!DeletedAdapterMask))
    {
        //
        // If there are no adapters to be added or deleted, just return
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return (STATUS_SUCCESS);
    }

    if (pSmbRequest->RequestType == SMB_SERVER) {
        NbtConfig.ServerMask = BindListAdapterMask;
    } else if (pSmbRequest->RequestType == SMB_CLIENT) {
        NbtConfig.ClientMask = BindListAdapterMask;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return STATUS_SUCCESS;
    } else {
        ASSERT(0);
    }

    pEntry = pHead = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContextBind = CONTAINING_RECORD(pEntry, tDEVICECONTEXT, Linkage);
        if (pDeviceContext->IPInterfaceContext == (ULONG)-1)    // For Cluster devices, etc
        {
            continue;
        }

        if (AddedAdapterMask & pDeviceContextBind->AdapterMask)
        {
            AddedAdapterMask &= ~(pDeviceContextBind->AdapterMask);
            Operation = AO_OPTION_ADD_IFLIST;
        }
        else if (DeletedAdapterMask & pDeviceContextBind->AdapterMask)
        {
            DeletedAdapterMask &= ~(pDeviceContextBind->AdapterMask);
            Operation = AO_OPTION_DEL_IFLIST;
        }
        else
        {
            continue;
        }

        NBT_REFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtSetSmbBindingInfo:  %sing Device=%wZ\n",
                (Operation == AO_OPTION_ADD_IFLIST ? "ADD" : "REMOV"), &pDeviceContextBind->BindName));

        //
        // Set the Session port info
        //
        if (pDeviceContext->hSession)
        {
            NbtSetTcpInfo (pDeviceContext->hSession,
                           Operation,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContextBind->IPInterfaceContext);
        }

        //
        // Now, set the same for the Datagram port
        //
        if ((pDeviceContext->pFileObjects) &&
            (pDeviceContext->pFileObjects->hDgram))
        {
            NbtSetTcpInfo (pDeviceContext->pFileObjects->hDgram,
                            Operation,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContextBind->IPInterfaceContext);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_DEVICE (pDeviceContextBind, REF_DEV_FIND_REF, TRUE);

        //
        // Set to restart from the beginning
        //
        pEntry = &NbtConfig.DeviceContexts;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return STATUS_SUCCESS;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSetSmbBindingInfo(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
{
    NETBT_SMB_BIND_REQUEST  *pSmbRequest = (PNETBT_SMB_BIND_REQUEST)pIrp->AssociatedIrp.SystemBuffer;
    PWSTR                   pBindListCache = NULL;
    PWSTR                   pBindList = NULL;
    PWSTR                   pOldBindList   = NULL;
    PWSTR                   *pTarget   = NULL;
    ULONG                   uInputLength = 0;
    ULONG                   uLength = 0;
    NTSTATUS                status = STATUS_SUCCESS;

    uInputLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (!(IsDeviceNetbiosless (pDeviceContext)) ||
        (!pSmbRequest) ||
        (uInputLength < sizeof(NETBT_SMB_BIND_REQUEST)))
    {
        KdPrint(("Nbt.NbtSetSmbBindingInfo: ERROR: pSmbRequest=<%p>, pDevice=<%p>\n",
            pSmbRequest, pDeviceContext));

        return (STATUS_UNSUCCESSFUL);
    }

    if (pIrp->RequestorMode != KernelMode) {
        return STATUS_ACCESS_DENIED;
    }

    status = NbtSetSmbBindingInfo2 (pDeviceContext, pSmbRequest);

    if (NT_SUCCESS(status) && pSmbRequest->MultiSZBindList) {

        //
        // Cache the binding info
        //

        pBindList = pSmbRequest->MultiSZBindList;
        uInputLength = 0;
        while (*pBindList) {
            uLength = wcslen (pBindList) + 1;
            uInputLength += uLength;
            pBindList += uLength;
        }
        uInputLength++;
        uInputLength *= sizeof(WCHAR);
        pBindList = pSmbRequest->MultiSZBindList;

        if (pSmbRequest->RequestType == SMB_SERVER) {
            pTarget = &NbtConfig.pServerBindings;
        } else if (pSmbRequest->RequestType == SMB_CLIENT) {
            pTarget = &NbtConfig.pClientBindings;
        } else {
            ASSERT(0);
        }

        pBindListCache = NbtAllocMem (uInputLength, NBT_TAG2('27'));
        if (NULL != pBindListCache) {

            RtlCopyMemory (pBindListCache, pBindList, uInputLength);
            pOldBindList = InterlockedExchangePointer (pTarget, pBindListCache);

            //
            // Free the old copy if any
            //
            if (NULL != pOldBindList) {
                CTEFreeMem (pOldBindList);
                pOldBindList = NULL;
            }

        }
    }

    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
DispatchIoctls(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++
Routine Description:

    This Routine handles calling the OS independent routine depending on
    the Ioctl passed in.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                                status=STATUS_UNSUCCESSFUL;
    ULONG                                   ControlCode;
    ULONG                                   Size;
    PVOID                                   pBuffer;

    ControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch (ControlCode)
    {
    case IOCTL_NETBT_REREAD_REGISTRY:
        {
            status = NTReReadRegistry(pDeviceContext);
            break;
        }

    case IOCTL_NETBT_ENABLE_EXTENDED_ADDR:
        {
            //
            // Enable extended addressing - pass up IP addrs on Datagram Recvs.
            //
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);
            tCLIENTELE  *pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

            if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
            {
                //
                // To make the stresser (devctl.exe) happy.  [JRuan 12/18/2000]
                //
                // ASSERTMSG ("Nbt.DispatchIoctls: ERROR - Invalid Address Handle\n", 0);
                status = STATUS_INVALID_HANDLE;
            }
            else if (pIrpSp->FileObject->FsContext2 != (PVOID)NBT_ADDRESS_TYPE)
            {
                status = STATUS_INVALID_ADDRESS;
            }
            else
            {
                pClientEle->ExtendedAddress = TRUE;
                status = STATUS_SUCCESS;
            }

            break;
        }

    case IOCTL_NETBT_DISABLE_EXTENDED_ADDR:
        {
            //
            // Disable extended addressing - dont pass up IP addrs on Datagram Recvs.
            //
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);
            tCLIENTELE  *pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

            if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
            {
//                ASSERTMSG ("Nbt.DispatchIoctls: ERROR - Invalid Address Handle\n", 0);
                status = STATUS_INVALID_HANDLE;
            }
            else if (pIrpSp->FileObject->FsContext2 != (PVOID)NBT_ADDRESS_TYPE)
            {
                status = STATUS_INVALID_ADDRESS;
            }
            else
            {
                pClientEle->ExtendedAddress = FALSE;
                status = STATUS_SUCCESS;
            }

            break;
        }

    case IOCTL_NETBT_GET_WINS_ADDR:
        {
            if ((pIrp->MdlAddress) &&
                ((Size = MmGetMdlByteCount (pIrp->MdlAddress)) >= sizeof(tWINS_ADDRESSES)) &&
                (pBuffer = (PVOID) MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, HighPagePriority)))
            {
                status = STATUS_SUCCESS;
                if (Size >= sizeof(tWINS_NODE_INFO))
                {
                    tWINS_NODE_INFO UNALIGNED *pWinsBuffer = (tWINS_NODE_INFO *) pBuffer;

                    CTEMemCopy (&pWinsBuffer->AllNameServers,
                                pDeviceContext->lAllNameServers,
                                (sizeof(tIPADDRESS)*(2+MAX_NUM_OTHER_NAME_SERVERS)));

                    pWinsBuffer->NumOtherServers = pDeviceContext->lNumOtherServers;
                    pWinsBuffer->LastResponsive = pDeviceContext->lLastResponsive;
                    pWinsBuffer->NetbiosEnabled = pDeviceContext->NetbiosEnabled;
                    pWinsBuffer->NodeType = NodeType;
                    pIrp->IoStatus.Information = sizeof(tWINS_NODE_INFO);
                }
                else
                {
                    tWINS_ADDRESSES UNALIGNED *pWinsBuffer = (tWINS_ADDRESSES *) pBuffer;

                    pWinsBuffer->PrimaryWinsServer = pDeviceContext->lNameServerAddress;
                    pWinsBuffer->BackupWinsServer = pDeviceContext->lBackupServer;
                    pIrp->IoStatus.Information = sizeof(tWINS_ADDRESSES);
                }
            }

            break;
        }

    case IOCTL_NETBT_GET_IP_ADDRS:
        {
            status = GetIpAddrs (pDeviceContext, pIrp);
            break;
        }

    case IOCTL_NETBT_GET_IP_SUBNET:
        {
            ULONG           Length;
            PULONG          pIpAddr;

            //
            // return this devicecontext's ip address and all the other
            // ip addrs after it.
            //
            if (pIrp->MdlAddress)
            {
                Length = MmGetMdlByteCount( pIrp->MdlAddress );
                if (Length < 2*sizeof(ULONG))
                {
                    status = STATUS_BUFFER_OVERFLOW;
                }
                else if (pIpAddr = (PULONG )MmGetSystemAddressForMdlSafe(pIrp->MdlAddress, HighPagePriority))
                {
                    //
                    // Put this adapter first in the list
                    //
                    CTEMemCopy(pIpAddr, &pDeviceContext->AssignedIpAddress, sizeof(pIpAddr[0]));
                    pIpAddr++;
                    CTEMemCopy(pIpAddr, &pDeviceContext->SubnetMask, sizeof(pIpAddr[0]));
                    pIpAddr++;
                    if (Length >= 3*sizeof(ULONG))
                    {
                        CTEMemCopy(pIpAddr, &pDeviceContext->DeviceType, sizeof(pIpAddr[0]));
                    }

                    status = STATUS_SUCCESS;
                }
            }

            break;
        }

    //
    // The following Ioctl is used mainly by the Server service
    //
    case IOCTL_NETBT_SET_TCP_CONNECTION_INFO:
        {
            status = NbtClientSetTcpInfo ((tCONNECTELE *) pIrpSp->FileObject->FsContext,
                                          pIrp->AssociatedIrp.SystemBuffer,
                                          pIrpSp->Parameters.DeviceIoControl.InputBufferLength);
            break;
        }

    //
    // The following Ioctls are used mainly by NbtStat.exe for diagnostic purposes
    //
    case IOCTL_NETBT_GET_INTERFACE_INFO:
        {
            status = NbtGetInterfaceInfo (pIrp);
            break;
        }

    case IOCTL_NETBT_PURGE_CACHE:
        {
            DelayedNbtResyncRemoteCache (NULL, NULL, NULL, NULL);
            status = STATUS_SUCCESS;
            break;
        }

    case IOCTL_NETBT_GET_CONNECTIONS:
        {
            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

                // return an array of netbios names that are registered
                status = NbtQueryConnectionList (pDeviceContext, &pBuffer, &Size);
            }
            break;
        }

    case IOCTL_NETBT_ADAPTER_STATUS:
        {
            if (pIrp->MdlAddress)
            {
                PIO_STACK_LOCATION      pIrpSp;
                tIPANDNAMEINFO         *pIpAndNameInfo;
                PCHAR                   pName;
                ULONG                   lNameType;
                ULONG                   NameLen;
                ULONG                   IpAddrsList[2];
                tIPADDRESS              *pIpAddrs = NULL;
                tDGRAM_SEND_TRACKING    *pTracker;

                //
                // in case the call results in a name query on the wire...
                //
                IoMarkIrpPending(pIrp);

                pIrpSp   = IoGetCurrentIrpStackLocation(pIrp);
                pIpAndNameInfo = pIrp->AssociatedIrp.SystemBuffer;
                NameLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength
                            - FIELD_OFFSET(tIPANDNAMEINFO,NetbiosAddress);

                //
                // Bug# 125288+120947:  Make sure the data passed in + the Address type are good
                //
                if ((pIpAndNameInfo) &&
                    (pIrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(tIPANDNAMEINFO)))
                {
                    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
                    // this routine gets a ptr to the netbios name out of the wierd
                    // TDI address syntax.
                    status = GetNetBiosNameFromTransportAddress(
                                            (PTRANSPORT_ADDRESS) &pIpAndNameInfo->NetbiosAddress,
                                            NameLen, &TdiAddr);
                    pName = TdiAddr.OEMRemoteName.Buffer;
                    NameLen = TdiAddr.OEMRemoteName.Length;
                    lNameType = TdiAddr.NameType;
                }

                if (NT_SUCCESS(status) &&
                     (lNameType == TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) &&
                     (NameLen == NETBIOS_NAME_SIZE))
                {
                    //
                    // Nbtstat sends down * in the first byte on Nbtstat -A <IP address>
                    // Make sure we let that case go ahead.
                    //
                    if (!pDeviceContext->NetbiosEnabled) {
                        status = STATUS_INVALID_DEVICE_STATE;
                    }
                    else if ((pName[0] == '*') && (pIpAndNameInfo->IpAddress == 0))
                    {
                        status = STATUS_BAD_NETWORK_PATH;
                    }
                    else if (NT_SUCCESS (status = GetTracker(&pTracker, NBT_TRACKER_ADAPTER_STATUS)))
                    {
                        if (pIpAndNameInfo->IpAddress)
                        {
                            IpAddrsList[0] = pIpAndNameInfo->IpAddress;
                            IpAddrsList[1] = 0;
                            pIpAddrs = IpAddrsList;
                        }

                        pTracker->ClientContext = pIrp;
                        status = NbtSendNodeStatus(pDeviceContext,
                                                   pName,
                                                   pIpAddrs,
                                                   pTracker,
                                                   CopyNodeStatusResponseCompletion);

                        // only complete the irp (below) for failure status's
                        if (status == STATUS_PENDING)
                        {
                            return(status);
                        }

                        //
                        // We cannot have a Success status returned here!
                        //
                        if (status == STATUS_SUCCESS)
                        {
                            ASSERT (0);
                            status = STATUS_UNSUCCESSFUL;
                        }

                        FreeTracker (pTracker, RELINK_TRACKER);
                    }
                }
                else if (NT_SUCCESS(status))
                {
                    status = STATUS_INVALID_PARAMETER;  // The NameType or NameLen must be wrong!
                }

                // the request has been satisfied, so unmark the pending
                // since we will return the irp below
                //
                pIrpSp->Control &= ~SL_PENDING_RETURNED;

            }

            break;
        }

    case IOCTL_NETBT_GET_REMOTE_NAMES:
        {
            if (pIrp->MdlAddress)
            {
               Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

               // return an array of netbios names that are registered
               status = NbtQueryAdapterStatus(pDeviceContext, &pBuffer, &Size, NBT_REMOTE);
            }
            break;
        }

    case IOCTL_NETBT_GET_BCAST_NAMES:
        {
            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

                // return an array of netbios names that are registered
                status = NbtQueryBcastVsWins(pDeviceContext,&pBuffer,&Size);
            }
            break;
        }

    case IOCTL_NETBT_NAME_RELEASE_REFRESH:
        {
            status = ReRegisterLocalNames (NULL, TRUE);
            break;
        }

    //
    // The following Ioctls are used by the Cluster code
    //
    case IOCTL_NETBT_ADD_INTERFACE:
        {
            //
            // Creates a dummy devicecontext which can be primed by the layer above
            // with a DHCP address. This is to support multiple IP addresses per adapter
            // for the Clusters group; but can be used by any module that needs support
            // for more than one IP address per adapter. This private interface hides the
            // devices thus created from the setup/regisrty and that is fine since the
            // component (say, the clusters client) takes the responsibility for ensuring
            // that the server (above us) comes to know of this new device.
            //
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);
            pBuffer = pIrp->AssociatedIrp.SystemBuffer;
            Size = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            //
            // return the export string created.
            //
            status = NbtAddNewInterface(pIrp, pBuffer, Size);

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.DispatchIoctls: ADD_INTERFACE -- status=<%x>\n", status));

            NTIoComplete(pIrp,status,(ULONG)-1);
            return status;
        }

    case IOCTL_NETBT_DELETE_INTERFACE:
        {
            //
            // Dereference this device for the Reference taken in the
            // Dispatch routine so that the cleanup can proceed properly
            //
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            if (pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER)
            {
                //
                // Delete the device this came down on..
                //
                status = NbtDestroyDevice (pDeviceContext, TRUE);
            }
            else
            {
                KdPrint(("Nbt.DispatchIoctls: ERROR: DELETE_INTERFACE <%x>, pDevice=<%p>\n",
                    status, pDeviceContext));
            }
            break;
        }

    case IOCTL_NETBT_QUERY_INTERFACE_INSTANCE:
        {
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            if (Size < sizeof(NETBT_ADD_DEL_IF))
            {
                // IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.DispatchIoctls:  QUERY_INTERFACE_INSTANCE: Output buffer too small\n"));
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                PNETBT_ADD_DEL_IF   pAddDelIf = (PNETBT_ADD_DEL_IF)pIrp->AssociatedIrp.SystemBuffer;
                status = STATUS_SUCCESS;

                ASSERT(pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER);
                pAddDelIf->InstanceNumber = pDeviceContext->InstanceNumber;
                pAddDelIf->Status = status;
                pIrp->IoStatus.Information = sizeof(NETBT_ADD_DEL_IF);

                NTIoComplete(pIrp,status,(ULONG)-1);
                return status;
            }

            break;
        }

    case IOCTL_NETBT_NEW_IPADDRESS:
        {
            tNEW_IP_ADDRESS *pNewAddress = (tNEW_IP_ADDRESS *)pIrp->AssociatedIrp.SystemBuffer;

            status = STATUS_UNSUCCESSFUL;
            //
            // Bug# 202320:  Make sure the data passed in is valid
            //
            if ((pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER) &&
                (pNewAddress) &&
                (pIrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(tNEW_IP_ADDRESS)))
            {
                KdPrint (("Nbt.DispatchIoctls: Calling NbtNewDhcpAddress on ClusterDevice <%x>!\n",
                    pDeviceContext));

                pDeviceContext->AssignedIpAddress = ntohl (pNewAddress->IpAddress);
                status = NbtNewDhcpAddress (pDeviceContext, pNewAddress->IpAddress, pNewAddress->SubnetMask);
                ASSERT (pDeviceContext->AssignedIpAddress == pDeviceContext->IpAddress);

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.DispatchIoctls: NEW_IPADDRESS, status=<%x>, IP=<%x>, pDevice=<%p>\n",
                        status, pNewAddress->IpAddress, pDeviceContext));
            }
            else
            {
                KdPrint(("Nbt.DispatchIoctls: ERROR: NEW_IPADDRESS status=<%x>, pDevice=<%p>\n",
                    status, pDeviceContext));
            }

            break;
        }

    case IOCTL_NETBT_SET_WINS_ADDRESS:
        {
            //
            // Sets the WINS addresses for a dynamic adapter
            //
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
            if (Size < sizeof(NETBT_SET_WINS_ADDR))
            {
                // IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("NbtSetWinsAddr: Input buffer too small for struct\n"));
                status = STATUS_INVALID_PARAMETER;
            }
            else if (pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER)
            {
                PNETBT_SET_WINS_ADDR   pSetWinsAddr = (PNETBT_SET_WINS_ADDR)pIrp->AssociatedIrp.SystemBuffer;
                status = STATUS_SUCCESS;

                pDeviceContext->lNameServerAddress = pSetWinsAddr->PrimaryWinsAddr;
                pDeviceContext->lBackupServer = pSetWinsAddr->SecondaryWinsAddr;
                pDeviceContext->SwitchedToBackup = 0;
                pDeviceContext->RefreshToBackup = 0;

                pSetWinsAddr->Status = status;
                pIrp->IoStatus.Information = 0;     // We are not copying any data to the Output buffers

                NTIoComplete (pIrp,status,(ULONG)-1);
                return status;
            }
            else
            {
                KdPrint(("Nbt.DispatchIoctls: ERROR: SET_WINS_ADDRESS <%x>, pDevice=<%p>\n",
                    status, pDeviceContext));
            }

            break;
        }

    //
    // The following Ioctls are used by the LmHost Services Dll (lmhSvc.dll) to
    // help NetBT ping addresses in user space or resolve names in Dns
    //
    case IOCTL_NETBT_DNS_NAME_RESOLVE:
        {
            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;

                if (Size < sizeof (tIPADDR_BUFFER_DNS))
                {
                    // IF_DBG(NBT_DEBUG_PNP_POWER)
                        KdPrint(("Nbt.DnsNameResolve: Input buffer size=<%d> < tIPADDR_BUFFER_DNS=<%d>\n",
                            Size,  sizeof (tIPADDR_BUFFER_DNS)));
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))
                {
                    // return an array of netbios names that are registered
                    status = NtProcessLmHSvcIrp (pDeviceContext,pBuffer,Size,pIrp,NBT_RESOLVE_WITH_DNS);
                    return(status);
                }
            }

            break;
        }

    case IOCTL_NETBT_CHECK_IP_ADDR:
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Ioctl Value is %X (IOCTL_NETBT_CHECK_IP_ADDR)\n",ControlCode));

            if (pIrp->MdlAddress)
            {
                Size = MmGetMdlByteCount( pIrp->MdlAddress ) ;
                if (Size < sizeof (tIPADDR_BUFFER_DNS))
                {
                    // IF_DBG(NBT_DEBUG_PNP_POWER)
                        KdPrint(("Nbt.CheckIpAddr: Input buffer size=<%d> < tIPADDR_BUFFER_DNS=<%d>\n",
                            Size,  sizeof (tIPADDR_BUFFER_DNS)));
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))
                {

                    // return an array of netbios names that are registered
                    status = NtProcessLmHSvcIrp (pDeviceContext,pBuffer,Size,pIrp,NBT_PING_IP_ADDRS);
                    return(status);
                }
            }

            break;
        }

    //
    // The following Ioctl is used by the DNS resolver to resolve names through Wins/Bcast
    //
    case IOCTL_NETBT_FIND_NAME:
        {
            tIPADDR_BUFFER   *pIpAddrBuffer;
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // in case the call results in a name query on the wire...
            //
            IoMarkIrpPending(pIrp);

            //
            // Bug# 120957:  Make sure the data passed in + the Address type are good
            // Bug# 234627:  Verify non-NULL MdlAddress ptr
            //
            pIpAddrBuffer = pIrp->AssociatedIrp.SystemBuffer;
            if ((pIrp->MdlAddress) &&   // to copy the data back!
                (pIpAddrBuffer) &&
                (pIrpSp->Parameters.DeviceIoControl.InputBufferLength >= sizeof(tIPADDR_BUFFER)))
            {
                status = NbtQueryFindName((PTDI_CONNECTION_INFORMATION)pIpAddrBuffer,
                                      pDeviceContext,
                                      pIrp,
                                      TRUE);
            }

            if (status == STATUS_PENDING)
            {
                return(status);
            }

            // the request has been satisfied, so unmark the pending
            // since we will return the irp below
            //
            pIrpSp->Control &= ~SL_PENDING_RETURNED;

            break;
        }

    //
    // The following Ioctls are used by the Wins server
    //
    case IOCTL_NETBT_WINS_RCV:
        {
            tWINS_INFO      *pWins = pIrpSp->FileObject->FsContext;

            if ((pDeviceContext == pWinsDeviceContext) &&
                (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)))
            {
                if (pIrp->MdlAddress)
                {
                    status = RcvIrpFromWins(pIrp);
                    return(status);
                }
            }
            else
            {
                status = STATUS_INVALID_HANDLE;
            }

            break;
        }

    case IOCTL_NETBT_WINS_SEND:
        {
            tWINS_INFO      *pWins = pIrpSp->FileObject->FsContext;
            BOOLEAN         MustSend;

            if ((pDeviceContext == pWinsDeviceContext) &&
                (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)))
            {
                if ((pIrp->MdlAddress) && !(IsListEmpty(&NbtConfig.DeviceContexts)))
                {
                    status = WinsSendDatagram (pDeviceContext,pIrp,(MustSend = FALSE));
                    return(status);
                }
            }
            else
            {
                status = STATUS_INVALID_HANDLE;
            }

            break;
        }

    case IOCTL_NETBT_WINS_SET_INFO:
        {
            tWINS_INFO      *pWins = pIrpSp->FileObject->FsContext;
            tWINS_SET_INFO  *pWinsSetInfo = (tWINS_SET_INFO *) pIrp->AssociatedIrp.SystemBuffer;

            if ((pDeviceContext == pWinsDeviceContext) &&
                (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)))
            {
                //
                // Validate input/output buffer size
                //
                Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
                if (Size >= sizeof(tWINS_SET_INFO))
                {
                    status = WinsSetInformation (pWins, pWinsSetInfo);
                }
                else
                {
                    IF_DBG(NBT_DEBUG_WINS)
                        KdPrint(("Nbt.DispatchIoctls[IOCTL_NETBT_WINS_SET_INFO]: Input buffer too small\n"));
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            else
            {
                status = STATUS_INVALID_HANDLE;
            }

            break;
        }

    //
    // The following Ioctl is used by the Remote boot code
    //
    case IOCTL_NETBT_ADD_TO_REMOTE_TABLE:
        {
            tREMOTE_CACHE  *pRemoteEntry = (tREMOTE_CACHE *) pIrp->AssociatedIrp.SystemBuffer;
            PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
            if (Size >= sizeof(tREMOTE_CACHE))
            {
                //
                // We need only the name, IpAddress, name_flags, and Ttl fields
                //
                status = NbtAddEntryToRemoteHashTable (pDeviceContext,
                                                       NAME_RESOLVED_BY_CLIENT,
                                                       pRemoteEntry->name,
                                                       pRemoteEntry->IpAddress,
                                                       pRemoteEntry->Ttl,
                                                       pRemoteEntry->name_flags);
            }
            else
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.DispatchIoctls[IOCTL_NETBT_ADD_TO_REMOTE_TABLE]: Input buffer too small for struct\n"));
                status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

    //
    // The following Ioctl is used by DsGetDcName
    //
    case IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE:
        {
            tNAME               *pRemoteName = (tNAME *) pIrp->AssociatedIrp.SystemBuffer;
            PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

            //
            // Validate input/output buffer size
            //
            Size = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
            if (Size >= sizeof(tNAME))
            {
                //
                // We need only the name
                //
                status = NbtFlushEntryFromRemoteHashTable (pRemoteName);
            }
            else
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.DispatchIoctls[IOCTL_NETBT_REMOVE_FROM_REMOTE_TABLE]: Input buffer too small\n"));
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

    //
    // The following Ioctl is used by the Rdr/Srv to add/remove addresses from the SmbDevice
    //
    case IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO:
        {
            ASSERT (pDeviceContext == pNbtSmbDevice);

            if ((pNbtSmbDevice) &&
                (NBT_REFERENCE_DEVICE (pNbtSmbDevice, REF_DEV_SMB_BIND, FALSE)))
            {
                status = NbtSetSmbBindingInfo (pDeviceContext, pIrp, pIrpSp);
                NBT_DEREFERENCE_DEVICE (pNbtSmbDevice, REF_DEV_SMB_BIND, FALSE);
            }
            else
            {
                ASSERT(0);
            }

            break;
        }

    default:
        {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }   // switch

    //
    // copy the reponse to the client's Mdl
    //
    if (!NT_ERROR(status) &&        // allow buffer overflow to pass by
        ((ControlCode == IOCTL_NETBT_GET_REMOTE_NAMES) ||
        (ControlCode == IOCTL_NETBT_GET_BCAST_NAMES) ||
        (ControlCode == IOCTL_NETBT_GET_CONNECTIONS)) )
    {
        status = TdiCopyBufferToMdl (pBuffer, 0, Size, pIrp->MdlAddress, 0,
                                     (PULONG) &pIrp->IoStatus.Information);

        CTEMemFree((PVOID)pBuffer);
    }

    //
    // either Success or an Error
    // so complete the irp
    //
    NTIoComplete(pIrp,status,0);
    return(status);
}


//----------------------------------------------------------------------------

NTSTATUS
GetIpAddrs(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PIRP                pIrp
    )

/*++

Routine Description:

This routine performs the IOCTL_GET_IP_ADDRS function.

It is in its own routine because it is non paged.

Arguments:

    pDeviceContext -
    pIrp -

Return Value:

    NTSTATUS -

--*/

{
    ULONG           Length;
    PULONG          pIpAddr;
    PLIST_ENTRY     pEntry,pHead;
    tDEVICECONTEXT  *pDevContext;
    KIRQL           OldIrq;
    tIPADDRESS      IpAddr;

    //
    // return this devicecontext's ip address and all the other
    // ip addrs after it.
    //
    if (!pIrp->MdlAddress)
    {
        return STATUS_INVALID_PARAMETER;
    }
    else if ((Length = MmGetMdlByteCount (pIrp->MdlAddress)) < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    else if (!(pIpAddr = (PULONG )MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Put this adapter first in the list
    // Don't include the smb device, its address is uninteresting
    if (!IsDeviceNetbiosless (pDeviceContext))
    {
        // Don't use memcpy, optimizing compiler always try to use a simple store instruction
        CTEMemCopy(pIpAddr, &pDeviceContext->AssignedIpAddress, sizeof(pIpAddr[0]));
        pIpAddr++;
        Length -= sizeof(ULONG);
    }

    // Return the others

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pEntry = pHead = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        if (Length < sizeof(ULONG))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return STATUS_BUFFER_OVERFLOW;
        }

        pDevContext = CONTAINING_RECORD(pEntry, tDEVICECONTEXT, Linkage);

        if ((pDevContext != pDeviceContext) &&
            (pDevContext->AssignedIpAddress))
        {
            // Don't use memcpy, optimizing compiler always try to use a simple store instruction
            CTEMemCopy(pIpAddr, &pDevContext->AssignedIpAddress, sizeof(pIpAddr[0]));
            pIpAddr++;
            Length -= sizeof(ULONG);
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // put a -1 address on the end
    //
    if (Length < sizeof(ULONG))
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    IpAddr = -1;
    CTEMemCopy(pIpAddr, &IpAddr, sizeof(pIpAddr[0]));

    return STATUS_SUCCESS;
} // GetIpAddrs

//----------------------------------------------------------------------------
NTSTATUS
NTReceive(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine handles Queuing a receive buffer on a connection or passing
    the recieve buffer to the transport if there is outstanding data waiting
    to be received on the connection.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                        status=STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION              pIrpSp;
    tCONNECTELE                     *pConnEle;
    KIRQL                           OldIrq, OldIrq1;
    ULONG                           ToCopy;
    ULONG                           ClientRcvLen;
    tLOWERCONNECTION                *pLowerConn;
    ULONG                           RemainingPdu;
    PTDI_REQUEST_KERNEL_RECEIVE     pParams;
    PTDI_REQUEST_KERNEL_RECEIVE     pClientParams;
    ULONG                           BytesCopied;


    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = pIrpSp->FileObject->FsContext;

    if ((pConnEle) &&
        (pConnEle->state == NBT_SESSION_UP))
    {
        CTESpinLock(pConnEle,OldIrq1);

        PUSH_LOCATION(0x30);
        if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            CTESpinFree(pConnEle,OldIrq1);
            ASSERTMSG ("Nbt.NTReceive: ERROR - Invalid Connection Handle\n", 0);
            status = STATUS_INVALID_HANDLE;
        }
        else if (pLowerConn = pConnEle->pLowerConnId)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            CTESpinFree(pConnEle,OldIrq1);
            status = STATUS_REMOTE_DISCONNECT;
        }
    }

    if (STATUS_SUCCESS != status)
    {
        PUSH_LOCATION(0x47);

        //
        // session in wrong state so reject the buffer posting
        // complete the irp, since there must have been some sort of error
        // to get to here
        //
        NTIoComplete(pIrp, status, 0);
        return(status);
    }

    PUSH_LOCATION(0x31);
    //
    // We are already holding the ConnEle lock

    CTESpinLock(pLowerConn,OldIrq);

    if (pLowerConn->StateRcv != PARTIAL_RCV)
    {
        // **** Fast Path Code ****
        //
        // Queue this receive buffer on to the Rcv Head
        //
        InsertTailList(&pConnEle->RcvHead, &pIrp->Tail.Overlay.ListEntry);

        status = NTCheckSetCancelRoutine(pIrp,(PVOID)NbtCancelReceive,pDeviceContext);

        if (!NT_SUCCESS(status))
        {
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
            CTESpinFree(pLowerConn,OldIrq);
            CTESpinFree(pConnEle,OldIrq1);

            NTIoComplete(pIrp,status,0);
            return(status);
        }
        else
        {
            //
            // if the irp is not cancelled, returning pending
            //
            CTESpinFree(pLowerConn,OldIrq);
            CTESpinFree(pConnEle,OldIrq1);

            return(STATUS_PENDING);
        }
    }
    else
    {
        // ***** Partial Rcv - Data Still in Transport *****

        BOOLEAN     ZeroLengthSend;

        PUSH_LOCATION(0x32);

        IF_DBG(NBT_DEBUG_RCV)
        KdPrint(("Nbt.NTReceive: A Rcv Buffer posted data in Xport,InXport= %X,InIndic %X RcvIndicated %X\n",
                pConnEle->BytesInXport,pLowerConn->BytesInIndicate,
                pConnEle->ReceiveIndicated));

        // get the MDL chain length
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

        // Reset the Irp pending flag
        pIrpSp->Control &= ~SL_PENDING_RETURNED;

        // fill in the next irp stack location with our completion routine.
        pIrpSp = IoGetNextIrpStackLocation(pIrp);

        pIrpSp->CompletionRoutine = CompletionRcv;
        pIrpSp->Context = (PVOID)pConnEle->pLowerConnId;
        pIrpSp->Flags = 0;

        // set flags so the completion routine is always invoked.
        pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

        pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pIrpSp->MinorFunction = TDI_RECEIVE;
        pIrpSp->DeviceObject = IoGetRelatedDeviceObject(pConnEle->pLowerConnId->pFileObject);
        pIrpSp->FileObject = pConnEle->pLowerConnId->pFileObject;

        pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
        pParams->ReceiveFlags = pClientParams->ReceiveFlags;

        // Since this irp is going to traverse through CompletionRcv, we
        // need to set the following, since it undoes this stuff.
        // This also prevents the LowerConn from being blown away before
        // the irp has returned from the transport
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
        //
        // pass the receive buffer directly to the transport, decrementing
        // the number of receive bytes that have been indicated
        //
        ASSERT(pConnEle->TotalPcktLen >= pConnEle->BytesRcvd);
        if (pClientParams->ReceiveLength > (pConnEle->TotalPcktLen - pConnEle->BytesRcvd))
        {
            pParams->ReceiveLength = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
        }
        else
        {
            pParams->ReceiveLength = pClientParams->ReceiveLength;
        }

        ClientRcvLen = pParams->ReceiveLength;
        //
        // Set the amount of data that we will receive so when the
        // irp completes in completionRcv, we can fill in that
        // info in the Irp
        //
        pConnEle->CurrentRcvLen = ClientRcvLen;

        // if a zero length send occurs, then ReceiveIndicated is set
        // to zero with the state set to RcvPartial. Or, the client may
        // pass down an Irp with no MDL in it!!
        //
        if ((pConnEle->ReceiveIndicated == 0) || !pIrp->MdlAddress)
        {
            ZeroLengthSend = TRUE;
        }
        else
        {
            ZeroLengthSend = FALSE;
        }

        // calculate how many bytes are still remaining for the client.
        if (pConnEle->ReceiveIndicated > ClientRcvLen)
        {
            PUSH_LOCATION(0x40);
            pConnEle->ReceiveIndicated -= ClientRcvLen;
        }
        else
        {
            pConnEle->ReceiveIndicated = 0;
        }

        if (pLowerConn->BytesInIndicate || ZeroLengthSend)
        {
            PMDL    Mdl;

            PUSH_LOCATION(0x33);
            if (ClientRcvLen > pLowerConn->BytesInIndicate)
            {
                ToCopy = pLowerConn->BytesInIndicate;
            }
            else
            {
                PUSH_LOCATION(0x41);
                ToCopy = ClientRcvLen;
            }

            // copy data from the indicate buffer to the client's buffer,
            // remembering that there is a session header in the indicate
            // buffer at the start of it... so skip that.  The
            // client can pass down a null Mdl address for a zero length
            // rcv so check for that.
            //
            if (Mdl = pIrp->MdlAddress)
            {
                TdiCopyBufferToMdl(MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl),
                                   0,           // src offset
                                   ToCopy,
                                   Mdl,
                                   0,                 // dest offset
                                   &BytesCopied);
            }
            else
            {
                BytesCopied = 0;
            }

            // client's MDL is too short...
            if (BytesCopied != ToCopy)
            {
                PUSH_LOCATION(0x42);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint(("Nbt:Receive Buffer too short for Indicate buff BytesCopied %X, ToCopy %X\n",
                            BytesCopied, ToCopy));

//                ToCopy = BytesCopied;

                // so the irp will be completed, below
                ClientRcvLen = BytesCopied;
            }

            pLowerConn->BytesInIndicate -= (USHORT)BytesCopied;

            // this case is only if the irp is full and should be returned
            // now.
            if (BytesCopied == ClientRcvLen)
            {
                PUSH_LOCATION(0x34);
                // check if the indicate buffer is empty now. If not, then
                // move the data forward to the start of the buffer.
                //
                if (pLowerConn->BytesInIndicate)
                {
                    PUSH_LOCATION(0x43);
                    CopyToStartofIndicate(pLowerConn,BytesCopied);
                }
                //
                // the irp is full so complete it
                //
                // the client MDL is full, so complete his irp
                // CompletionRcv increments the number of bytes rcvd
                // for this session pdu (pConnEle->BytesRcvd).
                pIrp->IoStatus.Information = BytesCopied;
                pIrp->IoStatus.Status = STATUS_SUCCESS;

                // since we are completing it and TdiRcvHandler did not set the next
                // one.
                //
                ASSERT(pIrp->CurrentLocation > 1);

                IoSetNextIrpStackLocation(pIrp);

                // we need to track how much of the client's MDL has filled
                // up to know when to return it.  CompletionRcv subtracts
                // from this value as it receives bytes.
                pConnEle->FreeBytesInMdl = ClientRcvLen;
                pConnEle->CurrentRcvLen  = ClientRcvLen;

                CTESpinFree(pLowerConn,OldIrq);
                CTESpinFree(pConnEle,OldIrq1);

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                return(STATUS_SUCCESS);
            }
            else
            {
                //
                // clear the number of bytes in the indicate buffer since the client
                // has taken more than the data left in the Indicate buffer
                //
                pLowerConn->BytesInIndicate = 0;

                // decrement the client rcv len by the amount already put into the
                // client Mdl
                //
                ClientRcvLen -= BytesCopied;
                IF_DBG(NBT_DEBUG_RCV)
                    KdPrint(("Nbt: Pass Client Irp to Xport BytesinXport %X, ClientRcvLen %X\n",
                                pConnEle->BytesInXport,ClientRcvLen));
                //
                // Set the amount left inthe transport after this irp
                // completes
                if (pConnEle->BytesInXport < ClientRcvLen )
                {
                    pConnEle->BytesInXport = 0;
                }
                else
                {
                    pConnEle->BytesInXport -= ClientRcvLen;
                }

                // Adjust the number of bytes in the Mdl chain so far since the
                // completion routine will only count the bytes filled in by the
                // transport
                pConnEle->BytesRcvd += BytesCopied;

                // the client is going to take more data from the transport with
                // this Irp.  Set the new Rcv Length that accounts for the data just
                // copied to the Irp.
                //
                pParams->ReceiveLength = ClientRcvLen;

                IF_DBG(NBT_DEBUG_RCV)
                KdPrint(("Nbt:ClientRcvLen = %X, LeftinXport= %X BytesCopied= %X %X\n",ClientRcvLen,
                                pConnEle->BytesInXport,BytesCopied,pLowerConn));

                // set the state to this so we can undo the MDL footwork
                // in completion rcv - since we have made a partial MDL and
                // put that at the start of the chain.
                //
                SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);

                // Note that the Irp Mdl address changes below
                // when MakePartialMdl is called so this line cannot
                // be moved to the common code below!!
                pLowerConn->pMdl = pIrp->MdlAddress;

                // setup the next MDL so we can create a partial mdl correctly
                // in TdiReceiveHandler
                //
                pConnEle->pNextMdl = pIrp->MdlAddress;

                // Build a partial Mdl to represent the client's Mdl chain since
                // we have copied data to it, and the transport must copy
                // more data to it after that data.
                //
                // Force the system to map and lock the user buffer
                MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority);
                MakePartialMdl(pConnEle,pIrp,BytesCopied);

                // pass the Irp to the transport
                //
                //
                IF_DBG(NBT_DEBUG_RCV)
                    KdPrint(("Nbt:Calling IoCallDriver\n"));
                ASSERT(pIrp->CurrentLocation > 1);
            }
        }
        else
        {
            PUSH_LOCATION(0x36);
            IF_DBG(NBT_DEBUG_RCV)
            KdPrint(("Nbt.NTReceive: Pass Irp To Xport Bytes in Xport %X, ClientRcvLen %X, RcvIndicated %X\n",
                                    pConnEle->BytesInXport,ClientRcvLen,pConnEle->ReceiveIndicated));
            //
            // there are no bytes in the indicate buffer, so just pass the
            // irp on down to the transport
            //
            //
            // Decide the next state depending on whether the transport currently
            // has enough data for this irp
            //
            if (pConnEle->BytesInXport < ClientRcvLen)
            {
                PUSH_LOCATION(0x37);
                pConnEle->BytesInXport = 0;
                //
                // to get to here, the implication is that ReceiveIndicated
                // equals zero too!! Since ReceiveInd cannot be more than
                // BytesInXport, so we can change the state to fill irp without
                // worrying about overwriting PartialRcv
                //
                SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);
                // setup the next MDL so we can create a partial mdl correctly
                // in TdiReceiveHandler
                //
                pConnEle->pNextMdl = pIrp->MdlAddress;
            }
            else
            {
                PUSH_LOCATION(0x38);
                pConnEle->BytesInXport -= ClientRcvLen;

                // set the state to this so we know what to do in completion rcv
                //
                if (pConnEle->ReceiveIndicated == 0)
                {
                    PUSH_LOCATION(0x39);
                    SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
                }
            }

            //
            // save the Irp so we can reconstruct things later
            //
            pLowerConn->pMdl = pIrp->MdlAddress;
        }

        // *** Common Code to passing irp to transport - when there is
        // data in the indicate buffer and when there isn't

        // keep track of data in MDL so we know when it is full
        // and we need to return it to the user
        //
        pConnEle->FreeBytesInMdl = pParams->ReceiveLength;
        // Force the system to map and lock the user buffer
        MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority);

        //
        // Null the Irp since we are passing it to the transport.
        //
        pConnEle->pIrpRcv = NULL;
        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pConnEle,OldIrq1);

        CHECK_COMPLETION(pIrp);

        status = IoCallDriver(IoGetRelatedDeviceObject(pLowerConn->pFileObject),pIrp);

        IF_DBG(NBT_DEBUG_RCV)
            KdPrint(("Nbt.NTReceive: Returning=<%x>, IoStatus.Status=<%x>, IoStatus.Information=<%x>\n",
                status, pIrp->IoStatus.Status, pIrp->IoStatus.Information));
    }

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTReceiveDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles receiving a datagram by passing the datagram rcv
    buffer to the non-OS specific code.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                        status;
    PIO_STACK_LOCATION              pIrpSp;
    PTDI_REQUEST_KERNEL_RECEIVEDG   pTdiRequest;
    TDI_REQUEST                     Request;
    ULONG                           ReceivedLength;
    tCLIENTELE                      *pClientEle;

    IF_DBG(NBT_DEBUG_RCV)
        KdPrint(("Nbt: Got a Receive datagram that NBT was NOT \n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.NTReceiveDatagram: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // get the sending information out of the irp
    pTdiRequest = (PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;
    Request.Handle.AddressHandle = pClientEle;

    status = NbtReceiveDatagram(
                    &Request,
                    pTdiRequest->ReceiveDatagramInformation,
                    pTdiRequest->ReturnDatagramInformation,
                    pTdiRequest->ReceiveLength,
                    &ReceivedLength,
                    (PVOID)pIrp->MdlAddress,   // user data
                    (tDEVICECONTEXT *)pDeviceContext,
                    pIrp);

    if (status != STATUS_PENDING)
    {

        NTIoComplete(pIrp,status,ReceivedLength);

    }

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NTSend(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles sending session pdus across a connection.  It is
    all OS specific code.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    NTSTATUS                        status;
    PTDI_REQUEST_KERNEL_SEND        pTdiRequest;
    PMDL                            pMdl;
    PSINGLE_LIST_ENTRY              pSingleListEntry;
    tSESSIONHDR                     *pSessionHdr;
    tCONNECTELE                     *pConnEle;
    KIRQL                           OldIrq;
    KIRQL                           OldIrq1;
    PTDI_REQUEST_KERNEL_SEND        pParams;
    PFILE_OBJECT                    pFileObject;
    tLOWERCONNECTION                *pLowerConn;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // This function could be called directly also while bypassing the
    // Io subsystem, so we need to recheck the DeviceContext here
    //
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NTSend:  Invalid Device=<%x>\n", pDeviceContext));
        status = STATUS_INVALID_DEVICE_STATE;
        goto ErrorInvalidDevice;
    }

    // get the sending information out of the irp
    pTdiRequest = (PTDI_REQUEST_KERNEL_SEND)&pIrpSp->Parameters;
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NTSend: ERROR - Invalid Connection Handle\n", 0);
        status = STATUS_INVALID_HANDLE;
        goto ErrorExit;     // Irp has to be completed in this routine! Bug# 202340
    }

    CTESpinLock(pConnEle,OldIrq);

    if (!(pLowerConn =  pConnEle->pLowerConnId))
    {
        CTESpinFree(pConnEle,OldIrq);

        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NTSend: attempting send when LowerConn has been freed!\n"));
        status = STATUS_INVALID_HANDLE;
        goto ErrorExit;     // to save on indent levels use a goto here
    }

    //
    // make sure lowerconn stays valid until the irp is done
    //
    CTESpinLock(pLowerConn,OldIrq1);
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SEND);
    CTESpinFree(pLowerConn,OldIrq1);

    // check the state of the connection
    if (pConnEle->state == NBT_SESSION_UP)
    {
        //
        // send the data on downward to tcp
        // allocate an MDL to allow us to put the session hdr in first and then
        // put the users buffer on after that, chained to the session hdr MDL.
        //
#if BACK_FILL
        {
           PMDL SmbMdl;
           SmbMdl = (PMDL)pIrp->MdlAddress;

            // Check if network header type is set
            // if yes, then we can back fill the nbt session header

            if ((SmbMdl) && (SmbMdl->MdlFlags & MDL_NETWORK_HEADER))
            {
                pSessionHdr = (tSESSIONHDR *)((ULONG_PTR)SmbMdl->MappedSystemVa - SESSION_HDR_SIZE);

                (ULONG_PTR)SmbMdl->MappedSystemVa -= SESSION_HDR_SIZE;
                SmbMdl->ByteOffset -= SESSION_HDR_SIZE;
                SmbMdl->ByteCount+= SESSION_HDR_SIZE;

                pSessionHdr->UlongLength = htonl(pTdiRequest->SendLength);

                IF_DBG(NBT_DEBUG_SEND)
                    KdPrint(("Nbt: Backfilled mdl %x %x\n", pSessionHdr, SmbMdl));
            }
            else
            {
                CTESpinLockAtDpc(&NbtConfig);

                if (NbtConfig.SessionMdlFreeSingleList.Next)
                {
                    pSingleListEntry = PopEntryList(&NbtConfig.SessionMdlFreeSingleList);
                    pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                    ASSERT ( MmGetMdlByteCount ( pMdl ) == sizeof ( tSESSIONHDR ) );
                }
                else
                {
                    NbtGetMdl(&pMdl,eNBT_FREE_SESSION_MDLS);
                    if (!pMdl)
                    {
                        IF_DBG(NBT_DEBUG_SEND)
                            KdPrint(("Nbt:Unable to get an MDL for a session send!\n"));

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        CTESpinFreeAtDpc(&NbtConfig);
                        CTESpinFree(pConnEle,OldIrq);

                        // to save on indent levels use a goto here
                        goto ErrorExit1;
                    }
                }

                CTESpinFreeAtDpc(&NbtConfig);

                // get the session hdr address out of the MDL
                pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);

                // the type of PDU is always a session message, since the session
                // request is sent when the client issues a "connect" rather than a send
                //
                pSessionHdr->UlongLength = htonl(pTdiRequest->SendLength);

                // get the device object and file object for the TCP transport underneath
                // link the user buffer on the end of the session header Mdl on the Irp
                //
                pMdl->Next = pIrp->MdlAddress;
                pIrp->MdlAddress = pMdl;
            }
        }
#else
        CTESpinLockAtDpc(&NbtConfig);

        if (NbtConfig.SessionMdlFreeSingleList.Next)
        {
            pSingleListEntry = PopEntryList(&NbtConfig.SessionMdlFreeSingleList);
            pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);

            ASSERT ( MmGetMdlByteCount ( pMdl ) == sizeof ( tSESSIONHDR ) );
        }
        else
        {
            NbtGetMdl(&pMdl,eNBT_FREE_SESSION_MDLS);

            if (!pMdl)
            {
                IF_DBG(NBT_DEBUG_SEND)
                    KdPrint(("Nbt:Unable to get an MDL for a session send!\n"));

                status = STATUS_INSUFFICIENT_RESOURCES;
                CTESpinFreeAtDpc(&NbtConfig);
                CTESpinFree(pConnEle,OldIrq);

                // to save on indent levels use a goto here
                goto ErrorExit1;
            }
        }

        CTESpinFreeAtDpc(&NbtConfig);

        // get the session hdr address out of the MDL
        pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);

        // the type of PDU is always a session message, since the session
        // request is sent when the client issues a "connect" rather than a send
        //
        pSessionHdr->UlongLength = htonl(pTdiRequest->SendLength);

        // get the device object and file object for the TCP transport underneath
        // link the user buffer on the end of the session header Mdl on the Irp
        //
        pMdl->Next = pIrp->MdlAddress;
        pIrp->MdlAddress = pMdl;

#endif //BACK_FILL

        pIrpSp = IoGetNextIrpStackLocation(pIrp);

        pParams = (PTDI_REQUEST_KERNEL_SEND)&pIrpSp->Parameters;
        pParams->SendFlags = pTdiRequest->SendFlags;
        pParams->SendLength = pTdiRequest->SendLength + sizeof(tSESSIONHDR);


        pIrpSp->CompletionRoutine = SendCompletion;
        pIrpSp->Context = (PVOID)pLowerConn;
        pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

        pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pIrpSp->MinorFunction = TDI_SEND;

        pFileObject = pLowerConn->pFileObject;
        pLowerConn->BytesSent += pTdiRequest->SendLength;

        pIrpSp->FileObject = pFileObject;
        pIrpSp->DeviceObject = IoGetRelatedDeviceObject(pFileObject);


        CTESpinFree(pConnEle,OldIrq);

        CHECK_COMPLETION(pIrp);

#if FAST_DISP
        //if we are all set to do fast path, do so now.
        if (pLowerConn->FastSend)
        {
            IoSetNextIrpStackLocation(pIrp);

            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.NTSend: Fasttdi path %x %x \n", pIrp, pIrpSp));

            status = pLowerConn->FastSend (pIrp, pIrpSp);
        }
        else
        {
            status = IoCallDriver (IoGetRelatedDeviceObject (pFileObject), pIrp);
        }
#else
        status = IoCallDriver(IoGetRelatedDeviceObject(pFileObject),pIrp);
#endif

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
        return(status);
    }   //correct state

    CTESpinFree(pConnEle,OldIrq);
    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt:Invalid state for connection on an attempted send, %X\n",
            pConnEle));
    status = STATUS_INVALID_HANDLE;

ErrorExit1:

    //
    // Dereference pLowerConn->RefCount, referenced above.
    //
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SEND, FALSE);

ErrorExit:

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);

ErrorInvalidDevice:

    //
    // Reset the Irp pending flag
    //
    pIrpSp->Control &= ~SL_PENDING_RETURNED;
    //
    // complete the irp, since there must have been some sort of error
    // to get to here
    //
    NTIoComplete (pIrp, status, 0);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
SendCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles the completion event when the send completes with
    the underlying transport.  It must put the session hdr buffer back in
    the correct free list and free the active q entry and put it back on
    its free list.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pConnectEle - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PMDL               pMdl;
    tLOWERCONNECTION  *pLowerConn;

    //
    // Do some checking to keep the Io system happy - propagate the pending
    // bit up the irp stack frame.... if it was set by the driver below then
    // it must be set by me
    //
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    // put the MDL we back on its free list and put the clients mdl back on the Irp
    // as it was before the send
    pMdl = Irp->MdlAddress;

#if BACK_FILL
    // If the header is back filled
    // we should adjust the pointers back to where it was.
    if (pMdl->MdlFlags & MDL_NETWORK_HEADER)
    {
        (ULONG_PTR)pMdl->MappedSystemVa += SESSION_HDR_SIZE;
        pMdl->ByteOffset += SESSION_HDR_SIZE;
        pMdl->ByteCount -= SESSION_HDR_SIZE;

        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt: Done with Backfilled mdl %x\n", pMdl));
    }
    else
    {
        Irp->MdlAddress = pMdl->Next;

        ASSERT ( MmGetMdlByteCount ( pMdl ) == SESSION_HDR_SIZE );

#if DBG
        IF_DBG(NBT_DEBUG_SEND)
        {
            PMDL             pMdl1;
            ULONG            ulen1,ulen2,ulen3;
            UCHAR            uc;
            tSESSIONHDR      *pSessionHdr;
            PSINGLE_LIST_ENTRY   pSingleListEntry;
            KIRQL            OldIrq;

            pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);
            ulen1 = htonl ( pSessionHdr->UlongLength );

            for ( ulen2 = 0 , pMdl1 = pMdl ; ( pMdl1 = pMdl1->Next ) != NULL ; )
            {
                ulen3 = MmGetMdlByteCount ( pMdl1 );
                ASSERT ( ulen3 > 0 );
                uc = ( ( UCHAR * ) MmGetMdlVirtualAddress ( pMdl1 ) ) [ ulen3 - 1 ];
                ulen2 += ulen3;
            }

            ASSERT ( ulen2 == ulen1 );

            CTESpinLock(&NbtConfig,OldIrq);
            for ( pSingleListEntry = &NbtConfig.SessionMdlFreeSingleList ;
                    ( pSingleListEntry = pSingleListEntry->Next ) != NULL ;
                    )
            {
                 pMdl1 = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                 ASSERT ( pMdl1 != pMdl  );
            }
            CTESpinFree(&NbtConfig,OldIrq);
        }
#endif  // DBG

        ExInterlockedPushEntryList(&NbtConfig.SessionMdlFreeSingleList,
                               (PSINGLE_LIST_ENTRY)pMdl,
                               &NbtConfig.LockInfo.SpinLock);
    }
#else
    Irp->MdlAddress = pMdl->Next;
    ASSERT ( MmGetMdlByteCount ( pMdl ) == sizeof ( tSESSIONHDR ) );

#if DBG
    IF_DBG(NBT_DEBUG_SEND)
    {
        PMDL             pMdl1;
        ULONG            ulen1,ulen2,ulen3;
        UCHAR            uc;
        tSESSIONHDR      *pSessionHdr;
        PSINGLE_LIST_ENTRY   pSingleListEntry;
        KIRQL            OldIrq;

        pSessionHdr = (tSESSIONHDR *)MmGetMdlVirtualAddress(pMdl);
        ulen1 = htonl ( pSessionHdr->UlongLength );

        for ( ulen2 = 0 , pMdl1 = pMdl ; ( pMdl1 = pMdl1->Next ) != NULL ; )
        {
            ulen3 = MmGetMdlByteCount ( pMdl1 );
            ASSERT ( ulen3 > 0 );
            uc = ( ( UCHAR * ) MmGetMdlVirtualAddress ( pMdl1 ) ) [ ulen3 - 1 ];
            ulen2 += ulen3;
        }

        ASSERT ( ulen2 == ulen1 );

        CTESpinLock(&NbtConfig,OldIrq);
        for ( pSingleListEntry = &NbtConfig.SessionMdlFreeSingleList ;
                ( pSingleListEntry = pSingleListEntry->Next ) != NULL ;
            )
        {
            pMdl1 = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
            ASSERT ( pMdl1 != pMdl  );
        }
        CTESpinFree(&NbtConfig,OldIrq);
    }
#endif  // DBG

    ExInterlockedPushEntryList(&NbtConfig.SessionMdlFreeSingleList,
                               (PSINGLE_LIST_ENTRY)pMdl,
                               &NbtConfig.LockInfo.SpinLock);

#endif //BACK_FILL
    // fill in the sent size so that it substracts off the session header size
    //
    if (Irp->IoStatus.Information > sizeof(tSESSIONHDR))
    {
        Irp->IoStatus.Information -= sizeof(tSESSIONHDR);
    }
    else
    {
        // nothing was sent
        Irp->IoStatus.Information = 0;
        IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt:Zero Send Length for a session send!\n"));
    }

    //
    // we incremented this before the send: deref it now
    //
    pLowerConn = (tLOWERCONNECTION *)Context;
    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_SEND, FALSE);

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( DeviceObject );
}


//----------------------------------------------------------------------------
NTSTATUS
NTSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles sending a datagram down to the transport.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    NTSTATUS                        status;
    LONG                            lSentLength;
    TDI_REQUEST                     Request;
    PTDI_REQUEST_KERNEL_SENDDG      pTdiRequest;
    tCLIENTELE                      *pClientEle;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.SendDatagram: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    // CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);

    // get the sending information out of the irp
    pTdiRequest = (PTDI_REQUEST_KERNEL_SENDDG)&pIrpSp->Parameters;
    Request.Handle.AddressHandle = pClientEle;

    lSentLength = 0;

    //
    // Mark IRP pending here
    //
    IoMarkIrpPending(pIrp);
    status = NbtSendDatagram (&Request,
                              pTdiRequest->SendDatagramInformation,
                              pTdiRequest->SendLength,
                              &lSentLength,
                              (PVOID)pIrp->MdlAddress,   // user data
                              (tDEVICECONTEXT *)pDeviceContext,
                              pIrp);


    if (status != STATUS_PENDING)
    {
        //
        // either Success or an Error
        //
        NTIoComplete(pIrp,status,lSentLength);
    }

    //
    // To make driver verifier and IO system happy, always return
    // STATUS_PENDING for the request marked as PENDING
    //
    return STATUS_PENDING;
}

//----------------------------------------------------------------------------
NTSTATUS
NTSetInformation(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles sets up event handlers that the client passes in.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    // *TODO*

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:************ Got a Set Information that was NOT expected *******\n"));
    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
NTQueueToWorkerThread(
    IN  PVOID                   DelayedWorkerRoutine,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 fJointLockHeld
    )
/*++

Routine Description:

    This routine simply queues a request on an excutive worker thread
    for later execution.  Scanning the LmHosts file must be down this way.

Arguments:
    pTracker            - the tracker block for context
    DelayedWorkerRoutine- the routine for the Workerthread to call
    pDeviceContext      - the device context which is this delayed event
                          pertains to.  This could be NULL (meaning it's an event
                          pertaining to not any specific device context)

Return Value:


--*/

{
    NTSTATUS                status;
    NBT_WORK_ITEM_CONTEXT   *pContext;
#ifdef _PNP_POWER_
    KIRQL                   OldIrq;
#endif  // _PNP_POWER_

    if ((pDeviceContext) &&
        (!NBT_REFERENCE_DEVICE(pDeviceContext, REF_DEV_WORKER, fJointLockHeld)))
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (pContext = (NBT_WORK_ITEM_CONTEXT *)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG2('22')))
    {
        pContext->pTracker = pTracker;
        pContext->pClientContext = pClientContext;
        pContext->ClientCompletion = ClientCompletion;
#ifdef _PNP_POWER_
        pContext->pDeviceContext = pDeviceContext;

        CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
        InitializeListHead(&pContext->NbtConfigLinkage);
        pContext->WorkerRoutine = DelayedWorkerRoutine;
        //
        // Don't Queue this request onto the Worker Queue if we have
        // already started unloading
        //
        if (NbtConfig.Unloading)
        {
            InsertTailList(&NbtConfig.WorkerQList, &pContext->NbtConfigLinkage);
        }
        else
        {
            ++NbtConfig.NumWorkerThreadsQueued;
            ExInitializeWorkItem(&pContext->Item,NTExecuteWorker,pContext);
            ExQueueWorkItem(&pContext->Item,DelayedWorkQueue);
        }
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);
#else
        ExInitializeWorkItem(&pContext->Item,CallBackRoutine,pContext);
        ExQueueWorkItem(&pContext->Item,DelayedWorkQueue);
#endif  // _PNP_POWER_

        return (STATUS_SUCCESS);
    }

    //
    // We would reach here only on Resource failure above!
    //
    if (pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WORKER, fJointLockHeld);
    }

    return (STATUS_INSUFFICIENT_RESOURCES);
}



//----------------------------------------------------------------------------
VOID
NTExecuteWorker(
    IN  PVOID     pContextInfo
    )
/*++

Routine Description:

    This routine handles executing delayed requests at non-Dpc level.  If
    the Device is currently being unloaded, we let the Unload Handler
    complete the request.

Arguments:
    pContext        - the Context data for this Worker thread

Return Value:

    none

--*/

{
    NBT_WORK_ITEM_CONTEXT       *pContext = (NBT_WORK_ITEM_CONTEXT *) pContextInfo;
    PNBT_WORKER_THREAD_ROUTINE  pDelayedWorkerRoutine = (PNBT_WORKER_THREAD_ROUTINE) pContext->WorkerRoutine;
    KIRQL                       OldIrq;

    (*pDelayedWorkerRoutine) (pContext->pTracker,
                              pContext->pClientContext,
                              pContext->ClientCompletion,
                              pContext->pDeviceContext);

    if (pContext->pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE(pContext->pDeviceContext, REF_DEV_WORKER, FALSE);
    }
    CTEMemFree ((PVOID) pContext);


    CTESpinLock(&NbtConfig.WorkerQLock,OldIrq);
    if (!--NbtConfig.NumWorkerThreadsQueued)
    {
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);
        KeSetEvent(&NbtConfig.WorkerQLastEvent, 0, FALSE);
    }
    else
    {
        CTESpinFree(&NbtConfig.WorkerQLock,OldIrq);
    }
}



//----------------------------------------------------------------------------
VOID
SecurityDelete(
    IN  PVOID     pContext
    )
/*++

Routine Description:

    This routine handles deleting a security context at non-dpc level.

Arguments:


Return Value:

    none

--*/
{
    PSECURITY_CLIENT_CONTEXT    pClientSecurity;

    pClientSecurity = (PSECURITY_CLIENT_CONTEXT)((NBT_WORK_ITEM_CONTEXT *)pContext)->pClientContext;
    SeDeleteClientSecurity(pClientSecurity);
    CTEMemFree(pContext);
}

//----------------------------------------------------------------------------
NTSTATUS
NTSendSession(
    IN  tDGRAM_SEND_TRACKING  *pTracker,
    IN  tLOWERCONNECTION      *pLowerConn,
    IN  PVOID                 pCompletion
    )
/*++
Routine Description:

    This Routine handles seting up a DPC to send a session pdu so that the stack
    does not get wound up in multiple sends for the keep alive timeout case.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/
{
    PKDPC   pDpc;

    if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('f')))
    {
        KeInitializeDpc(pDpc, DpcSendSession, (PVOID)pTracker);
        KeInsertQueueDpc(pDpc,(PVOID)pLowerConn,pCompletion);

        return (STATUS_SUCCESS);
    }

    return (STATUS_INSUFFICIENT_RESOURCES);
}

//----------------------------------------------------------------------------
VOID
DpcSendSession(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine simply calls TcpSendSession from a Dpc started in
    in NTSendSession (above).

Arguments:


Return Value:


--*/

{
    CTEMemFree((PVOID)pDpc);

    TcpSendSession((tDGRAM_SEND_TRACKING *)Context,
                   (tLOWERCONNECTION *)SystemArgument1,
                   (PVOID)SystemArgument2);
}


//----------------------------------------------------------------------------
NTSTATUS
NTSetEventHandler(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp)

/*++
Routine Description:

    This Routine handles

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION  pIrpSp;
    NTSTATUS            status;
    tCLIENTELE          *pClientEle;
    PTDI_REQUEST_KERNEL_SET_EVENT   pKeSetEvent;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
    {
        ASSERTMSG ("Nbt.NTSetEventHandler: ERROR - Invalid Address Handle\n", 0);
        return (STATUS_INVALID_HANDLE);
    }

    pKeSetEvent = (PTDI_REQUEST_KERNEL_SET_EVENT)&pIrpSp->Parameters;

    // call the not NT specific routine to setup the event handler in the
    // nbt data structures
    status = NbtSetEventHandler(
                        pClientEle,
                        pKeSetEvent->EventType,
                        pKeSetEvent->EventHandler,
                        pKeSetEvent->EventContext);

    return(status);

}

//----------------------------------------------------------------------------

VOID
NTIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength)

/*++
Routine Description:

    This Routine handles calling the NT I/O system to complete an I/O.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    KIRQL   OldIrq;

#if DBG
    if (!NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NTIoComplete: Returning Error status = %X\n",Status));
//        ASSERTMSG("Nbt: Error Ret Code In IoComplete",0);
    }
#endif

    pIrp->IoStatus.Status = Status;

    // use -1 as a flag to mean do not adjust the sent length since it is
    // already set
    if (SentLength != -1)
    {
        pIrp->IoStatus.Information = SentLength;
    }

#if DBG
    if ( (Status != STATUS_SUCCESS) &&
         (Status != STATUS_PENDING) &&
         (Status != STATUS_INVALID_DEVICE_REQUEST) &&
         (Status != STATUS_INVALID_PARAMETER) &&
         (Status != STATUS_IO_TIMEOUT) &&
         (Status != STATUS_BUFFER_OVERFLOW) &&
         (Status != STATUS_BUFFER_TOO_SMALL) &&
         (Status != STATUS_INVALID_HANDLE) &&
         (Status != STATUS_INSUFFICIENT_RESOURCES) &&
         (Status != STATUS_CANCELLED) &&
         (Status != STATUS_DUPLICATE_NAME) &&
         (Status != STATUS_TOO_MANY_NAMES) &&
         (Status != STATUS_TOO_MANY_SESSIONS) &&
         (Status != STATUS_REMOTE_NOT_LISTENING) &&
         (Status != STATUS_BAD_NETWORK_PATH) &&
         (Status != STATUS_HOST_UNREACHABLE) &&
         (Status != STATUS_CONNECTION_REFUSED) &&
         (Status != STATUS_WORKING_SET_QUOTA) &&
         (Status != STATUS_REMOTE_DISCONNECT) &&
         (Status != STATUS_LOCAL_DISCONNECT) &&
         (Status != STATUS_LINK_FAILED) &&
         (Status != STATUS_SHARING_VIOLATION) &&
         (Status != STATUS_UNSUCCESSFUL) &&
         (Status != STATUS_ACCESS_VIOLATION) &&
#ifdef MULTIPLE_WINS
         (Status != STATUS_NETWORK_UNREACHABLE) &&
#endif
         (Status != STATUS_NONEXISTENT_EA_ENTRY) )
    {
        KdPrint(("Nbt.NTIoComplete: returning unusual status = %X\n",Status));
    }
#endif

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    IoAcquireCancelSpinLock(&OldIrq);
    IoSetCancelRoutine(pIrp,NULL);
    IoReleaseCancelSpinLock(OldIrq);

    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
}



//----------------------------------------------------------------------------
//              ***** ***** Cancel Utilities ***** *****
//----------------------------------------------------------------------------

NTSTATUS
NTGetIrpIfNotCancelled(
    IN  PIRP            pIrp,
    IN  PIRP            *ppIrpInStruct
        )
/*++
Routine Description:

    This Routine gets the IOCancelSpinLock to coordinate with cancelling
    irps It then returns STATUS_SUCCESS. It also nulls the irp in the structure
    pointed to by the second parameter - so that the irp cancel routine
    will not also be called.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    KIRQL       OldIrq;
    NTSTATUS    status;

    IoAcquireCancelSpinLock(&OldIrq);

    // this nulls the irp in the datastructure - i.e. pConnEle->pIrp = NULL
    *ppIrpInStruct = NULL;

    if (!pIrp->Cancel)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }
    IoSetCancelRoutine(pIrp,NULL);

    IoReleaseCancelSpinLock(OldIrq);

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);
    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;

    }
    else
    {
        // setup the cancel routine
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp,CancelRoutine);
        status = STATUS_SUCCESS;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    return(status);

}
//----------------------------------------------------------------------------
NTSTATUS
NbtSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);
    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;

        //
        // Note the cancel spin lock is released by the Cancel routine
        //

        (*(PDRIVER_CANCEL)CancelRoutine)((PDEVICE_OBJECT)pDeviceContext,pIrp);

    }
    else
    {
        // setup the cancel routine and mark the irp pending
        //
        IoMarkIrpPending(pIrp);
        IoSetCancelRoutine(pIrp,CancelRoutine);
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        status = STATUS_SUCCESS;
    }
    return(status);

}

//----------------------------------------------------------------------------
VOID
NTClearContextCancel(
    IN NBT_WORK_ITEM_CONTEXT    *pContext
    )
/*++
Routine Description:

    This Routine sets the cancel routine for
    ((tDGRAM_SEND_TRACKING *)(pContext->pClientContext))->pClientIrp
    to NULL.

    NbtConfig.JointLock should be held when this routine is called.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/
{
    NTSTATUS status;
    status = NbtCancelCancelRoutine( ((tDGRAM_SEND_TRACKING *)(pContext->pClientContext))->pClientIrp );
    ASSERT ( status != STATUS_CANCELLED );
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCancelCancelRoutine(
    IN  PIRP            pIrp
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp to NULL

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS status = STATUS_SUCCESS;

    if ( pIrp )
    {
        //
        // Check if the irp was cancelled yet and if not, then set the
        // irp cancel routine.
        //
        IoAcquireCancelSpinLock(&pIrp->CancelIrql);

        if (pIrp->Cancel)
        {
            status = STATUS_CANCELLED;
        }
        IoSetCancelRoutine(pIrp,NULL);

        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return(status);
}


//----------------------------------------------------------------------------
//              ***** ***** Cancel Routines ***** *****
//----------------------------------------------------------------------------


VOID
NbtCancelListen(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a listen Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    tCLIENTELE           *pClientEle;
    KIRQL                OldIrq;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    tLISTENREQUESTS     *pListenReq;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Got a LISTEN Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    if ((!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!NBT_VERIFY_HANDLE2 ((pClientEle = pConnEle->pClientEle), NBT_VERIFY_CLIENT,NBT_VERIFY_CLIENT_DOWN)))
    {
        ASSERTMSG ("Nbt.NbtCancelListen: ERROR - Invalid Connection Handle\n", 0);
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        return;
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    NbtTrace(NBT_TRACE_INBOUND, ("Cancel Listen Irp %p ClientEle=%p", pIrp, pConnEle->pClientEle));

    // now search the client's listen queue looking for this connection
    //
    CTESpinLock(pClientEle,OldIrq);

    pHead = &pClientEle->ListenHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pListenReq = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
        if ((pListenReq->pConnectEle == pConnEle) &&
            (pListenReq->pIrp == pIrp))
        {
            RemoveEntryList(pEntry);
            CTESpinFree(pClientEle,OldIrq);

            // complete the irp
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            CTEMemFree((PVOID)pListenReq);

            return;

        }
        pEntry = pEntry->Flink;
    }

    CTESpinFree(pClientEle,OldIrq);
    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelSession(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a connect Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp(). It is called when
    the session setup pdu has been sent, and the state is still outbound.

    The cancel routine is only setup when the timer is started to time
    sending the session response pdu.


Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    KIRQL                OldIrq;
    PIO_STACK_LOCATION   pIrpSp;
    BOOLEAN              DerefConnEle=FALSE;
    tTIMERQENTRY         *pTimer;
    tDGRAM_SEND_TRACKING *pTracker;
    COMPLETIONCLIENT     pCompletion;
    PVOID                pContext;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelSession: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelSession: ERROR - Invalid Connection Handle\n", 0);
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("Cancel Session Irp %p ConnEle=%p LowerConn=%p, ClientEle=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle));
#ifdef RASAUTODIAL
    //
    // Cancel the automatic connection if one's
    // in progress.  If we don't find the
    // connection block in the automatic
    // connection driver, then it's already
    // been completed.
    //
    if (pConnEle->fAutoConnecting)
    {
        if (!NbtCancelPostConnect(pIrp))
        {
            return;
        }
    }
#endif // RASAUTODIAL

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if ((!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!(pConnEle->pIrp)) ||                  // the irp could get completed while acquiring the lock
        (!(pTracker = (tDGRAM_SEND_TRACKING *)pConnEle->pIrpRcv)))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    pTracker->Flags |= TRACKER_CANCELLED;

    if (pTimer = pTracker->pTimer)          // check for SessionStartupTimeout
    {
        pTracker->pTimer = NULL;
        //
        // stop the timer and only continue if the timer was stopped before
        // it expired
        //
        StopTimer(pTimer, &pCompletion, &pContext);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // pCompletion will be set if the timer had not expired
        // We want to cause a forced timeout, so we will just call the
        // timeout routine with STATUS_CANCELLED
        //
        if (pCompletion)
        {
            (*pCompletion) (pContext, STATUS_CANCELLED);
        }
    }
    else if (pConnEle->state == NBT_SESSION_OUTBOUND)
    {
        //
        // for some reason there is no timer, but the connection is still
        // outbound, so call the timer completion routine to kill off
        // the connection.
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        SessionStartupTimeout (pTracker, ULongToPtr(STATUS_CANCELLED), (PVOID)1);
    }
    else
    {
        //
        // Free the lock
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelConnect(
    IN PDEVICE_OBJECT pDeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles cancelling an NTConnect Irp - which has been
    passed down by a client (e.g. net view).  Typically, when the request
    succeeds on another adapter, it will issue this cancel.
    On receiving the cancel, if we are processing a Local IRP, we just
    pass the cancel on to the Local Irp which will complete this Irp also
    in its Completion Routine.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    PIO_STACK_LOCATION      pIrpSp;
    IN PIRP                 pLocalIrp;
    tCONNECTELE             *pConnEle;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:NbtCancelConnect ********** Got an Irp Cancel !!! **********\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = pIrpSp->FileObject->FsContext;

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelConnect: ERROR - Invalid Connection Handle\n", 0);
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("Cancel Connect Irp %p ConnEle=%p LowerConn=%p, ClientEle=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle));

    if ((pConnEle) &&
        (pLocalIrp = pConnEle->pIrp))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.NbtCancelConnect: pClientIrp=<%x>, pLocalIrp=<%x>, Device=<%x>, CancelR=<%x>\n",
                pIrp, pLocalIrp, pDeviceContext, pLocalIrp->CancelRoutine));
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        IoCancelIrp(pLocalIrp);
    }
    else
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return;
}


//----------------------------------------------------------------------------
VOID
NbtCancelReceive(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a listen Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    tLOWERCONNECTION     *pLowerConn;
    KIRQL                OldIrq;
    KIRQL                OldIrq1;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    PIRP                 pRcvIrp;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelReceive: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelReceive: ERROR - Invalid Connection Handle\n", 0);
        return;
    }

    NbtTrace(NBT_TRACE_INBOUND, ("Cancel Receive Irp %p ConnEle=%p LowerConn=%p, ClientEle=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle));
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        CTESpinLock(pLowerConn,OldIrq);
    }

    if (pConnEle->Verify == NBT_VERIFY_CONNECTION)
    {
        // now search the connection's receive queue looking for this Irp
        //
        pHead = &pConnEle->RcvHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pRcvIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);
            if (pRcvIrp == pIrp)
            {
                RemoveEntryList(pEntry);

                // complete the irp
                pIrp->IoStatus.Status = STATUS_CANCELLED;

                if (pLowerConn)
                {
                    CTESpinFree(pLowerConn,OldIrq);
                }
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                return;
            }
            pEntry = pEntry->Flink;
        }
    }

    if (pLowerConn)
    {
        CTESpinFree(pLowerConn,OldIrq);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return;
}


//----------------------------------------------------------------------------
VOID
NbtCancelRcvDgram(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a listen Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCLIENTELE           *pClientEle;
    KIRQL                OldIrq;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    tRCVELE              *pRcvEle;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelRcvDgram: Got a Cancel !!! *****************\n"));

    //
    // Need to acquire JointLock before Cancel lock!
    // Bug#: 124405
    //
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    IoAcquireCancelSpinLock(&pIrp->CancelIrql);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientEle = (tCLIENTELE *)pIrpSp->FileObject->FsContext;

    NbtTrace(NBT_TRACE_RECVDGRAM, ("Cancel RcvDgram Irp %p ClientEle=%p", pIrp, pClientEle));

    if (NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT))
    {
        // now search the client's listen queue looking for this connection
        //
        pHead = &pClientEle->RcvDgramHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pRcvEle = CONTAINING_RECORD(pEntry,tRCVELE,Linkage);
            if (pRcvEle->pIrp == pIrp)
            {
                RemoveEntryList(pEntry);

                // complete the irp
                pIrp->IoStatus.Status = STATUS_CANCELLED;

                IoReleaseCancelSpinLock(pIrp->CancelIrql);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                CTEMemFree((PVOID)pRcvEle);

                return;
            }
            pEntry = pEntry->Flink;
        }
    }
    else
    {
        ASSERTMSG ("Nbt.NbtCancelRcvDgram: ERROR - Invalid Address Handle\n", 0);
    }

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return;

}

//----------------------------------------------------------------------------

VOID
NbtCancelFindName(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a FindName Irp - which has
    been passed down by a client (e.g. ping).  Typically, when ping succeeds
    on another adapter, it will issue this cancel.
    On receiving the cancel, we stop any timer that is running in connection
    with name query and then complete the irp with status_cancelled.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    PIO_STACK_LOCATION      pIrpSp;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelFindName: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pTracker = pIrpSp->Parameters.Others.Argument4;

    NbtTrace(NBT_TRACE_NAMESRV, ("Cancel FindName Irp %p pTracker=%p", pIrp, pTracker));

    //
    // We want to ensure that the tracker supplied by FsContext
    // is the right Tracker for this Irp
    //
    if (pTracker && (pIrp == pTracker->pClientIrp))
    {
        //
        // if pClientIrp still valid, completion routine hasn't run yet: go ahead
        // and complete the irp here
        //
        pIrpSp->Parameters.Others.Argument4 = NULL;
        pTracker->pClientIrp = NULL;
        IoReleaseCancelSpinLock(pIrp->CancelIrql);

        NTIoComplete(pIrp,STATUS_CANCELLED,(ULONG)-1);

    } else
    {
        //
        // the completion routine has run.
        //
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return;
}


//----------------------------------------------------------------------------
VOID
NbtCancelLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a DNS name query Irp  or
    the CheckIpAddrs Irp that is passed down to NBT from Lmhsvc

    This routine will get the Resource Lock, and Null the Irp ptr in the
    DnsQueries or CheckAddr structure (as approp) and then return the irp.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tLMHSVC_REQUESTS    *pLmhSvcRequest = NULL;
    KIRQL               OldIrq;


    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pIrp == CheckAddr.QueryIrp)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtCancelLmhSvcIrp: Got a Cancel on CheckAddr Irp !!! *****************\n"));

        NbtTrace(NBT_TRACE_NAMESRV, ("Cancel LmhSvc CheckAddr Irp %p", pIrp));
        pLmhSvcRequest = &CheckAddr;
    }
    else if (pIrp == DnsQueries.QueryIrp)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtCancelLmhSvcIrp: Got a Cancel on DnsQueries Irp !!! *****************\n"));

        NbtTrace(NBT_TRACE_NAMESRV, ("Cancel LmhSvc DnsQueries Irp %p", pIrp));
        pLmhSvcRequest = &DnsQueries;
    }

    if (pLmhSvcRequest)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        pLmhSvcRequest->QueryIrp = NULL;
        pLmhSvcRequest->pIpAddrBuf = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelDisconnectWait(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a Disconnect Wait Irp - which has
    been passed down by a client so that when a disconnect occurs this
    irp will complete and inform the client.  The action here is to simply
    complete the irp with status cancelled.
    down to NBT from Lmhsvc, for the purpose of resolving a name with DNS.
    Nbt will complete this irp each time it has a name to resolve with DNS.

    This routine will get the Resource Lock, and Null the Irp ptr in the
    DnsQueries structure and then return the irp.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    PIO_STACK_LOCATION   pIrpSp;
    CTELockHandle           OldIrq;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Got a Disc Wait Irp Cancel !!! *****************\n"));


    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTESpinLock(pConnEle,OldIrq);
    NbtTrace(NBT_TRACE_OUTBOUND, ("Cancel DisconnectWait Irp %p ConnEle=%p LowerConn=%p, ClientEle=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle));

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelDisconnectWait: ERROR - Invalid Connection Handle\n", 0);
        pIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
    }
    else if (pConnEle->pIrpClose == pIrp)
    {
        pConnEle->pIrpClose = NULL;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
    }

    CTESpinFree(pConnEle,OldIrq);

    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

    return;
}

//----------------------------------------------------------------------------
VOID
NbtCancelWaitForLmhSvcIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a Query to DNS, so that the client's
    irp can be returned to the client.  This cancellation is instigated
    by the client (i.e. RDR).

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    BOOLEAN                 FoundIt = FALSE;
    NBT_WORK_ITEM_CONTEXT   *Context;
    CTELockHandle           OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker;
    PVOID                   pClientCompletion;
    PVOID                   pClientContext;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;


    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelWaitForLmhSvcIrp: Got a Cancel !!! *****************\n"));

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // First check the lmhost list, then the CheckAddr list, then the Dns list
    //
    if (!(Context = FindLmhSvcRequest (DeviceContext, pIrp, &LmHostQueries)))
    {
        if (!(Context = FindLmhSvcRequest (DeviceContext, pIrp, &CheckAddr)))
        {
            Context = FindLmhSvcRequest (DeviceContext, pIrp, &DnsQueries);
        }
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    NbtTrace(NBT_TRACE_NAMESRV, ("Cancel WaitForLmhsvc Irp %p", pIrp));

    //
    // Now complete the clients request to return the irp to the client
    //
    if (Context)
    {
        //
        // this is the name Query tracker
        //
        pTracker = Context->pTracker;
        pClientCompletion = Context->ClientCompletion;
        pClientContext = Context->pClientContext;

        // for dns names (NameLen>16), pTracker would be NULL
        if (pTracker)
        {
            // name did not resolve, so delete from table
            SetNameState (pTracker->pNameAddr, NULL, FALSE);
            NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
        }

        //
        // this should complete any name queries that are waiting on
        // this first name query - i.e. queries to the resolving name
        //
        CompleteClientReq(pClientCompletion, pClientContext, STATUS_CANCELLED);

        CTEMemFree(Context);
    }
}


//----------------------------------------------------------------------------
VOID
NbtCancelDgramSend(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Datagram Send.  The action here is to simply
    complete the irp with status cancelled.

    This routine will Null the Irp ptr in the Tracker structure (if available) so that
    SendDgramContinue does not find it.

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    PIO_STACK_LOCATION      pIrpSp;
    CTELockHandle           OldIrq;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtCancelDgramSend: Got a DatagramSend Irp Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pTracker = pIrpSp->Parameters.Others.Argument4;

    NbtTrace(NBT_TRACE_SENDDGRAM, ("Cancel SendDgram Irp %p", pIrp));

    if ((NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER)) &&
        (pTracker->pClientIrp == pIrp))
    {
        pTracker->pClientIrp = NULL;
        pIrpSp->Parameters.Others.Argument4 = NULL;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoReleaseCancelSpinLock(pIrp->CancelIrql);

        NTIoComplete(pIrp,STATUS_CANCELLED,(ULONG)-1);
    }
    else
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
    }

    return;
}

int
check_unicode_string(IN PUNICODE_STRING str)
{
    try {
        ProbeForRead(str, sizeof (UNICODE_STRING), sizeof(BYTE));
        if ((str->MaximumLength <= 0) || (str->Length <= 0) || (str->Length >= str->MaximumLength)) {
            return (-1);
        }
        ProbeForRead(str->Buffer, str->MaximumLength, sizeof(WCHAR));
        ASSERT((str->Length&1) == 0);
        if (str->Buffer[str->Length/sizeof(WCHAR)]) {
            return (-1);
        }
        return 0;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrint (("Nbt.check_unicode_string: Exception <0x%x> trying to access unicode string 0x%x\n",
            GetExceptionCode(), str));
        return (-1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\ntutil.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Ntutil.c

Abstract:

    This file contains a number of utility and support routines that are
    NT specific.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "ntprocs.h"
#include "stdio.h"
#include <ntddtcp.h>
#undef uint     // undef to avoid a warning where tdiinfo.h redefines it
#include <tcpinfo.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include "ntddip.h"     // Needed for PNETBT_PNP_RECONFIG_REQUEST
#include <align.h>
#include "ntutil.tmh"

NTSTATUS
CreateControlObject(
    tNBTCONFIG  *pConfig
    );

NTSTATUS
NbtProcessDhcpRequest(
    tDEVICECONTEXT  *pDeviceContext);
VOID
GetExtendedAttributes(
    tDEVICECONTEXT  *pDeviceContext
     );

PSTRM_PROCESSOR_LOG      LogAlloc ;
PSTRM_PROCESSOR_LOG      LogFree ;

extern      tTIMERQ TimerQ;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtAllocAndInitDevice)
#pragma CTEMakePageable(PAGE, CreateControlObject)
#pragma CTEMakePageable(PAGE, NbtProcessDhcpRequest)
#pragma CTEMakePageable(PAGE, NbtCreateAddressObjects)
#pragma CTEMakePageable(PAGE, GetExtendedAttributes)
#pragma CTEMakePageable(PAGE, ConvertToUlong)
#pragma CTEMakePageable(PAGE, NbtInitMdlQ)
#pragma CTEMakePageable(PAGE, NTZwCloseFile)
#pragma CTEMakePageable(PAGE, NTReReadRegistry)
#pragma CTEMakePageable(PAGE, DelayedNbtLogDuplicateNameEvent)
#pragma CTEMakePageable(PAGE, DelayedNbtCloseFileHandles)
#pragma CTEMakePageable(PAGE, SaveClientSecurity)
#endif
//*******************  Pageable Routine Declarations ****************

ulong
GetUnique32BitValue(
    void
    )

/*++

Routine Description:

    Returns a reasonably unique 32-bit number based on the system clock.
    In NT, we take the current system time, convert it to milliseconds,
    and return the low 32 bits.

Arguments:

    None.

Return Value:

    A reasonably unique 32-bit value.

--*/

{
    LARGE_INTEGER  ntTime, tmpTime;

    KeQuerySystemTime(&ntTime);

    tmpTime = CTEConvert100nsToMilliseconds(ntTime);

    return(tmpTime.LowPart);
}



//----------------------------------------------------------------------------
NTSTATUS
NbtAllocAndInitDevice(
    PUNICODE_STRING      pucBindName,
    PUNICODE_STRING      pucExportName,
    tDEVICECONTEXT       **ppDeviceContext,
    enum eNbtDevice      DeviceType
    )
/*++

Routine Description:

    This routine mainly allocates the device object and initializes some
    of its fields.

Arguments:


Return Value:

    status

--*/

{
    NTSTATUS            Status;
    PUCHAR              Buffer;
    ULONG               LinkOffset;
    tDEVICECONTEXT      *pDeviceContext;
    PDEVICE_OBJECT      DeviceObject = NULL;

    CTEPagedCode();

    *ppDeviceContext = NULL;

    Buffer = NbtAllocMem(pucExportName->MaximumLength+pucBindName->MaximumLength,NBT_TAG('w'));
    if (Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoCreateDevice (NbtConfig.DriverObject,                                  // Driver Object
                             sizeof(tDEVICECONTEXT)-sizeof(DEVICE_OBJECT),  // Device Extension
                             pucExportName,                                 // Device Name
                             FILE_DEVICE_NETWORK,                           // Device type 0x12
                             FILE_DEVICE_SECURE_OPEN,                       // Device Characteristics
                             FALSE,                                         // Exclusive
                             &DeviceObject);

    if (!NT_SUCCESS( Status ))
    {
        KdPrint(("Nbt.NbtAllocAndInitDevice:  FAILed <%x> ExportDevice=%wZ\n",Status,pucExportName));
        CTEMemFree (Buffer);
        return Status;
    }

    *ppDeviceContext = pDeviceContext = (tDEVICECONTEXT *)DeviceObject;

    //
    // zero out the data structure, beyond the OS specific part
    //
    LinkOffset = FIELD_OFFSET(tDEVICECONTEXT, Linkage);
    CTEZeroMemory (&pDeviceContext->Linkage, sizeof(tDEVICECONTEXT)-LinkOffset);

    // initialize the pDeviceContext data structure.  There is one of
    // these data structured tied to each "device" that NBT exports
    // to higher layers (i.e. one for each network adapter that it
    // binds to.
    InitializeListHead (&pDeviceContext->Linkage);  // Sets the forward link = back link = list head
    InitializeListHead (&pDeviceContext->UpConnectionInUse);
    InitializeListHead (&pDeviceContext->LowerConnection);
    InitializeListHead (&pDeviceContext->LowerConnFreeHead);
    InitializeListHead (&pDeviceContext->WaitingForInbound);
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
    KeInitializeEvent(&pDeviceContext->DelayedNotificationCompleteEvent, NotificationEvent, FALSE);
#endif

    // put a verifier value into the structure so that we can check that
    // we are operating on the right data when the OS passes a device context
    // to NBT
    pDeviceContext->Verify      = NBT_VERIFY_DEVCONTEXT;
    pDeviceContext->DeviceType  = DeviceType;   // Default
    CTEInitLock(&pDeviceContext->LockInfo.SpinLock);     // setup the spin lock
#if DBG
    pDeviceContext->LockInfo.LockNumber  = DEVICE_LOCK;
#endif

    pDeviceContext->RefCount = 1;       // Dereferenced when the Device is destroyed
// #if DBG
    pDeviceContext->ReferenceContexts[REF_DEV_CREATE]++;
// #endif  // DBG
    pDeviceContext->IPInterfaceContext = (ULONG)-1;    // by default

    pDeviceContext->ExportName.MaximumLength = pucExportName->MaximumLength;
    pDeviceContext->ExportName.Buffer = (PWSTR)Buffer;
    RtlCopyUnicodeString(&pDeviceContext->ExportName,pucExportName);
    pDeviceContext->BindName.MaximumLength = pucBindName->MaximumLength;
    pDeviceContext->BindName.Buffer = (PWSTR)(Buffer+pucExportName->MaximumLength);
    RtlCopyUnicodeString(&pDeviceContext->BindName,pucBindName);
    KeInitializeEvent (&pDeviceContext->DeviceCleanedupEvent, NotificationEvent, FALSE);

    pDeviceContext->EnableNagling = FALSE;

    // IpAddress, AssignedIpAddress, and NumAdditionalIpAddresses fields should be = 0
    // DeviceRegistrationHandle and NetAddressRegistrationHandle should be NULL
    // DeviceRefreshState and WakeupPatternRefCount should also be = 0
    return (Status);
}


NTSTATUS
NTQueryIPForInterfaceInfo(
    tDEVICECONTEXT  *pDeviceContext
    )
{
    PVOID               *pIPInfo;
    PIP_INTERFACE_INFO  pIPIfInfo;
    ULONG               BufferLen;
    NTSTATUS            status;
    ULONG               NextAdapterNumber;
    UNICODE_STRING      ucDeviceName;
    ULONG               Input, Metric, IfContext;

    if (NT_SUCCESS (status = NbtQueryIpHandler (pDeviceContext->pControlFileObject,
                                                IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER,
                                                (PVOID *) &pDeviceContext->pFastSend)))
    {
        BufferLen = sizeof(PVOID *);
        if (NT_SUCCESS (status = NbtProcessIPRequest (IOCTL_IP_GET_BESTINTFC_FUNC_ADDR,
                                                      NULL,         // No Input buffer
                                                      0,
                                                      (PVOID *) &pIPInfo,
                                                      &BufferLen)))
        {
            pDeviceContext->pFastQuery = *pIPInfo;
            CTEMemFree (pIPInfo);
            pIPInfo = NULL;
            if (pDeviceContext->pFastQuery) {
                /*
                 * Get the context for loopback IP address.
                 */
                IfContext = 0xffff;
                pDeviceContext->pFastQuery (ntohl(INADDR_LOOPBACK), &IfContext, &Metric);
                if (IfContext != 0xffff) {
                    NbtConfig.LoopbackIfContext = IfContext;
                }
            }
        }
        else
        {
            KdPrint (("Nbt.NTQueryIPForInterfaceInfo: ERROR: <%x> pFastQuery on Device:\n\t<%wZ>!\n",
                        status, &pDeviceContext->BindName));
            pDeviceContext->pFastQuery = NULL;
        }
    }
    else
    {
        KdPrint (("Nbt.NTQueryIPForInterfaceInfo: ERROR:<%x>, Irql=<%d>,pFastSend on Device:\n\t<%wZ>!\n",
                    status, KeGetCurrentIrql(), &pDeviceContext->BindName));
        pDeviceContext->pFastSend = NULL;
    }

    if ((pDeviceContext->DeviceType == NBT_DEVICE_NETBIOSLESS) ||
        (pDeviceContext->DeviceType == NBT_DEVICE_CLUSTER))
    {
        //
        // Cluster devices do not have any real InterfaceContext -- initialized to -1 by default
        //
        // Determine the InterfaceContext for the Loopback address
        //
        if ((NT_SUCCESS (status)) &&
            (pDeviceContext->DeviceType == NBT_DEVICE_NETBIOSLESS))
        {
            ASSERT (pDeviceContext->pFastQuery);
            pDeviceContext->pFastQuery (ntohl(INADDR_LOOPBACK), &pDeviceContext->IPInterfaceContext, &Metric);
        }
    }
    else if (NT_SUCCESS (status))
    {
        //
        // Get the InterfaceContext for this adapter
        //
        BufferLen = sizeof(IP_ADAPTER_INDEX_MAP) * (NbtConfig.AdapterCount+2);
        status = NbtProcessIPRequest (IOCTL_IP_INTERFACE_INFO,
                                      NULL,         // No Input buffer
                                      0,
                                      &pIPIfInfo,
                                      &BufferLen);

        if (NT_SUCCESS(status))
        {
            status = STATUS_UNSUCCESSFUL;
            for(NextAdapterNumber=0; NextAdapterNumber<(ULONG)pIPIfInfo->NumAdapters; NextAdapterNumber++)
            {
                ucDeviceName.Buffer = pIPIfInfo->Adapter[NextAdapterNumber].Name;
                ucDeviceName.Length = ucDeviceName.MaximumLength =
                                    (sizeof (WCHAR)) * wcslen(pIPIfInfo->Adapter[NextAdapterNumber].Name);

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("[%d/%d]\t<%wZ>\n",
                        NextAdapterNumber+1, pIPIfInfo->NumAdapters, &ucDeviceName));

                if (RtlCompareUnicodeString (&ucDeviceName, &pDeviceContext->BindName, TRUE) == 0)
                {
                    pDeviceContext->IPInterfaceContext = pIPIfInfo->Adapter[NextAdapterNumber].Index;
                    status = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(status))
            {
                BufferLen = sizeof (ULONG);
                Input = pDeviceContext->IPInterfaceContext;

                //
                // Query the latest WOL capabilities on this adapter!
                //
                if (NT_SUCCESS (status = NbtProcessIPRequest (IOCTL_IP_GET_WOL_CAPABILITY,
                                                              &Input,      // Input buffer
                                                              BufferLen,
                                                              (PVOID) &pIPInfo,
                                                              &BufferLen)))
                {
                    ASSERT (pIPInfo);
                    pDeviceContext->WOLProperties = * ((PULONG) pIPInfo);
                    CTEMemFree (pIPInfo);
                    pIPInfo = NULL;
                }

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NTQueryIPForInterfaceInfo[GET_WOL_CAPABILITY]: <%x>, pDeviceContext=<%p>, Input=<%x>, Result=<%x>\n",status, pDeviceContext, Input, pDeviceContext->WOLProperties));
            }
            else
            {
                KdPrint (("Nbt.NTQueryIPForInterfaceInfo:  Could not find IpInterface from [%d]:\n<%wZ>\n",
                    (ULONG)pIPIfInfo->NumAdapters, &pDeviceContext->BindName));
            }

            CTEMemFree (pIPIfInfo);
        }
        else
        {
            KdPrint (("Nbt.NTQueryIPForInterfaceInfo: ERROR<%x>, No InterfaceContext for Device:<%wZ>!\n",
                &pDeviceContext->BindName));
        }
    }

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtCreateDeviceObject(
    PUNICODE_STRING      pucBindName,
    PUNICODE_STRING      pucExportName,
    tADDRARRAY           *pAddrs,
    tDEVICECONTEXT       **ppDeviceContext,
    enum eNbtDevice      DeviceType
    )

/*++

Routine Description:

    This routine initializes a Driver Object from the device object passed
    in and the name of the driver object passed in.  After the Driver Object
    has been created, clients can "Open" the driver by that name.

    For the Netbiosless device, do not insert on device list.

Arguments:


Return Value:

    status - the outcome

--*/

{

    NTSTATUS            status;
    PDEVICE_OBJECT      DeviceObject = NULL;
    tDEVICECONTEXT      *pDeviceContext;
    tDEVICECONTEXT      *pDeviceContextOther;
    ULONG               ulIpAddress;
    CTELockHandle       OldIrq1;
    CTEULONGLONG        NextAdapterMask;
    ULONG               NextAdapterNumber;
    BOOLEAN             fAttached = FALSE;
    BOOLEAN             fInserted;
#ifdef _NETBIOSLESS
    BOOLEAN             fStopInitTimers = FALSE;

    if (DeviceType != NBT_DEVICE_NETBIOSLESS)
#endif
    {
        //
        // We need to acquire this lock since we can have multiple devices
        // being added simultaneously and hence we will need to have a unique
        // Adapter Number for each device
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        //
        // Check to make sure we have not yet crossed the limit!
        //
        if (NbtConfig.AdapterCount >= NBT_MAXIMUM_BINDINGS)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            KdPrint(("Nbt.NbtCreateDeviceObject: ERROR -- Cannot add new device=<%ws>, Max=<%d> reached\n",
                pucBindName->Buffer, NBT_MAXIMUM_BINDINGS));

            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        NbtConfig.AdapterCount++;

        //
        // If this is the first Device, we need to start the Timers
        //
        if (NbtConfig.AdapterCount == 1)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            status = InitTimersNotOs();

            CTESpinLock(&NbtConfig.JointLock,OldIrq1);
            //
            // If we failed and no one else also started the timers, then fail
            //
            if ((status != STATUS_SUCCESS) && (!(--NbtConfig.AdapterCount)))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                KdPrint(("Nbt.NbtCreateDeviceObject: InitTimersNotOs FAILed, failing to add device %ws\n",
                    pucBindName->Buffer));

                NbtLogEvent (EVENT_NBT_TIMERS, status, 0x112);
                StopInitTimers();
                return status;
            }
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }

    status = NbtAllocAndInitDevice (pucBindName, pucExportName, ppDeviceContext, DeviceType);
    if (!NT_SUCCESS(status))
    {
        KdPrint(("Nbt.NbtCreateDeviceObject: NbtAllocAndInitDevice returned status=%X\n",status));

        //
        // If we failed to add the first device stop the timers
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

#ifdef _NETBIOSLESS
        // SmbDevice does not affect adapter count
        if ((DeviceType != NBT_DEVICE_NETBIOSLESS) &&
            (!(--NbtConfig.AdapterCount)))
#else
        if (!(--NbtConfig.AdapterCount))
#endif
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            StopInitTimers();
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }

        return(status);
    }

    DeviceObject = (PDEVICE_OBJECT) (pDeviceContext = *ppDeviceContext);

    //
    // for a Bnode pAddrs is NULL
    //
    if (pAddrs)
    {
#ifdef MULTIPLE_WINS
        int i;
#endif

        pDeviceContext->lNameServerAddress  = pAddrs->NameServerAddress;
        pDeviceContext->lBackupServer       = pAddrs->BackupServer;
        pDeviceContext->RefreshToBackup     = 0;
        pDeviceContext->SwitchedToBackup    = 0;
#ifdef MULTIPLE_WINS
        pDeviceContext->lNumOtherServers    = pAddrs->NumOtherServers;
        pDeviceContext->lLastResponsive     = 0;
        for (i = 0; i < pAddrs->NumOtherServers; i++)
        {
            pDeviceContext->lOtherServers[i] = pAddrs->Others[i];
        }
#endif
#ifdef _NETBIOSLESS
        pDeviceContext->NetbiosEnabled       = pAddrs->NetbiosEnabled;
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtCreateDeviceObject: %wZ NetbiosEnabled = %d\n",
                 &pDeviceContext->ExportName, pDeviceContext->NetbiosEnabled));
#endif
        pDeviceContext->RasProxyFlags        = pAddrs->RasProxyFlags;
        pDeviceContext->EnableNagling        = pAddrs->EnableNagling;
        //
        // if the node type is set to Bnode by default then switch to Hnode if
        // there are any WINS servers configured.
        //
        if ((NodeType & DEFAULT_NODE_TYPE) &&
            (pAddrs->NameServerAddress || pAddrs->BackupServer))
        {
            NodeType = MSNODE | (NodeType & PROXY_NODE);
        }
    }
#ifdef _NETBIOSLESS
    else
    {
        pDeviceContext->NetbiosEnabled = TRUE;
        pDeviceContext->RasProxyFlags  = 0;
        pDeviceContext->EnableNagling  = FALSE;
    }
#endif

    CTEAttachFsp(&fAttached, REF_FSP_CREATE_DEVICE);

    status = NbtTdiOpenControl(pDeviceContext);
    if (NT_SUCCESS (status))
    {
        status = NTQueryIPForInterfaceInfo (pDeviceContext);
    }
    else
    {
        KdPrint(("Nbt.NbtCreateDeviceObject: NbtTdiOpenControl returned status=%X\n",status));
    }

    CTEDetachFsp(fAttached, REF_FSP_CREATE_DEVICE);

    if (NT_SUCCESS(status))
    {
        // increase the stack size of our device object, over that of the transport
        // so that clients create Irps large enough
        // to pass on to the transport below.
        // In theory, we should just add 1 here, to account for our presence in the
        // driver chain.
        //
        DeviceObject->StackSize = pDeviceContext->pControlDeviceObject->StackSize + 1;

        //
        // Get an Irp for the out of resource queue (used to disconnect sessions
        // when really low on memory)
        //
        if (!NbtConfig.OutOfRsrc.pIrp)
        {
            NbtConfig.OutOfRsrc.pIrp = NTAllocateNbtIrp(&pDeviceContext->DeviceObject);
            if (NbtConfig.OutOfRsrc.pIrp)
            {
                //
                // allocate a dpc structure and keep it: we might need if we hit an
                // out-of-resource condition
                //
                NbtConfig.OutOfRsrc.pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('a'));
                if (!NbtConfig.OutOfRsrc.pDpc)
                {
                    IoFreeIrp(NbtConfig.OutOfRsrc.pIrp);
                    NbtConfig.OutOfRsrc.pIrp = NULL;
                }
            }

            if ((!NbtConfig.OutOfRsrc.pIrp) || (!NbtConfig.OutOfRsrc.pDpc))
            {
                KdPrint(("Nbt.NbtCreateDeviceObject: Could not create OutOfRsrc Irps!\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (!NT_SUCCESS (status))
    {
        //
        // We failed somewhere, so clean up!
        //
        if (pDeviceContext->hControl)
        {
            CTEAttachFsp(&fAttached, REF_FSP_CREATE_DEVICE);
            ObDereferenceObject(pDeviceContext->pControlFileObject);
            NTZwCloseFile(pDeviceContext->hControl);
            pDeviceContext->pControlFileObject = NULL;
            pDeviceContext->hControl = NULL;
            CTEDetachFsp(fAttached, REF_FSP_CREATE_DEVICE);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        //
        // If this was the last Device to go away, stop the timers
        // (SmbDevice does not affect adapter count)
        //
        if (DeviceType == NBT_DEVICE_NETBIOSLESS)
        {
            if (!(NbtConfig.AdapterCount))
            {
                fStopInitTimers = TRUE;
            }
        }
        else if (!(--NbtConfig.AdapterCount))
        {
            fStopInitTimers = TRUE;
        }
        else if (NbtConfig.AdapterCount == 1)
        {
            NbtConfig.MultiHomed = FALSE;
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        if (fStopInitTimers)
        {
            StopInitTimers();
        }

        *ppDeviceContext = NULL;
        CTEMemFree (pDeviceContext->ExportName.Buffer);
        IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);

        NbtLogEvent (EVENT_NBT_CREATE_DEVICE, status, 0x113);

        return (status);
    }

    pDeviceContext->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;
#ifdef _NETBIOSLESS
    pDeviceContext->SessionPort = NBT_SESSION_TCP_PORT;
    pDeviceContext->NameServerPort = NBT_NAMESERVICE_UDP_PORT;
    pDeviceContext->DatagramPort = NBT_DATAGRAM_UDP_PORT;
    RtlZeroMemory (pDeviceContext->MessageEndpoint, NETBIOS_NAME_SIZE);
#endif

    //
    // An instance number is assigned to each device so that the service which
    // creates logical devices in Nbt can re-use these devices in case it fails
    // to destroy them in a prev. instance.
    //
    pDeviceContext->InstanceNumber = GetUnique32BitValue();

    //
    // Now set the Adapter number for this device
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    //
    // See if we have a gap in the AdapterMask of the current set of Devices
    // which we can utilize
    //
#ifdef _NETBIOSLESS
    // SmbDevice does not affect adapter count
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        NextAdapterNumber = 0;
        NextAdapterMask = 0xffffffffffffffff;
    }
    else
#endif
    {
        NextAdapterNumber = 1;  // 0 is for the SmbDevice!
        NextAdapterMask = 1;
        fInserted = FALSE;
        if (!IsListEmpty(&NbtConfig.DeviceContexts))
        {
            PLIST_ENTRY         pHead, pEntry;
            tDEVICECONTEXT      *pTmpDevContext;

            pHead = &NbtConfig.DeviceContexts;
            pEntry = pHead;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                pTmpDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                if (pTmpDevContext->AdapterMask > NextAdapterMask)
                {
                    pDeviceContext->Linkage.Flink = pEntry;
                    pDeviceContext->Linkage.Blink = pEntry->Blink;
                    pEntry->Blink->Flink = &pDeviceContext->Linkage;
                    pEntry->Blink = &pDeviceContext->Linkage;
                    fInserted = TRUE;
                    break;
                }

                NextAdapterNumber++;
                NextAdapterMask = (pTmpDevContext->AdapterMask) << 1;
            }
        }
        if (!fInserted)
        {
            // add this new device context on to end of the List in the
            // configuration data structure
            InsertTailList(&NbtConfig.DeviceContexts, &pDeviceContext->Linkage);
        }
    }

    NbtConfig.CurrentAdaptersMask |= NextAdapterMask;
    if ((1+NbtConfig.AdapterCount) > NbtConfig.RemoteCacheLen)  // Add 1 for the SmbDevice
    {
        NbtConfig.RemoteCacheLen += REMOTE_CACHE_INCREMENT;
    }

    // We keep a bit mask around to keep track of this adapter number so we can
    // quickly find if a given name is registered on a particular adapter,
    // by a corresponding bit set in the tNAMEADDR - local hash table entry
    //
    pDeviceContext->AdapterMask = NextAdapterMask;
    pDeviceContext->AdapterNumber = NextAdapterNumber;

    IF_DBG(NBT_DEBUG_NTUTIL)
        KdPrint (("Nbt.NbtCreateDeviceObject: Device=<%x>, New AdapterCount=<%d>, AdapterMask=<%lx:%lx>\n",
            pDeviceContext, NbtConfig.AdapterCount, NextAdapterMask));

    if (NbtConfig.AdapterCount > 1)
    {
        NbtConfig.MultiHomed = TRUE;
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
tDEVICECONTEXT *
GetDeviceWithIPAddress(
    tIPADDRESS  IpAddress
    )
/*++
Routine Description:

    This Routine references the device with preferably the requested
    IP address, otherwise, it will pick the first device with
    a valid IP address

    This routine must be called with the JointLock held!

Arguments:


Return Value:

    pDeviceContext

--*/

{
    LIST_ENTRY      *pEntry;
    LIST_ENTRY      *pHead;
    tDEVICECONTEXT  *pDeviceContext;
    tDEVICECONTEXT  *pDeviceContextWithIp = NULL;

    if (!IpAddress)
    {
        return NULL;
    }

    //
    // Find the device with this Ip address
    //
    pHead = pEntry = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContext = CONTAINING_RECORD (pEntry,tDEVICECONTEXT,Linkage);
        if (pDeviceContext->IpAddress)
        {
            if (IpAddress == pDeviceContext->IpAddress)
            {
                return pDeviceContext;
            }
            else if (!pDeviceContextWithIp)
            {
                pDeviceContextWithIp = pDeviceContext;
            }
        }
    }

    //
    // Couldn't find a Device with the requested IP address!
    // So, in the meantime return the first valid Device with an IP address (if any)
    //
    return pDeviceContextWithIp;
}


//----------------------------------------------------------------------------
#define MAX_REFERENCES  5000

BOOLEAN
NBT_REFERENCE_DEVICE(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN ULONG            ReferenceContext,
    IN BOOLEAN          fLocked
    )
{
    BOOLEAN         fStatus;
    CTELockHandle   OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    if (NBT_VERIFY_HANDLE (pDeviceContext, NBT_VERIFY_DEVCONTEXT))
    {
        InterlockedIncrement(&pDeviceContext->RefCount);
// #if DBG
        pDeviceContext->ReferenceContexts[ReferenceContext]++;
        ASSERT (pDeviceContext->ReferenceContexts[ReferenceContext] <= MAX_REFERENCES);
// #endif  // DBG
        fStatus = TRUE;
    }
    else
    {
        fStatus = FALSE;
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return (fStatus);
}


VOID
NBT_DEREFERENCE_DEVICE(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN ULONG            ReferenceContext,
    IN BOOLEAN          fLocked
    )
/*++
Routine Description:

    This Routine Dereferences the DeviceContext and queues it on
    to the worker thread if the the Device needs to be deleted

    This routine may be called with the JointLock held!

Arguments:

    pContext

Return Value:

    NONE

--*/

{
    CTELockHandle           OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    ASSERT (NBT_VERIFY_HANDLE2(pDeviceContext, NBT_VERIFY_DEVCONTEXT, NBT_VERIFY_DEVCONTEXT_DOWN));
    ASSERT (pDeviceContext->ReferenceContexts[ReferenceContext]);
// #if DBG
    pDeviceContext->ReferenceContexts[ReferenceContext]--;
// #endif  // DBG

    if (!(--pDeviceContext->RefCount))
    {
#if DBG
        {
            ULONG   i;
            for (i=0; i<REF_DEV_MAX; i++)
            {
                ASSERT(0 == pDeviceContext->ReferenceContexts[i]);
            }
        }
#endif  // DBG

        //
        // We cannot delete the device directly here since we are at raised Irql
        //
        CTEQueueForNonDispProcessing( DelayedNbtDeleteDevice,
                                      NULL,
                                      pDeviceContext,
                                      NULL,
                                      NULL,
                                      TRUE);
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


NTSTATUS
NbtDestroyDevice(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN BOOLEAN          fWait
    )
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pHead;
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   Context;
    CTELockHandle           OldIrq;
    BOOLEAN                 fRemoveFromSmbList = FALSE;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT))
    {
        ASSERT (NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT_DOWN));
        return (STATUS_INVALID_DEVICE_REQUEST);
    }
    //
    // First remove the Device from the NbtConfig list
    // (no-op for Wins and SmbDevice)
    //
    RemoveEntryList (&pDeviceContext->Linkage);
    if ((pDeviceContext->DeviceType != NBT_DEVICE_NETBIOSLESS) &&
        (pDeviceContext->IPInterfaceContext != (ULONG)-1))
    {
        if (pDeviceContext->AdapterMask & NbtConfig.ServerMask) {
            fRemoveFromSmbList = TRUE;
            NbtConfig.ServerMask &= (~pDeviceContext->AdapterMask);
        }
        NbtConfig.ClientMask &= (~pDeviceContext->AdapterMask);
    }

    pDeviceContext->Verify = NBT_VERIFY_DEVCONTEXT_DOWN;
    //
    // Clear out the DeviceContext entry from the IPContext-to-Device Map
    //
    NbtConfig.CurrentAdaptersMask &= ~pDeviceContext->AdapterMask;
    //
    // Remove any pending requests in the LmHosts or Dns or CheckAddrs Q's
    // This has to be done immediately after we change the device
    // state before releasing the lock.
    //
    TimeoutLmHRequests (NULL, pDeviceContext, TRUE, &OldIrq);

    if ((fRemoveFromSmbList) &&
        (pNbtSmbDevice) &&
        (NBT_REFERENCE_DEVICE (pNbtSmbDevice, REF_DEV_SMB_BIND, TRUE)))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        //
        // Set the Session port info
        //
        if (pNbtSmbDevice->hSession)
        {
            NbtSetTcpInfo (pNbtSmbDevice->hSession,
                           AO_OPTION_DEL_IFLIST,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContext->IPInterfaceContext);
        }

        //
        // Now, set the same for the Datagram port
        //
        if ((pNbtSmbDevice->pFileObjects) &&
            (pNbtSmbDevice->pFileObjects->hDgram))
        {
            NbtSetTcpInfo (pNbtSmbDevice->pFileObjects->hDgram,
                           AO_OPTION_DEL_IFLIST,
                           INFO_TYPE_ADDRESS_OBJECT,
                           pDeviceContext->IPInterfaceContext);
        }
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_DEVICE (pNbtSmbDevice, REF_DEV_SMB_BIND, TRUE);
    }

    //
    // If we still have any timers running on this Device, stop them!
    //
    pHead = &TimerQ.ActiveHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pTimer = CONTAINING_RECORD(pEntry,tTIMERQENTRY,Linkage);
        if (pTimer->pDeviceContext == (PVOID) pDeviceContext)
        {
            StopTimer(pTimer,&pClientCompletion,&Context);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (pClientCompletion)
            {
                (*pClientCompletion)(Context, STATUS_TIMEOUT);
            }

            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("NbtDestroyDevice: stopped timer on this Device")) ;

            CTESpinLock(&NbtConfig.JointLock,OldIrq);

            pEntry = pHead->Flink;  // Restart from the beginning since we released the lock
        }
        else
        {
            pEntry = pEntry->Flink;
        }
    }

    // Now do the Dereference which will cause this Device to be destroyed!
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_CREATE, TRUE);

    if (fWait)
    {
        NTSTATUS   status;

        InitializeListHead (&pDeviceContext->Linkage);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("Nbt.NbtDestroyDevice: Waiting on Device=<%p>:\n\t%wZ\n",
                pDeviceContext, &pDeviceContext->ExportName));
        //
        // Wait for all pending Timer and worker requests which have referenced this
        // Device to complete!
        //
        status = KeWaitForSingleObject (&pDeviceContext->DeviceCleanedupEvent,  // Object to wait on.
                               Executive,            // Reason for waiting
                               KernelMode,           // Processor mode
                               FALSE,                // Alertable
                               NULL);                // Timeout
        ASSERT(status == STATUS_SUCCESS);

        KdPrint(("Nbt.NbtDestroyDevice: *** Destroying Device *** \n\t%wZ\n", &pDeviceContext->ExportName));

        CTEMemFree (pDeviceContext->ExportName.Buffer);
        IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);
    }
    else
    {
        //
        // Put it here so that the Cleanup routine can find this Device
        //
        InsertTailList(&NbtConfig.DevicesAwaitingDeletion,&pDeviceContext->Linkage);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return (STATUS_SUCCESS);
}


/*******************************************************************

    NAME:       DelayedNbtDeleteDevice

    SYNOPSIS:   This Routine is the worker thread for Deleting the
                DeviceObject at PASSIVE level Irql

    ENTRY:      pDeviceContext - name of the device/ device ptr

    Return Value: NONE

********************************************************************/

VOID
DelayedNbtDeleteDevice(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )
{
    LIST_ENTRY            * pEntry;
    LIST_ENTRY            * pHead;
    LIST_ENTRY            * pClientEntry;
    LIST_ENTRY              TempList;
    tDEVICECONTEXT        * pTmpDeviceContext;
    tDEVICECONTEXT        * pNextDeviceContext;
    tCLIENTELE            * pClientEle;
    tCLIENTELE            * pLastClient;
    tADDRESSELE           * pAddress;
    tADDRESSELE           * pLastAddress;
    tNAMEADDR             * pNameAddr;
    tCONNECTELE           * pConnEle;
    tLOWERCONNECTION      * pLowerConn;
    tTIMERQENTRY          * pTimer;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   Context;
    tDGRAM_SEND_TRACKING  * pTracker;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    int                     i;
    WCHAR                   Buffer[MAX_PATH];
    UNICODE_STRING          ucExportName;
    PUNICODE_STRING         pucExportName;
    BOOLEAN                 Attached;
#ifdef _PNP_POWER_
    NTSTATUS                Status;
#endif  // _PNP_POWER_
    BOOLEAN                 fDelSmbDevice = FALSE;
    BOOLEAN                 fStopInitTimers = FALSE;
    BOOLEAN                 fNameReferenced = FALSE;
    tDEVICECONTEXT        * pDeviceContext = (tDEVICECONTEXT *) pContext;

    ASSERT (NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT_DOWN));

    //
    // Mark in the device extension that this is not a valid device anymore
    //
    pDeviceContext->Verify += 10;

    //
    // DeRegister this Device for our clients
    //
    if (pDeviceContext->NetAddressRegistrationHandle)
    {
        Status = TdiDeregisterNetAddress (pDeviceContext->NetAddressRegistrationHandle);
        pDeviceContext->NetAddressRegistrationHandle = NULL;
        NbtTrace(NBT_TRACE_PNP, ("DeregisterNetAddress: ExportName=%Z BindName=%Z status=%!status!",
            &pDeviceContext->ExportName, &pDeviceContext->BindName, Status));
    }
    if (pDeviceContext->DeviceRegistrationHandle)
    {
        Status = TdiDeregisterDeviceObject (pDeviceContext->DeviceRegistrationHandle);
        pDeviceContext->DeviceRegistrationHandle = NULL;
        NbtTrace(NBT_TRACE_PNP, ("DeregisterDevice: ExportName=%Z BindName=%Z status=%!status!",
            &pDeviceContext->ExportName, &pDeviceContext->BindName, Status));
    }
    if (!IsDeviceNetbiosless(pDeviceContext)) {
        NbtRemovePermanentName(pDeviceContext);
    }

    if (pDeviceContext->IpAddress)
    {
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint (("Nbt.DelayedNbtDeleteDevice: device %wZ deregistered\n",
                          &(pDeviceContext->ExportName) ));
        }

        CloseAddressesWithTransport(pDeviceContext);

        //
        // Dhcp is has passed down a null IP address meaning that it has
        // lost the lease on the previous address, so close all connections
        // to the transport - pLowerConn.
        //
        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
        DisableInboundConnections (pDeviceContext);
        CTEExReleaseResource(&NbtConfig.Resource);
    }

    if (pDeviceContext->pControlFileObject)
    {
        BOOLEAN Attached;

        CTEAttachFsp(&Attached, REF_FSP_DELETE_DEVICE);

        ObDereferenceObject(pDeviceContext->pControlFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tDelayedNbtDeleteDevice->ObDereferenceObject\n", pDeviceContext->pControlFileObject));
        Status = ZwClose(pDeviceContext->hControl);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tDelayedNbtDeleteDevice->ZwClose, status = <%x>\n", pDeviceContext->hControl, Status));

        pDeviceContext->pControlFileObject = NULL;
        pDeviceContext->hControl = NULL;

        CTEDetachFsp(Attached, REF_FSP_DELETE_DEVICE);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);

    ASSERT(IsListEmpty(&pDeviceContext->LowerConnFreeHead));

    //
    // walk through all names and see if any is being registered on this
    // device context: if so, stop and complete it!
    //
    for (i=0;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
    {
        pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

            //
            // if a name registration or refresh or release was started for this name
            // on this device context, stop the timer.  (Completion routine will take care of
            // doing registration on other device contexts if applicable)
            //
            if ((pTimer = pNameAddr->pTimer) &&
                (pTracker = pTimer->Context) &&
                (pTracker->pDeviceContext == pDeviceContext))
            {
                ASSERT(pTracker->pNameAddr == pNameAddr);

                pNameAddr->pTimer = NULL;

                StopTimer(pTimer,&pClientCompletion,&Context);

                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_DELETE_DEVICE);
                fNameReferenced = TRUE;

                CTESpinFree(pDeviceContext,OldIrq1);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                if (pClientCompletion)
                {
                    (*pClientCompletion)(Context,STATUS_TIMEOUT);
                }

                IF_DBG(NBT_DEBUG_NTUTIL)
                    KdPrint(("DelayedNbtDeleteDevice: stopped name reg timer")) ;

                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                CTESpinLock(pDeviceContext,OldIrq1);
            }

            pEntry = pEntry->Flink;
            if (fNameReferenced)
            {
                fNameReferenced = FALSE;
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_DELETE_DEVICE);
            }
        }
    }

    CTESpinFree(pDeviceContext,OldIrq1);

    //
    // Walk through the AddressHead list.  If any addresses exist and they
    // point to this device context, put the next device context.  Also, update
    // adapter mask to reflect that this device context is now gone.
    //
    pLastAddress = NULL;
    pLastClient = NULL;
    pHead = pEntry = &NbtConfig.AddressHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pAddress = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);
        ASSERT (pAddress->Verify == NBT_VERIFY_ADDRESS);

        //
        // Keep this Address around until we are done
        //
        NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_DEL_DEVICE);

        //
        // If we had referenced a previous address, Deref it now!
        //
        if (pLastAddress)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            //
            // The last Client may need to have the address present
            // while dereferencing, so deref it if we need to!
            //
            if (pLastClient)
            {
                NBT_DEREFERENCE_CLIENT(pLastClient);
                pLastClient = NULL;
            }

            NBT_DEREFERENCE_ADDRESS (pLastAddress, REF_ADDR_DEL_DEVICE);
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
        }

        pLastAddress = pAddress;    // => Save this so that we can Deref it later

        //
        // Need AddressLock to traverse ClientHead
        //
        CTESpinLock (pAddress, OldIrq2);

        pClientEntry = &pAddress->ClientHead;
        while ((pClientEntry = pClientEntry->Flink) != &pAddress->ClientHead)
        {
            pClientEle = CONTAINING_RECORD (pClientEntry,tCLIENTELE,Linkage);

            if (pClientEle->pDeviceContext == pDeviceContext)
            {
                CTESpinFree(pAddress, OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                KdPrint(("Nbt.DelayedNbtDeleteDevice: Client:Context <%-16.16s:%x>:<%x>, EVReceive:EVContext=<%x:%x>\n\tFAILed to Cleanup on Device<%x>\n",
                    pAddress->pNameAddr->Name, pAddress->pNameAddr->Name[15],
                    pClientEle, pClientEle->evReceive, pClientEle->RcvEvContext, pDeviceContext));

                if (pLastClient)
                {
                    NBT_DEREFERENCE_CLIENT(pLastClient);
                }

                pClientEle->pIrp = NULL;
                NbtCleanUpAddress(pClientEle,pDeviceContext);

                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                CTESpinLock (pAddress, OldIrq2);
                pLastClient = pClientEle;   // pClientEle still needs one more Deref
            }
        }

        pAddress->pNameAddr->AdapterMask &= (~pDeviceContext->AdapterMask);   // Clear Adapter Mask
        pAddress->pNameAddr->ConflictMask &= (~pDeviceContext->AdapterMask);

        if ((!(pAddress->pNameAddr->AdapterMask)) &&
            (pAddress->pNameAddr->NameTypeState & STATE_CONFLICT))
        {
            pAddress->pNameAddr->NameTypeState &= (~NAME_STATE_MASK);
            pAddress->pNameAddr->NameTypeState |= STATE_RESOLVED;
        }
        CTESpinFree(pAddress, OldIrq2);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // If we had referenced a previous Client or Address, Deref it now!
    //
    if (pLastClient)
    {
        NBT_DEREFERENCE_CLIENT(pLastClient);
    }
    if (pLastAddress)
    {
        NBT_DEREFERENCE_ADDRESS (pLastAddress, REF_ADDR_DEL_DEVICE);
    }

    //
    // if a call was started, but aborted then we could have some memory here!
    //
    while (!IsListEmpty(&pDeviceContext->UpConnectionInUse))
    {
        pEntry = RemoveHeadList(&pDeviceContext->UpConnectionInUse);
        pConnEle = CONTAINING_RECORD(pEntry,tCONNECTELE,Linkage);
        NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CREATE);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);
    //
    //  We have finished our regular cleanup, so now close all the remaining TDI handles
    //
    while (!IsListEmpty(&pDeviceContext->LowerConnection))
    {
        pEntry = RemoveHeadList(&pDeviceContext->LowerConnection);
        InitializeListHead (pEntry);
        pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint (("Nbt.DelayedNbtDeleteDevice:  Dereferencing pLowerConn <%x>\n", pLowerConn));
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
    }
    CTESpinFree(pDeviceContext,OldIrq1);

    //
    // If this was the last Device to go away, stop the timers
    // (SmbDevice does not affect adapter count)
    //
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        if (!(NbtConfig.AdapterCount))
        {
            //
            // No more devices funtioning, so stop the timers now!
            //
            fStopInitTimers = TRUE;
        }
    }
    else if (!(--NbtConfig.AdapterCount))
    {
        fStopInitTimers = TRUE;
    }
    else if (NbtConfig.AdapterCount == 1)
    {
        NbtConfig.MultiHomed = FALSE;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (fStopInitTimers)
    {
        StopInitTimers();
    }

    //
    // Now set the event for the waiting thread to complete!
    //
    KeSetEvent(&pDeviceContext->DeviceCleanedupEvent, 0, FALSE);
}



tDEVICECONTEXT *
GetDeviceFromInterface(
    IN  tIPADDRESS      IpAddress,
    IN  BOOLEAN         fReferenceDevice
    )
{
    LIST_ENTRY      *pEntry;
    LIST_ENTRY      *pHead;
    CTELockHandle   OldIrq;
    ULONG           IPInterfaceContext, Metric;
    tDEVICECONTEXT  *pDeviceContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (IsListEmpty(&NbtConfig.DeviceContexts))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return (NULL);
    }

    pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink, tDEVICECONTEXT, Linkage);
    NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    pDeviceContext->pFastQuery(IpAddress, &IPInterfaceContext, &Metric);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);

    pHead = pEntry = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContext = CONTAINING_RECORD (pEntry,tDEVICECONTEXT,Linkage);
        if (pDeviceContext->IPInterfaceContext == IPInterfaceContext)
        {
            if (fReferenceDevice)
            {
                NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, TRUE);
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return pDeviceContext;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (NULL);
}

//----------------------------------------------------------------------------

tDEVICECONTEXT *
GetAndRefNextDeviceFromNameAddr(
    IN  tNAMEADDR               *pNameAddr
    )
/*++

Routine Description:

    This routine finds the first adapter as specified in the name's adapter
    mask and set the DeviceContext associated with it.  It then clears the
    bit  in the adapter mask of pNameAddr.

Arguments:


Return Value:

    pDeviceContext if found a successful device!

--*/
{
    CTEULONGLONG    AdapterMask = 1;
    tDEVICECONTEXT  *pDeviceContext = NULL;
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;

    //
    // We may encounter an adapter for which the device is no
    // longer there, so we loop until we find the first valid
    // adapter or the mask is clear
    //
    while (pNameAddr->ReleaseMask)
    {
        //
        // Get the lowest AdapterMask bit and clear it in pNameAddr since
        // we are releasing the Name on that Adapter now
        //
        AdapterMask = ~(pNameAddr->ReleaseMask - 1) & pNameAddr->ReleaseMask;
        pNameAddr->ReleaseMask &= ~AdapterMask;

        //
        // Get the DeviceContext for this adapter mask
        //
        pHead = &NbtConfig.DeviceContexts;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            if (pDeviceContext->AdapterMask == AdapterMask)
            {
                //
                // Found a valid device on which this name is registered
                //
#ifndef VXD
                NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_GET_REF, TRUE);
#endif
                return pDeviceContext;
            }

            //
            // Go to next device
            //
            pEntry = pEntry->Flink;
        }
    }

    return NULL;
}


//----------------------------------------------------------------------------
NTSTATUS
CreateControlObject(
    tNBTCONFIG  *pConfig)

/*++

Routine Description:

    This routine allocates memory for the provider info block, tacks it
    onto the global configuration and sets default values for each item.

Arguments:


Return Value:


    NTSTATUS

--*/

{
    tCONTROLOBJECT      *pControl;


    CTEPagedCode();
    pControl = (tCONTROLOBJECT *) NbtAllocMem (sizeof(tCONTROLOBJECT), NBT_TAG2('21'));
    if (!pControl)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pControl->Verify = NBT_VERIFY_CONTROL;

    pControl->ProviderInfo.Version = 1;
    pControl->ProviderInfo.MaxSendSize = 0;
    pControl->ProviderInfo.MaxConnectionUserData = 0;

    // we need to get these values from the transport underneath...*TODO*
    // since the RDR uses this value
    pControl->ProviderInfo.MaxDatagramSize = 0;

    pControl->ProviderInfo.ServiceFlags = 0;
/*    pControl->ProviderInfo.TransmittedTsdus = 0;
    pControl->ProviderInfo.ReceivedTsdus = 0;
    pControl->ProviderInfo.TransmissionErrors = 0;
    pControl->ProviderInfo.ReceiveErrors = 0;
*/
    pControl->ProviderInfo.MinimumLookaheadData = 0;
    pControl->ProviderInfo.MaximumLookaheadData = 0;
/*    pControl->ProviderInfo.DiscardedFrames = 0;
    pControl->ProviderInfo.OversizeTsdusReceived = 0;
    pControl->ProviderInfo.UndersizeTsdusReceived = 0;
    pControl->ProviderInfo.MulticastTsdusReceived = 0;
    pControl->ProviderInfo.BroadcastTsdusReceived = 0;
    pControl->ProviderInfo.MulticastTsdusTransmitted = 0;
    pControl->ProviderInfo.BroadcastTsdusTransmitted = 0;
    pControl->ProviderInfo.SendTimeouts = 0;
    pControl->ProviderInfo.ReceiveTimeouts = 0;
    pControl->ProviderInfo.ConnectionIndicationsReceived = 0;
    pControl->ProviderInfo.ConnectionIndicationsAccepted = 0;
    pControl->ProviderInfo.ConnectionsInitiated = 0;
    pControl->ProviderInfo.ConnectionsAccepted = 0;
*/
    // put a ptr to this info into the pConfig so we can locate it
    // when we want to cleanup
    pConfig->pControlObj = pControl;

    /* KEEP THIS STUFF HERE SINCE WE MAY NEED TO ALSO CREATE PROVIDER STATS!!
        *TODO*
    DeviceList[i].ProviderStats.Version = 2;
    DeviceList[i].ProviderStats.OpenConnections = 0;
    DeviceList[i].ProviderStats.ConnectionsAfterNoRetry = 0;
    DeviceList[i].ProviderStats.ConnectionsAfterRetry = 0;
    DeviceList[i].ProviderStats.LocalDisconnects = 0;
    DeviceList[i].ProviderStats.RemoteDisconnects = 0;
    DeviceList[i].ProviderStats.LinkFailures = 0;
    DeviceList[i].ProviderStats.AdapterFailures = 0;
    DeviceList[i].ProviderStats.SessionTimeouts = 0;
    DeviceList[i].ProviderStats.CancelledConnections = 0;
    DeviceList[i].ProviderStats.RemoteResourceFailures = 0;
    DeviceList[i].ProviderStats.LocalResourceFailures = 0;
    DeviceList[i].ProviderStats.NotFoundFailures = 0;
    DeviceList[i].ProviderStats.NoListenFailures = 0;

    DeviceList[i].ProviderStats.DatagramsSent = 0;
    DeviceList[i].ProviderStats.DatagramBytesSent.HighPart = 0;
    DeviceList[i].ProviderStats.DatagramBytesSent.LowPart = 0;

    DeviceList[i].ProviderStats.DatagramsReceived = 0;
    DeviceList[i].ProviderStats.DatagramBytesReceived.HighPart = 0;
    DeviceList[i].ProviderStats.DatagramBytesReceived.LowPart = 0;

    DeviceList[i].ProviderStats.PacketsSent = 0;
    DeviceList[i].ProviderStats.PacketsReceived = 0;

    DeviceList[i].ProviderStats.DataFramesSent = 0;
    DeviceList[i].ProviderStats.DataFrameBytesSent.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesSent.LowPart = 0;

    DeviceList[i].ProviderStats.DataFramesReceived = 0;
    DeviceList[i].ProviderStats.DataFrameBytesReceived.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesReceived.LowPart = 0;

    DeviceList[i].ProviderStats.DataFramesResent = 0;
    DeviceList[i].ProviderStats.DataFrameBytesResent.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesResent.LowPart = 0;

    DeviceList[i].ProviderStats.DataFramesRejected = 0;
    DeviceList[i].ProviderStats.DataFrameBytesRejected.HighPart = 0;
    DeviceList[i].ProviderStats.DataFrameBytesRejected.LowPart = 0;

    DeviceList[i].ProviderStats.ResponseTimerExpirations = 0;
    DeviceList[i].ProviderStats.AckTimerExpirations = 0;
    DeviceList[i].ProviderStats.MaximumSendWindow = 0;
    DeviceList[i].ProviderStats.AverageSendWindow = 0;
    DeviceList[i].ProviderStats.PiggybackAckQueued = 0;
    DeviceList[i].ProviderStats.PiggybackAckTimeouts = 0;

    DeviceList[i].ProviderStats.WastedPacketSpace.HighPart = 0;
    DeviceList[i].ProviderStats.WastedPacketSpace.LowPart = 0;
    DeviceList[i].ProviderStats.WastedSpacePackets = 0;
    DeviceList[i].ProviderStats.NumberOfResources = 0;
    */
    return(STATUS_SUCCESS);

}


VOID
DelayedNbtCloseFileHandles(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )
{
    BOOLEAN         Attached = FALSE;
    NTSTATUS        Status;
    tFILE_OBJECTS   *pFileObjects = (tFILE_OBJECTS *) pContext;

    CTEPagedCode();
    CTEAttachFsp(&Attached, REF_FSP_CLOSE_FILE_HANDLES);

    if (pFileObjects->pNameServerFileObject)
    {
        ObDereferenceObject((PVOID *)pFileObjects->pNameServerFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tDelayedNbtCloseFileHandles->ObDereferenceObject\n",
                pFileObjects->pNameServerFileObject));

        Status = ZwClose(pFileObjects->hNameServer);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tDelayedNbtCloseFileHandles->ZwClose, status = <%x>\n",
                pFileObjects->hNameServer, Status));
        NbtTrace(NBT_TRACE_PNP, ("%!FUNC! close NameServer UDP handle pFileObjects %p", pFileObjects));
    }

    if (pFileObjects->pDgramFileObject)
    {
        ObDereferenceObject((PVOID *) pFileObjects->pDgramFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tDelayedNbtCloseFileHandles->ObDereferenceObject\n",
                pFileObjects->pDgramFileObject));

        Status = ZwClose(pFileObjects->hDgram);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tDelayedNbtCloseFileHandles->ZwClose, status = <%x>\n",
                pFileObjects->hDgram, Status));
        NbtTrace(NBT_TRACE_PNP, ("%!FUNC! close Datagram UDP handle on pFileObjects %p", pFileObjects));
    }

    CTEDetachFsp(Attached, REF_FSP_CLOSE_FILE_HANDLES);

    CTEMemFree (pFileObjects);
}


//----------------------------------------------------------------------------
NTSTATUS
CloseAddressesWithTransport(
    IN  tDEVICECONTEXT  *pDeviceContext
        )
/*++

Routine Description:

    This routine checks each device context to see if there are any open
    connections, and returns SUCCESS if there are.

Arguments:

Return Value:

    none

--*/

{
    BOOLEAN       Attached;
    CTELockHandle OldIrq;
    PFILE_OBJECT  pNSFileObject, pSFileObject, pDGFileObject;
#ifdef _PNP_POWER_
    PFILE_OBJECT  pCFileObject;
    NTSTATUS        Status;
#endif  // _PNP_POWER_
    tFILE_OBJECTS  *pFileObjects = pDeviceContext->pFileObjects;

    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    pDeviceContext->IpAddress = 0;

    //
    // Check for the existence of Objects under SpinLock and
    // then Close them outside of the SpinLock
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pSFileObject = pDeviceContext->pSessionFileObject)
    {
        pDeviceContext->pSessionFileObject = NULL;
    }

    pDeviceContext->pFileObjects = NULL;
    if ((pFileObjects) &&
        (--pFileObjects->RefCount > 0))
    {
        NbtTrace(NBT_TRACE_PNP, ("%!FUNC! closing UDP handle on deivce %p will be delayed. (pFileObjects %p)",
                                pDeviceContext, pFileObjects));
        pFileObjects = NULL;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    //
    // Now close all the necessary objects as appropriate
    //
    CTEAttachFsp(&Attached, REF_FSP_CLOSE_ADDRESSES);
    if (pSFileObject)
    {
        ObDereferenceObject((PVOID *)pSFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tCloseAddressesWithTransport2->ObDereferenceObject\n", pSFileObject));
        Status = ZwClose(pDeviceContext->hSession);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tCloseAddressesWithTransport2->ZwClose, status = <%x>\n", pDeviceContext->hSession, Status));
        pDeviceContext->hSession = NULL;
        NbtTrace(NBT_TRACE_PNP, ("%!FUNC! close TCP session handle on device %p", pDeviceContext));
    }

    if (pFileObjects)
    {
        DelayedNbtCloseFileHandles (NULL, pFileObjects, NULL, NULL);
    }

    CTEDetachFsp(Attached, REF_FSP_CLOSE_ADDRESSES);
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCreateAddressObjects(
    IN  ULONG                IpAddress,
    IN  ULONG                SubnetMask,
    OUT tDEVICECONTEXT       *pDeviceContext)

/*++

Routine Description:

    This routine gets the ip address and subnet mask out of the registry
    to calcuate the broadcast address.  It then creates the address objects
    with the transport.

Arguments:

    pucRegistryPath - path to NBT config info in registry
    pucBindName     - name of the service to bind to.
    pDeviceContext  - ptr to the device context... place to store IP addr
                      and Broadcast address permanently

Return Value:

    none

--*/

{
    NTSTATUS                        status, locstatus;
    ULONG                           ValueMask;
    UCHAR                           IpAddrByte;
    tFILE_OBJECTS                   *pFileObjects;

    CTEPagedCode();

    if (!(pFileObjects = (tFILE_OBJECTS *) NbtAllocMem (sizeof(tFILE_OBJECTS), NBT_TAG2('39'))))
    {
        KdPrint(("Nbt.NbtCreateAddressObjects:  Failed to allocate memory for FileObject context!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(pFileObjects, sizeof(tFILE_OBJECTS));
    pFileObjects->RefCount = 1;

    //
    // to get the broadcast address combine the IP address with the subnet mask
    // to yield a value with 1's in the "local" portion and the IP address
    // in the network portion
    //
    ValueMask = (SubnetMask & IpAddress) | (~SubnetMask & -1);

    IF_DBG(NBT_DEBUG_NTUTIL)
        KdPrint(("Broadcastaddress = %X\n",ValueMask));

    //
    // the registry can be configured to set the subnet broadcast address to
    // -1 rather than use the actual subnet broadcast address.  This code
    // checks for that and sets the broadcast address accordingly.
    //
    if (NbtConfig.UseRegistryBcastAddr)
    {
        pDeviceContext->BroadcastAddress = NbtConfig.RegistryBcastAddr;
    }
    else
    {
        pDeviceContext->BroadcastAddress = ValueMask;
    }

    pDeviceContext->IpAddress = IpAddress;

    pDeviceContext->SubnetMask = SubnetMask;
    //
    // get the network number by checking the top bits in the ip address,
    // looking for 0 or 10 or 110 or 1110
    //
    IpAddrByte = ((PUCHAR)&IpAddress)[3];
    if ((IpAddrByte & 0x80) == 0)
    {
        // class A address - one byte netid
        IpAddress &= 0xFF000000;
    }
    else if ((IpAddrByte & 0xC0) ==0x80)
    {
        // class B address - two byte netid
        IpAddress &= 0xFFFF0000;
    }
    else if ((IpAddrByte & 0xE0) ==0xC0)
    {
        // class C address - three byte netid
        IpAddress &= 0xFFFFFF00;
    }
    pDeviceContext->NetMask = IpAddress;

    // now create the address objects.

    // open the Ip Address for inbound Datagrams.
    status = NbtTdiOpenAddress (&pFileObjects->hDgram,
                                &pFileObjects->pDgramDeviceObject,
                                &pFileObjects->pDgramFileObject,
                                pDeviceContext,
#ifdef _NETBIOSLESS
                                pDeviceContext->DatagramPort,
#else
                                (USHORT)NBT_DATAGRAM_UDP_PORT,
#endif
                                pDeviceContext->IpAddress,
                                0);     // not a TCP port

    if (NT_SUCCESS(status))
    {
#ifdef _NETBIOSLESS
        if (pDeviceContext->NameServerPort == 0)
        {
            pFileObjects->hNameServer = NULL;
            pFileObjects->pNameServerDeviceObject = NULL;
            pFileObjects->pNameServerFileObject = NULL;
        }
        else
#endif
        {
            // open the Nameservice UDP port ..
            status = NbtTdiOpenAddress (&pFileObjects->hNameServer,
                                        &pFileObjects->pNameServerDeviceObject,
                                        &pFileObjects->pNameServerFileObject,
                                        pDeviceContext,
#ifdef _NETBIOSLESS
                                        pDeviceContext->NameServerPort,
#else
                                        (USHORT)NBT_NAMESERVICE_UDP_PORT,
#endif
                                        pDeviceContext->IpAddress,
                                        0); // not a TCP port
        }

        if (NT_SUCCESS(status))
        {
#ifdef _NETBIOSLESS
            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("Nbt.NbtCreateAddressObjects: Open Session Port=<%d>, pDeviceContext=<%x>\n",
                     pDeviceContext->SessionPort, pDeviceContext));
#endif

            // Open the TCP port for Session Services
            status = NbtTdiOpenAddress (&pDeviceContext->hSession,
                                        &pDeviceContext->pSessionDeviceObject,
                                        &pDeviceContext->pSessionFileObject,
                                        pDeviceContext,
#ifdef _NETBIOSLESS
                                        pDeviceContext->SessionPort,
#else
                                        (USHORT)NBT_SESSION_TCP_PORT,
#endif
                                        pDeviceContext->IpAddress,
                                        TCP_FLAG | SESSION_FLAG);      // TCP port

            if (NT_SUCCESS(status))
            {
                //
                // This will get the MAC address for a RAS connection
                // which is zero until there really is a connection to
                // the RAS server
                //
                GetExtendedAttributes(pDeviceContext);

                //
                // If this is P-to-P, and the Subnet mask is all 1's, set broadcast
                // address to all 1's and limit broadcast to this interface only
                //
                if ((pDeviceContext->IpInterfaceFlags & (IP_INTFC_FLAG_P2P | IP_INTFC_FLAG_P2MP)) &&
                    (SubnetMask == DEFAULT_BCAST_ADDR))   // If SubnetMask == -1 and connection is P-to-P
                {
                    pDeviceContext->BroadcastAddress = DEFAULT_BCAST_ADDR;

                    if (pFileObjects->hNameServer)
                    {
                        NbtSetTcpInfo (pFileObjects->hNameServer,
                                       AO_OPTION_LIMIT_BCASTS,
                                       INFO_TYPE_ADDRESS_OBJECT,
                                       (ULONG)TRUE);
                    }

                    if (pFileObjects->hDgram)
                    {
                        NbtSetTcpInfo (pFileObjects->hDgram,
                                       AO_OPTION_LIMIT_BCASTS,
                                       INFO_TYPE_ADDRESS_OBJECT,
                                       (ULONG)TRUE);
                    }
                }

                ASSERT (!pDeviceContext->pFileObjects);
                pDeviceContext->pFileObjects = pFileObjects;

                return(status);
            }

            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("Nbt.NbtCreateAddressObjects: Error opening Session address with TDI, status=<%x>\n",status));

            //
            // Ensure that the Object pointers are NULLed out!
            //
            pDeviceContext->pSessionFileObject = NULL;

            ObDereferenceObject(pFileObjects->pNameServerFileObject);
            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t  --<   ><====<%x>\tNbtCreateAddressObjects1->ObDereferenceObject\n", pFileObjects->pNameServerFileObject));
            pFileObjects->pNameServerFileObject = NULL;

            locstatus = NTZwCloseFile(pFileObjects->hNameServer);
            IF_DBG(NBT_DEBUG_HANDLES)
                KdPrint (("\t<===<%x>\tNbtCreateAddressObjects1->NTZwCloseFile (NameServer), status = <%x>\n", pFileObjects->hNameServer, locstatus));
        }
        ObDereferenceObject(pFileObjects->pDgramFileObject);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t  --<   ><====<%x>\tNbtCreateAddressObjects2->ObDereferenceObject\n", pFileObjects->pDgramFileObject));
        pFileObjects->pDgramFileObject = NULL;

        locstatus = NTZwCloseFile(pFileObjects->hDgram);
        IF_DBG(NBT_DEBUG_HANDLES)
            KdPrint (("\t<===<%x>\tNbtCreateAddressObjects2->NTZwCloseFile (Dgram), status = <%x>\n", pFileObjects->hDgram, locstatus));

        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint(("Unable to Open NameServer port with TDI, status = %X\n",status));
    }

    CTEMemFree (pFileObjects);
    return(status);
}

//----------------------------------------------------------------------------
VOID
GetExtendedAttributes(
    tDEVICECONTEXT  *pDeviceContext
     )
/*++

Routine Description:

    This routine converts a unicode dotted decimal to a ULONG

Arguments:


Return Value:

    none

--*/

{
    NTSTATUS                            status;
    TCP_REQUEST_QUERY_INFORMATION_EX    QueryReq;
    IO_STATUS_BLOCK                     IoStatus;
    HANDLE                              event;
    IO_STATUS_BLOCK                     IoStatusBlock;
    NTSTATUS                            Status;
    OBJECT_ATTRIBUTES                   ObjectAttributes;
    PFILE_FULL_EA_INFORMATION           EaBuffer;
    UNICODE_STRING                      DeviceName;
    HANDLE                              hTcp;
    ULONG                               Length;
    UCHAR                               pBuffer[256];
    ULONG                               BufferSize = 256;
    BOOLEAN                             Attached = FALSE;
    PWSTR                               pName = L"Tcp";

    CTEPagedCode();

    //
    // Open a control channel to TCP for this IOCTL.
    //
    // NOTE: We cannot use the hControl in the DeviceContext since that was created in the context
    // of the system process (address arrival from TCP/IP). Here, we are in the context of the service
    // process (Ioctl down from DHCP) and so we need to open another control channel.
    //
    // NOTE: We still need to maintain the earlier call to create a control channel since that is
    // used to submit TDI requests down to TCP/IP.
    //

    // copy device name into the unicode string
    Status = CreateDeviceString(pName,&DeviceName);
    if (!NT_SUCCESS(Status))
    {
        return;
    }

#ifdef HDL_FIX
    InitializeObjectAttributes (&ObjectAttributes, &DeviceName, OBJ_KERNEL_HANDLE, NULL, NULL);
#else
    InitializeObjectAttributes (&ObjectAttributes, &DeviceName, 0, NULL, NULL);
#endif  // HDL_FIX

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint(("Nbt.GetExtendedAttributes: Tcp device to open = %ws\n", DeviceName.Buffer));

    EaBuffer = NULL;

    Status = ZwCreateFile (&hTcp,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,     // object attributes.
                           &IoStatusBlock,        // returned status information.
                           NULL,                  // block size (unused).
                           FILE_ATTRIBUTE_NORMAL, // file attributes.
                           0,
                           FILE_CREATE,
                           0,                     // create options.
                           (PVOID)EaBuffer,       // EA buffer.
                           0); // Ea length

    CTEMemFree(DeviceName.Buffer);

    IF_DBG(NBT_DEBUG_TDIADDR)
        KdPrint( ("OpenControl CreateFile Status:%X, IoStatus:%X\n", Status, IoStatusBlock.Status));

    if ( NT_SUCCESS( Status ))
    {
        //
        // Initialize the TDI information buffers.
        //
        //
        // pass in the ipaddress as the first ULONG of the context array
        //
        *(ULONG *)QueryReq.Context = htonl(pDeviceContext->IpAddress);

        QueryReq.ID.toi_entity.tei_entity   = CL_NL_ENTITY;
        QueryReq.ID.toi_entity.tei_instance = 0;
        QueryReq.ID.toi_class               = INFO_CLASS_PROTOCOL;
        QueryReq.ID.toi_type                = INFO_TYPE_PROVIDER;
        QueryReq.ID.toi_id                  = IP_INTFC_INFO_ID;

        status = ZwCreateEvent(&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
        if (!NT_SUCCESS(status))
        {
            ZwClose( hTcp );
            return;
        }

        //
        // Make the actual TDI call
        //
        status = ZwDeviceIoControlFile (hTcp,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_QUERY_INFORMATION_EX,
                                        &QueryReq,
                                        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                                        pBuffer,
                                        BufferSize);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if ( status == STATUS_PENDING )
        {
            status = NtWaitForSingleObject (event, FALSE, NULL);
            ASSERT(status == STATUS_SUCCESS);
        }

        if (NT_SUCCESS(status))
        {
            pDeviceContext->IpInterfaceFlags = ((IPInterfaceInfo *) pBuffer)->iii_flags;

            //
            // get the length of the mac address in case is is less than 6 bytes
            //
            Length =   (((IPInterfaceInfo *)pBuffer)->iii_addrlength < sizeof(tMAC_ADDRESS))
                ? ((IPInterfaceInfo *)pBuffer)->iii_addrlength : sizeof(tMAC_ADDRESS);
            CTEZeroMemory(pDeviceContext->MacAddress.Address,sizeof(tMAC_ADDRESS));
            CTEMemCopy(&pDeviceContext->MacAddress.Address[0], ((IPInterfaceInfo *)pBuffer)->iii_addr,Length);
        }

        status = ZwClose(event);
        ASSERT (NT_SUCCESS(status));

        //
        // Close the handle to TCP since we dont need it anymore; all TDI requests go thru the
        // Control handle in the DeviceContext.
        //
        status = ZwClose(hTcp);
        ASSERT (NT_SUCCESS(status));

        status = IoStatus.Status;
    }
    else
    {
        KdPrint(("Nbt:Failed to Open the control connection to the transport, status1 = %X\n", Status));
    }

    return;
}


//----------------------------------------------------------------------------
NTSTATUS
ConvertToUlong(
    IN  PUNICODE_STRING      pucAddress,
    OUT ULONG                *pulValue)

/*++

Routine Description:

    This routine converts a unicode dotted decimal to a ULONG

Arguments:


Return Value:

    none

--*/

{
    NTSTATUS        status;
    OEM_STRING      OemAddress;

    // create integer from unicode string

    CTEPagedCode();
    status = RtlUnicodeStringToAnsiString(&OemAddress, pucAddress, TRUE);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    status = ConvertDottedDecimalToUlong(OemAddress.Buffer,pulValue);

    RtlFreeAnsiString(&OemAddress);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint(("ERR: Bad Dotted Decimal Ip Address(must be <=255 with 4 dots) = %ws\n",
                        pucAddress->Buffer));

        return(status);
    }

    return(STATUS_SUCCESS);


}



//----------------------------------------------------------------------------
VOID
NbtGetMdl(
    PMDL    *ppMdl,
    enum eBUFFER_TYPES eBuffType)

/*++

Routine Description:

    This routine allocates an Mdl.

Arguments:

    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    PMDL           pMdl;
    ULONG          lBufferSize;
    PVOID          pBuffer;

    *ppMdl = NULL;
    if (NbtConfig.iCurrentNumBuff[eBuffType] >= NbtConfig.iMaxNumBuff[eBuffType])
    {
        return;
    }

    lBufferSize = NbtConfig.iBufferSize[eBuffType];

    pBuffer = NbtAllocMem((USHORT)lBufferSize,NBT_TAG('g'));
    if (!pBuffer)
    {
        return;
    }

    // allocate a MDL to hold the session hdr
    pMdl = IoAllocateMdl(
                (PVOID)pBuffer,
                lBufferSize,
                FALSE,      // want this to be a Primary buffer - the first in the chain
                FALSE,
                NULL);

    if (!pMdl)
    {
	    CTEMemFree(pBuffer);
        return;
    }

    // fill in part of the session hdr since it is always the same
    if (eBuffType == eNBT_FREE_SESSION_MDLS)
    {
        ((tSESSIONHDR *)pBuffer)->Flags = NBT_SESSION_FLAGS;
        ((tSESSIONHDR *)pBuffer)->Type = NBT_SESSION_MESSAGE;
    }
    else if (eBuffType == eNBT_DGRAM_MDLS)
    {
        ((tDGRAMHDR *)pBuffer)->Flags = FIRST_DGRAM | (NbtConfig.PduNodeType >> 10);
        ((tDGRAMHDR *)pBuffer)->PckOffset = 0; // not fragmented

    }

    // map the Mdl properly to fill in the pages portion of the MDL
    MmBuildMdlForNonPagedPool(pMdl);

    NbtConfig.iCurrentNumBuff[eBuffType]++;
    *ppMdl = pMdl;
}

//----------------------------------------------------------------------------
NTSTATUS
NbtInitMdlQ(
    PSINGLE_LIST_ENTRY pListHead,
    enum eBUFFER_TYPES eBuffType)

/*++

Routine Description:

    This routine allocates Mdls for use later.

Arguments:

    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    int             i;
    PMDL            pMdl;


    CTEPagedCode();
    // Initialize the list head, so the last element always points to NULL
    pListHead->Next = NULL;

    // create a small number first and then lis the list grow with time
    for (i=0;i < NBT_INITIAL_NUM ;i++ )
    {
        NbtGetMdl (&pMdl,eBuffType);
        if (!pMdl)
        {
            KdPrint(("NBT:Unable to allocate MDL at initialization time!!\n"));\
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // put on free list
        PushEntryList (pListHead, (PSINGLE_LIST_ENTRY)pMdl);
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
NTZwCloseFile(
    IN  HANDLE      Handle
    )

/*++
Routine Description:

    This Routine handles closing a handle with NT within the context of NBT's
    file system process.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS    status;
    BOOLEAN     Attached = FALSE;

    CTEPagedCode();
    //
    // Attach to NBT's FSP (file system process) to free the handle since
    // the handle is only valid in that process.
    //
    CTEAttachFsp(&Attached, REF_FSP_CLOSE_FILE);
    status = ZwClose(Handle);
    CTEDetachFsp(Attached, REF_FSP_CLOSE_FILE);

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTReReadRegistry(
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine re-reads the registry values when DHCP issues the Ioctl
    to do so.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    tADDRARRAY          DeviceAddressArray;
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pEntry;
#ifdef MULTIPLE_WINS
    int j;
#endif

    CTEPagedCode();


    ASSERT (NBT_VERIFY_HANDLE2 (pDeviceContext, NBT_VERIFY_DEVCONTEXT, NBT_VERIFY_DEVCONTEXT_DOWN));

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("NBT:Found BindName: %lx\n", pDeviceContext->BindName));


    if (LookupDeviceInRegistry(&pDeviceContext->BindName, &DeviceAddressArray, NULL) == STATUS_SUCCESS) {
        //
        // We found a match
        //
        pDeviceContext->lNameServerAddress  = DeviceAddressArray.NameServerAddress;
        pDeviceContext->lBackupServer       = DeviceAddressArray.BackupServer;
        pDeviceContext->SwitchedToBackup    = 0;
        pDeviceContext->RefreshToBackup     = 0;
#ifdef MULTIPLE_WINS
        pDeviceContext->lNumOtherServers    = DeviceAddressArray.NumOtherServers;
        pDeviceContext->lLastResponsive     = 0;
        for (j = 0; j < DeviceAddressArray.NumOtherServers; j++) {
            pDeviceContext->lOtherServers[j] = DeviceAddressArray.Others[j];
        }
#endif
#ifdef _NETBIOSLESS
        pDeviceContext->NetbiosEnabled       = DeviceAddressArray.NetbiosEnabled;
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NTReReadRegistry: <%wZ> NetbiosEnabled=<%d>\n",
                 &pDeviceContext->ExportName, pDeviceContext->NetbiosEnabled));
#endif
        pDeviceContext->RasProxyFlags        = DeviceAddressArray.RasProxyFlags;
        pDeviceContext->EnableNagling        = DeviceAddressArray.EnableNagling;
        SetNodeType();
    } else {
        KdPrint(("netbt!NtReReadRegistry: Cannot find device in the registry\n"));
    }

    if (pDeviceContext->IpAddress)
    {
        if (!(NodeType & BNODE))
        {
            // Probably the Ip address just changed and Dhcp is informing us
            // of a new Wins Server addresses, so refresh all the names to the
            // new wins server
            //
            ReRegisterLocalNames(pDeviceContext, FALSE);
        }
        else
        {
            //
            // no need to refresh
            // on a Bnode
            //
            NbtStopRefreshTimer();
        }
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
ULONG   EventLogSequenceNumber = 0;

NTSTATUS
NbtLogEventDetailed(
    IN ULONG    EventCode,
    IN NTSTATUS NtStatusCode,
    IN ULONG    Info,
    IN PVOID    RawDataBuffer,
    IN USHORT   RawDataLength,
    IN USHORT   NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings


/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    va_list                 ParmPtr;                    // Pointer to stack parms.
    PCHAR                   DumpData;
    LONG                    Length;
    ULONG                   i, SizeOfRawData, RemainingSpace, TotalErrorLogEntryLength;
    ULONG                   SizeOfStringData = 0;
    PWSTR                   StringOffset, InsertionString;

    if (NumberOfInsertionStrings != 0)
    {
        va_start (ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1)
        {
            InsertionString = va_arg (ParmPtr, PWSTR);
            Length = wcslen (InsertionString);
            while ((Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //
    TotalErrorLogEntryLength = min (RawDataLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
                                    ERROR_LOG_MAXIMUM_SIZE);

    RemainingSpace = TotalErrorLogEntryLength - FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
    if (RemainingSpace > SizeOfStringData)
    {
        SizeOfRawData = RemainingSpace - SizeOfStringData;
    }
    else
    {
        SizeOfStringData = RemainingSpace;
        SizeOfRawData = 0;
    }

    ErrorLogEntry = IoAllocateErrorLogEntry (NbtConfig.DriverObject, (UCHAR) TotalErrorLogEntryLength);
    if (ErrorLogEntry == NULL)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:  Unable to allocate Error Packet for Error logging\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Fill in the error log entry
    //
    ErrorLogEntry->ErrorCode                = EventCode;
    ErrorLogEntry->UniqueErrorValue         = Info;
    ErrorLogEntry->FinalStatus              = NtStatusCode;
    ErrorLogEntry->MajorFunctionCode        = 0;
    ErrorLogEntry->RetryCount               = 0;
    ErrorLogEntry->IoControlCode            = 0;
    ErrorLogEntry->DeviceOffset.LowPart     = 0;
    ErrorLogEntry->DeviceOffset.HighPart    = 0;
    ErrorLogEntry->DumpDataSize             = 0;
    ErrorLogEntry->NumberOfStrings          = 0;
    ErrorLogEntry->SequenceNumber           = EventLogSequenceNumber++;
    ErrorLogEntry->StringOffset = (USHORT) (ROUND_UP_COUNT (FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                                            + SizeOfRawData, ALIGN_WORD));


    //
    // Append the dump data.  This information is typically an SMB header.
    //
    if ((RawDataBuffer) && (SizeOfRawData))
    {
        DumpData = (PCHAR) ErrorLogEntry->DumpData;
        Length = min (RawDataLength, (USHORT)SizeOfRawData);
        RtlCopyMemory (DumpData, RawDataBuffer, Length);
        ErrorLogEntry->DumpDataSize = (USHORT)Length;
    }

    //
    // Add the debug informatuion strings
    //
    if (NumberOfInsertionStrings)
    {
        StringOffset = (PWSTR) ((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

        //
        // Set up ParmPtr to point to first of the caller's parameters.
        //
        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1)
        {
            InsertionString = va_arg(ParmPtr, PWSTR);
            Length = wcslen(InsertionString);
            while ( (Length > 0) && (InsertionString[Length-1] == L' '))
            {
                Length--;
            }

            if (((Length + 1) * sizeof(WCHAR)) > SizeOfStringData)
            {
                Length = (SizeOfStringData/sizeof(WCHAR)) - 1;
            }

            if (Length > 0)
            {
                RtlCopyMemory (StringOffset, InsertionString, Length*sizeof(WCHAR));
                StringOffset += Length;
                *StringOffset++ = L'\0';

                SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                ErrorLogEntry->NumberOfStrings += 1;
            }
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);

    return(STATUS_SUCCESS);
}



NTSTATUS
NbtLogEvent(
    IN ULONG             EventCode,
    IN NTSTATUS          Status,
    IN ULONG             Location
    )

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.


Arguments:

    EventCode         - Identifies the error message.
    Status            - The status value to log: this value is put into the
                        data portion of the log message.


Return Value:

    STATUS_SUCCESS                  - The error was successfully logged..
    STATUS_BUFER_OVERFLOW           - The error data was too large to be logged.
    STATUS_INSUFFICIENT_RESOURCES   - Unable to allocate memory.


--*/

{
    return (NbtLogEventDetailed (EventCode, Status, Location, NULL, 0, 0));
}


VOID
DelayedNbtLogDuplicateNameEvent(
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
{
    tNAMEADDR               *pNameAddr      = (tNAMEADDR *) Context1;
    tIPADDRESS              RemoteIpAddress = (tIPADDRESS) PtrToUlong (Context2);
    ULONG                   Location        = (ULONG) PtrToUlong (Context3);
    UCHAR                   *pszNameOrig    = pNameAddr->Name;

    NTSTATUS                status;
    UCHAR                   *pAddr;
    WCHAR                   wstrName[22];
    WCHAR                   wstrDeviceIp[22];
    WCHAR                   wstrRemoteServerIp[22];

    UCHAR                   pszName[22];
    STRING                  TmpOEMString;
    UNICODE_STRING          UnicodeString;

    CTEPagedCode();

    UnicodeString.MaximumLength = sizeof(WCHAR)*(22);

    sprintf (pszName,"%-15.15s:%x", pszNameOrig, pszNameOrig[15]);
    UnicodeString.Length = 0;
    UnicodeString.Buffer = wstrName;
    RtlInitString (&TmpOEMString, pszName);
    status = RtlOemStringToUnicodeString (&UnicodeString, &TmpOEMString, FALSE);
    UnicodeString.Buffer[UnicodeString.Length] = L'\0';

    pAddr = (PUCHAR) &pDeviceContext->IpAddress;
    swprintf (wstrDeviceIp, L"%d.%d.%d.%d", pAddr[3], pAddr[2], pAddr[1], pAddr[0]);

    pAddr = (PUCHAR) &RemoteIpAddress;
    swprintf (wstrRemoteServerIp, L"%d.%d.%d.%d", pAddr[3], pAddr[2], pAddr[1], pAddr[0]);

    status = NbtLogEventDetailed (EVENT_NBT_DUPLICATE_NAME_ERROR,
                                  STATUS_UNSUCCESSFUL,
                                  Location,
                                  NULL,
                                  0,
                                  3,
                                  &wstrName,
                                  &wstrDeviceIp,
                                  &wstrRemoteServerIp);

    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, FALSE);
}



#if DBG
//----------------------------------------------------------------------------
VOID
AcquireSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN PKIRQL          pOldIrq,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function gets the spin lock, and then sets the mask in Nbtconfig, per
    processor.


Arguments:


Return Value:


--*/

{
    CCHAR  CurrProc;
    UCHAR  LockFree;

    CTEGetLock(&pLockInfo->SpinLock,pOldIrq);

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();
    NbtConfig.CurrProc = CurrProc;

    LockFree = (pLockInfo->LockNumber > (UCHAR)NbtConfig.CurrentLockNumber[CurrProc]);
    if (!LockFree)
    {
        KdPrint(("Nbt.AcquireSpinLockDebug: CurrProc = %X, CurrentLockNum = %X DataSTructLock = %X\n",
        CurrProc,NbtConfig.CurrentLockNumber[CurrProc],pLockInfo->LockNumber));
    }                                                                       \

    ASSERTMSG("Possible DeadLock, Getting SpinLock at a lower level\n",LockFree);
    NbtConfig.CurrentLockNumber[CurrProc]|= pLockInfo->LockNumber;

    pLockInfo->LastLockLine = LineNumber;
}

//----------------------------------------------------------------------------
VOID
FreeSpinLockDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN KIRQL           OldIrq,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function clears the spin lock from the mask in Nbtconfig, per
    processor and then releases the spin lock.


Arguments:


Return Value:
     none

--*/

{
    CCHAR  CurrProc;

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();

    NbtConfig.CurrentLockNumber[CurrProc] &= ~pLockInfo->LockNumber;

    pLockInfo->LastReleaseLine = LineNumber;
    CTEFreeLock(&pLockInfo->SpinLock,OldIrq);
}
//----------------------------------------------------------------------------
VOID
AcquireSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function gets the spin lock, and then sets the mask in Nbtconfig, per
    processor.


Arguments:


Return Value:


--*/

{
    CCHAR  CurrProc;
    UCHAR  LockFree;

    CTEGetLockAtDPC(&pLockInfo->SpinLock, 0);
    pLockInfo->LastLockLine = LineNumber;

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();
    NbtConfig.CurrProc = CurrProc;

    LockFree = (pLockInfo->LockNumber > (UCHAR)NbtConfig.CurrentLockNumber[CurrProc]);
    if (!LockFree)
    {
        KdPrint(("Nbt.AcquireSpinLockAtDpcDebug: CurrProc = %X, CurrentLockNum = %X DataSTructLock = %X\n",
        CurrProc,NbtConfig.CurrentLockNumber[CurrProc],pLockInfo->LockNumber));
    }                                                                       \

    ASSERTMSG("Possible DeadLock, Getting SpinLock at a lower level\n",LockFree);
    NbtConfig.CurrentLockNumber[CurrProc]|= pLockInfo->LockNumber;

}

//----------------------------------------------------------------------------
VOID
FreeSpinLockAtDpcDebug(
    IN tNBT_LOCK_INFO  *pLockInfo,
    IN INT             LineNumber
    )

/*++

Routine Description:

    This function clears the spin lock from the mask in Nbtconfig, per
    processor and then releases the spin lock.


Arguments:


Return Value:
     none

--*/

{
    CCHAR  CurrProc;

    CurrProc = (CCHAR)KeGetCurrentProcessorNumber();

    NbtConfig.CurrentLockNumber[CurrProc] &= ~pLockInfo->LockNumber;

    pLockInfo->LastReleaseLine = LineNumber;
    CTEFreeLockFromDPC(&pLockInfo->SpinLock, 0);
}
#endif //if Dbg

NTSTATUS
NbtBuildDeviceAcl(
    OUT PACL * DeviceAcl
    )
/*++

Routine Description:

    (Lifted from TCP - TcpBuildDeviceAcl)
    This routine builds an ACL which gives Administrators, LocalService and NetworkService
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid, ServiceSid, NetworkSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    AdminsSid = SeExports->SeAliasAdminsSid;
    ServiceSid = SeExports->SeLocalServiceSid;
    NetworkSid = SeExports->SeNetworkServiceSid;

    AclLength = sizeof(ACL) +
        3 * sizeof(ACCESS_ALLOWED_ACE) +
        RtlLengthSid(AdminsSid) +
        RtlLengthSid(ServiceSid) +
        RtlLengthSid(NetworkSid) -
        3 * sizeof(ULONG);

    NewAcl = ExAllocatePool(PagedPool, AclLength);

    if (NewAcl == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);

    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }
    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    AdminsSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    ServiceSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    NetworkSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    *DeviceAcl = NewAcl;

    return (STATUS_SUCCESS);
}

NTSTATUS
NbtCreateAdminSecurityDescriptor(PDEVICE_OBJECT dev)
/*++

Routine Description:

    (Lifted from TCP - TcpCreateAdminSecurityDescriptor)
    This routine creates a security descriptor which gives access
    only to Administrtors and LocalService. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL rawAcl = NULL;
    NTSTATUS status;
    CHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR localSecurityDescriptor = (PSECURITY_DESCRIPTOR) & buffer;
    SECURITY_INFORMATION securityInformation = DACL_SECURITY_INFORMATION;

    //
    // Build a local security descriptor with an ACL giving only
    // administrators and service access.
    //
    status = NbtBuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        KdPrint(("TCP: Unable to create Raw ACL, error: %x\n", status));
        return (status);
    }

    (VOID) RtlCreateSecurityDescriptor(
                                       localSecurityDescriptor,
                                       SECURITY_DESCRIPTOR_REVISION
                                       );

    (VOID) RtlSetDaclSecurityDescriptor(
                                        localSecurityDescriptor,
                                        TRUE,
                                        rawAcl,
                                        FALSE
                                        );

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                                         NULL,
                                         &securityInformation,
                                         localSecurityDescriptor,
                                         &dev->SecurityDescriptor,
                                         PagedPool,
                                         IoGetFileObjectGenericMapping()
                                         );

    if (!NT_SUCCESS(status)) {
        KdPrint(("Nbt: SeSetSecurity failed, %lx\n", status));
    }

    ExFreePool(rawAcl);
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\ntpnp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NTPNP.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    NBT Transport and other routines that are specific to the NT implementation
    of a driver.

Author:

    Earle R. Horton (earleh) 08-Nov-1995

Revision History:

--*/


#include "precomp.h"
#include "ntddip.h"     // Needed for PNETBT_PNP_RECONFIG_REQUEST
#include "ntprocs.h"
#include <tcpinfo.h>
#include <tdiinfo.h>
#include "ntpnp.tmh"

#ifdef _NETBIOSLESS
NTSTATUS
NbtSpecialDeviceAdd(
    PUNICODE_STRING pucBindName,
    PUNICODE_STRING pucExportName,
    PWSTR pKeyName,
    USHORT DefaultSessionPort,
    USHORT DefaultDatagramPort
    );

NTSTATUS
NbtSpecialReadRegistry(
    PWSTR pKeyName,
    tDEVICECONTEXT *pDeviceContext,
    USHORT DefaultSessionPort,
    USHORT DefaultDatagramPort
    );
#endif

tDEVICECONTEXT *
CheckAddrNotification(
    IN PTA_ADDRESS         Addr,
    IN PUNICODE_STRING     pDeviceName,
    OUT ULONG*  IpAddr
    );

extern HANDLE   TdiClientHandle;
extern HANDLE   TdiProviderHandle;
static DWORD    AddressCount = 0;

NET_DEVICE_POWER_STATE     LastSystemPowerState = NetDeviceStateD0;   // by default

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtNotifyTdiClients)
#pragma CTEMakePageable(PAGE, NbtAddressAdd)
#pragma CTEMakePageable(PAGE, NbtAddNewInterface)
#pragma CTEMakePageable(PAGE, NbtDeviceAdd)
#pragma CTEMakePageable(PAGE, TdiAddressArrival)
#pragma CTEMakePageable(PAGE, TdiAddressDeletion)
#pragma CTEMakePageable(PAGE, TdiBindHandler)
#pragma CTEMakePageable(PAGE, NbtCreateSmbDevice)
#pragma CTEMakePageable(PAGE, NbtSpecialReadRegistry)
#pragma CTEMakePageable(PAGE, NbtPnPPowerComplete)
#pragma CTEMakePageable(PAGE, TdiPnPPowerHandler)
#pragma CTEMakePageable(PAGE, LookupDeviceInRegistry)
#pragma CTEMakePageable(PAGE, CheckAddrNotification)
#endif
//*******************  Pageable Routine Declarations ****************



//
// This used at the boot time.
// We shouldn't call TdiProviderReady until all the interfaces
// we know so far have been initialized
//
// TcpipReady: set to TRUE when we receive TdiProviderReady from IP
// NumIfBeingIndicated: the # of interfaces being indicated to our clients
// JustBooted: set to FALSE after we call TdiProviderReady
//

DWORD  JustBooted = TRUE;
#define IsBootTime()    (InterlockedExchange(&JustBooted, FALSE))

//#if DBG
//
// TcpipReady is for debugging purpose only.
//
// BootTimeCounter is initialized to ONE which
// take it into account.
//
int    TcpipReady = FALSE;
//#endif

LONG   BootTimeCounter = 1;     // For the IP's ProviderReady



void
NbtUpBootCounter(void)
{
    if (!JustBooted) {
        return;
    }

    ASSERT(BootTimeCounter >= 0);

    InterlockedIncrement(&BootTimeCounter);
}

void
NbtDownBootCounter(void)
{
    LONG    CounterSnapshot;

    if (!JustBooted) {
        return;
    }

    ASSERT(BootTimeCounter > 0);
    CounterSnapshot = InterlockedDecrement(&BootTimeCounter);

    if (!CounterSnapshot && IsBootTime()) {

        //
        // Just try our best
        //
        // The caller always call us at PASSIVE_LEVEL except from
        // StartProcessNbtDhcpRequests, a timer routine which could
        // be called at DISPATCH_LEVEL
        //
        if (KeGetCurrentIrql() == PASSIVE_LEVEL) {

            TdiProviderReady (TdiProviderHandle);   // Notify our clients now

        } else {

            //
            // Although this is a benign assert, we still want it
            // to capture the normal cases in which this function
            // should be called at PASSIVE_LEVEL.
            //
            ASSERT (0);

        }

    }
}


//----------------------------------------------------------------------------
tDEVICECONTEXT *
NbtFindAndReferenceDevice(
    PUNICODE_STRING      pucBindName,
    BOOLEAN              fNameIsBindName
    )
{
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pEntry;
    tDEVICECONTEXT      *pDeviceContext;
    CTELockHandle       OldIrq;
    PUNICODE_STRING     pucNameToCompare;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
        //
        // Reference this device so that it doesn't disappear when we release the lock!
        //
        NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // Set the right type of name to compare against
        //
        if (fNameIsBindName)
        {
            pucNameToCompare = &pDeviceContext->BindName;
        }
        else
        {
            pucNameToCompare = &pDeviceContext->ExportName;
        }

        //
        // Use case-insensitive compare since registry is case-insensitive
        //
        if (RtlCompareUnicodeString(pucBindName, pucNameToCompare, TRUE) == 0)
        {
            //
            // We have already Referenced this device above
            //
            return (pDeviceContext);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        pEntry = pEntry->Flink;
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    return (tDEVICECONTEXT *)NULL;
}

VOID
NbtNotifyTdiClients(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  enum eTDI_ACTION    Action
    )
/*++

Routine Description:

    This is where all Tdi registrations and Deregistrations occur
    ASSUMPTION:  Only 1 thread will running this request at any time

Arguments:

    None.

Return Value:

    None (since this is a Worker thread)

--*/

{
    CTELockHandle       OldIrq;
    NTSTATUS            status = STATUS_SUCCESS;
    HANDLE              NetAddressRegistrationHandle, DeviceRegistrationHandle;
    PLIST_ENTRY         pEntry;

    CTEPagedCode();

    NbtTrace(NBT_TRACE_PNP, ("ExportName=%Z BindName=%Z Action=%d",
            &pDeviceContext->ExportName, &pDeviceContext->BindName, Action));
    switch (Action)
    {
        case NBT_TDI_REGISTER:
        {
            //
            // Add the "permanent" name to the local name table.  This is the IP
            // address of the node padded out to 16 bytes with zeros.
            //
#ifdef _NETBIOSLESS
            if (!IsDeviceNetbiosless(pDeviceContext))
#endif
            {
                NbtAddPermanentName(pDeviceContext);
            }

            //
            // If the device was not registered with TDI, do so now.
            //
            if (!pDeviceContext->DeviceRegistrationHandle)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNotifyTdiClients: Calling TdiRegisterDeviceObject ...\n"));

                status = TdiRegisterDeviceObject( &pDeviceContext->ExportName,
                                             &pDeviceContext->DeviceRegistrationHandle);
                if (!NT_SUCCESS(status))
                {
                    pDeviceContext->DeviceRegistrationHandle = NULL;
                }
                NbtTrace(NBT_TRACE_PNP, ("RegisterDeviceObject: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.NbtNotifyTdiClients: TdiRegisterDeviceObject for <%x> returned <%x>\n",
                        pDeviceContext, status));
            }

            //
            // If the Net address was not registered with TDI, do so now.
            //
            if ((!pDeviceContext->NetAddressRegistrationHandle) &&
#ifdef _NETBIOSLESS
                (!IsDeviceNetbiosless(pDeviceContext)) &&
#endif
                (pDeviceContext->pPermClient))
            {
                TA_NETBIOS_ADDRESS  PermAddress;

                PermAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
                PermAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
                PermAddress.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
                CTEMemCopy( PermAddress.Address[0].Address[0].NetbiosName,
                            pDeviceContext->pPermClient->pAddress->pNameAddr->Name,
                            NETBIOS_NAME_SIZE);

                status = TdiRegisterNetAddress(
                            (PTA_ADDRESS) PermAddress.Address,
                            &pDeviceContext->ExportName,
                            (PTDI_PNP_CONTEXT) &pDeviceContext->Context2,
                            &pDeviceContext->NetAddressRegistrationHandle);

                if (!NT_SUCCESS(status))
                {
                    pDeviceContext->NetAddressRegistrationHandle = NULL;
                }
                NbtTrace(NBT_TRACE_PNP, ("RegisterNetAddress: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));

                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNotifyTdiClients: TdiRegisterNetAddress for <%x> returned <%x>\n",
                        pDeviceContext, status));
            }
            break;
        }

        case NBT_TDI_DEREGISTER:
        {
            if (NetAddressRegistrationHandle = pDeviceContext->NetAddressRegistrationHandle)
            {
                pDeviceContext->NetAddressRegistrationHandle = NULL;
                status = TdiDeregisterNetAddress (NetAddressRegistrationHandle);

                NbtTrace(NBT_TRACE_PNP, ("DeregisterNetAddress: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNbtNotifyTdiClients: TdiDeregisterNetAddress<%x> returned<%x>\n",
                        pDeviceContext, status));
            }

            if (DeviceRegistrationHandle = pDeviceContext->DeviceRegistrationHandle)
            {
                pDeviceContext->DeviceRegistrationHandle = NULL;
                status = TdiDeregisterDeviceObject (DeviceRegistrationHandle);

                NbtTrace(NBT_TRACE_PNP, ("DeregisterDeviceObject: ExportName=%Z BindName=%Z status=%!status!",
                    &pDeviceContext->ExportName, &pDeviceContext->BindName, status));
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.NbtNotifyTdiClients: TdiDeregisterDeviceObject<%x> returned<%x>\n",
                        pDeviceContext, status));
            }

            //
            // The permanent name is a function of the MAC address so remove
            // it since the Address is going away
            //
#ifdef _NETBIOSLESS
            if (!IsDeviceNetbiosless(pDeviceContext))
#endif
            {
                NbtRemovePermanentName(pDeviceContext);
            }

            break;
        }

        default:
            KdPrint(("Nbt.NbtNotifyTdiClients: ERROR: Invalid Action=<%x> on Device <%x>\n",
                Action, pDeviceContext));
    }
}



//----------------------------------------------------------------------------
NTSTATUS
NbtAddressAdd(
    ULONG           IpAddr,
    tDEVICECONTEXT  *pDeviceContext,
    PUNICODE_STRING pucBindString
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    tADDRARRAY          DeviceAddressArray;
    tIPADDRESS          pIpAddresses[MAX_IP_ADDRS];
    tIPADDRESS          SubnetMask;
    ULONG               NumAddressesRead;

    CTEPagedCode();

    ASSERT(pucBindString && IpAddr);

    //
    // Find the bind and export devices to use from the device
    // described in the registry that uses this address.
    //
    if (status != STATUS_SUCCESS) {
        return status;
    }

    status = LookupDeviceInRegistry(pucBindString, &DeviceAddressArray, NULL);
    if (!NT_SUCCESS(status)) {
        KdPrint(("netbt!NbtAddressAdd: Cannot find device in the registry: status <%x>\n", status));
        NbtTrace(NBT_TRACE_PNP, ("BindName=%Z IP=%!ipaddr! status=%!status!",
                    pucBindString, IpAddr, status));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Fetch a static IP address from the registry.
    //
    *pIpAddresses = 0;
    status = GetIPFromRegistry (pucBindString,
                                pIpAddresses,
                                &SubnetMask,
                                MAX_IP_ADDRS,
                                &NumAddressesRead,
                                NBT_IP_STATIC);

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("Nbt.NbtAddressAdd: GetIPFromRegistry for NBT_IP_STATIC returned <%x>\n",status));
    NbtTrace(NBT_TRACE_PNP, ("GetIPFromRegistry return status=%!status! for NBT_IP_STATIC BindName=%Z IP=%!ipaddr!",
                    status, pucBindString, IpAddr));

    if ((status != STATUS_SUCCESS) || (*pIpAddresses != IpAddr)) {
        //
        // This one doesn't have a valid static address.  Try DHCP.
        //
        *pIpAddresses = 0;              // Cleanup any previously-read entries!
        status = GetIPFromRegistry (pucBindString,
                                    pIpAddresses,
                                    &SubnetMask,
                                    MAX_IP_ADDRS,
                                    &NumAddressesRead,
                                    NBT_IP_DHCP);
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("Nbt.NbtAddressAdd: GetIPFromRegistry for NBT_IP_DHCP returned <%x>\n",status));
        NbtTrace(NBT_TRACE_PNP, ("GetIPFromRegistry return status=%!status! for NBT_IP_DHCP BindName=%Z IP=%!ipaddr!",
                    status, pucBindString, IpAddr));
    }

    if ((status != STATUS_SUCCESS) || (*pIpAddresses != IpAddr)) {
        //
        // Check for Autoconfiguration IP address
        //
        *pIpAddresses = 0;              // Cleanup any previously-read entries!
        status = GetIPFromRegistry (pucBindString,
                                    pIpAddresses,
                                    &SubnetMask,
                                    MAX_IP_ADDRS,
                                    &NumAddressesRead,
                                    NBT_IP_AUTOCONFIGURATION);
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("Nbt.NbtAddressAdd: GetIPFromRegistry for NBT_IP_AUTOCONFIGURATION returned <%x>\n",
                status));
        NbtTrace(NBT_TRACE_PNP, ("GetIPFromRegistry return status=%!status! for NBT_IP_AUTO BindName=%Z IP=%!ipaddr!",
                    status, pucBindString, IpAddr));
    }

    //
    // The Device must have been created beforehand by using the BindHandler
    //
    if ((status == STATUS_SUCCESS) && (*pIpAddresses == IpAddr)) {
        BOOLEAN     IsDuplicateNotification = FALSE;
#ifdef MULTIPLE_WINS
        int i;
#endif

        pDeviceContext->RasProxyFlags = DeviceAddressArray.RasProxyFlags;
        pDeviceContext->EnableNagling = DeviceAddressArray.EnableNagling;
        //
        // Initialize the WINs server addresses
        //
        if ((IpAddr == pDeviceContext->IpAddress) &&
            (DeviceAddressArray.NetbiosEnabled == pDeviceContext->NetbiosEnabled) &&
            (DeviceAddressArray.NameServerAddress == pDeviceContext->lNameServerAddress) &&
            (DeviceAddressArray.BackupServer == pDeviceContext->lBackupServer))
        {
            IsDuplicateNotification = TRUE;
            NbtTrace(NBT_TRACE_PNP, ("Duplicate notification: %Z %!ipaddr!", pucBindString, IpAddr));
        }

        pDeviceContext->lNameServerAddress  = DeviceAddressArray.NameServerAddress;
        pDeviceContext->lBackupServer       = DeviceAddressArray.BackupServer;
        pDeviceContext->RefreshToBackup     = 0;
        pDeviceContext->SwitchedToBackup    = 0;
#ifdef MULTIPLE_WINS
        pDeviceContext->lNumOtherServers    = DeviceAddressArray.NumOtherServers;
        pDeviceContext->lLastResponsive     = 0;
        for (i = 0; i < DeviceAddressArray.NumOtherServers; i++) {
            pDeviceContext->lOtherServers[i] = DeviceAddressArray.Others[i];
        }
#endif
#ifdef _NETBIOSLESS
        pDeviceContext->NetbiosEnabled       = DeviceAddressArray.NetbiosEnabled;
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("NbtAddressAdd: %wZ, enabled = %d\n",
                 &pDeviceContext->ExportName, pDeviceContext->NetbiosEnabled));
        NbtTrace(NBT_TRACE_PNP, ("NetbiosEnabled=%x: %Z %!ipaddr!",
                pDeviceContext->NetbiosEnabled, pucBindString, IpAddr));
#endif

        //
        // Open the addresses with the transports
        // these are passed into here in the reverse byte order, wrt to the IOCTL
        // from DHCP.
        //
        if (IsDuplicateNotification) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            ULONG       i;

            //
            // We may have read more than Ip address for this Device
            // so save all of them
            //
            if (NumAddressesRead > 1) {
                for (i=1; i<NumAddressesRead; i++) {
                    pDeviceContext->AdditionalIpAddresses[i-1] = pIpAddresses[i];
                }
            }
            ASSERT (NumAddressesRead > 0);
#if 0
            //
            // TcpIp does not support opening of multiple addresses
            // per handle, so disable this option for now!
            //
            pDeviceContext->NumAdditionalIpAddresses = NumAddressesRead - 1;
#endif
            pDeviceContext->AssignedIpAddress = IpAddr;
            NbtNewDhcpAddress(pDeviceContext,htonl(*pIpAddresses),htonl(SubnetMask));

            if (pNbtSmbDevice) {

                NETBT_SMB_BIND_REQUEST  SmbRequest = { 0 };

                SmbRequest.RequestType = SMB_SERVER;
                SmbRequest.MultiSZBindList = NbtConfig.pServerBindings;
                SmbRequest.pDeviceName = NULL;
                SmbRequest.PnPOpCode = TDI_PNP_OP_ADD;

                if (SmbRequest.MultiSZBindList) {
                    NbtSetSmbBindingInfo2(
                            pNbtSmbDevice,
                            &SmbRequest
                            );
                }

                SmbRequest.RequestType = SMB_CLIENT;
                SmbRequest.MultiSZBindList = NbtConfig.pClientBindings;
                SmbRequest.pDeviceName = NULL;
                SmbRequest.PnPOpCode = TDI_PNP_OP_ADD;
                if (SmbRequest.MultiSZBindList) {
                    NbtSetSmbBindingInfo2(
                            pNbtSmbDevice,
                            &SmbRequest
                            );
                }

            }
        }
    } else {
        KdPrint (("Nbt.NbtAddressAdd: ERROR -- pDeviceContext=<%x>, status=<%x>, IpAddr=<%x>, ulIpAddress=<%x>\n",
            pDeviceContext, status, IpAddr, *pIpAddresses));
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}

NTSTATUS
NbtAddNewInterface (
    IN  PIRP            pIrp,
    IN  PVOID           *pBuffer,
    IN  ULONG            Size
    )
/*++

Routine Description:

    Creates a device context by coming up with a unique export string to name
    the device.

Arguments:

Return Value:

Notes:


--*/
{
    ULONG               nextIndex = InterlockedIncrement(&NbtConfig.InterfaceIndex);
    WCHAR               Suffix[16];
    WCHAR               Bind[60] = L"\\Device\\If";
    WCHAR               Export[60] = L"\\Device\\NetBt_If";
    UNICODE_STRING      ucSuffix;
    UNICODE_STRING      ucBindStr;
    UNICODE_STRING      ucExportStr;
    NTSTATUS            status;
    ULONG               OutSize;
    BOOLEAN             Attached = FALSE;
    tADDRARRAY          *pAddrArray = NULL;
    tDEVICECONTEXT      *pDeviceContext = NULL;
    PNETBT_ADD_DEL_IF   pAddDelIf = (PNETBT_ADD_DEL_IF)pBuffer;

    CTEPagedCode();

    //
    // Validate output buffer size
    //
    if (Size < sizeof(NETBT_ADD_DEL_IF))
    {
        KdPrint(("Nbt.NbtAddNewInterface: Output buffer too small for struct\n"));
        NbtTrace(NBT_TRACE_PNP, ("Output buffer too small for struct size=%d, required=%d",
                Size, sizeof(NETBT_ADD_DEL_IF)));
        return(STATUS_INVALID_PARAMETER);
    }
    //
    // Create the bind/export strings as:
    //      Bind: \Device\IF<1>   Export: \Device\NetBt_IF<1>
    //      where 1 is a unique interface index.
    //
    ucSuffix.Buffer = Suffix;
    ucSuffix.Length = 0;
    ucSuffix.MaximumLength = sizeof(Suffix);

    RtlIntegerToUnicodeString(nextIndex, 10, &ucSuffix);

    RtlInitUnicodeString(&ucBindStr, Bind);
    ucBindStr.MaximumLength = sizeof(Bind);
    RtlInitUnicodeString(&ucExportStr, Export);
    ucExportStr.MaximumLength = sizeof(Export);

    RtlAppendUnicodeStringToString(&ucBindStr, &ucSuffix);
    RtlAppendUnicodeStringToString(&ucExportStr, &ucSuffix);

    OutSize = FIELD_OFFSET (NETBT_ADD_DEL_IF, IfName[0]) +
               ucExportStr.Length + sizeof(UNICODE_NULL);

    if (Size < OutSize)
    {
        KdPrint(("Nbt.NbtAddNewInterface: Buffer too small for name\n"));
        NbtTrace(NBT_TRACE_PNP, ("Buffer too small for name size=%d, required=%d", Size, OutSize));
        pAddDelIf->Length = ucExportStr.Length + sizeof(UNICODE_NULL);
        pAddDelIf->Status = STATUS_BUFFER_TOO_SMALL;
        pIrp->IoStatus.Information = sizeof(NETBT_ADD_DEL_IF);
        return STATUS_SUCCESS;
    }

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint(( "Nbt.NbtAddNewInterface: Creating ucBindStr: %ws ucExportStr: %ws\n",
                ucBindStr.Buffer, ucExportStr.Buffer ));
    //
    // Attach to the system process so that all handles are created in the
    // proper context.
    //
    CTEAttachFsp(&Attached, REF_FSP_ADD_INTERFACE);

    status = NbtCreateDeviceObject (&ucBindStr,
                                    &ucExportStr,
                                    &pAddrArray[0],
                                    &pDeviceContext,
                                    NBT_DEVICE_CLUSTER);

    CTEDetachFsp(Attached, REF_FSP_ADD_INTERFACE);

    if (pDeviceContext)
    {
        //
        // Fill up the output buffer with the export name
        //
        RtlCopyMemory(&pAddDelIf->IfName[0], ucExportStr.Buffer, ucExportStr.Length+sizeof(UNICODE_NULL));
        pAddDelIf->Length = ucExportStr.Length + sizeof(UNICODE_NULL);
        pAddDelIf->InstanceNumber = pDeviceContext->InstanceNumber;
        pAddDelIf->Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = OutSize;
        //
        // By-pass the TDI PnP mechanism for logical interfaces (ie don't register with TDI)
        //
        return (STATUS_SUCCESS);
    }

    NbtTrace(NBT_TRACE_PNP, ("NbtCreateDeviceObject return %!status! for BindName=%Z ExportName=%Z",
            status, &ucBindStr, &ucExportStr));

    return  status;
}


NTSTATUS
NbtDeviceAdd(
    PUNICODE_STRING pucBindString
    )
{
    tDEVICECONTEXT      *pDeviceContext;
    UNICODE_STRING      ucExportString;
    tADDRARRAY          DeviceAddressArray;
    BOOLEAN             Attached = FALSE;
    NTSTATUS            Status;
    PLIST_ENTRY         pHead, pEntry;
    NTSTATUS            dontcarestatus;
    int i;


    CTEPagedCode();

    //
    // Ignore it if we already bind to the device
    //
    if (pDeviceContext = NbtFindAndReferenceDevice (pucBindString, TRUE)) {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);

        KdPrint (("Nbt.NbtDeviceAdd: ERROR: Device=<%ws> already exists!\n", pucBindString->Buffer));
        NbtTrace(NBT_TRACE_PNP, ("Device %Z already exists!", pucBindString));
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Can we find the new device in registry file? If not, ignore it.
    //
    Status = LookupDeviceInRegistry(pucBindString, &DeviceAddressArray, &ucExportString);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("netbt!NbtDeviceAdd: Cannot find device in the registry: status <%x>\n", Status));
        NbtTrace(NBT_TRACE_PNP, ("LookupDeviceInRegistry return %!status! for device %Z",
            Status, pucBindString));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Attach to the system process so that all handles are created in the
    // proper context.
    //
    CTEAttachFsp(&Attached, REF_FSP_DEVICE_ADD);

    Status = NbtCreateDeviceObject (pucBindString,
                                    &ucExportString,
                                    &DeviceAddressArray,
                                    &pDeviceContext,
                                    NBT_DEVICE_REGULAR);
    CTEMemFree(ucExportString.Buffer);

    CTEDetachFsp(Attached, REF_FSP_DEVICE_ADD);

    //
    // Call Tdi to re-enumerate the addresses for us
    //
    if (NT_SUCCESS (Status)) {
        TdiEnumerateAddresses(TdiClientHandle);
    } else {
        KdPrint (("Nbt.NbtDeviceAdd:  ERROR: NbtCreateDeviceObject returned <%x>\n", Status));
        NbtTrace(NBT_TRACE_PNP, ("NbtCreateDeviceObject return %!status! for device %Z",
            Status, pucBindString));
    }

    return (Status);
}


//  TdiAddressArrival - PnP TDI_ADD_ADDRESS_HANDLER
//              Handles an IP address arriving
//              Called by TDI when an address arrives.
//
//  Input:      Addr            - IP address that's coming.
//
//  Returns:    Nothing.
//
VOID
TdiAddressArrival(
    PTA_ADDRESS Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    ULONG               IpAddr, LastAssignedIpAddress;
    tDEVICECONTEXT      *pDeviceContext;
    PTDI_PNP_CONTEXT    pTdiContext;
    NTSTATUS            status;

    CTEPagedCode();

    pDeviceContext = CheckAddrNotification(Addr, pDeviceName, &IpAddr);
    if (pDeviceContext == NULL) {
        return;
    }

    //
    // Now the device is referenced!!!
    //
    NbtTrace(NBT_TRACE_PNP, ("TdiAddressArrival for %Z, IpAddr=%!ipaddr!, "
            "pDeviceContext->AssignedIpAddress=%!ipaddr!, pDeviceContext->IpAddress=%!ipaddr!",
            pDeviceName, IpAddr, pDeviceContext->AssignedIpAddress, pDeviceContext->IpAddress));

    //
    // Update the PDO in Context2
    //
    pTdiContext = (PTDI_PNP_CONTEXT) &pDeviceContext->Context2;
    pTdiContext->ContextSize = Context->ContextSize;
    pTdiContext->ContextType = Context->ContextType;
    *(PVOID UNALIGNED*) pTdiContext->ContextData = *(PVOID UNALIGNED*) Context->ContextData;

    LastAssignedIpAddress = pDeviceContext->AssignedIpAddress;
    if (NT_SUCCESS (status = NbtAddressAdd(IpAddr, pDeviceContext, pDeviceName))) {
        // Register Smb Device
        // Assumption 1: tdi can assign multiple addresses to same device
        // Assumption 2: tdi will always delete an assignment it made
        // THIS IS CODED FOR ONE ADDRESS PER DEVICE
        // First assigned address wins (and is reference counted)
        if (LastAssignedIpAddress == 0) {
            if ((1 == InterlockedIncrement (&AddressCount)) && (NbtConfig.SMBDeviceEnabled) && (pNbtSmbDevice)) {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.TdiAddressArrival:  Registering NetbiosSmb Device\n"));
                NbtNotifyTdiClients (pNbtSmbDevice, NBT_TDI_REGISTER);
            }
        }
    } else {
        NbtTrace(NBT_TRACE_PNP, ("NbtAddressAdd return %!status! for device %Z",
            status, pDeviceName));
    }

    //
    // Derefenece the device
    //
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);
    SetNodeType();
}

//  TdiAddressDeletion - PnP TDI_DEL_ADDRESS_HANDLER
//              Handles an IP address going away.
//              Called by TDI when an address is deleted. If it's an address we
//              care about we'll clean up appropriately.
//
//  Input:      Addr            - IP address that's going.
//
//  Returns:    Nothing.
//
VOID
TdiAddressDeletion(
    PTA_ADDRESS Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    ULONG IpAddr;
    tDEVICECONTEXT      *pDeviceContext;

    CTEPagedCode();

    pDeviceContext = CheckAddrNotification(Addr, pDeviceName, &IpAddr);
    if (pDeviceContext == NULL) {
        return;
    }

    //
    // Now the device is referenced!!!
    //
    NbtTrace(NBT_TRACE_PNP, ("TdiAddressDeletion for %Z, IpAddr=%!ipaddr!, "
            "pDeviceContext->AssignedIpAddress=%!ipaddr!, pDeviceContext->IpAddress=%!ipaddr!",
            pDeviceName, IpAddr, pDeviceContext->AssignedIpAddress, pDeviceContext->IpAddress));

    // Deregister Smb Device
    // THIS IS CODED FOR ONE ADDRESS PER DEVICE
    // Only deletion of an assigned address wins (and is ref counted)
    if (pDeviceContext->AssignedIpAddress == IpAddr) {
        if ((0 == InterlockedDecrement (&AddressCount)) && (pNbtSmbDevice)) {
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiAddressDeletion:  Deregistering NetbiosSmb Device\n"));
            NbtNotifyTdiClients (pNbtSmbDevice, NBT_TDI_DEREGISTER);
        }

        pDeviceContext->AssignedIpAddress = 0;
        if (IpAddr == pDeviceContext->IpAddress) {
            NbtNewDhcpAddress(pDeviceContext, 0, 0);
        }
    }

    //
    // Derefenece the device
    //
    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);
    SetNodeType();
}

VOID
TdiBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList)
{
    NTSTATUS        Status;
    tDEVICECONTEXT  *pDeviceContext;

    CTEPagedCode();

    switch (PnPOpCode)
    {
        case (TDI_PNP_OP_ADD):
        {
            Status = NbtDeviceAdd (pDeviceName);
            if (!NT_SUCCESS(Status))
            {
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_ADD]: ERROR <%x>, AdapterCount=<%x>\n",
                    Status, NbtConfig.AdapterCount));
                NbtLogEvent (EVENT_NBT_CREATE_DEVICE, Status, 0x111);
            }
            NbtTrace(NBT_TRACE_PNP, ("NbtDeviceAdd return %!status! for %Z", Status, pDeviceName));

            break;
        }

        case (TDI_PNP_OP_DEL):
        {
            //
            // If the Device is Valid, Dereference it!
            //
            if (pDeviceContext  = NbtFindAndReferenceDevice (pDeviceName, TRUE))
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_DEL]: Dereferencing Device <%wZ>\n",
                        &pDeviceContext->BindName));

                // Deref it since we referenced it above!
                NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);

                Status = NbtDestroyDevice (pDeviceContext, TRUE);
                NbtTrace(NBT_TRACE_PNP, ("NbtDestoryDevice return %!status! for %Z", Status, pDeviceName));
            }
            else
            {
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_DEL]: ERROR -- Device=<%wZ>\n", pDeviceName));
                NbtTrace(NBT_TRACE_PNP, ("NbtFindAndReferenceDevice return NULL for %Z", pDeviceName));
            }

            break;
        }

        case (TDI_PNP_OP_UPDATE):
        {
            tDEVICES            *pBindDevices = NULL;
            tDEVICES            *pExportDevices = NULL;
            tADDRARRAY          *pAddrArray = NULL;

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_UPDATE]:  Got Update Notification\n"));
            //
            // Re-read the registry
            //
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
            NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);
            NbtReadRegistryCleanup (&pBindDevices, &pExportDevices, &pAddrArray);
            CTEExReleaseResource(&NbtConfig.Resource);
            SetNodeType();
            NbtTrace(NBT_TRACE_PNP, ("[TDI_PNP_OP_UPDATE]"));
            break;
        }

        case (TDI_PNP_OP_PROVIDERREADY):
        {
            WCHAR               wcIpDeviceName[60]  = DD_IP_DEVICE_NAME;
            UNICODE_STRING      ucIpDeviceName;

            RtlInitUnicodeString(&ucIpDeviceName, wcIpDeviceName);
            ucIpDeviceName.MaximumLength = sizeof (wcIpDeviceName);

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_NETREADY]: Comparing <%wZ> with <%wZ>\n",
                    pDeviceName, &ucIpDeviceName));
            NbtTrace(NBT_TRACE_PNP, ("[TDI_PNP_OP_NETREADY]: <%Z> <==> <%Z>", pDeviceName, &ucIpDeviceName));

            //
            // Use case-insensitive compare since registry is case-insensitive
            //
            if (RtlCompareUnicodeString(pDeviceName, &ucIpDeviceName, TRUE) == 0)
            {
                //
                // This is the notification we were waiting for from Ip, so now
                // notify our clients of our completion status as a provider!
                //
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.TdiBindHandler[TDI_PNP_OP_NETREADY]:  Got Ip Notification\n"));

//#if DBG
                TcpipReady = TRUE;
//#endif
                NbtDownBootCounter();
            }

            break;
        }

        case (TDI_PNP_OP_NETREADY):
        {
            // Nothing to do!
            NbtTrace(NBT_TRACE_PNP, ("[TDI_PNP_OP_NETREADY]"));
            break;
        }

        default:
        {
            KdPrint(("Nbt.TdiBindHandler: Unknown Opcode=<%x>\n", PnPOpCode));
            NbtTrace(NBT_TRACE_PNP, ("Unknown Opcode=<%x>", PnPOpCode));
            ASSERT (0);
        }
    }
}



tDEVICECONTEXT *
NbtCreateSmbDevice(
    )

/*++

Routine Description:

The model of this device is different from the rest of the Netbt devices in that netbt devices
are per-adapter.  For this device there is only one instance across all adapters.

This is the code that creates the Smb device.  We create it at DriverEntry and Destory it
at driver Unload time.

We try to call existing routines to create the new device, so that we can reuse as much code
as possible and have the new device initialized identically to the other netbt devices.  Then
we customize this device by setting some variables controlling port and endpoint.

In the current design, a message-only Netbt device is only single session.  Different sessions,
or applications, use different Tcp ports.  Each message-only Netbt device is assigned a single
port, such as Smb.  If you want to
support a different application over Netbt, The easiest thing is to instantiate a new message-only
device with a different Tcp port.  Perhaps there is a way to delay the binding of the port on the
client side from device creation to connection creation?

Another idea to consider is to modularize the construction of these message-only devices.  You
could have a table in the registry naming the device, with its unique initialization parameters.
This code could then read the table.

Create and initialize the message special device.
This function is not driven by Pnp because it is not adapter specific.

The idea here was to abstract the details of special devices as much as possible.  The way
the current code is written, you must have a single port for each device.  This means you
typically will get one application for each special device.  Right now the only case is
rdr/srv using message-mode for smb traffic.  In the future, if you had another netbios session
application that wanted an internet pure device, you could just call this routine with the
new parameters.

Two issues that I can think of:
1. The default session name is still hardcoded.  You might want to pass that in here if you
didn't want *smbserver as the session name.
2. Binding is per application.  Currently there is a .Inf file to get Smb bound to the rdr
and srv.  If you have a new application and a new special device, you will need another .inf
file.

Arguments:


Return Value:

    NTSTATUS -

--*/

{
    NTSTATUS                Status;
    BOOLEAN                 Attached = FALSE;
    tDEVICECONTEXT          *pDeviceContext = NULL;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    UNICODE_STRING          ucSmbDeviceBindName;
    UNICODE_STRING          ucSmbDeviceExportName;
    WCHAR                   Path[MAX_PATH];
    UNICODE_STRING          ParamPath;
    OBJECT_ATTRIBUTES       TmpObjectAttributes;
    HANDLE                  Handle;
    ULONG                   Metric;

    CTEPagedCode();

    NbtTrace(NBT_TRACE_PNP, ("Creating Smb device"));

    RtlInitUnicodeString(&ucSmbDeviceBindName, WC_SMB_DEVICE_BIND_NAME);
    ucSmbDeviceBindName.MaximumLength = sizeof (WC_SMB_DEVICE_BIND_NAME);
    RtlInitUnicodeString(&ucSmbDeviceExportName, WC_SMB_DEVICE_EXPORT_NAME);
    ucSmbDeviceExportName.MaximumLength = sizeof (WC_SMB_DEVICE_EXPORT_NAME);

    CTEAttachFsp(&Attached, REF_FSP_CREATE_SMB_DEVICE);

    //
    // Create the SMBDevice
    //
    Status = NbtCreateDeviceObject (&ucSmbDeviceBindName,   // Bind name, ignored, but must match for delete
                                    &ucSmbDeviceExportName, // Export name
                                    NULL,
                                    &pDeviceContext,
                                    NBT_DEVICE_NETBIOSLESS);// message-only Netbt device

    if (NT_SUCCESS(Status))
    {
        pDeviceContext->SessionPort = NbtConfig.DefaultSmbSessionPort;
        pDeviceContext->DatagramPort = NbtConfig.DefaultSmbDatagramPort;
        pDeviceContext->NameServerPort = 0;  // Disable this port for security reasons

        RtlCopyMemory (pDeviceContext->MessageEndpoint, "*SMBSERVER      ", NETBIOS_NAME_SIZE );

        //
        // Here is where we initialize the handles in the special device
        // Create the handles to the transport. This does not depend on dhcp
        // Use LOOP_BACK because we need to put something non-zero here
        //
        // This device is registered based on address notifications
        //
//        Status = NbtCreateAddressObjects (LOOP_BACK, 0, pDeviceContext);
        Status = NbtCreateAddressObjects (INADDR_LOOPBACK, 0, pDeviceContext);
        pDeviceContext->BroadcastAddress = LOOP_BACK;   // Make sure no broadcasts
        if (NT_SUCCESS(Status))
        {
            //
            // Now clear the If lists and add the INADDR_LOOPBACK address
            //
            if (pDeviceContext->hSession)
            {
                NbtSetTcpInfo (pDeviceContext->hSession,
                               AO_OPTION_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               (ULONG) TRUE);
                NbtSetTcpInfo (pDeviceContext->hSession,
                               AO_OPTION_ADD_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               pDeviceContext->IPInterfaceContext);
            }

            //
            // Now, set the same for the Datagram port
            //
            if ((pDeviceContext->pFileObjects) &&
                (pDeviceContext->pFileObjects->hDgram))
            {
                NbtSetTcpInfo (pDeviceContext->pFileObjects->hDgram,
                               AO_OPTION_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               (ULONG) TRUE);
                NbtSetTcpInfo (pDeviceContext->pFileObjects->hDgram,
                               AO_OPTION_ADD_IFLIST,
                               INFO_TYPE_ADDRESS_OBJECT,
                               pDeviceContext->IPInterfaceContext);
            }
            NbtTrace(NBT_TRACE_PNP, ("Successful creating Smb device"));
        }
        else
        {
            KdPrint (("Nbt.NbtCreateSmbDevice: NbtCreateAddressObjects Failed, status = <%x>\n", Status));
            NbtTrace(NBT_TRACE_PNP, ("NbtCreateAddressObject Failed with %!status!", Status));
        }
    }
    else
    {
        KdPrint (("Nbt.NbtCreateSmbDevice: NbtCreateDeviceObject Failed, status = <%x>\n", Status));
        NbtTrace(NBT_TRACE_PNP, ("NbtCreateDeviceObject Failed with %!status!", Status));
    }

    CTEDetachFsp(Attached, REF_FSP_CREATE_SMB_DEVICE);

    return (pDeviceContext);
}



VOID
NbtPnPPowerComplete(
    IN PNET_PNP_EVENT  NetEvent,
    IN NTSTATUS        ProviderStatus
    )
{
    CTEPagedCode();

    TdiPnPPowerComplete (TdiClientHandle, NetEvent, ProviderStatus);
    NbtTrace(NBT_TRACE_PNP, ("[NbtPnPPowerComplete]"));
}


NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     pDeviceName,
    IN  PNET_PNP_EVENT      PnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    )
{
    tDEVICECONTEXT              *pDeviceContext = NULL;
    NTSTATUS                    status = STATUS_SUCCESS;    // Success by default!
    PNETBT_PNP_RECONFIG_REQUEST PnPEventBuffer = (PNETBT_PNP_RECONFIG_REQUEST) PnPEvent->Buffer;
    PNET_DEVICE_POWER_STATE     pPowerState = (PNET_DEVICE_POWER_STATE) PnPEventBuffer;   // Power requests
    BOOLEAN                     fWait = FALSE;
#ifdef _NETBIOSLESS
    BOOLEAN                     fOldNetbiosEnabledState;
#endif

    CTEPagedCode();

    //
    // Pass the request up first
    //
    if ((pDeviceName) && (pDeviceName->Length)) {
        if (!(pDeviceContext = NbtFindAndReferenceDevice (pDeviceName, TRUE))) {
            return (STATUS_SUCCESS);
        }

#ifdef _NETBIOSLESS
        fOldNetbiosEnabledState = pDeviceContext->NetbiosEnabled;
#endif
    } else if (PnPEvent->NetEvent != NetEventReconfigure) {
        //
        // pDeviceName is not set for Reconfigure events
        // The only valid case for no Device to be specified is Reconfigure!
        //
        return STATUS_UNSUCCESSFUL;
    }

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint(("Nbt.NbtTdiPnpPowerHandler: Device=<%wZ>, Event=<%d>, C1=<%p>, C2=<%p>\n",
                 pDeviceName, PnPEvent->NetEvent, Context1, Context2 ));
    NbtTrace(NBT_TRACE_PNP, ("Device=<%Z>, Event=<%d>, C1=<%p>, C2=<%p>",
                 pDeviceName, PnPEvent->NetEvent, Context1, Context2));

    switch (PnPEvent->NetEvent)
    {
        case (NetEventQueryPower):
        {
            //
            // Check if we should veto this request
            //
            if ((*pPowerState != NetDeviceStateD0) &&
                (NbtConfig.MinimumRefreshSleepTimeout == 0))
            {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler[QueryPower]: Device=<%x>, PowerState=<%x>, status=<%x>\n",
                    pDeviceContext, *pPowerState, status));
            NbtTrace(NBT_TRACE_PNP, ("[QueryPower]: Device=<%Z>, PowerState=<%x>, status=%!status!",
                    pDeviceName, *pPowerState, status));

            //
            // NetBt doesn't need to do anything here, so we'll just return!
            //
            break;
        }
        case (NetEventSetPower):
        {
            //
            // Check if we should veto this request (if requested by user)
            //
            if ((*pPowerState != NetDeviceStateD0) &&
                (NbtConfig.MinimumRefreshSleepTimeout == 0))
            {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler[SetPower]: Device=<%x>, PowerState=<%d=>%d>, status=<%x>\n",
                    pDeviceContext, LastSystemPowerState, *pPowerState, status));
            NbtTrace(NBT_TRACE_PNP, ("[SetPower]: Device=<%Z>, PowerState=<%x>, status=%!status!",
                    pDeviceName, *pPowerState, status));

            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

            if (*pPowerState != LastSystemPowerState)  // this is a state transition
            {
                switch (*pPowerState)
                {
                    case NetDeviceStateD0:
                    {
                        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESH_SLEEPING;

                        if (NbtConfig.pWakeupRefreshTimer)
                        {
                            if (NT_SUCCESS (CTEQueueForNonDispProcessing (DelayedNbtStopWakeupTimer,
                                                                          NULL,
                                                                          NbtConfig.pWakeupRefreshTimer,
                                                                          NULL, NULL, FALSE)))
                            {
                                NbtConfig.pWakeupRefreshTimer->RefCount++;
                                NbtConfig.pWakeupRefreshTimer = NULL;
                            }

                            // Ignore the return status!    (Best effort!)
                            StartTimer(RefreshTimeout,
                                       NbtConfig.InitialRefreshTimeout/NbtConfig.RefreshDivisor,
                                       NULL,            // context value
                                       NULL,            // context2 value
                                       NULL,
                                       NULL,
                                       NULL,            // This Timer is Global!
                                       &NbtConfig.pRefreshTimer,
                                       0,
                                       FALSE);
                        }
                        break;
                    }

                    case NetDeviceStateD1:
                    case NetDeviceStateD2:
                    case NetDeviceStateD3:
                    {
                        if (LastSystemPowerState != NetDeviceStateD0)  // Don't differentiate bw D1, D2, & D3
                        {
                            break;
                        }

                        //
                        // Reset the Refresh Timer to function accordingly
                        //
                        NbtStopRefreshTimer();
                        ASSERT (!NbtConfig.pWakeupRefreshTimer);
                        NbtConfig.GlobalRefreshState |= NBT_G_REFRESH_SLEEPING;

                        KeClearEvent (&NbtConfig.WakeupTimerStartedEvent);
                        if (NT_SUCCESS (CTEQueueForNonDispProcessing (DelayedNbtStartWakeupTimer,
                                                                      NULL,
                                                                      NULL,
                                                                      NULL,
                                                                      NULL,
                                                                      FALSE)))
                        {
                            fWait = TRUE;
                        }

                        break;
                    }

                    default:
                    {
                        ASSERT (0);
                    }
                }

                LastSystemPowerState = *pPowerState;
            }

            CTEExReleaseResource(&NbtConfig.Resource);

            if (fWait)
            {
                NTSTATUS   status;
                status = KeWaitForSingleObject (&NbtConfig.WakeupTimerStartedEvent,   // Object to wait on.
                                       Executive,            // Reason for waiting
                                       KernelMode,           // Processor mode
                                       FALSE,                // Alertable
                                       NULL);                // Timeout
                ASSERT(status == STATUS_SUCCESS);
            }

            break;
        }

        case (NetEventQueryRemoveDevice):
        {
            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventQueryRemoveDevice -- status=<%x>\n",status));
            NbtTrace(NBT_TRACE_PNP, ("[NetEventQueryRemoveDevice]: Device=<%Z>, status=%!status!",
                    pDeviceName, status));
            break;
        }
        case (NetEventCancelRemoveDevice):
        {
            status = TdiPnPPowerRequest (&pDeviceContext->ExportName, PnPEvent, Context1, Context2, NbtPnPPowerComplete);
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventCancelRemoveDevice -- status=<%x>\n",status));
            NbtTrace(NBT_TRACE_PNP, ("[NetEventCancelRemoveDevice]: Device=<%Z>, status=%!status!",
                    pDeviceName, status));
            break;
        }
        case (NetEventReconfigure):
        {
            //
            // First check if the WINs server entries have been modified
            //
            if (pDeviceContext)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler: WINs servers have changed for <%x>\n",pDeviceContext));
                status = NTReReadRegistry (pDeviceContext);
                NbtTrace(NBT_TRACE_PNP, ("[NetEventReconfigure]: WINs servers have changed for %Z, status=%!status!",
                        pDeviceName, status));
            }
            else    // check the rest of the options
            {
#if 0
// EnumDnsOption is no longer set through the UI, so we can ignore this!
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler: Checking EnumDNS option for <%x>\n",pDeviceContext));

                switch (PnPEventBuffer->enumDnsOption)
                {
                    case (WinsOnly):
                        NbtConfig.UseDnsOnly = FALSE;
                        NbtConfig.ResolveWithDns = FALSE;
                        break;

                    case (DnsOnly):
                        NbtConfig.UseDnsOnly = TRUE;
                        NbtConfig.ResolveWithDns = TRUE;
                        break;

                    case (WinsThenDns):
                        NbtConfig.UseDnsOnly = FALSE;
                        NbtConfig.ResolveWithDns = TRUE;
                        break;

                    default:
                        KdPrint (("Nbt.TdiPnPPowerHandler: ERROR bad option for enumDnsOption <%x>\n",
                                    PnPEventBuffer->enumDnsOption));
                }
#endif  // 0

                if (PnPEventBuffer->fLmhostsEnabled)
                {
                    if ((!NbtConfig.EnableLmHosts) ||       // if the user is re-enabling LmHosts
                        (PnPEventBuffer->fLmhostsFileSet))  // the user wants to use a new LmHosts file
                    {
                        tDEVICES        *pBindDevices=NULL;
                        tDEVICES        *pExportDevices=NULL;
                        tADDRARRAY      *pAddrArray=NULL;

                        IF_DBG(NBT_DEBUG_PNP_POWER)
                            KdPrint (("Nbt.TdiPnPPowerHandler: Reading LmHosts file\n"));


                        //
                        // ReRead the registry for the LmHost options
                        //
                        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
                        status = NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);
                        NbtReadRegistryCleanup(&pBindDevices, &pExportDevices, &pAddrArray);
                        CTEExReleaseResource(&NbtConfig.Resource);

                        DelayedNbtResyncRemoteCache(NULL, NULL, NULL, NULL);
                    }
                }
                else
                {
                    NbtConfig.EnableLmHosts = PnPEventBuffer->fLmhostsEnabled;
                }
            }

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventReconfigure -- status=<%x>\n",status));
            NbtTrace(NBT_TRACE_PNP, ("NetEventReconfigure -- %Z status=%!status!", pDeviceName, status));

            break;
        }
        case (NetEventBindList):
        {
            //
            // Just do a general reread of the registry parameters since we could
            // get WINS address change notifications through here!
            //
            if (pDeviceContext)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler: NetEventBindList request for <%x>\n",pDeviceContext));
                status = NTReReadRegistry (pDeviceContext);
            }
            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.TdiPnPPowerHandler: NetEventBindList -- status=<%x>\n",status));
            break;
        }
        case (NetEventPnPCapabilities):
        {
            //
            // Query into TcpIp to get the latest Pnp properties on this device!
            //
            if (pDeviceContext)
            {
                PULONG  pResult = NULL;
                ULONG   BufferLen = sizeof (ULONG);
                ULONG   Input = pDeviceContext->IPInterfaceContext;

                //
                // Query the latest WOL capabilities on this adapter!
                //
                if (NT_SUCCESS (status = NbtProcessIPRequest (IOCTL_IP_GET_WOL_CAPABILITY,
                                                              &Input,      // Input buffer
                                                              BufferLen,
                                                              (PVOID) &pResult,
                                                              &BufferLen)))
                {
                    ASSERT (pResult);
                    pDeviceContext->WOLProperties = *pResult;
                    CTEMemFree (pResult);
                }


                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint (("Nbt.TdiPnPPowerHandler[NetEventPnPCapabilities] <%x>, pDeviceContext=<%p>, Input=<%x>, Result=<%x>\n",status, pDeviceContext, Input, pDeviceContext->WOLProperties));

                status = STATUS_SUCCESS;
            }
            break;
        }

        default:
            KdPrint(("Nbt.TdiPnPPowerHandler: Invalid NetEvent=<%x> -- status=<%x>\n",
                PnPEvent->NetEvent,status));

    }

    if (pDeviceContext) {
#ifdef _NETBIOSLESS
        //
        // Check for transition in Netbios enable state
        //
        if (fOldNetbiosEnabledState != pDeviceContext->NetbiosEnabled)
        {
            if (pDeviceContext->NetbiosEnabled)
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("Nbt.NbtTdiPnpPowerHandler: Enabling address on %wZ\n",
                        &pDeviceContext->ExportName));

                // We don't know what the right IP address is,
                // so we tell TDI to Enumerate!
                TdiEnumerateAddresses(TdiClientHandle);
            }
            else
            {
                IF_DBG(NBT_DEBUG_PNP_POWER)
                    KdPrint(("NbtTdiPnp: disabling address on %wZ", &pDeviceContext->ExportName ));
                NbtNewDhcpAddress(pDeviceContext, 0, 0);    // Get rid of IP address to disable adapter
            }
        }
#endif

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);
        SetNodeType();
    }

    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
CheckSetWakeupPattern(
    tDEVICECONTEXT  *pDeviceContext,
    PUCHAR          pName,
    BOOLEAN         RequestAdd
    )
{
    NTSTATUS                            Status = STATUS_UNSUCCESSFUL;
    CTELockHandle                       OldIrq;
    ULONG                               OutBufLen = sizeof (PVOID);
    ULONG                               InBufLen = 0;

    IP_WAKEUP_PATTERN_REQUEST           IPWakeupPatternReq; // Ioctl Data Format    (12 bytes)
    NET_PM_WAKEUP_PATTERN_DESC          WakeupPatternDesc;  // IP data              (8 Bytes)
    NETBT_WAKEUP_PATTERN                PatternData;        // Data Storage for the Wakeup Data itself (72)

    BOOLEAN                             fAttached = FALSE;

    if (pDeviceContext->DeviceType != NBT_DEVICE_REGULAR)
    {
        return STATUS_UNSUCCESSFUL;
    }

    CTESpinLock(pDeviceContext,OldIrq);
    //
    // Only 1 pattern (the first one) can be set at any time
    //
    if (RequestAdd)
    {
        if (pDeviceContext->WakeupPatternRefCount)
        {
            //
            // There is already a pattern registered on this device
            //
            if (CTEMemEqu (pDeviceContext->WakeupPatternName, pName, NETBIOS_NAME_SIZE-1))
            {
                pDeviceContext->WakeupPatternRefCount++;
                Status = STATUS_SUCCESS;
            }

            CTESpinFree(pDeviceContext,OldIrq);
            return (Status);
        }

        // This is the first pattern
        CTEMemCopy(&pDeviceContext->WakeupPatternName,pName,NETBIOS_NAME_SIZE);
        pDeviceContext->WakeupPatternRefCount++;
    }
    //
    // This is a Delete pattern request
    //
    else
    {
        if ((!pDeviceContext->WakeupPatternRefCount) ||        // No pattern currently registered
            (!CTEMemEqu (pDeviceContext->WakeupPatternName, pName, NETBIOS_NAME_SIZE-1))) // Not this pattern
        {
            CTESpinFree(pDeviceContext,OldIrq);
            return (STATUS_UNSUCCESSFUL);
        }
        //
        // The pattern for deletion matched the pattern that was set earlier
        //
        else if (--pDeviceContext->WakeupPatternRefCount)
        {
            //
            // This pattern is still referenced
            //
            CTESpinFree(pDeviceContext,OldIrq);
            return (STATUS_SUCCESS);
        }
    }
    CTESpinFree(pDeviceContext,OldIrq);

    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint(("Nbt.SetWakeupPattern: %s<%-16.16s:%x> on Device=<%wZ>\n",
            (RequestAdd ? "Add" : "Remove"), pName, pName[15], &pDeviceContext->BindName));

    //
    // Initialize the Pattern Data
    //
    CTEZeroMemory((PVOID) &PatternData, sizeof(NETBT_WAKEUP_PATTERN));
    ConvertToHalfAscii((PCHAR) &PatternData.nbt_NameRR, pName, NULL, 0);
    PatternData.iph_protocol       = 0x11;     // UDP Protocol
    PatternData.udph_src           = htons (NBT_NAMESERVICE_UDP_PORT);
    PatternData.udph_dest          = htons (NBT_NAMESERVICE_UDP_PORT);
    PatternData.nbt_OpCodeFlags    = htons (0x0010);
    //
    // Initialize the WakeupPattern Description
    //
    WakeupPatternDesc.Next    = NULL;
    WakeupPatternDesc.Ptrn    = (PUCHAR) &PatternData;
    WakeupPatternDesc.Mask    = NetBTPatternMask;
    WakeupPatternDesc.PtrnLen = NetBTPatternLen;
    //
    // Initialize the WakeupPattern Request
    //
    IPWakeupPatternReq.PtrnDesc         = &WakeupPatternDesc;
    IPWakeupPatternReq.AddPattern       = RequestAdd;   // Add = TRUE, Remove = FALSE

    OutBufLen = sizeof(IP_ADAPTER_INDEX_MAP) * (NbtConfig.AdapterCount+2);
    IPWakeupPatternReq.InterfaceContext = pDeviceContext->IPInterfaceContext;

    //
    // Now, register the Wakeup pattern on this adapter
    //
    Status = NbtProcessIPRequest (IOCTL_IP_WAKEUP_PATTERN,
                                  &IPWakeupPatternReq,      // Input buffer
                                  sizeof (IP_WAKEUP_PATTERN_REQUEST),
                                  NULL,
                                  &OutBufLen);

    //
    // If we were doing an add, we need to Deref since we failed to register this pattern
    //
    if ((RequestAdd) &&
        (!NT_SUCCESS (Status)))
    {
        CTESpinLock(pDeviceContext,OldIrq);
        pDeviceContext->WakeupPatternRefCount--;
        CTESpinFree(pDeviceContext,OldIrq);
    }

    return Status;
}

/*
 * bug #88696
 *  Set the global variable NodeType based on RegistryNodeType and WINS configuration
 */
void
SetNodeType(void)
{
    /* We only need to check if the registry NodeType is broadcast */
    if (RegistryNodeType & (BNODE| DEFAULT_NODE_TYPE)) {
        /*
         * If there exist at least one active link with WINS server,
         * we set NodeType to hybrid.
         */
        PLIST_ENTRY         head, item;
        CTELockHandle       OldIrq;

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NodeType = RegistryNodeType;
        head = &NbtConfig.DeviceContexts;
        for (item = head->Flink; item != head; item = item->Flink) {
            tDEVICECONTEXT* dev;

            dev = CONTAINING_RECORD(item, tDEVICECONTEXT, Linkage);
            if (dev->IsDestroyed || dev->IpAddress == 0 ||
                    !dev->NetbiosEnabled) {
                continue;
            }
            if ((dev->lNameServerAddress!=LOOP_BACK && dev->lNameServerAddress) || (dev->lBackupServer!=LOOP_BACK && dev->lBackupServer)) {
                NodeType = (MSNODE | (NodeType & PROXY));
                /* We don't need to check further */
                break;
            }
        }

        // A broadcast node cannot have proxy
        if ((NodeType & BNODE) && (NodeType & PROXY)) {
            NodeType &= (~PROXY);
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

NTSTATUS
LookupDeviceInRegistry(
    IN PUNICODE_STRING pBindName,
    OUT tADDRARRAY* pAddrs,
    OUT PUNICODE_STRING pExportName
    )
{
    tDEVICES    *pBindDevices = NULL;
    tDEVICES    *pExportDevices = NULL;
    tADDRARRAY  *pAddrArray = NULL;
    NTSTATUS    Status;
    int         i;

    CTEPagedCode();

    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    Status = NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);

    if (!NT_SUCCESS(Status) || !pBindDevices || !pExportDevices || !pAddrArray) {
        KdPrint (("NetBT!LookupDeviceInRegistry: Registry incomplete: pBind=<%x>, pExport=<%x>, pAddrArray=<%x>\n",
            pBindDevices, pExportDevices, pAddrArray));
        CTEExReleaseResource(&NbtConfig.Resource);
        NbtReadRegistryCleanup(&pBindDevices, &pExportDevices, &pAddrArray);

        return STATUS_REGISTRY_CORRUPT;
    }

    Status = STATUS_UNSUCCESSFUL;
    for (i=0; i<pNbtGlobConfig->uNumDevicesInRegistry; i++ ) {
        if (RtlCompareUnicodeString(pBindName, &pBindDevices->Names[i], TRUE) == 0) {
            Status = STATUS_SUCCESS;
            if (pAddrs) {
                RtlCopyMemory(pAddrs, &pAddrArray[i], sizeof(pAddrArray[i]));
            }
            if (pExportName) {
                pExportName->MaximumLength = pExportDevices->Names[i].MaximumLength;
                pExportName->Buffer = NbtAllocMem(pExportDevices->Names[i].MaximumLength, NBT_TAG2('17'));
                if (pExportName->Buffer == NULL) {
                    KdPrint (("NetBT!LookupDeviceInRegistry: fail to allocate memory\n"));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlCopyUnicodeString(pExportName, &pExportDevices->Names[i]);
                }
            }
            break;
        }
    }

    NbtReadRegistryCleanup(&pBindDevices, &pExportDevices, &pAddrArray);
    CTEExReleaseResource(&NbtConfig.Resource);
    return Status;
}

tDEVICECONTEXT *
CheckAddrNotification(
    IN PTA_ADDRESS         Addr,
    IN PUNICODE_STRING     pDeviceName,
    OUT ULONG              *IpAddr
    )
/*++
       Check if the TDI address notification is for us,
       if so, return a Referenced device context and the IP address
       otherwise, return NULL.

       Note: it is the caller's responsibility to dereference the device context.
 --*/
{
    CTEPagedCode();

    //
    // Ignore any other type of address except IP
    //
    if (Addr->AddressType != TDI_ADDRESS_TYPE_IP) {
        return NULL;
    }

    *IpAddr = ntohl(((PTDI_ADDRESS_IP)&Addr->Address[0])->in_addr);
    IF_DBG(NBT_DEBUG_PNP_POWER)
    {
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("netbt!CheckAddrNotification: %d.%d.%d.%d\n",
                    ((*IpAddr)>>24)&0xFF,((*IpAddr)>>16)&0xFF,((*IpAddr)>>8)&0xFF,(*IpAddr)&0xFF));
    }

    //
    // Filter out zero address notifications
    //
    if (*IpAddr == 0) {
        KdPrint (("Nbt.TdiAddressDeletion: ERROR: Address <%x> not assigned to any device!\n", IpAddr));
        return NULL;
    }

    //
    // Ignore this notification if we don't bind to this device
    //
    return NbtFindAndReferenceDevice (pDeviceName, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\registry.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

    This contains all routines necessary to load device pathnames from the
    registry.

Author:

    Jim Stewart (Jimst) October 9 1992

Revision History:
    Jiandong Ruan (jruan) April 6 2000  Add NbtReadRegistryCleanup

Notes:

--*/

#include "precomp.h"


//
// Local functions used to access the registry.
//

NTSTATUS
NbtOpenRegistry(
    IN HANDLE       NbConfigHandle,
    IN PWSTR        String,
    OUT PHANDLE     pHandle
    );

VOID
NbtCloseRegistry(
    IN HANDLE LinkageHandle,
    IN HANDLE ParametersHandle
    );

NTSTATUS
NbtReadLinkageInformation(
    IN  PWSTR       pName,
    IN  HANDLE      LinkageHandle,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,      // place to put read in config data
    OUT ULONG       *pNumDevices
    );

NTSTATUS
OpenAndReadElement(
    IN  PUNICODE_STRING pucRootPath,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    );

NTSTATUS
GetIpAddressesList (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       pwsKeyName,
    IN  ULONG       MaxAddresses,
    OUT tIPADDRESS  *pAddrArray,
    OUT ULONG       *pNumGoodAddresses
    );

NTSTATUS
GetServerAddress (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       KeyName,
    OUT PULONG      pIpAddr
    );

NTSTATUS
NbtAppendString (
    IN  PWSTR               FirstString,
    IN  PWSTR               SecondString,
    OUT PUNICODE_STRING     pucString
    );

NTSTATUS
ReadStringRelative(
    IN  PUNICODE_STRING pRegistryPath,
    IN  PWSTR           pRelativePath,
    IN  PWSTR           pValueName,
    OUT PUNICODE_STRING pOutString
    );

VOID
NbtFindLastSlash(
    IN  PUNICODE_STRING pucRegistryPath,
    OUT PWSTR           *ppucLastElement,
    IN  int             *piLength
    );

NTSTATUS
ReadSmbDeviceInfo(
    IN HANDLE       NbConfigHandle
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtReadRegistry)
#pragma CTEMakePageable(PAGE, NbtReadRegistryCleanup)
#pragma CTEMakePageable(PAGE, ReadNameServerAddresses)
#pragma CTEMakePageable(PAGE, GetIpAddressesList)
#pragma CTEMakePageable(PAGE, GetServerAddress)
#pragma CTEMakePageable(PAGE, NTReadIniString)
#pragma CTEMakePageable(PAGE, GetIPFromRegistry)
#pragma CTEMakePageable(PAGE, NbtOpenRegistry)
#pragma CTEMakePageable(PAGE, NbtParseMultiSzEntries)
#pragma CTEMakePageable(PAGE, NbtReadLinkageInformation)
#pragma CTEMakePageable(PAGE, NbtReadSingleParameter)
#pragma CTEMakePageable(PAGE, OpenAndReadElement)
#pragma CTEMakePageable(PAGE, ReadElement)
#pragma CTEMakePageable(PAGE, NTGetLmHostPath)
#pragma CTEMakePageable(PAGE, ReadStringRelative)
#pragma CTEMakePageable(PAGE, NbtFindLastSlash)
#pragma CTEMakePageable(PAGE, ReadSmbDeviceInfo)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
NbtReadRegistry(
    OUT tDEVICES        **ppBindDevices,
    OUT tDEVICES        **ppExportDevices,
    OUT tADDRARRAY      **ppAddrArray
    )
/*++

Routine Description:

    This routine is called to get information from the registry,
    starting at RegistryPath to get the parameters.
    This routine must be called with the NbtConfig.Resource lock HELD

Arguments:

    Before calling this routine, the following Global parameters
    must have been initialized (in DriverEntry):

        NbtConfig.pRegistry

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    NTSTATUS            OpenStatus;
    HANDLE              LinkageHandle;
    HANDLE              ParametersHandle;
    HANDLE              NbtConfigHandle;
    NTSTATUS            Status;
    ULONG               Disposition;
    OBJECT_ATTRIBUTES   TmpObjectAttributes;
    PWSTR               LinkageString = L"Linkage";
    PWSTR               ParametersString = L"Parameters";
    tDEVICES            *pBindDevices;
    tDEVICES            *pExportDevices;
    UNICODE_STRING      ucString;
    ULONG               NumBindings;

    CTEPagedCode();

	*ppExportDevices = *ppBindDevices = NULL;
	*ppAddrArray = NULL;

    //
    // Open the registry.
    //
    InitializeObjectAttributes (&TmpObjectAttributes,
                                &NbtConfig.pRegistry,                       // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NULL,                                       // root
                                NULL);                                      // security descriptor

    Status = ZwCreateKey (&NbtConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    if (!NT_SUCCESS(Status))
    {
        KdPrint (("Nbt.NbtReadRegistry:  ZwCreateKey FAILed, status=<%x>\n", Status));
        NbtLogEvent (EVENT_NBT_CREATE_DRIVER, Status, 0x114);
        return STATUS_UNSUCCESSFUL;
    }

    OpenStatus = NbtOpenRegistry (NbtConfigHandle, LinkageString, &LinkageHandle);
    if (NT_SUCCESS(OpenStatus))
    {
        OpenStatus = NbtOpenRegistry (NbtConfigHandle, ParametersString, &ParametersHandle);
        if (NT_SUCCESS(OpenStatus))
        {
            //
            // Read in the binding information (if none is present
            // the array will be filled with all known drivers).
            //
            if (pBindDevices = NbtAllocMem ((sizeof(tDEVICES)+2*NBT_MAXIMUM_BINDINGS*sizeof(UNICODE_STRING)),
                                            NBT_TAG2('25')))
            {
                if (pExportDevices=NbtAllocMem((sizeof(tDEVICES)+2*NBT_MAXIMUM_BINDINGS*sizeof(UNICODE_STRING)),
                                     NBT_TAG2('26')))
                {
                    ReadParameters (&NbtConfig, ParametersHandle);// Read various parameters from the registry
                    ReadSmbDeviceInfo (NbtConfigHandle); // Set the information for the SmbDevice

                    //
                    // From now on, the only failures we can encounter are in reading the
                    // Bind, Export or Name Server address entries, hence if we fail here,
                    // we will still return success, but will assume 0 devices configured!
                    //
                    pBindDevices->RegistryData = pExportDevices->RegistryData = NULL;
                    Status = NbtReadLinkageInformation (NBT_BIND,
                                                        LinkageHandle,
                                                        2*NBT_MAXIMUM_BINDINGS,
                                                        pBindDevices,
                                                        &NumBindings);
					if (!NT_SUCCESS(Status))
                    {
                        KdPrint (("Nbt.NbtReadRegistry: NbtReadLinkageInformation FAILed - BIND <%x>\n",
                            Status));
                        NbtLogEvent (EVENT_NBT_READ_BIND, Status, 0x115);
                    }
                    else    // if (NT_SUCCESS(Status))
					{
	                    IF_DBG(NBT_DEBUG_NTUTIL)
	                        KdPrint(("Binddevice = %ws\n",pBindDevices->Names[0].Buffer));

                        NbtConfig.uNumDevicesInRegistry = (USHORT) NumBindings;
                        NumBindings = 0;

	                    //  Read the EXPORT information as well.
	                    Status = NbtReadLinkageInformation (NBT_EXPORT,
	                                                        LinkageHandle,
                                                            2*NBT_MAXIMUM_BINDINGS,
	                                                        pExportDevices,
	                                                        &NumBindings);
	                    if (NT_SUCCESS(Status))
                        {
	                        // we want the lowest number for num devices in case there
	                        // are more bindings than exports or viceversa
	                        //
//                            ASSERT (NumBindings == NbtConfig.uNumDevicesInRegistry);
	                        NbtConfig.uNumDevicesInRegistry = (USHORT)
                                                              (NbtConfig.uNumDevicesInRegistry > NumBindings ?
	                                                           NumBindings : NbtConfig.uNumDevicesInRegistry);

                            if (NbtConfig.uNumDevicesInRegistry == 0)
                            {
                                KdPrint (("Nbt.NbtReadRegistry: WARNING - NumDevicesInRegistry = 0\n"));
                            }
                        }
                        else
                        {
                            KdPrint (("Nbt.NbtReadRegistry: NbtReadLinkageInformation FAILed - EXPORT <%x>\n",
                                Status));
                            NbtLogEvent (EVENT_NBT_READ_EXPORT, Status, 0x116);
                        }
                    }

                    if ((NT_SUCCESS(Status)) &&
                        (NbtConfig.uNumDevicesInRegistry))
					{
	                    IF_DBG(NBT_DEBUG_NTUTIL)
	                        KdPrint(("Exportdevice = %ws\n",pExportDevices->Names[0].Buffer));

	                    //
	                    // read in the NameServer IP address now
	                    //
	                    Status = ReadNameServerAddresses (NbtConfigHandle,
	                                                      pBindDevices,
	                                                      NbtConfig.uNumDevicesInRegistry,
	                                                      ppAddrArray);

	                    if (!NT_SUCCESS(Status))
                        {
                            if (!(NodeType & BNODE))        // Post Warning!
                            {
                                NbtLogEvent (EVENT_NBT_NAME_SERVER_ADDRS, Status, 0x118);
                            }
                            KdPrint(("Nbt.NbtReadRegistry: ReadNameServerAddresses returned <%x>\n", Status));
                        }
                        else    // if (NT_SUCCESS(Status))
                        {
                            //
                            // check if any WINS servers have been configured change
                            // to Hnode
                            //
                            if (NodeType & (BNODE | DEFAULT_NODE_TYPE))
                            {
                                ULONG i;
                                for (i=0; i<NbtConfig.uNumDevicesInRegistry; i++)
                                {
                                    if (((*ppAddrArray)[i].NameServerAddress != LOOP_BACK) ||
                                        ((*ppAddrArray)[i].BackupServer != LOOP_BACK))
                                    {
                                        NodeType = MSNODE | (NodeType & PROXY);
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    if ((!NT_SUCCESS(Status)) ||
                        (0 == NbtConfig.uNumDevicesInRegistry))
                    {
                        //
                        // We had problems reading the Bind or Export or Address entries
                        //
                        if (pBindDevices->RegistryData)
                        {
                            CTEMemFree(pBindDevices->RegistryData);
                        }
                        CTEMemFree(pBindDevices);

                        if (pExportDevices->RegistryData)
                        {
                            CTEMemFree(pExportDevices->RegistryData);
                        }
                        CTEMemFree(pExportDevices);

                        pBindDevices = pExportDevices = NULL;
                        NbtConfig.uNumDevicesInRegistry = 0;
                        Status = STATUS_SUCCESS;
                    }

                    //
                    // we have done the check for default node so turn off
                    // the flag
                    //
                    NodeType &= ~DEFAULT_NODE_TYPE;
                    //
                    // A Bnode cannot be a proxy too
                    //
                    if (NodeType & BNODE)
                    {
                        if (NodeType & PROXY)
                        {
                            NodeType &= ~PROXY;
                        }
                    }

                    // keep the size around for allocating memory, so that when we run over
                    // OSI, only this value should change (in theory at least)
                    NbtConfig.SizeTransportAddress = sizeof(TDI_ADDRESS_IP);

                    // fill in the node type value that is put into all name service Pdus
                    // that go out identifying this node type
                    switch (NodeType & NODE_MASK)
                    {
                        case BNODE:
                            NbtConfig.PduNodeType = 0;
                            break;
                        case PNODE:
                            NbtConfig.PduNodeType = 1 << 13;
                            break;
                        case MNODE:
                            NbtConfig.PduNodeType = 1 << 14;
                            break;
                        case MSNODE:
                            NbtConfig.PduNodeType = 3 << 13;
                            break;

                    }

                    // read the name of the transport to bind to
                    //
                    if (NT_SUCCESS(ReadElement(ParametersHandle, WS_TRANSPORT_BIND_NAME, &ucString)))
                    {
                        UNICODE_STRING  StreamsString;

                        //
                        // if there is already a bind string, free it before
                        // allocating another
                        //
                        if (NbtConfig.pTcpBindName)
                        {
                            //
                            // CreateDeviceString in tdicnct.c could access the pTcpBindName right
                            // after it is freed. The right way is using a lock. But, ...
                            //
                            // Hack!!!:
                            // Although this doesn't completely fix the problem, it has the minimum
                            // side-effect.
                            //
                            // The value of WS_TRANSPORT_BIND_NAME won't change. By doing this,
                            // we avoid the possible access-after-free problem in most cases.
                            //
                            RtlInitUnicodeString(&StreamsString, NbtConfig.pTcpBindName);
                            if (RtlCompareUnicodeString(&ucString,&StreamsString,TRUE)) {
                                CTEMemFree(NbtConfig.pTcpBindName);
                                NbtConfig.pTcpBindName = ucString.Buffer;
                            } else {
                                CTEMemFree(ucString.Buffer);
                                ucString = StreamsString;
                            }
                        } else {
                            NbtConfig.pTcpBindName = ucString.Buffer;
                        }

                        // ********** REMOVE LATER ***********
                        RtlInitUnicodeString(&StreamsString,NBT_TCP_BIND_NAME);
                        if (RtlCompareUnicodeString(&ucString,&StreamsString,TRUE))
                        {
                            StreamsStack = FALSE;
                        }
                        else
                        {
                            StreamsStack = TRUE;
                        }
                    }
                    else
                    {
                        StreamsStack = TRUE;
                    }

                    ZwClose(ParametersHandle);
                    ZwClose(LinkageHandle);
                    ZwClose(NbtConfigHandle);

                    *ppExportDevices = pExportDevices;
                    *ppBindDevices   = pBindDevices;
                    return (Status);
                }
                else
                {
                    KdPrint (("Nbt.NbtReadRegistry:  FAILed to allocate pExportDevices\n"));
                }
                CTEMemFree(pBindDevices);
            }
            else
            {
                KdPrint (("Nbt.NbtReadRegistry:  FAILed to allocate pBindDevices\n"));
            }
            ZwClose(ParametersHandle);
        }
        else
        {
            KdPrint (("Nbt.NbtReadRegistry:  NbtOpenRegistry FAILed for PARAMETERS, status=<%x>\n", Status));
            NbtLogEvent (EVENT_NBT_OPEN_REG_PARAMS, OpenStatus, 0x119);
        }
        ZwClose(LinkageHandle);
    }
    else
    {
        KdPrint (("Nbt.NbtReadRegistry:  NbtOpenRegistry FAILed for LINKAGE, status=<%x>\n", Status));
        NbtLogEvent (EVENT_NBT_OPEN_REG_LINKAGE, OpenStatus, 0x120);
    }

    ZwClose (NbtConfigHandle);

    return STATUS_UNSUCCESSFUL;
}

//----------------------------------------------------------------------------
VOID
NbtReadRegistryCleanup(
    IN tDEVICES        **ppBindDevices,
    IN tDEVICES        **ppExportDevices,
    IN tADDRARRAY      **ppAddrArray
    )
/*++

Routine Description:

    This routine is called to release resources allocated by NbtReadRegistry
++*/

{
    CTEPagedCode();
    if (ppBindDevices[0]) {
        CTEMemFree((PVOID)ppBindDevices[0]->RegistryData);
        CTEMemFree((PVOID)ppBindDevices[0]);
        ppBindDevices[0] = NULL;
    }
    if (ppExportDevices[0]) {
        CTEMemFree((PVOID)ppExportDevices[0]->RegistryData);
        CTEMemFree((PVOID)ppExportDevices[0]);
        ppExportDevices[0] = NULL;
    }
    if (ppAddrArray[0]) {
        CTEMemFree((PVOID)ppAddrArray[0]);
        ppAddrArray[0] = NULL;
    }
}


NTSTATUS
ReadSmbDeviceInfo(
    IN HANDLE       NbtConfigHandle
    )
{
    HANDLE      SmbHandle;
    NTSTATUS    Status;

    CTEPagedCode();

    Status = NbtOpenRegistry (NbtConfigHandle, WC_SMB_PARAMETERS_LOCATION, &SmbHandle);
    if (NT_SUCCESS(Status))
    {
        NbtConfig.DefaultSmbSessionPort =  (USHORT) CTEReadSingleIntParameter (SmbHandle,
                                                                               SESSION_PORT,
                                                                               NBT_SMB_SESSION_TCP_PORT,
                                                                               1);

        NbtConfig.DefaultSmbDatagramPort =  (USHORT) CTEReadSingleIntParameter (SmbHandle,
                                                                                DATAGRAM_PORT,
                                                                                NBT_SMB_DATAGRAM_UDP_PORT,
                                                                                1);
        ZwClose (SmbHandle);
    }
    else
    {
        NbtConfig.DefaultSmbSessionPort = NBT_SMB_SESSION_TCP_PORT;
        NbtConfig.DefaultSmbDatagramPort = NBT_SMB_DATAGRAM_UDP_PORT;
    }

    return (Status);
}



//----------------------------------------------------------------------------
NTSTATUS
ReadNameServerAddresses (
    IN  HANDLE      NbtConfigHandle,
    IN  tDEVICES    *BindDevices,
    IN  ULONG       NumberDevices,
    OUT tADDRARRAY  **ppAddrArray
    )

/*++

Routine Description:

    This routine is called to read the name server addresses from the registry.
    It stores them in a data structure that it allocates.  This memory is
    subsequently freed in driver.c when the devices have been created.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
#define ADAPTER_SIZE_MAX    400

    UNICODE_STRING  ucString;
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    HANDLE          Handle;
    LONG            i,j,Len;
    PWSTR           pwsAdapter = L"Parameters\\Interfaces\\";
    PWSTR           BackSlash = L"\\";
    tADDRARRAY      *pAddrArray;
    ULONG           LenAdapter;
#ifdef _NETBIOSLESS
    ULONG           Options;
#endif
    ULONG           NumNameServerAddresses = 0;

    CTEPagedCode();

    *ppAddrArray = NULL;

    // this is large enough for 400 characters of adapter name.
    ucString.Buffer = NbtAllocMem (ADAPTER_SIZE_MAX, NBT_TAG2('27'));
    if (!ucString.Buffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pAddrArray = NbtAllocMem (sizeof(tADDRARRAY)*NumberDevices, NBT_TAG2('28'));
    if (!pAddrArray)
    {
        CTEMemFree(ucString.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CTEZeroMemory(pAddrArray,sizeof(tADDRARRAY)*NumberDevices);
    *ppAddrArray = pAddrArray;

    // get the adapter name out of the Bind string, and use it to open
    // a key by the same name, to get the name server addresses
    //
    for (i = 0;i < (LONG)NumberDevices ;i ++ )
    {
        WCHAR   *pBuffer;

        Len = BindDevices->Names[i].Length/sizeof(WCHAR);
        Len--;
        //
        // start at the end a work backwards looking for a '\'
        //
        j  = Len;
        pBuffer = &BindDevices->Names[i].Buffer[j];
        while (j)
        {
            if (*pBuffer != *BackSlash)
            {
                j--;
                pBuffer--;
            }
            else
                break;
        }

        // if we don't find a backslash or at least one
        // character name then continue around again, or the name
        // is longer than the buffer, then go to the next device in the
        // bind list
        //
        if ((j == 0) ||
            (j == Len) ||
            (j == Len -1) ||
            ((Len - j) > ADAPTER_SIZE_MAX))
        {
            continue;
        }

        // copy the string "Adapter\" to the buffer since the adapters all
        // appear under this key in the registery
        //
        LenAdapter = wcslen(pwsAdapter);
        CTEMemCopy(ucString.Buffer, pwsAdapter, LenAdapter*sizeof(WCHAR));
        //
        // copy just the adapter name from the Bind string, since that is
        // the name of the key to open to find the name server ip addresses
        //
        CTEMemCopy(&ucString.Buffer[LenAdapter], ++pBuffer, (Len - j)*sizeof(WCHAR));
        ucString.Buffer[Len - j + LenAdapter] = 0;

        pAddrArray->NameServerAddress = LOOP_BACK;
        pAddrArray->BackupServer = LOOP_BACK;
#ifdef MULTIPLE_WINS
        pAddrArray->Others[0] = LOOP_BACK;          // For Safety
        pAddrArray->NumOtherServers = 0;
        pAddrArray->LastResponsive = 0;
#endif

        status = NbtOpenRegistry (NbtConfigHandle, ucString.Buffer, &Handle);
        if (NT_SUCCESS(status))
        {
            status = GetIpAddressesList(Handle,         // Generic routine to read in list of Ip addresses
                                        PWS_NAME_SERVER_LIST,
                                        2+MAX_NUM_OTHER_NAME_SERVERS,
                                        pAddrArray->AllNameServers,
                                        &NumNameServerAddresses);

            if (!NT_SUCCESS(status) ||
                (pAddrArray->NameServerAddress == LOOP_BACK))
            {
                NumNameServerAddresses = 0;
                status = GetIpAddressesList(Handle,
                                            PWS_DHCP_NAME_SERVER_LIST,
                                            2+MAX_NUM_OTHER_NAME_SERVERS,
                                            pAddrArray->AllNameServers,
                                            &NumNameServerAddresses);

            }

            //
            // Continue even if we failed to read in any IP addresses
            //
            if (NumNameServerAddresses > 2)
            {
                pAddrArray->NumOtherServers = (USHORT) NumNameServerAddresses - 2;
            }

#ifdef _NETBIOSLESS
            // NbtReadSingle doesn't quite do what we want.  In this case, if the non-dhcp-
            // decorated option is present but zero, we DO want to go on to the dhcp-
            // decorated one.  So, try the dhcp-decorated one explicitly if we get back zero.
            Options = NbtReadSingleParameter( Handle, PWS_NETBIOS_OPTIONS, 0, 0 );
            if (Options == 0)
            {
                Options = NbtReadSingleParameter( Handle, PWS_DHCP_NETBIOS_OPTIONS, 0, 0 );
            }
            // Options is encoded as four bytes
            // Each byte can be an independent set of flags
            // The high order three bytes can be used for controlling other aspects
            // Enabled option, default is TRUE
            pAddrArray->NetbiosEnabled = ((Options & 0xff) != NETBT_MODE_NETBIOS_DISABLED);
#endif
            pAddrArray->RasProxyFlags = NbtReadSingleParameter(Handle, PWS_RAS_PROXY_FLAGS, 0, 0);
            pAddrArray->EnableNagling = (NbtReadSingleParameter(Handle, PWS_ENABLE_NAGLING, 0, 0) != FALSE);

            // don't want to fail this routine just because the
            // name server address was not set
            status = STATUS_SUCCESS;

            ZwClose(Handle);
        }
        pAddrArray++;

    }

    CTEMemFree(ucString.Buffer);
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
GetIpAddressesList (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       pwsKeyName,
    IN  ULONG       MaxAddresses,
    OUT tIPADDRESS  *pAddrArray,
    OUT ULONG       *pNumGoodAddresses
    )

/*++

Routine Description:

    This routine is called to read a list of Ip addresses from the registry.

Arguments:


Return Value:

    None.

--*/
{
    ULONG           NumEntriesRead, NumGoodAddresses, NumAddressesAttempted;
    tDEVICES        *pucAddressList;
    NTSTATUS        Status;
    STRING          String;
    ULONG           IpAddr;
    PWSTR           DhcpName = L"Dhcp";
    UNICODE_STRING  DhcpKeyName;

    CTEPagedCode();

    pucAddressList=NbtAllocMem((sizeof(tDEVICES)+2*NBT_MAXIMUM_BINDINGS*sizeof(UNICODE_STRING)),NBT_TAG('i'));
    if (!pucAddressList)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Since NbtReadLinkageInformation very conveniently reads in the values for
    // a MULTI_SZ registry entry, we will re-use this function here!
    //
    //
    NumEntriesRead = 0;
    Status = NbtReadLinkageInformation (pwsKeyName,
                                        ParametersHandle,
                                        2*NBT_MAXIMUM_BINDINGS,
                                        pucAddressList,
                                        &NumEntriesRead);
    if ((STATUS_ILL_FORMED_SERVICE_ENTRY == Status) || (!NT_SUCCESS(Status)))
    {
        IF_DBG(NBT_DEBUG_NTUTIL)
            KdPrint(("GetIpAddressesList: ERROR -- NbtReadLinkageInformation=<%x>, <%ws>\n",
                Status, pwsKeyName));

        CTEMemFree(pucAddressList);
        return STATUS_UNSUCCESSFUL;
    }

    String.Buffer = NbtAllocMem (REGISTRY_BUFF_SIZE, NBT_TAG2('29'));
    if (!String.Buffer)
    {
        KdPrint(("GetNameServerAddresses: Failed to Allocate memory\n"));
        CTEMemFree((PVOID)pucAddressList->RegistryData);
        CTEMemFree(pucAddressList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    String.MaximumLength = REGISTRY_BUFF_SIZE;

    //
    // NumGoodAddresses will be bound by MaxAddresses, while
    // NumAddressesAttempted will be bound by NumEntriesRead
    // Also, we could have read NumEntriesRead > MaxAddresses
    // (some of the entries could be invalid), but we will not
    // attempt to read > 2*MaxAddresses entires
    //
    NumGoodAddresses = 0;
    NumAddressesAttempted = 0;
    while ((NumGoodAddresses < MaxAddresses) &&
           (NumAddressesAttempted < NumEntriesRead) &&
           (NumAddressesAttempted < (2*MaxAddresses)))
    {
        Status  = RtlUnicodeStringToAnsiString(&String, &pucAddressList->Names[NumAddressesAttempted], FALSE);
        if (NT_SUCCESS(Status))
        {
            Status = ConvertDottedDecimalToUlong((PUCHAR) String.Buffer, &IpAddr);
            if (NT_SUCCESS(Status) && IpAddr)
            {
                pAddrArray[NumGoodAddresses++] = IpAddr;
            }
        }
        NumAddressesAttempted++;
    }

    CTEMemFree ((PVOID)String.Buffer);
    CTEMemFree ((PVOID)pucAddressList->RegistryData);
    CTEMemFree ((PVOID)pucAddressList);

    //
    // If we were able to read in at least 1 good Ip address,
    // return success, otherwise return failure!
    //
    if (NumGoodAddresses)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_INVALID_ADDRESS;
    }

    *pNumGoodAddresses = NumGoodAddresses;
    return(Status);
}

NTSTATUS
GetServerAddress (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       KeyName,
    OUT PULONG      pIpAddr
    )

/*++

Routine Description:

    This routine is called to read the name server addresses from the registry.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{
    NTSTATUS        status;
    ULONG           IpAddr;
    PUCHAR          NameServer;

    CTEPagedCode();

    status = CTEReadIniString(ParametersHandle,KeyName,&NameServer);

    if (NT_SUCCESS(status))
    {
        status = ConvertDottedDecimalToUlong(NameServer,&IpAddr);
        if (NT_SUCCESS(status) && IpAddr)
        {
            *pIpAddr = IpAddr;
        }
        else
        {
            if (IpAddr != 0)
            {
                NbtLogEvent (EVENT_NBT_BAD_PRIMARY_WINS_ADDR, 0, 0x121);
            }
            *pIpAddr = LOOP_BACK;
        }

        CTEMemFree((PVOID)NameServer);


    }
    else
    {
        *pIpAddr = LOOP_BACK;
    }

    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NbtAppendString (
    IN  PWSTR               FirstString,
    IN  PWSTR               SecondString,
    OUT PUNICODE_STRING     pucString
    )

/*++

Routine Description:

    This routine is called to append the second string to the first string.
    It allocates memory for this, so the caller must be sure to free it.

Arguments:


Return Value:

    None.

--*/
{
    NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
    ULONG           Length;
    PWSTR           pDhcpKeyName;

    CTEPagedCode();

    Length = (wcslen(FirstString) + wcslen(SecondString) + 1)*sizeof(WCHAR);
    pDhcpKeyName = NbtAllocMem (Length, NBT_TAG2('30'));
    if (pDhcpKeyName)
    {
        pucString->Buffer = pDhcpKeyName;
        pucString->Length = (USHORT)0;
        pucString->MaximumLength = (USHORT)Length;
        pucString->Buffer[0] = UNICODE_NULL;

        status = RtlAppendUnicodeToString(pucString,FirstString);
        if (NT_SUCCESS(status))
        {
            status = RtlAppendUnicodeToString(pucString,SecondString);
            if (NT_SUCCESS(status))
            {
                return status;
            }
        }
        CTEMemFree(pDhcpKeyName);

    }
    return(status);
}
//----------------------------------------------------------------------------
NTSTATUS
NTReadIniString (
    IN  HANDLE      ParametersHandle,
    IN  PWSTR       KeyName,
    OUT PUCHAR      *ppString
    )

/*++

Routine Description:

    This routine is called to read a string of configuration information from
    the registry.

Arguments:

    ParametersHandle    - handle to open key in registry
    KeyName             - key to read
    ppString            - returned string

Return Value:

    None.

--*/
{
    UNICODE_STRING  ucString;
    STRING          String;
    NTSTATUS        status;
    PUCHAR          pBuffer;
    PWSTR           Dhcp = L"Dhcp";

    CTEPagedCode();
    //
    // read in the Scope Id
    //
    // if the key is not there or it is set to a null string try to read the
    // dhcp key
    //
    status = ReadElement (ParametersHandle, KeyName, &ucString);
    if (!NT_SUCCESS(status) || (ucString.Length == 0))
    {
        UNICODE_STRING  String;

        // free the string allocated in ReadElement
        if (NT_SUCCESS(status))
        {
            CTEMemFree(ucString.Buffer);
        }
        //
        // try to read a similar string that is prefixed with "DHCP"
        // incase there is only the DHCP configuration information present
        // and not overrides keys.
        //
        status = NbtAppendString(Dhcp,KeyName,&String);
        if (NT_SUCCESS(status))
        {
            status = ReadElement (ParametersHandle, String.Buffer, &ucString);
            CTEMemFree(String.Buffer);  // Free the buffer allocated in NbtAppendString
        }
    }
    // the scope must be less than
    // 255-16 characters since the whole name is limited to 255 as per the
    // RFC
    //
    IF_DBG(NBT_DEBUG_NTUTIL)
    KdPrint(("Nbt: ReadIniString = %ws\n",ucString.Buffer));

    if (NT_SUCCESS(status))
    {
        if ((ucString.Length > 0) &&
           (ucString.Length <= (255 - NETBIOS_NAME_SIZE)*sizeof(WCHAR)))
        {

            pBuffer = NbtAllocMem (ucString.MaximumLength/sizeof(WCHAR), NBT_TAG2('31'));
            if (pBuffer)
            {
                // convert to an ascii string and store in the config data structure
                // increment pBuffer to leave room for the length byte
                //
                String.Buffer = pBuffer;
                String.MaximumLength = ucString.MaximumLength/sizeof(WCHAR);
                status = RtlUnicodeStringToAnsiString (&String, &ucString, FALSE);
                if (NT_SUCCESS(status))
                {
                    *ppString = pBuffer;
                }
                else
                {
                    CTEMemFree(pBuffer);
                }
            }
            else
            {
                status = STATUS_UNSUCCESSFUL;
            }


        }
        else if (NT_SUCCESS(status))
        {
            // force the code to setup a null scope since the one in the
            // registry is null
            //
            status = STATUS_UNSUCCESSFUL;
        }

        // free the string allocated in ReadElement
        CTEMemFree(ucString.Buffer);
    }

    return(status);
}

VOID
NbtFreeRegistryInfo (
    )

/*++

Routine Description:

    This routine is called by Nbt to free any storage that was allocated
    by NbConfigureTransport in producing the specified CONFIG_DATA structure.

Arguments:

    ConfigurationInfo - A pointer to the configuration information structure.

Return Value:

    None.

--*/
{

}

//----------------------------------------------------------------------------
NTSTATUS
GetIPFromRegistry(
    IN  PUNICODE_STRING         pucBindDevice,
    OUT tIPADDRESS              *pIpAddresses,
    OUT tIPADDRESS              *pSubnetMask,
    IN  ULONG                   MaxIpAddresses,
    OUT ULONG                   *pNumIpAddresses,
    IN  enum eNbtIPAddressType  IPAddressType
    )
/*++

Routine Description:

    This routine is called to get the IP address of an adapter from the
    Registry.  The Registry path variable contains the path name
    for NBT's registry entries.  The last element of this path name is
    removed to give the path to any card in the registry.

    The BindDevice path contains a Bind string for NBT.  We remove the last
    element of this path (which is the adapter name \Elnkii01) and tack it
    onto the modified registry path from above.  We then tack on
    \Parameters which will give the full path to the Tcpip key, which
    we open to get the Ip address.


Arguments:

    Before calling this routine, the following Global parameters
    must have been initialized (in DriverEntry):

        NbtConfig.pRegistry

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/
{
    ULONG               i, Len, Disposition;
    PVOID               pBuffer;
    NTSTATUS            Status = STATUS_UNSUCCESSFUL;   // by default
    PWSTR               pwsIpAddressName, pwsSubnetMask;
    PWSTR               pwsAdapterGuid, pwsLastSlash;
    PWSTR               pwsTcpParams        = L"Tcpip\\Parameters\\Interfaces\\"; // key to open
    PWSTR               pwsUnderScore       = L"_";
    UNICODE_STRING      Path;
    HANDLE              TcpGuidHandle;
    OBJECT_ATTRIBUTES   TmpObjectAttributes;

    CTEPagedCode();

    switch (IPAddressType)
    {
        case (NBT_IP_STATIC):
            pwsIpAddressName = STATIC_IPADDRESS_NAME;
            pwsSubnetMask = STATIC_IPADDRESS_SUBNET;
            break;

        case (NBT_IP_DHCP):
            pwsIpAddressName = DHCP_IPADDRESS_NAME;
            pwsSubnetMask = DHCP_IPADDRESS_SUBNET;
            break;

        case (NBT_IP_AUTOCONFIGURATION):
            pwsIpAddressName = DHCP_IPAUTOCONFIGURATION_NAME;
            pwsSubnetMask = DHCP_IPAUTOCONFIGURATION_SUBNET;
            break;

        default:
            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("Invalid IP Address Type <%x>\n", IPAddressType));
            return STATUS_INVALID_ADDRESS;
    }

    // Extract the Adapter Guid from the BindDevice name
    // pucBindDevice:   \Device\TCPIP_<AdapterGuid>
    // Find the last back slash in the path name to the bind device
    NbtFindLastSlash (pucBindDevice, &pwsAdapterGuid, &Len);
    if (pwsAdapterGuid)
    {
        //
        // Now, search the string to find the first underscore in "TCPIP_"
        //
        Len = wcslen(pwsAdapterGuid);
        for(i=0; i<Len; i++)
        {
            if (pwsAdapterGuid[i] == *pwsUnderScore)
            {
                // want ptr to point at character after the slash
                pwsAdapterGuid = &pwsAdapterGuid[i+1];
                break;
            }
        }

        //
        // If we found the underscore, then we have found the Guid!
        //
        if (i < Len-1)
        {
            Status = STATUS_SUCCESS;
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        //
        // We could not find the Guid!
        //
        return Status;
    }

    // Initialize the Registry key name
    // Get the total length of the Registry key to open (+1 for unicode null)
    Len =  NbtConfig.pRegistry.MaximumLength
         + (wcslen(pwsTcpParams) + wcslen(pwsAdapterGuid) + 1) * sizeof(WCHAR);
    pBuffer = NbtAllocMem (Len, NBT_TAG2('32'));
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Path.Buffer = pBuffer;
    Path.MaximumLength = (USHORT)Len;
    Path.Length = 0;

    RtlCopyUnicodeString(&Path, &NbtConfig.pRegistry);  // \REGISTRY\Machine\System\ControlSet\Services\NetBT
    NbtFindLastSlash(&Path, &pwsLastSlash, &Len);       // \REGISTRY\Machine\System\ControlSet\Services
    Path.Length = (USHORT)Len;
    *pwsLastSlash = UNICODE_NULL;

    RtlAppendUnicodeToString(&Path, pwsTcpParams);      // ...Tcpip\Parameters\Interfaces
    RtlAppendUnicodeToString(&Path, pwsAdapterGuid);    // ......AdapterGuid

    //
    // Open the registry.
    //
    InitializeObjectAttributes (&TmpObjectAttributes,
                                &Path,                                      // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NULL,                                       // root
                                NULL);                                      // security descriptor

    Status = ZwCreateKey (&TcpGuidHandle,
                          KEY_READ,          // We don't need to write any values
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    // We are done with the Path buffer, so free it
    CTEMemFree(pBuffer);

    if (!NT_SUCCESS(Status))
    {
        KdPrint(("Nbt.GetIPFromRegistry: Error, ZwCreateKey <%x>\n", Status));
        return STATUS_UNSUCCESSFUL;
    }

    Status = STATUS_INVALID_ADDRESS;
    *pNumIpAddresses = 0;
    if (NT_SUCCESS (GetIpAddressesList(TcpGuidHandle,
                                       pwsIpAddressName,
                                       MaxIpAddresses,
                                       pIpAddresses,
                                       pNumIpAddresses)))
    {
        //
        // DHCP may put a 0 Ip address in the registry - we don't want to
        // set the address under these conditions.
        //
        if ((*pNumIpAddresses) && (*pIpAddresses))
        {
            i = 0;
            if (NT_SUCCESS (GetIpAddressesList(TcpGuidHandle,
                                               pwsSubnetMask,
                                               1,
                                               pSubnetMask,
                                               &i)))
            {
                Status = STATUS_SUCCESS;
            }
        }
    }

    ZwClose (TcpGuidHandle);

    return Status;
} // GetIPFromRegistry


//----------------------------------------------------------------------------
NTSTATUS
NbtOpenRegistry(
    IN HANDLE       NbConfigHandle,
    IN PWSTR        String,
    OUT PHANDLE     pHandle
    )

/*++

Routine Description:

    This routine is called by Nbt to open the registry. If the registry
    tree for Nbt exists, then it opens it and returns TRUE. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns FALSE.


Arguments:

    NbConfigHandle  - this is the root handle which String is relative to
    String          - the name of the key to open below the root handle
    pHandle         - returns the handle to the String key.

Return Value:

    The status of the request.

--*/
{

    NTSTATUS        Status;
    UNICODE_STRING  KeyName;
    OBJECT_ATTRIBUTES TmpObjectAttributes;

    CTEPagedCode();

    //
    // Open the Nbt key.
    //
    RtlInitUnicodeString (&KeyName, String);

    InitializeObjectAttributes (&TmpObjectAttributes,
                                &KeyName,                                   // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NbConfigHandle,                             // root
                                NULL);                                      // security descriptor

    Status = ZwOpenKey (pHandle, KEY_READ, &TmpObjectAttributes);

    return Status;
}   /* NbOpenRegistry */


NTSTATUS
NbtParseMultiSzEntries(
    IN  PWSTR       StartBindValue,
    IN  PWSTR       EndBindValue,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,
    OUT ULONG       *pNumDevices
    )
{
    USHORT                      ConfigBindings = 0;
    NTSTATUS                    status = STATUS_SUCCESS;

    CTEPagedCode();

    try {
        while ((StartBindValue < EndBindValue) && (*StartBindValue != 0)) {
            if (ConfigBindings >= MaxBindings) {
                status = STATUS_BUFFER_OVERFLOW;
                break;
            }

            // this sets the buffer ptr in Names to point to CurBindValue, so
            // this value must be real memory and not stack, hence the need
            // to allocate memory above...
            RtlInitUnicodeString (&pDevices->Names[ConfigBindings], (PCWSTR)StartBindValue);
            ++ConfigBindings;

            //
            // Now advance the "Bind" value.
            //
            // wcslen => wide character string length for a unicode string
            StartBindValue += wcslen((PCWSTR)StartBindValue) + 1;
        }

        *pNumDevices = ConfigBindings;
        return (status);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrint (("Nbt.NbtParseMultiSzEntries: Exception <0x%x>\n", GetExceptionCode()));
        for (ConfigBindings = 0; ConfigBindings < MaxBindings; ConfigBindings++) {
            pDevices->Names[ConfigBindings].Buffer = NULL;
            pDevices->Names[ConfigBindings].Length = pDevices->Names[ConfigBindings].MaximumLength = 0;
        }
        *pNumDevices = 0;
        return STATUS_ACCESS_VIOLATION;
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NbtReadLinkageInformation(
    IN  PWSTR       pName,
    IN  HANDLE      LinkageHandle,
    IN  ULONG       MaxBindings,
    OUT tDEVICES    *pDevices,      // place to put read in config data
    OUT ULONG       *pNumDevices
    )

/*++

Routine Description:

    This routine is called by Nbt to read its linkage information
    from the registry. If there is none present, then ConfigData
    is filled with a list of all the adapters that are known
    to Nbt.

Arguments:

    RegistryHandle - A pointer to the open registry.

Return Value:

    Status

--*/

{
    NTSTATUS                    RegistryStatus;
    UNICODE_STRING              BindString;
    ULONG                       BytesWritten = 0;
    PKEY_VALUE_FULL_INFORMATION RegistryData;

    CTEPagedCode();

    pDevices->RegistryData = NULL;
    RtlInitUnicodeString (&BindString, pName); // copy "Bind" or "Export" into the unicode string

    //
    // Determine how many bytes we need to allocate for the Read buffer
    RegistryStatus = ZwQueryValueKey (LinkageHandle,
                                      &BindString,               // string to retrieve
                                      KeyValueFullInformation,
                                      NULL,
                                      0,
                                      &BytesWritten);            // # of bytes to read

    if ((RegistryStatus != STATUS_BUFFER_TOO_SMALL) ||
        (BytesWritten == 0))
    {
        return STATUS_ILL_FORMED_SERVICE_ENTRY;
    }

    if (!(RegistryData = (PKEY_VALUE_FULL_INFORMATION) NbtAllocMem (BytesWritten, NBT_TAG2('33'))))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RegistryStatus = ZwQueryValueKey (LinkageHandle,
                                      &BindString,                      // string to retrieve
                                      KeyValueFullInformation,
                                      (PVOID) RegistryData,             // returned info
                                      BytesWritten,
                                      &BytesWritten);                   // # of bytes valid data

    if (!NT_SUCCESS(RegistryStatus) ||
        (RegistryStatus == STATUS_BUFFER_OVERFLOW))
    {
        CTEMemFree(RegistryData);
        return RegistryStatus;
    }

    if (BytesWritten == 0)
    {
        CTEMemFree(RegistryData);
        return STATUS_ILL_FORMED_SERVICE_ENTRY;
    }

    pDevices->RegistryData = RegistryData;
    NbtParseMultiSzEntries ((PWCHAR)((PUCHAR)RegistryData+RegistryData->DataOffset),
                            (PWSTR) ((PUCHAR)RegistryData+RegistryData->DataOffset+RegistryData->DataLength),
                            MaxBindings,
                            pDevices,
                            pNumDevices);

    return STATUS_SUCCESS;

}   /* NbtReadLinkageInformation */

//----------------------------------------------------------------------------
ULONG
NbtReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    )

/*++

Routine Description:

    This routine is called by Nbt to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    static ULONG InformationBuffer[60];
    PKEY_VALUE_FULL_INFORMATION Information =
        (PKEY_VALUE_FULL_INFORMATION)InformationBuffer;
    UNICODE_STRING ValueKeyName;
    ULONG       InformationLength;
    ULONG       ReturnValue=DefaultValue;
    NTSTATUS    Status;
    ULONG       Count=2;
    PWSTR       Dhcp = L"Dhcp";
    BOOLEAN     FreeString = FALSE;

    CTEPagedCode();
    RtlInitUnicodeString (&ValueKeyName, ValueName);

    while (Count--)
    {

        Status = ZwQueryValueKey(
                     ParametersHandle,
                     &ValueKeyName,
                     KeyValueFullInformation,
                     (PVOID)Information,
                     sizeof (InformationBuffer),
                     &InformationLength);


        if ((Status == STATUS_SUCCESS) && (Information->DataLength == sizeof(ULONG)))
        {

            RtlMoveMemory(
                (PVOID)&ReturnValue,
                ((PUCHAR)Information) + Information->DataOffset,
                sizeof(ULONG));

            if (ReturnValue < MinimumValue)
            {
                ReturnValue = MinimumValue;
            }

        }
        else
        {
            //
            // try to read the Dhcp key instead if the first read failed.
            //
            Status = STATUS_SUCCESS;
            if (Count)
            {
                Status = NbtAppendString(Dhcp,ValueName,&ValueKeyName);
            }

            if (!NT_SUCCESS(Status))
            {
                Count = 0;
                ReturnValue = DefaultValue;
            }
            else
                FreeString = TRUE;


        }
    } // of while

    // nbt append string allocates memory.
    if (FreeString)
    {
        CTEMemFree(ValueKeyName.Buffer);

    }
    return ReturnValue;

}   /* NbtReadSingleParameter */


//----------------------------------------------------------------------------
NTSTATUS
OpenAndReadElement(
    IN  PUNICODE_STRING pucRootPath,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    )
/*++

Routine Description:

    This routine is called by Nbt to read in the Ip address appearing in the
    registry at the path pucRootPath, with a key of pwsKeyName

Arguments:
    pucRootPath - the registry path to the key to read
    pwsKeyName  - the key to open (i.e. Tcpip)
    pwsValueName- the name of the value to read (i.e. IPAddress)

Return Value:

    pucString - the string returns the string read from the registry

--*/

{

    NTSTATUS        Status;
    HANDLE          hRootKey;
    OBJECT_ATTRIBUTES TmpObjectAttributes;

    CTEPagedCode();

    InitializeObjectAttributes (&TmpObjectAttributes,
                                pucRootPath,                                // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                NULL,                                       // root
                                NULL);                                      // security descriptor

    Status = ZwOpenKey (&hRootKey, KEY_READ, &TmpObjectAttributes);
    if (!NT_SUCCESS(Status))
    {
        return STATUS_UNSUCCESSFUL;
    }

    Status = ReadElement(hRootKey,pwsValueName,pucString);

    ZwClose (hRootKey);

    return(Status);
}


//----------------------------------------------------------------------------
NTSTATUS
ReadElement(
    IN  HANDLE          HandleToKey,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    )
/*++

Routine Description:

    This routine is will read a string value given by pwsValueName, under a
    given Key (which must be open) - given by HandleToKey. This routine
    allocates memory for the buffer in the returned pucString, so the caller
    must deallocate that.

Arguments:

    pwsValueName- the name of the value to read (i.e. IPAddress)

Return Value:

    pucString - the string returns the string read from the registry

--*/

{
    ULONG           ReadStorage[150];   // 600 bytes
    ULONG           BytesRead;
    NTSTATUS        Status;
    PWSTR           pwsSrcString;
    PKEY_VALUE_FULL_INFORMATION ReadValue = (PKEY_VALUE_FULL_INFORMATION)ReadStorage;

    CTEPagedCode();

    // now put the name of the value to read into a unicode string
    RtlInitUnicodeString(pucString,pwsValueName);

    // this read the value of IPAddress under the key opened above
    Status = ZwQueryValueKey(
                         HandleToKey,
                         pucString,               // string to retrieve
                         KeyValueFullInformation,
                         (PVOID)ReadValue,                 // returned info
                         sizeof(ReadStorage),
                         &BytesRead               // # of bytes returned
                         );

    if ( Status == STATUS_BUFFER_OVERFLOW )
    {
        ReadValue = (PKEY_VALUE_FULL_INFORMATION) NbtAllocMem (BytesRead, NBT_TAG2('35'));
        if (ReadValue == NULL)
        {
            IF_DBG(NBT_DEBUG_NTUTIL)
                KdPrint(("ReadElement: failed to allocate %d bytes for element\n",BytesRead));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ReadElement_Return;
        }
        Status = ZwQueryValueKey(
                             HandleToKey,
                             pucString,               // string to retrieve
                             KeyValueFullInformation,
                             (PVOID)ReadValue,                 // returned info
                             BytesRead,
                             &BytesRead               // # of bytes returned
                             );
    }
    if (!NT_SUCCESS(Status))
    {
        IF_DBG(NBT_DEBUG_NTUTIL)
        KdPrint(("failed to Query Value Status = %X\n",Status));
        goto ReadElement_Return;
    }

    if ( BytesRead == 0 )
    {
        Status = STATUS_ILL_FORMED_SERVICE_ENTRY;
        goto ReadElement_Return;
    }
    else
    if (ReadValue->DataLength == 0)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto ReadElement_Return;
    }


    // create the pucString and copy the data returned to it
    // assumes that the ReadValue string ends in a UNICODE_NULL
    //bStatus = RtlCreateUnicodeString(pucString,pwSrcString);
    pwsSrcString = (PWSTR)NbtAllocMem ((USHORT)ReadValue->DataLength, NBT_TAG2('36'));
    if (!pwsSrcString)
    {
        ASSERTMSG((PVOID)pwsSrcString,
                    (PCHAR)"Unable to allocate memory for a Unicode string");
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        // move the read in data from the stack to the memory allocated
        // from the nonpaged pool
        RtlMoveMemory(
            (PVOID)pwsSrcString,
            ((PUCHAR)ReadValue) + ReadValue->DataOffset,
            ReadValue->DataLength);

        RtlInitUnicodeString(pucString,pwsSrcString);
        // if there isn't a null on the end of the pwsSrcString, then
        // it will not work correctly. - a null string comes out with a
        // length of 1!! since the null is counted therefore use
        // rtlinitunicode string afterall.
 //       pucString->MaximumLength = ReadValue->DataLength;
 //       pucString->Length = ReadValue->DataLength;
 //       pucString->Buffer = pwsSrcString;
    }

ReadElement_Return:

    if ((ReadValue != (PKEY_VALUE_FULL_INFORMATION)ReadStorage)
        && (ReadValue != NULL))
    {
        CTEMemFree(ReadValue);
    }

    return(Status);
}

//----------------------------------------------------------------------------
NTSTATUS
NTGetLmHostPath(
    OUT PUCHAR *ppPath
    )
/*++

Routine Description:

    This routine will read the DataBasePath from under
     ...\tcpip\parameters\databasepath

Arguments:

    pPath - ptr to a buffer containing the path name.

Return Value:


--*/

{
    NTSTATUS        status;
    UNICODE_STRING  ucDataBase;
    STRING          StringPath;
    STRING          LmhostsString;
    ULONG           StringMax;
    PWSTR           LmHosts = L"lmhosts";
    PWSTR           TcpIpParams = L"TcpIp\\Parameters";
    PWSTR           TcpParams = L"Tcp\\Parameters";
    PWSTR           DataBase = L"DataBasePath";
    PCHAR           ascLmhosts="\\lmhosts";
    PCHAR           pBuffer;

    CTEPagedCode();

    *ppPath = NULL;
    status = ReadStringRelative(&NbtConfig.pRegistry,
                                TcpIpParams,
                                DataBase,
                                &ucDataBase);

    if (!NT_SUCCESS(status))
    {
        // check for the new TCP stack which a slightly different registry
        // key name.
        //
        status = ReadStringRelative(&NbtConfig.pRegistry,
                                    TcpParams,
                                    DataBase,
                                    &ucDataBase);
        if (!NT_SUCCESS(status))
        {
            return STATUS_UNSUCCESSFUL;
        }
    }


    StringMax = ucDataBase.Length/sizeof(WCHAR) + strlen(ascLmhosts) + 1;
    pBuffer = NbtAllocMem (StringMax, NBT_TAG2('37'));
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    StringPath.Buffer = (PCHAR)pBuffer;
    StringPath.MaximumLength = (USHORT)StringMax;
    StringPath.Length = (USHORT)StringMax;

    // convert to ascii from unicode
    status = RtlUnicodeStringToAnsiString(&StringPath, &ucDataBase, FALSE);
    CTEMemFree(ucDataBase.Buffer);  // this memory was allocated in OpenAndReadElement

    if (!NT_SUCCESS(status))
    {
        CTEMemFree(StringPath.Buffer);
        return(STATUS_UNSUCCESSFUL);
    }

    // now put the "\lmhosts" name on the end of the string
    //
    RtlInitString(&LmhostsString, ascLmhosts);
    status = RtlAppendStringToString(&StringPath, &LmhostsString);
    if (NT_SUCCESS(status))
    {
        //
        // is the first part of the directory "%SystemRoot%" ?
        //
        // If so, it must be changed to "\\SystemRoot\\".
        //
        //          0123456789 123456789 1
        //          %SystemRoot%\somewhere
        //
        //
        if (strncmp(StringPath.Buffer, "%SystemRoot%", 12) == 0)
        {

            StringPath.Buffer[0]  = '\\';
            StringPath.Buffer[11] = '\\';
            if (StringPath.Buffer[12] == '\\')
            {
                ASSERT(StringPath.Length >= 13);

                if (StringPath.Length > 13)
                {
                    // overlapped copy
                    RtlMoveMemory (&(StringPath.Buffer[12]),        // Destination
                                   &(StringPath.Buffer[13]),        // Source
                                   (ULONG) StringPath.Length - 13); // Length

                    StringPath.Buffer[StringPath.Length - 1] = (CHAR) NULL;
                }

                StringPath.Length--;
            }
        }

        *ppPath = (PCHAR)StringPath.Buffer;
    }
    else
    {
        CTEMemFree(StringPath.Buffer);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
ReadStringRelative(
    IN  PUNICODE_STRING pRegistryPath,
    IN  PWSTR           pRelativePath,
    IN  PWSTR           pValueName,
    OUT PUNICODE_STRING pOutString
    )

/*++

Routine Description:

    This routine reads a string from a registry key parallel to the
    Netbt key - such as ..\tcpip\parameters\database

Arguments:

    pRegistryPath = ptr to the Netbt Registry path
    pRelativePath = path to value relative to same root as nbt.
    pValueName    = value to read



Return Value:

    The length of the path up to and including the last slash and a ptr
    to the first character of the last element of the string.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  RegistryPath;
    UNICODE_STRING  RelativePath;
    ULONG           StringMax;
    PVOID           pBuffer;
    PWSTR           pLastElement;
    ULONG           Length;

    CTEPagedCode();

    StringMax = (pRegistryPath->MaximumLength + wcslen(pRelativePath)*sizeof(WCHAR)+2);
    //
    // allocate some memory for the registry path so that it is large enough
    // to append a string on to, for the relative key to be read
    //
    if (!(pBuffer = NbtAllocMem (StringMax, NBT_TAG2('38'))))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RegistryPath.MaximumLength = (USHORT)StringMax;
    RegistryPath.Buffer = pBuffer;
    RtlCopyUnicodeString(&RegistryPath,pRegistryPath);

    //
    // find the last backslash and truncate the string
    NbtFindLastSlash(&RegistryPath,&pLastElement,&Length);
    RegistryPath.Length = (USHORT)Length;

    if (pLastElement)
    {
        *pLastElement = UNICODE_NULL;
        RtlInitUnicodeString(&RelativePath,pRelativePath);
        status = RtlAppendUnicodeStringToString(&RegistryPath,&RelativePath);

        if (NT_SUCCESS(status))
        {
            status = OpenAndReadElement(&RegistryPath,pValueName,pOutString);

            if (NT_SUCCESS(status))
            {
                // free the registry path
                //
                CTEMemFree(pBuffer);
                return(status);
            }
        }
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    CTEMemFree(pBuffer);
    return(status);
}
//----------------------------------------------------------------------------
VOID
NbtFindLastSlash(
    IN  PUNICODE_STRING pucRegistryPath,
    OUT PWSTR           *ppucLastElement,
    IN  int             *piLength
    )

/*++

Routine Description:

    This routine is called by Nbt to find the last slash in a registry
    path name.

Arguments:


Return Value:

    The length of the path up to and including the last slash and a ptr
    to the first character of the last element of the string.

--*/

{
    int             i;
    PWSTR           pwsSlash = L"\\";
    int             iStart;

    CTEPagedCode();

    // search starting at the end of the string for the last back slash
    iStart = wcslen(pucRegistryPath->Buffer)-1;
    for(i=iStart;i>=0 ;i-- )
    {
        if (pucRegistryPath->Buffer[i] == *pwsSlash)
        {
            if (i==pucRegistryPath->Length-1)
            {
                // name ends a back slash... this is an error
                break;
            }
            // increase one to allow for the slash
            *piLength = (i+1)*sizeof(WCHAR);
            if (ppucLastElement != NULL)
            {
                // want ptr to point at character after the slash
                *ppucLastElement = &pucRegistryPath->Buffer[i+1];
            }
            return;
        }
    }

    // null the pointer if one is passed in
    if (ppucLastElement != NULL)
    {
        *ppucLastElement = NULL;
    }
    *piLength = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\tdihndlr.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Tdihndlr.c

Abstract:


    This file contains the TDI handlers that are setup for Connects,
    Receives, Disconnects, and Errors on various objects such as connections
    and udp endpoints .

    This file represents the inbound TDI interface on the Bottom of NBT.  Therefore
    the code basically decodes the incoming information and passes it to
    a non-Os specific routine to do what it can.  Upon return from that
    routine additional Os specific work may need to be done.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

    Will Lees (wlees)    Sep 11, 1997
        Added support for message-only devices

--*/

#include "precomp.h"
#include "ctemacro.h"
#include "tdihndlr.tmh"

// this macro checks that the types field is always zero in the Session
// Pdu
//
#if DBG
#define CHECK_PDU( _Size,_Offset) \
    if (_Size > 1)              \
        ASSERT(((PUCHAR)pTsdu)[_Offset] == 0)
#else
#define CHECK_PDU( _Size,_Offset )
#endif

#if DBG
UCHAR   pLocBuff[256];
UCHAR   CurrLoc;

ULONG   R1;
ULONG   R2;
ULONG   R3;
ULONG   R4;

ULONG   C1;
ULONG   C2;
ULONG   C3;
ULONG   C4;

ULONG   HitCounter;

#define INCR_COUNT(_Count) _Count++
#else
#define INCR_COUNT(_Count)
#endif


//
// This ntohl swaps just three bytes, since the 4th byte could be a session
// keep alive message type.
//
__inline long
myntohl(long x)
{
    return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L));
}

NTSTATUS
LessThan4BytesRcvd(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    OUT PVOID                *ppIrp
    );
NTSTATUS
ClientTookSomeOfTheData(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    IN  ULONG                BytesTaken,
    IN  ULONG                PduSize
    );
NTSTATUS
MoreDataRcvdThanNeeded(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    );
NTSTATUS
NotEnoughDataYet(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  ULONG                PduSize,
    OUT PVOID                *ppIrp
    );
NTSTATUS
ProcessIrp(
    IN tLOWERCONNECTION *pLowerConn,
    IN PIRP     pIrp,
    IN PVOID    pBuffer,
    IN PULONG   BytesTaken,
    IN ULONG    BytesIndicted,
    IN ULONG    BytesAvailable
    );

NTSTATUS
NtBuildIndicateForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    );

NTSTATUS
AcceptCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

VOID
DpcNextOutOfRsrcKill(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );

VOID
DpcGetRestOfIndication(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );

NTSTATUS
ClientBufferOverFlow(
    IN tLOWERCONNECTION     *pLowerConn,
    IN tCONNECTELE          *pConnEle,
    IN PIRP                 pIrp,
    IN ULONG                BytesRcvd
    );
VOID
DpcHandleNewSessionPdu (
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    );
VOID
HandleNewSessionPdu (
    IN  tLOWERCONNECTION *pLowerConn,
    IN  ULONG           Offset,
    IN  ULONG           ToGet
    );
NTSTATUS
NewSessionCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );
NTSTATUS
BuildIrpForNewSessionInIndication (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  PIRP                pIrpIn,
    IN  ULONG               BytesAvailable,
    IN  ULONG               RemainingPdu,
    OUT PIRP                *ppIrp
    );
VOID
TrackIndicatedBytes(
    IN ULONG            BytesIndicated,
    IN ULONG            BytesTaken,
    IN tCONNECTELE      *pConnEle
    );

__inline
VOID
DerefLowerConnFast (
    IN tLOWERCONNECTION *pLowerConn,
    IN tCONNECTELE      *pConnEle,
    IN CTELockHandle    OldIrq
    );

NTSTATUS
CopyDataandIndicate(
    IN PVOID                ReceiveEventContext,
    IN PVOID                ConnectionContext,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    );

VOID
SumMdlLengths (
    IN PMDL         pMdl,
    IN ULONG        BytesAvailable,
    IN tCONNECTELE  *pConnectEle
    );



NTSTATUS
RsrcKillCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

VOID
NbtCancelFillIrpRoutine(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );

NTSTATUS
NameSrvCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef _NETBIOSLESS
NTSTATUS
PerformInboundProcessing(
    tDEVICECONTEXT *pDeviceContext,
    tLOWERCONNECTION *pLowerConn,
    PTA_IP_ADDRESS pIpAddress
    );
#endif

//----------------------------------------------------------------------------
__inline
NTSTATUS
Normal(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    ASSERTMSG("Should not execute this procedure",0);
    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
LessThan4BytesRcvd(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    there isn't 128 bytes yet or a whole pdu.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE  *pConnectEle;
    NTSTATUS     status;

    // for short indications less than 4 bytes we can't determine
    // the pdu size so just get the header first then get the
    // whole pdu next.

    status = NtBuildIrpForReceive(pLowerConn,
                                  sizeof(tSESSIONHDR),
                                  (PVOID *)ppIrp);

    pConnectEle = pLowerConn->pUpperConnection;

    pConnectEle->BytesInXport = BytesAvailable;

    if (!NT_SUCCESS(status))
    {
        CTESpinFreeAtDpc(pLowerConn);
        OutOfRsrcKill(pLowerConn);
        CTESpinLockAtDpc(pLowerConn);
        return( STATUS_DATA_NOT_ACCEPTED);
    }
    //
    // set the irp mdl length to size of session hdr so that
    // we don't get more than one session pdu into the buffer
    //
    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

    *BytesTaken = 0;
    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:Switching to Ind Buff(<4 bytes), Avail = %X\n",
            BytesAvailable));

    PUSH_LOCATION(0);
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//----------------------------------------------------------------------------
NTSTATUS
ClientTookSomeOfTheData(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    IN  ULONG                BytesTaken,
    IN  ULONG                PduSize
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    the client has not taken all of the data indicated to it.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE  *pConnectEle;

    //
    // took some of the data, so keep track of the
    // rest of the data left here by going to the PARTIALRCV
    // state.
    //
    PUSH_LOCATION(0x5);

    SET_STATERCV_LOWER(pLowerConn, PARTIAL_RCV, PartialRcv);

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt.ClientTookSomeOfTheData: Switch to Partial Rcv Indicated=%X, PduSize=%X\n",
            BytesIndicated,PduSize-4));

    // Note: PduSize must include the 4 byte session header for this to
    // work correctly.
    //
    pConnectEle = pLowerConn->pUpperConnection;
    //
    // We always indicate the whole Pdu size to the client, so the amount
    // indicated is that minus what was taken - typically the 4 byte
    // session hdr
    //
    pConnectEle->ReceiveIndicated = PduSize - BytesTaken;

    // amount left in the transport...
    pConnectEle->BytesInXport = BytesAvailable - BytesTaken;

    // need to return this status since we took the 4 bytes
    // session header at least, even if the client took none.
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
MoreDataRcvdThanNeeded(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    there isn't 128 bytes yet or a whole pdu.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE  *pConnectEle;
    ULONG        Length;
    ULONG        Remaining;
    ULONG        PduSize;
    NTSTATUS     status;
    tSESSIONHDR  UNALIGNED *pSessionHdr;


    PUSH_LOCATION(0x6);
    //
    // there is too much data, so keep track of the
    // fact that there is data left in the transport
    // and get it with the indicate buffer
    //
    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

    ASSERT(pLowerConn->BytesInIndicate == 0);
#if DBG
    if (pLowerConn->BytesInIndicate)
    {
        KdPrint(("Nbt:Bytes in indicate should be ZERO, but are = %X\n",
            pLowerConn->BytesInIndicate));
    }
#endif
    pConnectEle = pLowerConn->pUpperConnection;
    pConnectEle->BytesInXport = BytesAvailable - *BytesTaken;

    //
    // for short indications less than 4 bytes we can't determine
    // the pdu size so just get the header first then get the
    // whole pdu next.
    //
    Remaining = BytesIndicated - *BytesTaken;
    if ((LONG) Remaining < (LONG) sizeof(tSESSIONHDR))
    {
        status = NtBuildIrpForReceive(pLowerConn,sizeof(tSESSIONHDR),(PVOID *)ppIrp);
        if (!NT_SUCCESS(status))
        {
            // this is a serious error - we must
            // kill of the connection and let the
            // redirector restart it
            KdPrint(("Nbt:Unable to get an Irp for RCv - Closing Connection!! %X\n",pLowerConn));
            CTESpinFreeAtDpc(pLowerConn);

            OutOfRsrcKill(pLowerConn);
            CTESpinLockAtDpc(pLowerConn);

            return(STATUS_DATA_NOT_ACCEPTED);
        }
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:< 4 Bytes,BytesTaken=%X,Avail=%X,Ind=%X,Remain=%X\n",
            *BytesTaken,BytesAvailable,BytesIndicated,
            Remaining));

        // DEBUG
        CTEZeroMemory(MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl),
                        NBT_INDICATE_BUFFER_SIZE);

        PUSH_LOCATION(0x7);
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        // if we get to here there are enough bytes left to determine
        // the next pdu size...so we can determine how much
        // data to get for the indicate buffer
        //
        pSessionHdr = (tSESSIONHDR UNALIGNED *)((PUCHAR)pTsdu + *BytesTaken);

        PduSize = myntohl(pSessionHdr->UlongLength) + sizeof(tSESSIONHDR);


        Length = (PduSize > NBT_INDICATE_BUFFER_SIZE) ?
                         NBT_INDICATE_BUFFER_SIZE : PduSize;

        //
        // The NewSessionCompletion routine recalculates
        // what is left in the transport  when the
        // irp completes
        //
        status = NtBuildIrpForReceive(pLowerConn,Length,(PVOID *)ppIrp);
        if (!NT_SUCCESS(status))
        {
            // this is a serious error - we must
            // kill of the connection and let the
            // redirector restart it
            KdPrint(("Nbt:Unable to get an Irp for RCV(2) - Closing Connection!! %X\n",pLowerConn));
            CTESpinFreeAtDpc(pLowerConn);
            OutOfRsrcKill(pLowerConn);
            CTESpinLockAtDpc(pLowerConn);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Switch to Ind Buff, InXport = %X, Pdusize=%X,ToGet=%X\n",
                pConnectEle->BytesInXport,PduSize-4,Length));

    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//----------------------------------------------------------------------------
NTSTATUS
NotEnoughDataYet(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  ULONG                PduSize,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles the case when data has arrived on a connection but
    there isn't 128 bytes yet or a whole pdu.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    tCONNECTELE         *pConnectEle;
    ULONG               Length;

    PUSH_LOCATION(0x9);
    //
    // not enough data indicated, so use the indicate buffer
    //
    Length = (PduSize > NBT_INDICATE_BUFFER_SIZE) ?
                     NBT_INDICATE_BUFFER_SIZE : PduSize;

    status = NtBuildIrpForReceive(pLowerConn,Length,(PVOID *)ppIrp);
    if (!NT_SUCCESS(status))
    {
        CTESpinFreeAtDpc(pLowerConn);
        OutOfRsrcKill(pLowerConn);
        CTESpinLockAtDpc(pLowerConn);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    *BytesTaken = 0;

    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

    pConnectEle = pLowerConn->pUpperConnection;
    pConnectEle->BytesInXport = BytesAvailable;

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:Not Enough data indicated in Tdihndlr, using indic. buffer Indicated = %X,Avail=%X,PduSize= %X\n",
            BytesIndicated, BytesAvailable,PduSize-4));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

//----------------------------------------------------------------------------
NTSTATUS
FillIrp(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    ASSERTMSG("Should not execute this procedure",0);
    return(STATUS_SUCCESS);
    // do nothing

}
//----------------------------------------------------------------------------
NTSTATUS
IndicateBuffer(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine handles reception of data while in the IndicateBuffer state.
    In this state the indicate buffer is receiveing data until at least
    128 bytes have been receive, or a whole pdu has been received.


Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE         *pConnectEle;
    NTSTATUS            status;
    ULONG               PduSize;
    ULONG               ToCopy;
    PVOID               pIndicateBuffer;
    ULONG               Taken;

    //
    // there is data in the indicate buffer and we got a new
    // indication, so copy some or all of the indication to the
    // indicate buffer
    //
    PVOID       pDest;
    ULONG       RemainPdu;
    ULONG       SpaceLeft;
    ULONG       TotalBytes;
    ULONG       ToCopy1=0;

    INCR_COUNT(R3);
    PUSH_LOCATION(0xe);
    pConnectEle = pLowerConn->pUpperConnection;
    ASSERT(pLowerConn->StateRcv == INDICATE_BUFFER);
    //
    // The indicate buffer always starts with a pdu
    //
    pIndicateBuffer = MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl);

    // the location to start copying the new data into is right
    // after the existing data in the buffer
    //
    pDest = (PVOID)((PUCHAR)pIndicateBuffer + pLowerConn->BytesInIndicate);

    //
    // the session header may not be all into the indicate
    // buffer yet, so check that before getting the pdu length.
    //
    if (pLowerConn->BytesInIndicate < sizeof(tSESSIONHDR))
    {
        PUSH_LOCATION(0xe);
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Too Few in Indicate Buff, Adding InIndicate %X\n",
            pLowerConn->BytesInIndicate));

        ToCopy1 = sizeof(tSESSIONHDR) - pLowerConn->BytesInIndicate;
        if (ToCopy1 > BytesIndicated)
        {
            ToCopy1 = BytesIndicated;
        }
        CTEMemCopy(pDest,pTsdu,ToCopy1);

        pDest = (PVOID)((PUCHAR)pDest + ToCopy1);
        pTsdu = (PVOID)((PUCHAR)pTsdu + ToCopy1);

        pLowerConn->BytesInIndicate += (USHORT)ToCopy1;

        *BytesTaken = ToCopy1;
    }

    // now check again, and pass down an irp to get more data if necessary
    //
    if (pLowerConn->BytesInIndicate < sizeof(tSESSIONHDR))
    {
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:< 4 Bytes in IndicBuff, BytesinInd= %X, BytesIndicated=%x\n",
                    pLowerConn->BytesInIndicate,BytesIndicated));

        PUSH_LOCATION(0xF);

        //
        // the data left in the transport is what was Available
        // minus what we just copied to the indicate buffer
        //
        pConnectEle->BytesInXport = BytesAvailable - ToCopy1;

        if (pConnectEle->BytesInXport)
        {
            PUSH_LOCATION(0x10);
            //
            // pass the indicate buffer down to get some more data
            // to fill out to the end of the session hdr
            //
            NtBuildIndicateForReceive(pLowerConn,
                                      sizeof(tSESSIONHDR)-pLowerConn->BytesInIndicate,
                                      (PVOID *)ppIrp);

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:INDIC_BUF...need more data for hdr Avail= %X, InXport = %X\n",
                        BytesAvailable,pConnectEle->BytesInXport,pLowerConn));

            return(STATUS_MORE_PROCESSING_REQUIRED);
        }

        // if we get to here there isn't 4 bytes in the indicate buffer and
        // there is no more data in the Transport, so just wait for the next
        // indication.
        //
        return(STATUS_SUCCESS);
    }

    PduSize = myntohl(((tSESSIONHDR *)pIndicateBuffer)->UlongLength)
                        + sizeof(tSESSIONHDR);

    // copy up to 132 bytes or the whole pdu to the indicate buffer
    //
    RemainPdu = PduSize - pLowerConn->BytesInIndicate;

    SpaceLeft = NBT_INDICATE_BUFFER_SIZE - pLowerConn->BytesInIndicate;

    if (RemainPdu < SpaceLeft)
        ToCopy = RemainPdu;
    else
        ToCopy = SpaceLeft;

    if (ToCopy > (BytesIndicated-ToCopy1))
    {
        ToCopy = (BytesIndicated - ToCopy1);
    }

    //
    // Copy the indication or part of it to the indication
    // buffer
    //
    CTEMemCopy(pDest,pTsdu,ToCopy);

    pLowerConn->BytesInIndicate += (USHORT)ToCopy;

    TotalBytes = pLowerConn->BytesInIndicate;

    // the amount of data taken is the amount copied to the
    // indicate buffer
    //
    *BytesTaken = ToCopy + ToCopy1;

#if DBG
    {
        tSESSIONHDR  UNALIGNED  *pSessionHdr;
        pSessionHdr = (tSESSIONHDR UNALIGNED *)pIndicateBuffer;
        ASSERT((pSessionHdr->Type == NBT_SESSION_KEEP_ALIVE) ||
                (pSessionHdr->Type == NBT_SESSION_MESSAGE));
    }
#endif

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:INDIC_BUFF, TotalBytes= %X, InIndic=%X, Copied(0/1)= %X %X Avail %X\n",
                TotalBytes,pLowerConn->BytesInIndicate,ToCopy,ToCopy1,BytesAvailable));


    // the data left in the transport is what was Available
    // minus what we just copied to the indicate buffer
    //
    pConnectEle->BytesInXport = BytesAvailable - *BytesTaken;

    // now check if we have a whole pdu or 132 bytes, either way
    // enough to indicate to the client.
    //
    ASSERT(TotalBytes <= NBT_INDICATE_BUFFER_SIZE);

    if ((TotalBytes < NBT_INDICATE_BUFFER_SIZE) && (TotalBytes < PduSize) && (pConnectEle->BytesInXport)) {
        //
        // This could happen if BytesIndicated < BytesAvailable
        //
        ToCopy = PduSize;
        if (ToCopy > NBT_INDICATE_BUFFER_SIZE) {
            ToCopy = NBT_INDICATE_BUFFER_SIZE;
        }

        ASSERT (TotalBytes == pLowerConn->BytesInIndicate);
        NtBuildIndicateForReceive(pLowerConn, ToCopy - TotalBytes, (PVOID *)ppIrp);
#if DBG
        HitCounter++;
#endif
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    if ((TotalBytes == NBT_INDICATE_BUFFER_SIZE) ||
        (TotalBytes == PduSize))
    {

        status = CopyDataandIndicate(
                        ReceiveEventContext,
                        (PVOID)pLowerConn,
                        ReceiveFlags,
                        TotalBytes,
                        pConnectEle->BytesInXport + TotalBytes,
                        &Taken,
                        pIndicateBuffer,
                        (PIRP *)ppIrp);

    }
    else
    {

        // not enough data in the indicate buffer yet
        // NOTE: *BytesTaken should be set correctly above...
        // = ToCopy + ToCopy1;

        PUSH_LOCATION(0x11);
        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Not Enough data indicated(INDICBUFF state), Indicated = %X,PduSize= %X,InIndic=%X\n",
                BytesIndicated, PduSize, pLowerConn->BytesInIndicate));


        status = STATUS_SUCCESS;
    }
    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
PartialRcv(
    IN  PVOID                ReceiveEventContext,
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PVOID                *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    tCONNECTELE     *pConnectEle;
    //
    // the data for the client may be in the indicate buffer and
    // in this case the transport could indicate us with more data. Therefore
    // track the number of bytes available in the transport which
    // we will get when the client finally posts a buffer.
    // This state could also happen on a zero length Rcv when the
    // client does not accept the data, and later posts a rcv
    // buffer for the zero length rcv.
    //
    INCR_COUNT(R4);
    PUSH_LOCATION(0x13);
    ASSERT(pLowerConn->StateRcv == PARTIAL_RCV);
    pConnectEle = pLowerConn->pUpperConnection;

//    ASSERT(pConnectEle->BytesInXport == 0);
#if DBG
    if (pConnectEle->BytesInXport != 0)
    {
        KdPrint(("Nbt.PartialRcv: pConnectEle->BytesInXport != 0 Avail %X, InIndicate=%X,InXport %X %X\n",
                    BytesAvailable,pLowerConn->BytesInIndicate,
                    pConnectEle->BytesInXport,pLowerConn));
    }
#endif  // DBG
    pConnectEle->BytesInXport = BytesAvailable;

    IF_DBG(NBT_DEBUG_NAMESRV)
    KdPrint(("Nbt:Got Indicated while in PartialRcv state Avail %X, InIndicate=%X,InXport %X %X\n",
                BytesAvailable,pLowerConn->BytesInIndicate,
                pConnectEle->BytesInXport,pLowerConn));

    *BytesTaken = 0;
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
TdiReceiveHandler (
    IN  PVOID                ReceiveEventContext,
    IN  PVOID                ConnectionContext,
    IN  USHORT               ReceiveFlags,
    IN  ULONG                BytesIndicated,
    IN  ULONG                BytesAvailable,
    OUT PULONG               BytesTaken,
    IN  PVOID                pTsdu,
    OUT PIRP                 *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network. It calls
    a non OS specific routine to decide what to do.  That routine passes back
    either a RcvElement (buffer) or a client rcv handler to call.

Arguments:

    IN PVOID ReceiveEventContext - Context provided for this event when event set
    IN PVOID ConnectionContext  - Connection Context, (pLowerConnection)
    IN USHORT ReceiveFlags      - Flags describing the message
    IN ULONG BytesIndicated     - Number of bytes available at indication time
    IN ULONG BytesAvailable     - Number of bytes available to receive
    OUT PULONG BytesTaken       - Number of bytes consumed by redirector.
    IN PVOID pTsdu              - Data from remote machine.
    OUT PIRP *ppIrp             - I/O request packet filled in if received data


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    register tLOWERCONNECTION    *pLowerConn;
    PIRP                pIrp;
    CTELockHandle       OldIrq;
    NTSTATUS            status;
    tCONNECTELE         *pConnEle;
    ULONG               BTaken;

    *ppIrp = NULL;
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;

    // NOTE:
    // Access is synchronized through the spin lock on pLowerConn for all
    // Session related stuff.  This includes the case where the client
    // posts another Rcv Buffer in NTReceive. - so there is no need to get the
    // pConnEle Spin lock too.
    //

    CTESpinLock(pLowerConn,OldIrq);
//    pLowerConn->InRcvHandler = TRUE;
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);

    // save this on the stack in case we need to dereference it below.
    pConnEle = pLowerConn->pUpperConnection;

    // call the correct routine depending on the state of the connection
    // Normal/FillIrp/PartialRcv/IndicateBuffer/Inbound/OutBound
    //

    if ((pLowerConn->State == NBT_SESSION_UP) &&
        (pLowerConn->StateRcv == FILL_IRP))
    {
        PIO_STACK_LOCATION              pIrpSp;
        PMDL                            pNewMdl;
        PFILE_OBJECT                    pFileObject;
        ULONG                           RemainingPdu;
        PVOID                           NewAddress;
        PTDI_REQUEST_KERNEL_RECEIVE     pClientParams;
        PTDI_REQUEST_KERNEL_RECEIVE     pParams;
        KIRQL                           OldIrq2;
        ULONG                           RcvLength;


        PUSH_LOCATION(0xa);

        pIrp = pConnEle->pIrpRcv;

        if (!pIrp)
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint (("Nbt:TdiReceiveHandler:  No pIrpRcv for pConnEle=<%x>, pLowerConn=<%d>\n",
                    pConnEle, pLowerConn));
            *BytesTaken = 0;
            DerefLowerConnFast(pLowerConn,pConnEle,OldIrq);
            return (STATUS_SUCCESS);
        }

        // we are still waiting for the rest of the session pdu so
        // do not call the RcvHandlrNotOs, since we already have the buffer
        // to put this data in.
        // too much data may have arrived... i.e. part of the next session pdu..
        // so check and set the receive length accordingly
        //

        RemainingPdu = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
        RcvLength = RemainingPdu;
        //
        // try high runner case first
        //
        if (BytesAvailable <= RemainingPdu)
        {
            PUSH_LOCATION(0xb);
            //
            //  if the client buffer is too small to take all of the rest of the
            //  data, shorten the receive length and keep track of how many
            //  bytes are left in the transport. ReceiveIndicated should have
            //  been set when the irp was passed down originally.
            //
            if (BytesAvailable > pConnEle->FreeBytesInMdl)
            {
                PUSH_LOCATION(0xb);

                RcvLength = pConnEle->FreeBytesInMdl;
                pConnEle->BytesInXport = BytesAvailable - RcvLength;
            }
            if (RcvLength > pConnEle->FreeBytesInMdl) {
                ASSERT(BytesAvailable <= pConnEle->FreeBytesInMdl);
                RcvLength = pConnEle->FreeBytesInMdl;
                pConnEle->BytesInXport = 0;
            }
        }
        else
        {
            //
            // start of session pdu in the middle of the indication
            //
            PUSH_LOCATION(0xc);
            //
            // It is possible that the client buffer is too short, so check
            // for that case.
            //
            if (RemainingPdu > pConnEle->FreeBytesInMdl)
            {
                RcvLength = pConnEle->FreeBytesInMdl;
                PUSH_LOCATION(0xd);
            }
            /* Remember how much data is left in the transport
             when this irp passes through the completionrcv routine
             it will pass the indication buffer back to the transport
             to get at least 4 bytes of header information so we
             can determine the next session pdu's size before receiving
             it.  The trick is to avoid having more than one session
             pdu in the buffer at once.
            */
            pConnEle->BytesInXport = BytesAvailable - RcvLength;

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:End of FILL_IRP, found new Pdu BytesInXport=%X\n",
                        pConnEle->BytesInXport));

        }

        // if the transport has all of the data it says is available, then
        // do the copy here ( if the client buffer is large enough - checked
        // by !ReceiveIndicated)
        //
        if ((BytesAvailable == BytesIndicated) &&
            (RcvLength >= BytesIndicated) &&
            !pConnEle->ReceiveIndicated)
        {
            ULONG   BytesCopied;
            ULONG   TotalBytes;

            PUSH_LOCATION(0x70);

            if (RcvLength > BytesIndicated)
                RcvLength = BytesIndicated;

            status = TdiCopyBufferToMdl(
                                    pTsdu,
                                    0,
                                    RcvLength,
                                    pConnEle->pNextMdl,
                                    pConnEle->OffsetFromStart,
                                    &BytesCopied);

            //
            // if the irp is not yet full, or the free bytes have not
            // been exhausted by this copy, then adjust some counts and return
            // quickly, otherwise call the completion rcv routine as if the
            // irp has completed normally from the transport -
            //
            TotalBytes = pConnEle->BytesRcvd + BytesCopied;

            if ((TotalBytes < pConnEle->TotalPcktLen) &&
                (BytesCopied < pConnEle->FreeBytesInMdl))
            {
                PMDL    pMdl;

                //
                // take the short cut and do not call completion rcv since we
                // are still waiting for more data
                //
                PUSH_LOCATION(0x81);
                pConnEle->BytesRcvd      += BytesCopied;
                pConnEle->FreeBytesInMdl -= BytesCopied;

                // clean up the partial mdl.
                //
                pMdl = pConnEle->pNewMdl;
                MmPrepareMdlForReuse(pMdl);

                // set where the next rcvd data will start, by setting the pNextMdl and
                // offset from start.
                //
                pMdl = pConnEle->pNextMdl;
                if ((BytesCopied + pConnEle->OffsetFromStart) < MmGetMdlByteCount(pMdl))
                {
                    PUSH_LOCATION(0x82);
                    //
                    // All of this data will fit into the current Mdl, and
                    // the next data will start in the same Mdl (if there is more data)
                    //
                    pConnEle->OffsetFromStart  += BytesCopied;
                }
                else
                {
                    PUSH_LOCATION(0x83)
                    SumMdlLengths(pMdl,
                                  pConnEle->OffsetFromStart + BytesCopied,
                                  pConnEle);
                }
                *BytesTaken = BytesCopied;
                status = STATUS_SUCCESS;

                IF_DBG(NBT_DEBUG_FASTPATH)
                KdPrint(("I"));
                goto ExitRoutine;
            }
            else
            {
                IF_DBG(NBT_DEBUG_FASTPATH)
                KdPrint(("i"));
                CTESpinFree(pLowerConn,OldIrq);
                //
                // the values are set to this so that when Completion Rcv is
                // called it will increment the BytesRcvd by BytesCopied.
                //
                pIrp->IoStatus.Status = STATUS_SUCCESS;
                pIrp->IoStatus.Information = BytesCopied;

                //
                //   now call the irp completion routine, shorting out the io
                //   subsystem - to process the irp
                //
                status = CompletionRcv(NULL,pIrp,(PVOID)pLowerConn);
                //
                // complete the irp back to the client if required
                //
                if (status != STATUS_MORE_PROCESSING_REQUIRED)
                {
                    IoAcquireCancelSpinLock(&OldIrq2);
                    IoSetCancelRoutine(pIrp,NULL);
                    IoReleaseCancelSpinLock(OldIrq2);

                    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
                }
            }

            //
            // tell the transport we took all the data that we did take.
            // Since CompletionRcv has unlocked the spin lock and decremented
            // the refcount, return here.
            //
            *BytesTaken = BytesCopied;
            return(STATUS_SUCCESS);
        }
        else
        {
            //
            // Either BytesIndicated != BytesAvailable or the RcvBuffer
            // is too short, so make up an Irp with a partial Mdl and pass it
            // to the transport.
            //
            PUSH_LOCATION(0x71);

            NewAddress = (PVOID)((PCHAR)MmGetMdlVirtualAddress(pConnEle->pNextMdl)
                                + pConnEle->OffsetFromStart);

            /* create a partial MDL so that the new data is copied after the existing data
             in the MDL.  Use the pNextMdl field stored in the pConnEle
             that was set up during the last receive.( since at that time
             we knew the BytesAvailable then).  Without this we would have to
             traverse the list of Mdls for each receive.

             0 for length means map the rest of the buffer
            */
            pNewMdl = pConnEle->pNewMdl;

            if ((MmGetMdlByteCount(pConnEle->pNextMdl) - pConnEle->OffsetFromStart) > MAXUSHORT)
            {
                IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,MAXUSHORT);
            }
            else
            {
                IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,0);
            }
            //
            // hook the new partial mdl to the front of the MDL chain
            //
            pNewMdl->Next = pConnEle->pNextMdl->Next;

            pIrp->MdlAddress = pNewMdl;
            ASSERT(pNewMdl);

            CHECK_PTR(pConnEle);
            pConnEle->pIrpRcv = NULL;

            IoAcquireCancelSpinLock(&OldIrq2);
            IoSetCancelRoutine(pIrp,NULL);
            IoReleaseCancelSpinLock(OldIrq2);

            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

            pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

            /* this code is sped up somewhat by expanding the code here rather than calling
             the TdiBuildReceive macro

             make the next stack location the current one.  Normally IoCallDriver
             would do this but we are not going through IoCallDriver here, since the
             Irp is just passed back with RcvIndication.
            */
            ASSERT(pIrp->CurrentLocation > 1);
            IoSetNextIrpStackLocation(pIrp);
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
            pParams->ReceiveLength = RcvLength;

            pIrpSp->CompletionRoutine = CompletionRcv;
            pIrpSp->Context = (PVOID)pLowerConn;

            /* set flags so the completion routine is always invoked.
            */
            pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;
            pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            pIrpSp->MinorFunction = TDI_RECEIVE;

            pFileObject = pLowerConn->pFileObject;
            ASSERT (pFileObject->Type == IO_TYPE_FILE);
            pIrpSp->FileObject = pFileObject;
            pIrpSp->DeviceObject = IoGetRelatedDeviceObject(pFileObject);

            pParams->ReceiveFlags = pClientParams->ReceiveFlags;

            /*
              pass the Irp back to the transport
            */
            *ppIrp = (PVOID)pIrp;
            *BytesTaken = 0;

            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
    }
    else
    if ((pLowerConn->State == NBT_SESSION_UP) &&
        (pLowerConn->StateRcv == NORMAL))
    {
        ULONG               PduSize;
        UCHAR               Passit;

        INCR_COUNT(R1);
        /*
         check indication and if less than 1 pdu or 132 bytes then
         copy to the indicate buffer and go to Indic_buffer state
         The while loop allows us to indicate multiple Pdus to the
         client in the event that several indications arrive in one
         indication from the transport
         NOTE:
         It is possible to get an indication that occurs in the middle
         of the pdu if the client took the first indication rather
         than passing an irp back, and thence going to the FILL_IRP
         state. So check if BytesRcvd is zero, meaning that we are
         expecting a new PDU.
        */
        ASSERT(pConnEle->BytesInXport == 0);
        ASSERT(pLowerConn->StateRcv == NORMAL);

        if (pConnEle->BytesRcvd == 0)
        {
            if (BytesIndicated >= sizeof(tSESSIONHDR))
            {
                PduSize = myntohl(((tSESSIONHDR UNALIGNED *)pTsdu)->UlongLength)
                                          + sizeof(tSESSIONHDR);
                Passit = FALSE;

            }
            else
            {
                status = LessThan4BytesRcvd(pLowerConn,
                                            BytesAvailable,
                                            BytesTaken,
                                            ppIrp);
                goto ExitRoutine;
            }

        }
        else
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Got rest of PDU in indication BytesInd %X, BytesAvail %X\n",
                BytesIndicated, BytesAvailable));

            /* This is the remaining pdu size
            */
            PduSize = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
            /* a flag to pass the if below, since we are passing the
             remaining data of a pdu to the client and we do not have
             to adhere to the 128 bytes restriction.
            */
            PUSH_LOCATION(0x1);
            if (pConnEle->JunkMsgFlag)
            {
                //
                // in this case the client has indicated that it took the
                // entire message on the previous indication, so don't
                // indicate any more to it.
                //
                PUSH_LOCATION(0x1);

                if (BytesAvailable < PduSize)
                {
                    BTaken = BytesAvailable;
                }
                else
                {
                    BTaken = PduSize;
                }
                pConnEle->BytesRcvd += BTaken;
                if (pConnEle->BytesRcvd == pConnEle->TotalPcktLen)
                {
                    PUSH_LOCATION(0x1);
                    pConnEle->BytesRcvd = 0; // reset for the next session pdu
                    pConnEle->JunkMsgFlag = FALSE;
                }
                status = STATUS_SUCCESS;
                goto SkipIndication;
            }
            Passit = TRUE;

        }
        /*
         be sure that there is at least 132 bytes or a whole pdu
         Since a keep alive has a zero length byte, we check for
         that because the 4 byte session hdr is added to the 0 length
         giving 4, so a 4 byte Keep Alive pdu will pass this test.
        */
        if ((BytesIndicated >= NBT_INDICATE_BUFFER_SIZE) ||
            (BytesIndicated >= PduSize) || Passit )
        {

            PUSH_LOCATION(0x2);

            /*
            // Indicate to the client
            */
            status = RcvHandlrNotOs(
                            ReceiveEventContext,
                            (PVOID)pLowerConn,
                            ReceiveFlags,
                            BytesIndicated,
                            BytesAvailable,
                            &BTaken,
                            pTsdu,
                            (PVOID)&pIrp
                            );


            if (status == STATUS_MORE_PROCESSING_REQUIRED)
            {
                ULONG               RemainingPdu;
                PIO_STACK_LOCATION  pIrpSp;
                PTDI_REQUEST_KERNEL_RECEIVE pClientParams;

                RemainingPdu = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;
                pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
                pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

                // check if we can copy to the client's irp directly - meaning
                // that we have received the whole pdu in this indication and
                // the client's buffer is large enough, and there is no more
                // data in the transport.
                //

                if ((RemainingPdu == (BytesIndicated - BTaken)) &&
                    (BytesIndicated == BytesAvailable) &&
                    (pClientParams->ReceiveLength >= RemainingPdu) &&
                    pIrp->MdlAddress)
                {
                    ULONG   BytesCopied;

                    PUSH_LOCATION(0x88);

                    status = TdiCopyBufferToMdl(
                                            (PVOID)((PUCHAR)pTsdu + BTaken),
                                            0,
                                            RemainingPdu,
                                            pIrp->MdlAddress,
                                            0,
                                            &BytesCopied);

                    IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint(("Nbt:Copy to client Buffer RcvLen=%X,StateRcv=%X\n",
                                RemainingPdu,pLowerConn->StateRcv));

                    pIrp->IoStatus.Information = BytesCopied;
                    pIrp->IoStatus.Status = STATUS_SUCCESS;

                    // reset a few things since this pdu has been fully recv'd
                    //
                    CHECK_PTR(pConnEle);
                    pConnEle->BytesRcvd = 0;
                    CHECK_PTR(pConnEle);
                    pConnEle->pIrpRcv = NULL;

                    //
                    //   tell the transport we took all the data that we did take.
                    //
                    *BytesTaken = BytesCopied + BTaken;

                    //
                    // complete the irp back to the client if required
                    //
                    IF_DBG(NBT_DEBUG_FASTPATH)
                    KdPrint(("F"));

                    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                    pLowerConn->BytesRcvd += BytesCopied;

                    DerefLowerConnFast(pLowerConn,pConnEle,OldIrq);
                    return(STATUS_SUCCESS);
                }
                else
                {
                    PUSH_LOCATION(0x3);

                    status = ProcessIrp(pLowerConn,
                                        pIrp,
                                        pTsdu,
                                        &BTaken,
                                        BytesIndicated,
                                        BytesAvailable);

                    *BytesTaken = BTaken;
                    ASSERT(*BytesTaken <= (pConnEle->TotalPcktLen + sizeof(tSESSIONHDR)) );
                    if (status == STATUS_RECEIVE_EXPEDITED)
                    {
                        // in this case the processirp routine has completed the
                        // irp, so just return since the completion routine will
                        // have adjusted the RefCount and InRcvHandler flag
                        //
                        *ppIrp = NULL;
                        CTESpinFree(pLowerConn,OldIrq);
                        return(STATUS_SUCCESS);
                    }
                    else
                    if (status == STATUS_SUCCESS)
                    {
                        *ppIrp = NULL;

                    }
                    else
                    {
                        *ppIrp = (PVOID)pIrp;
                    }
                }


             }
             else
             {
                // for the skip indication case the client has told us it
                // does not want to be indicated with any more of the data
                //
SkipIndication:
                //
                // the client received some, all or none of the data
                // For Keep Alives the PduSize is 4 and BytesTaken = 4
                // so this check and return status success
                //
                *BytesTaken = BTaken;

                pLowerConn->BytesRcvd += BTaken - sizeof(tSESSIONHDR);

                //
                // if the connection has disonnected, then just return
                //
                if (!pLowerConn->pUpperConnection)
                {
                    *BytesTaken = BytesAvailable;
                    status = STATUS_SUCCESS;
                }
                else
                if (BTaken > BytesAvailable)
                {
                    //
                    // in this case the client has taken all of the message
                    // which could be larger than the available because
                    // we set bytesavail to the message length. So set a flag
                    // that tells us to discard the rest of the message as
                    // it comes in.
                    //
                    pConnEle->JunkMsgFlag = TRUE;
                    pConnEle->BytesRcvd = BytesAvailable - sizeof(tSESSIONHDR);
                    *BytesTaken = BytesAvailable;

                }
                else
                if (pLowerConn->StateRcv == PARTIAL_RCV)
                {
                    // this may be a zero length send -that the client has
                    // decided not to accept.  If so then the state will be set
                    // to PartialRcv.  In this case do NOT go down to the transport
                    // and get the rest of the data, but wait for the client
                    // to post a rcv buffer.
                    //

                    // amount left in the transport...
                    pConnEle->BytesInXport = BytesAvailable - BTaken;
                    status = STATUS_SUCCESS;
                }
                else
                if (BTaken == PduSize)
                {
                    /*
                     Must have taken all of the pdu data, so check for
                     more data available - if so send down the indicate
                     buffer to get it.
                    */
                    ASSERT(BTaken <= BytesIndicated);
                    if (BytesAvailable <= BTaken)
                    {
                        /* FAST PATH
                        */
                        PUSH_LOCATION(0x8);

                        status = STATUS_SUCCESS;

                    }
                    else
                    {
                        /*
                         get remaining data with the indicate buffer
                        */
                        status = MoreDataRcvdThanNeeded(pLowerConn,
                                                        BytesIndicated,
                                                        BytesAvailable,
                                                        BytesTaken,
                                                        pTsdu,
                                                        ppIrp);
                    }
                }
                else
                {
                    //
                    // the client may have taken all the data in the
                    // indication!!, in which case return status success
                    // Note: that we check bytes available here not bytes
                    // indicated - since the client could take all indicated
                    // data but still leave data in the transport.
                    //
                    if (BTaken == BytesAvailable)
                    {
                        PUSH_LOCATION(0x4);
                        status = STATUS_SUCCESS;

                    }
                    else
                    {
                        PUSH_LOCATION(0x87);
                        if (BTaken > PduSize)
                        {
#ifndef VXD
#if DBG
                        DbgBreakPoint();
#endif
#endif
                            //
                            // the client took more than a PDU size worth,
                            // which is odd....
                            //
                            PUSH_LOCATION(0x87);
                            ASSERT(BTaken <= PduSize);

                            CTESpinFreeAtDpc(pLowerConn);
                            OutOfRsrcKill(pLowerConn);
                            CTESpinLockAtDpc(pLowerConn);

                            status = STATUS_SUCCESS;

                        }
                        else
                        {
                            //
                            // otherwise the client did not take all of the data,
                            // which can mean that
                            // the client did not take all that it could, so
                            // go to the partial rcv state to keep track of it.
                            //
                            status = ClientTookSomeOfTheData(pLowerConn,
                                                    BytesIndicated,
                                                    BytesAvailable,
                                                    *BytesTaken,
                                                    PduSize);
                        }
                    }
                }

             }

        }
        else
        {
            status = NotEnoughDataYet(pLowerConn,
                             BytesIndicated,
                             BytesAvailable,
                             BytesTaken,
                             PduSize,
                             (PVOID *)ppIrp);
        }
    }
    else
    {
        status = (*pLowerConn->CurrentStateProc)(ReceiveEventContext,
                                         pLowerConn,
                                         ReceiveFlags,
                                         BytesIndicated,
                                         BytesAvailable,
                                         BytesTaken,
                                         pTsdu,
                                         ppIrp);
    }

    //
    // in the IndicateBuffer state we have sent the indicate buffer
    // down the the transport and expect it to come back in
    // NewSessionCompletionRoutine. Therefore do not dereference the lower
    // connection and do not change the InRcvHandler flag.

    // If an Irp
    // is returned, then do not undo the reference - but rather
    // wait for CompletionRcv to be called.
    //
ExitRoutine:
    if (status != STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // quickly check if we can just decrement the ref count without calling
        // NBT_DEREFERENCE_LOWERCONN
        //
        PUSH_LOCATION(0x50);
        DerefLowerConnFast (pLowerConn, pConnEle, OldIrq);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
    }

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
ProcessIrp(
    IN tLOWERCONNECTION *pLowerConn,
    IN PIRP     pIrp,
    IN PVOID    pBuffer,
    IN PULONG   BytesTaken,
    IN ULONG    BytesIndicated,
    IN ULONG    BytesAvailable
    )
/*++

Routine Description:

    This routine handles a Receive Irp that the client has returned on an
    indication.  The idea here is to check the Irp's MDL length to be
    sure the pdu fits into the MDL, and also keep track of the situation where
    more than one data is required to fill the pdu.

Arguments:


Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS                    status;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnectEle;
    PTDI_REQUEST_KERNEL_RECEIVE pClientParams;
    ULONG                       RemainingPdu;
    PMDL                        pMdl;
    PFILE_OBJECT                pFileObject;
    ULONG                       ReceiveLength;
    BOOLEAN                     QuickRoute;
    BOOLEAN                     FromCopyData;

    pConnectEle = pLowerConn->pUpperConnection;

    status = STATUS_SUCCESS;

    // subtract session header and any bytes that the client took
    //
    BytesAvailable -= *BytesTaken;

    //
    // put together an Irp stack location to process the receive and pass down
    // to the transport.
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

    //
    // check if this will be a multiple rcv session pdu.  If it is then
    // allocate a partial MDL to be used for mapping part of the first
    // MDL in each chunk received
    //
    RemainingPdu = pConnectEle->TotalPcktLen - pConnectEle->BytesRcvd;
    ReceiveLength = RemainingPdu;
    PUSH_LOCATION(0x19);
    pIrpSp = IoGetNextIrpStackLocation(pIrp);

    // this code should not be hit if called by CopyDataandIndicate
    // which is in the indicate buffer state since it adjusts the bytesInXport
    // which is also set by the code in TdiReceiveHndlr in the INDICATE_BUFFER
    // state before calling CopyDataandIndicate.  Also, CopyDataandIndicate
    // does not want this routine to set the state to fillIrp when Bytes
    // Available < RemainingPdu
    //
    FromCopyData = (pLowerConn->StateRcv == INDICATE_BUFFER);
    if (!FromCopyData)
    {

        QuickRoute = TRUE;
        // we need this code within the check since this routine is also called by the
        // HandleNewSessionPdu routine, which calls IoCallDriver, which
        // increments the stack location itself.
        //
        ASSERT(pIrp->CurrentLocation > 1);

        if (BytesAvailable == RemainingPdu)
        {
            if (pClientParams->ReceiveLength >= BytesAvailable)
            {
                // *** FAST PATH CASE ****
                goto ExitCode;
            }
        }
        else
        if (BytesAvailable < RemainingPdu ) // need more data from transport
        {
            PUSH_LOCATION(0x14);
            // it is possible for the client to pass down an irp with no
            // MDL in it, so we check for that here
            //
            if (pIrp->MdlAddress)
            {
                PUSH_LOCATION(0x14);

                //
                // save the client's irp address since the session pdu will arrive
                // in several chunks, and we need to continually pass the irp to the
                // transport for each chunk.
                //
                //pConnectEle->pIrpRcv = pIrp;
                // NOTE: the pIrp is NOT saved here because the irp is about
                // to be passed back to the transport.  Hence we do not want
                // to accidently complete it in DisconnectHandlrNotOs
                // if a disconnect comes in while the irp is in the transport.
                // pIrpRcv is set to pIrp in Completion Rcv while we have
                // the irp in our possession.

                //
                // keep the initial Mdl(chain) since we need to
                // to copy new data after the existing data, when the session pdu arrives
                // as several chunks from TCP. Keeping the Mdl around allows us to
                // reconstruct the original Mdl chain when we are all done.
                //
                pLowerConn->pMdl = pIrp->MdlAddress;
                //
                // this call maps the client's Mdl so that on each partial Mdl creation
                // we don't go through  a mapping and unmapping (when MmPrepareMdlForReuse)
                // is called in the completion routine.
                //
                (PVOID)MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority);

                pMdl = pIrp->MdlAddress;

                // the nextmdl is setup to allow us to create a partial Mdl starting
                // from the next one.  CompletionRcv will adjust this if it needs to.
                //
                pConnectEle->pNextMdl = pMdl;

                // need more data from the transport to fill this
                // irp
                //
                CHECK_PTR(pConnectEle);
                pConnectEle->pIrpRcv = NULL;
                SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);
            }

            status = STATUS_MORE_PROCESSING_REQUIRED;

            // if the client buffer is big enough, increment to the next
            // io stack location and jump to the code that sets up the
            // irp, since we always want to pass it to the transport in this
            // case because the transport will hold onto the irp till it is full
            // if it can. (faster)
            //
            if (pClientParams->ReceiveLength >= RemainingPdu)
            {
                // *** FAST PATH CASE ****
                IoSetNextIrpStackLocation(pIrp);
                pConnectEle->FreeBytesInMdl = ReceiveLength;
                pConnectEle->CurrentRcvLen  = RemainingPdu;
                goto ExitCode2;
            }

            //
            // if there is no mdl then we want to be able to go through the
            // quick route below to return the null mdl right away, so
            // don't set Quickroute false here.
            //


        }
        else
        if (BytesAvailable > RemainingPdu)
        {
            PUSH_LOCATION(0x15);
            //
            // there is too much data, so keep track of the
            // fact that there is data left in the transport
            // and get it when the irp completes through
            // completion recv.
            //
            SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

            // this calculation may have to be adjusted below if the client's
            // buffer is too short. NOTE: BytesTaken have already been subtracted
            // from BytesAvailable (above).
            //
            pConnectEle->BytesInXport = BytesAvailable - RemainingPdu;

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Switching to Indicate Buff(Irp), Indic = %X, Pdusize=%X\n",
                    BytesIndicated,pConnectEle->TotalPcktLen));


            status = STATUS_DATA_NOT_ACCEPTED;
        }

        // DEBUG*
        //IoSetNextIrpStackLocation(pIrp);
    }
    else
    {
        QuickRoute = FALSE;
    }

    //
    // if the receive buffer is too short then flag it so when the client
    // passes another buffer to NBT, nbt will pass it to the transport
    //
    //if (BytesAvailable > pClientParams->ReceiveLength )
    {

        // so just check for too short of a client buffer.
        //
        if (RemainingPdu > pClientParams->ReceiveLength)
        {
            PUSH_LOCATION(0x17);

            ReceiveLength = pClientParams->ReceiveLength;
            //
            // Adjust the number of bytes left in the transport up by the number of
            // bytes not taken by the client.  Be sure not to add in the number
            // of bytes in the transport twice, since it could have been done
            // above where the state is set to INDICATE_BUFFER
            //
            if (status == STATUS_DATA_NOT_ACCEPTED)
            {
                // BytesInXport was already incremented to account for any
                // amount over remainingPdu, so just add the amount that the
                // client buffer is short of RemainingPdu
                //
                PUSH_LOCATION(0x18);
                if (BytesAvailable > ReceiveLength )
                {
                    pConnectEle->BytesInXport += (RemainingPdu - ReceiveLength);
                }
                // the client has not taken all of the data , but has returned
                // a buffer that is ReceiveLength long, therefore the amount
                // that the client needs to take is just the total pdu - rcvlength.
                //
                pConnectEle->ReceiveIndicated = (RemainingPdu - ReceiveLength);
            }
            else
            {
                //
                // BytesInXport has not been incremented yet so add the entire
                // amount that the client buffer is too short by. Check if
                // the client's buffer will take all of the data.
                //
                if (BytesAvailable > ReceiveLength )
                {
                    pConnectEle->BytesInXport += (BytesAvailable - ReceiveLength);
                }
                // the client has not taken all of the data , but has returned
                // a buffer that is ReceiveLength long, therefore the amount
                // that the client needs to take is just what was indicated
                // to the client - recvlength.
                //
                pConnectEle->ReceiveIndicated = (RemainingPdu - ReceiveLength);
            }


            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Switching to PartialRcv for Irp. RecvInd. =%X, RemainPdu %X Avail %X\n",
                    pConnectEle->ReceiveIndicated,RemainingPdu,BytesAvailable));
        }

    }

ExitCode:

    // keep track of data in MDL so we know when it is full and we need to
    // return it to the user. CurrentRcvLen tells us how many bytes the current
    // Irp can have max when the Mdl is full.
    //
    pConnectEle->FreeBytesInMdl = ReceiveLength;
    pConnectEle->CurrentRcvLen  = ReceiveLength;
    if (ReceiveLength > RemainingPdu)
    {
        pConnectEle->CurrentRcvLen  = RemainingPdu;
    }
    if (QuickRoute)
    {
        //
        // check if we can copy the data  to the client's MDL
        // right here. If the indication is too short pass an Irp down
        // to the transport.
        //
        BytesIndicated -= *BytesTaken;

        if ((ReceiveLength <= BytesIndicated))
        {
            ULONG   BytesCopied;

            PUSH_LOCATION(0x76);

            if (pIrp->MdlAddress)
            {

                status = TdiCopyBufferToMdl(
                                        (PVOID)((PUCHAR)pBuffer + *BytesTaken),
                                        0,
                                        ReceiveLength,
                                        pIrp->MdlAddress,
                                        0,
                                        &BytesCopied);

            }
            else
            {
                //
                // No Mdl, so just return the irp to the client, and then
                // return success to the caller so we tell the transport that
                // we took only BytesTaken
                //
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:No MDL, so complete Irp\n"));


                PUSH_LOCATION(0x77);
                BytesCopied = 0;
            }

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Copy to client Buffer RcvLen=%X,StateRcv=%X\n",
                        ReceiveLength,pLowerConn->StateRcv));

            pIrp->IoStatus.Information = BytesCopied;
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            //
            //   now call the irp completion routine, shorting out the io
            //   subsystem - to process the irp
            //
            CTESpinFreeAtDpc(pLowerConn);
            status = CompletionRcv(NULL,pIrp,(PVOID)pLowerConn);

            //
            //   tell the transport we took all the data that we did take.
            //
            *BytesTaken += BytesCopied;

            IF_DBG(NBT_DEBUG_FASTPATH)
            KdPrint(("f"));
            //
            // complete the irp back to the client if required
            //
            if (status != STATUS_MORE_PROCESSING_REQUIRED)
            {
                PUSH_LOCATION(0x76);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:Completing Irp Quickly\n"));

                IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            }

            // since we have called CompletionRcv, that routine has
            // adjusted the refcount and InRcvHandlr flag, so return this
            // status to cause the caller to return directly
            CTESpinLockAtDpc(pLowerConn);
            return(STATUS_RECEIVE_EXPEDITED);

        }
        else
        {
            //
            // make the next stack location the current one.  Normally IoCallDriver
            // would do this but we are not going through IoCallDriver here, since the
            // Irp is just passed back with RcvIndication.
            //
            IoSetNextIrpStackLocation(pIrp);
        }
    }
ExitCode2:
    pIrpSp->CompletionRoutine = CompletionRcv;
    pIrpSp->Context           = (PVOID)pLowerConn;

    // set Control flags so the completion routine is always invoked.
    pIrpSp->Control       = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

    pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pIrpSp->MinorFunction = TDI_RECEIVE;

    pFileObject           = pLowerConn->pFileObject;
    ASSERT (pFileObject->Type == IO_TYPE_FILE);
    pIrpSp->FileObject    = pFileObject;
    pIrpSp->DeviceObject  = IoGetRelatedDeviceObject(pFileObject);

    pParams               = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
    pParams->ReceiveFlags = pClientParams->ReceiveFlags;

    // Set the correct receive length in the irp in case the client has
    // passed one down that is larger than the message
    //
    pParams->ReceiveLength = ReceiveLength;

    //
    // just check for a zero length send, where the client has
    // passed down an Irp with a null mdl, or the pdu size is zero.  We don't want to pass
    // that to the transport because it will hold onto it till the next
    // pdu comes in from the wire - we want to complete the irp when this routine
    // returns. When this is called from CopyDataAndIndicate don't
    // to this because copydataandindicate does all the checks.
    //
    if (!FromCopyData)
    {
        if ((RemainingPdu == 0) || !pIrp->MdlAddress)
        {
            //
            // the call to IoCompleteRequest will call completionRcv which will
            // decrement the RefCount. Similarly returning status success will
            // cause the caller to decrement the ref count, so increment one
            // more time here to account for this second decrement.
            //
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
            CTESpinFreeAtDpc(pLowerConn);

            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            CTESpinLockAtDpc(pLowerConn);

            status = STATUS_SUCCESS;
        }
        else
            status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
ClientBufferOverFlow(
    IN tLOWERCONNECTION     *pLowerConn,
    IN tCONNECTELE          *pConnEle,
    IN PIRP                 pIrp,
    IN ULONG                BytesRcvd
    )
/*++

Routine Description:

    This routine completes the Irp by tracking the number of bytes received

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pLowerConn - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    // *TODO*

    ASSERT(0);

    switch (pLowerConn->StateRcv)
    {
        case PARTIAL_RCV:
        case FILL_IRP:
        case NORMAL:
        case INDICATE_BUFFER:
        default:
            ;
    }
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
CompletionRcv(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp by tracking the number of bytes received

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pLowerConn - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    register tCONNECTELE        *pConnectEle;
    NTSTATUS                    status;
    ULONG                       BytesRcvd;
    tLOWERCONNECTION            *pLowerConn;
    PKDPC                       pDpc;
    CTELockHandle               OldIrq;
    CTELockHandle               OldIrq2;
    PMDL                        pMdl;
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    BOOLEAN                     AllowDereference=TRUE;

    //
    // Do some checking to keep the Io system happy - propagate the pending
    // bit up the irp stack frame.... if it was set by the driver below then
    // it must be set by me
    //
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    // check the bytes recvd
    pLowerConn = (tLOWERCONNECTION *)Context;
    //
    // if the link has disconnected, do not process the irp, just pass it
    // up the chain.
    //
    CTESpinLock(pLowerConn,OldIrq);
    if (!NT_SUCCESS(Irp->IoStatus.Status) || !pLowerConn->pUpperConnection)
    {
        PUSH_LOCATION(0x1);
        if (pLowerConn->StateRcv == FILL_IRP)
        {
            PUSH_LOCATION(0x1);
            Irp->MdlAddress = pLowerConn->pMdl;
            ASSERT(Irp->MdlAddress);

        }
        SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);
        //
        // the rcv failed so kill the connection since
        // we can't keep track of message boundaries any more.
        //
        CTESpinFree(pLowerConn,OldIrq);
        OutOfRsrcKill(pLowerConn);
        CTESpinLock(pLowerConn,OldIrq);

        status = STATUS_SUCCESS;
        goto ExitCode;
    }

    pConnectEle = pLowerConn->pUpperConnection;

    // keep track of how many bytes have been received
    //
    BytesRcvd = (ULONG)Irp->IoStatus.Information;
    pConnectEle->BytesRcvd += BytesRcvd;
    //
    // subtract the number of bytes rcvd from the length of the client
    // buffer
    // so when more data arrives we can determine if we are going to
    // overflow the client buffer.
    //
    pConnectEle->FreeBytesInMdl -= BytesRcvd;

    pIrpSp = IoGetCurrentIrpStackLocation(Irp);
    pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

    pLowerConn->BytesRcvd += BytesRcvd;

    CHECK_PTR(pConnectEle);
    if (Irp->IoStatus.Status == STATUS_BUFFER_OVERFLOW)
    {
        //
        // the client's buffer was too short - probably because he said it
        // was longer than it really was
        //
        PUSH_LOCATION(0x1a);
        KdPrint(("Nbt:Client Buffer Too short on CompletionRcv\n"));

        if (pLowerConn->StateRcv == FILL_IRP)
        {
            PUSH_LOCATION(0x1a);
            Irp->MdlAddress = pLowerConn->pMdl;
            ASSERT(Irp->MdlAddress);
        }
        pConnectEle->BytesRcvd = 0; // reset for the next session pdu
        status = ClientBufferOverFlow(pLowerConn,pConnectEle,Irp,BytesRcvd);

        //
        // the client's buffer was too short so kill the connection since
        // we can't keep track of message boundaries any more.
        //
        SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);
        CTESpinFree(pLowerConn,OldIrq);
        OutOfRsrcKill(pLowerConn);
        CTESpinLock(pLowerConn,OldIrq);

        goto ExitCode;
    }
    else if ((pConnectEle->FreeBytesInMdl == 0) ||
       (pConnectEle->BytesRcvd == pConnectEle->TotalPcktLen))
    {
        INCR_COUNT(C1);
    //
    // this case handles when the Irp MDL is full or the whole pdu has been
    // received.
    //

        //
        // reset the MDL fields back to where they were
        // if this was a multi-rcv session pdu
        //
        //
        if (pLowerConn->StateRcv == FILL_IRP)
        {

            INCR_COUNT(C2);
            PUSH_LOCATION(0x1b);

            Irp->MdlAddress = pLowerConn->pMdl;
            ASSERT(Irp->MdlAddress);

            //
            // allow the MDL to be used again for the next session PDU
            //
            pMdl = pConnectEle->pNewMdl;
            MmPrepareMdlForReuse(pMdl);

            pConnectEle->OffsetFromStart  = 0;

        }

        CHECK_PTR(pConnectEle);
        pConnectEle->pIrpRcv = NULL;
        //
        // we have received all of the data
        // so complete back to the client
        //
        status = STATUS_SUCCESS;
        //
        // the amount of data in this irp is the CurrentRcvLen which
        // could be less than BytesRcvd when the client passes down
        // short rcv buffers.
        //
        Irp->IoStatus.Information = pConnectEle->CurrentRcvLen;

        if (pConnectEle->BytesRcvd == pConnectEle->TotalPcktLen)
        {

            pConnectEle->BytesRcvd = 0; // reset for the next session pdu
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        else
        {
            PUSH_LOCATION(0x27);
            //
            // this MDL must be too short to take the whole pdu, so set the
            // status to buffer overflow.
            //
            Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

        }

        //
        // The client may have passed down a  too short irp which we are
        // tracking with ReceiveIndicated, so set state to partialrcv if
        // necessary.
        //
        if (pConnectEle->ReceiveIndicated == 0)
        {
            SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
        }
        else
        {
            PUSH_LOCATION(0x26);
            //
            // there may still be data left in the transport
            //
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Short Rcv, still data indicated to client\n"));

            SET_STATERCV_LOWER(pLowerConn, PARTIAL_RCV, PartialRcv);
        }

        //
        // Check if there is still more data in the transport or if the client
        // has been indicated with more data and has subsequently posted a rcv
        // which we must get now and pass to the transport.
        //
        if ((pConnectEle->BytesInXport) || (pLowerConn->StateRcv == PARTIAL_RCV))
        {
            INCR_COUNT(C3);
            //
            // send down another
            // irp to get the data and complete the client's current irp.
            //
            PUSH_LOCATION(0x1c);
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:ComplRcv BytesInXport= %X, %X\n",pConnectEle->BytesInXport,
                                pLowerConn));

            if (pLowerConn->StateRcv != PARTIAL_RCV)
            {
                SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);
                pLowerConn->BytesInIndicate = 0;
            }

            CTESpinFree(pLowerConn,OldIrq);

            IoAcquireCancelSpinLock(&OldIrq);
            IoSetCancelRoutine(Irp,NULL);
            IoReleaseCancelSpinLock(OldIrq);

            // Complete the current Irp
            IoCompleteRequest(Irp,IO_NETWORK_INCREMENT);

            CTESpinLock(pLowerConn,OldIrq);

            // rather than call HandleNewSessionPdu directly, we queue a
            // Dpc since streams does not currently expect to get a recv
            // posted while it is processing an indication response.  The
            // Dpc will run when streams is all done, and it should handle
            // this posted receive ok.


            if (pLowerConn->StateRcv == PARTIAL_RCV)
            {
                //
                // check if the client has passed down another rcv buffer
                // and if so, start a Dpc which will pass down the client's
                // buffer.
                //
                if (!IsListEmpty(&pConnectEle->RcvHead))
                {
                    if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('p')))
                    {
                        KeInitializeDpc(pDpc, DpcGetRestOfIndication, (PVOID)pLowerConn);
                        KeInsertQueueDpc(pDpc,NULL,NULL);
                        //
                        // we don't want to dereference pLowerConn at the end
                        // since we will use it in the DPC routine.
                        //
                        CTESpinFree(pLowerConn,OldIrq);
                        return(STATUS_MORE_PROCESSING_REQUIRED);
                    }
                    else
                    {
                        CTESpinFreeAtDpc(pLowerConn);
                        OutOfRsrcKill(pLowerConn);
                        CTESpinLockAtDpc(pLowerConn);
                    }
                }
            }
            else if (pLowerConn->StateRcv != FILL_IRP)
            {
                if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('q')))
                {
                    //
                    // just get the session hdr to start with so we know how large
                    // the pdu is, then get the rest of the pdu after that completes.
                    //
                    KeInitializeDpc(pDpc, DpcHandleNewSessionPdu, (PVOID)pLowerConn);
                    KeInsertQueueDpc(pDpc,NULL,(PVOID)sizeof(tSESSIONHDR));
                    //
                    // we don't want to dereference pLowerConn at the end
                    // since we will use it in the DPC routine.
                    //
                    CTESpinFree(pLowerConn,OldIrq);
                    return(STATUS_MORE_PROCESSING_REQUIRED);
                }
                else
                {
                    CTESpinFreeAtDpc(pLowerConn);
                    OutOfRsrcKill(pLowerConn);
                    CTESpinLockAtDpc(pLowerConn);
                }
            }
            else
            {
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint (("Nbt.CompletionRcv: * pLowerConn=<%p>, IP=<%x>\n",
                        pLowerConn, pLowerConn->SrcIpAddr));
            }

            status = STATUS_MORE_PROCESSING_REQUIRED;
            goto ExitCode;
        }
    }
    else if (pConnectEle->BytesRcvd < pConnectEle->TotalPcktLen)
    {
        ULONG   Bytes;

        INCR_COUNT(C4);
        PUSH_LOCATION(0x1d);
        //
        // in this case we have not received all of the data from the transport
        // for this session pdu, so tell the io subystem not to finish processing
        // the irp yet if it is not a partial Rcv.
        //
        status = STATUS_MORE_PROCESSING_REQUIRED;

        // clean up the partial mdl.
        //
        pMdl = pConnectEle->pNewMdl;
        MmPrepareMdlForReuse(pMdl);

        // set where the next rcvd data will start, by setting the pNextMdl and
        // offset from start.
        //
        pMdl = pConnectEle->pNextMdl;
        ASSERT(pMdl);

        Bytes = BytesRcvd + pConnectEle->OffsetFromStart;
        if (Bytes < MmGetMdlByteCount(pMdl))
        {
            PUSH_LOCATION(0x74);
            //
            // All of this data will fit into the current Mdl, and
            // the next data will start in the same Mdl (if there is more data)
            //
            pConnectEle->OffsetFromStart  += BytesRcvd;

            IF_DBG(NBT_DEBUG_FILLIRP)
            KdPrint(("~"));
        }
        else
        {
            //
            // sum the Mdl lengths until we find enough space for the data
            // to fit into.
            //
            IF_DBG(NBT_DEBUG_FILLIRP)
            KdPrint(("^"));
            PUSH_LOCATION(0x75);

            SumMdlLengths(pMdl,Bytes,pConnectEle);

        }

        // since we are holding on to the rcv Irp, set up a cancel routine
        IoAcquireCancelSpinLock(&OldIrq2);

        // if the session was disconnected while the transport had the
        // irp, then cancel the irp now...
        //
        if ((pConnectEle->state != NBT_SESSION_UP) || Irp->Cancel)
        {
            CHECK_PTR(pConnectEle);
            pConnectEle->pIrpRcv = NULL;
            SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);

            IoReleaseCancelSpinLock(OldIrq2);
            CTESpinFree(pLowerConn,OldIrq);

            // since the irp has been cancelled, don't touch it.
            // return status success so the IO subsystem passes the irp
            // back to the owner.
            //
            status = STATUS_SUCCESS;

//            Irp->IoStatus.Status = STATUS_CANCELLED;
//            IoCompleteRequest(Irp,IO_NETWORK_INCREMENT);

            // the irp is being cancelled in mid session pdu.  We can't
            // recover since we have given the client only part of a pdu,
            // therefore disconnect the connection.

            OutOfRsrcKill(pLowerConn);

            CTESpinLock(pLowerConn,OldIrq);

        }
        else
        {
            // setup the cancel routine
            IoSetCancelRoutine(Irp, NbtCancelFillIrpRoutine);

            // the pIrpRcv value is set to Zero when the irp is in the
            // tranport, so we can't accidently complete it twice in
            // disconnectHandlrNotOs when a disconnect occurs and the
            // transport has the irp. So here we save the value again so FillIrp
            // will work correctly.
            //
            pConnectEle->pIrpRcv = Irp;
            // set the irp mdl back to its original so that a cancel will
            // find the irp in the right state
            //
            Irp->MdlAddress = pLowerConn->pMdl;

            IoReleaseCancelSpinLock(OldIrq2);

        }
    }
    else
    {
        //IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Too Many Bytes Rcvd!! Rcvd# = %d, TotalLen = %d,NewBytes =%d,%X\n",
                    pConnectEle->BytesRcvd,pConnectEle->TotalPcktLen,
                    Irp->IoStatus.Information,pLowerConn));
        ASSERT(0);
        // this status will return the irp to the user
        //
        status = STATUS_SUCCESS;
        if (pLowerConn->StateRcv == FILL_IRP)
        {

            PUSH_LOCATION(0x1f);

            Irp->MdlAddress = pLowerConn->pMdl;
            Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            Irp->IoStatus.Information = 0;

            //
            // allow the MDL to be used again for the next session PDU
            //
            pMdl = pConnectEle->pNewMdl;
            MmPrepareMdlForReuse(pMdl);


        }
        pConnectEle->OffsetFromStart  = 0;
        pConnectEle->BytesRcvd = 0;

        SET_STATERCV_LOWER(pLowerConn, NORMAL, pLowerConn->CurrentStateProc);

        //WHAT ELSE TO DO HERE OTHER THAN KILL THE CONNECTION, SINCE WE ARE
        // PROBABLY OFF WITH RESPECT TO THE SESSION HDR....
        // ....RESET THE CONNECTION ????

        CTESpinFree(pLowerConn,OldIrq);

        OutOfRsrcKill(pLowerConn);

        CTESpinLock(pLowerConn,OldIrq);

    }

ExitCode:
    //
    // quickly check if we can just decrement the ref count without calling
    // NBT_DEREFERENCE_LOWERCONN - this function is __inline!!
    //
    PUSH_LOCATION(0x52);
    DerefLowerConnFast (pLowerConn, pConnectEle, OldIrq);

    return(status);

    UNREFERENCED_PARAMETER( DeviceObject );
}
//----------------------------------------------------------------------------

__inline
NTSTATUS
RcvHandlrNotOs (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    )
/*++

Routine Description:

    This routine is the receive event indication handler.

    It is called when an session packet arrives from the network, when the
    session has already been established (NBT_SESSION_UP state). The routine
    looks for a receive buffer first and failing that looks for a receive
    indication handler to pass the message to.

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    NTSTATUS               status;
    PLIST_ENTRY            pRcv;
    PVOID                  pRcvElement;
    tCLIENTELE             *pClientEle;
    tSESSIONHDR UNALIGNED  *pSessionHdr;
    tLOWERCONNECTION       *pLowerConn;
    tCONNECTELE            *pConnectEle;
    CTELockHandle          OldIrq;
    PIRP                   pIrp;
    ULONG                  ClientBytesTaken;
    BOOLEAN                DebugMore;
    ULONG                  RemainingPdu;

//********************************************************************
//********************************************************************
//
//  NOTE: A copy of this procedure is in Tdihndlr.c - it is inlined for
//        the NT case.  Therefore, only change this procedure and then
//        copy the procedure body to Tdihndlr.c
//
//
//********************************************************************
//********************************************************************

    // get the ptr to the lower connection, and from that get the ptr to the
    // upper connection block
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pSessionHdr = (tSESSIONHDR UNALIGNED *)pTsdu;

    //
    // Session ** UP ** processing
    //
    *BytesTaken = 0;

    pConnectEle = pLowerConn->pUpperConnection;

    ASSERT(pConnectEle->pClientEle);

    ASSERT(BytesIndicated >= sizeof(tSESSIONHDR));

    // this routine can get called by the next part of a large pdu, so that
    // we don't always started at the begining of  a pdu.  The Bytes Rcvd
    // value is set to zero in CompletionRcv when a new pdu is expected
    //
    if (pConnectEle->BytesRcvd == 0)
    {

        if (pSessionHdr->Type == NBT_SESSION_MESSAGE)
        {

            //
            // expecting the start of a new session Pkt, so get the length out
            // of the pTsdu passed in
            //
            pConnectEle->TotalPcktLen = myntohl(pSessionHdr->UlongLength);

            // remove the Session header by adjusting the data pointer
            pTsdu = (PVOID)((PUCHAR)pTsdu + sizeof(tSESSIONHDR));

            // shorten the number of bytes since we have stripped off the
            // session header
            BytesIndicated  -= sizeof(tSESSIONHDR);
            BytesAvailable -= sizeof(tSESSIONHDR);
            *BytesTaken = sizeof(tSESSIONHDR);
        }
        //
        // Session Keep Alive
        //
        else
        if (pSessionHdr->Type == NBT_SESSION_KEEP_ALIVE)
        {
            // session keep alives are simply discarded, since the act of sending
            // a keep alive indicates the session is still alive, otherwise the
            // transport would report an error.

            // tell the transport that we took the Pdu
            *BytesTaken = sizeof(tSESSIONHDR);
            return(STATUS_SUCCESS);

        }
        else
        {
//            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.RcvHandlrNotOs: Unexpected SessionPdu rcvd:type=%X\n",
                    pSessionHdr->Type));

//            ASSERT(0);
            *BytesTaken = BytesIndicated;
            return(STATUS_SUCCESS);
        }
    }

    //
    // check if there are any receive buffers queued against this connection
    //
    if (!IsListEmpty(&pConnectEle->RcvHead))
    {
        // get the first buffer off the receive list
        pRcv = RemoveHeadList(&pConnectEle->RcvHead);
#ifndef VXD
        pRcvElement = CONTAINING_RECORD(pRcv,IRP,Tail.Overlay.ListEntry);

        // the cancel routine was set when this irp was posted to Nbt, so
        // clear it now, since the irp is being passed to the transport
        //
        IoAcquireCancelSpinLock(&OldIrq);
        IoSetCancelRoutine((PIRP)pRcvElement,NULL);
        IoReleaseCancelSpinLock(OldIrq);

#else
        pRcvElement = CONTAINING_RECORD(pRcv, RCV_CONTEXT, ListEntry ) ;
#endif

        //
        // this buffer is actually an Irp, so pass it back to the transport
        // as a return parameter
        //
        *RcvBuffer = pRcvElement;
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  No receives on this connection. Is there a receive event handler for this
    //  address?
    //
    pClientEle = pConnectEle->pClientEle;

    //
    // For safe
    //
    if (NULL == pClientEle) {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

#ifdef VXD
    //
    // there is always a receive event handler in the Nt case - it may
    // be the default handler, but it is there, so no need for test.
    //
    if (pClientEle->evReceive)
#endif
    {


        // check that we have not received more data than we should for
        // this session Pdu. i.e. part of the next session pdu. BytesRcvd may
        // have a value other than zero if the pdu has arrived in two chunks
        // and the client has taken the previous one in the indication rather
        // than passing back an Irp.
        //
#if DBG
        DebugMore = FALSE;
#endif
        RemainingPdu = pConnectEle->TotalPcktLen - pConnectEle->BytesRcvd;
        if (BytesAvailable >= RemainingPdu)
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt.RcvHandlrNotOs: More Data Recvd than expecting! Avail= %X,TotalLen= %X,state=%x\n",
                        BytesAvailable,pConnectEle->TotalPcktLen,pLowerConn->StateRcv));
#if DBG
            DebugMore =TRUE;
#endif
            // shorten the indication to the client so that they don't
            // get more data than the end of the pdu
            //
            BytesAvailable = RemainingPdu;
            if (BytesIndicated > BytesAvailable)
            {
                BytesIndicated = BytesAvailable;
            }
            //
            // We always indicated at raised IRQL since we call freelockatdispatch
            // below
            //
            ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE | TDI_RECEIVE_AT_DISPATCH_LEVEL;
        }
        else
        {
            // the transport may have has this flag on.  We need to
            // turn it off if the entire message is not present, where entire
            // message means within the bytesAvailable length. We deliberately
            // use bytesavailable so that Rdr/Srv can know that the next
            // indication will be a new message if they set bytestaken to
            // bytesavailable.
            //
            ReceiveFlags &= ~TDI_RECEIVE_ENTIRE_MESSAGE;
            ReceiveFlags |= TDI_RECEIVE_AT_DISPATCH_LEVEL;
#ifndef VXD
            BytesAvailable = RemainingPdu;
#endif
        }

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt.RcvHandlrNotOs: Calling Client's EventHandler <%x> BytesIndicated=<%x>, BytesAvailable=<%x>\n",
                pClientEle->evReceive, BytesIndicated, BytesAvailable));

        //
        //  NT-specific code locks pLowerConn before calling this routine,
        //
        CTESpinFreeAtDpc(pLowerConn);

        // call the Client Event Handler
        ClientBytesTaken = 0;
        status = (*pClientEle->evReceive)(
                      pClientEle->RcvEvContext,
                      pConnectEle->ConnectContext,
                      ReceiveFlags,
                      BytesIndicated,
                      BytesAvailable,
                      &ClientBytesTaken,
                      pTsdu,
                      &pIrp);

        CTESpinLockAtDpc(pLowerConn);

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt.RcvHandlrNotOs: Client's EventHandler returned <%x>, BytesTaken=<%x>, pIrp=<%x>\n",
                status, ClientBytesTaken, pIrp));

#if DBG
        if (DebugMore)
        {
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(( "Nbt.RcvHandlrNotOs: Client TOOK %X bytes, pIrp = %X,status =%X\n",
                   ClientBytesTaken,pIrp,status));
        }
#endif
        if (!pLowerConn->pUpperConnection)
        {
            // the connection was disconnected in the interim
            // so do nothing.
            if (status == STATUS_MORE_PROCESSING_REQUIRED)
            {
                CTEIoComplete(pIrp,STATUS_CANCELLED,0);
                *BytesTaken = BytesAvailable;
                return(STATUS_SUCCESS);
            }
        }
        else
        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            ASSERT(pIrp);
            //
            // the client may pass back a receive in the pIrp.
            // In this case pIrp is a valid receive request Irp
            // and the status is MORE_PROCESSING
            //

            // don't put these lines outside the if incase the client
            // does not set ClientBytesTaken when it returns an error
            // code... we don't want to use the value then
            //
            // count the bytes received so far.  Most of the bytes
            // will be received in the CompletionRcv handler in TdiHndlr.c
            pConnectEle->BytesRcvd += ClientBytesTaken;

            // The client has taken some of the data at least...
            *BytesTaken += ClientBytesTaken;

            *RcvBuffer = pIrp;

            // ** FAST PATH **
            return(status);
        }
        else
        //
        // no irp was returned... the client just took some of the bytes..
        //
        if (status == STATUS_SUCCESS)
        {

            // count the bytes received so far.
            pConnectEle->BytesRcvd += ClientBytesTaken;
            *BytesTaken += ClientBytesTaken;

            //
            // look at how much data was taken and adjust some counts
            //
            if (pConnectEle->BytesRcvd == pConnectEle->TotalPcktLen)
            {
                // ** FAST PATH **
                CHECK_PTR(pConnectEle);
                pConnectEle->BytesRcvd = 0; // reset for the next session pdu
                return(status);
            }
            else
            if (pConnectEle->BytesRcvd > pConnectEle->TotalPcktLen)
            {
                //IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Too Many Bytes Rcvd!! Rcvd# = %d, TotalLen = %d\n",
                            pConnectEle->BytesRcvd,pConnectEle->TotalPcktLen));

                ASSERTMSG("Nbt:Client Took Too Much Data!!!\n",0);

                //
                // try to recover by saying that the client took all of the
                // data so at least the transport is not confused too
                //
                *BytesTaken = BytesIndicated;

            }
            else
            // the client did not take all of the data so
            // keep track of the fact
            {
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("NBT:Client took Indication BytesRcvd=%X, TotalLen=%X BytesAvail %X ClientTaken %X\n",
                            pConnectEle->BytesRcvd,
                            pConnectEle->TotalPcktLen,
                            BytesAvailable,
                            ClientBytesTaken));

                //
                // the next time the client sends down a receive buffer
                // the code will pass it to the transport and decrement the
                // ReceiveIndicated counter which is set in Tdihndlr.c

            }
        }
        else
        if (status == STATUS_DATA_NOT_ACCEPTED)
        {
            // client has not taken ANY data...
            //
            // In this case the *BytesTaken is set to 4, the session hdr.
            // since we really have taken that data to setup the PduSize
            // in the pConnEle structure.
            //

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt.RcvHandlrNotOs: Status DATA NOT ACCEPTED returned from client Avail %X %X\n",
                    BytesAvailable,pConnectEle));

            // the code in tdihndlr.c normally looks after incrementing
            // the ReceiveIndicated count for data that is not taken by
            // the client, but if it is a zero length send that code cannot
            // detect it, so we put code here to handle that case
            //
            // It is possible for the client to do a disconnect after
            // we release the spin lock on pLowerConn to call the Client's
            // disconnect indication.  If that occurs, do not overwrite
            // the StateProc with PartialRcv
            //
            if ((pConnectEle->TotalPcktLen == 0) &&
                (pConnectEle->state == NBT_SESSION_UP))
            {
                SET_STATERCV_LOWER(pLowerConn, PARTIAL_RCV, PartialRcv);
                CHECK_PTR(pConnectEle);
                pConnectEle->ReceiveIndicated = 0;  // zero bytes waiting for client
            }
            else
            {
                //
                // if any bytes were taken (i.e. the session hdr) then
                // return status success. (otherwise the status is
                // statusNotAccpeted).
                //
                if (*BytesTaken)
                {
                    status = STATUS_SUCCESS;
                }
            }

            //
            // the next time the client sends down a receive buffer
            // the code will pass it to the transport and decrement this
            // counter.
        }
        else
            ASSERT(0);


        return(status);

    }
#ifdef VXD
    //
    // there is always a receive event handler in the Nt case - it may
    // be the default handler, but it is there, so no need for test.
    //
    else
    {
        //
        // there is no client buffer to pass the data to, so keep
        // track of the fact so when the next client buffer comes down
        // we can get the data from the transport.
        //
        KdPrint(("NBT:Client did not have a Buffer posted, rcvs indicated =%X,BytesRcvd=%X, TotalLen=%X\n",
                    pConnectEle->ReceiveIndicated,
                    pConnectEle->BytesRcvd,
                    pConnectEle->TotalPcktLen));

        // the routine calling this one increments ReceiveIndicated and sets the
        // state to PartialRcv to keep track of the fact that there is data
        // waiting in the transport
        //
        return(STATUS_DATA_NOT_ACCEPTED);
    }
#endif
}

//----------------------------------------------------------------------------
__inline
VOID
DerefLowerConnFast(
    IN tLOWERCONNECTION *pLowerConn,
    IN tCONNECTELE      *pConnEle,
    IN CTELockHandle    OldIrq
    )
/*++

Routine Description:

    This routine dereferences the lower connection and if someone has
    tried to do that during the execution of the routine that called
    this one, the pConnEle is dereferenced too.

Arguments:


Return Value:


--*/

{
    if (pLowerConn->RefCount > 1)
    {
        // This is the FAST PATH
        IF_DBG(NBT_DEBUG_REF)
            KdPrint(("\t--pLowerConn=<%x:%d->%d>, <%d:%s>\n",
                pLowerConn,pLowerConn->RefCount,(pLowerConn->RefCount-1),__LINE__,__FILE__));
        pLowerConn->RefCount--; 
        ASSERT (pLowerConn->References[REF_LOWC_RCV_HANDLER]--);
        CTESpinFree(pLowerConn,OldIrq);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, FALSE);
    }
}
//----------------------------------------------------------------------------
VOID
DpcGetRestOfIndication(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine is called when the client has been  indicated with more
    data than they will take and there is a rcv buffer on their RcvHead
    list when completion rcv runs.

Arguments:


Return Value:


--*/

{
    NTSTATUS            status;
    CTELockHandle       OldIrq;
    tCONNECTELE         *pConnEle;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    tLOWERCONNECTION    *pLowerConn=(tLOWERCONNECTION *)Context;
    PLIST_ENTRY         pEntry;

    CTEMemFree((PVOID)pDpc);

    CTESpinLockAtDpc(&NbtConfig.JointLock);

    // a disconnect indication can come in any time and separate the lower and
    // upper connections, so check for that
    if (!pLowerConn->pUpperConnection || pLowerConn->StateRcv != PARTIAL_RCV)
    {
        PUSH_LOCATION(0xA4);
        //
        // Dereference pLowerConn
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, TRUE);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        return;
    }

    CTESpinLockAtDpc(pLowerConn);

    pConnEle = (tCONNECTELE *)pLowerConn->pUpperConnection;
    if (!IsListEmpty(&pConnEle->RcvHead))
    {
        PUSH_LOCATION(0xA5);
        pEntry = RemoveHeadList(&pConnEle->RcvHead);

        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);

        pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&OldIrq);
        IoSetCancelRoutine(pIrp,NULL);
        IoReleaseCancelSpinLock(OldIrq);

        //
        // call the same routine that the client would call to post
        // a recv buffer, except now we are in the PARTIAL_RCV state
        // and the buffer will be passed to the transport.
        //
        status = NTReceive (pLowerConn->pDeviceContext, pIrp);
    }
    else
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        PUSH_LOCATION(0xA6);
    }
    //
    // Dereference pLowerConn
    //
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, FALSE);
}

//----------------------------------------------------------------------------
VOID
DpcHandleNewSessionPdu (
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine simply calls HandleNewSessionPdu from a Dpc started in
    NewSessionCompletionRoutine.

Arguments:


Return Value:


--*/

{
    CTEMemFree((PVOID)pDpc);


    HandleNewSessionPdu((tLOWERCONNECTION *)Context,
                        PtrToUlong(SystemArgument1),
                        PtrToUlong(SystemArgument2));

}

//----------------------------------------------------------------------------
VOID
HandleNewSessionPdu (
    IN  tLOWERCONNECTION *pLowerConn,
    IN  ULONG           Offset,
    IN  ULONG           ToGet
    )
/*++

Routine Description:

    This routine handles the case when a session pdu starts in the middle of
    a data indication from the transport. It gets an Irp from the free list
    and formulates a receive to pass to the transport to get that data.  The
    assumption is that the client has taken all data preceding the next session
    pdu. If the client hasn't then this routine should not be called yet.

Arguments:


Return Value:

    pConnectionContext      - connection context returned to the transport(connection to use)

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    ULONG               BytesTaken;
    PIRP                pIrp;
    PFILE_OBJECT        pFileObject;
    PMDL                pMdl;
    ULONG               BytesToGet;
    tCONNECTELE         *pConnEle;

    pIrp = NULL;
    BytesTaken = 0;

    // we grab the joint lock because it is needed to separate the lower and
    // upper connections, so with it we can check if they have been separated.
    //
    CTESpinLockAtDpc(&NbtConfig.JointLock);
    pConnEle = pLowerConn->pUpperConnection;

    // a disconnect indication can come in any time and separate the lower and
    // upper connections, so check for that
    if (!pLowerConn->pUpperConnection)
    {
        //
        // remove the reference from CompletionRcv
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, TRUE);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        return;
    }

    //
    // get an Irp from the list
    //
    status = GetIrp(&pIrp);
    if (!NT_SUCCESS(status))
    {
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        KdPrint(("Nbt:Unable to get an Irp - Closing Connection!!\n",0));
        status = OutOfRsrcKill(pLowerConn);
        //
        // remove the reference from CompletionRcv
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, FALSE);
        return;
    }

    CTESpinLockAtDpc(pLowerConn);
    //
    // be sure the connection has not disconnected in the meantime...
    //
    if (pLowerConn->State != NBT_SESSION_UP)
    {
        REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
        ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                    &pIrp->Tail.Overlay.ListEntry,
                                    &NbtConfig.LockInfo.SpinLock);
        CTESpinFreeAtDpc(pLowerConn);
        //
        // remove the reference from CompletionRcv
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER, TRUE);
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        return;
    }

    pFileObject = pLowerConn->pFileObject;
    ASSERT (pFileObject->Type == IO_TYPE_FILE);

    // use the indication buffer for the receive.
    pMdl = pLowerConn->pIndicateMdl;

    // this flag is set below so we know if there is data in the indicate buffer
    // or not.
    if (Offset)
    {
        PVOID       NewAddress;
        PMDL        pNewMdl;

        // there is still data in the indication buffer ,so only
        // fill the empty space.  This means adjusting the Mdl to
        // to only map the last portion of the Indication Buffer
        NewAddress = (PVOID)((PCHAR)MmGetMdlVirtualAddress(pMdl)
                            + Offset);

        // create a partial MDL so that the new data is copied after the existing data
        // in the MDL.
        //
        // 0 for length means map the rest of the buffer
        //
        pNewMdl = pConnEle->pNewMdl;

        IoBuildPartialMdl(pMdl,pNewMdl,NewAddress,0);

        pMdl = pNewMdl;

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:Mapping IndicBuffer to partial Mdl Offset=%X, ToGet=%X %X\n",
                    Offset,ToGet,
                    pLowerConn));
    }
    else
    {
        CHECK_PTR(pLowerConn);
        pLowerConn->BytesInIndicate = 0;
    }

    //
    // Only get the amount of data specified, which is either the 4 byte header
    // or the rest of the pdu so that we never have
    // more than one session pdu in the indicate buffer.
    //
    BytesToGet = ToGet;

    ASSERT (pFileObject->Type == IO_TYPE_FILE);
    TdiBuildReceive(
        pIrp,
        IoGetRelatedDeviceObject(pFileObject),
        pFileObject,
        NewSessionCompletionRoutine,
        (PVOID)pLowerConn,
        pMdl,
        (ULONG)TDI_RECEIVE_NORMAL,
        BytesToGet); // only ask for the number of bytes left and no more

    CTESpinFreeAtDpc(pLowerConn);
    CTESpinFreeAtDpc(&NbtConfig.JointLock);

    CHECK_COMPLETION(pIrp);
    status = IoCallDriver(IoGetRelatedDeviceObject(pFileObject),pIrp);

}

//----------------------------------------------------------------------------
NTSTATUS
NewSessionCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of the receive to get the remaining
    data left in the transport when a session PDU starts in the middle of
    an indication from the transport.  This routine is run as the completion
    of a recv Irp passed to the transport by NBT, to get the remainder of the
    data in the transport.

    The routine then calls the normal receive handler, which can either
    consume the data or pass back an Irp.  If an Irp is passed back then
    the data is copied into that irp in this routine.

Arguments:


Return Value:

    pConnectionContext      - connection context returned to the transport(connection to use)

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    ULONG               BytesTaken;
    tCONNECTELE         *pConnEle;
    PVOID               pData;
    KIRQL               OldIrq;
    PMDL                pMdl;
    ULONG               BytesIndicated;
    ULONG               BytesAvailable;
    PKDPC               pDpc;
    tLOWERCONNECTION    *pLowerConn;
    ULONG               Length;
    ULONG               PduLen;
    PIRP                pRetIrp;

    // we grab the joint lock because it is needed to separate the lower and
    // upper connections, so with it we can check if they have been separated.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pLowerConn = (tLOWERCONNECTION *)pContext;
    pConnEle = pLowerConn->pUpperConnection;

    CTESpinLockAtDpc(pLowerConn);

    // a disconnect indication can come in any time and separate the lower and
    // upper connections, so check for that
    //
    if (!pConnEle)
    {
        CTESpinFreeAtDpc(&NbtConfig.JointLock);
        status = STATUS_UNSUCCESSFUL;
        goto ExitRoutine;
    }

    CTESpinFreeAtDpc(&NbtConfig.JointLock);


    BytesTaken = 0;

    pMdl = pLowerConn->pIndicateMdl;

    pData = MmGetMdlVirtualAddress(pMdl);

    //
    // The Indication buffer may have more data in it than what we think
    // was left in the transport, because the transport may have received more
    // data in the intervening time.  Check for this case.
    //
    if (pIrp->IoStatus.Information > pConnEle->BytesInXport)
    {
        // no data left in transport
        //
        CHECK_PTR(pConnEle);
        pConnEle->BytesInXport = 0;
    }
    else
    {
        //
        // subtract what we just retrieved from the transport, from the count
        // of data left in the transport
        //
        pConnEle->BytesInXport -= (ULONG)pIrp->IoStatus.Information;
    }

    //
    // there may be data still in the indication buffer,
    // so add that amount to what we just received.
    //
    pLowerConn->BytesInIndicate += (USHORT)pIrp->IoStatus.Information;
    BytesIndicated = pLowerConn->BytesInIndicate;

    // put the irp back on its free list
    CHECK_PTR(pIrp);
    pIrp->MdlAddress = NULL;

    REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
    ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                &pIrp->Tail.Overlay.ListEntry,
                                &NbtConfig.LockInfo.SpinLock);

    //
    // we need to set the bytes available to be the data in the Xport + the
    // bytes in the indicate buffer, so that
    // ReceiveIndicated gets set to the correct value if the client does
    // not take all of data
    //
    BytesAvailable = pConnEle->BytesInXport + BytesIndicated;
    pRetIrp = NULL;

    // if the number of bytes is 4 then we just have the header and must go
    // back to the transport for the rest of the pdu, or we have a keep
    // alive pdu...
    //
    //
    // This could be a session keep alive pdu so check the pdu type.  Keep
    // alives just go to the RcvHndlrNotOs routine and return, doing nothing.
    // They have a length of zero, so the overall length is 4 and they could
    // be confused for session pdus otherwise.
    //
    status = STATUS_SUCCESS;
    if (BytesIndicated == sizeof(tSESSIONHDR))
    {
        PUSH_LOCATION(0x1e)
        if (((tSESSIONHDR UNALIGNED *)pData)->Type == NBT_SESSION_MESSAGE)
        {
            // if there is still data in the transport we must send down an
            // irp to get the data, however, if there is no data left in
            // the transport, then the data will come up on its own, into
            // the indicate_buffer case in the main Receivehandler.
            //
            if (pConnEle->BytesInXport)
            {
                PUSH_LOCATION(0x1e);

                // tell the DPC routine to get the data at an offset of 4 for length Length

                //
                // this is the first indication to find out how large the pdu is, so
                // get the length and go get the rest of the pdu.
                //
                Length = myntohl(((tSESSIONHDR UNALIGNED *)pData)->UlongLength);

                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:Got Pdu Hdr in sessioncmplionroutine, PduLen =%X\n",Length));

                //  it is possible to get a zero length pdu, in which case we
                // do NOT need to go to the transport to get more data
                //
                if (Length)
                {
                    PUSH_LOCATION(0x1e);
                    //
                    // now go get this amount of data and add it to the header
                    //
                    CTESpinFree(pLowerConn,OldIrq);
                    if (pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('r')))
                    {
                        // check that the pdu is not going to overflow the indicate buffer.
                        //
                        if (Length > NBT_INDICATE_BUFFER_SIZE - sizeof(tSESSIONHDR))
                        {
                            Length = NBT_INDICATE_BUFFER_SIZE - sizeof(tSESSIONHDR);
                        }
                        ASSERTMSG("Nbt:Getting ZERO bytes from Xport!!\n",Length);

                        KeInitializeDpc(pDpc, DpcHandleNewSessionPdu, (PVOID)pLowerConn);
                        KeInsertQueueDpc(pDpc, ULongToPtr(sizeof(tSESSIONHDR)), ULongToPtr(Length));

                        // clean up the partial mdl since we are going to turn around and reuse
                        // it in HandleNewSessionPdu above..
                        //
                        // THIS CALL SHOULD NOT BE NEEDED SINCE THE INDICATE BUFFER IS NON_PAGED
                        // POOL
//                        MmPrepareMdlForReuse(pConnEle->pNewMdl);

                        // return this status to stop to tell the io subsystem to stop processing
                        // this irp when we return it.
                        //
                        return(STATUS_MORE_PROCESSING_REQUIRED);
                    }

                    OutOfRsrcKill(pLowerConn);
                    CTESpinLock (pLowerConn,OldIrq);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ExitRoutine;
                }
            }
        }
    }

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt:NewSessComplRcv BytesinXport= %X,InIndicate=%X Indic. %X,Avail=%X %X\n",
            pConnEle->BytesInXport,pLowerConn->BytesInIndicate,BytesIndicated,
            BytesAvailable,pConnEle->pLowerConnId));

    if (!NT_SUCCESS(pIrp->IoStatus.Status))
    {
        ASSERTMSG("Nbt:Not Expecting a Bad Status Code\n",0);
        goto ExitRoutine;
    }

    //
    // check if we have a whole pdu in the indicate buffer or not.  IF not
    // then just return and wait for more data to hit the TdiReceiveHandler
    // code. This check passes KeepAlives correctly since they have a pdu
    // length of 0, and adding the header gives 4, their overall length.
    //
    PduLen = myntohl(((tSESSIONHDR UNALIGNED *)pData)->UlongLength);
    if ((BytesIndicated < PduLen + sizeof(tSESSIONHDR)) &&
        (BytesIndicated != NBT_INDICATE_BUFFER_SIZE))

    {
        PUSH_LOCATION(0x1f);

        IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Returning in NewSessionCompletion BytesIndicated = %X\n", BytesIndicated));
    }
    else
    {
        PUSH_LOCATION(0x20);

        status = CopyDataandIndicate (NULL,
                                     (PVOID)pLowerConn,
                                     0,            // rcv flags
                                     BytesIndicated,
                                     BytesAvailable,
                                     &BytesTaken,
                                     pData,
                                     (PVOID)&pRetIrp);

    }

ExitRoutine:
    //
    // check if an irp is passed back, so we don't Deref in that case.
    //
    if (status != STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // quickly check if we can just decrement the ref count without calling
        // NBT_DEREFERENCE_LOWERCONN
        //
        PUSH_LOCATION(0x51);
        DerefLowerConnFast(pLowerConn,pConnEle,OldIrq);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}
//----------------------------------------------------------------------------
NTSTATUS
NtBuildIndicateForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    )
/*++

Routine Description:

    This routine sets up the indicate buffer to get data from the transport
    when the indicate buffer already has some data in it.  A partial MDL is
    built and the attached to the irp.
    before we indicate.

Arguments:


Return Value:


    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS                    status;
    PIRP                        pIrp;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    PIO_STACK_LOCATION          pIrpSp;
    tCONNECTELE                 *pConnEle;
    PMDL                        pNewMdl;
    PVOID                       NewAddress;

    //
    // get an Irp from the list
    //

    status = GetIrp(&pIrp);

    if (!NT_SUCCESS(status))
    {
        KdPrint(("NBT:Unable to get Irp, Kill connection\n"));

        CTESpinFreeAtDpc(pLowerConn);
        OutOfRsrcKill(pLowerConn);
        CTESpinLockAtDpc(pLowerConn);

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pConnEle= pLowerConn->pUpperConnection;

    NewAddress = (PVOID)((PCHAR)MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl)
                        + pLowerConn->BytesInIndicate);

    // create a partial MDL so that the new data is copied after the existing data
    // in the MDL.
    //
    // 0 for length means map the rest of the buffer
    //
    pNewMdl = pConnEle->pNewMdl;

    IoBuildPartialMdl(pLowerConn->pIndicateMdl,pNewMdl,NewAddress,0);

    ASSERT (pLowerConn->pFileObject->Type == IO_TYPE_FILE);
    TdiBuildReceive(
        pIrp,
        IoGetRelatedDeviceObject(pLowerConn->pFileObject),
        pLowerConn->pFileObject,
        NewSessionCompletionRoutine,
        (PVOID)pLowerConn,
        pNewMdl,
        (ULONG)TDI_RECEIVE_NORMAL,
        Length);

    //
    // we need to set the next Irp stack location because this irp is returned
    // as a return parameter rather than being passed through IoCallDriver
    // which increments the stack location itself
    //
    ASSERT(pIrp->CurrentLocation > 1);
    IoSetNextIrpStackLocation(pIrp);

    *ppIrp = (PVOID)pIrp;

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NtBuildIrpForReceive (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               Length,
    OUT PVOID               *ppIrp
    )
/*++

Routine Description:

    This routine gets an Irp to be used to receive data and hooks the indication
    Mdl to it, so we can accumulate at least 128 bytes of data for the client
    before we indicate.

Arguments:


Return Value:


    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS                    status;
    PIRP                        pIrp;
    PTDI_REQUEST_KERNEL_RECEIVE pParams;
    PIO_STACK_LOCATION          pIrpSp;

    //
    // get an Irp from the list
    //
    status = GetIrp(&pIrp);

    if (!NT_SUCCESS(status))
    {
        KdPrint(("NBT:Unable to get Irp, Kill connection\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CHECK_PTR(pLowerConn);
    pLowerConn->BytesInIndicate = 0;

    ASSERT (pLowerConn->pFileObject->Type == IO_TYPE_FILE);
    TdiBuildReceive(
        pIrp,
        IoGetRelatedDeviceObject(pLowerConn->pFileObject),
        pLowerConn->pFileObject,
        NewSessionCompletionRoutine,
        (PVOID)pLowerConn,
        pLowerConn->pIndicateMdl,
        (ULONG)TDI_RECEIVE_NORMAL,
        Length);

    //
    // we need to set the next Irp stack location because this irp is returned
    // as a return parameter rather than being passed through IoCallDriver
    // which increments the stack location itself
    //
    ASSERT(pIrp->CurrentLocation > 1);
    IoSetNextIrpStackLocation(pIrp);

    *ppIrp = (PVOID)pIrp;

    return(STATUS_SUCCESS);
}

#pragma inline_depth(0)
//----------------------------------------------------------------------------
NTSTATUS
CopyDataandIndicate(
    IN PVOID                ReceiveEventContext,
    IN PVOID                ConnectionContext,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    )
/*++

Routine Description:


    This routine combines data indicated with the indicate buffer to
    indicate the total to the client. Any bytes Indicated are those bytes
    in the indicate buffer. Bytes available adds in any bytes in the transport.

    The idea here is to copy as much as possible from the indicate buffer and
    then pass back an irp if there is still more data in the transport.  If
    no data left in the transport, this routine completes the client irp and
    returns STATUS_SUCCESS.

Arguments:


Return Value:


    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS                    status;
    tLOWERCONNECTION            *pLowerConn;
    tCONNECTELE                 *pConnEle;
    ULONG                       BytesCopied;
    ULONG                       Indicated;
    ULONG                       Available;
    ULONG                       Taken;
    ULONG                       AmountAlreadyInIndicateBuffer;
    PVOID                       pBuffer;
    PIRP                        pIrp;
    BOOLEAN                     bReIndicate=FALSE;
    ULONG                       RemainingPdu;
    ULONG                       ToCopy;
    PKDPC                       pDpc;
    ULONG                       SaveInXport;
    ULONG                       PduSize;

    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pConnEle = pLowerConn->pUpperConnection;

    AmountAlreadyInIndicateBuffer = pLowerConn->BytesInIndicate;

    //
    // set the parameters for the call to the TdiReceiveHandler routine
    //

    Indicated = BytesIndicated;
    Available = BytesAvailable;
    Taken = 0;


//    ASSERT(pLowerConn->StateRcv == INDICATE_BUFFER);

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:Amount In Indicate = %X\n",AmountAlreadyInIndicateBuffer));

    // now that we have 128 bytes (plus the session hdr = 132 total) we
    // can indicate to the client

    pBuffer = MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl);

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
    KdPrint(("Nbt:FromCopyData, BytesAvail= %X,BytesInd= %X,BytesRcvd= %X,Amount=%X, %X,state=%X,RcvEC=%X\n",
                    Available,Indicated,pConnEle->BytesRcvd,
                    AmountAlreadyInIndicateBuffer,pLowerConn,pLowerConn->StateRcv,
                    ReceiveEventContext));

    pIrp = NULL;

    //
    // Reset this count so that the routine processes the Session header correctly
    //
    CHECK_PTR(pConnEle);
    pConnEle->BytesRcvd = 0;
    PUSH_LOCATION(0x21);
    status = RcvHandlrNotOs(
                    NULL,
                    ConnectionContext,
                    ReceiveFlags,
                    Indicated,
                    Available,
                    &Taken,
                    pBuffer,
                    (PVOID)&pIrp
                    );

    //
    // if the connection has disonnected, then just return
    //
    if (!pLowerConn->pUpperConnection)
    {
        *BytesTaken = BytesAvailable;
        return(STATUS_SUCCESS);
    }

    // do not use pConnEle->TotalPcktLen here becauase it won't be set for
    // keep alives - must use actual buffer to get length.
    PduSize = myntohl(((tSESSIONHDR UNALIGNED *)pBuffer)->UlongLength) + sizeof(tSESSIONHDR);

    RemainingPdu = pConnEle->TotalPcktLen - pConnEle->BytesRcvd;

    if (Taken <= pLowerConn->BytesInIndicate)
    {
        pLowerConn->BytesInIndicate -= (USHORT)Taken;
    }
    else
    {
        pLowerConn->BytesInIndicate = 0;
    }

    if (pIrp)
    {
        PIO_STACK_LOCATION            pIrpSp;
        PTDI_REQUEST_KERNEL_RECEIVE   pParams;
        ULONG                         ClientRcvLen;

        PUSH_LOCATION(0x22);
        //
        // BytesInXport will be recalculated by ProcessIrp based on BytesAvailable
        // and the ClientRcvLength, so set it to 0 here.
        //
        SaveInXport = pConnEle->BytesInXport;
        CHECK_PTR(pConnEle);
        pConnEle->BytesInXport = 0;
        status = ProcessIrp(pLowerConn,
                            pIrp,
                            pBuffer,
                            &Taken,
                            Indicated,
                            Available);

        //
        // copy the data in the indicate buffer that was not taken by the client
        // into the MDL and then update the bytes taken and pass the irp on downwar
        // to the transport
        //
        ToCopy = Indicated - Taken;

        // the Next stack location has the correct info in it because we
        // called TdiRecieveHandler with a null ReceiveEventContext,
        // so that routine does not increment the stack location
        //
        pIrpSp = IoGetNextIrpStackLocation(pIrp);
        pParams = (PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;
        ClientRcvLen = pParams->ReceiveLength;

        // did the client's Pdu fit entirely into the indication buffer?
        //
        if (ClientRcvLen <= ToCopy)
        {
            PUSH_LOCATION(0x23);
            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:Took some(or all) RemainingPdu= %X, ClientRcvLen= %X,InXport=%X %X\n",
                        RemainingPdu,ClientRcvLen,pConnEle->BytesInXport,pLowerConn));

            // if ProcessIrp has recalculated the bytes in the Xport
            // then set it back to where it should be, Since ProcessIrp will
            // put all not taken bytes as bytes in the transport - but some
            // of the bytes are still in the indicate buffer.
            //
            pConnEle->BytesInXport = SaveInXport;

            // it could be a zero length send where the client returns a null
            // mdl, or the client returns an mdl and the RcvLen is really zero.
            //
            if (pIrp->MdlAddress && ClientRcvLen)
            {
                TdiCopyBufferToMdl(pBuffer,     // indicate buffer
                                   Taken,       // src offset
                                   ClientRcvLen,
                                   pIrp->MdlAddress,
                                   0,                 // dest offset
                                   &BytesCopied);
            }
            else
                BytesCopied = 0;

            //
            // check for data still in the transport - subtract data copied to
            // Irp, since Taken was already subtracted.
            //
            pLowerConn->BytesInIndicate -= (USHORT)BytesCopied;

            *BytesTaken = Taken + BytesCopied;
            ASSERT(BytesCopied == ClientRcvLen);

            // the client has received all of the data, so complete his irp
            //
            pIrp->IoStatus.Information = BytesCopied;
            pIrp->IoStatus.Status = STATUS_SUCCESS;

            // since we are completing it and TdiRcvHandler did not set the next
            // one.
            //
            ASSERT(pIrp->CurrentLocation > 1);

            // since we are completing the irp here, no need to call
            // this, because it will complete through completionrcv.
            IoSetNextIrpStackLocation(pIrp);

            // there should not be any data in the indicate buffer since it
            // only holds either 132 bytes or a whole pdu unless the client
            // receive length is too short...
            //
            if (pLowerConn->BytesInIndicate)
            {
                PUSH_LOCATION(0x23);
                // when the irp goes through completionRcv it should set the
                // state to PartialRcv and the next posted buffer from
                // the client should pickup this data.
                CopyToStartofIndicate(pLowerConn,(Taken+BytesCopied));
            }
            else
            {
                //
                // this will complete through CompletionRcv and for that
                // reason it will get any more data left in the transport.  The
                // Completion routine will set the correct state for the rcv when
                // it processes this Irp ( to INDICATED, if needed). ProcessIrp
                // may have set ReceiveIndicated, so that CompletionRcv will
                // set the state to PARTIAL_RCV when it runs.
                //
                SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
            }

            CTESpinFreeAtDpc(pLowerConn);
            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            CTESpinLockAtDpc(pLowerConn);
            //
            // this was undone by CompletionRcv, so redo them, since the
            // caller will undo them again.
            //
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
            return(STATUS_SUCCESS);
        }
        else
        {

            PUSH_LOCATION(0x24);
            //
            // there is still data that we need to get to fill the PDU.  There
            // may be more data left in the transport or not after the irp is
            // filled.
            // In either case the Irps' Mdl must be adjusted to account for
            // filling part of it.
            //
            TdiCopyBufferToMdl(pBuffer,     // IndicateBuffer
                               Taken,       // src offset
                               ToCopy,
                               pIrp->MdlAddress,
                               0,                 // dest offset
                               &BytesCopied);

            //
            // save the Mdl so we can reconstruct things later
            //
            pLowerConn->pMdl  = pIrp->MdlAddress;
            pConnEle->pNextMdl = pIrp->MdlAddress;
            ASSERT(pIrp->MdlAddress);
            //
            // The irp is being passed back to the transport, so we NULL
            // our ptr to it so we don't try to cancel it on a disconnect
            //
            CHECK_PTR(pConnEle);
            pConnEle->pIrpRcv = NULL;

            // Adjust the number of bytes in the Mdl chain so far since the
            // completion routine will only count the bytes filled in by the
            // transport
            //
            pConnEle->BytesRcvd += BytesCopied;

            *BytesTaken = BytesIndicated;

            //
            // clear the number of bytes in the indicate buffer since the client
            // has taken more than the data left in the Indicate buffer
            //
            CHECK_PTR(pLowerConn);
            pLowerConn->BytesInIndicate = 0;

            // decrement the client rcv len by the amount already put into the
            // client Mdl
            //
            ClientRcvLen -= BytesCopied;
            //
            // if ProcessIrp did recalculate the bytes in the transport
            // then set back to what it was.  Process irp will do this
            // recalculation if the clientrcv buffer is too short only.
            //
            pConnEle->BytesInXport = SaveInXport;

            //
            // adjust the number of bytes downward due to the client rcv
            // buffer
            //
            if (ClientRcvLen < SaveInXport)
            {
                PUSH_LOCATION(0x24);
                pConnEle->BytesInXport -= ClientRcvLen;
            }
            else
            {
                pConnEle->BytesInXport = 0;
            }

            // ProcessIrp will set bytesinXport and ReceiveIndicated - since
            // the indicate buffer is empty that calculation of BytesInXport
            // will be correct.
            //

            // We MUST set the state to FILL_IRP so that completion Rcv
            // undoes the partial MDL stuff - i.e. it puts the original
            // MdlAddress in the Irp, rather than the partial Mdl address.
            // CompletionRcv will set the state to partial Rcv if ReceiveIndicated
            // is not zero.
            //
            SET_STATERCV_LOWER(pLowerConn, FILL_IRP, FillIrp);

            // the client is going to take more data from the transport with
            // this Irp.  Set the new Rcv Length that accounts for the data just
            // copied to the Irp.
            //
            pParams->ReceiveLength = ClientRcvLen;

            // keep track of data in MDL so we know when it is full and we need to
            // return it to the user - ProcessIrp set it to ClientRcvLen, so
            // shorten it here.
            //
            pConnEle->FreeBytesInMdl -= BytesCopied;

            IF_DBG(NBT_DEBUG_INDICATEBUFF)
            KdPrint(("Nbt:ClientRcvLen = %X, LeftinXport= %X RemainingPdu= %X %X\n",ClientRcvLen,
                            pConnEle->BytesInXport,RemainingPdu,pLowerConn));


            // Build a partial Mdl to represent the client's Mdl chain since
            // we have copied data to it, and the transport must copy
            // more data to it after that data.
            //
            MakePartialMdl(pConnEle,pIrp,BytesCopied);

            *ppIrp = pIrp;

            // increments the stack location, since TdiReceiveHandler did not.
            //
            if (ReceiveEventContext)
            {
                ASSERT(pIrp->CurrentLocation > 1);
                IoSetNextIrpStackLocation(pIrp);

                return(STATUS_MORE_PROCESSING_REQUIRED);
            }
            else
            {
                // pass the Irp to the transport since we were called from
                // NewSessionCompletionRoutine
                //
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                    KdPrint(("Nbt:Calling IoCallDriver\n"));
                ASSERT(pIrp->CurrentLocation > 1);

                CTESpinFreeAtDpc(pLowerConn);
                CHECK_COMPLETION(pIrp);
                ASSERT (pLowerConn->pFileObject->Type == IO_TYPE_FILE);
                IoCallDriver(IoGetRelatedDeviceObject(pLowerConn->pFileObject),pIrp);
                CTESpinLockAtDpc(pLowerConn);

                return(STATUS_MORE_PROCESSING_REQUIRED);
            }
        }
    }
    else
    {
        PUSH_LOCATION(0x54);
        //
        // no Irp passed back, the client just took some or all of the data
        //
        *BytesTaken = Taken;
        pLowerConn->BytesRcvd += Taken - sizeof(tSESSIONHDR);

        ASSERT(*BytesTaken < 0x7FFFFFFF );

        //
        // if more than the indicate buffer is taken, then the client
        // is probably trying to say it doesn't want any more of the
        // message.
        //
        if (Taken > BytesIndicated)
        {
            //
            // in this case the client has taken more than the indicated.
            // We set bytesavailable to the message length in RcvHndlrNotOs,
            // so the client has probably said BytesTaken=BytesAvailable.
            // So kill the connection
            // because we have no way of handling this case here, since
            // part of the message may still be in the transport, and we
            // might have to send the indicate buffer down there multiple
            // times to get all of it...a mess!  The Rdr only sets bytestaken =
            // bytesAvailable under select error conditions anyway.
            //
            CTESpinFreeAtDpc(pLowerConn);
            OutOfRsrcKill(pLowerConn);
            CTESpinLockAtDpc(pLowerConn);

            *BytesTaken = BytesAvailable;

        }
        else if (pLowerConn->StateRcv == PARTIAL_RCV)
        {
            // this may be a zero length send -that the client has
            // decided not to accept.  If so then the state will be set
            // to PartialRcv.  In this case do NOT go down to the transport
            // and get the rest of the data, but wait for the client
            // to post a rcv buffer.
            //
            PUSH_LOCATION(0x54);
            return(STATUS_SUCCESS);
        }
        else if (Taken == PduSize)
        {
            //
            // Must have taken all of the pdu data, so check for
            // more data available - if so send down the indicate
            // buffer to get it.
            //
            if (pConnEle->BytesInXport)
            {
                PUSH_LOCATION(0x28);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:CopyData BytesInXport= %X, %X\n",pConnEle->BytesInXport,
                                    pLowerConn));

                //
                // there is still data in the transport so Q a Dpc to use
                // the indicate buffer to get the data
                //
                pDpc = NbtAllocMem(sizeof(KDPC),NBT_TAG('s'));

                if (pDpc)
                {
                    KeInitializeDpc(pDpc, DpcHandleNewSessionPdu, (PVOID)pLowerConn);

                    SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, IndicateBuffer);

                    // get just the header first to see how large the pdu is
                    //
                    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_RCV_HANDLER);
                    KeInsertQueueDpc(pDpc,NULL,(PVOID)sizeof(tSESSIONHDR));
                }
                else
                {
                    CTESpinFreeAtDpc(pLowerConn);
                    OutOfRsrcKill(pLowerConn);
                    CTESpinLockAtDpc(pLowerConn);
                }
            }
            else
            {
                PUSH_LOCATION(0x29);
                //
                // clear the flag saying that we are using the indicate buffer
                //
                SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);
            }

            PUSH_LOCATION(0x2a);
            return(STATUS_SUCCESS);
        }
        else
        {
            //
            // the client may have taken all the data in the
            // indication!!, in which case return status success
            // Note: that we check bytes available here not bytes
            // indicated - since the client could take all indicated
            // data but still leave data in the transport. If the client
            // got told there was more available but only took the indicated,
            // the we need to do the else and track ReceiveIndicated, but if
            // Indicated == Available, then we take the if and wait for
            // another indication from the transport.
            //
            if (Taken == BytesAvailable)
            {
                PUSH_LOCATION(0x4);
                status = STATUS_SUCCESS;

            }
            else
            {

                // did not take all of the data in the Indication
                //

                PUSH_LOCATION(0x2b);
                IF_DBG(NBT_DEBUG_INDICATEBUFF)
                KdPrint(("Nbt:Took Part of indication... BytesRemaining= %X, LeftInXport= %X, %X\n",
                            pLowerConn->BytesInIndicate,pConnEle->BytesInXport,pLowerConn));

                //
                // The amount of data Indicated to the client should not exceed
                // the Pdu size, so check that, since this routine could get
                // called with bytesAvailable > than the Pdu size.
                //
                // That is checked above where we check if Taken > BytesIndicated.

                SaveInXport = pConnEle->BytesInXport;
                ASSERT(Taken <= PduSize);
                status = ClientTookSomeOfTheData(pLowerConn,
                                        Indicated,
                                        Available,
                                        Taken,
                                        PduSize);

                //
                // Since the data may be divided between some in the transport
                // and some in the indicate buffer do not let ClientTookSomeOf...
                // recalculate the amount in the transport, since it assumes all
                // untaken data is in the transport. Since the client did not
                // take of the indication, the Bytes in Xport have not changed.
                //
                pConnEle->BytesInXport = SaveInXport;
                //
                // need to move the data forward in the indicate buffer so that
                // it begins at the start of the buffer
                //
                if (Taken)
                {
                    CopyToStartofIndicate(pLowerConn,Taken);
                }

            }
        }

    }
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
TdiConnectHandler (
    IN PVOID                pConnectEventContext,
    IN int                  RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN PVOID                pUserData,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pConnectionContext,
    OUT PIRP                *ppAcceptIrp
    )
/*++

Routine Description:

    This routine is connect event handler.  It is invoked when a request for
    a connection has been received by the provider.  NBT accepts the connection
    on one of its connections in its LowerConnFree list

    Initially a TCP connection is setup with this port.  Then a Session Request
    packet is sent across the connection to indicate the name of the destination
    process.  This packet is received in the RcvHandler.

    For message-only mode, make session establishment automatic without the exchange of
    messages.  In this case, the best way to do this is to force the code through its paces.
    The code path for "inbound" setup includes AcceptCompletionRoutine, Inbound, and
    CompleteSessionSetup.  We do this by creating a fake session request and feeding it into
    the state machine.

    As part of connection/session establishment, Netbt must notify
    the consumer.  Normally this is done after connection establishment when the session request
    comes in.  We must move this process up so that the consumer gets his notification and
    yah/nay opportunity during connection acceptance, so we gets a chance to reject the connection.

Arguments:

    pConnectEventContext    - the context passed to the transport when this event was setup
    RemoteAddressLength     - the length of the source address (4 bytes for IP)
    pRemoteAddress          - a ptr to the source address
    UserDataLength          - the number of bytes of user data - includes the session Request hdr
    pUserData               - ptr the the user data passed in
    OptionsLength           - number of options to pass in
    pOptions                - ptr to the options

Return Value:

    pConnectionContext      - connection context returned to the transport(connection to use)

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    PFILE_OBJECT        pFileObject;
    PIRP                pRequestIrp;
    CONNECTION_CONTEXT  pConnectionId;
    tDEVICECONTEXT      *pDeviceContext;

    *pConnectionContext = NULL;

    // convert the context value into the device context record ptr
    pDeviceContext = (tDEVICECONTEXT *)pConnectEventContext;

    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(("pDeviceContxt = %X ConnectEv = %X",pDeviceContext,pConnectEventContext));
    ASSERTMSG("Bad Device context passed to the Connection Event Handler",
        pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT);

    // get an Irp from the list
    status = GetIrp(&pRequestIrp);

    if (!NT_SUCCESS(status))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // call the non-OS specific routine to find a free connection.

    status = ConnectHndlrNotOs(
                pConnectEventContext,
                RemoteAddressLength,
                pRemoteAddress,
                UserDataLength,
                pUserData,
                &pConnectionId);


    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIHNDLR)
            KdPrint(("NO FREE CONNECTIONS in connect handler\n"));

        // put the Irp back on its free list
        //
        REMOVE_FROM_LIST(&pRequestIrp->ThreadListEntry);
        ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                    &pRequestIrp->Tail.Overlay.ListEntry,
                                    &NbtConfig.LockInfo.SpinLock);
        NbtTrace(NBT_TRACE_INBOUND, ("ConnectHndlrNotOs return %!status!", status));

        return(STATUS_DATA_NOT_ACCEPTED);
    }

#ifdef _NETBIOSLESS
    //
    // MessageOnly mode.  Establish session automatically.
    //
    // ******************************************************************************************

    if (IsDeviceNetbiosless(pDeviceContext))
    {
        status = PerformInboundProcessing (pDeviceContext,
                                           (tLOWERCONNECTION *) pConnectionId,
                                           pRemoteAddress);
        if (!NT_SUCCESS(status))
        {
//            IF_DBG(NBT_DEBUG_TDIHNDLR)
                KdPrint(("MessageOnly connect processing rejected with status 0x%x\n", status));

            // put the Irp back on its free list
            //
            REMOVE_FROM_LIST(&pRequestIrp->ThreadListEntry);
            ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                        &pRequestIrp->Tail.Overlay.ListEntry,
                                        &NbtConfig.LockInfo.SpinLock);
            NbtTrace(NBT_TRACE_INBOUND, ("PerformInboundProecessing return %!status!", status));

            return(STATUS_DATA_NOT_ACCEPTED);
        }
    }
    // ******************************************************************************************
    //
    //
#endif

    pFileObject = ((tLOWERCONNECTION *)pConnectionId)->pFileObject;
    ASSERT (pFileObject->Type == IO_TYPE_FILE);

    TdiBuildAccept(
        pRequestIrp,
        IoGetRelatedDeviceObject(pFileObject),
        pFileObject,
        AcceptCompletionRoutine,
        (PVOID)pConnectionId,
        NULL,
        NULL);

    // we need to null the MDL address because the transport KEEPS trying to
    // release buffers!! which do not exist!!!
    //
    CHECK_PTR(pRequestIrp);
    pRequestIrp->MdlAddress = NULL;


    // return the connection id to accept the connect indication on.
    *pConnectionContext = (CONNECTION_CONTEXT)pConnectionId;
    *ppAcceptIrp = pRequestIrp;
    //
    // make the next stack location the current one.  Normally IoCallDriver
    // would do this but we are not going through IoCallDriver here, since the
    // Irp is just passed back with Connect Indication.
    //
    ASSERT(pRequestIrp->CurrentLocation > 1);
    IoSetNextIrpStackLocation(pRequestIrp);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


#ifdef _NETBIOSLESS
//----------------------------------------------------------------------------

static void
Inet_ntoa_nb(
    ULONG Address,
    PCHAR Buffer
    )
/*++

Routine Description:

This routine converts an IP address into its "dotted quad" representation.  The IP address is
expected to be in network byte order. No attempt is made to handle the other dotted notions as
defined in in.h.  No error checking is done: all address values are permissible including 0
and -1.  The output string is blank padded to 16 characters to make the name look like a netbios
name.

The string representation is in ANSI, not UNICODE.

The caller must allocate the storage, which should be 16 characters.

Arguments:

    Address - IP address in network byte order
    Buffer - Pointer to buffer to receive string representation, ANSI

Return Value:

void

--*/

{
    ULONG i;
    UCHAR byte, c0, c1, c2;
    PCHAR p = Buffer;

    for( i = 0; i < 4; i++ )
    {
        byte = (UCHAR) (Address & 0xff);

        c0 = byte % 10;
        byte /= 10;
        c1 = byte % 10;
        byte /= 10;
        c2 = byte;

        if (c2 != 0)
        {
            *p++ = c2 + '0';
            *p++ = c1 + '0';
        } else if (c1 != 0)
        {
            *p++ = c1 + '0';
        }
        *p++ = c0 + '0';

        if (i != 3)
            *p++ = '.';

        Address >>= 8;
    }

    // space pad up to 16 characters
    while (p < (Buffer + 16))
    {
        *p++ = ' ';
    }
} // Inet_ntoa1


//----------------------------------------------------------------------------

NTSTATUS
PerformInboundProcessing(
    tDEVICECONTEXT *pDeviceContext,
    tLOWERCONNECTION *pLowerConn,
    PTA_IP_ADDRESS pIpAddress
    )

/*++

Routine Description:

This routine is called by the connection handler to force the state machine through a session
establishment even though no message has been received.  We create a session request and feed
it into Inbound processing.  Inbound will find the listening consumer and give him a chance to
accept.

Arguments:

    pDeviceContext -
    pLowerConn -
    pIpAddress - Ip address of the source of the connect request

Return Value:

    NTSTATUS -

--*/

{
    ULONG status;
    ULONG BytesTaken;
    USHORT sLength;
    tSESSIONREQ *pSessionReq = NULL;
    PUCHAR pCopyTo;
    CHAR SourceName[16];

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.TdiConnectHandler: skipping session setup\n"));

    if (pIpAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    Inet_ntoa_nb( pIpAddress->Address[0].Address[0].in_addr, SourceName );

    // the length is the 4 byte session hdr length + the half ascii calling
    // and called names + the scope length times 2, one for each name
    //
    sLength = (USHORT) (sizeof(tSESSIONREQ)  + (NETBIOS_NAME_SIZE << 2) + (NbtConfig.ScopeLength <<1));
    pSessionReq = (tSESSIONREQ *)NbtAllocMem(sLength,NBT_TAG('G'));
    if (!pSessionReq)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("Out of resource for %!ipaddr!:%d",
            pIpAddress->Address[0].Address[0].in_addr, pIpAddress->Address[0].Address[0].sin_port));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pSessionReq->Hdr.Type   = NBT_SESSION_REQUEST;
    pSessionReq->Hdr.Flags  = NBT_SESSION_FLAGS;
    pSessionReq->Hdr.Length = (USHORT)htons(sLength- (USHORT)sizeof(tSESSIONHDR));  // size of called and calling NB names.

    // put the Dest HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii( (PCHAR)&pSessionReq->CalledName.NameLength,
                                  pDeviceContext->MessageEndpoint,
                                  NbtConfig.pScope,
                                  NbtConfig.ScopeLength);

    // put the Source HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii(pCopyTo,
                                 SourceName,
                                 NbtConfig.pScope,
                                 NbtConfig.ScopeLength);

    // Inbound expects this lock to be held!
    CTESpinLockAtDpc(pLowerConn);

    status = Inbound(
        NULL,                            // ReceiveEventContext - not used
        pLowerConn,                      // ConnectionContext
        0,                               // ReceiveFlags - not used
        sLength,                         // BytesIndicated
        sLength,                         // BytesAvailable - not used
        &BytesTaken,                     // BytesTaken
        pSessionReq,                     // pTsdu
        NULL                             // RcvBuffer
        );

    CTESpinFreeAtDpc(pLowerConn);

    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_INBOUND, ("Inbound() returns %!status! for %!ipaddr!:%d %!NBTNAME!<%02x>",
            status, pIpAddress->Address[0].Address[0].in_addr,
            pIpAddress->Address[0].Address[0].sin_port, pCopyTo, (unsigned)pCopyTo[15]));
    }

    CTEMemFree( pSessionReq );

    return status;
} // PerformInboundProcessing

#endif

//----------------------------------------------------------------------------
NTSTATUS
AcceptCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of an Accept to the transport.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    tLOWERCONNECTION    *pLowerConn;
    CTELockHandle       OldIrq;
    tDEVICECONTEXT      *pDeviceContext;

    pLowerConn = (tLOWERCONNECTION *)pContext;
    pDeviceContext = pLowerConn->pDeviceContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pDeviceContext);
    CTESpinLockAtDpc(pLowerConn);
    //
    // if the connection disconnects before the connect accept irp (this irp)
    // completes do not put back on the free list here but let  nbtdisconnect
    // handle it.
    // (i.e if the state is no longer INBOUND, then don't touch the connection
    //

#ifdef _NETBIOSLESS
    if (!NT_SUCCESS(pIrp->IoStatus.Status))
    {
        NbtTrace(NBT_TRACE_INBOUND, ("AcceptCompletionRoutine is called with %!status!", pIrp->IoStatus.Status));
        if (pLowerConn->State == NBT_SESSION_INBOUND)
        {
#else
    if ((!NT_SUCCESS(pIrp->IoStatus.Status)) &&
        (pLowerConn->State == NBT_SESSION_INBOUND))
    {
#endif
            //
            // the accept failed, so close the connection and create
            // a new one to be sure all activity is run down on the connection.
            //

            //
            // Previously, the LowerConnection was in the SESSION_INBOUND state
            // hence we have to remove it from the WaitingForInbound Q and put
            // it on the active LowerConnection list!
            //
            RemoveEntryList (&pLowerConn->Linkage);
            InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
            SET_STATE_LOWER (pLowerConn, NBT_IDLE);

            //
            // Change the RefCount Context to Connected!
            //
            NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, TRUE);
            InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
            CTESpinFreeAtDpc(pLowerConn);

            CTESpinFreeAtDpc(pDeviceContext);

            KdPrint(("Nbt.AcceptCompletionRoutine: error: %lx\n", pIrp->IoStatus.Status));

            if (!NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
            {
                pDeviceContext = NULL;
            }

            CTEQueueForNonDispProcessing (DelayedCleanupAfterDisconnect,
                                          NULL,
                                          pLowerConn,
                                          NULL,
                                          pDeviceContext,
                                          TRUE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);
#ifdef _NETBIOSLESS
        }
        else if (pLowerConn->State == NBT_SESSION_UP)
        {
            NTSTATUS status;
            // We are in message only mode and we need to clean up because the client rejected
            // the accept for some reason.  We are in the UP state so we need to do a heavy
            // duty cleanup.
            ASSERT( IsDeviceNetbiosless(pLowerConn->pDeviceContext) );

            CTESpinFreeAtDpc(pLowerConn);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            KdPrint(("Nbt.AcceptCompletionRoutine: Message only error: %lx\n", pIrp->IoStatus.Status));
            NbtTrace(NBT_TRACE_INBOUND, ("Message only error: %!status!", pIrp->IoStatus.Status));

            // this call will indicate the disconnect to the client and clean up abit.
            //
            status = DisconnectHndlrNotOs (NULL,
                                           (PVOID)pLowerConn,
                                           0,
                                           NULL,
                                           0,
                                           NULL,
                                           TDI_DISCONNECT_ABORT);

        }
        else
        {
            // Already disconnected
            CTESpinFreeAtDpc(pLowerConn);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
#endif
    }
    else
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFreeAtDpc(pDeviceContext);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }


    // put the Irp back on its free list
    REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
    ExInterlockedInsertTailList (&NbtConfig.IrpFreeList,
                                 &pIrp->Tail.Overlay.ListEntry,
                                 &NbtConfig.LockInfo.SpinLock);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is not initiating thread - we are the initiator
    return(STATUS_MORE_PROCESSING_REQUIRED);

}

//----------------------------------------------------------------------------
NTSTATUS
TdiDisconnectHandler (
    IN PVOID                EventContext,
    IN PVOID                ConnectionContext,
    IN ULONG                DisconnectDataLength,
    IN PVOID                pDisconnectData,
    IN ULONG                DisconnectInformationLength,
    IN PVOID                pDisconnectInformation,
    IN ULONG                DisconnectIndicators
    )
/*++

Routine Description:

    This routine is called when a session is disconnected from a remote
    machine.

Arguments:

    IN PVOID EventContext,
    IN PCONNECTION_CONTEXT ConnectionContext,
    IN ULONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN ULONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectIndicators

Return Value:

    NTSTATUS - Status of event indicator

--*/

{

    NTSTATUS            status;
    tDEVICECONTEXT      *pDeviceContext;

    // convert the context value into the device context record ptr
    pDeviceContext = (tDEVICECONTEXT *)EventContext;

    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(("pDeviceContxt = %X ConnectEv = %X\n",pDeviceContext,ConnectionContext));
    ASSERTMSG("Bad Device context passed to the Connection Event Handler",
            pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT);

    // call the non-OS specific routine to find a free connection.

    status = DisconnectHndlrNotOs(
                EventContext,
                ConnectionContext,
                DisconnectDataLength,
                pDisconnectData,
                DisconnectInformationLength,
                pDisconnectInformation,
                DisconnectIndicators);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIHNDLR)
            KdPrint(("NO FREE CONNECTIONS in connect handler\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }


    return status;

}


//----------------------------------------------------------------------------
NTSTATUS
TdiRcvDatagramHandler(
    IN PVOID                pDgramEventContext,
    IN int                  SourceAddressLength,
    IN PVOID                pSourceAddress,
    IN int                  OptionsLength,
    IN PVOID                pOptions,
    IN ULONG                ReceiveDatagramFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *pIoRequestPacket
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an Datagram arrives from the network, it will look for a
    the address with an appropriate read datagram outstanding or a Datagrm
    Event handler setup.

Arguments:

    pDgramEventContext      - Context provided for this event - pab
    SourceAddressLength,    - length of the src address
    pSourceAddress,         - src address
    OptionsLength,          - options length for the receive
    pOptions,               - options
    BytesIndicated,         - number of bytes this indication
    BytesAvailable,         - number of bytes in complete Tsdu
    pTsdu                   - pointer to the datagram


Return Value:

    *pBytesTaken            - number of bytes used
    *IoRequestPacket        - Receive IRP if MORE_PROCESSING_REQUIRED.
    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    tDEVICECONTEXT      *pDeviceContext = (tDEVICECONTEXT *)pDgramEventContext;
    tDGRAMHDR UNALIGNED *pDgram = (tDGRAMHDR UNALIGNED *)pTsdu;
    PIRP                pIrp = NULL;
    ULONG               lBytesTaken;
    tCLIENTLIST         *pClientList;
    CTELockHandle       OldIrq;

    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(( "NBT receive datagram handler pDeviceContext: %X\n",
                pDeviceContext ));

    *pIoRequestPacket = NULL;

    ASSERTMSG("NBT:Invalid Device Context passed to DgramRcv Handler!!\n",
                pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT );

    // call a non-OS specific routine to decide what to do with the datagrams
    pIrp = NULL;
    pClientList = NULL;
    status = DgramHndlrNotOs(
                    pDgramEventContext,
                    SourceAddressLength,
                    pSourceAddress,
                    OptionsLength,
                    pOptions,
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    &lBytesTaken,
                    pTsdu,
                    (PVOID *)&pIrp,
                    &pClientList);


    if ( !NT_SUCCESS(status) )
    {
        // fail the request back to the transport provider since we
        // could not find a receive buffer or receive handler or the
        // data was taken in the indication handler.
        //
        return(STATUS_DATA_NOT_ACCEPTED);

    }
    else
    {
        // a rcv buffer was returned, so use it for the receive.(an Irp)
        PTDI_REQUEST_KERNEL_RECEIVEDG   pParams;
        PIO_STACK_LOCATION              pIrpSp;
        ULONG                           lRcvLength;
        ULONG                           lRcvFlags;

        // When the client list is returned, we need to make up an irp to
        // send down to the transport, which we will use in the completion
        // routine to copy the data to all clients, ONLY if we are not
        // using a client buffer, so check that flag first.
        //
        if (pClientList && !pClientList->fUsingClientBuffer)
        {
            PMDL            pMdl;
            PVOID           pBuffer;

            //
            // get an irp to do the receive with and attach
            // a buffer to it.
            //
            while (1)
            {
                if (NT_SUCCESS(GetIrp(&pIrp)))
                {
                    if (pBuffer = NbtAllocMem (BytesAvailable, NBT_TAG('t')))
                    {
                        if (pMdl = IoAllocateMdl (pBuffer, BytesAvailable, FALSE, FALSE, NULL))
                        {
                            break;
                        }

                        KdPrint(("Nbt.TdiRcvDatagramHandler:  Unable to IoAllocateMdl, Kill Connection\n"));
                        CTEMemFree(pBuffer);
                    }
                    else
                    {
                        KdPrint(("Nbt.TdiRcvDatagramHandler:  Unable to allocate Buffer, Kill Connection\n"));
                    }

                    REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
                    ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                                &pIrp->Tail.Overlay.ListEntry,
                                                &NbtConfig.LockInfo.SpinLock);
                }
                else
                {
                    KdPrint(("Nbt.TdiRcvDatagramHandler:  Unable to GetIrp, Kill Connection\n"));
                }

                if (!pClientList->fProxy)   
                {
                    //
                    // We failed, so Dereference the Client + Address we had
                    // reference earlier for multiple clients
                    //
                    NBT_DEREFERENCE_CLIENT (pClientList->pClientEle);
                    NBT_DEREFERENCE_ADDRESS (pClientList->pAddress, REF_ADDR_MULTICLIENTS);
                    CTEMemFree(pClientList->pRemoteAddress);
                }

                CTEMemFree(pClientList);
                return (STATUS_DATA_NOT_ACCEPTED);
            }

            // Map the pages in memory...
            MmBuildMdlForNonPagedPool(pMdl);
            pIrp->MdlAddress = pMdl;
            lRcvFlags = 0;
            lRcvLength = BytesAvailable;
        }
        else
        {
            ASSERT(pIrp);
            // *TODO* may have to keep track of the case where the
            // client returns a buffer that is not large enough for all of the
            // data indicated.  So the next posting of a buffer gets passed
            // directly to the transport.
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            lRcvFlags = ((PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters)->ReceiveFlags;
            lRcvLength = ((PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters)->ReceiveLength;

            if (lRcvLength < BytesIndicated - lBytesTaken)
            {
                IF_DBG(NBT_DEBUG_TDIHNDLR)
                    KdPrint(("Nbt:Clients Buffer is too short on Rcv Dgram size= %X, needed = %X\n",
                          lRcvLength, BytesIndicated-lBytesTaken));
            }
        }

        // this code is sped up somewhat by expanding the code here rather than calling
        // the TdiBuildReceive macro
        // make the next stack location the current one.  Normally IoCallDriver
        // would do this but we are not going through IoCallDriver here, since the
        // Irp is just passed back with RcvIndication.
        ASSERT(pIrp->CurrentLocation > 1);
        IoSetNextIrpStackLocation(pIrp);
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pIrpSp->CompletionRoutine = CompletionRcvDgram;

        // pass the ClientList to the completion routine so it can
        // copy the datagram to several clients that may be listening on the
        // same name
        //
        pIrpSp->Context = (PVOID)pClientList;
        CHECK_PTR(pIrpSp);
        pIrpSp->Flags = 0;

        // set flags so the completion routine is always invoked.
        pIrpSp->Control = SL_INVOKE_ON_SUCCESS | SL_INVOKE_ON_ERROR | SL_INVOKE_ON_CANCEL;

        pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        pIrpSp->MinorFunction = TDI_RECEIVE_DATAGRAM;
        //
        // Verify that we have a valid Device and FileObject for TcpIp below
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        if (pDeviceContext->pFileObjects)
        {
            pIrpSp->DeviceObject = pDeviceContext->pFileObjects->pDgramDeviceObject;
            pIrpSp->FileObject = pDeviceContext->pFileObjects->pDgramFileObject;
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pParams = (PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;
        pParams->ReceiveFlags = lRcvFlags;
        pParams->ReceiveLength = lRcvLength;

        // pass back the irp to the transport provider and increment the stack
        // location so it can write to the irp if it needs to.
        *pIoRequestPacket = pIrp;
        *pBytesTaken = lBytesTaken;

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    //
    //  Transport will complete the processing of the request, we don't
    //  want the datagram.
    //

    IF_DBG (NBT_DEBUG_TDIHNDLR)
        KdPrint(( "NBT receive datagram handler ignored receive, pDeviceContext: %X\n",
                    pDeviceContext ));

    return STATUS_DATA_NOT_ACCEPTED;

    // to keep the compiler from generating warnings...
    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( pBytesTaken );
    UNREFERENCED_PARAMETER( pTsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( pOptions );

}

//----------------------------------------------------------------------------
NTSTATUS
TdiRcvNameSrvHandler(
    IN PVOID             pDgramEventContext,
    IN int               SourceAddressLength,
    IN PVOID             pSourceAddress,
    IN int               OptionsLength,
    IN PVOID             pOptions,
    IN ULONG             ReceiveDatagramFlags,
    IN ULONG             BytesIndicated,
    IN ULONG             BytesAvailable,
    OUT ULONG            *pBytesTaken,
    IN PVOID             pTsdu,
    OUT PIRP             *pIoRequestPacket
    )
/*++

Routine Description:

    This routine is the Name Service datagram event indication handler.
    It gets all datagrams destined for UDP port 137


Arguments:

    pDgramEventContext      - Context provided for this event - pab
    SourceAddressLength,    - length of the src address
    pSourceAddress,         - src address
    OptionsLength,          - options length for the receive
    pOptions,               - options
    BytesIndicated,         - number of bytes this indication
    BytesAvailable,         - number of bytes in complete Tsdu
    pTsdu                   - pointer to the datagram


Return Value:

    *pBytesTaken            - number of bytes used
    *IoRequestPacket        - Receive IRP if MORE_PROCESSING_REQUIRED.
    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS            status;
    tDEVICECONTEXT      *pDeviceContext = (tDEVICECONTEXT *)pDgramEventContext;
    tNAMEHDR UNALIGNED  *pNameSrv = (tNAMEHDR UNALIGNED *)pTsdu;
    USHORT              OpCode;


    IF_DBG(NBT_DEBUG_TDIHNDLR)
        KdPrint(( "NBT: NAMEHDR datagram handler pDeviceContext: %X\n",
                pDeviceContext ));

    *pIoRequestPacket = NULL;
    //
    // check if the whole datagram has arrived yet
    //
    if (BytesIndicated != BytesAvailable)
    {
        PIRP    pIrp;
        PVOID   pBuffer;
        PMDL    pMdl;
        ULONG   Length;

        //
        // get an irp to do the receive with and attach
        // a buffer to it.
        //
        status = GetIrp(&pIrp);

        if (!NT_SUCCESS(status))
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // make an Mdl for a buffer to get all of the data from
        // the transprot
        //
        Length = BytesAvailable + SourceAddressLength + sizeof(ULONG);
        Length = ((Length + 3)/sizeof(ULONG)) * sizeof(ULONG);
        pBuffer = NbtAllocMem(Length,NBT_TAG('u'));
        if (pBuffer)
        {
            PVOID   pSrcAddr;

            //
            // save the source address and length in the buffer for later
            // indication back to this routine.
            //
            *(ULONG UNALIGNED *)((PUCHAR)pBuffer + BytesAvailable) = SourceAddressLength;
            pSrcAddr = (PVOID)((PUCHAR)pBuffer + BytesAvailable + sizeof(ULONG));

            CTEMemCopy(pSrcAddr,
                       pSourceAddress,
                       SourceAddressLength);

            // Allocate a MDL and set the header sizes correctly
            pMdl = IoAllocateMdl(
                            pBuffer,
                            BytesAvailable,
                            FALSE,
                            FALSE,
                            NULL);

            if (pMdl)
            {
                // Map the pages in memory...
                MmBuildMdlForNonPagedPool(pMdl);
                pIrp->MdlAddress = pMdl;
                ASSERT(pDeviceContext);

                //
                // Build a Datagram Receive Irp (as opposed to a Connect Receive Irp)
                // Bug# 125816
                //
                TdiBuildReceiveDatagram(
                           pIrp,
                           &pDeviceContext->DeviceObject,
                           pDeviceContext->pFileObjects->pNameServerFileObject,
                           NameSrvCompletionRoutine,
                           ULongToPtr(BytesAvailable),
                           pMdl,
                           BytesAvailable,
                           NULL,
                           NULL,
                           (ULONG)TDI_RECEIVE_NORMAL);

                *pBytesTaken = 0;
                *pIoRequestPacket = pIrp;

                // make the next stack location the current one.  Normally IoCallDriver
                // would do this but we are not going through IoCallDriver here, since the
                // Irp is just passed back with RcvIndication.
                //
                ASSERT(pIrp->CurrentLocation > 1);
                IoSetNextIrpStackLocation(pIrp);

                return(STATUS_MORE_PROCESSING_REQUIRED);
            }

            CTEMemFree(pBuffer);
        }

        // put our Irp back on its free list
        //
        REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
        ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                    &pIrp->Tail.Overlay.ListEntry,
                                    &NbtConfig.LockInfo.SpinLock);

        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Bug# 125279: Ensure that we have received enough data to be able to
    // read most data fields
    if (BytesIndicated < NBT_MINIMUM_QUERY) // should this be limited to 12 ?
    {
        KdPrint (("Nbt.TdiRcvNameSrvHandler: WARNING!!! Rejecting Request -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, NBT_MINIMUM_QUERY));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    if (pWinsInfo)
    {
        USHORT  TransactionId;
        ULONG   SrcAddress;

        SrcAddress = ntohl(((PTDI_ADDRESS_IP)&((PTRANSPORT_ADDRESS)pSourceAddress)->Address[0].Address[0])->in_addr);
        //
        // Pass To Wins if:
        //
        //   1) It is a response pdu with the transaction id in the WINS range
        //               that is not a WACK...                        OR
        //   2) It is a request that is NOT broadcast....and...
        //   2) It is a name query(excluding node status requests),
        //          Allowing queries from other netbt clients
        //          allowing queries from anyone not on this machine OR
        //   3) It is a name release request.                        OR
        //   4) It is a name refresh                                 OR
        //   5) It is a name registration
        //
        OpCode = pNameSrv->OpCodeFlags;
        TransactionId = ntohs(pNameSrv->TransactId);

        if (((OpCode & OP_RESPONSE) && (TransactionId <= WINS_MAXIMUM_TRANSACTION_ID) && (OpCode != OP_WACK))
                ||
            ((!(OpCode & (OP_RESPONSE | FL_BROADCAST)))
                    &&
             ((((OpCode & NM_FLAGS_MASK) == OP_QUERY) &&
               (OpCode & FL_RECURDESIRE) &&          // not node status request
               ((TransactionId > WINS_MAXIMUM_TRANSACTION_ID) || (!SrcIsUs(SrcAddress))))
                    ||
              (OpCode & (OP_RELEASE | OP_REFRESH))
                    ||
              (OpCode & OP_REGISTRATION))))
        {
            status = PassNamePduToWins(
                              pDeviceContext,
                              pSourceAddress,
                              pNameSrv,
                              BytesIndicated);

//            NbtConfig.DgramBytesRcvd += BytesIndicated;

            //
            // if WINS took the data then tell the transport to dump the data
            // since we have buffered it already.  Otherwise, let nbt take
            // a look at the data
            //
            if (NT_SUCCESS(status))
            {
                return(STATUS_DATA_NOT_ACCEPTED);
            }
        }
    }


    // DO a quick check of the name to see if it is in the local name table
    // and reject it otherwise - for name queries only, if not the proxy
    //
    if (!(NodeType & PROXY))
    {
        ULONG       UNALIGNED   *pHdr;
        ULONG                   i,lValue;
        UCHAR                   pNameStore[NETBIOS_NAME_SIZE];
        UCHAR                   *pName;
        tNAMEADDR               *pNameAddr;
        CTELockHandle           OldIrq;

        // it must be a name query request, not a response, and not a
        // node status request, to enter this special check
        //
        OpCode = pNameSrv->OpCodeFlags;
        if (((OpCode & NM_FLAGS_MASK) == OP_QUERY) &&
            (!(OpCode & OP_RESPONSE)) &&
            (OpCode & FL_RECURDESIRE))   // not node status request
        {
            pHdr = (ULONG UNALIGNED *)pNameSrv->NameRR.NetBiosName;
            pName = pNameStore;

            // the Half Ascii portion of the netbios name is always 32 bytes long
            for (i=0; i < NETBIOS_NAME_SIZE*2 ;i +=4 )
            {
                lValue = *pHdr - 0x41414141;  // four A's
                pHdr++;
                lValue =    ((lValue & 0x0F000000) >> 16) +
                            ((lValue & 0x0F0000) >> 4) +
                            ((lValue & 0x0F00) >> 8) +
                            ((lValue & 0x0F) << 4);
                *(PUSHORT)pName = (USHORT)lValue;
                ((PUSHORT)pName)++;

            }
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                            pNameStore,
                                            NULL,
                                            &pNameAddr);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (!NT_SUCCESS(status))
            {
                *pBytesTaken = BytesIndicated;
                return(STATUS_DATA_NOT_ACCEPTED);
            }
        }
    }

    ASSERT(pDeviceContext);

    // call a non-OS specific routine to decide what to do with the datagrams
    status = NameSrvHndlrNotOs(
                    pDeviceContext,
                    pSourceAddress,
                    pNameSrv,
                    BytesIndicated,
                    (BOOLEAN)((ReceiveDatagramFlags & TDI_RECEIVE_BROADCAST) != 0));

//    NbtConfig.DgramBytesRcvd += BytesIndicated


    return status;

    // to keep the compiler from generating warnings...
    UNREFERENCED_PARAMETER( SourceAddressLength );
    UNREFERENCED_PARAMETER( BytesIndicated );
    UNREFERENCED_PARAMETER( BytesAvailable );
    UNREFERENCED_PARAMETER( pBytesTaken );
    UNREFERENCED_PARAMETER( pTsdu );
    UNREFERENCED_PARAMETER( OptionsLength );
    UNREFERENCED_PARAMETER( pOptions );

}
//----------------------------------------------------------------------------
NTSTATUS
NameSrvCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles the case when a name service datagram is too
    short and and Irp has to be passed back to the transport to get the
    rest of the datagram.  The irp completes through here when full.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pConnectEle - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS        status;
    PIRP            pIoRequestPacket;
    ULONG           BytesTaken;
    ULONG           Offset = PtrToUlong(Context);
    PVOID           pBuffer;
    ULONG           SrcAddressLength;
    PVOID           pSrcAddress;


    IF_DBG (NBT_DEBUG_TDIHNDLR)
        KdPrint(("NameSrvCompletionRoutine pRcvBuffer: %X, Status: %X Length %X\n",
            Context, pIrp->IoStatus.Status, pIrp->IoStatus.Information));

    if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))
    {
        SrcAddressLength = *(ULONG UNALIGNED *)((PUCHAR)pBuffer + Offset);
        pSrcAddress = (PVOID)((PUCHAR)pBuffer + Offset + sizeof(ULONG));

        if (!DeviceObject)
        {
            DeviceObject = (IoGetNextIrpStackLocation (pIrp))->DeviceObject;
        }

        //
        // just call the regular indication routine as if UDP had done it.
        //
        TdiRcvNameSrvHandler (DeviceObject,
                              SrcAddressLength,
                              pSrcAddress,
                              0,
                              NULL,
                              TDI_RECEIVE_NORMAL,
                              (ULONG) pIrp->IoStatus.Information,
                              (ULONG) pIrp->IoStatus.Information,
                              &BytesTaken,
                              pBuffer,
                              &pIoRequestPacket);

        CTEMemFree (pBuffer);
    }

    //
    // put our Irp back on its free list
    //
    IoFreeMdl (pIrp->MdlAddress);
    REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
    ExInterlockedInsertTailList (&NbtConfig.IrpFreeList,
                                 &pIrp->Tail.Overlay.ListEntry,
                                 &NbtConfig.LockInfo.SpinLock);

    return (STATUS_MORE_PROCESSING_REQUIRED);
}


//----------------------------------------------------------------------------
NTSTATUS
CompletionRcvDgram(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine completes the Irp by removing the Rcv Element off the queue
    and putting it back on the free list.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the pConnectEle - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS                status;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PTA_NETBIOS_ADDRESS     pRemoteAddress;
    ULONG                   RemoteAddressLength;
    ULONG                   BytesCopied;
    PVOID                   pTsdu;
    ULONG                   ReceiveFlags;
    tCLIENTLIST             *pClientList;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    ULONG                   ClientBytesTaken;
    ULONG                   DataLength;
    tADDRESSELE             *pAddress;
    tRCVELE                 *pRcvEle;
    PLIST_ENTRY             pRcvEntry;
    tDEVICECONTEXT          *pDeviceContext;
    CTEULONGLONG            AdapterMask;

    IF_DBG (NBT_DEBUG_TDIHNDLR)
        KdPrint(("CompletionRcvDgram pRcvBuffer: %X, Status: %X Length %X\n",
            Context,
            Irp->IoStatus.Status,
            Irp->IoStatus.Information ));


    // there may be several clients that want to see this datagram so check
    // the client list to see...
    //
    if (Context)
    {
        tCLIENTELE    *pClientPrev = NULL;

        //
        // Bug# 124683: Data may be invalid if Completion status was failure
        //
        if (NT_SUCCESS (Irp->IoStatus.Status))
        {
            DataLength = (ULONG)Irp->IoStatus.Information;
        }
        else
        {
            ASSERT (0);
            DataLength = 0;
        }

        pTsdu = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, HighPagePriority);
        pClientList = (tCLIENTLIST *) Context;

#ifdef PROXY_NODE
        if (pClientList->fProxy)
        {
            //
            // Call the ProxyDoDgramDist
            //
            status = ProxyDoDgramDist( pTsdu, DataLength,
                                       (tNAMEADDR *)pClientList->pAddress, //NameAddr
                                       pClientList->pRemoteAddress);    //device context
        }
        else
#endif
        {
            CTESpinLock(&NbtConfig.JointLock,OldIrq);

            // for the multihomed host, we only want to distribute the inbound
            // datagram to clients on this same adapter, to avoid giving the
            // datagram to the same client several times, once for each adapter
            // it is bound to.
            //
            pDeviceContext      = pClientList->pClientEle->pDeviceContext;
            AdapterMask         = pDeviceContext->AdapterMask;

            pAddress            = pClientList->pAddress;
            pRemoteAddress      = pClientList->pRemoteAddress;
            RemoteAddressLength = pClientList->RemoteAddressLength;
            ReceiveFlags        = pClientList->ReceiveDatagramFlags;

            //
            // Since we will be traversing the ClientHead, lock
            // the Address (we have already referenced the Address
            // + Client in DgramRcvNotOs)
            //
            CTESpinLock(pAddress, OldIrq1);

            pHead               = &pClientList->pAddress->ClientHead;
            pEntry              = pHead->Flink;
            if (!pClientList->fUsingClientBuffer)
            {
                while (pEntry != pHead)
                {
                    PTDI_IND_RECEIVE_DATAGRAM  EvRcvDgram;
                    PVOID                      RcvDgramEvContext;
                    tCLIENTELE                 *pClientEle;
                    PIRP                       pRcvIrp;


                    pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                    // for multihomed hosts only distribute the datagram to
                    // clients hooked to this device context to avoid duplicate
                    // indications
                    //
                    if ((pClientEle->Verify == NBT_VERIFY_CLIENT) &&   // as opposed to CLIENT_DOWN!
                        (pClientEle->pDeviceContext->AdapterMask == AdapterMask))
                    {
                        EvRcvDgram = pClientEle->evRcvDgram;
                        RcvDgramEvContext = pClientEle->RcvDgramEvContext;
                        RemoteAddressLength = FIELD_OFFSET(TA_NETBIOS_ADDRESS,
                                                    Address[0].Address[0].NetbiosName[NETBIOS_NAME_SIZE]);

                        //
                        // Bug # 452211 -- since one of the clients may have the Extended
                        // addressing field set, set the # of addresses accordingly
                        //
                        if (pClientEle->ExtendedAddress)
                        {
                            pRemoteAddress->TAAddressCount = 2;
                            RemoteAddressLength += FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP);
                        }
                        else
                        {
                            pRemoteAddress->TAAddressCount = 1;
                        }

                        NBT_REFERENCE_CLIENT(pClientEle);

                        CTESpinFree(pAddress, OldIrq1);
                        CTESpinFree(&NbtConfig.JointLock, OldIrq);

                        // dereference the previous client in the list
                        if (pClientPrev)
                        {
                            NBT_DEREFERENCE_CLIENT(pClientPrev);
                        }
                        pClientPrev = pClientEle;

                        pRcvIrp = NULL;

                        ClientBytesTaken = 0;

                        status = (*EvRcvDgram) (RcvDgramEvContext,
                                                RemoteAddressLength,
                                                pRemoteAddress,
                                                0,
                                                NULL,
#ifndef VXD
                                                ReceiveFlags,
#endif
                                                DataLength,
                                                DataLength,
                                                &ClientBytesTaken,
                                                pTsdu,
                                                &pRcvIrp);

                        if (!pRcvIrp)
                        {
                            // if no buffer is returned, then the client is done
                            // with the data so go to the next client ...since it may
                            // be possible to process all clients in this loop without
                            // ever sending an irp down to the transport
                            // free the remote address mem block

                            status = STATUS_DATA_NOT_ACCEPTED;
                        }
                        else
                        {

                            // the client has passed back an irp so
                            // copy the data to the client's Irp
                            //
                            TdiCopyBufferToMdl(pTsdu,
                                            ClientBytesTaken,
                                            DataLength - ClientBytesTaken,
                                            pRcvIrp->MdlAddress,
                                            0,
                                            &BytesCopied);

                            // length is copied length (since the MDL may be
                            // too short to take it all)
                            //
                            if (BytesCopied < (DataLength-ClientBytesTaken))
                            {
                                pRcvIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

                            }
                            else
                            {
                                pRcvIrp->IoStatus.Status = STATUS_SUCCESS;
                            }

                            pRcvIrp->IoStatus.Information = BytesCopied;

                            IoCompleteRequest(pRcvIrp,IO_NETWORK_INCREMENT);
                        }

                        CTESpinLock(&NbtConfig.JointLock, OldIrq);
                        CTESpinLock(pAddress, OldIrq1);
                    }
                    // this code is protected from a client removing itself
                    // from the list of clients attached to an address by
                    // referencing the client prior to releasing the spin lock
                    // on the address.  The client element does not get
                    // removed from the address list until its ref count goes
                    // to zero. We must hold the joint spin lock to prevent the
                    // next client from deleting itself from the list before we
                    // can increment its reference count.
                    //
                    pEntry = pEntry->Flink;

                } // of while(pEntry != pHead)
            }
            else
            {
                // *** Client Has posted a receive Buffer, rather than using
                // *** receive handler - VXD case!
                // ***
                while (pEntry != pHead)
                {
                    tCLIENTELE                 *pClientEle;
                    PIRP                       pRcvIrp;

                    pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                    // for multihomed hosts only distribute the datagram to
                    // clients hooked to this device context to avoid duplicate
                    // indications
                    //
                    if (pClientEle->pDeviceContext->AdapterMask == AdapterMask)
                    {
                        if (pClientEle == pClientList->pClientEle)
                        {
                            // this is the client whose buffer we are using - it is
                            // passed up to the client after all other clients
                            // have been processed.
                            //
                            pEntry = pEntry->Flink;
                            continue;
                        }

                        // check for datagrams posted to this name
                        //
                        if (!IsListEmpty(&pClientEle->RcvDgramHead))
                        {

                            pRcvEntry = RemoveHeadList(&pClientEle->RcvDgramHead);
                            pRcvEle   = CONTAINING_RECORD(pRcvEntry,tRCVELE,Linkage);
                            pRcvIrp   = pRcvEle->pIrp;

                            //
                            // copy the data to the client's Irp
                            //
                            TdiCopyBufferToMdl(pTsdu,
                                            0,
                                            DataLength,
                                            pRcvIrp->MdlAddress,
                                            0,
                                            &BytesCopied);

                            // length is copied length (since the MDL may be too short to take it all)
                            if (BytesCopied < DataLength)
                            {
                                pRcvIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

                            }
                            else
                            {
                                pRcvIrp->IoStatus.Status = STATUS_SUCCESS;
                            }

                            pRcvIrp->IoStatus.Information = BytesCopied;

                            //
                            // Increment the RefCount so that this Client hangs around!
                            //
                            NBT_REFERENCE_CLIENT (pClientEle);
                            CTESpinFree(pAddress, OldIrq1);
                            CTESpinFree(&NbtConfig.JointLock, OldIrq);

                            //
                            // undo the InterlockedIncrement to the Previous client
                            //
                            if (pClientPrev)
                            {
                                NBT_DEREFERENCE_CLIENT(pClientPrev);
                            }
                            pClientPrev = pClientEle;

                            IoCompleteRequest(pRcvIrp,IO_NETWORK_INCREMENT);

                            // free the receive block
                            CTEMemFree((PVOID)pRcvEle);
                            CTESpinLock(&NbtConfig.JointLock, OldIrq);
                            CTESpinLock(pAddress, OldIrq1);
                        }

                        pEntry = pEntry->Flink;
                    }
                } // of while(pEntry != pHead)

                CTESpinFree(pAddress, OldIrq1);
                CTESpinFree(&NbtConfig.JointLock, OldIrq);

                // undo the InterlockedIncrement on the refcount
                if (pClientPrev)
                {
                    NBT_DEREFERENCE_CLIENT(pClientPrev);
                }

                //
                // The Client + Address were referenced in DgramRcvNotOs to be sure they did not
                // disappear until this dgram rcv was done, which is now.
                //
                NBT_DEREFERENCE_CLIENT (pClientList->pClientEle); // Bug#: 124675
                NBT_DEREFERENCE_ADDRESS (pClientList->pAddress, REF_ADDR_MULTICLIENTS);

                // free the remote address structure and the client list
                // allocated in DgramHndlrNotOs
                //
                CTEMemFree (pClientList->pRemoteAddress);
                CTEMemFree (pClientList);

                // returning success allows the IO subsystem to complete the
                // irp that we used to get the data - i.e. one client's
                // buffer
                //
                return(STATUS_SUCCESS);
            }

            CTESpinFree(pAddress, OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            // dereference the previous client in the list from the RcvHANDLER
            // case a page or so above...
            //
            if (pClientPrev)
            {
                NBT_DEREFERENCE_CLIENT(pClientPrev);
            }

            //
            // The Client + Address were referenced in DgramRcvNotOs to be sure they did not
            // disappear until this dgram rcv was done, which is now.
            //
            NBT_DEREFERENCE_CLIENT (pClientList->pClientEle); // Bug#: 124675
            NBT_DEREFERENCE_ADDRESS (pClientList->pAddress, REF_ADDR_MULTICLIENTS);
        }

        //
        // Free the buffers allocated
        //
        if (!pClientList->fProxy)
        {
            CTEMemFree (pClientList->pRemoteAddress);
        }
        CTEMemFree (pClientList);

        CTEMemFree(pTsdu);

        //
        // Free the Mdl + put the Irp back on its free list
        //
        IF_DBG(NBT_DEBUG_RCV)
            KdPrint(("****Freeing Mdl: Irp = %X Mdl = %X\n",Irp,Irp->MdlAddress));
        IoFreeMdl(Irp->MdlAddress);
        REMOVE_FROM_LIST(&Irp->ThreadListEntry);
        ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                    &Irp->Tail.Overlay.ListEntry,
                                    &NbtConfig.LockInfo.SpinLock);

        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    // for the single receive case this passes the rcv up to the client
    //
    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( DeviceObject );
}


//----------------------------------------------------------------------------
NTSTATUS
TdiErrorHandler (
    IN PVOID Context,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is called on any error indications passed back from the
    transport. It implements LAN_STATUS_ALERT.

Arguments:

    Context     - Supplies the pfcb for the address.

    Status      - Supplies the error.

Return Value:

    NTSTATUS - Status of event indication

--*/

{
#ifdef _NETBIOSLESS
    tDEVICECONTEXT *pDeviceContext = (tDEVICECONTEXT *)Context;

    // If NB-full trys to contact NB-less host, we may get this error
    if ( (Status == STATUS_PORT_UNREACHABLE) ||
         (Status == STATUS_HOST_UNREACHABLE))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }
    // TODO: Log a message here
    KdPrint(("Nbt.TdiErrorHandler: TDI error event notification\n\tDevice %x\n\tStatus: 0x%x\n",
            pDeviceContext, Status));
#else
    KdPrint(("Nbt.TdiErrorHandler: Error Event HAndler hit unexpectedly\n"));
#endif
    return(STATUS_DATA_NOT_ACCEPTED);
}


//----------------------------------------------------------------------------
VOID
SumMdlLengths (
    IN PMDL         pMdl,
    IN ULONG        BytesCopied,
    IN tCONNECTELE  *pConnectEle
    )

/*++

Routine Description:

    This routine is called to sum the lengths of MDLs in a chain.

Arguments:


Return Value:

    NTSTATUS - Status of event indication

--*/

{
    ULONG       TotalLength;

    TotalLength = 0;

    do
    {
        if ((TotalLength + MmGetMdlByteCount(pMdl)) > BytesCopied)
        {
            pConnectEle->OffsetFromStart = BytesCopied - TotalLength;
            pConnectEle->pNextMdl = pMdl;
            break;
        }
        else
        {
            TotalLength += MmGetMdlByteCount(pMdl);
        }
    }
    while (pMdl=(PMDL)pMdl->Next);

    return;
}


//----------------------------------------------------------------------------
VOID
MakePartialMdl (
    IN tCONNECTELE      *pConnEle,
    IN PIRP             pIrp,
    IN ULONG            ToCopy
    )

/*++

Routine Description:

    This routine is called to build a partial Mdl that accounts for ToCopy
    bytes of data being copied to the start of the Client's Mdl.

Arguments:

    pConnEle    - ptr to the connection element

Return Value:

    NTSTATUS - Status of event indication

--*/

{
    PMDL        pNewMdl;
    PVOID       NewAddress;

    // Build a partial Mdl to represent the client's Mdl chain since
    // we have copied data to it, and the transport must copy
    // more data to it after that data.
    //
    SumMdlLengths(pIrp->MdlAddress,ToCopy,pConnEle);

    // this routine has set the Mdl that the next data starts at and
    // the offset from the start of that Mdl, so create a partial Mdl
    // to map that buffer and tack it on the mdl chain instead of the
    // original
    //
    pNewMdl = pConnEle->pNewMdl;
    NewAddress = (PVOID)((PUCHAR)MmGetMdlVirtualAddress(pConnEle->pNextMdl)
                        + pConnEle->OffsetFromStart);

    if ((MmGetMdlByteCount(pConnEle->pNextMdl) - pConnEle->OffsetFromStart) > MAXUSHORT)
    {
        IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,MAXUSHORT);
    }
    else
    {
        IoBuildPartialMdl(pConnEle->pNextMdl,pNewMdl,NewAddress,0);
    }

    // hook the new partial mdl to the front of the MDL chain
    //
    pNewMdl->Next = pConnEle->pNextMdl->Next;

    pIrp->MdlAddress = pNewMdl;
    ASSERT(pNewMdl);
}
//----------------------------------------------------------------------------
VOID
CopyToStartofIndicate (
    IN tLOWERCONNECTION       *pLowerConn,
    IN ULONG                  DataTaken
    )

/*++

Routine Description:

    This routine is called to copy data remaining in the indicate buffer to
    the head of the indicate buffer.

Arguments:

    pLowerConn    - ptr to the lower connection element

Return Value:

    none

--*/

{
    PVOID       pSrc;
    ULONG       DataLeft;
    PVOID       pMdl;


    DataLeft = pLowerConn->BytesInIndicate;

    pMdl = (PVOID)MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl);

    pSrc = (PVOID)( (PUCHAR)pMdl + DataTaken);

    CTEMemCopy(pMdl,pSrc,DataLeft);

}

//----------------------------------------------------------------------------

ULONG   FailuresSinceLastLog = 0;

NTSTATUS
OutOfRsrcKill(
    OUT tLOWERCONNECTION    *pLowerConn)

/*++
Routine Description:

    This Routine handles killing a connection when an out of resource condition
    occurs.  It uses a special Irp that it has saved away, and a linked list
    if that irp is currently in use.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                    status;
    CTELockHandle               OldIrq;
    CTELockHandle               OldIrq1;
    PIRP                        pIrp;
    PFILE_OBJECT                pFileObject;
    PDEVICE_OBJECT              pDeviceObject;
    tDEVICECONTEXT              *pDeviceContext = pLowerConn->pDeviceContext;
    CTESystemTime               CurrentTime;

    CTESpinLock(pDeviceContext,OldIrq);
    CTESpinLock(&NbtConfig,OldIrq1);

    //
    // If we have not logged any event recently, then log an event!
    //
    CTEQuerySystemTime (CurrentTime);

    FailuresSinceLastLog++;
    if (pLowerConn->pUpperConnection &&     // Log it only when the connection hasn't been disconnected
            (CurrentTime.QuadPart-NbtConfig.LastOutOfRsrcLogTime.QuadPart) > ((ULONGLONG) ONE_HOUR*10000))
    {
        NbtLogEvent (EVENT_NBT_NO_RESOURCES, FailuresSinceLastLog, 0x117);
        NbtConfig.LastOutOfRsrcLogTime = CurrentTime;
        FailuresSinceLastLog = 0;
    }

    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_OUT_OF_RSRC);
    if (NbtConfig.OutOfRsrc.pIrp)
    {
        // get an Irp to send the message in
        pIrp = NbtConfig.OutOfRsrc.pIrp;
        NbtConfig.OutOfRsrc.pIrp = NULL;

        pFileObject = pLowerConn->pFileObject;
        ASSERT (pFileObject->Type == IO_TYPE_FILE);
        pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

        CTESpinFree(&NbtConfig,OldIrq1);
        CTESpinFree(pDeviceContext,OldIrq);

        // store some context stuff in the Irp stack so we can call the completion
        // routine set by the Udpsend code...
        TdiBuildDisconnect(
            pIrp,
            pDeviceObject,
            pFileObject,
            RsrcKillCompletion,
            pLowerConn,               //context value passed to completion routine
            NULL,               // Timeout...
            TDI_DISCONNECT_ABORT,
            NULL,               // send connection info
            NULL);              // return connection info

        CHECK_PTR(pIrp);
        pIrp->MdlAddress = NULL;

        CHECK_COMPLETION(pIrp);
        status = IoCallDriver(pDeviceObject,pIrp);

        IF_DBG(NBT_DEBUG_REF)
        KdPrint(("Nbt.OutOfRsrcKill: Kill connection, %X\n",pLowerConn));

        return(status);

    }
    else
    {
        //
        // The lower conn could get removed here, then get dequed from the ConnectionHead and come here
        // (via DpcNextOutOfRsrcKill), and fail to get an Irp; we re-enque it into the OutOfRsrc list,
        // but should not try to deque it here.
        //
        if (!pLowerConn->OutOfRsrcFlag)
        {
            RemoveEntryList(&pLowerConn->Linkage);

            //
            // The lower conn gets removed from the inactive list here and again when
            // DelayedCleanupAfterDisconnect calls NbtDeleteLowerConn. In order to prevent
            // the second deque, we set a flag here and test for it in NbtDeleteLowerConn.
            //
            pLowerConn->OutOfRsrcFlag = TRUE;
        }

        pLowerConn->Linkage.Flink = pLowerConn->Linkage.Blink = (PLIST_ENTRY)0x00006041;
        InsertTailList(&NbtConfig.OutOfRsrc.ConnectionHead,&pLowerConn->Linkage);

        CTESpinFree(&NbtConfig,OldIrq1);
        CTESpinFree(pDeviceContext,OldIrq);
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
RsrcKillCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of a disconnect to the transport.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS            status;
    KIRQL               OldIrq;
    PLIST_ENTRY         pEntry;
    tLOWERCONNECTION    *pLowerConn;
    PKDPC               pDpc;



    pLowerConn = (tLOWERCONNECTION *)pContext;

    // this call will indicate the disconnect to the client and clean up
    // abit.
    //
    status = DisconnectHndlrNotOs (NULL,
                                   (PVOID)pLowerConn,
                                   0,
                                   NULL,
                                   0,
                                   NULL,
                                   TDI_DISCONNECT_ABORT);

    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_OUT_OF_RSRC, FALSE);

    CTESpinLock(&NbtConfig,OldIrq);
    NbtConfig.OutOfRsrc.pIrp = pIrp;

    if (!IsListEmpty(&NbtConfig.OutOfRsrc.ConnectionHead))
    {
        if (NbtConfig.OutOfRsrc.pDpc)
        {
            pDpc = NbtConfig.OutOfRsrc.pDpc;
            NbtConfig.OutOfRsrc.pDpc = NULL;

            pEntry = RemoveHeadList(&NbtConfig.OutOfRsrc.ConnectionHead);
            pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);

            pLowerConn->Linkage.Flink = pLowerConn->Linkage.Blink = (PLIST_ENTRY)0x00006109;
            KeInitializeDpc(pDpc, DpcNextOutOfRsrcKill, (PVOID)pLowerConn);
            KeInsertQueueDpc(pDpc,NULL,NULL);

            CTESpinFree(&NbtConfig,OldIrq);
        }
        else
        {
            CTESpinFree(&NbtConfig,OldIrq);
        }
    }
    else
    {
        CTESpinFree(&NbtConfig,OldIrq);
    }

    //
    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    //
    return(STATUS_MORE_PROCESSING_REQUIRED);
}


//----------------------------------------------------------------------------
VOID
DpcNextOutOfRsrcKill(
    IN  PKDPC           pDpc,
    IN  PVOID           Context,
    IN  PVOID           SystemArgument1,
    IN  PVOID           SystemArgument2
    )
/*++

Routine Description:

    This routine simply calls OutOfRsrcKill from a Dpc started in
    RsrcKillCompletion.

Arguments:


Return Value:
--*/
{

    KIRQL               OldIrq;
    tLOWERCONNECTION   *pLowerConn;


    pLowerConn = (tLOWERCONNECTION *)Context;

    CTESpinLock(&NbtConfig,OldIrq);
    NbtConfig.OutOfRsrc.pDpc = pDpc;
    CTESpinFree(&NbtConfig,OldIrq);

    OutOfRsrcKill(pLowerConn);

    //
    // to remove the extra reference put on pLowerConn when OutOfRsrc called
    //
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_OUT_OF_RSRC, FALSE);
}


//----------------------------------------------------------------------------
VOID
NbtCancelFillIrpRoutine(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a Receive Irp that has been saved
    during the FILL_IRP state. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    tCONNECTELE          *pConnEle;
    KIRQL                OldIrq;
    KIRQL                OldIrq1;
    KIRQL                OldIrq2;
    PIO_STACK_LOCATION   pIrpSp;
    tLOWERCONNECTION     *pLowerConn;
    BOOLEAN              CompleteIt = FALSE;

    IF_DBG(NBT_DEBUG_INDICATEBUFF)
        KdPrint(("Nbt.NbtCancelFillIrpRoutine: Got a Receive Cancel Irp !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERTMSG ("Nbt.NbtCancelFillIrpRoutine: ERROR - Invalid Connection Handle\n", 0);
        // complete the irp
        pIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

        return;
    }

    // now look for an Irp to cancel
    //
    CHECK_PTR(pConnEle);
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);

    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        CTESpinLock(pLowerConn,OldIrq2);
        SET_STATERCV_LOWER(pLowerConn, INDICATE_BUFFER, RejectAnyData);
    }

    pConnEle->pIrpRcv = NULL;

    if (pLowerConn)
    {
        CTESpinFree(pLowerConn,OldIrq2);
    }

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    // complete the irp
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

    if (pLowerConn)
    {
        //
        // Cancelling a Rcv Irp in the fill irp state will cause netbt
        // to lose track of where it is in the message so it must kill
        // the connection.
        //
        OutOfRsrcKill(pLowerConn);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\debug.c ===
#include "precomp.h"

#if DBG
ULONG   DbgLevel = DEF_DBG_LEVEL;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\tdiout.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Tdiout.c

Abstract:


    This file represents the TDI interface on the bottom edge of NBT.
    The procedures herein conform to the TDI I/F spec. and then convert
    the information to NT specific Irps etc.  This implementation can be
    changed out to run on another OS.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/


#include "precomp.h"   // procedure headings

// function prototypes for completion routines used in this file
NTSTATUS
TdiSendDatagramCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pSendbufferMdl
    );
NTSTATUS
TcpConnectComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );
NTSTATUS
TcpDisconnectComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );
NTSTATUS
SendSessionCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    );

// DEBUG
VOID
CheckIrpList(
    );

//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagram(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PTDI_CONNECTION_INFORMATION     pSendDgramInfo,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tDGRAM_SEND_TRACKING            *pDgramTracker
    )
/*++

Routine Description:

    This routine sends a datagram to the transport

Arguments:

    pSendBuffer     - this is really an Mdl in NT land.  It must be tacked on
                      the end of the Mdl created for the Nbt datagram header.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PMDL             pMdl;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;
    PVOID            pCompletionRoutine;
    tBUFFER          *pSendBuffer = &pDgramTracker->SendBuffer;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    status = GetIrp(&pRequestIrp);      // get an Irp from the list
    if (NT_SUCCESS(status))
    {
        pRequestIrp->CancelRoutine = NULL;

        // set up the completion routine passed in from Udp Send using the APC
        // fields in the Irp that would normally be used to complete the request
        // back to the client - although we are really the client here so we can
        // use these fields our self!
        pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                                (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
        pRequestIrp->Overlay.AsynchronousParameters.UserApcContext = (PVOID)pRequestInfo->RequestContext;

        // Allocate a MDL and set the head sizes correctly
        if (!(pMdl = IoAllocateMdl (pSendBuffer->pDgramHdr, pSendBuffer->HdrLength, FALSE, FALSE, NULL)))
        {
            REMOVE_FROM_LIST(&pRequestIrp->ThreadListEntry);
            ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                        &pRequestIrp->Tail.Overlay.ListEntry,
                                        &NbtConfig.LockInfo.SpinLock);

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiSendDatagram: Failed to get an Irp"));
    }

    // tack the client's send buffer (MDL) onto the end of the datagram header
    // Mdl, and then pass the irp on downward to the transport
    if (NT_SUCCESS(status) && pSendBuffer->pBuffer) {
        pMdl->Next = IoAllocateMdl (pSendBuffer->pBuffer, pSendBuffer->Length, FALSE, FALSE, NULL);
        if (pMdl->Next == NULL) {
            REMOVE_FROM_LIST(&pRequestIrp->ThreadListEntry);
            ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                        &pRequestIrp->Tail.Overlay.ListEntry,
                                        &NbtConfig.LockInfo.SpinLock);

            status = STATUS_INSUFFICIENT_RESOURCES;
            IoFreeMdl(pMdl);
            pMdl = NULL;
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (pRequestInfo->RequestNotifyObject)  // call the completion routine (if there is one)
        {
            NBT_DEREFERENCE_DEVICE (pDgramTracker->pDeviceContext, REF_DEV_UDP_SEND, FALSE);

            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                        ((PVOID)pRequestInfo->RequestContext,
                         STATUS_INSUFFICIENT_RESOURCES,
                         0L);
        }

        return(STATUS_PENDING);         // so the Irp is not completed twice.
    }

    // Map the pages in memory...
    ASSERT(!pSendBuffer->pBuffer || pMdl->Next);
    MmBuildMdlForNonPagedPool(pMdl);
    if (pMdl->Next) {
        MmBuildMdlForNonPagedPool(pMdl->Next);
    }
    pCompletionRoutine = TdiSendDatagramCompletion;

    // store some context stuff in the Irp stack so we can call the completion
    // routine set by the Udpsend code...
    TdiBuildSendDatagram (pRequestIrp,
                          pDeviceObject,
                          pFileObject,
                          pCompletionRoutine,
                          (PVOID)pMdl->Next,   // The completion routine will know that we have allocated an extra MDL
                          pMdl,
                          SendLength,
                          pSendDgramInfo);

    CHECK_COMPLETION(pRequestIrp);
    status = IoCallDriver(pDeviceObject,pRequestIrp);
    *pSentSize = SendLength;            // Fill in the SentSize

    // The transport always completes the IRP, so as long as the irp made it
    // to the transport it got completed. The return code from the transport
    // does not indicate if the irp was completed or not.  The real status
    // of the operation is in the Irp Iostatus return code.
    // What we need to do is make sure NBT does not complete the irp AND the
    // transport complete the Irp.  Therefore this routine returns
    // status pending if the Irp was passed to the transport, regardless of
    // the return code from the transport.  This return code signals the caller
    // that the irp will be completed via the completion routine and the
    // actual status of the send can be found in the Irpss IoStatus.Status
    // variable.
    //
    // If the Caller of this routine gets a bad return code, they can assume
    // that this routine failed to give the Irp to the transport and it
    // is safe for them to complete the Irp themselves.
    //
    // If the Completion routine is set to null, then there is no danger
    // of the irp completing twice and this routine will return the transport
    // return code in that case.

    if (pRequestInfo->RequestNotifyObject)
    {
        return(STATUS_PENDING);
    }
    else
    {
        return(status);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagramCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pSendbufferMdl
    )
/*++

Routine Description:

    This routine handles the completion of a datagram send to the transport.
    It must call the client completion routine and free the Irp and Mdl.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    KIRQL                   OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker = pIrp->Overlay.AsynchronousParameters.UserApcContext;
    tDEVICECONTEXT          *pDeviceContext;

    // check for a completion routine of the clients to call...
    if (pIrp->Overlay.AsynchronousParameters.UserApcRoutine)
    {
        //
        // The Tracker can be free'ed in the routine below, so save the Device ptr
        //
        pDeviceContext = pTracker->pDeviceContext;

        (*((NBT_COMPLETION)pIrp->Overlay.AsynchronousParameters.UserApcRoutine))
                        ((PVOID)pIrp->Overlay.AsynchronousParameters.UserApcContext,
                         pIrp->IoStatus.Status,
                         (ULONG)pIrp->IoStatus.Information);    // sent length

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_UDP_SEND, FALSE);
    }

    // Don't depend on pIrp->MdlAddress->Next which may occassionally changed by others
    ASSERT((PMDL)pSendbufferMdl == pIrp->MdlAddress->Next);
    if (pSendbufferMdl) {
        IoFreeMdl((PMDL)pSendbufferMdl);
    }
    // deallocate the MDL.. this is done by the IO subsystem in IoCompleteRequest
    pIrp->MdlAddress->Next = NULL;
    IoFreeMdl(pIrp->MdlAddress);
    REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
    ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                &pIrp->Tail.Overlay.ListEntry,
                                &NbtConfig.LockInfo.SpinLock);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    return(STATUS_MORE_PROCESSING_REQUIRED);
}



//----------------------------------------------------------------------------
PIRP
NTAllocateNbtIrp(
    IN PDEVICE_OBJECT   DeviceObject
    )
/*++

Routine Description:

    This routine allocates an irp by calling the IO system, and then it
    undoes the queuing of the irp to the current thread, since these are
    NBTs own irps, and should not be attached to a thread.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    PIRP                pIrp;



    // call the IO subsystem to allocate the irp

    pIrp = IoAllocateIrp(DeviceObject->StackSize,FALSE);

    if (!pIrp)
    {
        return(NULL);
    }
    //
    // Simply return a pointer to the packet.
    //

    return pIrp;

}

//----------------------------------------------------------------------------
NTSTATUS
TdiConnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  ULONG_PTR                       lTimeout,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    IN  PIRP                            pClientIrp
    )
/*++

Routine Description:

    This routine sends a connect request to the tranport provider, to setup
    a connection to the other side...

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    // get an Irp from the list
    status = GetIrp(&pRequestIrp);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiConnect: Failed to get an Irp"));
        // call the completion routine with this status
       (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                   ((PVOID)pRequestInfo->RequestContext,
                    STATUS_INSUFFICIENT_RESOURCES,
                    0L);
        return(STATUS_PENDING);
    }
    pRequestIrp->CancelRoutine = NULL;

    // set up the completion routine passed in from Tcp SessionStart using the APC
    // fields in the Irp that would normally be used to complete the request
    // back to the client - although we are really the client here so we can
    // use these fields ourselves
    pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                            (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
    pRequestIrp->Overlay.AsynchronousParameters.UserApcContext =
                            (PVOID)pRequestInfo->RequestContext;

    // store some context stuff in the Irp stack so we can call the completion
    // routine set by the Udpsend code...
    TdiBuildConnect(
        pClientIrp,
        pDeviceObject,
        pFileObject,
        TcpConnectComplete,
        (PVOID)pRequestIrp,   //context value passed to completion routine
        lTimeout,           // use timeout on connect
        pSendInfo,
        NULL);

    pRequestIrp->MdlAddress = NULL;

    CHECK_COMPLETION(pClientIrp);
    status = IoCallDriver(pDeviceObject,pClientIrp);

    // the transport always completes the IRP, so we always return status pending
    return(STATUS_PENDING);

}


//----------------------------------------------------------------------------
NTSTATUS
TdiDisconnect(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  PVOID                           lTimeout,
    IN  ULONG                           Flags,
    IN  PTDI_CONNECTION_INFORMATION     pSendInfo,
    IN  PCTE_IRP                        pClientIrp,
    IN  BOOLEAN                         Wait
    )
/*++

Routine Description:

    This routine sends a connect request to the tranport provider, to setup
    a connection to the other side...

Arguments:

    pClientIrp - this is the irp that the client used when it issued an
                 NbtDisconnect.  We pass this irp to the transport so that
                 the client can do a Ctrl C and cancel the irp if the
                 disconnect takes too long.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    status = GetIrp(&pRequestIrp);
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiDisconnect: Failed to get an Irp"));
        // call the completion routine will  this status
       (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                   ((PVOID)pRequestInfo->RequestContext,
                    STATUS_INSUFFICIENT_RESOURCES,
                    0L);
        return(STATUS_PENDING);
    }
    if (!pClientIrp)
    {
        // if no client irp was passed in, then just use our Irp
        pClientIrp = pRequestIrp;
    }
    pRequestIrp->CancelRoutine = NULL;

    // set up the completion routine passed in from Tcp SessionStart using the APC
    // fields in the Irp that would normally be used to complete the request
    // back to the client - although we are really the client here so we can
    // use these fields ourselves
    pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                            (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
    pRequestIrp->Overlay.AsynchronousParameters.UserApcContext =
                            (PVOID)pRequestInfo->RequestContext;

    // store some context stuff in the Irp stack so we can call the completion
    // routine set by the Udpsend code...
    // Note that pRequestIrp is passed to the completion routine as a context
    // value so we will know the routine to call for the client's completion.
    TdiBuildDisconnect(
        pClientIrp,
        pDeviceObject,
        pFileObject,
        TcpConnectComplete,
        (PVOID)pRequestIrp,   //context value passed to completion routine
        lTimeout,
        Flags,
        NULL,          // send connection info
        NULL);              // return connection info

    pRequestIrp->MdlAddress = NULL;

    // if Wait is set, then this means do a synchronous disconnect and block
    // until the irp is returned.
    //
    if (Wait)
    {
        status = SubmitTdiRequest(pFileObject,pClientIrp);
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_TDIOUT)
                KdPrint (("Nbt.TdiDisconnect:  ERROR -- SubmitTdiRequest returned <%x>\n", status));
        }

        //
        // return the irp to its pool
        //
        REMOVE_FROM_LIST(&pRequestIrp->ThreadListEntry);
        ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                    &pRequestIrp->Tail.Overlay.ListEntry,
                                    &NbtConfig.LockInfo.SpinLock);
        return(status);
    }
    else
    {
        CHECK_COMPLETION(pClientIrp);
        status = IoCallDriver(pDeviceObject,pClientIrp);
        // the transport always completes the IRP, so we always return status pending
        return(STATUS_PENDING);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
TcpConnectComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of a TCP session setup.  The TCP
    connection is either setup or not depending on the status returned here.
    It must called the clients completion routine (in udpsend.c).  Which should
    look after sending the NetBios sesion startup pdu across the TCP connection.

    The pContext value is actually one of NBTs irps that is JUST used to store
    the calling routines completion routine.  The real Irp used is the original
    client's irp.  This is done so that IoCancelIrp will cancel the connect
    properly.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    KIRQL   OldIrq;
    PIRP    pMyIrp;

    pMyIrp = (PIRP)pContext;

    // check for a completion routine of the clients to call...
    if (pMyIrp->Overlay.AsynchronousParameters.UserApcRoutine)
    {
       (*((NBT_COMPLETION)pMyIrp->Overlay.AsynchronousParameters.UserApcRoutine))
                   ((PVOID)pMyIrp->Overlay.AsynchronousParameters.UserApcContext,
                    pIrp->IoStatus.Status,
                    0L);

    }

    REMOVE_FROM_LIST(&pMyIrp->ThreadListEntry);
    ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                &pMyIrp->Tail.Overlay.ListEntry,
                                &NbtConfig.LockInfo.SpinLock);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is not initiating thread - we are the initiator
    return(STATUS_MORE_PROCESSING_REQUIRED);

}
//----------------------------------------------------------------------------
NTSTATUS
TdiSend(
    IN  PTDI_REQUEST                    pRequestInfo,
    IN  USHORT                          sFlags,
    IN  ULONG                           SendLength,
    OUT PULONG                          pSentSize,
    IN  tBUFFER                         *pSendBuffer,
    IN  ULONG                           Flags
    )
/*++

Routine Description:

    This routine sends a packet to the transport on a TCP connection

Arguments:

    pSendBuffer     - this is really an Mdl in NT land.  It must be tacked on
                      the end of the Mdl created for the Nbt datagram header.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS         status;
    PIRP             pRequestIrp;
    PMDL             pMdl;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;

    // get an Irp to send the message in
    pFileObject = (PFILE_OBJECT)pRequestInfo->Handle.AddressHandle;
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

    // get an Irp from the list
    status = GetIrp(&pRequestIrp);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_TDIOUT)
            KdPrint(("Nbt.TdiSend: Failed to get an Irp"));
        // call the completion routine with  this status
        if (pRequestInfo->RequestNotifyObject)
        {
            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                        ((PVOID)pRequestInfo->RequestContext,
                         STATUS_INSUFFICIENT_RESOURCES,
                         0L);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    pRequestIrp->CancelRoutine = NULL;


    // set up the completion routine passed in from Udp Send using the APC
    // fields in the Irp that would normally be used to complete the request
    // back to the client - although we are really the client here so we can
    // use these fields our self!
    pRequestIrp->Overlay.AsynchronousParameters.UserApcRoutine =
                            (PIO_APC_ROUTINE)pRequestInfo->RequestNotifyObject;
    pRequestIrp->Overlay.AsynchronousParameters.UserApcContext =
                            (PVOID)pRequestInfo->RequestContext;


    // get the MDL that is currently linked to the IRP (i.e. created at the
    // same time that we created the IRP list. Set the sizes correctly in
    // the MDL header.
    pMdl = IoAllocateMdl(
                    pSendBuffer->pDgramHdr,
                    pSendBuffer->HdrLength,
                    FALSE,
                    FALSE,
                    NULL);

    if (!pMdl)
    {
        REMOVE_FROM_LIST(&pRequestIrp->ThreadListEntry);
        ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                    &pRequestIrp->Tail.Overlay.ListEntry,
                                    &NbtConfig.LockInfo.SpinLock);

        // call the completion routine will  this status
        if (pRequestInfo->RequestNotifyObject)
        {
            (*((NBT_COMPLETION)pRequestInfo->RequestNotifyObject))
                        ((PVOID)pRequestInfo->RequestContext,
                         STATUS_INSUFFICIENT_RESOURCES,
                         0L);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Map the pages in memory...
    MmBuildMdlForNonPagedPool(pMdl);

    TdiBuildSend(
        pRequestIrp,
        pDeviceObject,
        pFileObject,
        SendSessionCompletionRoutine,
        NULL,                     //context value passed to completion routine
        pMdl,
        sFlags,
        SendLength);    // include session hdr length (ULONG)
    //
    // tack the Client's buffer on the end, if there is one
    //
    if (pSendBuffer->Length)
    {
        pMdl->Next = pSendBuffer->pBuffer;
    }

    CHECK_COMPLETION(pRequestIrp);
    status = IoCallDriver(pDeviceObject,pRequestIrp);

    *pSentSize = SendLength; // the size we attempted to send

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
SendSessionCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine handles the completion of a send to the transport.
    It must call any client supplied completion routine and free the Irp
    and Mdl back to its pool.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    KIRQL       OldIrq;

    //
    // check for a completion routine of the clients to call...
    //
    if (pIrp->Overlay.AsynchronousParameters.UserApcRoutine)
    {
       (*((NBT_COMPLETION)pIrp->Overlay.AsynchronousParameters.UserApcRoutine))
                   ((PVOID)pIrp->Overlay.AsynchronousParameters.UserApcContext,
                    pIrp->IoStatus.Status,
                    (ULONG)pIrp->IoStatus.Information);    // sent length

    }



    IoFreeMdl(pIrp->MdlAddress);

    REMOVE_FROM_LIST(&pIrp->ThreadListEntry);
    ExInterlockedInsertTailList(&NbtConfig.IrpFreeList,
                                &pIrp->Tail.Overlay.ListEntry,
                                &NbtConfig.LockInfo.SpinLock);
    //
    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    //
    return(STATUS_MORE_PROCESSING_REQUIRED);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	debug.h
//
// Description: Debug macros definitions
//
// Author:	Stefan Solomon (stefans)    October 4, 1993.
//
// Revision History:
//
//***

#ifndef _IPXFLT_DEBUG_
#define _IPXFLT_DEBUG_

#if DBG
extern ULONG DbgLevel;
#define DBG_IOCTLS		0x00000001
#define DBG_FWDIF		0x00000002
#define DBG_IFHASH		0x00000010
#define DBG_PKTCACHE	0x00000020
#define DBG_PKTLOGS		0x00000100
#define DBG_ERRORS		0x10000000

#define DEF_DBG_LEVEL	(DBG_IOCTLS|DBG_FWDIF|DBG_ERRORS|DBG_IFHASH)

#define IpxFltDbgPrint(LEVEL,ARGS)										\
	do {															    \
		if (DbgLevel & (LEVEL)) {										\
			DbgPrint ARGS;											    \
		}															    \
	} while (0)

#else
#define IpxFltDbgPrint(LEVEL,ARGS) do {NOTHING;} while (0)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\filter.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\filter.c

Abstract:
    IPX Filter driver filtering and maintanance routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

	// Masks to test components of the filter descriptor
	// (Have to use globals in lue of constants to get correct
	// byte ordering)
const union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_Network;
		ULONGLONG		FD_NetworkSrcDst;
	} FltSrcNetMask = {{{0xFF, 0xFF, 0xFF, 0xFF}, {0, 0, 0, 0}}};
#define FLT_SRC_NET_MASK FltSrcNetMask.FD_NetworkSrcDst

const union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_Network;
		ULONGLONG		FD_NetworkSrcDst;
	} FltDstNetMask = {{{0, 0, 0, 0}, {0xFF, 0xFF, 0xFF, 0xFF}}};
#define FLT_DST_NET_MASK FltDstNetMask.FD_NetworkSrcDst

const union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_NS;
		ULONGLONG		FD_NodeSocket;
	} FltNodeMask = {{{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, {0, 0}}};
#define FLT_NODE_MASK FltNodeMask.FD_NodeSocket

const union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_NS;
		ULONGLONG		FD_NodeSocket;
	} FltSocketMask = {{{0, 0, 0, 0, 0, 0}, {0xFF, 0xFF}}};
#define FLT_SOCKET_MASK FltSocketMask.FD_NodeSocket

	// Hash tables of interface control blocks with filter descriptions
		// Input filters
LIST_ENTRY	InterfaceInHash[FLT_INTERFACE_HASH_SIZE];
		// Output filters
LIST_ENTRY	InterfaceOutHash[FLT_INTERFACE_HASH_SIZE];
		// Serializes access to interface table
FAST_MUTEX		InterfaceTableLock;
LIST_ENTRY		LogIrpQueue;
USHORT			LogSeqNum;


	// Hash function for interface hash tables
#define InterfaceIndexHash(Index) (Index%FLT_INTERFACE_HASH_SIZE)

	// Packet descriptor block
typedef struct _PACKET_DESCR {
	union {
		struct {
			ULONG			Src;			// Source network
			ULONG			Dst;			// Destination network
		}				PD_Network;
		ULONGLONG		PD_NetworkSrcDst;	// Combined field
	};
	ULONGLONG			PD_SrcNodeSocket;	// Source node & socket
	ULONGLONG			PD_DstNodeSocket;	// Destination node & socket
	LONG				PD_ReferenceCount;	// Filter reference count
	UCHAR				PD_PacketType;		// Packet type
	BOOLEAN				PD_LogMatches;
} PACKET_DESCR, *PPACKET_DESCR;

	// Packet cache (only though that pass the filter)
PPACKET_DESCR	PacketCache[FLT_PACKET_CACHE_SIZE];
KSPIN_LOCK		PacketCacheLock;


/*++
	A c q u i r e P a c k e t R e f e r e n c e

Routine Description:

	Returns reference to the packet descriptor in the cache

Arguments:
	idx			- cache index
	pd			- pointer to packet descriptor to be returned

Return Value:
	None

--*/
//VOID
//AcquirePacketReference (
//	IN UINT				idx,
//	OUT PPACKET_DESCR	pd
//	);
#define AcquirePacketReference(idx,pd)	{				\
	KIRQL		oldIRQL;								\
	KeAcquireSpinLock (&PacketCacheLock, &oldIRQL);		\
	if ((pd=PacketCache[idx])!=NULL)					\
		InterlockedIncrement (&pd->PD_ReferenceCount);	\
	KeReleaseSpinLock (&PacketCacheLock, oldIRQL);		\
}

/*++
	R e l e a s e P a c k e t R e f e r e n c e

Routine Description:

	Releases reference to the cached packet descriptor

Arguments:
	pd			- pointer to packet descriptor to release

Return Value:
	None

--*/
//VOID
//ReleasePacketReference (
//	IN PPACKET_DESCR	pd
//	);
#define ReleasePacketReference(pd)	{						\
	if (InterlockedDecrement (&pd->PD_ReferenceCount)>=0)	\
		NOTHING;											\
	else													\
		ExFreePool (pd);									\
}

/*++
	R e p l a c e P a c k e t R e f e r e n c e

Routine Description:

	Replaces packet cache entry

Arguments:
	idx			- cache index
	pd			- pointer to packet descriptor to be installed in the cache

Return Value:
	None

--*/
//VOID
//ReplacePacket (
//	IN UINT				idx,
//	IN PPACKET_DESCR	pd
//	);
#define ReplacePacket(idx,pd)	{							\
	KIRQL			oldIRQL;								\
	PPACKET_DESCR	oldPD;									\
	KeAcquireSpinLock (&PacketCacheLock, &oldIRQL);			\
	oldPD = PacketCache[idx];								\
	PacketCache[idx] = pd;									\
	KeReleaseSpinLock (&PacketCacheLock, oldIRQL);			\
	IpxFltDbgPrint (DBG_PKTCACHE,							\
		 ("IpxFlt: Replaced packet descriptor %08lx"		\
			" with %08lx in cache at index %ld.\n",			\
			oldPD, pd, idx));								\
	if (oldPD!=NULL) {										\
		ReleasePacketReference(oldPD);						\
	}														\
}

	// Defined below
VOID
FlushPacketCache (
	VOID
	);

/*++
	I n i t i a l i z e T a b l e s

Routine Description:

	Initializes hash and cash tables and protection stuff
Arguments:
	None
Return Value:
	STATUS_SUCCESS

--*/
NTSTATUS
InitializeTables (
	VOID
	) {
	UINT	i;
	for (i=0; i<FLT_INTERFACE_HASH_SIZE; i++) {
		InitializeListHead (&InterfaceInHash[i]);
		InitializeListHead (&InterfaceOutHash[i]);
	}

	for (i=0; i<FLT_PACKET_CACHE_SIZE; i++) {
		PacketCache[i] = NULL;
	}
	KeInitializeSpinLock (&PacketCacheLock);
	ExInitializeFastMutex (&InterfaceTableLock);
	InitializeListHead (&LogIrpQueue);
	LogSeqNum = 0;
	return STATUS_SUCCESS;
}

/*++
	D e l e t e T a b l e s

Routine Description:

	Deletes hash and cash tables
Arguments:
	None
Return Value:
	None

--*/
VOID
DeleteTables (
	VOID
	) {
	UINT	i;

	for (i=0; i<FLT_INTERFACE_HASH_SIZE; i++) {
		while (!IsListEmpty (&InterfaceInHash[i])) {
			NTSTATUS		status;
			PINTERFACE_CB	ifCB = CONTAINING_RECORD (InterfaceInHash[i].Flink,
									INTERFACE_CB, ICB_Link);
			status = FwdSetFilterInContext (ifCB->ICB_Index, NULL);
			ASSERT (status==STATUS_SUCCESS);
			RemoveEntryList (&ifCB->ICB_Link);
			ExFreePool (ifCB);
		}
		while (!IsListEmpty (&InterfaceOutHash[i])) {
			NTSTATUS		status;
			PINTERFACE_CB	ifCB = CONTAINING_RECORD (InterfaceOutHash[i].Flink,
									INTERFACE_CB, ICB_Link);
			status = FwdSetFilterOutContext (ifCB->ICB_Index, NULL);
			ASSERT (status==STATUS_SUCCESS);
			RemoveEntryList (&ifCB->ICB_Link);
			ExFreePool (ifCB);
		}
	}
	for (i=0; i<FLT_PACKET_CACHE_SIZE; i++) {
		if (PacketCache[i] != NULL)
			ExFreePool (PacketCache[i]);
	}
	return ;
}


/*++
	S e t F i l t e r s

Routine Description:
	
	Sets/replaces filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	FilterInfoSize - size of the info array
	FilterInfo	- array of filter descriptions (UI format)
Return Value:
	STATUS_SUCCESS - filter info was set/replaced ok
	STATUS_UNSUCCESSFUL - could not set filter context in forwarder
	STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
						filter info block for interface

--*/
NTSTATUS
SetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						Index,
	IN ULONG						FilterAction,
	IN ULONG						FilterInfoSize,
	IN PIPX_TRAFFIC_FILTER_INFO		FilterInfo
	) {
	PINTERFACE_CB	ifCB = NULL, oldCB = NULL;
	ULONG			FilterCount 
						= FilterInfoSize/sizeof (IPX_TRAFFIC_FILTER_INFO);
	ULONG			i;
	PFILTER_DESCR	fd;
	PLIST_ENTRY		HashBucket = &HashTable[InterfaceIndexHash(Index)], cur;
	NTSTATUS		status = STATUS_SUCCESS;

	if (FilterCount>0) {
		ifCB = ExAllocatePoolWithTag (
					NonPagedPool,
					FIELD_OFFSET (INTERFACE_CB, ICB_Filters[FilterCount]),
					IPX_FLT_TAG
					);
		if (ifCB==NULL) {
			IpxFltDbgPrint (DBG_IFHASH|DBG_ERRORS,
				("IpxFlt: Could not allocate interface CB for if %ld.\n",
				Index));
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		ifCB->ICB_Index = Index;
		ifCB->ICB_FilterAction = (FilterAction==IPX_TRAFFIC_FILTER_ACTION_PERMIT)
									? FILTER_PERMIT : FILTER_DENY;
		ifCB->ICB_FilterCount = FilterCount;
			// Copy/Map UI filters to the internal format
		for (i=0, fd = ifCB->ICB_Filters; i<FilterCount; i++, fd++, FilterInfo++) {
			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_SRCNET) {
				memcpy (fd->FD_Network.Src, FilterInfo->SourceNetwork, 4);
				memcpy (fd->FD_NetworkMask.Src, FilterInfo->SourceNetworkMask, 4);
			}
			else {
				memset (fd->FD_Network.Src, 0, 4);
				memset (fd->FD_NetworkMask.Src, 0, 4);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_DSTNET) {
				memcpy (fd->FD_Network.Dst, FilterInfo->DestinationNetwork, 4);
				memcpy (fd->FD_NetworkMask.Dst, FilterInfo->DestinationNetworkMask, 4);
			}
			else {
				memset (fd->FD_Network.Dst, 0, 4);
				memset (fd->FD_NetworkMask.Dst, 0, 4);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_SRCNODE) {
				memcpy (fd->FD_SrcNS.Node, FilterInfo->SourceNode, 6);
				memset (fd->FD_SrcNSMask.Node, 0xFF, 6);
			}
			else {
				memset (fd->FD_SrcNS.Node, 0, 6);
				memset (fd->FD_SrcNSMask.Node, 0, 6);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_SRCSOCKET) {
				memcpy (fd->FD_SrcNS.Socket, FilterInfo->SourceSocket, 2);
				memset (fd->FD_SrcNSMask.Socket, 0xFF, 2);
			}
			else {
				memset (fd->FD_SrcNS.Socket, 0, 2);
				memset (fd->FD_SrcNSMask.Socket, 0, 2);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_DSTNODE) {
				memcpy (fd->FD_DstNS.Node, FilterInfo->DestinationNode, 6);
				memset (fd->FD_DstNSMask.Node, 0xFF, 6);
			}
			else {
				memset (fd->FD_DstNS.Node, 0, 6);
				memset (fd->FD_DstNSMask.Node, 0, 6);
			}

			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_DSTSOCKET) {
				memcpy (fd->FD_DstNS.Socket, FilterInfo->DestinationSocket, 2);
				memset (fd->FD_DstNSMask.Socket, 0xFF, 2);
			}
			else {
				memset (fd->FD_DstNS.Socket, 0, 2);
				memset (fd->FD_DstNSMask.Socket, 0, 2);
			}
			if (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_ON_PKTTYPE) {
				fd->FD_PacketType = FilterInfo->PacketType;
				fd->FD_PacketTypeMask = 0xFF;
			}
			else {
				fd->FD_PacketType = 0;
				fd->FD_PacketTypeMask = 0;
			}

			fd->FD_LogMatches = (FilterInfo->FilterDefinition&IPX_TRAFFIC_FILTER_LOG_MATCHES)!=0;
		}
	}

	ExAcquireFastMutex (&InterfaceTableLock);

		// Find the old block and/or a place for a new one
	cur = HashBucket->Flink;
	while (cur!=HashBucket) {
		oldCB = CONTAINING_RECORD (cur, INTERFACE_CB, ICB_Link);
		if (oldCB->ICB_Index==Index) {
				// Found the old one, place new after it
			cur = cur->Flink;
			break;
		}
		else if (oldCB->ICB_Index>Index) {
				// No chance to see the old one anymore, place where
				// we are now
			oldCB = NULL;
			break;
		}
		cur = cur->Flink;
	}
		
		// Set context in forwarder
	if (HashTable==InterfaceInHash) {
		status = FwdSetFilterInContext (Index, ifCB);
	}
	else {
		ASSERT (HashTable==InterfaceOutHash);
		status = FwdSetFilterOutContext (Index, ifCB);
	}

	if (NT_SUCCESS (status)) {
			// Update table if we succeded
		IpxFltDbgPrint (DBG_IFHASH,
			("IpxFlt: Set filters for if %ld (ifCB:%08lx).\n",
			Index, ifCB));

		if (oldCB!=NULL) {
			IpxFltDbgPrint (DBG_IFHASH,
				("IpxFlt: Deleting replaced filters for if %ld (ifCB:%08lx).\n",
				Index, oldCB));
			RemoveEntryList (&oldCB->ICB_Link);
			ExFreePool (oldCB);
		}



		if (ifCB!=NULL) {
			InsertTailList (cur, &ifCB->ICB_Link);
		}

		FlushPacketCache ();
	}
	else {
		IpxFltDbgPrint (DBG_IFHASH|DBG_ERRORS,
			("IpxFlt: Failed to set context for if %ld (ifCB:%08lx).\n",
			Index, ifCB));
	}

	ExReleaseFastMutex (&InterfaceTableLock);
	return status;
}

/*++
	G e t F i l t e r s

Routine Description:
	
	Gets filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	TotalSize	- total memory required to hold all filter descriptions
	FilterInfo	- array of filter descriptions (UI format)
	FilterInfoSize - on input: size of the info array
					on output: size of the info placed in the array
Return Value:
	STATUS_SUCCESS - filter info was returned ok
	STATUS_BUFFER_OVERFLOW - array is not big enough to hold all
					filter info, only placed the info that fit

--*/
NTSTATUS
GetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						Index,
	OUT ULONG						*FilterAction,
	OUT ULONG						*TotalSize,
	OUT PIPX_TRAFFIC_FILTER_INFO	FilterInfo,
	IN OUT ULONG					*FilterInfoSize
	) {
	PINTERFACE_CB	oldCB = NULL;
	ULONG			i, AvailBufCount = 
						(*FilterInfoSize)/sizeof (IPX_TRAFFIC_FILTER_INFO);
	PFILTER_DESCR	fd;
	PLIST_ENTRY		HashBucket = &HashTable[InterfaceIndexHash(Index)], cur;
	NTSTATUS		status = STATUS_SUCCESS;

		// Locate interface filters block
	ExAcquireFastMutex (&InterfaceTableLock);
	cur = HashBucket->Flink;
	while (cur!=HashBucket) {
		oldCB = CONTAINING_RECORD (cur, INTERFACE_CB, ICB_Link);
		if (oldCB->ICB_Index==Index) {
			cur = cur->Flink;
			break;
		}
		else if (oldCB->ICB_Index>Index) {
			oldCB = NULL;
			break;
		}
		cur = cur->Flink;
	}

	if (oldCB!=NULL) {
		*FilterAction = IS_FILTERED(oldCB->ICB_FilterAction)
				? IPX_TRAFFIC_FILTER_ACTION_DENY
                : IPX_TRAFFIC_FILTER_ACTION_PERMIT;
		*TotalSize = oldCB->ICB_FilterCount*sizeof (IPX_TRAFFIC_FILTER_INFO);
			// Copy/Map as many descriptors as fit
		for (i=0, fd = oldCB->ICB_Filters;
					(i<oldCB->ICB_FilterCount) && (i<AvailBufCount);
					i++, fd++, FilterInfo++) {
			FilterInfo->FilterDefinition = 0;
			if (fd->FD_NetworkMaskSrcDst&FLT_SRC_NET_MASK) {
				memcpy (FilterInfo->SourceNetwork, fd->FD_Network.Src, 4);
				memcpy (FilterInfo->SourceNetworkMask, fd->FD_NetworkMask.Src, 4);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNET;
			}

			if (fd->FD_NetworkMaskSrcDst&FLT_DST_NET_MASK) {
				memcpy (FilterInfo->DestinationNetwork, fd->FD_Network.Dst, 4);
				memcpy (FilterInfo->DestinationNetworkMask, fd->FD_NetworkMask.Dst, 4);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNET;
			}

			if (fd->FD_SrcNodeSocketMask&FLT_NODE_MASK) {
				memcpy (FilterInfo->SourceNode, fd->FD_SrcNS.Node, 6);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCNODE;
			}

			if (fd->FD_DstNodeSocketMask&FLT_NODE_MASK) {
				memcpy (FilterInfo->DestinationNode, fd->FD_DstNS.Node, 6);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTNODE;
			}

			if (fd->FD_SrcNodeSocketMask&FLT_SOCKET_MASK) {
				memcpy (FilterInfo->SourceSocket, fd->FD_SrcNS.Socket, 2);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_SRCSOCKET;
			}
			if (fd->FD_DstNodeSocketMask&FLT_SOCKET_MASK) {
				memcpy (FilterInfo->DestinationSocket, fd->FD_DstNS.Socket, 2);
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_DSTSOCKET;
			}
			if (fd->FD_PacketTypeMask&0xFF) {
				FilterInfo->PacketType = fd->FD_PacketType;
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_ON_PKTTYPE;
			}
			if (fd->FD_LogMatches)
				FilterInfo->FilterDefinition |= IPX_TRAFFIC_FILTER_LOG_MATCHES;
		}

		*FilterInfoSize = i*sizeof (IPX_TRAFFIC_FILTER_INFO);

		IpxFltDbgPrint (DBG_IFHASH, 
			("IpxFlt: Returning %d filters (%d available)"
				" for interface %d (ifCB: %08lx).\n",
				i, oldCB->ICB_FilterCount, Index));
		if (i<oldCB->ICB_FilterCount)
			status = STATUS_BUFFER_OVERFLOW;
		ExReleaseFastMutex (&InterfaceTableLock);
	}
	else {
			// No interface block -> we are passing all the packets
			// unfiltered
		ExReleaseFastMutex (&InterfaceTableLock);
		IpxFltDbgPrint (DBG_IFHASH, 
			("IpxFlt: No filters for interface %d.\n", Index));
		*FilterAction = IPX_TRAFFIC_FILTER_ACTION_PERMIT;
		*TotalSize = 0;
		*FilterInfoSize = 0;
	}
	return status;
}


VOID
LogPacket (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	) {
	PIRP				irp;
	PIO_STACK_LOCATION	irpStack;
    ULONG				outBufLength;
    PUCHAR				outBuffer;
	ULONG_PTR			offset;
	KIRQL				cancelIRQL;

	IoAcquireCancelSpinLock (&cancelIRQL);
	LogSeqNum += 1;
	while (!IsListEmpty (&LogIrpQueue)) {
		irp = CONTAINING_RECORD (LogIrpQueue.Flink,IRP,Tail.Overlay.ListEntry);
		irpStack = IoGetCurrentIrpStackLocation(irp);
		outBufLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
		if (irp->MdlAddress == NULL)
		{
		    outBuffer = NULL;
		}
		else
		{
    		outBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe (irp->MdlAddress, NormalPagePriority);
		}
		if (outBuffer != NULL)
		{
    		offset = (PUCHAR) ALIGN_UP ((ULONG_PTR)outBuffer + (ULONG_PTR)irp->IoStatus.Information, ULONG) - outBuffer;
    		if (offset+ipxHdrLength+FIELD_OFFSET (FLT_PACKET_LOG, Header)<outBufLength) {
    			PFLT_PACKET_LOG	pLog = (PFLT_PACKET_LOG) (outBuffer+offset);
    			pLog->SrcIfIdx = ifInContext 
    								? ((PINTERFACE_CB)ifInContext)->ICB_Index
    								: -1;
    			pLog->DstIfIdx = ifOutContext 
    								? ((PINTERFACE_CB)ifOutContext)->ICB_Index
    								: -1;
    			pLog->DataSize = (USHORT)ipxHdrLength;
    			pLog->SeqNum = LogSeqNum;
    			memcpy (pLog->Header, ipxHdr, ipxHdrLength);
    			irp->IoStatus.Information = offset+FIELD_OFFSET (FLT_PACKET_LOG, Header[ipxHdrLength]);
    			if (irp->Tail.Overlay.ListEntry.Flink!=&LogIrpQueue) {
    				RemoveEntryList (&irp->Tail.Overlay.ListEntry);
    				IoSetCancelRoutine (irp, NULL);
    				irp->IoStatus.Status = STATUS_SUCCESS;
    				IoReleaseCancelSpinLock (cancelIRQL);
    				IpxFltDbgPrint (DBG_PKTLOGS,
    					("IpxFlt: completing logging request"
    					" with %d bytes of data.\n",
    					irp->IoStatus.Information));
    				IoCompleteRequest (irp, IO_NO_INCREMENT);
    				return;
    			}
    			else
    				break;
    		}
        }    		
		RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        IoSetCancelRoutine (irp, NULL);
		irp->IoStatus.Status = STATUS_SUCCESS;
		IoReleaseCancelSpinLock (cancelIRQL);
	    IpxFltDbgPrint (DBG_ERRORS|DBG_PKTLOGS,
			("IpxFlt: completing logging request"
			" with %d bytes of data (not enough space).\n",
			irp->IoStatus.Information));
		IoCompleteRequest (irp, IO_NO_INCREMENT);
		IoAcquireCancelSpinLock (&cancelIRQL);
	}
	IoReleaseCancelSpinLock (cancelIRQL);
}


/*++
	F i l t e r

Routine Description:
	
	Filters the packet supplied by the forwarder

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT		- packet should be passed on by the forwarder
	FILTER_DENY_IN		- packet should be dropped because of input filter
	FILTER_DENY_OUT		- packet should be dropped because of output filter
--*/
FILTER_ACTION
Filter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	) {
	PACKET_DESCR	pd;
	FILTER_ACTION	res = FILTER_PERMIT;
	UINT			idx;

	ASSERT (ipxHdrLength>=IPXH_HDRSIZE);
		// Copy packet to aligned buffer
	pd.PD_Network.Dst = *((UNALIGNED ULONG *)(ipxHdr+IPXH_DESTNET));
	pd.PD_Network.Src = *((UNALIGNED ULONG *)(ipxHdr+IPXH_SRCNET));
	pd.PD_DstNodeSocket = *((UNALIGNED ULONGLONG *)(ipxHdr+IPXH_DESTNODE));
	pd.PD_SrcNodeSocket = *((UNALIGNED ULONGLONG *)(ipxHdr+IPXH_SRCNODE));
	pd.PD_PacketType = *(ipxHdr+IPXH_PKTTYPE);
	pd.PD_LogMatches = FALSE;
		// We do not cache netbios broadcast
	if (pd.PD_PacketType!=IPX_NETBIOS_TYPE) {
		PPACKET_DESCR	cachedPD;
			// Get cached packet
		idx = (UINT)((pd.PD_Network.Dst
								+pd.PD_DstNodeSocket
								+pd.PD_PacketType)
							%FLT_PACKET_CACHE_SIZE);
		AcquirePacketReference (idx, cachedPD);
		if (cachedPD!=NULL) {
				// Fast path: packet in the cache matches
			if ((pd.PD_NetworkSrcDst==cachedPD->PD_NetworkSrcDst)
					&& (pd.PD_SrcNodeSocket==cachedPD->PD_SrcNodeSocket)
					&& (pd.PD_DstNodeSocket==cachedPD->PD_DstNodeSocket)
					&& (pd.PD_PacketType==cachedPD->PD_PacketType)) {
				if (cachedPD->PD_LogMatches)
					LogPacket (ipxHdr,ipxHdrLength,ifInContext,ifOutContext);
				ReleasePacketReference (cachedPD);
				return FILTER_PERMIT;
			}
				// Do not need cached packet anymore
			ReleasePacketReference (cachedPD);
		}
	}
		// Slow path: check all filters
	if (ifInContext!=NO_FILTER_CONTEXT) {
		PFILTER_DESCR	fd,	fdEnd;
			// Read default result (no filter match)
		res = NOT_FILTER_ACTION(((PINTERFACE_CB)ifInContext)->ICB_FilterAction);
		fd = ((PINTERFACE_CB)ifInContext)->ICB_Filters;
		fdEnd = &((PINTERFACE_CB)ifInContext)->ICB_Filters
					[((PINTERFACE_CB)ifInContext)->ICB_FilterCount];
		while (fd<fdEnd) {
			if (	((pd.PD_NetworkSrcDst & fd->FD_NetworkMaskSrcDst)
						== fd->FD_NetworkSrcDst)
				&&	((pd.PD_SrcNodeSocket & fd->FD_SrcNodeSocketMask)
						== fd->FD_SrcNodeSocket)
				&&	((pd.PD_DstNodeSocket & fd->FD_DstNodeSocketMask)
						== fd->FD_DstNodeSocket)
				&&	((pd.PD_PacketType & fd->FD_PacketTypeMask)
						== fd->FD_PacketType) ) {
					// Filter match: reverse the result
				res = NOT_FILTER_ACTION(res);
				if (fd->FD_LogMatches) {
					pd.PD_LogMatches = TRUE;
					LogPacket (ipxHdr,ipxHdrLength,ifInContext,ifOutContext);
				}
				break;
			}
			fd++;
		}
					// Return right away if told to drop
		if (IS_FILTERED(res))
			return FILTER_DENY_IN;
	}

	if (ifOutContext!=NO_FILTER_CONTEXT) {
		PFILTER_DESCR	fd,	fdEnd;
			// Read default result (no filter match)
		res = NOT_FILTER_ACTION(((PINTERFACE_CB)ifOutContext)->ICB_FilterAction);
		fd = ((PINTERFACE_CB)ifOutContext)->ICB_Filters;
		fdEnd = &((PINTERFACE_CB)ifOutContext)->ICB_Filters
					[((PINTERFACE_CB)ifOutContext)->ICB_FilterCount];
		while (fd<fdEnd) {
			if (	((pd.PD_NetworkSrcDst & fd->FD_NetworkMaskSrcDst)
						== fd->FD_NetworkSrcDst)
				&&	((pd.PD_SrcNodeSocket & fd->FD_SrcNodeSocketMask)
						== fd->FD_SrcNodeSocket)
				&&	((pd.PD_DstNodeSocket & fd->FD_DstNodeSocketMask)
						== fd->FD_DstNodeSocket)
				&&	((pd.PD_PacketType & fd->FD_PacketTypeMask)
						== fd->FD_PacketType) ) {
					// Filter match: reverse the result
				res = NOT_FILTER_ACTION(res);
				if (fd->FD_LogMatches&&!pd.PD_LogMatches) {
					pd.PD_LogMatches = TRUE;
					LogPacket (ipxHdr,ipxHdrLength,ifInContext,ifOutContext);
				}
				break;
			}
			fd++;
		}
					// Return right away if told to drop
		if (IS_FILTERED(res))
			return FILTER_DENY_OUT;
	}

			// Cache the packet (we know that it is a pass
			// because we would have returned if it was a drop)
	if (pd.PD_PacketType!=IPX_NETBIOS_TYPE) {
		PPACKET_DESCR	cachedPD;
		cachedPD = ExAllocatePoolWithTag (
					NonPagedPool,
					sizeof (PACKET_DESCR),
					IPX_FLT_TAG
					);
		if (cachedPD!=NULL) {
			*cachedPD = pd;
			cachedPD->PD_ReferenceCount = 0;
			ReplacePacket (idx, cachedPD);
		}
	}

	return res;
}


/*++
	I n t e r f a c e D e l e t e d

Routine Description:
	
	Frees interface filters blocks when forwarder indicates that
	interface is deleted
Arguments:
	ifInContext		- context associated with input filters block	
	ifOutContext	- context associated with output filters block
Return Value:
	None

--*/
VOID
InterfaceDeleted (
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	) {
	IpxFltDbgPrint (DBG_FWDIF,
		("IpxFlt: InterfaceDeleted indication,"
			"(inContext: %08lx, outContext: %08lx).\n",
			ifInContext, ifOutContext));
	ExAcquireFastMutex (&InterfaceTableLock);
	if (ifInContext!=NULL) {
		PINTERFACE_CB	ifCB = (PINTERFACE_CB)ifInContext;
		IpxFltDbgPrint (DBG_IFHASH,
			("IpxFlt: Deleting filters for if %ld (ifCB:%08lx)"
			" on InterfaceDeleted indication from forwarder.\n",
			ifCB->ICB_Index, ifCB));
		RemoveEntryList (&ifCB->ICB_Link);
		ExFreePool (ifCB);
	}

	if (ifOutContext!=NULL) {
		PINTERFACE_CB	ifCB = (PINTERFACE_CB)ifOutContext;
		IpxFltDbgPrint (DBG_IFHASH,
			("IpxFlt: Deleting filters for if %ld (ifCB:%08lx)"
			" on InterfaceDeleted indication from forwarder.\n",
			ifCB->ICB_Index, ifCB));
		RemoveEntryList (&ifCB->ICB_Link);
		ExFreePool (ifCB);
	}
	ExReleaseFastMutex (&InterfaceTableLock);
	FlushPacketCache ();
	return ;
}

/*++
	F l u s h P a c k e t C a c h e

Routine Description:
	
	Deletes all cached packet descriptions
Arguments:
	None
Return Value:
	None

--*/
VOID
FlushPacketCache (
	VOID
	) {
	UINT	i;
	IpxFltDbgPrint (DBG_PKTCACHE, ("IpxFlt: Flushing packet chache.\n"));
	for (i=0; i<FLT_PACKET_CACHE_SIZE; i++) {
		ReplacePacket (i, NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\filter.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\filter.h

Abstract:
    IPX Filter driver filtering and maintanance routines


Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef _IPXFLT_FILTER_
#define _IPXFLT_FILTER_

	// IPX header constants
#define IPXH_HDRSIZE	    30	    // Size of the IPX header
#define IPXH_CHECKSUM	    0	    // Checksum
#define IPXH_LENGTH			2	    // Length
#define IPXH_XPORTCTL	    4	    // Transport Control
#define IPXH_PKTTYPE	    5	    // Packet Type
#define IPXH_DESTADDR	    6	    // Dest. Address (Total)
#define IPXH_DESTNET	    6	    // Dest. Network Address
#define IPXH_DESTNODE	    10	    // Dest. Node Address
#define IPXH_DESTSOCK	    16	    // Dest. Socket Number
#define IPXH_SRCADDR	    18	    // Source Address (Total)
#define IPXH_SRCNET			18	    // Source Network Address
#define IPXH_SRCNODE	    22	    // Source Node Address
#define IPXH_SRCSOCK	    28	    // Source Socket Number

//*** Packet Types we care about
#define IPX_NETBIOS_TYPE    20	   // Netbios propagated packet

// Conversions from/to on-the-wire format
#define GETUSHORT(src) (            \
    (USHORT)(                       \
        (((UCHAR *)src)[0]<<8)      \
        + (((UCHAR *)src)[1])       \
    )                               \
)

#define GETULONG(src) (             \
    (ULONG)(                        \
        (((UCHAR *)src)[0]<<24)     \
        + (((UCHAR *)src)[1]<<16)   \
        + (((UCHAR *)src)[2]<<8)    \
        + (((UCHAR *)src)[3])       \
    )                               \
)

#define PUTUSHORT(src,dst) {                \
    ((UCHAR *)dst)[0] = ((UCHAR)(src>>8));  \
    ((UCHAR *)dst)[1] = ((UCHAR)src);       \
}

#define PUTULONG(src,dst) {                 \
    ((UCHAR *)dst)[0] = ((UCHAR)(src>>24)); \
    ((UCHAR *)dst)[1] = ((UCHAR)(src>>16)); \
    ((UCHAR *)dst)[2] = ((UCHAR)(src>>8));  \
    ((UCHAR *)dst)[3] = ((UCHAR)src);       \
}

	// Other important constatns
#define FLT_INTERFACE_HASH_SIZE	257
#define FLT_PACKET_CACHE_SIZE	257
#define IPX_FLT_TAG				'lFwN'


	// Filter description
typedef struct _FILTER_DESCR {
	union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_Network;
		ULONGLONG		FD_NetworkSrcDst;
	};
	union {
		struct {
			UCHAR			Src[4];
			UCHAR			Dst[4];
		}				FD_NetworkMask;
		ULONGLONG		FD_NetworkMaskSrcDst;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_SrcNS;
		ULONGLONG		FD_SrcNodeSocket;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_SrcNSMask;
		ULONGLONG		FD_SrcNodeSocketMask;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_DstNS;
		ULONGLONG		FD_DstNodeSocket;
	};
	union {
		struct {
			UCHAR			Node[6];
			UCHAR			Socket[2];
		}				FD_DstNSMask;
		ULONGLONG		FD_DstNodeSocketMask;
	};
	UCHAR				FD_PacketType;
	UCHAR				FD_PacketTypeMask;
	BOOLEAN				FD_LogMatches;
} FILTER_DESCR, *PFILTER_DESCR;

	// Interface filters block
typedef struct _INTERFACE_CB {
	LIST_ENTRY		ICB_Link;
	ULONG			ICB_Index;
	ULONG			ICB_FilterAction;
	ULONG			ICB_FilterCount;
	FILTER_DESCR	ICB_Filters[1];
} INTERFACE_CB, *PINTERFACE_CB;

	// Interface hash tables
extern LIST_ENTRY		InterfaceInHash[FLT_INTERFACE_HASH_SIZE];
extern LIST_ENTRY		InterfaceOutHash[FLT_INTERFACE_HASH_SIZE];
extern LIST_ENTRY		LogIrpQueue;

/*++
	I n i t i a l i z e T a b l e s

Routine Description:

	Initializes hash and cash tables and protection stuff
Arguments:
	None
Return Value:
	STATUS_SUCCESS

--*/
NTSTATUS
InitializeTables (
	VOID
	);

/*++
	D e l e t e T a b l e s

Routine Description:

	Deletes hash and cash tables
Arguments:
	None
Return Value:
	None

--*/
VOID
DeleteTables (
	VOID
	);

/*++
	S e t F i l t e r s

Routine Description:
	
	Sets/replaces filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	FilterInfoSize - size of the info array
	FilterInfo	- array of filter descriptions (UI format)
Return Value:
	STATUS_SUCCESS - filter info was set/replaced ok
	STATUS_UNSUCCESSFUL - could not set filter context in forwarder
	STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
						filter info block for interface

--*/
NTSTATUS
SetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						InterfaceIndex,
	IN ULONG						FilterAction,
	IN ULONG						FilterInfoSize,
	IN PIPX_TRAFFIC_FILTER_INFO		FilterInfo
	);
#define SetInFilters(Index,Action,InfoSize,Info) \
			SetFilters(InterfaceInHash,Index,Action,InfoSize,Info)
#define SetOutFilters(Index,Action,InfoSize,Info) \
			SetFilters(InterfaceOutHash,Index,Action,InfoSize,Info)


/*++
	G e t F i l t e r s

Routine Description:
	
	Gets filter information for an interface
Arguments:
	HashTable	- input or output hash table
	Index		- interface index
	FilterAction - default action if there is no filter match
	TotalSize	- total memory required to hold all filter descriptions
	FilterInfo	- array of filter descriptions (UI format)
	FilterInfoSize - on input: size of the info array
					on output: size of the info placed in the array
Return Value:
	STATUS_SUCCESS - filter info was returned ok
	STATUS_BUFFER_OVERFLOW - array is not big enough to hold all
					filter info, only placed the info that fit

--*/
NTSTATUS
GetFilters (
	IN PLIST_ENTRY					HashTable,
	IN ULONG						InterfaceIndex,
	OUT ULONG						*FilterAction,
	OUT ULONG						*TotalSize,
	OUT PIPX_TRAFFIC_FILTER_INFO	FilterInfo,
	IN OUT ULONG					*FilterInfoSize
	);
#define GetInFilters(Index,Action,TotalSize,Info,InfoSize) \
			GetFilters(InterfaceInHash,Index,Action,TotalSize,Info,InfoSize)
#define GetOutFilters(Index,Action,TotalSize,Info,InfoSize) \
			GetFilters(InterfaceOutHash,Index,Action,TotalSize,Info,InfoSize)

/*++
	F i l t e r

Routine Description:
	
	Filters the packet supplied by the forwarder

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT	- packet should be passed on by the forwarder
	FILTER_DEDY		- packet should be dropped
--*/
FILTER_ACTION
Filter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	);

/*++
	I n t e r f a c e D e l e t e d

Routine Description:
	
	Frees interface filters blocks when forwarder indicates that
	interface is deleted
Arguments:
	ifInContext		- context associated with input filters block	
	ifOutContext	- context associated with output filters block
Return Value:
	None

--*/
VOID
InterfaceDeleted (
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\netbt\sys\nt\winsif.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    Winsif.c

Abstract:

    This module implements all the code surrounding the WINS interface to
    netbt that allows WINS to share the same 137 socket as netbt.

Author:

    Jim Stewart (Jimst)    1-30-94

Revision History:

--*/


#include "precomp.h"

VOID
NbtCancelWinsIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );
VOID
NbtCancelWinsSendIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    );
VOID
WinsDgramCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  ULONG                   Length
    );

NTSTATUS
CheckIfLocalNameActive(
    IN  tREM_ADDRESS    *pSendAddr
    );

PVOID
WinsAllocMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    );

VOID
WinsFreeMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  PVOID           pBuffer,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    );

VOID
InitiateRefresh (
    );

BOOLEAN RefreshedYet;

//
// take this define from Winsock.h since including winsock.h causes
// redefinition problems with various types.
//
#define AF_UNIX 1
#define AF_INET 2

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGENBT, NTCloseWinsAddr)
#pragma CTEMakePageable(PAGENBT, InitiateRefresh)
#pragma CTEMakePageable(PAGENBT, PassNamePduToWins)
#pragma CTEMakePageable(PAGENBT, NbtCancelWinsIrp)
#pragma CTEMakePageable(PAGENBT, NbtCancelWinsSendIrp)
#pragma CTEMakePageable(PAGENBT, CheckIfLocalNameActive)
#pragma CTEMakePageable(PAGENBT, WinsDgramCompletion)
#pragma CTEMakePageable(PAGENBT, WinsFreeMem)
#pragma CTEMakePageable(PAGENBT, WinsAllocMem)
#endif
//*******************  Pageable Routine Declarations ****************

tWINS_INFO      *pWinsInfo;
LIST_ENTRY      FreeWinsList;
HANDLE           NbtDiscardableCodeHandle={0};
tDEVICECONTEXT  *pWinsDeviceContext = NULL;
ULONG           LastWinsSignature = 0x8000;

#define COUNT_MAX   10

//----------------------------------------------------------------------------
NTSTATUS
NTOpenWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  tIPADDRESS      IpAddress
    )
/*++
Routine Description:

    This Routine handles opening the Wins Object that is used by
    by WINS to send and receive name service datagrams on port 137.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    tWINS_INFO                  *pWins;
    CTELockHandle               OldIrq;

    //
    // Page in the Wins Code, if it hasn't already been paged in.
    //
    if ((!NbtDiscardableCodeHandle) &&
        (!(NbtDiscardableCodeHandle = MmLockPagableCodeSection (NTCloseWinsAddr))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // if the WINs endpoint structure is not allocated, then allocate it
    // and initialize it.
    //
    if (pWinsInfo)
    {
        status = STATUS_UNSUCCESSFUL;
    }
    else if (!(pWins = NbtAllocMem(sizeof(tWINS_INFO),NBT_TAG('v'))))
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        CTEZeroMemory(pWins,sizeof(tWINS_INFO));
        pWins->Verify = NBT_VERIFY_WINS_ACTIVE;
        InitializeListHead(&pWins->Linkage);
        InitializeListHead(&pWins->RcvList);
        InitializeListHead(&pWins->SendList);

        pWins->RcvMemoryMax  = NbtConfig.MaxDgramBuffering;
        pWins->SendMemoryMax = NbtConfig.MaxDgramBuffering;
        pWins->IpAddress     = IpAddress;

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        pWins->pDeviceContext= GetDeviceWithIPAddress(IpAddress);
        pWins->WinsSignature = LastWinsSignature++;
        pWinsInfo = pWins;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pIrpSp->FileObject->FsContext   = (PVOID) pWinsInfo;
        pIrpSp->FileObject->FsContext2  = (PVOID) NBT_WINS_TYPE;

        RefreshedYet = FALSE;
        status = STATUS_SUCCESS;
    }

    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt:Open Wins Address Rcvd, status= %X\n",status));

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NTCleanUpWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine handles closing the Wins Object that is used by
    by WINS to send and receive name service datagrams on port 137.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    CTELockHandle               OldIrq;
    PLIST_ENTRY                 pHead, pEntry;
    tWINSRCV_BUFFER             *pRcv;
    tWINS_INFO                  *pWins = NULL;
    PIRP                        pSendIrp, pRcvIrp;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = pIrpSp->FileObject->FsContext;

    if (pWinsInfo && (pWins == pWinsInfo))
    {
        ASSERT (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE));
        pWins->Verify = NBT_VERIFY_WINS_DOWN;

        //
        // prevent any more dgram getting queued up
        //
        pWinsInfo = NULL;

        //
        // free any rcv buffers that may be queued up
        //
        pHead = &pWins->RcvList;
        while (!IsListEmpty(pHead))
        {
            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt.NTCleanUpWinsAddr: Freeing Rcv buffered for Wins\n"));

            pEntry = RemoveHeadList(pHead);
            pRcv = CONTAINING_RECORD(pEntry,tWINSRCV_BUFFER,Linkage);

            WinsFreeMem (pWins, pRcv, pRcv->DgramLength,TRUE);
        }

        //
        // return any Send buffers that may be queued up
        //
        pHead = &pWins->SendList;
        while (!IsListEmpty(pHead))
        {

            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt.NTCleanUpWinsAddr: Freeing Send Wins Address!\n"));

            pEntry = RemoveHeadList(pHead);
            pSendIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

            CTESpinFree (&NbtConfig. JointLock, OldIrq);
            NbtCancelCancelRoutine (pSendIrp);
            CTEIoComplete (pSendIrp, STATUS_CANCELLED, 0);
            CTESpinLock (&NbtConfig.JointLock, OldIrq);
        }

        pWins->pDeviceContext = NULL;
        InsertTailList (&FreeWinsList, &pWins->Linkage);

        //
        // Complete any Rcv Irps that may be hanging on this request
        //
        if (pRcvIrp = pWins->RcvIrp)
        {
            pWins->RcvIrp = NULL;
            pRcvIrp->IoStatus.Status = STATUS_CANCELLED;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            NbtCancelCancelRoutine (pRcvIrp);
            CTEIoComplete (pRcvIrp, STATUS_CANCELLED, 0);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT (0);
        status = STATUS_INVALID_HANDLE;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NTCleanUpWinsAddr:  pWins=<%p>, status=<%x>\n", pWins, status));

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NTCloseWinsAddr(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp
    )
/*++
Routine Description:

    This Routine handles closing the Wins Object that is used by
    by WINS to send and receive name service datagrams on port 137.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION          pIrpSp;
    NTSTATUS                    status;
    CTELockHandle               OldIrq;
    tWINS_INFO                  *pWins = NULL;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // if the WINs endpoint structure is allocated, then deallocate it
    //
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = pIrpSp->FileObject->FsContext;

    if (NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_DOWN))
    {
        pWins->Verify += 10;
        RemoveEntryList (&pWins->Linkage);
        CTEMemFree (pWins);

        pIrpSp->FileObject->FsContext2 = (PVOID)NBT_CONTROL_TYPE;
        status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT (0);
        status = STATUS_INVALID_HANDLE;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NTCloseWinsAddr:  pWins=<%p>, status=<%x>\n", pWins, status));

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
WinsSetInformation(
    IN  tWINS_INFO      *pWins,
    IN  tWINS_SET_INFO  *pWinsSetInfo
    )
{
    CTELockHandle               OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if ((pWins == pWinsInfo) &&
        (pWinsSetInfo->IpAddress))
    {
        pWins->IpAddress        = pWinsSetInfo->IpAddress;
        pWins->pDeviceContext   = GetDeviceWithIPAddress (pWinsSetInfo->IpAddress);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
InitiateRefresh (
    )
/*++

Routine Description:

    This routine tries to refresh all names with WINS on THIS node.

Arguments:

    pIrp            - Wins Rcv Irp

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    CTELockHandle               OldIrq;
    PLIST_ENTRY                 pHead;
    PLIST_ENTRY                 pEntry;
    ULONG                       Count;
    ULONG                       NumberNames;


    //
    // be sure all net cards have this card as the primary wins
    // server since Wins has to answer name queries for this
    // node.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (!(NodeType & BNODE))
    {
        LONG    i;

        Count = 0;
        NumberNames = 0;

        for (i=0 ;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
        {
            pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
            pEntry = pHead;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                NumberNames++;
            }
        }

        while (Count < COUNT_MAX)
        {
            if (!(NbtConfig.GlobalRefreshState & NBT_G_REFRESHING_NOW))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                ReRegisterLocalNames(NULL, FALSE);

                break;
            }
            else
            {
                LARGE_INTEGER   Timout;
                NTSTATUS        Locstatus;

                IF_DBG(NBT_DEBUG_WINS)
                    KdPrint(("Nbt:Waiting for Refresh to finish, so names can be reregistered\n"));

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                //
                // set a timeout that should be long enough to wait
                // for all names to fail registration with a down
                // wins server.
                //
                // 2 sec*3 retries * 8 names / 5 = 9 seconds a shot.
                // for a total of 90 seconds max.
                //
                Timout.QuadPart = Int32x32To64(
                             MILLISEC_TO_100NS/(COUNT_MAX/2),
                             (NbtConfig.uRetryTimeout*NbtConfig.uNumRetries)
                             *NumberNames);

                Timout.QuadPart = -(Timout.QuadPart);

                //
                // wait for a few seconds and try again.
                //
                Locstatus = KeDelayExecutionThread(
                                            KernelMode,
                                            FALSE,      // Alertable
                                            &Timout);      // Timeout



                Count++;
                if (Count < COUNT_MAX)
                {
                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                }
            }
        }

    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
RcvIrpFromWins(
    IN  PCTE_IRP        pIrp
    )
/*++

Routine Description:

    This function takes the rcv irp posted by WINS and decides if there are
    any datagram queued waiting to go up to WINS.  If so then the datagram
    is copied to the WINS buffer and passed back up.  Otherwise the irp is
    held by Netbt until a datagram does come in.

Arguments:

    pIrp            - Wins Rcv Irp

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                status;
    NTSTATUS                Locstatus;
    tREM_ADDRESS            *pWinsBuffer;
    tWINSRCV_BUFFER         *pBuffer;
    PLIST_ENTRY             pEntry;
    CTELockHandle           OldIrq;
    tWINS_INFO              *pWins;
    PIO_STACK_LOCATION      pIrpSp;
    PMDL                    pMdl;
    ULONG                   CopyLength;
    ULONG                   DgramLength;
    ULONG                   BufferLength;

    status = STATUS_INVALID_HANDLE;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = pIrpSp->FileObject->FsContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!RefreshedYet)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        InitiateRefresh();
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        RefreshedYet = TRUE;
    }

    if ((!pWins) || (pWins != pWinsInfo))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NTIoComplete(pIrp,status,0);
        return(status);
    }

    if (!IsListEmpty(&pWins->RcvList))
    {
        //
        // There is at least one datagram waiting to be received
        //
        pEntry = RemoveHeadList(&pWins->RcvList);
        pBuffer = CONTAINING_RECORD(pEntry,tWINSRCV_BUFFER,Linkage);

        //
        // Copy the datagram and the source address to WINS buffer and return to WINS
        //
        if ((pMdl = pIrp->MdlAddress) &&
            (pWinsBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
        {
            BufferLength = MmGetMdlByteCount(pMdl);
            DgramLength = pBuffer->DgramLength;
            CopyLength = (DgramLength <= BufferLength) ? DgramLength : BufferLength;

            CTEMemCopy ((PVOID)pWinsBuffer, (PVOID)&pBuffer->Address.Family, CopyLength);

            ASSERT(pWinsBuffer->Port);
            ASSERT(pWinsBuffer->IpAddress);

            if (CopyLength < DgramLength)
            {
                Locstatus = STATUS_BUFFER_OVERFLOW;
            }
            else
            {
                Locstatus = STATUS_SUCCESS;
            }
        }
        else
        {
            CopyLength = 0;
            Locstatus = STATUS_UNSUCCESSFUL;
        }

        //
        // subtract from the total amount buffered for WINS since we are
        // passing a datagram up to WINS now.
        //
        pWins->RcvMemoryAllocated -= pBuffer->DgramLength;
        CTEMemFree(pBuffer);

        //
        // pass the irp up to WINS
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_WINS)
            KdPrint(("Nbt:Returning Wins rcv Irp immediately with queued dgram, status=%X,pIrp=%X\n"
                        ,status,pIrp));

        pIrp->IoStatus.Information = CopyLength;
        pIrp->IoStatus.Status = Locstatus;

        IoCompleteRequest(pIrp,IO_NO_INCREMENT);

        return(STATUS_SUCCESS);
    }

    if (pWins->RcvIrp)
    {
        status = STATUS_NOT_SUPPORTED;
    }
    else
    {
        status = NTCheckSetCancelRoutine(pIrp, NbtCancelWinsIrp, NULL);
        if (NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt:Holding onto Wins Rcv Irp, pIrp =%Xstatus=%X\n", status,pIrp));

            pWins->RcvIrp = pIrp;
            status = STATUS_PENDING;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (!NT_SUCCESS(status))
    {
        NTIoComplete(pIrp,status,0);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
PassNamePduToWins (
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    pSrcAddress,
    IN tNAMEHDR UNALIGNED       *pNameSrv,
    IN ULONG                    uNumBytes
    )
/*++

Routine Description:

    This function is used to allow NBT to pass name query service Pdu's to
    WINS.  Wins posts a Rcv irp to Netbt.  If the Irp is here then simply
    copy the data to the irp and return it, otherwise buffer the data up
    to a maximum # of bytes. Beyond that limit the datagrams are discarded.

    If Retstatus is not success then the pdu will also be processed by
    nbt. This allows nbt to process packets when wins pauses and
    its list of queued buffers is exceeded.

Arguments:

    pDeviceContext  - card that the request can in on
    pSrcAddress     - source address
    pNameSrv        - ptr to the datagram
    uNumBytes       - length of datagram

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                Retstatus;
    NTSTATUS                status;
    tREM_ADDRESS            *pWinsBuffer;
    PCTE_IRP                pIrp;
    CTELockHandle           OldIrq;
    PTRANSPORT_ADDRESS      pSourceAddress;
    ULONG                   SrcAddress;
    SHORT                   SrcPort;


    //
    // Get the source port and ip address, since WINS needs this information.
    //
    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr;
    SrcPort     = ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    Retstatus = STATUS_SUCCESS;
    if (pWinsInfo)
    {
        if (!pWinsInfo->RcvIrp)
        {
            //
            // Queue the name query pdu if we have not exeeded our current queue
            // length
            //
            if (pWinsInfo->RcvMemoryAllocated < pWinsInfo->RcvMemoryMax)
            {
                tWINSRCV_BUFFER    *pBuffer;

                pBuffer = NbtAllocMem(uNumBytes + sizeof(tWINSRCV_BUFFER)+8,NBT_TAG('v'));
                if (pBuffer)
                {
                    //
                    // check if it is a name reg from this node
                    //
                    if (pNameSrv->AnCount == WINS_SIGNATURE)
                    {
                        pNameSrv->AnCount = 0;
                        pBuffer->Address.Family = AF_UNIX;
                    }
                    else
                    {
                        pBuffer->Address.Family = AF_INET;
                    }

                    CTEMemCopy((PUCHAR)((PUCHAR)pBuffer + sizeof(tWINSRCV_BUFFER)),
                                (PVOID)pNameSrv,uNumBytes);

                    pBuffer->Address.Port = SrcPort;
                    pBuffer->Address.IpAddress = SrcAddress;
                    pBuffer->Address.LengthOfBuffer = uNumBytes;

                    ASSERT(pBuffer->Address.Port);
                    ASSERT(pBuffer->Address.IpAddress);

                    // total amount allocated
                    pBuffer->DgramLength = uNumBytes + sizeof(tREM_ADDRESS);


                    //
                    // Keep track of the total amount buffered so that we don't
                    // eat up all non-paged pool buffering for WINS
                    //
                    pWinsInfo->RcvMemoryAllocated += pBuffer->DgramLength;

                    IF_DBG(NBT_DEBUG_WINS)
                        KdPrint(("Nbt:Buffering Wins Rcv - no Irp, status=%X\n"));
                    InsertTailList(&pWinsInfo->RcvList,&pBuffer->Linkage);

                }
            }
            else
            {
                // this ret status will allow netbt to process the packet.
                //
                Retstatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
        else
        {
            PMDL    pMdl;
            ULONG   CopyLength;
            ULONG   BufferLength;

            //
            // The recv irp is here so copy the data to its buffer and
            // pass it up to WINS
            //
            pIrp = pWinsInfo->RcvIrp;
            pWinsInfo->RcvIrp = NULL;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            //
            // Copy the datagram and the source address to WINS buffer and return to WINS
            //
            if ((!(pMdl = pIrp->MdlAddress)) ||
                ((BufferLength = MmGetMdlByteCount(pMdl)) <  sizeof(tREM_ADDRESS)) ||
                (!(pWinsBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                CopyLength = 0;
            }
            else
            {
                if (BufferLength >= (uNumBytes + sizeof(tREM_ADDRESS)))
                {
                    CopyLength = uNumBytes;
                }
                else
                {
                    CopyLength = BufferLength - sizeof(tREM_ADDRESS);
                }

                //
                // check if it is a name reg from this node
                //
                if (pNameSrv->AnCount == WINS_SIGNATURE)
                {
                    pNameSrv->AnCount = 0;
                    pWinsBuffer->Family = AF_UNIX;
                }
                else
                {
                    pWinsBuffer->Family     = AF_INET;
                }
                CTEMemCopy((PVOID)((PUCHAR)pWinsBuffer + sizeof(tREM_ADDRESS)), (PVOID)pNameSrv, CopyLength);

                pWinsBuffer->Port       = SrcPort;
                pWinsBuffer->IpAddress  = SrcAddress;
                pWinsBuffer->LengthOfBuffer = uNumBytes;

                ASSERT(pWinsBuffer->Port);
                ASSERT(pWinsBuffer->IpAddress);

                //
                // pass the irp up to WINS
                //
                if (CopyLength < uNumBytes)
                {
                    status = STATUS_BUFFER_OVERFLOW;
                }
                else
                {
                    status = STATUS_SUCCESS;
                }

                IF_DBG(NBT_DEBUG_WINS)
                    KdPrint(("Nbt:Returning Wins Rcv Irp - data from net, Length=%X,pIrp=%X\n"
                        ,uNumBytes,pIrp));
            }

            NTIoComplete(pIrp,status,CopyLength);
        }
    }
    else
    {
        //
        // this ret status will allow netbt to process the packet.
        //
        Retstatus = STATUS_INSUFFICIENT_RESOURCES;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(Retstatus);

}

//----------------------------------------------------------------------------
VOID
NbtCancelWinsIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a WinsRcv Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL                OldIrq;
    PIO_STACK_LOCATION   pIrpSp;
    tWINS_INFO           *pWins;


    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NbtCancelWinsIrp: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pWins = (tWINS_INFO *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // Be sure that PassNamePduToWins has not taken the RcvIrp for a
    // Rcv just now.
    //
    if ((NBT_VERIFY_HANDLE (pWins, NBT_VERIFY_WINS_ACTIVE)) &&
        (pWins->RcvIrp == pIrp))
    {
        pWins->RcvIrp = NULL;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

    }


}
//----------------------------------------------------------------------------
VOID
NbtCancelWinsSendIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling a WinsRcv Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    The final status from the operation.

--*/
{
    KIRQL                OldIrq;
    PLIST_ENTRY          pHead;
    PLIST_ENTRY          pEntry;
    PIO_STACK_LOCATION   pIrpSp;
    tWINS_INFO           *pWins;
    BOOLEAN              Found;
    PIRP                 pIrpList;


    IF_DBG(NBT_DEBUG_WINS)
        KdPrint(("Nbt.NbtCancelWinsSendIrp: Got a Cancel !!! *****************\n"));

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = (tWINS_INFO *)pIrpSp->FileObject->FsContext;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pWins == pWinsInfo)
    {
        //
        // find the matching irp on the list and remove it
        //
        pHead = &pWinsInfo->SendList;
        pEntry = pHead;
        Found = FALSE;

        while ((pEntry = pEntry->Flink) != pHead)
        {
            pIrpList = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);
            if (pIrp == pIrpList)
            {
                RemoveEntryList(pEntry);
                Found = TRUE;
            }
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        if (Found)
        {
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
        }
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}
//----------------------------------------------------------------------------
NTSTATUS
WinsSendDatagram(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PIRP            pIrp,
    IN  BOOLEAN         MustSend)

/*++
Routine Description:

    This Routine handles sending a datagram down to the transport. MustSend
    it set true by the Send Completion routine when it attempts to send
    one of the queued datagrams, in case we still don't pass the memory
    allocated check and refuse to do the send - sends will just stop then without
    this boolean.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    PIO_STACK_LOCATION              pIrpSp;
    NTSTATUS                        status;
    tWINS_INFO                      *pWins;
    tREM_ADDRESS                    *pSendAddr;
    PVOID                           pDgram;
    ULONG                           DgramLength;
    tDGRAM_SEND_TRACKING            *pTracker;
    CTELockHandle                   OldIrq;
    BOOLEAN                         fIsWinsDevice = FALSE;
    ULONG                           DataSize;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pWins = (tWINS_INFO *)pIrpSp->FileObject->FsContext;

    status = STATUS_UNSUCCESSFUL;

    if (!(pSendAddr = (tREM_ADDRESS *) MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
    {
        pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Bug# 234600:  Check if the DataSize is correct
    //
    DataSize = MmGetMdlByteCount (pIrp->MdlAddress);
    if ((DataSize < sizeof(tREM_ADDRESS)) ||
        ((DataSize - sizeof(tREM_ADDRESS)) < pSendAddr->LengthOfBuffer))
    {
        pIrp->IoStatus.Status = STATUS_INVALID_BLOCK_LENGTH;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        return STATUS_INVALID_BLOCK_LENGTH;
    }

    //
    // check if it is a name that is registered on this machine
    //
    if (pSendAddr->Family == AF_UNIX)
    {
        status = CheckIfLocalNameActive(pSendAddr);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pWins) &&
        (pWins == pWinsInfo))
    {
        if (pDeviceContext == pWinsDeviceContext)
        {
            fIsWinsDevice = TRUE;
            if (!(pDeviceContext = pWinsInfo->pDeviceContext) ||
                !(NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, TRUE)))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

//                status = STATUS_INVALID_HANDLE;
                status = STATUS_SUCCESS;
                pIrp->IoStatus.Status = status;
                IoCompleteRequest(pIrp,IO_NO_INCREMENT);
                return (status);
            }
        }

        if ((pWins->SendMemoryAllocated < pWins->SendMemoryMax) || MustSend)
        {
            if (pSendAddr->IpAddress != 0)
            {
                DgramLength = pSendAddr->LengthOfBuffer;
                pDgram = WinsAllocMem (pWins, DgramLength, FALSE);

                if (pDgram)
                {
                    CTEMemCopy(pDgram, (PVOID)((PUCHAR)pSendAddr+sizeof(tREM_ADDRESS)), DgramLength);

                    //
                    // get a buffer for tracking Dgram Sends
                    //
                    status = GetTracker(&pTracker, NBT_TRACKER_SEND_WINS_DGRAM);
                    if (NT_SUCCESS(status))
                    {
                        pTracker->SendBuffer.pBuffer   = NULL;
                        pTracker->SendBuffer.Length    = 0;
                        pTracker->SendBuffer.pDgramHdr = pDgram;
                        pTracker->SendBuffer.HdrLength = DgramLength;
                        pTracker->pClientIrp           = NULL;
                        pTracker->pDeviceContext       = pDeviceContext;
                        pTracker->pNameAddr            = NULL;
                        pTracker->pDestName            = NULL;
                        pTracker->UnicodeDestName      = NULL;
                        pTracker->pClientEle           = NULL;
                        pTracker->AllocatedLength      = DgramLength;
                        pTracker->ClientContext        = IntToPtr(pWins->WinsSignature);

                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        // send the Datagram...
                        status = UdpSendDatagram (pTracker,
                                                  ntohl(pSendAddr->IpAddress),
                                                  WinsDgramCompletion,
                                                  pTracker,               // context for completion
                                                  (USHORT)ntohs(pSendAddr->Port),
                                                  NBT_NAME_SERVICE);

                        IF_DBG(NBT_DEBUG_WINS)
                            KdPrint(("Nbt:Doing Wins Send, status=%X\n",status));

                        // sending the datagram could return status pending,
                        // but since we have buffered the dgram, return status
                        // success to the client
                        //
                        status = STATUS_SUCCESS;
                        //
                        // Fill in the sent size
                        //
                        pIrp->IoStatus.Information = DgramLength;
                    }
                    else
                    {
                        WinsFreeMem (pWins, (PVOID)pDgram,DgramLength,FALSE);

                        CTESpinFree(&NbtConfig.JointLock,OldIrq);
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                status = STATUS_INVALID_PARAMETER;
            }

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        }
        else
        {
            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt:Holding onto Buffering Wins Send, status=%X\n"));

            //
            // Hold onto the datagram till memory frees up
            //
            InsertTailList(&pWins->SendList,&pIrp->Tail.Overlay.ListEntry);

            status = NTCheckSetCancelRoutine(pIrp,NbtCancelWinsSendIrp,NULL);
            if (!NT_SUCCESS(status))
            {
                RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                NTIoComplete(pIrp,status,0);
            }
            else
            {
                status = STATUS_PENDING;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }
        }

        if (fIsWinsDevice)
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, FALSE);
        }
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = STATUS_INVALID_HANDLE;

        pIrp->IoStatus.Status = status;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    }

    return(status);

}


//----------------------------------------------------------------------------
NTSTATUS
CheckIfLocalNameActive(
    IN  tREM_ADDRESS    *pSendAddr
    )

/*++
Routine Description

    This routine checks if this is a name query response and if the
    name is still active on the local node.

Arguments:

    pMdl = ptr to WINS Mdl

Return Values:

    VOID

--*/

{
    NTSTATUS            status;
    tNAMEHDR UNALIGNED  *pNameHdr;
    tNAMEADDR           *pResp;
    UCHAR               pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    ULONG               lNameSize;
    CTELockHandle       OldIrq;

    pNameHdr = (tNAMEHDR UNALIGNED *)((PUCHAR)pSendAddr + sizeof(tREM_ADDRESS));
    //
    // Be sure it is a name query PDU that we are checking
    //
    if (((pNameHdr->OpCodeFlags & NM_FLAGS_MASK) == OP_QUERY) ||
         ((pNameHdr->OpCodeFlags & NM_FLAGS_MASK) == OP_RELEASE))
    {
        status = ConvertToAscii ((PCHAR)&pNameHdr->NameRR.NameLength,
                                 pSendAddr->LengthOfBuffer,
                                 pName,
                                 &pScope,
                                 &lNameSize);

        if (NT_SUCCESS(status))
        {
            //
            // see if the name is still active in the local hash table
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            status = FindInHashTable(NbtConfig.pLocalHashTbl, pName, pScope, &pResp);

            if ((pNameHdr->OpCodeFlags & NM_FLAGS_MASK) == OP_QUERY)
            {
                if (NT_SUCCESS(status))
                {
                    //
                    // if not resolved then set to negative name query resp.
                    //
                    if (!(pResp->NameTypeState & STATE_RESOLVED))
                    {
                        pNameHdr->OpCodeFlags |= htons(NAME_ERROR);
                    }
                }
                //
                // We can have a scenario where the local machine was a DC
                // at one time, so it set the UNIX to tell Wins when registering
                // the local name.A  However, once that machine is downgraded,
                // Wins will still have the UNIX flag set for that record if
                // there were other DC's also present.
                // Thus, we can have the following scenario where the machine
                // is currently not a DC, but the UNIX flag is set in the response
                // so we should not mark the name in Error.  This would not
                // be a problem if the client is configured with other Wins
                // server addresses, but otherwise it could cause problems!
                // Bug # 54659
                //
                else if (pName[NETBIOS_NAME_SIZE-1] != SPECIAL_GROUP_SUFFIX)
                {
                    pNameHdr->OpCodeFlags |= htons(NAME_ERROR);
                }
            }
            else
            {
                //
                // check if it is a release response - if so we must have
                // received a name release request, so mark the name in
                // conflict and return a positive release response.
                //
                // Note:  The case we are looking at here is if another Wins
                // sent a NameRelease demand for some name to the local machine.
                // Since we pass all name releases up to Wins, NetBT will
                // not get a chance to determine if it is a local name when
                // the release first came in.
                // Typically, Wins should make the call properly as to whether
                // NetBT should mark the local name in conflict or not, but
                // it has been observed that Wins displayed inconsistent behavior
                // setting the UNIX flag only if the local machine was the last
                // to register/refresh the name (Bug # 431042).
                // For now, we will remove this functionality for Group names.
                // 
                if (pNameHdr->OpCodeFlags & OP_RESPONSE)
                {
                    //
                    // Bug # 206192:  If we are sending the response to
                    // ourselves, don't put the name into conflict
                    // (could be due to NbtStat -RR!)
                    //
                    if (NT_SUCCESS(status) &&
                       (pResp->NameTypeState & STATE_RESOLVED) &&
                       (pResp->NameTypeState & NAMETYPE_UNIQUE) &&
                       !(pNameHdr->OpCodeFlags & FL_RCODE) &&       // Only for positive name release response
                       !(SrcIsUs(ntohl(pSendAddr->IpAddress))))
                    {
                        NbtLogEvent (EVENT_NBT_NAME_RELEASE, pSendAddr->IpAddress, 0x122);

                        pResp->NameTypeState &= ~NAME_STATE_MASK;
                        pResp->NameTypeState |= STATE_CONFLICT;
                        pResp->ConflictMask |= pResp->AdapterMask;
                    }
                }
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
    }

    //
    // the name is not in the local table so fail the datagram send attempt
    //
    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
WinsDgramCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  ULONG                   Length
    )

/*++
Routine Description

    This routine cleans up after a data gram send.

Arguments:

    pTracker
    status
    Length

Return Values:

    VOID

--*/

{
    CTELockHandle           OldIrq;
    LIST_ENTRY              *pEntry;
    PIRP                    pIrp;
    BOOLEAN                 MustSend;
#ifdef _PNP_POWER_
    tDEVICECONTEXT          *pDeviceContext;
#endif

    //
    // free the buffer used for sending the data and the tracker - note
    // that the datagram header and the send buffer are allocated as one
    // chunk.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pWinsInfo) &&
        (pTracker->ClientContext == IntToPtr(pWinsInfo->WinsSignature)))
    {
        WinsFreeMem(pWinsInfo,
                    (PVOID)pTracker->SendBuffer.pDgramHdr,
                    pTracker->AllocatedLength,
                    FALSE);

        if (!IsListEmpty(&pWinsInfo->SendList))
        {
#ifdef _PNP_POWER_
            //
            // If there are no devices available to send this request on,
            // complete all pending requests gracefully
            //
            if (!(pDeviceContext = pWinsInfo->pDeviceContext) ||
                !(NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, TRUE)))
            {
                status = STATUS_PLUGPLAY_NO_DEVICE;

                while (!IsListEmpty(&pWinsInfo->SendList))
                {
                    pEntry = RemoveHeadList(&pWinsInfo->SendList);
                    pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    NbtCancelCancelRoutine (pIrp);
                    pIrp->IoStatus.Status = status;
                    IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                FreeTracker (pTracker, RELINK_TRACKER);

                return;
            }
#endif  // _PNP_POWER_

            IF_DBG(NBT_DEBUG_WINS)
                KdPrint(("Nbt:Sending another Wins Dgram that is Queued to go\n"));

            pEntry = RemoveHeadList(&pWinsInfo->SendList);
            pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NbtCancelCancelRoutine (pIrp);

            //
            // Send this next datagram
            //
            status = WinsSendDatagram(pDeviceContext,
                                      pIrp,
                                      MustSend = TRUE);

            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_WINS, FALSE);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
    }
    else
    {
        //
        // just free the memory since WINS has closed its address handle.
        //
        CTEMemFree((PVOID)pTracker->SendBuffer.pDgramHdr);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    FreeTracker (pTracker, RELINK_TRACKER);
}

//----------------------------------------------------------------------------
PVOID
WinsAllocMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    )

/*++
Routine Description:

    This Routine handles allocating memory and keeping track of how
    much has been allocated.

Arguments:

    Size    - number of bytes to allocate
    Rcv     - boolean that indicates if it is rcv or send buffering

Return Value:

    ptr to the memory allocated

--*/

{
    if (Rcv)
    {
        if (pWinsContext->RcvMemoryAllocated > pWinsContext->RcvMemoryMax)
        {
            return NULL;
        }
        else
        {
            pWinsContext->RcvMemoryAllocated += Size;
            return (NbtAllocMem(Size,NBT_TAG('v')));
        }
    }
    else
    {
        if (pWinsContext->SendMemoryAllocated > pWinsContext->SendMemoryMax)
        {
            return(NULL);
        }
        else
        {
            pWinsContext->SendMemoryAllocated += Size;
            return(NbtAllocMem(Size,NBT_TAG('v')));
        }
    }
}
//----------------------------------------------------------------------------
VOID
WinsFreeMem(
    IN  tWINS_INFO      *pWinsContext,
    IN  PVOID           pBuffer,
    IN  ULONG           Size,
    IN  BOOLEAN         Rcv
    )

/*++
Routine Description:

    This Routine handles freeing memory and keeping track of how
    much has been allocated.

Arguments:

    pBuffer - buffer to free
    Size    - number of bytes to allocate
    Rcv     - boolean that indicates if it is rcv or send buffering

Return Value:

    none

--*/

{
    if (pWinsContext)
    {
        if (Rcv)
        {
            pWinsContext->RcvMemoryAllocated -= Size;
        }
        else
        {
            pWinsContext->SendMemoryAllocated -= Size;
        }
    }

    CTEMemFree(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\precomp.h

Abstract:
    IPX Forwarder driver precompiled header file


Author:

    Vadim Eydelman

Revision History:

--*/

#define ISN_NT 1
#define NT 1

#if DBG
#define DEBUG 1
#endif

// System includes
#include <ntosp.h>
#include <ndis.h>
#include <zwapi.h>

// Routing includes
#include <ipxfltdf.h>
#include <ipxfwd.h>
#include <ipxtfflt.h>

// IPX shared includes
#include "ipxfltif.h"

// Internal module prototypes
#include "filter.h"
#include "fwdbind.h"
#include "debug.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\fwdbind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\fwdbind.c

Abstract:
    IPX Filter driver binding with forwarder routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

	// Buffer to keep forwarder entry points
IPX_FLT_BIND_OUTPUT	FltBindOutput;
// global handle of the FWD driver
HANDLE					HdlFwdFile = NULL;


/*++
	B i n d T o F w d D r i v e r

Routine Description:

	Opens  forwarder driver and exchages entry points
Arguments:
	None
Return Value:
	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
BindToFwdDriver (
	KPROCESSOR_MODE requestorMode
	) {
    NTSTATUS					status;
    IO_STATUS_BLOCK				IoStatusBlock;
    OBJECT_ATTRIBUTES			ObjectAttributes;
	UNICODE_STRING				UstrFwdFileName;
	IPX_FLT_BIND_INPUT			FltBindInput = {Filter, InterfaceDeleted};

	ASSERT (HdlFwdFile == NULL);

	RtlInitUnicodeString (&UstrFwdFileName, IPXFWD_NAME);
	InitializeObjectAttributes(
				&ObjectAttributes,
				&UstrFwdFileName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL
				);

	if (requestorMode==UserMode)
		status = ZwCreateFile(&HdlFwdFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);
	else
		status = NtCreateFile(&HdlFwdFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);

	if (NT_SUCCESS(status)) {

		if (requestorMode==UserMode)
			status = ZwDeviceIoControlFile(
							HdlFwdFile,		    // HANDLE to File
							NULL,			    // HANDLE to Event
							NULL,			    // ApcRoutine
							NULL,			    // ApcContext
							&IoStatusBlock,	    // IO_STATUS_BLOCK
							IOCTL_FWD_INTERNAL_BIND_FILTER,	 // IoControlCode
							&FltBindInput,		// Input Buffer
							sizeof(FltBindInput), // Input Buffer Length
							&FltBindOutput,		// Output Buffer
							sizeof(FltBindOutput));// Output Buffer Length
		else
			status = NtDeviceIoControlFile(
							HdlFwdFile,		    // HANDLE to File
							NULL,			    // HANDLE to Event
							NULL,			    // ApcRoutine
							NULL,			    // ApcContext
							&IoStatusBlock,	    // IO_STATUS_BLOCK
							IOCTL_FWD_INTERNAL_BIND_FILTER,	 // IoControlCode
							&FltBindInput,		// Input Buffer
							sizeof(FltBindInput), // Input Buffer Length
							&FltBindOutput,		// Output Buffer
							sizeof(FltBindOutput));// Output Buffer Length
		if (NT_SUCCESS (status))
			return STATUS_SUCCESS;
		else
			IpxFltDbgPrint (DBG_ERRORS,
					("IpxFlt: Failed to bind to forwarder %08lx.\n", status));
		if (requestorMode==KernelMode)
			ZwClose (HdlFwdFile);
		else
			NtClose (HdlFwdFile);
	
	}
	else
		IpxFltDbgPrint (DBG_ERRORS,
				("IpxFlt: Failed create forwarder file %08lx.\n", status));
	HdlFwdFile = NULL;
	return status;
}



/*++
	U n i n d T o F w d D r i v e r

Routine Description:

	Closes forwarder driver
Arguments:
	None
Return Value:
	None

--*/
VOID
UnbindFromFwdDriver (
	KPROCESSOR_MODE requestorMode
	) {
	NTSTATUS	status;

	ASSERT (HdlFwdFile != NULL);

	if (requestorMode==UserMode)
		status = ZwClose (HdlFwdFile);
	else
		status = NtClose (HdlFwdFile);
	ASSERT (NT_SUCCESS (status));
	HdlFwdFile = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\driver.c

Abstract:
    IPX Filter driver dispatch routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

PFILE_OBJECT		RouterFile;

NTSTATUS
IpxFltDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IpxFltUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
IpxFltCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	);
	
/*++
	D r i v e r E n t r y

Routine Description:

	Installable driver initialization entry point.
	This entry point is called directly by the I/O system.

Arguments:

	DriverObject - pointer to the driver object

	RegistryPath - pointer to a unicode string representing the path
				   to driver-specific key in the registry

Return Value:

	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
	) {

	PDEVICE_OBJECT deviceObject = NULL;
	NTSTATUS       status;
	UNICODE_STRING deviceNameUnicodeString;

	IpxFltDbgPrint (DBG_IOCTLS, ("IpxFlt: Driver Entry.\n"));

	RtlInitUnicodeString (&deviceNameUnicodeString,
						  IPXFLT_NAME);

	status = IoCreateDevice (DriverObject,
							   0,
							   &deviceNameUnicodeString,
							   FILE_DEVICE_IPXFLT,
							   0,
							   FALSE,		// Non-Exclusive
							   &deviceObject
							   );

	if (NT_SUCCESS(status)) {
		//
		// Create dispatch points for device control, create, close.
		//
		DriverObject->MajorFunction[IRP_MJ_CREATE]
			= DriverObject->MajorFunction[IRP_MJ_CLEANUP]
			= DriverObject->MajorFunction[IRP_MJ_CLOSE]
			= DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]
			= IpxFltDispatch;
		DriverObject->DriverUnload = IpxFltUnload;
		status = BindToFwdDriver (KernelMode);
		if (NT_SUCCESS (status)) {
			RouterFile = NULL;
			return STATUS_SUCCESS;
		}
		else {
		    IoDeleteDevice (DriverObject->DeviceObject);
		}
	}
	else
		IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
						("IpxFlt: Could not create device object.\n"));

	return status;
}



/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
NTSTATUS
IpxFltDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    ) {
    PIO_STACK_LOCATION	IrpStack;
    PVOID				inBuffer, outBuffer;
    ULONG				inpBufLength;
    ULONG				outBufLength;
    NTSTATUS			status;
	KIRQL				cancelIRQL;
    ULONG               ulBytes;

    ulBytes = 0;
    Irp->IoStatus.Information = 0;
	status = STATUS_SUCCESS;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    switch (IrpStack->MajorFunction) {
	case IRP_MJ_CREATE:
		IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IRP_MJ_CREATE.\n"));
		break;

	case IRP_MJ_CLOSE:
		IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IRP_MJ_CLOSE.\n"));
		if (IrpStack->FileObject == RouterFile) {
			DeleteTables ();
			RouterFile = NULL;
		}
		break;

	case IRP_MJ_CLEANUP:
		IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IRP_MJ_CLEANUP.\n"));
		if (IrpStack->FileObject==RouterFile) {
			IoAcquireCancelSpinLock (&cancelIRQL);
			while (!IsListEmpty (&LogIrpQueue)) {
				PIRP irp = CONTAINING_RECORD (LogIrpQueue.Blink,
										IRP, Tail.Overlay.ListEntry);
				irp->Cancel = TRUE;
				irp->CancelIrql = cancelIRQL;
				irp->CancelRoutine = NULL;
				IpxFltCancel(DeviceObject, irp);
				IoAcquireCancelSpinLock (&cancelIRQL);
			}
			IoReleaseCancelSpinLock(cancelIRQL);
		}
		break;

	case IRP_MJ_DEVICE_CONTROL:
    //
    // Get the pointer to the input/output buffer and it's length
    //
		status = STATUS_INVALID_PARAMETER;
		inpBufLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
		outBufLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		switch (IrpStack->Parameters.DeviceIoControl.IoControlCode&3) {
		case METHOD_BUFFERED:
			inBuffer = outBuffer = Irp->AssociatedIrp.SystemBuffer;
			break;

		case METHOD_IN_DIRECT:
		case METHOD_OUT_DIRECT:
			inBuffer = Irp->AssociatedIrp.SystemBuffer;
			if (outBufLength>0) {
				outBuffer = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, NormalPagePriority);
				if (outBuffer == NULL)
				{
        			IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS, ("IpxFlt: System out of PTE's.\n"));
        			goto DispatchExit;
				}
			}
			else {
				outBuffer = NULL; 
			}
			break;
		default:
			IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS, ("IpxFlt: Unsupported io method.\n"));
			goto DispatchExit;
		}


		if (IrpStack->FileObject==RouterFile) {
			switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
			case IOCTL_FLT_IF_SET_IN_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_SET_IN_FILTERS.\n"));
				if ((inpBufLength==sizeof (FLT_IF_SET_PARAMS))
						&& (((PFLT_IF_SET_PARAMS)inBuffer)->FilterSize
								==sizeof (IPX_TRAFFIC_FILTER_INFO)))
					status = SetInFilters (
								((PFLT_IF_SET_PARAMS)inBuffer)->InterfaceIndex,
								((PFLT_IF_SET_PARAMS)inBuffer)->FilterAction,
								outBufLength,
								(PIPX_TRAFFIC_FILTER_INFO)outBuffer);
			
				break;

			case IOCTL_FLT_IF_SET_OUT_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_SET_OUT_FILTERS.\n"));
				if ((inpBufLength==sizeof (FLT_IF_SET_PARAMS))
						&& (((PFLT_IF_SET_PARAMS)inBuffer)->FilterSize
								==sizeof (IPX_TRAFFIC_FILTER_INFO)))
					status = SetOutFilters (
								((PFLT_IF_SET_PARAMS)inBuffer)->InterfaceIndex,
								((PFLT_IF_SET_PARAMS)inBuffer)->FilterAction,
								outBufLength,
								(PIPX_TRAFFIC_FILTER_INFO)outBuffer);
			
				break;
			case IOCTL_FLT_IF_RESET_IN_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_RESET_IN_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength==0))
					status = SetInFilters (
								*((PULONG)inBuffer),
								IPX_TRAFFIC_FILTER_ACTION_DENY,
								0, NULL);
			
				break;
			case IOCTL_FLT_IF_RESET_OUT_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_RESET_OUT_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength==0))
					status = SetOutFilters (
								*((PULONG)inBuffer),
								IPX_TRAFFIC_FILTER_ACTION_DENY,
								0, NULL);
			
				break;
			case IOCTL_FLT_IF_GET_IN_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_GET_IN_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength>=sizeof (FLT_IF_GET_PARAMS))) {
					Irp->IoStatus.Information 
							= outBufLength-sizeof (FLT_IF_GET_PARAMS);
				    ulBytes = (ULONG)Irp->IoStatus.Information;
					status = GetInFilters (
								*((PULONG)inBuffer),
								&((PFLT_IF_GET_PARAMS)outBuffer)->FilterAction,
								&((PFLT_IF_GET_PARAMS)outBuffer)->TotalSize,
								(PIPX_TRAFFIC_FILTER_INFO)
										((PUCHAR)outBuffer+sizeof (FLT_IF_GET_PARAMS)),
							    &ulBytes);
					Irp->IoStatus.Information = ulBytes;
					if (NT_SUCCESS (status)) {
						Irp->IoStatus.Information += sizeof (FLT_IF_GET_PARAMS);
						((PFLT_IF_GET_PARAMS)outBuffer)->FilterSize
							= sizeof (IPX_TRAFFIC_FILTER_INFO);
					}
					else
						Irp->IoStatus.Information = 0;
				}
				break;
			case IOCTL_FLT_IF_GET_OUT_FILTERS:
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_IF_GET_OUT_FILTERS.\n"));
				if ((inpBufLength==sizeof (ULONG))
						&& (outBufLength>=sizeof (FLT_IF_GET_PARAMS))) {
					Irp->IoStatus.Information 
							= outBufLength-sizeof (FLT_IF_GET_PARAMS);
				    ulBytes = (ULONG)Irp->IoStatus.Information;
					status = GetOutFilters (
								*((PULONG)inBuffer),
								&((PFLT_IF_GET_PARAMS)outBuffer)->FilterAction,
								&((PFLT_IF_GET_PARAMS)outBuffer)->TotalSize,
								(PIPX_TRAFFIC_FILTER_INFO)
										((PUCHAR)outBuffer+sizeof (FLT_IF_GET_PARAMS)),
							    &ulBytes);
					Irp->IoStatus.Information = ulBytes;
					if (NT_SUCCESS (status)) {
						Irp->IoStatus.Information += sizeof (FLT_IF_GET_PARAMS);
						((PFLT_IF_GET_PARAMS)outBuffer)->FilterSize
							= sizeof (IPX_TRAFFIC_FILTER_INFO);
					}
					else
						Irp->IoStatus.Information = 0;
				}
			
				break;
			case IOCTL_FLT_GET_LOGGED_PACKETS:
				IpxFltDbgPrint (DBG_PKTLOGS, ("IpxFlt: IOCTL_FLT_GET_LOGGED_PACKETS.\n"));
				Irp->IoStatus.Status = status = STATUS_PENDING;
				IoMarkIrpPending (Irp);
				IoAcquireCancelSpinLock (&cancelIRQL);
				InsertTailList (&LogIrpQueue,
								&Irp->Tail.Overlay.ListEntry);
				IoSetCancelRoutine (Irp, IpxFltCancel);
				if (LogIrpQueue.Flink!=&Irp->Tail.Overlay.ListEntry) {
					PIRP	irp = CONTAINING_RECORD (
										LogIrpQueue.Flink,
										IRP,
										Tail.Overlay.ListEntry);
					if (irp->IoStatus.Information>0) {
						RemoveEntryList (&irp->Tail.Overlay.ListEntry);
						IoSetCancelRoutine (irp, NULL);
						irp->IoStatus.Status = STATUS_SUCCESS;
						IoReleaseCancelSpinLock (cancelIRQL);
						IpxFltDbgPrint (DBG_PKTLOGS,
							("IpxFlt: completing logging request"
							" with %d bytes of data.\n",
							irp->IoStatus.Information));
						IoCompleteRequest (irp, IO_NO_INCREMENT);
						break;
					}
				}
				IoReleaseCancelSpinLock (cancelIRQL);
				break;
			default:
				IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
						("IpxFlt: Unsupported IOCTL %lx.\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
		}
		else if (RouterFile==NULL) {
			if (IrpStack->Parameters.DeviceIoControl.IoControlCode
					==IOCTL_FLT_START) {
				IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: IOCTL_FLT_START.\n"));
				status = InitializeTables ();
				if (NT_SUCCESS (status)) {
					RouterFile  = IrpStack->FileObject;
					status = STATUS_SUCCESS;
				}
			}
			else {
				IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
						("IpxFlt: Unsupported IOCTL %lx (driver is not started yet)).\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
				status = STATUS_INVALID_DEVICE_REQUEST;
			}
		}
		else {
			IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
					("IpxFlt: Unsupported IOCTL %lx from non-router client.\n",
					IrpStack->Parameters.DeviceIoControl.IoControlCode));
			status = STATUS_INVALID_DEVICE_REQUEST;
		}

		break;
	default:
		IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
							("IpxFlt: Unsupported function %lx.\n",
											IrpStack->MajorFunction));
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
    }

DispatchExit:
    if (status!=STATUS_PENDING) {
	Irp->IoStatus.Status = status;
	if (NT_SUCCESS (status))
		;
	else
		IpxFltDbgPrint (DBG_IOCTLS|DBG_ERRORS,
							("IpxFlt: Failed call with status %lx.\n",
							status));
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}



/*++

Routine Description:
	Cleans up on driver unload

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
VOID
IpxFltUnload(
    IN PDRIVER_OBJECT DriverObject
    ) {
	IpxFltDbgPrint (DBG_IOCTLS,	("IpxFlt: Unloading\n"));
	if (RouterFile!=NULL) {
		DeleteTables ();
		RouterFile = NULL;
	}
	UnbindFromFwdDriver (KernelMode);
    IoDeleteDevice (DriverObject->DeviceObject);
}


/*++
	I p x F l t C a n c e l

Routine Description:
	Cancels specified IRP

Arguments:
	DeviceObject	- forwarder device object
	irp				- irp to cancel

Return Value:
	None
--*/
VOID
IpxFltCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	) {
    RemoveEntryList (&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock (irp->CancelIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IpxFltDbgPrint(DBG_IOCTLS, ("IpxFlt: completing cancelled irp.\n"));
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\flt\fwdbind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\flt\fwdbind.h

Abstract:
    IPX Filter driver binding with forwarder routines


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFLT_FWDBIND_
#define _IPXFLT_FWDBIND_


	// Buffer to keep forwarder entry points
extern IPX_FLT_BIND_OUTPUT	FltBindOutput;

	// Forwarder entry points macros
#define FwdSetFilterInContext (FltBindOutput.SetIfInContextHandler)
#define FwdSetFilterOutContext (FltBindOutput.SetIfOutContextHandler)


/*++
	B i n d T o F w d D r i v e r

Routine Description:

	Opens  forwarder driver and exchages entry points
Arguments:
	None
Return Value:
	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
BindToFwdDriver (
	KPROCESSOR_MODE requestorMode
	);

/*++
	U n i n d T o F w d D r i v e r

Routine Description:

	Closes forwarder driver
Arguments:
	None
Return Value:
	None

--*/
VOID
UnbindFromFwdDriver (
	KPROCESSOR_MODE requestorMode
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\ddreqs.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ddreqs.c

Abstract:
	Management of demand dial request queues


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

LIST_ENTRY	ConnectionIrpQueue;
LIST_ENTRY	ConnectionRequestQueue;

/*++
	Q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Adds request to connected the interface to the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				connected
    packet  - packet that prompted the connection request
    data    - pointer to actual data in the packet
	oldIRQL	- IRQL at which interface lock was acquired

Return Value:
	None

	Note that interface lock must be acquired before calling this
	routine which will release it

--*/
VOID
QueueConnectionRequest (
	PINTERFACE_CB	ifCB,
    PNDIS_PACKET    packet,
    PUCHAR          data,
	KIRQL			oldIRQL
	) {
	KIRQL	cancelIRQL;

	IoAcquireCancelSpinLock (&cancelIRQL);
	SET_IF_CONNECTING (ifCB);
	if (!IsListEmpty (&ConnectionIrpQueue)) {
	    ULONG ulBytes = 0;
		PIRP				irp = CONTAINING_RECORD (
										ConnectionIrpQueue.Flink,
										IRP,
										Tail.Overlay.ListEntry);
		PIO_STACK_LOCATION	irpStack=IoGetCurrentIrpStackLocation(irp);
		RemoveEntryList (&irp->Tail.Overlay.ListEntry);
		ASSERT (irpStack->Parameters.DeviceIoControl.IoControlCode
										==IOCTL_FWD_GET_DIAL_REQUEST);
		ASSERT ((irpStack->Parameters.DeviceIoControl.IoControlCode&3)
										==METHOD_BUFFERED);
        IoSetCancelRoutine (irp, NULL);
		IoReleaseCancelSpinLock (cancelIRQL);

        FillConnectionRequest (
                ifCB->ICB_Index,
                packet,
                data,
				(PFWD_DIAL_REQUEST)irp->AssociatedIrp.SystemBuffer,
				irpStack->Parameters.DeviceIoControl.OutputBufferLength,
				&ulBytes);
		irp->IoStatus.Information = ulBytes;
        irp->IoStatus.Status = STATUS_SUCCESS;

		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
    	IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
	    	("IpxFwd: Passing dial request for if %ld (icb:%08lx) with %d bytes of data.\n",
		    ifCB->ICB_Index, ifCB, irp->IoStatus.Information));
		IoCompleteRequest (irp, IO_NO_INCREMENT);
	}
	else {
    	InsertTailList (&ConnectionRequestQueue, &ifCB->ICB_ConnectionLink);
		IoReleaseCancelSpinLock (cancelIRQL);
        ifCB->ICB_ConnectionPacket = packet;
        ifCB->ICB_ConnectionData = data;
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
	}
}

/*++
	D e q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Removes conection requset for the interface from the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				removed

Return Value:
	None

--*/
VOID
DequeueConnectionRequest (
	PINTERFACE_CB	ifCB
	) {
	KIRQL	cancelIRQL;
	IoAcquireCancelSpinLock (&cancelIRQL);
	if (IsListEntry (&ifCB->ICB_ConnectionLink)) {
		RemoveEntryList (&ifCB->ICB_ConnectionLink);
		InitializeListEntry (&ifCB->ICB_ConnectionLink);
	}
	IoReleaseCancelSpinLock (cancelIRQL);
}

/*++
	F i l l C o n n e c t i o n R e q u e s t

Routine Description:
	Fills the provided buffer with index of interface that needs
	to be connected and packet that prompted the request
	
Arguments:
    index   - if index
    packet  - packet that prompted the request
    data    - pointer to IPX data (IPX header) inside of the packet
	request	- request buffer to fill
    reqSize - size of request buffer
    bytesCopied - bytesCopied into the request buffer

Return Value:
	STATUS_SUCCESS - array was filled successfully
	This routine assumes that there it is called only when there
	are outstanding requests in the request queue

--*/
VOID
FillConnectionRequest (
    IN ULONG                    index,
    IN PNDIS_PACKET             packet,
    IN PUCHAR                   data,
	IN OUT PFWD_DIAL_REQUEST	request,
    IN ULONG                    reqSize,
    OUT PULONG                  bytesCopied
    ) {
    PNDIS_BUFFER    buf;

    *bytesCopied = 0;
	request->IfIndex = index;
    NdisQueryPacket (packet, NULL, NULL, &buf, NULL);
    do {
        PVOID   va;
        UINT    length;

        NdisQueryBuffer (buf, &va, &length);
        if (((PUCHAR)va<=data)
                && ((PUCHAR)va+length>data)) {
            TdiCopyMdlToBuffer (buf,
                    (ULONG)(data-(PUCHAR)va),
                    request,
                    FIELD_OFFSET (FWD_DIAL_REQUEST, Packet),
                    reqSize,
                    bytesCopied);
            *bytesCopied += FIELD_OFFSET (FWD_DIAL_REQUEST, Packet);
            break;
        }
        NdisGetNextBuffer (buf, &buf);
    }
    while (buf!=NULL);
}

/*++
	F a i l C o n n e c t i o n R e q u e s t s

Routine Description:
	Cleans up on connection request failure
	
Arguments:
	InterfaceIndex - index of interface that could not be connected

Return Value:
	STATUS_SUCCESS - clean up was successfull
	STATUS_UNSUCCESSFUL - interface with this index does not exist

--*/
NTSTATUS
FailConnectionRequest (
	IN ULONG	InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;

	ASSERT (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX);

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
	    IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
			("IpxFwd: Dial request failed for if %ld (icb:%08lx).\n",
			ifCB->ICB_Index, ifCB));
		ProcessInternalQueue (ifCB);
		ProcessExternalQueue (ifCB);
		KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
		if (IS_IF_CONNECTING (ifCB)) {
			SET_IF_NOT_CONNECTING (ifCB);
			DequeueConnectionRequest (ifCB);
		}
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	debug.h
//
// Description: Debug macros definitions
//
// Author:	Stefan Solomon (stefans)    October 4, 1993.
//
// Revision History:
//
//***

#ifndef _IPXFWD_DEBUG_
#define _IPXFWD_DEBUG_

#if DBG
#define DBG_PACKET_ALLOC	((ULONG)0x00000001)
#define DBG_INTF_TABLE		((ULONG)0x00000002)
#define DBG_ROUTE_TABLE		((ULONG)0x00000004)
#define DBG_NBROUTE_TABLE	((ULONG)0x00000008)
#define DBG_IOCTLS			((ULONG)0x00000010)
#define DBG_LINEIND			((ULONG)0x00000020)
#define DBG_IPXBIND			((ULONG)0x00000040)
#define DBG_REGISTRY		((ULONG)0x00000080)
#define DBG_INT_RECV		((ULONG)0x00000100)
#define DBG_RECV			((ULONG)0x00000200)
#define DBG_SEND			((ULONG)0x00000400)
#define DBG_INT_SEND		((ULONG)0x00000800)
#define DBG_NETBIOS			((ULONG)0x00001000)
#define DBG_IPXROUTE		((ULONG)0x00002000)
#define DBG_DIALREQS		((ULONG)0x00004000)
#define DBG_SPOOFING		((ULONG)0x00008000)

#define DBG_INFORMATION		((ULONG)0x10000000)
#define DBG_WARNING			((ULONG)0x20000000)
#define DBG_ERROR			((ULONG)0x40000000)

#define DEF_DBG_LEVEL (					\
			DBG_ERROR|DBG_WARNING		\
			| DBG_INTF_TABLE			\
			| DBG_LINEIND				\
			| DBG_IPXBIND				\
			| DBG_REGISTRY				\
			| DBG_IPXROUTE				\
			| DBG_IOCTLS				\
			| DBG_DIALREQS				\
			| DBG_SPOOFING				\
		)

extern ULONG DbgLevel;
extern LONGLONG ActivityTreshhold;
extern LARGE_INTEGER CounterFrequency;

#define IpxFwdDbgPrint(COMPONENT,LEVEL,ARGS)							\
	do {															    \
		if ((DbgLevel & ((COMPONENT)|(LEVEL)))==((COMPONENT)|(LEVEL))){ \
			DbgPrint ARGS;											    \
		}															    \
	} while (0)

#else
#define IpxFwdDbgPrint(COMPONENT,LEVEL,ARGS) do {NOTHING;} while (0)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\debug.c ===
#include "precomp.h"

#if DBG
ULONG   DbgLevel = DEF_DBG_LEVEL;
LONGLONG ActivityTreshhold = _I64_MAX;
LARGE_INTEGER CounterFrequency;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\ddreqs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ddreqs.h

Abstract:
	Management of demand dial request queues


Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef _IPXFWD_DDREQS_
#define _IPXFWD_DDREQS_

// Connection requests to DIM
//	Queue of request that need to be satisfied by DIM
extern LIST_ENTRY ConnectionRequestQueue;
//	Queue of request IRPs posted by the router manager
extern LIST_ENTRY ConnectionIrpQueue;

/*++
	I n i t i a l i z e C o n n e c t i o n Q u e u e s

Routine Description:
	Initializes connection request and irp queues
	
Arguments:
	None

Return Value:
	None

--*/
//VOID
//InitializeConnectionQueues (
//	void
//	);
#define InitializeConnectionQueues() {									\
	InitializeListHead (&ConnectionIrpQueue);							\
	InitializeListHead (&ConnectionRequestQueue);						\
}

/*++
	F i l l C o n n e c t i o n R e q u e s t

Routine Description:
	Fills the provided buffer with index of interface that needs
	to be connected and packet that prompted the request
	
Arguments:
    index   - if index
    packet  - packet that prompted the request
    data    - pointer to IPX data (IPX header) inside of the packet
	request	- request buffer to fill
    reqSize - size of request buffer
    bytesCopied - bytesCopied into the request buffer

Return Value:
	STATUS_SUCCESS - array was filled successfully
	This routine assumes that there it is called only when there
	are outstanding requests in the request queue

--*/
VOID
FillConnectionRequest (
    IN ULONG                    index,
    IN PNDIS_PACKET             packet,
    IN PUCHAR                   data,
	IN OUT PFWD_DIAL_REQUEST	request,
    IN ULONG                    reqSize,
    OUT PULONG                  bytesCopied
	);

/*++
	F a i l C o n n e c t i o n R e q u e s t s

Routine Description:
	Cleans up on connection request failure
	
Arguments:
	InterfaceIndex - index of interface that could not be connected

Return Value:
	STATUS_SUCCESS - clean up was successfull
	STATUS_UNSUCCESSFUL - interface with this index does not exist

--*/
NTSTATUS
FailConnectionRequest (
	IN ULONG	InterfaceIndex
	);
	
/*++
	Q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Adds request to connected the interface to the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				connected
    packet  - packet that prompted the connection request
    data    - pointer to actual data in the packet
	oldIRQL	- IRQL at which interface lock was acquired

Return Value:
	None

	Note that interface lock must be acquired before calling this
	routine which will release it

--*/
VOID
QueueConnectionRequest (
	PINTERFACE_CB	ifCB,
    PNDIS_PACKET    packet,
    PUCHAR          data,
	KIRQL			oldIRQL
	);

/*++
	D e q u e u e C o n n e c t i o n R e q u e s t

Routine Description:
	Removes conection requset for the interface from the queue

Arguments:
	ifCB	- control block of the interface that needs to be
				removed

Return Value:
	None

--*/
VOID
DequeueConnectionRequest (
	PINTERFACE_CB	ifCB
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\driver.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\driver.h

Abstract:
    IPX Forwarder driver dispatch routines


Author:

    Vadim Eydelman

Revision History:

--*/


#ifndef _IPXFWD_DRIVER_
#define _IPXFWD_DRIVER_

// Pseudo constant 0xFFFFFFFFFFFFF
extern const UCHAR BROADCAST_NODE[6];

// Performance measurement:
//	Enabling flag
extern BOOLEAN			MeasuringPerformance;
//	Access control
extern KSPIN_LOCK		PerfCounterLock;
//	Statistic accumulators (counters)
extern FWD_PERFORMANCE	PerfBlock;

// Access control for external callers (ipx stack, filter driver)
//	Flag set upon completion of initialization of all components
extern volatile BOOLEAN IpxFwdInitialized;
//	Number of clients executing forwarder code (if -1, the forwarder
//	is being stopped)
extern LONG		ClientCount;
//	Event to be signalled by the last client inside forwarder
extern KEVENT	ClientsGoneEvent;

 
/*++
	E n t e r F o r w a r d e r

Routine Description:
	Checks if forwarder is initialized and grants access
	to it (records the entrance as well

Arguments:
	None

Return Value:
	TRUE - access granted
	FALSE - forwarder is not yet initialized or is being stopped

--*/
//BOOLEAN
//EnterForwarder (
//	void
//	);
#define EnterForwarder() (									\
	(InterlockedIncrement(&ClientCount), IpxFwdInitialized) \
			? TRUE											\
			: (DoLeaveForwarder(), FALSE)						\
	)

/*++
	L e a v e F o r w a r d e r

Routine Description:
	Records the fact that external client stopped using forwarder
	
Arguments:
	None

Return Value:
	None

--*/
//BOOLEAN
//EnterForwarder (
//	void
//	);
#define LeaveForwarder()							\
	((InterlockedDecrement(&ClientCount)<0)			\
		? KeSetEvent (&ClientsGoneEvent,0,FALSE)	\
		: 0											\
	)

// Same as above but implemented as a routine to be used in
// the EnterForwarder macro above (this reduces code size
// and aids in debugging by improving readability of disassembly
BOOLEAN
DoLeaveForwarder (
	VOID
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\filterif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\filterif.c

Abstract:
    IPX Forwarder driver interface with filter driver


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

	// Filter driver entry points
IPX_FLT_BIND_INPUT FltBindInput = {NULL, NULL};
	// Protects access to filter driver contexts
RW_LOCK		FltLock;


/*++
	D o F i l t e r

Routine Description:
	
	Calls filter driver entry point while holding reader access
	to interface contexts

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT	- packet should be passed on by the forwarder
	FILTER_DENY		- packet should be dropped

--*/
FILTER_ACTION
DoFilter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContex
	) {
	RWCOOKIE		cookie;
	FILTER_ACTION	result;
	AcquireReaderAccess (&FltLock, cookie);
	result = FltBindInput.FilterHandler (ipxHdr,
							ipxHdrLength,
							ifInContext,
							ifOutContex); 
	ReleaseReaderAccess (&FltLock, cookie);
	return result;
}

/*++
	D o I n t e r f a c e D e l e t e d

Routine Description:
	Resets interface contexts and calls filter dirver entry point
	making sure that all no one holds reader access to filter driver
	interface contexts
Arguments:
	ifCB	 - interface to be deleted
Return Value:
	None

--*/
VOID
DoInterfaceDeleted (
	PINTERFACE_CB	ifCB
	) {
	PVOID	inContext = ifCB->ICB_FilterInContext,
			outContext = ifCB->ICB_FilterOutContext;
	ifCB->ICB_FilterInContext = NO_FILTER_CONTEXT;
	ifCB->ICB_FilterOutContext = NO_FILTER_CONTEXT;
	WaitForAllReaders (&FltLock);
	FltBindInput.InterfaceDeletedHandler(inContext,
							outContext);
}

/*++
	S e t I f I n C o n t e x t

Routine Description:
	Associates filter driver context with
	the packets received on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifInContext		- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
NTSTATUS
SetIfInContext (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifInContext
	) {
	PINTERFACE_CB	ifCB;
    NTSTATUS        status = STATUS_SUCCESS;

    if (EnterForwarder ()) { 
	    ifCB = GetInterfaceReference (InterfaceIndex);
	    if (ifCB!=NULL) {
		    ifCB->ICB_FilterInContext = ifInContext;
		    WaitForAllReaders (&FltLock);
    	    ReleaseInterfaceReference(ifCB);
	    }
	    else
		    status = STATUS_UNSUCCESSFUL;
        LeaveForwarder ();
    }
    return status;
}

/*++
	S e t I f O u t C o n t e x t

Routine Description:
	Associates filter driver context with
	the packets sent on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifOutContext	- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
NTSTATUS
SetIfOutContext (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifOutContext
	) {
	PINTERFACE_CB	ifCB;
    NTSTATUS        status = STATUS_SUCCESS;

    if (EnterForwarder ()) { 
    	ifCB = GetInterfaceReference (InterfaceIndex);
	    if (ifCB!=NULL) {
		    ifCB->ICB_FilterOutContext = ifOutContext;
		    WaitForAllReaders (&FltLock);
    	    ReleaseInterfaceReference(ifCB);
    	}
	    else
		    status = STATUS_UNSUCCESSFUL;
        LeaveForwarder ();
    }
    return status;
}

/*++
	B i n d F i l t e r D r i v e r

Routine Description:
	Exchanges entry points with filter driver
Arguments:
	bindInput	- filter driver entry points
	bindOutput	- forwarder driver entry points
Return Value:
	None
--*/
VOID
BindFilterDriver (
	IN PIPX_FLT_BIND_INPUT		bindInput,
	OUT PIPX_FLT_BIND_OUTPUT	bindOutput
	) {
	memcpy (&FltBindInput, bindInput, sizeof (IPX_FLT_BIND_INPUT));
	bindOutput->Size = sizeof (IPX_FLT_BIND_OUTPUT);
	bindOutput->SetIfInContextHandler = SetIfInContext;
	bindOutput->SetIfOutContextHandler = SetIfOutContext;
	InitializeRWLock (&FltLock); 
}

/*++
	U n b i n d F i l t e r D r i v e r

Routine Description:
	Resets locally stored filter driver entry points
	and resets filter driver contexts on all interfaces
Arguments:
	None
Return Value:
	None
--*/
VOID
UnbindFilterDriver (
	VOID
	) {
	PINTERFACE_CB	ifCB = NULL;
	FltBindInput.FilterHandler = NULL;
	FltBindInput.InterfaceDeletedHandler = NULL;
	
	while ((ifCB=GetNextInterfaceReference (ifCB))!=NULL) {
		ifCB->ICB_FilterInContext = NO_FILTER_CONTEXT;
		ifCB->ICB_FilterOutContext = NO_FILTER_CONTEXT;
	}
	InternalInterface->ICB_FilterInContext = NO_FILTER_CONTEXT;
	InternalInterface->ICB_FilterOutContext = NO_FILTER_CONTEXT;
	WaitForAllReaders (&FltLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\driver.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\driver.c

Abstract:
    IPX Forwarder driver dispatch routines


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

const UCHAR BROADCAST_NODE[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
const LONGLONG WaitTimeout = -50000000i64;
volatile BOOLEAN IpxFwdInitialized = FALSE;

BOOLEAN			MeasuringPerformance = FALSE;
KSPIN_LOCK		PerfCounterLock;
FWD_PERFORMANCE PerfBlock;

LONG		ClientCount = 0;
KEVENT		ClientsGoneEvent;

PFILE_OBJECT	RouterFile, FilterFile;

NTSTATUS
IpxFwdDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IpxFwdUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DoStart (
	IN ULONG	RouteHashTableSize,
	IN BOOLEAN	thisMachineOnly
	);

NTSTATUS
DoStop (
	void
	);

NTSTATUS
DoSetInterface (
	IN ULONG		InterfaceIndex,
	IN BOOLEAN		NetbiosAccept,
	IN UCHAR		NetbiosDeliver
	);

NTSTATUS
DoGetInterface (
	IN ULONG			InterfaceIndex,
	OUT PFWD_IF_STATS	stats,
	OUT BOOLEAN			*NetbiosAccept,
	OUT UCHAR			*NetbiosDeliver
	);

NTSTATUS
DoSetNbNames (
	IN ULONG			InterfaceIndex,
	IN ULONG			Count,
	IN PFWD_NB_NAME		Names
	);

NTSTATUS
DoGetNbNames (
	IN ULONG			InterfaceIndex,
	IN OUT ULONG    	*BufferSize,
	OUT ULONG			*Count,
	OUT PFWD_NB_NAME	Names
	);

NTSTATUS
DoBindInterface (
	IN ULONG						InterfaceIndex,
	IN PFWD_ADAPTER_BINDING_INFO	info
	);

NTSTATUS
DoUnbindInterface (
	IN ULONG					InterfaceIndex
	);

NTSTATUS
DoDisableInterface (
	IN ULONG					InterfaceIndex
	);

NTSTATUS
DoEnableInterface (
	IN ULONG					InterfaceIndex
	);

NTSTATUS
DoSetRoutes (
	IN PFWD_ROUTE_SET_PARAMS	routeArray,
	IN ULONG					nRoutes,
	OUT PULONG					nProcessed
	);

VOID
IpxFwdCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	);

NTSTATUS
DoGetPerfCounters (
	OUT PFWD_PERFORMANCE_PARAMS	perfParams,
	OUT ULONG* plSize
	);

// [pmay] Keep the forwarder sync'd with the stack's nic id
// numbering scheme.
NTSTATUS DecrementNicids (USHORT usThreshold);
NTSTATUS IncrementNicids (USHORT usThreshold);
NTSTATUS DoGetIfTable    (FWD_INTERFACE_TABLE_ROW * pRows,
                          ULONG dwRowBufferSize);

	
/*++
	D r i v e r E n t r y

Routine Description:

	Installable driver initialization entry point.
	This entry point is called directly by the I/O system.

Arguments:

	DriverObject - pointer to the driver object

	RegistryPath - pointer to a unicode string representing the path
				   to driver-specific key in the registry

Return Value:

	STATUS_SUCCESS if successful,
	STATUS_UNSUCCESSFUL otherwise

--*/
NTSTATUS
DriverEntry (
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
	) {

	PDEVICE_OBJECT deviceObject = NULL;
	NTSTATUS       status;
	WCHAR          deviceNameBuffer[] = IPXFWD_NAME;
	UNICODE_STRING deviceNameUnicodeString;

	IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION,
								("IpxFwd: Entering DriverEntry\n"));

	//
	// Create an non-EXCLUSIVE device object
	//

	RtlInitUnicodeString (&deviceNameUnicodeString,
						  deviceNameBuffer);

	status = IoCreateDevice (DriverObject,
							   0,
							   &deviceNameUnicodeString,
							   FILE_DEVICE_IPXFWD,
							   0,
							   FALSE,		// Non-Exclusive
							   &deviceObject
							   );

	if (NT_SUCCESS(status)) {
		//
		// Create dispatch points for device control, create, close.
		//
		GetForwarderParameters (RegistryPath);
		DriverObject->MajorFunction[IRP_MJ_CREATE]
			= DriverObject->MajorFunction[IRP_MJ_CLEANUP]
			= DriverObject->MajorFunction[IRP_MJ_CLOSE]
			= DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]
			= IpxFwdDispatch;
		DriverObject->DriverUnload = IpxFwdUnload;
		status = BindToIpxDriver (KernelMode);
		if (NT_SUCCESS (status)) {

#if DBG
			KeQueryPerformanceCounter (&CounterFrequency);
#endif
			FilterFile = RouterFile = NULL;
			ClientCount = 0;
			return STATUS_SUCCESS;
		}
    IoDeleteDevice (DriverObject->DeviceObject);
	}
	else
		IpxFwdDbgPrint (DBG_IOCTLS, DBG_ERROR,
							("IpxFwd: IoCreateDevice failed\n"));

	return status;
}



/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
NTSTATUS
IpxFwdDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    ) {
    PIO_STACK_LOCATION	IrpStack;
    PVOID				inBuffer, outBuffer;
    ULONG				inpBufLength;
    ULONG				outBufLength;
    NTSTATUS			status;
	KIRQL				cancelIRQL;
    LONG                lNumProcessed;
    ULONG               ulBytesCopied;

    ulBytesCopied = 0;
    lNumProcessed = 0;
    Irp->IoStatus.Information = 0;
	status = STATUS_SUCCESS;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    IrpStack = IoGetCurrentIrpStackLocation(Irp);


    switch (IrpStack->MajorFunction) {
	case IRP_MJ_CREATE:
		IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: IRP_MJ_CREATE\n"));
		break;

	case IRP_MJ_CLOSE:
		IpxFwdDbgPrint(DBG_IOCTLS,  DBG_WARNING, ("IpxFwd: IRP_MJ_CLOSE\n"));
		if (EnterForwarder ()) {
			if (IrpStack->FileObject==RouterFile) {
				LeaveForwarder ();
				IpxFwdInitialized = FALSE;
				while (InterlockedDecrement (&ClientCount)>=0) {
					KeWaitForSingleObject (&ClientsGoneEvent,
												Executive,
												KernelMode,
												FALSE,
												(PLARGE_INTEGER)&WaitTimeout);
					InterlockedIncrement (&ClientCount);
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
							("IpxFwd: Waiting for all clients (%ld) to exit.\n",
							ClientCount));
				}
				status = DoStop ();
				ClientCount = 0;
				RouterFile = NULL;
			}
			else if (IrpStack->FileObject==FilterFile) {
				UnbindFilterDriver ();
				FilterFile = NULL;
				LeaveForwarder ();
			}
			else
				LeaveForwarder ();
		}
		break;

	case IRP_MJ_CLEANUP:
		IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: IRP_MJ_CLEANUP\n"));
		if (EnterForwarder ()) {
			if (IrpStack->FileObject==RouterFile) {
				IoAcquireCancelSpinLock (&cancelIRQL);
				while (!IsListEmpty (&ConnectionIrpQueue)) {
					PIRP irp = CONTAINING_RECORD (ConnectionIrpQueue.Blink,
										IRP, Tail.Overlay.ListEntry);
					irp->Cancel = TRUE;
					irp->CancelIrql = cancelIRQL;
					irp->CancelRoutine = NULL;
					IpxFwdCancel(DeviceObject, irp);
					IoAcquireCancelSpinLock (&cancelIRQL);
				}
				IoReleaseCancelSpinLock(cancelIRQL);
			}
			LeaveForwarder ();
		}
		break;

	case IRP_MJ_DEVICE_CONTROL:
    //
    // Get the pointer to the input/output buffer and it's length
    //

		status = STATUS_INVALID_PARAMETER;
		inpBufLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
		outBufLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		switch (IrpStack->Parameters.DeviceIoControl.IoControlCode&3) {
		case METHOD_BUFFERED:
			inBuffer = outBuffer = Irp->AssociatedIrp.SystemBuffer;
			break;

		case METHOD_IN_DIRECT:
		case METHOD_OUT_DIRECT:
			inBuffer = Irp->AssociatedIrp.SystemBuffer;
			if (outBufLength>0) {
				outBuffer = MmGetSystemAddressForMdlSafe (Irp->MdlAddress, NormalPagePriority);
				if (outBuffer == NULL)
				{
        			IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
        				("IpxFwd: System too low on memory to allocate mdl buffer.\n"));
        			goto DispatchExit;
				}
			}
			else {
				outBuffer = NULL;
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
					("IpxFwd: IOCTL...METHOD_DIRECT with 0 output buffer ???\n"));
			}
			break;
		default:
			IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
				("IpxFwd: IOCTL...METHOD_NEITHER ???\n"));
			goto DispatchExit;
		}


		if (EnterForwarder ()) {
			if (IrpStack->FileObject==RouterFile) {
				switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
				case IOCTL_FWD_SET_ROUTES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_SET_ROUTES\n"));
					if (inpBufLength>=sizeof (FWD_ROUTE_SET_PARAMS))
						status = DoSetRoutes (
									(PFWD_ROUTE_SET_PARAMS)inBuffer,
									inpBufLength/sizeof(FWD_ROUTE_SET_PARAMS),
									&lNumProcessed);
				
					break;

				case IOCTL_FWD_SET_NB_NAMES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_SET_NB_NAMES\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoSetNbNames (
								*((PULONG)inBuffer),
								outBufLength/sizeof (FWD_NB_NAME),
								(PFWD_NB_NAME)outBuffer);
					break;
									
				case IOCTL_FWD_RESET_NB_NAMES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_RESET_NB_NAMES\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoSetNbNames (*((PULONG)inBuffer), 0, NULL);

					break;
				case IOCTL_FWD_GET_NB_NAMES:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_NB_NAMES\n"));
					if ((inpBufLength==sizeof (ULONG))
							&& (outBufLength>=sizeof(ULONG))) {
						Irp->IoStatus.Information = outBufLength
								-FIELD_OFFSET (FWD_NB_NAMES_PARAMS, Names);
						status = DoGetNbNames (
								*((PULONG)inBuffer),
								&ulBytesCopied,
								&((PFWD_NB_NAMES_PARAMS)outBuffer)->TotalCount,
								((PFWD_NB_NAMES_PARAMS)outBuffer)->Names);
						Irp->IoStatus.Information = ulBytesCopied;
						if (NT_SUCCESS (status)) {
							Irp->IoStatus.Information += FIELD_OFFSET (
											FWD_NB_NAMES_PARAMS, Names);
						}
					}
					break;
									
				case IOCTL_FWD_CREATE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_CREATE_INTERFACE\n"));
					if (inpBufLength==sizeof(FWD_IF_CREATE_PARAMS))
						status = AddInterface (
								((PFWD_IF_CREATE_PARAMS)inBuffer)->Index,
								((PFWD_IF_CREATE_PARAMS)inBuffer)->InterfaceType,
								((PFWD_IF_CREATE_PARAMS)inBuffer)->NetbiosAccept,
								((PFWD_IF_CREATE_PARAMS)inBuffer)->NetbiosDeliver);
					break;

				case IOCTL_FWD_DELETE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_DELETE_INTERFACE\n"));
					if (inpBufLength==sizeof(ULONG))
						status = DeleteInterface (
									*((PULONG)inBuffer));
							
					break;

				case IOCTL_FWD_SET_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_SET_INTERFACE\n"));
					if (inpBufLength==sizeof(FWD_IF_SET_PARAMS))
						status = DoSetInterface (
								((PFWD_IF_SET_PARAMS)inBuffer)->Index,
								((PFWD_IF_SET_PARAMS)inBuffer)->NetbiosAccept,
								((PFWD_IF_SET_PARAMS)inBuffer)->NetbiosDeliver);
					break;

				case IOCTL_FWD_GET_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_INTERFACE\n"));
					if ((inpBufLength==sizeof(ULONG))
							&& (outBufLength==sizeof(FWD_IF_GET_PARAMS))) {
						status = DoGetInterface (
								*((PULONG)inBuffer),
								&((PFWD_IF_GET_PARAMS)outBuffer)->Stats,
								&((PFWD_IF_GET_PARAMS)outBuffer)->NetbiosAccept,
								&((PFWD_IF_GET_PARAMS)outBuffer)->NetbiosDeliver);
						if (NT_SUCCESS (status))
							Irp->IoStatus.Information = sizeof(FWD_IF_GET_PARAMS);
					}
					break;

				case IOCTL_FWD_BIND_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_BIND_INTERFACE\n"));
					if (inpBufLength==sizeof(FWD_IF_BIND_PARAMS))
						status = DoBindInterface (
									((PFWD_IF_BIND_PARAMS)inBuffer)->Index,
									&((PFWD_IF_BIND_PARAMS)inBuffer)->Info);
					break;

				case IOCTL_FWD_UNBIND_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_UNBIND_INTERFACE\n"));
					if (inpBufLength==sizeof(ULONG))
						status = DoUnbindInterface (*((PULONG)inBuffer));
					break;

                case IOCTL_FWD_RENUMBER_NICS:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_RENUMBER_NICS\n"));
					if (inpBufLength == sizeof(FWD_RENUMBER_NICS_DATA)) {
					    if (((FWD_RENUMBER_NICS_DATA*)inBuffer)->ulOpCode == FWD_NIC_OPCODE_DECREMENT)
					        status = DecrementNicids (((FWD_RENUMBER_NICS_DATA*)inBuffer)->usThreshold);
					    else
					        status = IncrementNicids (((FWD_RENUMBER_NICS_DATA*)inBuffer)->usThreshold);
					}
                    break;

				case IOCTL_FWD_GET_DIAL_REQUEST:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_DIAL_REQUEST\n"));
					if (outBufLength>=sizeof (ULONG)) {
						IoAcquireCancelSpinLock (&cancelIRQL);
						if (!IsListEmpty (&ConnectionRequestQueue)) {
                            PINTERFACE_CB ifCB = CONTAINING_RECORD (
                                            ConnectionRequestQueue.Flink,
                                            INTERFACE_CB,
                                            ICB_ConnectionLink);
		                    RemoveEntryList (&ifCB->ICB_ConnectionLink);
		                    InitializeListEntry (&ifCB->ICB_ConnectionLink);
    						IoReleaseCancelSpinLock (cancelIRQL);
                            KeAcquireSpinLock (&ifCB->ICB_Lock, &cancelIRQL);
							FillConnectionRequest (
                                        ifCB->ICB_Index,
                                        ifCB->ICB_ConnectionPacket,
                                        ifCB->ICB_ConnectionData,
										(PFWD_DIAL_REQUEST)outBuffer,
										outBufLength,
										&ulBytesCopied);
                            Irp->IoStatus.Information = ulBytesCopied;
                            status = STATUS_SUCCESS;
                            KeReleaseSpinLock (&ifCB->ICB_Lock, cancelIRQL);
						}
						else {
							InsertTailList (&ConnectionIrpQueue,
											&Irp->Tail.Overlay.ListEntry);
							IoSetCancelRoutine (Irp, IpxFwdCancel);
							IoMarkIrpPending (Irp);
							Irp->IoStatus.Status = status = STATUS_PENDING;
    						IoReleaseCancelSpinLock (cancelIRQL);
						}
					}
					break;
				case IOCTL_FWD_DIAL_REQUEST_FAILED:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_DIAL_REQUEST_FAILED\n"));
					if (inpBufLength==sizeof (ULONG))
						status = FailConnectionRequest (
										*((PULONG)inBuffer));
					break;
				case IOCTL_FWD_DISABLE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_DISABLE_INTERFACE\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoDisableInterface (
										*((PULONG)inBuffer));
					break;
				case IOCTL_FWD_ENABLE_INTERFACE:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_ENABLE_INTERFACE\n"));
					if (inpBufLength==sizeof (ULONG))
						status = DoEnableInterface (
										*((PULONG)inBuffer));
					break;
			    case IOCTL_FWD_UPDATE_CONFIG:
					IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_UPDATE_CONFIG\n"));
					if (inpBufLength==sizeof (FWD_UPDATE_CONFIG_PARAMS)) {
					    ThisMachineOnly = ((FWD_UPDATE_CONFIG_PARAMS*)inBuffer)->bThisMachineOnly;
						status = STATUS_SUCCESS;
				    }
					break;
				default:
					IpxFwdDbgPrint (DBG_IOCTLS, DBG_WARNING, ("IpxFwd: unknown IRP_MJ_DEVICE_CONTROL\n"));
					break;

				}
			}
			else if (IrpStack->Parameters.DeviceIoControl.IoControlCode
							==IOCTL_FWD_INTERNAL_BIND_FILTER)
            {
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_INTERNAL_BIND_FILTER\n"));
			    //
			    // pmay: 218246
			    // We only allow the kernel-mode ipx filter driver
			    // to bind to us.
			    //
				if (
				     (ExGetPreviousMode() == KernelMode)           &&
				     (inpBufLength == sizeof(IPX_FLT_BIND_INPUT) ) &&
				     (outBufLength >= sizeof(ULONG) )
				   )
				{
					if (outBufLength >= sizeof (IPX_FLT_BIND_OUTPUT)) {
						BindFilterDriver (
								(PIPX_FLT_BIND_INPUT)inBuffer,
								(PIPX_FLT_BIND_OUTPUT)outBuffer);
						Irp->IoStatus.Information = sizeof (IPX_FLT_BIND_OUTPUT);
						FilterFile = IrpStack->FileObject;
						status = STATUS_SUCCESS;
					}
					else {
						IPX_FLT_BIND_OUTPUT	bindOutput;
						BindFilterDriver (
								(PIPX_FLT_BIND_INPUT)inBuffer,
								&bindOutput);
						memcpy (outBuffer, &bindOutput, outBufLength);
						Irp->IoStatus.Information = outBufLength;
						status = STATUS_BUFFER_OVERFLOW;
					}
			    }
			}
			else if (IrpStack->Parameters.DeviceIoControl.IoControlCode
							==IOCTL_FWD_GET_PERF_COUNTERS) {
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_PERF_COUNTERS\n"));
				if (outBufLength==sizeof (FWD_PERFORMANCE_PARAMS))
				{
					status = DoGetPerfCounters (
									((PFWD_PERFORMANCE_PARAMS)outBuffer),
									&ulBytesCopied);
                    Irp->IoStatus.Information = ulBytesCopied;
                }
			}
			else if (IrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_FWD_GET_IF_TABLE) {
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_INFORMATION, ("IpxFwd: IOCTL_FWD_GET_IF_TABLE\n"));
				status = DoGetIfTable (outBuffer, outBufLength);
    			Irp->IoStatus.Information = outBufLength;
            }
			else {
				status = STATUS_ACCESS_DENIED;
				IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING,
					("IpxFwd: IOCTL: %08lx on non-router file object!\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
			}
			LeaveForwarder ();
		} else {
			if (IrpStack->Parameters.DeviceIoControl.IoControlCode==IOCTL_FWD_START) {
				IpxFwdDbgPrint (DBG_IOCTLS, DBG_WARNING,
											("IpxFwd: IOCTL_FWD_START\n"));
				if (inpBufLength==sizeof (FWD_START_PARAMS)) {
					KeInitializeEvent (&ClientsGoneEvent,
										SynchronizationEvent,
										FALSE);
					status = DoStart (
								((PFWD_START_PARAMS)inBuffer)->RouteHashTableSize,
								((PFWD_START_PARAMS)inBuffer)->ThisMachineOnly);
					if (NT_SUCCESS (status)) {
						RouterFile = IrpStack->FileObject;
						IpxFwdInitialized = TRUE;
					}
				}
			}
			else {
				IpxFwdDbgPrint (DBG_IOCTLS, DBG_ERROR,
						("IpxFwd: IOCTL: %08lx but fwd not started.\n",
						IrpStack->Parameters.DeviceIoControl.IoControlCode));
			}
		}
		break;
	default:
		IpxFwdDbgPrint (DBG_IOCTLS, DBG_ERROR,
					("IpxFwd: unknown MajorFunction.\n"));
		break;
    }

DispatchExit:
	if (status!=STATUS_PENDING) {
		IpxFwdDbgPrint(DBG_IOCTLS,
			NT_ERROR(status) ? DBG_WARNING : DBG_INFORMATION,
			("IpxFwd: completing IOCTL %08lx with status %08lx.\n",
			IrpStack->Parameters.DeviceIoControl.IoControlCode,
			status));
		Irp->IoStatus.Status = status;
		IoCompleteRequest(Irp, IO_NO_INCREMENT);
	}

    return status;
}



/*++

Routine Description:
	Cleans up on driver unload

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
VOID
IpxFwdUnload(
    IN PDRIVER_OBJECT DriverObject
    ) {
    IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: unloading\n"));
	if (EnterForwarder ()) {
		LeaveForwarder ();
		IpxFwdInitialized = FALSE;
		while (InterlockedDecrement (&ClientCount)>=0) {
			KeWaitForSingleObject (&ClientsGoneEvent,
										Executive,
										KernelMode,
										FALSE,
										(PLARGE_INTEGER)&WaitTimeout);
			InterlockedIncrement (&ClientCount);
			IpxFwdDbgPrint(DBG_IOCTLS, DBG_ERROR,
					("IpxFwd: Waiting for all clients (%ld) to exit.\n",
					ClientCount));
		}
		DoStop ();
	}

	UnbindFromIpxDriver (KernelMode);
    IoDeleteDevice (DriverObject->DeviceObject);
}



/*++
	D o S t a r t

Routine Description:
	Initializes all driver components and binds to IPX
	stack driver at strat up

Arguments:
	RouteHashTableSize	- size of route hash table
	thisMachineOnly		- whether to forward dialin client packets
							to other dests on the net

Return Value:
	STATUS_SUCCESS - initialization succeded
	STATUS_UNSUCCESSFULL - failure

--*/
NTSTATUS
DoStart (
	IN ULONG	RouteHashTableSize,
	IN BOOLEAN	thisMachineOnly
	) {
	NTSTATUS		status;

	InitializeConnectionQueues ();
	RouteHashSize = RouteHashTableSize;
	status = CreateTables ();
	if (NT_SUCCESS (status)) {
		InitializePacketAllocator ();
		InitializeNetbiosQueue ();
		InitializeRecvQueue ();
		InitializeSendQueue ();
		MeasuringPerformance = FALSE;
		KeInitializeSpinLock (&PerfCounterLock);
		ThisMachineOnly = thisMachineOnly;

		return STATUS_SUCCESS;
	}
	return status;
}

/*++
	D o S t o p

Routine Description:
	Cleans up allocated resources and unbinds from IPX stack
	driver when forwarder is stopped

Arguments:
	None

Return Value:
	STATUS_SUCCESS - cleanup succeded

--*/
NTSTATUS
DoStop (
	void
	) {
	if (FilterFile!=NULL) {
		UnbindFilterDriver ();
		FilterFile = NULL;
	}
	DeleteSendQueue ();
	DeleteRecvQueue ();
	DeleteNetbiosQueue ();
	DeleteTables ();	// Unbinds all bound interfaces
	if (WanPacketListId!=-1) {
		DeregisterPacketConsumer (WanPacketListId);
		WanPacketListId = -1;
	}
	DeletePacketAllocator ();
	return STATUS_SUCCESS;
}

/*++
	D o S e t R o u t e s

Routine Description:
	Updates route table with supplied routes

Arguments:
	routeArray - array of routes to add/de;ete/update
	nRoutes		- number of routes in the array
	nProcessed	- number of routes that were processed successfully

Return Value:
	STATUS_SUCCESS - all routes were processed ok
	error status - reason of failure for the first unprocessed route

--*/
NTSTATUS
DoSetRoutes (
	IN PFWD_ROUTE_SET_PARAMS	routeArray,
	IN ULONG				nRoutes,
	OUT PULONG				nProcessed
	) {
	NTSTATUS	status=STATUS_SUCCESS;
	UINT		i;

	for (i=0; i<nRoutes; i++, routeArray++) {
		switch (routeArray->Action) {
		case FWD_ADD_ROUTE:
			status = AddRoute (routeArray->Network,
									routeArray->NextHopAddress,
									routeArray->TickCount,
									routeArray->HopCount,
									routeArray->InterfaceIndex);
			break;
		case FWD_DELETE_ROUTE:
			status = DeleteRoute (routeArray->Network);
			break;
		case FWD_UPDATE_ROUTE:
			status = UpdateRoute (routeArray->Network,
									routeArray->NextHopAddress,
									routeArray->TickCount,
									routeArray->HopCount,
									routeArray->InterfaceIndex);
			break;
		default:
			status = STATUS_INVALID_PARAMETER;
			break;
		}
		if (!NT_SUCCESS (status))
			break;
	}
	*nProcessed = i;
	return status;
}


/*++
	D o S e t N b N a m e s

Routine Description:
	Sets static Netbios Names on the interface

Arguments:
	InterfaceIndex - index oc interface on which to set names
	Count			- number of names to set
	Names			- array of netbios names

Return Value:
	STATUS_SUCCESS - names were set OK
	STATUS_UNSUCCESSFULL - interface does not exist
	STATUS_INSUFFICIENT_RESOURCES - not enough resources to complete
							the operation

--*/
NTSTATUS
DoSetNbNames (
	IN ULONG			InterfaceIndex,
	IN ULONG			Count,
	IN PFWD_NB_NAME		Names
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;
	PNB_ROUTE		nbRoutes;
	NTSTATUS		status=STATUS_SUCCESS;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_NBRoutes!=NULL) {
			DeleteNBRoutes (ifCB->ICB_NBRoutes, ifCB->ICB_NBRouteCount);
			ifCB->ICB_NBRoutes = NULL;
			ifCB->ICB_NBRouteCount = 0;
		}
		if (Count>0) {
			status = AddNBRoutes (ifCB, Names, Count, &nbRoutes);
			if (NT_SUCCESS (status)) {
				ifCB->ICB_NBRoutes = nbRoutes;
				ifCB->ICB_NBRouteCount = Count;
			}
		}
		ReleaseInterfaceReference (ifCB);
	}
	else
		status = STATUS_UNSUCCESSFUL;

	return status;
}


/*++
	D o G e t N b N a m e s

Routine Description:
	Gets all static Netbios Names on the interface

Arguments:
	InterfaceIndex - index of interface from which to get names
	ArraySize - on input: size of the buffer to put names into
				on output: size of data put into the array
	Names			- buffer to put names into names, if buffer
				is to small to hold all names, this orutine stuffs
				total number of names into the first ULONG in the
				array (this is the only way to return in to the
				caller through the IOCTL interface)

Return Value:
	STATUS_SUCCESS - names were copied into the array
	STATUS_UNSUCCESSFULL - interface does not exist
	STATUS_BUFFER_OVERFLOW - buffer is too small to copy all the
				names, number of names are in the first ULONG of
				the buffer

--*/
NTSTATUS
DoGetNbNames (
	IN ULONG			InterfaceIndex,
	IN OUT ULONG        *ArraySize,
	OUT ULONG			*TotalCount,
	OUT PFWD_NB_NAME	Names
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;
	NTSTATUS		status=STATUS_SUCCESS;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_NBRoutes!=NULL) {
			ULONG			i;
			PFWD_NB_NAME	nameLM = Names+(*ArraySize/sizeof(FWD_NB_NAME));
			for (i=0; (i<ifCB->ICB_NBRouteCount)&&(Names<nameLM); i++, Names++)
				NB_NAME_CPY (Names,	&ifCB->ICB_NBRoutes[i].NBR_Name);
			*ArraySize = sizeof (FWD_NB_NAME)*i;
			*TotalCount = ifCB->ICB_NBRouteCount;
		}
		else {
			*ArraySize = 0;
			*TotalCount = 0;
		}
		ReleaseInterfaceReference (ifCB);
	}
	else
		status = STATUS_UNSUCCESSFUL;

	return status;
}


/*++
	D o S e t I n t e r f a c e

Routine Description:
	Sets interface configurable parameters

Arguments:
	InterfaceIndex - index of interface to set
	NetbiosAccept	- whether to accept nb packets on the interface
	NetbiosDeliver - whether to deliver nb packets on the interface

Return Value:
	STATUS_SUCCESS - interface was set OK
	STATUS_UNSUCCESSFULL - interface does not exist

--*/
NTSTATUS
DoSetInterface (
	IN ULONG		InterfaceIndex,
	IN BOOLEAN		NetbiosAccept,
	IN UCHAR		NetbiosDeliver
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
		ifCB->ICB_NetbiosAccept = NetbiosAccept;
		ifCB->ICB_NetbiosDeliver = NetbiosDeliver;
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}


/*++
	D o G e t I n t e r f a c e

Routine Description:
	Gets interface configurable parameters and statistics

Arguments:
	InterfaceIndex - index of interface to query
	stats			- interface statistics
	NetbiosAccept	- whether nb packets accepter on the interface
	NetbiosDeliver - whether nb packets delivered on the interface

Return Value:
	STATUS_SUCCESS - interface data was queried OK
	STATUS_UNSUCCESSFULL - interface does not exist

--*/
NTSTATUS
DoGetInterface (
	IN ULONG			InterfaceIndex,
	OUT PFWD_IF_STATS	stats,
	OUT BOOLEAN			*NetbiosAccept,
	OUT UCHAR			*NetbiosDeliver
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		*NetbiosAccept = ifCB->ICB_NetbiosAccept;
		*NetbiosDeliver = ifCB->ICB_NetbiosDeliver;
		IF_STATS_CPY (stats, &ifCB->ICB_Stats);
		if (!IS_IF_ENABLED(ifCB))
			stats->OperationalState = FWD_OPER_STATE_DOWN;
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}

/*++
	D o B i n d I n t e r f a c e

Routine Description:
	Binds interface to the specified adapter and sets binding
	parameters

Arguments:
	InterfaceIndex - index of interface to bind
	info			- binding info

Return Value:
	STATUS_SUCCESS - interface was bound OK
	STATUS_UNSUCCESSFULL - interface does not exist or could not be
							bound
--*/
NTSTATUS
DoBindInterface (
	IN ULONG					InterfaceIndex,
	IN PFWD_ADAPTER_BINDING_INFO	info
	) {
	PINTERFACE_CB	ifCB;
	NTSTATUS		status;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_InterfaceType==FWD_IF_PERMANENT)
			status = BindInterface (ifCB,
									(USHORT)info->AdapterIndex,
									info->MaxPacketSize,
									info->Network,
									info->LocalNode,
									info->RemoteNode);
		else
			status = STATUS_SUCCESS;
		ReleaseInterfaceReference (ifCB);
		return status;
	}
	else
		return STATUS_UNSUCCESSFUL;
}


/*++
	D o U n b i n d I n t e r f a c e

Routine Description:
	Unbinds interface from the adapter and invalidates binding
	parameters

Arguments:
	InterfaceIndex - index of interface to unbind

Return Value:
	STATUS_SUCCESS - interface was unbound OK
	STATUS_UNSUCCESSFULL - interface does not exist
--*/
NTSTATUS
DoUnbindInterface (
	IN ULONG					InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		if (ifCB->ICB_InterfaceType==FWD_IF_PERMANENT)
			UnbindInterface (ifCB);

		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}

/*++
	D o D i s a b l e I n t e r f a c e

Routine Description:
	Disables all packet traffic through the interface

Arguments:
	InterfaceIndex - index of interface to disable

Return Value:
	STATUS_SUCCESS - interface was disabled OK
	STATUS_UNSUCCESSFULL - interface does not exist
--*/
NTSTATUS
DoDisableInterface (
	IN ULONG					InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		KIRQL	oldIRQL;
		KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
		if (IS_IF_ENABLED (ifCB)) {
			SET_IF_DISABLED (ifCB);
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
			if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
				ProcessInternalQueue (ifCB);
				ProcessExternalQueue (ifCB);
			}
		}
		else
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}


/*++
	D o E n a b l e I n t e r f a c e

Routine Description:
	Enables all packet traffic through the interface

Arguments:
	InterfaceIndex - index of interface to enable

Return Value:
	STATUS_SUCCESS - interface was disabled OK
	STATUS_UNSUCCESSFULL - interface does not exist
--*/
NTSTATUS
DoEnableInterface (
	IN ULONG					InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;

	ifCB = GetInterfaceReference (InterfaceIndex);
	if (ifCB!=NULL) {
		SET_IF_ENABLED (ifCB);
		ReleaseInterfaceReference (ifCB);
		return STATUS_SUCCESS;
	}
	else
		return STATUS_UNSUCCESSFUL;
}



/*++
	I p x F w d C a n c e l

Routine Description:
	Cancels specified IRP

Arguments:
	DeviceObject	- forwarder device object
	irp				- irp to cancel

Return Value:
	None
--*/
VOID
IpxFwdCancel (
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				irp
	) {
    RemoveEntryList (&irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock (irp->CancelIrql);

    irp->IoStatus.Information = 0;
    irp->IoStatus.Status = STATUS_CANCELLED;
    IpxFwdDbgPrint(DBG_IOCTLS, DBG_WARNING, ("IpxFwd: completing cancelled irp.\n"));
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}

/*++
	D o G e t P e r f C o u n t e r s

Routine Description:
	Gets performance counters

Arguments:
	perfParams	- buffer ot pu counters into

Return Value:
	STATUS_SUCCESS - counter were copied ok
	STATUS_UNSUCCESSFULL - performance measurement were not enabled
--*/
NTSTATUS
DoGetPerfCounters (
	OUT PFWD_PERFORMANCE_PARAMS	perfParams,
	OUT ULONG* pulSize
	) {
	LONGLONG	lTotalPacketProcessingTime;
	LONGLONG	lMaxPacketProcessingTime;
	LONG		lPacketCounter;
	LONGLONG	lTotalNbPacketProcessingTime;
	LONGLONG	lMaxNbPacketProcessingTime;
	LONG		lNbPacketCounter;
	KIRQL		oldIRQL;
	
	if (!MeasuringPerformance)
		return STATUS_UNSUCCESSFUL;

	KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
	*perfParams = PerfBlock;
	memset (&PerfBlock, 0, sizeof (PerfBlock));
	KeReleaseSpinLock (&PerfCounterLock, oldIRQL);

	*pulSize = sizeof(PerfBlock);
	
	return STATUS_SUCCESS;
}


BOOLEAN
DoLeaveForwarder (
	VOID
	) {
	return LeaveForwarder () != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\fwddefs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\fwddefs.h

Abstract:
	IPX Forwarder driver constants and general macro definitions

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_FWDDEFS_
#define _IPXFWD_FWDDEFS_


// Forwarder tag used in memory allocations
#define FWD_POOL_TAG					'wFwN'

//*** Offsets into the IPX header
#define IPXH_HDRSIZE	    30	    // Size of the IPX header
#define IPXH_CHECKSUM	    0	    // Checksum
#define IPXH_LENGTH			2	    // Length
#define IPXH_XPORTCTL	    4	    // Transport Control
#define IPXH_PKTTYPE	    5	    // Packet Type
#define IPXH_DESTADDR	    6	    // Dest. Address (Total)
#define IPXH_DESTNET	    6	    // Dest. Network Address
#define IPXH_DESTNODE	    10	    // Dest. Node Address
#define IPXH_DESTSOCK	    16	    // Dest. Socket Number
#define IPXH_SRCADDR	    18	    // Source Address (Total)
#define IPXH_SRCNET			18	    // Source Network Address
#define IPXH_SRCNODE	    22	    // Source Node Address
#define IPXH_SRCSOCK	    28	    // Source Socket Number

//*** Packet Types we care about
#define IPX_NETBIOS_TYPE    20	   // Netbios propagated packet

//*** Socket Numbers we care about
#define IPX_NETBIOS_SOCKET  ((USHORT)0x0455)
#define IPX_SAP_SOCKET		((USHORT)0x0452)
#define IPX_SMB_NAME_SOCKET	((USHORT)0x0551)

//*** maximum nr of hops for a normal packet ***
#define IPX_MAX_HOPS	    16

//*** offsets into the netbios name frames ***
#define NB_NAME_TYPE_FLAG				62
#define NB_DATA_STREAM_TYPE2			63
#define NB_NAME							64
#define NB_TOTAL_DATA_LENGTH			80
// *** offsets into smb name claim/query frames
#define SMB_OPERATION					62
#define SMB_NAME_TYPE					63
#define SMB_MESSAGE_IF					64
#define SMB_NAME						66


// Some commonly used macros
#define IPX_NODE_CPY(dst,src) memcpy(dst,src,6)
#define IPX_NODE_CMP(node1,node2) memcmp(node1,node2,6)

#define IPX_NET_CPY(dst,src) memcpy(dst,src,4)
#define IPX_NET_CMP(net1,net2) memcmp(net1,net2,4)

#define NB_NAME_CPY(dst,src) strncpy((char *)dst,(char *)src,16)
#define NB_NAME_CMP(name1,name2) strncmp((char *)name1,(char *)name2,16)

// Make sure the structure is copied with DWORD granularity
#define IF_STATS_CPY(dst,src) \
		(dst)->OperationalState	= (src)->OperationalState;	\
		(dst)->MaxPacketSize	= (src)->MaxPacketSize;		\
		(dst)->InHdrErrors		= (src)->InHdrErrors;		\
		(dst)->InFiltered		= (src)->InFiltered;		\
		(dst)->InNoRoutes		= (src)->InNoRoutes;		\
		(dst)->InDiscards		= (src)->InDiscards;		\
		(dst)->InDelivers		= (src)->InDelivers;		\
		(dst)->OutFiltered		= (src)->OutFiltered;		\
		(dst)->OutDiscards		= (src)->OutDiscards;		\
		(dst)->OutDelivers		= (src)->OutDelivers;		\
		(dst)->NetbiosReceived	= (src)->NetbiosReceived;	\
		(dst)->NetbiosSent		= (src)->NetbiosSent;

// Extensions to list macros
#define InitializeListEntry(entry) InitializeListHead(entry)
#define IsListEntry(entry) IsListEmpty(entry)
#define IsSingleEntry(head) ((head)->Flink==(head)->Blink)

// Conversions from/to on-the-wire format
#define GETUSHORT(src) (			\
	(USHORT)(						\
		(((UCHAR *)src)[0]<<8)		\
		+ (((UCHAR *)src)[1])		\
	)								\
)

#define GETULONG(src) (				\
	(ULONG)(						\
		(((UCHAR *)src)[0]<<24)		\
		+ (((UCHAR *)src)[1]<<16)	\
		+ (((UCHAR *)src)[2]<<8)	\
		+ (((UCHAR *)src)[3])		\
	)								\
)

#define PUTUSHORT(src,dst) {				\
	((UCHAR *)dst)[0] = ((UCHAR)(src>>8));	\
	((UCHAR *)dst)[1] = ((UCHAR)src);		\
}

#define PUTULONG(src,dst) {					\
	((UCHAR *)dst)[0] = ((UCHAR)(src>>24));	\
	((UCHAR *)dst)[1] = ((UCHAR)(src>>16));	\
	((UCHAR *)dst)[2] = ((UCHAR)(src>>8));	\
	((UCHAR *)dst)[3] = ((UCHAR)src);		\
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\filterif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\filterif.h

Abstract:
    IPX Forwarder interface with filter driver


Author:

    Vadim Eydelman

Revision History:

--*/


#ifndef _IPXFWD_FILTERIF_
#define _IPXFWD_FILTERIF_
	// Filter driver entry points
extern IPX_FLT_BIND_INPUT FltBindInput;

	// Macros to improve performance when filter driver
	// is not bound or has not associated its contexts
	// with interfaces of interest
#define FltFilter(hdr,hdrSize,inContext,outContext)	(			\
	((FltBindInput.FilterHandler==NULL)							\
			|| ((inContext==NO_FILTER_CONTEXT)					\
					&&(outContext==NO_FILTER_CONTEXT)))			\
		? FILTER_PERMIT											\
		: DoFilter (hdr,hdrSize,inContext,outContext)			\
)

#define FltInterfaceDeleted(ifCB)	{									\
	if ((FltBindInput.InterfaceDeletedHandler!=NULL)					\
			&& ((ifCB->ICB_FilterInContext!=NO_FILTER_CONTEXT)			\
				||(ifCB->ICB_FilterOutContext!=NO_FILTER_CONTEXT)))		\
		DoInterfaceDeleted (ifCB);										\
}

/*++
	B i n d F i l t e r D r i v e r

Routine Description:
	Exchanges entry points with filter driver
Arguments:
	bindInput	- filter driver entry points
	bindOutput	- forwarder driver entry points
Return Value:
	None
--*/
VOID
BindFilterDriver (
	IN PIPX_FLT_BIND_INPUT		bindInput,
	OUT PIPX_FLT_BIND_OUTPUT	bindOutput
	);

/*++
	U n b i n d F i l t e r D r i v e r

Routine Description:
	Resets locally stored filter driver entry points
	and resets filter driver contexts on all interfaces
Arguments:
	None
Return Value:
	None
--*/
VOID
UnbindFilterDriver (
	VOID
	);


/*++
	D o F i l t e r

Routine Description:
	
	Calls filter driver entry point while holding reader access
	to interface contexts

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT	- packet should be passed on by the forwarder
	FILTER_DENY		- packet should be dropped

--*/
FILTER_ACTION
DoFilter (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContex
	);

/*++
	D o I n t e r f a c e D e l e t e d

Routine Description:
	Resets interface contexts and calls filter dirver entry point
	making sure that all no one holds reader access to filter driver
	interface contexts
Arguments:
	ifCB	 - interface to be deleted
Return Value:
	None

--*/
VOID
DoInterfaceDeleted (
	PINTERFACE_CB	ifCB
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\ipxbind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ipxbind.c

Abstract:
    IPX Forwarder Driver interface with IPX stack driver


Author:

    Vadim Eydelman

Revision History:

--*/

#include    "precomp.h"


// global handle of the IPX driver
HANDLE					HdlIpxFile;


// Buffer for IPX binding output structure
PIPX_INTERNAL_BIND_RIP_OUTPUT	IPXBindOutput=NULL;

NTSTATUS
IpxFwdFindRoute (
	IN  PUCHAR					Network,
	IN  PUCHAR					Node,
	OUT PIPX_FIND_ROUTE_REQUEST	RouteEntry
	);

/*++
*******************************************************************
    B i n d T o I p x D r i v e r

Routine Description:
	Exchanges binding information with IPX stack driver
Arguments:
	None
Return Value:
	STATUS_SUCCESS - exchange was done OK
	STATUS_INSUFFICIENT_RESOURCES - could not allocate buffers for
									info exchange
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindToIpxDriver (
	KPROCESSOR_MODE requestorMode
	) {
    NTSTATUS					status;
    IO_STATUS_BLOCK				IoStatusBlock;
    OBJECT_ATTRIBUTES			ObjectAttributes;
    PIPX_INTERNAL_BIND_INPUT	bip;
	UNICODE_STRING				UstrIpxFileName;
	PWSTR						WstrIpxFileName;

	ASSERT (IPXBindOutput==NULL);

    // Read Ipx exported device name from the registry
    status = ReadIpxDeviceName (&WstrIpxFileName);
	if (!NT_SUCCESS (status))
		return status;

	RtlInitUnicodeString (&UstrIpxFileName, WstrIpxFileName);
	InitializeObjectAttributes(
				&ObjectAttributes,
				&UstrIpxFileName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL
				);

	if (requestorMode==UserMode)
		status = ZwCreateFile(&HdlIpxFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);
	else
		status = NtCreateFile(&HdlIpxFile,
							SYNCHRONIZE | GENERIC_READ,
							&ObjectAttributes,
							&IoStatusBlock,
							NULL,
							FILE_ATTRIBUTE_NORMAL,
							FILE_SHARE_READ | FILE_SHARE_WRITE,
							FILE_OPEN,
							FILE_SYNCHRONOUS_IO_NONALERT,
							NULL,
							0L);

	if (!NT_SUCCESS(status)) {
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			("IpxFwd: Open of the IPX driver failed with %lx\n", status));
		return status;
		}

	IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
			 ("IpxFwd: Open of the IPX driver was successful.\n"));

	// First, send a IOCTL to find out how much data we need to allocate
	if ((bip = ExAllocatePoolWithTag (
					PagedPool,
					sizeof(IPX_INTERNAL_BIND_INPUT),
					FWD_POOL_TAG)) == NULL) {

		if (ExGetPreviousMode()!=KernelMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			 ("IpxFwd: Could not allocate input binding buffer!\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    //
    // Zero out the memory so that there are no garbage pointers.
    // - ShreeM
    //
    RtlZeroMemory(bip, sizeof(IPX_INTERNAL_BIND_INPUT));

	// fill in our bind data
	// bip->Version = 1;
	bip->Version = ISN_VERSION;
	bip->Identifier = IDENTIFIER_RIP;
	bip->BroadcastEnable = TRUE;
	bip->LookaheadRequired = IPXH_HDRSIZE;
	bip->ProtocolOptions = 0;
	bip->ReceiveHandler = IpxFwdReceive;
	bip->ReceiveCompleteHandler = IpxFwdReceiveComplete;
	bip->SendCompleteHandler = IpxFwdSendComplete;
	bip->TransferDataCompleteHandler = IpxFwdTransferDataComplete;
	bip->FindRouteCompleteHandler = NULL;
	bip->LineUpHandler = IpxFwdLineUp;
	bip->LineDownHandler = IpxFwdLineDown;
	bip->InternalSendHandler = IpxFwdInternalSend;
	bip->FindRouteHandler = IpxFwdFindRoute;
	bip->InternalReceiveHandler = IpxFwdInternalReceive;
//	bip->RipParameters = GlobalWanNetwork ? IPX_RIP_PARAM_GLOBAL_NETWORK : 0;


	if (requestorMode==UserMode)
		status = ZwDeviceIoControlFile(
						HdlIpxFile,		    // HANDLE to File
						NULL,			    // HANDLE to Event
						NULL,			    // ApcRoutine
						NULL,			    // ApcContext
						&IoStatusBlock,	    // IO_STATUS_BLOCK
						IOCTL_IPX_INTERNAL_BIND,	 // IoControlCode
						bip,			    // Input Buffer
						sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
						NULL,			    // Output Buffer
						0);			    // Output Buffer Length
	else
		status = NtDeviceIoControlFile(
						HdlIpxFile,		    // HANDLE to File
						NULL,			    // HANDLE to Event
						NULL,			    // ApcRoutine
						NULL,			    // ApcContext
						&IoStatusBlock,	    // IO_STATUS_BLOCK
						IOCTL_IPX_INTERNAL_BIND,	 // IoControlCode
						bip,			    // Input Buffer
						sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
						NULL,			    // Output Buffer
						0);			    // Output Buffer Length


	if (status == STATUS_PENDING) {
		if (requestorMode==UserMode)
			status = ZwWaitForSingleObject(
						HdlIpxFile,
						FALSE,
						NULL);
		else
			status = NtWaitForSingleObject(
						HdlIpxFile,
						FALSE,
						NULL);
		if (NT_SUCCESS(status))
			status = IoStatusBlock.Status;
	}

	if (status != STATUS_BUFFER_TOO_SMALL) {
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			  ("IpxFwd: Ioctl to the IPX driver failed with %lx\n", status));

		ExFreePool(bip);
		if (requestorMode==UserMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		return STATUS_INVALID_PARAMETER;
	}

	if ((IPXBindOutput = (PIPX_INTERNAL_BIND_RIP_OUTPUT)
				ExAllocatePoolWithTag(NonPagedPool,
					(ULONG)IoStatusBlock.Information,
					FWD_POOL_TAG)) == NULL) {

		ExFreePool(bip);
		if (requestorMode==UserMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			 ("IpxFwd: Could not allocate output binding buffer!\n"));
		return STATUS_INSUFFICIENT_RESOURCES;
	}


	if (requestorMode==UserMode)
		status = ZwDeviceIoControlFile(
					 HdlIpxFile,		    // HANDLE to File
					 NULL,			    // HANDLE to Event
					 NULL,			    // ApcRoutine
					 NULL,			    // ApcContext
					 &IoStatusBlock,	    // IO_STATUS_BLOCK
					 IOCTL_IPX_INTERNAL_BIND,   // IoControlCode
					 bip,			    // Input Buffer
					 sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
					 IPXBindOutput,		    // Output Buffer
					 (ULONG)IoStatusBlock.Information);  // Output Buffer Length
	else
		status = NtDeviceIoControlFile(
					 HdlIpxFile,		    // HANDLE to File
					 NULL,			    // HANDLE to Event
					 NULL,			    // ApcRoutine
					 NULL,			    // ApcContext
					 &IoStatusBlock,	    // IO_STATUS_BLOCK
					 IOCTL_IPX_INTERNAL_BIND,   // IoControlCode
					 bip,			    // Input Buffer
					 sizeof(IPX_INTERNAL_BIND_INPUT),// Input Buffer Length
					 IPXBindOutput,		    // Output Buffer
					 (ULONG)IoStatusBlock.Information);  // Output Buffer Length


	if (status == STATUS_PENDING) {
		if (requestorMode==UserMode)
			status = ZwWaitForSingleObject(
							HdlIpxFile,
							(BOOLEAN)FALSE,
							NULL);
		else
			status = NtWaitForSingleObject(
							HdlIpxFile,
							(BOOLEAN)FALSE,
							NULL);
		if (NT_SUCCESS(status))
			status = IoStatusBlock.Status;
		}

    if (!NT_SUCCESS (status)) {
		IpxFwdDbgPrint (DBG_IPXBIND, DBG_ERROR,
			  ("IpxFwd: Ioctl to the IPX driver failed with %lx\n", IoStatusBlock.Status));

		ExFreePool(bip);
		ExFreePool(IPXBindOutput);
		IPXBindOutput = NULL;
		if (requestorMode==UserMode)
			ZwClose (HdlIpxFile);
		else
			NtClose (HdlIpxFile);
		return status;
		}

    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
			 ("IpxFwd: Succesfuly bound to the IPX driver\n"));

    ExFreePool (bip);
	ExFreePool (WstrIpxFileName);

    return status;
}


/*++
*******************************************************************
    U n b i n d F r o m I p x D r i v e r

Routine Description:
	Closes connection to IPX stack driver
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
UnbindFromIpxDriver (
	KPROCESSOR_MODE requestorMode
	) {
		// Free binding output buffer and close driver handle
	ASSERT (IPXBindOutput!=NULL);
	ExFreePool (IPXBindOutput);
	IPXBindOutput = NULL;
    IpxFwdDbgPrint (DBG_IPXBIND, DBG_WARNING,
			 ("IpxFwd: Closing IPX driver handle\n"));
	if (requestorMode==UserMode)
		ZwClose (HdlIpxFile);
	else
		NtClose (HdlIpxFile);
}


/*++
*******************************************************************
	F w  F i n d R o u t e

Routine Description:
	This routine is provided by the Kernel Forwarder to find the route
	to a given node and network
Arguments:
	Network - the destination network
	Node - destination node
	RouteEntry - filled in by the Forwarder if a route exists
Return Value:
	STATUS_SUCCESS
	STATUS_NETWORK_UNREACHABLE - if the findroute failed
*******************************************************************
--*/
NTSTATUS
IpxFwdFindRoute (
	IN  PUCHAR					Network,
	IN  PUCHAR					Node,
	OUT PIPX_FIND_ROUTE_REQUEST	RouteEntry
	) {
	PINTERFACE_CB	ifCB;
	ULONG			net;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_NETWORK_UNREACHABLE;
	PFWD_ROUTE		fwRoute;

	if (!EnterForwarder ())
		return STATUS_UNSUCCESSFUL;

	net = GETULONG (Network);

	ifCB = FindDestination (net, Node, &fwRoute);
	if (ifCB!=NULL) {
		if (IS_IF_ENABLED(ifCB)) {
			KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
			switch (ifCB->ICB_Stats.OperationalState) {
			case FWD_OPER_STATE_UP:
				IPX_NET_CPY (&RouteEntry->Network, Network);
				if (fwRoute->FR_Network==ifCB->ICB_Network) {
					if (Node!=NULL) {
						IPX_NODE_CPY (RouteEntry->LocalTarget.MacAddress, Node);
					}
					else {
						IPX_NODE_CPY (RouteEntry->LocalTarget.MacAddress,
												BROADCAST_NODE);
					}
				}
				else {
					IPX_NODE_CPY (RouteEntry->LocalTarget.MacAddress,
											fwRoute->FR_NextHopAddress);
				}
                if (ifCB!=InternalInterface) {
				    ADAPTER_CONTEXT_TO_LOCAL_TARGET (
                                    ifCB->ICB_AdapterContext,
									&RouteEntry->LocalTarget);
                }
                else {
				    CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (
                                    VIRTUAL_NET_ADAPTER_CONTEXT,
									&RouteEntry->LocalTarget);
                }

                //
                // Fill in the hop count and tick count
                //
                RouteEntry->TickCount = fwRoute->FR_TickCount;
                RouteEntry->HopCount  = fwRoute->FR_HopCount;
                
				status = STATUS_SUCCESS;
				break;
			case FWD_OPER_STATE_SLEEPING:
				IPX_NODE_CPY (&RouteEntry->LocalTarget.MacAddress,
												fwRoute->FR_NextHopAddress);
				CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (DEMAND_DIAL_ADAPTER_CONTEXT,
												&RouteEntry->LocalTarget);
				status = STATUS_SUCCESS;

                //
                // Fill in the hop count and tick count
                //
                RouteEntry->TickCount = fwRoute->FR_TickCount;
                RouteEntry->HopCount  = fwRoute->FR_HopCount;
                
				
				break;
			case FWD_OPER_STATE_DOWN:
				status = STATUS_NETWORK_UNREACHABLE;
				break;
			default:
				ASSERTMSG ("Inavalid operational state", FALSE);
			}
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
	#if DBG
			if (Node!=NULL) {
				if (NT_SUCCESS (status)) {
					IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
						("IpxFwd: Found route for IPX driver:"
							" %08lX:%02X%02X%02X%02X%02X%02X"
							" -> %ld(%ld):%02X%02X%02X%02X%02X%02X\n",
							net, Node[0],Node[1],Node[2],Node[3],Node[4],Node[5],
							ifCB->ICB_Index, RouteEntry->LocalTarget.NicId,
								RouteEntry->LocalTarget.MacAddress[0],
								RouteEntry->LocalTarget.MacAddress[1],
								RouteEntry->LocalTarget.MacAddress[2],
								RouteEntry->LocalTarget.MacAddress[3],
								RouteEntry->LocalTarget.MacAddress[4],
								RouteEntry->LocalTarget.MacAddress[5]));
				}
				else {
					IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
						("IpxFwd: Network unreachable for:"
							" %08lX:%02X%02X%02X%02X%02X%02X -> %ld.\n",
							net, Node[0],Node[1],Node[2],Node[3],Node[4],Node[5],
							ifCB->ICB_Index));
				}
			}
			else {
				if (NT_SUCCESS (status)) {
					IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION,
						("IpxFwd: Found route for IPX driver:"
							" %08lX"
							" -> %ld(%ld):%02X%02X%02X%02X%02X%02X\n",
							net, ifCB->ICB_Index, RouteEntry->LocalTarget.NicId,
								RouteEntry->LocalTarget.MacAddress[0],
								RouteEntry->LocalTarget.MacAddress[1],
								RouteEntry->LocalTarget.MacAddress[2],
								RouteEntry->LocalTarget.MacAddress[3],
								RouteEntry->LocalTarget.MacAddress[4],
								RouteEntry->LocalTarget.MacAddress[5]));
				}
				else {
					IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
						("IpxFwd: Network unreachable for:"
							" %08lX -> %ld.\n", net));
				}
			}
	#endif
			ReleaseInterfaceReference (ifCB);
			ReleaseRouteReference (fwRoute);

		}
	}
	else {
#if DBG
		if (Node!=NULL) {
			IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
				("IpxFwd: No route for:"
					" %08lX:%02X%02X%02X%02X%02X%02X.\n",
					net, Node[0],Node[1],Node[2],Node[3],Node[4],Node[5]));
		}
		else {
			IpxFwdDbgPrint (DBG_IPXROUTE, DBG_WARNING,
				("IpxFwd: No route for: %08lX.\n", net));
		}
#endif
		status = STATUS_NETWORK_UNREACHABLE;
	}
	LeaveForwarder ();
	return status;
}
			


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\ipxbind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\ipxbind.h

Abstract:
    IPX Forwarder Driver interface with IPX stack driver


Author:

    Vadim Eydelman

Revision History:

--*/


#ifndef _IPXFWD_IPXBIND_
#define _IPXFWD_IPXBIND_

extern PIPX_INTERNAL_BIND_RIP_OUTPUT	IPXBindOutput;
#define IPXMacHeaderSize (IPXBindOutput->MacHeaderNeeded)
#define IPXOpenAdapterProc (IPXBindOutput->OpenAdapterHandler)
#define IPXCloseAdapterProc (IPXBindOutput->CloseAdapterHandler)
#define IPXInternalSendCompletProc (IPXBindOutput->InternalSendCompleteHandler)
#define IPXSendProc (IPXBindOutput->SendHandler)
#define IPXTransferData (IPXBindOutput->TransferDataHandler)


/*++
*******************************************************************
    B i n d T o I p x D r i v e r

Routine Description:
	Exchanges binding information with IPX stack driver
Arguments:
Return Value:
	STATUS_SUCCESS - exchange was done OK
	STATUS_INSUFFICIENT_RESOURCES - could not allocate buffers for
									info exchange
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindToIpxDriver (
	KPROCESSOR_MODE requestorMode
	);


/*++
*******************************************************************
    U n b i n d T o I p x D r i v e r

Routine Description:
	Closes connection to IPX stack driver
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
UnbindFromIpxDriver (
	KPROCESSOR_MODE requestorMode
	);


#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\lineind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\lineind.h

Abstract:
	Processing line indication (bind/unbind)


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_LINEIND_
#define _IPXFWD_LINEIND_

/*++
*******************************************************************
    B i n d I n t e r f a c e

Routine Description:
	Binds interface to physical adapter and exchanges contexts
	with IPX stack
Arguments:
	ifCB			- interface to bind
	NicId			- id of an adapter
	MaxPacketSize	- max size of packet allowed
	Network			- adapter network address
	LocalNode		- adapter local node address
	RemoteNode		- peer node address (for clients on global
						net)
Return Value:
	STATUS_SUCCESS - interface was bound OK
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindInterface (
	IN PINTERFACE_CB	ifCB,
	IN USHORT			NicId,
	IN ULONG			MaxPacketSize,
	IN ULONG			Network,
	IN PUCHAR			LocalNode,
	IN PUCHAR			RemoteNode
	);

/*++
*******************************************************************
    U n b i n d I n t e r f a c e

Routine Description:
	Unbinds interface from physical adapter and breaks connection
	with IPX stack
Arguments:
	ifCB			- interface to unbind
Return Value:
	None
*******************************************************************
--*/
VOID
UnbindInterface (
	PINTERFACE_CB	ifCB
	);

/*++
*******************************************************************
    F w L i n e U p

Routine Description:
	Process line up indication delivered by IPX stack
Arguments:
	NicId		- adapter ID on which connection was established
	LineInfo	- NDIS/IPX line information
	DeviceType	- medium specs
	ConfigurationData - IPX CP configuration data
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineUp (
	IN USHORT			NicId,
	IN PIPX_LINE_INFO	LineInfo,
	IN NDIS_MEDIUM		DeviceType,
	IN PVOID			ConfigurationData
	);

/*++
*******************************************************************
    F w L i n e D o w n

Routine Description:
	Process line down indication delivered by IPX stack
Arguments:
	NicId		- disconnected adapter ID 
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineDown (
	IN USHORT	NicId,
	IN ULONG_PTR Context
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\lineind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\lineind.c

Abstract:
	Processing line indication (bind/unbind)


Author:

    Vadim Eydelman

Revision History:

--*/

#include    "precomp.h"


/*++
*******************************************************************
    B i n d I n t e r f a c e

Routine Description:
	Binds interface to physical adapter and exchanges contexts
	with IPX stack
Arguments:
	ifCB			- interface to bind
	NicId			- id of an adapter
	MaxPacketSize	- max size of packet allowed
	Network			- adapter network address
	LocalNode		- adapter local node address
	RemoteNode		- peer node address (for clients on global
						net)
Return Value:
	STATUS_SUCCESS - interface was bound OK
	error status returned by IPX stack driver

*******************************************************************
--*/
NTSTATUS
BindInterface (
	IN PINTERFACE_CB	ifCB,
	IN USHORT			NicId,
	IN ULONG			MaxPacketSize,
	IN ULONG			Network,
	IN PUCHAR			LocalNode,
	IN PUCHAR			RemoteNode
	) {
	KIRQL				oldIRQL;
	NTSTATUS			status;
    NIC_HANDLE          NicHandle={0};
	
	KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
	if (ifCB->ICB_Stats.OperationalState!=FWD_OPER_STATE_UP) {
		switch (ifCB->ICB_InterfaceType) {
		case FWD_IF_PERMANENT:
			if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX)
				status = RegisterPacketConsumer (MaxPacketSize,
											&ifCB->ICB_PacketListId);
			else
				status = STATUS_SUCCESS;
			break;
		case FWD_IF_DEMAND_DIAL:
		case FWD_IF_LOCAL_WORKSTATION:
		case FWD_IF_REMOTE_WORKSTATION:
			if (IS_IF_CONNECTING (ifCB)) {
				SET_IF_NOT_CONNECTING (ifCB);
				DequeueConnectionRequest (ifCB);
			}
			status = STATUS_SUCCESS;
			break;
		default:
		    status = STATUS_INVALID_PARAMETER;
			ASSERTMSG ("Invalid interface type ", FALSE);
			break;
		}
		if (NT_SUCCESS (status)) {
			if (Network==GlobalNetwork) {
				ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
				IPX_NODE_CPY (ifCB->ICB_RemoteNode, RemoteNode);
				status = AddGlobalNetClient (ifCB);
				ASSERT (status==STATUS_SUCCESS);
			}
			KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
			
			if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX) {
                NIC_HANDLE_FROM_NIC(NicHandle, NicId);
				status = IPXOpenAdapterProc (NicHandle, (ULONG_PTR)ifCB,
										&ifCB->ICB_AdapterContext);
            }

			if (NT_SUCCESS (status)) {
				ifCB->ICB_Network = Network;
				IPX_NODE_CPY (ifCB->ICB_RemoteNode, RemoteNode);
				IPX_NODE_CPY (ifCB->ICB_LocalNode, LocalNode);
				if (ifCB->ICB_InterfaceType==FWD_IF_PERMANENT)
					ifCB->ICB_Stats.MaxPacketSize = MaxPacketSize;
				else
					ifCB->ICB_Stats.MaxPacketSize = WAN_PACKET_SIZE;
				ifCB->ICB_NicId = NicId;
				ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_UP;

				AcquireInterfaceReference (ifCB);
				IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION,
					("IpxFwd: Bound interface %ld (icb: %08lx):"
					" Nic-%d, Net-%08lx,"
					" LocalNode-%02x%02x%02x%02x%02x%02x,"
					" RemoteNode-%02x%02x%02x%02x%02x%02x.\n",
					ifCB->ICB_Index, ifCB, NicId, Network,
					LocalNode[0], LocalNode[1], LocalNode[2],
						LocalNode[3], LocalNode[4], LocalNode[5],
					RemoteNode[0], RemoteNode[1], RemoteNode[2],
						RemoteNode[3], RemoteNode[4], RemoteNode[5]));

				if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX) {
					ProcessInternalQueue (ifCB);
					ProcessExternalQueue (ifCB);
				}
				return STATUS_SUCCESS;
			}

			IpxFwdDbgPrint (DBG_LINEIND, DBG_ERROR,
					("IpxFwd: Could not open adapter %d to bind"
					" interface %ld (icb: %08lx)!\n",
					NicId, ifCB->ICB_Index, ifCB));

			KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
			if (Network==GlobalNetwork) {
				DeleteGlobalNetClient (ifCB);
			}

			switch (ifCB->ICB_InterfaceType) {
			case FWD_IF_PERMANENT:
				DeregisterPacketConsumer (ifCB->ICB_PacketListId);
				break;
			case FWD_IF_DEMAND_DIAL:
			case FWD_IF_LOCAL_WORKSTATION:
			case FWD_IF_REMOTE_WORKSTATION:
				break;
			}
		}
		ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
	
		ProcessInternalQueue (ifCB);
		ProcessExternalQueue (ifCB);
	}
	else {
		ASSERT (Network==ifCB->ICB_Network);
		ASSERT (NicId==(USHORT)ifCB->ICB_AdapterContext.NicId);
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		status = STATUS_SUCCESS; // Report success if already
								// connected
		IpxFwdDbgPrint (DBG_LINEIND, DBG_WARNING,
			("IpxFwd: Interface %ld (icb: %08lx) is already bound to Nic %d.\n",
			ifCB->ICB_Index, ifCB, NicId));
	}
	return status;
}


/*++
*******************************************************************
    U n b i n d I n t e r f a c e

Routine Description:
	Unbinds interface from physical adapter and breaks connection
	with IPX stack
Arguments:
	ifCB			- interface to unbind
Return Value:
	None
*******************************************************************
--*/
VOID
UnbindInterface (
	PINTERFACE_CB	ifCB
	) {
	KIRQL		oldIRQL;
	KeAcquireSpinLock (&ifCB->ICB_Lock, &oldIRQL);
	if (ifCB->ICB_Stats.OperationalState==FWD_OPER_STATE_UP) {
		switch (ifCB->ICB_InterfaceType) {
		case FWD_IF_PERMANENT:
			ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
			if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX)
				DeregisterPacketConsumer (ifCB->ICB_PacketListId);
			break;
		case FWD_IF_DEMAND_DIAL:
		case FWD_IF_LOCAL_WORKSTATION:
		case FWD_IF_REMOTE_WORKSTATION:
			ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_SLEEPING;
			KeQuerySystemTime ((PLARGE_INTEGER)&ifCB->ICB_DisconnectTime);
			break;
		default:
			ASSERTMSG ("Invalid interface type ", FALSE);
			break;
		}
		if (ifCB->ICB_CashedInterface!=NULL)
			ReleaseInterfaceReference (ifCB->ICB_CashedInterface);
		ifCB->ICB_CashedInterface = NULL;
		if (ifCB->ICB_CashedRoute!=NULL)
			ReleaseRouteReference (ifCB->ICB_CashedRoute);
		ifCB->ICB_CashedRoute = NULL;
		if (ifCB->ICB_Network==GlobalNetwork)
			DeleteGlobalNetClient (ifCB);
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);

		IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION,
			("IpxFwd: Unbinding interface %ld (icb: %08lx) from Nic %ld.\n",
			ifCB->ICB_Index, ifCB, ifCB->ICB_AdapterContext));
		if (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX) {
		    // [pmay].  Because of pnp, this interface may not need to have an
		    // adapter closed any more.  This is because nic id's get renumbered.
		    if (ifCB->ICB_NicId != INVALID_NIC_ID)
    			IPXCloseAdapterProc (ifCB->ICB_AdapterContext);
			ProcessInternalQueue (ifCB);
			ProcessExternalQueue (ifCB);
		}
		ReleaseInterfaceReference (ifCB);
	}
	else {
		KeReleaseSpinLock (&ifCB->ICB_Lock, oldIRQL);
		IpxFwdDbgPrint (DBG_LINEIND, DBG_WARNING,
			("IpxFwd: Interface %ld (icb: %08lx) is already unbound.\n",
			ifCB->ICB_Index, ifCB));
	}
}



/*++
*******************************************************************
    F w L i n e U p

Routine Description:
	Process line up indication delivered by IPX stack
Arguments:
	NicId		- adapter ID on which connection was established
	LineInfo	- NDIS/IPX line information
	DeviceType	- medium specs
	ConfigurationData - IPX CP configuration data
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineUp (
	IN USHORT			NicId,
	IN PIPX_LINE_INFO	LineInfo,
	IN NDIS_MEDIUM		DeviceType,
	IN PVOID			ConfigurationData
	) {
	PINTERFACE_CB		ifCB;
	if (ConfigurationData==NULL)	// This is just an update for multilink
									// connections
		return;

    if (!EnterForwarder()) {
		return;
    }
	IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION, ("IpxFwd: FwdLineUp.\n"));

	ifCB = GetInterfaceReference (
		((PIPXCP_CONFIGURATION)ConfigurationData)->InterfaceIndex);
	if (ifCB!=NULL) {
		LONG	Net = GETULONG (((PIPXCP_CONFIGURATION)ConfigurationData)->Network);
		
		ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		ASSERT (ifCB->ICB_InterfaceType!=FWD_IF_PERMANENT);
		
		BindInterface (ifCB,
			NicId,
			LineInfo->MaximumPacketSize,
			Net,
			((PIPXCP_CONFIGURATION)ConfigurationData)->LocalNode,
			((PIPXCP_CONFIGURATION)ConfigurationData)->RemoteNode
			);
		ReleaseInterfaceReference (ifCB);
	}
	LeaveForwarder ();
}




/*++
*******************************************************************
    F w L i n e D o w n

Routine Description:
	Process line down indication delivered by IPX stack
Arguments:
	NicId		- disconnected adapter ID
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdLineDown (
	IN USHORT NicId,
	IN ULONG_PTR Context
	) {
	PINTERFACE_CB	ifCB;

    if (!EnterForwarder()) {
		return;
    }
	IpxFwdDbgPrint (DBG_LINEIND, DBG_INFORMATION, ("IpxFwd: FwdLineDown.\n"));


	ifCB = InterfaceContextToReference ((PVOID)Context, NicId);
	if (ifCB!=NULL) {
		ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		ASSERT (ifCB->ICB_InterfaceType!=FWD_IF_PERMANENT);
		UnbindInterface (ifCB);
		ReleaseInterfaceReference (ifCB);
	}
	LeaveForwarder ();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\netbios.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\netbios.c

Abstract:
	Netbios packet processing

Author:

    Vadim Eydelman

Revision History:

--*/
#include    "precomp.h"

LIST_ENTRY	NetbiosQueue;
KSPIN_LOCK	NetbiosQueueLock;
WORK_QUEUE_ITEM		NetbiosWorker;
BOOLEAN				NetbiosWorkerScheduled=FALSE;
ULONG				NetbiosPacketsQuota;
ULONG				MaxNetbiosPacketsQueued = DEF_MAX_NETBIOS_PACKETS_QUEUED;


/*++
*******************************************************************
    P r o c e s s N e t b i o s Q u e u e

Routine Description:
	Process packets in the netbios broadcast queue (sends them on
	all interfaces in sequence)
Arguments:
	Context - unused
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosQueue (
	PVOID		Context
	) {
	KIRQL			oldIRQL;
	LIST_ENTRY		tempQueue;

	KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);
		// Check if there is something in the queue
	if (!IsListEmpty (&NetbiosQueue)) {
			// Move the queue to local variable
		InsertHeadList (&NetbiosQueue, &tempQueue);
		RemoveEntryList (&NetbiosQueue);
		InitializeListHead (&NetbiosQueue);

		KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);
		do {
			PLIST_ENTRY		cur;
			PPACKET_TAG		pktTag;

			cur = RemoveHeadList (&tempQueue);
			pktTag = CONTAINING_RECORD (cur, PACKET_TAG, PT_QueueLink);
				// Check if this packet has to be sent on other
				// interfaces
			if (!(pktTag->PT_Flags&PT_NB_DESTROY)) {
				PINTERFACE_CB	dstIf = pktTag->PT_InterfaceReference;
				PUCHAR			dataPtr = pktTag->PT_Data;
				UINT			rtCount = *(dataPtr+IPXH_XPORTCTL);
				PUCHAR			netListPtr;
				UINT			i;
					
				if (dstIf==NULL) {
						// This is a brand new packet: not sent on any
						// interface yet
					USHORT dstSock = GETUSHORT (dataPtr+IPXH_DESTSOCK);
						// Check if we have a static route for this name
						// (offset to name depends on packet dest socket)
					if (dstSock==IPX_NETBIOS_SOCKET)
						dstIf = FindNBDestination (dataPtr+NB_NAME);
					else if (dstSock==IPX_SMB_NAME_SOCKET)
						dstIf = FindNBDestination (dataPtr+SMB_NAME);
					else
						dstIf = NULL;

					if (dstIf!=NULL) {
							// Static route found, make sure this packet
							// won't be sent on any other interface
						pktTag->PT_Flags |= PT_NB_DESTROY;
						InterlockedIncrement (&NetbiosPacketsQuota);
							// Make sure the packet has not traversed
							// this network already
						for (i=0, netListPtr=dataPtr+IPXH_HDRSIZE; i<rtCount; i++,netListPtr+=4) {
							if (GETULONG (netListPtr)==dstIf->ICB_Network)
								break;
						}
							// Make sure we are allowed to send on this
							// interface
						if ((dstIf!=InternalInterface)
							&& (i==rtCount)	// Has not already traversed
											// this network
							&& IS_IF_ENABLED (dstIf)
							&& ((dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL)
								|| (dstIf->ICB_NetbiosDeliver
										==FWD_NB_DELIVER_STATIC)
								|| ((dstIf->ICB_NetbiosDeliver
										==FWD_NB_DELIVER_IF_UP)
									&& (dstIf->ICB_Stats.OperationalState
											==FWD_OPER_STATE_UP)))) {
							NOTHING;
						}
						else {
							// We have static route, but can't send it,
							// no point to propagate in on other interfaces
							// as well
							ReleaseInterfaceReference (dstIf);
							dstIf = NULL;
							goto FreePacket;
						}
					}
					else { // no static route
						goto FindNextInterface;
					}
				}
				else {	// not a brand new packet (already sent on some 
						// interfaces)

				FindNextInterface:

						// Loop through the interface list till we find
						// the one on which we can send
					while ((dstIf=GetNextInterfaceReference (dstIf))!=NULL) {
							// Check if we allowed to send on this interface
						if (IS_IF_ENABLED (dstIf)
							&& ((dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL)
								|| ((dstIf->ICB_NetbiosDeliver
											==FWD_NB_DELIVER_IF_UP)
									&& (dstIf->ICB_Stats.OperationalState
											==FWD_OPER_STATE_UP)))) {
								// Make sure the packet has not traversed
								// this network already
							for (i=0, netListPtr=dataPtr+IPXH_HDRSIZE; i<rtCount; i++,netListPtr+=4) {
								if (GETULONG (netListPtr)==dstIf->ICB_Network)
									break;
							}
								// Network was not in the list
							if (i==rtCount)
								break;
						}
					}
				}
					// Save the destination interface in the packet
				pktTag->PT_InterfaceReference = dstIf;
					// Go ahead and send if we have a valid destination
				if (dstIf!=NULL) {
					SendPacket (dstIf, pktTag);
						// The rest does not apply: if the packet was sent or
						// failed, it will be queued back to NetbiosQueue;
						// if it was queued to interface to be connected,
						// a copy of it will be queued to NetbiosQueue
					continue;
				}
				// else no more destinations to send this packet on
			}
			else { // Packet has to be destroyed
				if (pktTag->PT_InterfaceReference!=NULL)
					ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
			}

		FreePacket:
			IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
				("IpxFwd: No more interfaces for nb packet %08lx.\n",
				pktTag));
			if (MeasuringPerformance
					&& (pktTag->PT_PerfCounter!=0)) {
				LARGE_INTEGER	PerfCounter = KeQueryPerformanceCounter (NULL);
				PerfCounter.QuadPart -= pktTag->PT_PerfCounter;
				KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
				PerfBlock.TotalNbPacketProcessingTime += PerfCounter.QuadPart;
				PerfBlock.NbPacketCounter += 1;
				if (PerfBlock.MaxNbPacketProcessingTime < PerfCounter.QuadPart)
					PerfBlock.MaxNbPacketProcessingTime = PerfCounter.QuadPart;
				KeReleaseSpinLock (&PerfCounterLock, oldIRQL);
				}
			if (!(pktTag->PT_Flags&PT_NB_DESTROY))
				InterlockedIncrement (&NetbiosPacketsQuota);
			FreePacket (pktTag);
		} while (!IsListEmpty (&tempQueue));

		KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);
		if (IsListEmpty (&NetbiosQueue)
				|| !EnterForwarder ()) {
			NetbiosWorkerScheduled = FALSE;
		}
		else {
			ExQueueWorkItem (&NetbiosWorker, DelayedWorkQueue);
		}
	}
	KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);
	LeaveForwarder ();
}		

/*++
*******************************************************************
    P r o c e s s N e t b i o s P a c k e t

Routine Description:
	Processes received netbios broadcast packet (checks network list
	and source filter, updates input statistics)
Arguments:
	srcIf - interfae on which packet was received
	pktTag - netbios packet
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosPacket (
	PINTERFACE_CB	srcIf,
	PPACKET_TAG		pktTag
	) {
	PUCHAR			dataPtr, dataPtr2;
	UINT			rtCount;
	UINT			i, j;
	KIRQL			oldIRQL;
	ULONG           ulNetwork;


	dataPtr = pktTag->PT_Data;
	rtCount = *(dataPtr+IPXH_XPORTCTL);

    //
	// pmay: 264339: Make sure valid networks are listed
	// 
	// We used to only verify that the source network was not 
	// contained in the list.  Now, we verify that 0 and 0xfffffff
	// are also absent.
    // 
	for (i = 0, dataPtr += IPXH_HDRSIZE; i < rtCount; i++, dataPtr += 4) 
	{
	    ulNetwork = GETULONG (dataPtr);
	    
		if ((srcIf->ICB_Network == ulNetwork) ||
	        (ulNetwork == 0xffffffff)         ||
	        (ulNetwork == 0x0))
	    {
	        break;
	    }
	}

    // 
    // pmay: 272193
    //
    // nwlnknb on nt4 puts status bits into the first router slot in 
    // the type 20 payload.  As a consequence, the router has to 
    // ignore the first slot when validating the router table so that nt4 
    // client bcasts aren't dropped at the router.
    //
    if (rtCount == 0)
    {
        j = 1;
        dataPtr2 = dataPtr + 4;
    }
    else
    {
        j = i;
        dataPtr2 = dataPtr;
    }

    //
    // pmay: 264331
    //
    // Make sure the rest of the networks listed are zero
    //
	for (; j < 8; j++, dataPtr2 += 4)
	{
	    ulNetwork = GETULONG (dataPtr2);
	    
	    if (ulNetwork != 0x0)
	    {
	        break;
	    }
	}

	// We scaned the whole list and we haven't found it
	if ((i == rtCount) && (j == 8)) { 
        FILTER_ACTION   action;
        action = FltFilter (pktTag->PT_Data,
				            GETUSHORT (pktTag->PT_Data+IPXH_LENGTH),
				            srcIf->ICB_FilterInContext, NULL);
			// Apply the input filter
		if (action==FILTER_PERMIT) {
			InterlockedIncrement (&srcIf->ICB_Stats.NetbiosReceived);
			InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
			PUTULONG (srcIf->ICB_Network, dataPtr);
    		*(pktTag->PT_Data+IPXH_XPORTCTL) += 1;
			IPX_NODE_CPY (pktTag->PT_Target.MacAddress, BROADCAST_NODE);
				// Initialize the packet
			pktTag->PT_InterfaceReference = NULL;	// not yet sent on any
													// interfaces
			pktTag->PT_Flags = 0;					// No flags
			QueueNetbiosPacket (pktTag);
			IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
				("IpxFwd: Queued nb packet %08lx from if %ld.\n",
								pktTag, srcIf->ICB_Index));
		}
		else {
            ASSERT (action==FILTER_DENY_IN);
			IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
				("IpxFwd: Filtered out nb packet %08lx"
				" from if %ld.\n", pktTag, srcIf->ICB_Index));
			InterlockedIncrement (&NetbiosPacketsQuota);
			InterlockedIncrement (&srcIf->ICB_Stats.InFiltered);
			FreePacket (pktTag);
		}
	}
	else {
		IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
			("IpxFwd: Source net is already in nb packet %08lx"
			" from if %ld.\n", pktTag, srcIf->ICB_Index));
		InterlockedIncrement (&NetbiosPacketsQuota);
		InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
		FreePacket (pktTag);
	}
	ReleaseInterfaceReference (srcIf);

}


/*++
*******************************************************************
    D e l e t e N e t b i o s Q u e u e

Routine Description:
	Deletes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteNetbiosQueue (
	void
	) {
	while (!IsListEmpty (&NetbiosQueue)) {
		PPACKET_TAG pktTag = CONTAINING_RECORD (NetbiosQueue.Flink,
											PACKET_TAG,
											PT_QueueLink);
		RemoveEntryList (&pktTag->PT_QueueLink);
		if (pktTag->PT_InterfaceReference!=NULL) {
			ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
		}
		FreePacket (pktTag);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\packets.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\packets.c

Abstract:
    IPX Forwarder Driver packet allocator


Author:

    Vadim Eydelman

Revision History:

--*/

#include "precomp.h"

ULONG	RcvPktsPerSegment = DEF_RCV_PKTS_PER_SEGMENT;
ULONG	MaxRcvPktsPoolSize =0;
ULONG	RcvPktsPoolSize = 0;
KSPIN_LOCK	AllocatorLock;
const LONGLONG SegmentTimeout = -10i64*10000000i64;

SEGMENT_LIST ListEther={1500};
SEGMENT_LIST ListTR4={4500};
SEGMENT_LIST ListTR16={17986};

PSEGMENT_LIST	SegmentMap[FRAME_SIZE_VARIATIONS][FRAME_SIZE_VARIATIONS] = {
	{&ListEther, &ListEther, &ListEther},
	{&ListEther, &ListTR4, &ListTR4},
	{&ListEther, &ListTR4, &ListTR16}
};

VOID
AllocationWorker (
	PVOID		Context
	);
	
VOID
SegmentTimeoutDpc (
	PKDPC		dpc,
	PVOID		Context,
	PVOID		SystemArgument1,
	PVOID		SystemArgument2
	);
	
/*++
*******************************************************************
    C r e a t e S e g m e n t

Routine Description:
	Allocates and initializes packet segment
Arguments:
	list - segment list to which new segment will be added
Return Value:
	Pointer to allocated segment, NULL if fails

*******************************************************************
--*/
PPACKET_SEGMENT
CreateSegment (
	PSEGMENT_LIST	list
	) {
	KIRQL				oldIRQL;
	NDIS_STATUS			status;
	PPACKET_SEGMENT		segment;
	ULONG				segmentsize = list->SL_BlockCount*list->SL_BlockSize
								+FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers);
	if (MaxRcvPktsPoolSize!=0) {
			// Check if this allocation would exceed the limit
		KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
		if (RcvPktsPoolSize+segmentsize<MaxRcvPktsPoolSize) {
			RcvPktsPoolSize += segmentsize;
			KeReleaseSpinLock (&AllocatorLock, oldIRQL);
		}
		else {
			KeReleaseSpinLock (&AllocatorLock, oldIRQL);
			return NULL;
		}
	}

		// Allocate chunk of memory to hold segment header and buffers
	segment = ExAllocatePoolWithTag (
					NonPagedPool,
					segmentsize,
					FWD_POOL_TAG);
	if (segment!=NULL) {
		segment->PS_SegmentList = list;
		segment->PS_FreeHead = NULL;
		segment->PS_BusyCount = 0;
		segment->PS_PacketPool = (NDIS_HANDLE)FWD_POOL_TAG;
		KeQuerySystemTime ((PLARGE_INTEGER)&segment->PS_FreeStamp);
		NdisAllocatePacketPoolEx (
				&status,
				&segment->PS_PacketPool,
				list->SL_BlockCount,
				0,
				IPXMacHeaderSize
						+FIELD_OFFSET (PACKET_TAG, PT_MacHeader));
		if (status==NDIS_STATUS_SUCCESS) {
        	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING, 
                ("IpxFwd: CreateSegent pool: %x\n", segment->PS_PacketPool));
	
			NdisAllocateBufferPool (
				&status,
				&segment->PS_BufferPool,
				list->SL_BlockCount*2);
			if (status==NDIS_STATUS_SUCCESS) {
				PUCHAR			bufferptr = segment->PS_Buffers;
				PNDIS_PACKET	packetDscr;
				PNDIS_BUFFER	bufferDscr;
				PPACKET_TAG		packetTag;
				ULONG			i;

				for (i=0; i<list->SL_BlockCount; i++,
										bufferptr+=list->SL_BlockSize) {
					NdisAllocatePacket (
						&status,
						&packetDscr,
						segment->PS_PacketPool);
					ASSERT (status==NDIS_STATUS_SUCCESS);

					packetTag = (PPACKET_TAG)packetDscr->ProtocolReserved;
					packetTag->PT_Segment = segment;
					packetTag->PT_Data = bufferptr;
					packetTag->PT_InterfaceReference = NULL;
					
					NdisAllocateBuffer (
						&status,
						&packetTag->PT_MacHdrBufDscr,
						segment->PS_BufferPool,
						packetTag->PT_MacHeader,
						IPXMacHeaderSize);
					ASSERT (status==NDIS_STATUS_SUCCESS);

					NdisAllocateBuffer (
						&status,
						&bufferDscr,
						segment->PS_BufferPool,
						bufferptr,
						list->SL_BlockSize);
					ASSERT (status==NDIS_STATUS_SUCCESS);
					if (bufferDscr)
					{
    					NdisChainBufferAtFront (packetDscr, bufferDscr);
					}

					packetTag->PT_Next = segment->PS_FreeHead;
					segment->PS_FreeHead = packetTag;
				}
				IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
					("IpxFwd: Allocated packet segment %08lx for list %ld.\n",
					segment, list->SL_BlockSize));
				return segment;
			}
			else {
				IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_ERROR,
					("IpxFwd: Failed to allocate buffer pool"
					" for new segment in list %ld.\n",
					list->SL_BlockSize));
			}
			NdisFreePacketPool (segment->PS_PacketPool);
		}
		else {
			IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_ERROR,
				("IpxFwd: Failed to allocate packet pool"
				" for new segment in list %ld.\n",
				list->SL_BlockSize));
		}
		ExFreePool (segment);
	}
	else {
		IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_ERROR,
			("IpxFwd: Failed to allocate new segment for list %ld.\n",
			list->SL_BlockSize));
	}

	return NULL;
}


/*++
*******************************************************************
    D e l e t e S e g m e n t

Routine Description:
	Frees packet segment
Arguments:
	segment - segment to free
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegment (
	PPACKET_SEGMENT	segment
	) {
	PSEGMENT_LIST	list = segment->PS_SegmentList;

	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING, 
	                ("IpxFwd: DeleteSegment entered. %d %x\n",segment->PS_BusyCount, segment->PS_PacketPool));
	
	ASSERT (segment->PS_BusyCount == 0);
	
	// Free all NDIS packet and buffer descriptors first
	while (segment->PS_FreeHead!=NULL) {
		PNDIS_BUFFER	bufferDscr;
		PPACKET_TAG		packetTag = segment->PS_FreeHead;
		PNDIS_PACKET	packetDscr = CONTAINING_RECORD (packetTag,
									NDIS_PACKET, ProtocolReserved);

		segment->PS_FreeHead = packetTag->PT_Next;

		ASSERT (packetTag->PT_MacHdrBufDscr!=NULL);
		NdisFreeBuffer (packetTag->PT_MacHdrBufDscr);

		NdisUnchainBufferAtFront (packetDscr, &bufferDscr);
		ASSERT (bufferDscr!=NULL);
		NdisFreeBuffer (bufferDscr);
		
		NdisFreePacket (packetDscr);
	}
	NdisFreeBufferPool (segment->PS_BufferPool);

	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING, 
	                ("IpxFwd: DeleteSegment pool:      %x\n", segment->PS_PacketPool));
	                
	NdisFreePacketPool (segment->PS_PacketPool);

	// [pmay] Remove this -- for debugging only
	segment->PS_PacketPool = NULL;

		// Decrement memory used if we have a quota
	if (MaxRcvPktsPoolSize!=0) {
		KIRQL			oldIRQL;
		ULONG			segmentsize = list->SL_BlockCount*list->SL_BlockSize
								+FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers);
		KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
		RcvPktsPoolSize -= segmentsize;
		KeReleaseSpinLock (&AllocatorLock, oldIRQL);
	}
	ExFreePool (segment);
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
		("IpxFwd: Deleting segment %08lx in list %ld.\n",
		segment, list->SL_BlockSize));
}


/*++
*******************************************************************
    R e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Registers a consumer (bound interface) of packets of the
	given size
Arguments:
	pktsize - maximum size of packets needed
	listId - buffer to return packet list id where packets
			of required size are located
Return Value:
	STATUS_SUCCESS - registration succeded
	STATUS_INSUFFICIENT_RESOURCES - not enogh resources to register

*******************************************************************
--*/
NTSTATUS
RegisterPacketConsumer (
	IN ULONG	pktsize,
	OUT INT		*listID
	) {
	NTSTATUS		status=STATUS_SUCCESS;
	KIRQL			oldIRQL;
	PSEGMENT_LIST	list;
	INT				i;
	LONG			addRefCount = 1;

	KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
	ASSERT (pktsize<=SegmentMap[FRAME_SIZE_VARIATIONS-1]
								[FRAME_SIZE_VARIATIONS-1]->SL_BlockSize);

	for (i=0; i<FRAME_SIZE_VARIATIONS; i++) {
		list = SegmentMap[i][i];
		if (pktsize<=list->SL_BlockSize) {
			list->SL_RefCount += 1;
			*listID = i;
			break;
		}
	}
	KeReleaseSpinLock (&AllocatorLock, oldIRQL);
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
		("IpxFwd: Registered packet consumer, pktsz: %ld, list: %ld.\n",
		pktsize, list->SL_BlockSize));
	return status;
}

/*++
*******************************************************************
    D e r e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Deregisters a consumer (bound interface) of packets of the
	given size
Arguments:
	listId - packet list id used by the consumer
Return Value:
	None

*******************************************************************
--*/
VOID
DeregisterPacketConsumer (
	IN INT		listID
	) {
	KIRQL		oldIRQL;
	PSEGMENT_LIST	list;

	ASSERT ((listID>=0) && (listID<FRAME_SIZE_VARIATIONS));

	KeAcquireSpinLock (&AllocatorLock, &oldIRQL);
	list = SegmentMap[listID][listID];
	
	ASSERT (list->SL_RefCount>0);
	
	list->SL_RefCount -= 1;
	
	KeReleaseSpinLock (&AllocatorLock, oldIRQL);
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
		("IpxFwd: Deregistered packet consumer, list: %ld.\n",
		list->SL_BlockSize));
	
	}
	
/*++
*******************************************************************
    I n i t i a l i z e S e g m e n t L i s t

Routine Description:
	Initializes list of packet segments
Arguments:
	list - list to initalize
Return Value:
	None

*******************************************************************
--*/
VOID
InitializeSegmentList(
	PSEGMENT_LIST	list
	) {
	InitializeListHead (&list->SL_Head);
	list->SL_FreeCount = 0;
		// Make sure we don't have any leftover larger than
		// the buffer size (kernel memory allocator
		// allocates full pages)
	list->SL_BlockCount = (ULONG)
				(ROUND_TO_PAGES (
						list->SL_BlockSize*RcvPktsPerSegment
						+FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers))
					-FIELD_OFFSET(PACKET_SEGMENT,PS_Buffers))
				/list->SL_BlockSize;
	list->SL_LowCount = list->SL_BlockCount/2;
	list->SL_RefCount = 0;
	list->SL_AllocatorPending = FALSE;
	list->SL_TimerDpcPending = FALSE;
	KeInitializeSpinLock (&list->SL_Lock);
	KeInitializeTimer (&list->SL_Timer);
	KeInitializeDpc (&list->SL_TimerDpc, SegmentTimeoutDpc, list);
	ExInitializeWorkItem (&list->SL_Allocator, AllocationWorker, list);
}

/*++
*******************************************************************
    D e l e t e S e g m e n t L i s t

Routine Description:
	Deletes list of packet segments
Arguments:
	list - list to delete
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegmentList (
	PSEGMENT_LIST	list
	) {
	KeCancelTimer (&list->SL_Timer);
	while (!IsListEmpty (&list->SL_Head)) {
		PPACKET_SEGMENT segment;
		segment = CONTAINING_RECORD (list->SL_Head.Blink,
										PACKET_SEGMENT, PS_Link);

		RemoveEntryList (&segment->PS_Link);
		DeleteSegment (segment);
	}
}


/*++
*******************************************************************
    S e g m e n t T i m e o u t D p c

Routine Description:
	Timer DPC that launches allocator worker to get rid of unused
	segments
Arguments:
	Context - segment list to check for unused segments
Return Value:
	None

*******************************************************************
--*/
VOID
SegmentTimeoutDpc (
	PKDPC		dpc,
	PVOID		Context,
	PVOID		SystemArgument1,
	PVOID		SystemArgument2
	) {
#define list ((PSEGMENT_LIST)Context)
	KIRQL			oldIRQL;
	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_INFORMATION,
		("IpxFwd: Segment timed out in list: %ld.\n",
		list->SL_BlockSize));
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
	list->SL_TimerDpcPending = FALSE;
	if (!list->SL_AllocatorPending
			&& (list->SL_FreeCount>=list->SL_BlockCount)
			&& EnterForwarder ()) {
		list->SL_AllocatorPending = TRUE;
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
		ExQueueWorkItem (&list->SL_Allocator, DelayedWorkQueue);
	}
	else {
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
	}
	LeaveForwarder ();
#undef list
}


/*++
*******************************************************************
    A l l o c a t i o n W o r k e r

Routine Description:
	Adds new segment or releases unused segments from the list
	depending on the free packet count and time that segments
	are not used
Arguments:
	Context - packet list to process
Return Value:
	None

*******************************************************************
--*/
VOID
AllocationWorker (
	PVOID	Context
	) {
#define list ((PSEGMENT_LIST)Context)
	KIRQL			oldIRQL;
	PPACKET_SEGMENT segment = NULL;
	LONGLONG		curTime;

	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_INFORMATION,
		("IpxFwd: Allocating/scavenging segment(s) in list: %ld.\n",
		list->SL_BlockSize));
	KeQuerySystemTime ((PLARGE_INTEGER)&curTime);
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
	list->SL_AllocatorPending = FALSE;
	if (list->SL_FreeCount<list->SL_BlockCount) {
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
			// First allocate a segment
		segment = CreateSegment (list);
		if (segment!=NULL) {
			KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
			InsertTailList (&list->SL_Head, &segment->PS_Link);		
			list->SL_FreeCount += list->SL_BlockCount;
			if (!list->SL_TimerDpcPending
					&& EnterForwarder ()) {
				list->SL_TimerDpcPending = TRUE;
				KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
				KeSetTimer (&list->SL_Timer, *((PLARGE_INTEGER)&SegmentTimeout), &list->SL_TimerDpc);
			}
			else {
				KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
			}
		}
	}
	else {
			// Make sure that there is either more than segment in the list
			// or there is one and no registered users
		if (!IsListEmpty (&list->SL_Head)) {

		    // [pmay] Remove this -- for debugging purposes only.
		    //
            //{
            //    LIST_ENTRY * pEntry = &list->SL_Head;
            //    
            // 	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
            //		("IpxFwd: Scanning %x for possible segment deletion.\n",list));
            //
            //    while (pEntry->Flink != list->SL_Head.Flink) {
            //        segment = CONTAINING_RECORD (pEntry->Flink, PACKET_SEGMENT, PS_Link);
            //    	IpxFwdDbgPrint (DBG_PACKET_ALLOC, DBG_WARNING,
            //    		("IpxFwd: Segment:  %x\n",segment));
            //        pEntry = pEntry->Flink;
            //    }
            //}
            
			segment = CONTAINING_RECORD (list->SL_Head.Blink,
											PACKET_SEGMENT, PS_Link);
				// Check for all segments with no used blocks
				// except for the last one (delete event the last
				// one if there are no clients)
			while ((segment->PS_BusyCount==0)
					&& ((list->SL_Head.Flink!=&segment->PS_Link)
						|| (list->SL_RefCount<=0))) {
				LONGLONG	timeDiff;
					// Check if it has not been used for long enough
				timeDiff = SegmentTimeout - (segment->PS_FreeStamp-curTime);
				if (timeDiff>=0) {
						// Delete the segment
					RemoveEntryList (&segment->PS_Link);
					list->SL_FreeCount -= list->SL_BlockCount;
					KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
					DeleteSegment (segment);
					KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);
					if (!IsListEmpty (&list->SL_Head)) {
						segment = CONTAINING_RECORD (list->SL_Head.Blink,
												PACKET_SEGMENT, PS_Link);
						continue;
					}
				}
				else { // Reschedule the timer otherwise
					if (!list->SL_TimerDpcPending
							&& EnterForwarder ()) {
						list->SL_TimerDpcPending = TRUE;
						KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
						KeSetTimer (&list->SL_Timer,
										*((PLARGE_INTEGER)&timeDiff),
										&list->SL_TimerDpc);
						goto ExitAllocator; // Spinlock is already released
					}
				}
			break;
			} // while
		} // if (IsListEmpty)
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);
	}
ExitAllocator:
	LeaveForwarder ();
#undef list
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\netbios.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\netbios.h

Abstract:
	Netbios packet processing

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef IPXFWD_NETBIOS
#define IPXFWD_NETBIOS

extern LIST_ENTRY		NetbiosQueue;
extern KSPIN_LOCK		NetbiosQueueLock;
extern WORK_QUEUE_ITEM	NetbiosWorker;
extern BOOLEAN			NetbiosWorkerScheduled;
extern ULONG			NetbiosPacketsQuota;
extern ULONG			MaxNetbiosPacketsQueued;
#define DEF_MAX_NETBIOS_PACKETS_QUEUED	256


/*++
*******************************************************************
    I n i t i a l i z e N e t b i o s Q u e u e

Routine Description:
	Initializes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
//VOID
//InitializeNetbiosQueue (
//	void
//	)
#define InitializeNetbiosQueue()	{							\
	InitializeListHead (&NetbiosQueue);							\
	KeInitializeSpinLock (&NetbiosQueueLock);					\
	ExInitializeWorkItem (&NetbiosWorker, &ProcessNetbiosQueue, NULL);\
	NetbiosWorkerScheduled = FALSE;								\
	NetbiosPacketsQuota = MaxNetbiosPacketsQueued;				\
}

/*++
*******************************************************************
    D e l e t e N e t b i o s Q u e u e

Routine Description:
	Deletes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteNetbiosQueue (
	void
	);


/*++
*******************************************************************
    P r o c e s s N e t b i o s Q u e u e

Routine Description:
	Process packets in the netbios bradcast queue
Arguments:
	Context - unused
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosQueue (
	PVOID		Context
	);

/*++
*******************************************************************
    P r o c e s s N e t b i o s P a c k e t

Routine Description:
	Processes received netbios broadcast packet
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessNetbiosPacket (
	PINTERFACE_CB	srcIf,
	PPACKET_TAG		pktTag
	);


#define QueueNetbiosPacket(pktTag) {						\
	KIRQL		oldIRQL;									\
	KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);		\
	InsertTailList (&NetbiosQueue, &pktTag->PT_QueueLink);	\
	KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);			\
}

#define ScheduleNetbiosWorker() {							\
	KIRQL		oldIRQL;									\
	KeAcquireSpinLock (&NetbiosQueueLock, &oldIRQL);		\
	if (!NetbiosWorkerScheduled								\
			&& !IsListEmpty (&NetbiosQueue)					\
			&& EnterForwarder ()) {							\
		NetbiosWorkerScheduled	= TRUE;						\
		ExQueueWorkItem (&NetbiosWorker, DelayedWorkQueue);	\
	}														\
	KeReleaseSpinLock (&NetbiosQueueLock, oldIRQL);			\
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\packets.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\packets.h

Abstract:
    IPX Forwarder Driver packet allocator


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_PACKETS_
#define _IPXFWD_PACKETS_

// Forward structure prototypes
struct _SEGMENT_LIST;
typedef struct _SEGMENT_LIST SEGMENT_LIST, *PSEGMENT_LIST;
struct _PACKET_SEGMENT;
typedef struct _PACKET_SEGMENT PACKET_SEGMENT, *PPACKET_SEGMENT;
struct _PACKET_TAG;
typedef struct _PACKET_TAG PACKET_TAG, *PPACKET_TAG;

// Forwarder data associated with each packet it allocates
struct _PACKET_TAG {
	union {
		UCHAR			PT_Identifier;	// this should be IDENTIFIER_RIP
		PPACKET_TAG		PT_Next;		// link in packet segment
	};
	union {
		PVOID			SEND_RESERVED[SEND_RESERVED_COMMON_SIZE];	// needed by ipx
										// for padding on ethernet
		PINTERFACE_CB	PT_SourceIf;	// Source interface reference needed
										// for spoofing keep-alives and
                                        // queuing connection requests
	};
	PPACKET_SEGMENT		PT_Segment;		// segment where it belongs
	LONGLONG			PT_PerfCounter;
	ULONG				PT_Flags;
#define	PT_NB_DESTROY	0x1				// NB packet to be not requeued
#define PT_SOURCE_IF	0x2				// Spoofing packet with src if reference
	PUCHAR				PT_Data;		// Data buffer
	PNDIS_BUFFER		PT_MacHdrBufDscr; // buffer descriptor for
										// mac header buffer required
										// by IPX
	PINTERFACE_CB		PT_InterfaceReference;	// points to the interface CB where
										// it is queued
	LIST_ENTRY			PT_QueueLink;	// links this packet in send queue
	IPX_LOCAL_TARGET	PT_Target;		// destination target for ipx
										// stack
	UCHAR				PT_MacHeader[1];// Mac header buffer reserved for IPX
};

// Segment of preallocated packets complete with buffers
struct _PACKET_SEGMENT {
	LIST_ENTRY				PS_Link;		// Link in segment list
	PSEGMENT_LIST			PS_SegmentList;	// Segment list we belong to
	PPACKET_TAG				PS_FreeHead;	// List of free packets in
											// this segment
	ULONG					PS_BusyCount;	// Count of packets allocated
											// from this segment
	NDIS_HANDLE				PS_PacketPool;	// Pool of NDIS packet
											// descriptors used by the
											// packets in this segment
	NDIS_HANDLE				PS_BufferPool;	// Pool of NDIS buffer
											// descriptors used by the
											// packets in this segment
	LONGLONG				PS_FreeStamp;	// Time when last packet was freed
	union {
		UCHAR					PS_Buffers[1];	// Memory used by buffers
		LONGLONG				PS_BuffersAlign;
	};
};


// List of segment with preallocated packets
struct _SEGMENT_LIST {
	const ULONG				SL_BlockSize;	// Size of packet's buffer
	LIST_ENTRY				SL_Head;		// Head of the segment list
	ULONG					SL_FreeCount;	// Total number of free packets
											// in all segment in the list
	ULONG					SL_BlockCount;	// Number of packets per segment
	ULONG					SL_LowCount;	// Free count at which we
											// will preallocate new segment
	LONG					SL_RefCount;	// Number of consumers that are
											// using packets in this list
	BOOLEAN					SL_TimerDpcPending;
	BOOLEAN					SL_AllocatorPending;
	WORK_QUEUE_ITEM			SL_Allocator;	// Allocation work item
	KTIMER					SL_Timer;		// Timer to free unused segments
	KDPC					SL_TimerDpc;	// DPC of the timer of unused segments
	KSPIN_LOCK				SL_Lock;		// Access control
};


// The number of rcv packets per segment (config parameter)
#define     MIN_RCV_PKTS_PER_SEGMENT	    8
#define     DEF_RCV_PKTS_PER_SEGMENT	    64
#define     MAX_RCV_PKTS_PER_SEGMENT	    256
extern ULONG RcvPktsPerSegment;

// Maximum size of memory that can be used to allocate packets (config
// param). 0 means no limit
extern ULONG MaxRcvPktsPoolSize;

// There are currently three known frame sizes: ethernet-1500,
//		token ring 4k - 4500, token ring 16k - 17986
#define FRAME_SIZE_VARIATIONS	3

// List of packet segments for Ethernet packets
extern SEGMENT_LIST	ListEther;	
// List of packet segments for Token Ring 4K packets
extern SEGMENT_LIST	ListTR4;
// List of packet segments for Token Ring 16K packets
extern SEGMENT_LIST	ListTR16;
// Mapping from src and destination packet size requirments
// to the appropriate segment list
extern PSEGMENT_LIST SegmentMap[FRAME_SIZE_VARIATIONS][FRAME_SIZE_VARIATIONS];
// Timeout for unused segment
extern const LONGLONG SegmentTimeout;
extern KSPIN_LOCK	AllocatorLock;

/*++
*******************************************************************
    I n i t i a l i z e P a c k e t A l l o c a t o r

Routine Description:
	Initializes packet allocator
Arguments:
    None
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	InitializePacketAllocator (
//		void
//	);
#define InitializePacketAllocator() {			\
	KeInitializeSpinLock(&AllocatorLock);		\
	InitializeSegmentList(&ListEther);			\
	InitializeSegmentList(&ListTR4);			\
	InitializeSegmentList(&ListTR16);			\
}

/*++
*******************************************************************
    D e l e t e P a c k e t A l l o c a t o r

Routine Description:
	Disposes of all resources in packet allocator
Arguments:
    None
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	DeletePacketAllocator (
//		void
//	);
#define DeletePacketAllocator() {			\
	DeleteSegmentList(&ListEther);			\
	DeleteSegmentList(&ListTR4);			\
	DeleteSegmentList(&ListTR16);			\
}


/*++
*******************************************************************
    A l l o c a t e P a c k e t

Routine Description:
	Allocate packet for source - destination combination
Arguments:
    srcListId - identifies max frame size for source interface
	dstListId - identifies max frame size for destination
	packet - receives pointer to allocated packet or NULL if allocation
			fails
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	AllocatePacket (
//		IN INT		srcListId,
//		IN INT		dstListId,
//		OUT PPACKET_TAG	packet
//		);
#define AllocatePacket(srcListId,dstListId,packet) {					\
	PSEGMENT_LIST		list;											\
	ASSERT ((srcListId>=0) && (srcListId<FRAME_SIZE_VARIATIONS));		\
	ASSERT ((dstListId>=0) && (dstListId<FRAME_SIZE_VARIATIONS));		\
	list = SegmentMap[srcListId][dstListId];							\
	AllocatePacketFromList(list,packet);								\
}

/*++
*******************************************************************
    D u p l i c a t e P a c k e t

Routine Description:
	Duplicates packet
Arguments:
	src	- source packet
	dst - receives pointer to duplicated packet or NUUL if operation
	failed
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	DuplicatePacket (
//		IN PPACKET_TAG	src
//		OUT PPACKET_TAG	dst
//		);
#define DuplicatePacket(src,dst) {										\
	PSEGMENT_LIST		list;											\
	list = src->PT_Segment->PS_SegmentList;								\
	AllocatePacketFromList(list,dst);									\
}


/*++
*******************************************************************
    A l l o c a t e P a c k e t F r o m L i s t

Routine Description:
	Allocate packet from specified packet segment list
Arguments:
	list	- list from which to allocate
	packet	- receives pointer to allocated packet or NULL if allocation
			fails
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	AllocatePacketFromList (
//		IN PSEGMENT_LIST	list
//		OUT PPACKET_TAG		packet
//		);
#define AllocatePacketFromList(list,packet) {							\
	PPACKET_SEGMENT		segment;										\
	KIRQL				oldIRQL;										\
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);						\
	do {																\
		if (list->SL_FreeCount>0) {										\
			segment = CONTAINING_RECORD (list->SL_Head.Flink,			\
											 PACKET_SEGMENT, PS_Link);	\
			while (segment->PS_FreeHead==NULL) {						\
				segment = CONTAINING_RECORD (segment->PS_Link.Flink,	\
											PACKET_SEGMENT, PS_Link);	\
				ASSERT (&segment->PS_Link!=&list->SL_Head);				\
			}															\
			list->SL_FreeCount -= 1;									\
			if ((list->SL_FreeCount<list->SL_LowCount)					\
					&& !list->SL_AllocatorPending						\
					&& EnterForwarder ()) {								\
				list->SL_AllocatorPending = TRUE;						\
				ExQueueWorkItem (&list->SL_Allocator, DelayedWorkQueue);\
			}															\
		}																\
		else {															\
			segment = CreateSegment (list);								\
			if (segment!=NULL) {										\
				InsertTailList (&list->SL_Head, &segment->PS_Link);		\
				segment->PS_SegmentList = list;							\
				list->SL_FreeCount = list->SL_BlockCount-1;				\
			}															\
			else {														\
				packet = NULL;											\
				break;													\
			}															\
		}																\
		packet = segment->PS_FreeHead;									\
		segment->PS_FreeHead = packet->PT_Next;							\
		segment->PS_BusyCount += 1;										\
		packet->PT_Identifier = IDENTIFIER_RIP;							\
		packet->PT_Flags = 0;											\
	}																	\
	while (FALSE);														\
	KeReleaseSpinLock (&list->SL_Lock, oldIRQL);						\
}

/*++
*******************************************************************
    F r e e P a c k e t

Routine Description:
	Free allocated packet
Arguments:
	packet - packet to free
Return Value:
	None

*******************************************************************
--*/
//	VOID
//	FreePacket (
//		IN PPACKET_TAG	packet
//		);
#define FreePacket(packet) {							\
	PPACKET_SEGMENT		segment=packet->PT_Segment;		\
	PSEGMENT_LIST		list;							\
	KIRQL				oldIRQL;						\
	list = segment->PS_SegmentList;						\
	KeAcquireSpinLock (&list->SL_Lock, &oldIRQL);		\
	packet->PT_Next = segment->PS_FreeHead;				\
	segment->PS_FreeHead = packet;						\
	list->SL_FreeCount += 1;							\
	segment->PS_BusyCount -= 1;							\
	if (segment->PS_BusyCount==0) {						\
		if (list->SL_TimerDpcPending) {					\
			KeQuerySystemTime ((PLARGE_INTEGER)&segment->PS_FreeStamp);	\
			KeReleaseSpinLock (&list->SL_Lock, oldIRQL);\
		}												\
		else if (EnterForwarder ()) {					\
			list->SL_TimerDpcPending = TRUE;			\
			KeReleaseSpinLock (&list->SL_Lock, oldIRQL);\
			KeSetTimer (&list->SL_Timer,				\
					*((PLARGE_INTEGER)&SegmentTimeout),	\
					&list->SL_TimerDpc);				\
		}												\
		else {											\
			KeReleaseSpinLock (&list->SL_Lock, oldIRQL);\
		}												\
	}													\
	else {												\
		KeReleaseSpinLock (&list->SL_Lock, oldIRQL);	\
	}													\
}
	

/*++
*******************************************************************
    C r e a t e S e g m e n t

Routine Description:
	Allocates and initializes packet segment
Arguments:
	list - segment list to which new segment will be added
Return Value:
	Pointer to allocated segment, NULL if fails

*******************************************************************
--*/
PPACKET_SEGMENT
CreateSegment (
	PSEGMENT_LIST	list
	);

/*++
*******************************************************************
    D e l e t e S e g m e n t

Routine Description:
	Frees packet segment
Arguments:
	segment - segment to free
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegment (
	PPACKET_SEGMENT	segment
	);

/*++
*******************************************************************
    R e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Registers a consumer (bound interface) of packets of the
	given size
Arguments:
	pktsize - maximum size of packets needed
	listId - buffer to return packet list id where packets
			of required size are located
Return Value:
	STATUS_SUCCESS - registration succeded
	STATUS_INSUFFICIENT_RESOURCES - not enogh resources to register

*******************************************************************
--*/
NTSTATUS
RegisterPacketConsumer (
	IN ULONG	pktsize,
	OUT INT		*listID
	);

/*++
*******************************************************************
    D e r e g i s t e r P a c k e t C o n s u m e r

Routine Description:
	Deregisters a consumer (bound interface) of packets of the
	given size
Arguments:
	listId - packet list id used by the consumer
Return Value:
	None

*******************************************************************
--*/
VOID
DeregisterPacketConsumer (
	IN INT		listID
	);

/*++
*******************************************************************
    I n i t i a l i z e S e g m e n t L i s t

Routine Description:
	Initializes list of packet segments
Arguments:
	list - list to initalize
Return Value:
	None

*******************************************************************
--*/
VOID
InitializeSegmentList(
	PSEGMENT_LIST	list
	);


/*++
*******************************************************************
    D e l e t e S e g m e n t L i s t

Routine Description:
	Deletes list of packet segments
Arguments:
	list - list to delete
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteSegmentList (
	PSEGMENT_LIST	list
	);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\precomp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\precomp.h

Abstract:
    IPX Forwarder driver precompiled header file

Author:

    Vadim Eydelman

Revision History:

--*/

#define ISN_NT 1
#define NT 1

#if DBG
#define DEBUG 1
#endif

// System includes
#include <ntosp.h>
#include <tdikrnl.h>
#include <ndis.h>
#include <zwapi.h>
#include <limits.h>

// IPX shared includes
#include "bind.h"
#include "ipxfwd.h"
#include "ipxfltif.h"
#include "ipxfwtbl.h"

// Constants and macros
#include "fwddefs.h"
#include "rwlock.h"

// Internal module prototypes
#include "registry.h"
#include "packets.h"
#include "ipxbind.h"
#include "rcvind.h"
#include "send.h"
#include "netbios.h"
#include "lineind.h"
#include "ddreqs.h"
#include "driver.h"
#include "filterif.h"
#include "debug.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\rcvind.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\rcvind.c

Abstract:
	Receive indication processing

Author:

    Vadim Eydelman

Revision History:

--*/
#include    "precomp.h"

#if DBG
VOID
DbgFilterReceivedPacket(PUCHAR	    hdrp);
#endif

// Doesn't allow accepting packets (for routing) from dial-in clients
BOOLEAN	ThisMachineOnly = FALSE;

/*++
*******************************************************************
    F w R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet was
	received by the NIC dirver.  Only external destined packets are
	indicated by this routine (with the exception of Netbios boradcasts
	that indicated both for internal and external handlers)
Arguments:
	MacBindingHandle	- handle of NIC driver
	MaxReceiveContext	- NIC driver context
	RemoteAddress		- sender's address
	MacOptions			-
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
	LookaheadBufferOffset - offset of lookahead buffer in the physical
							packet
Return Value:
    TRUE if we take the MDL chain to return later with NdisReturnPacket

*******************************************************************
--*/
BOOLEAN
IpxFwdReceive (
    NDIS_HANDLE			MacBindingHandle,
    NDIS_HANDLE			MacReceiveContext,
    ULONG_PTR			Context,
    PIPX_LOCAL_TARGET	RemoteAddress,
    ULONG				MacOptions,
    PUCHAR				LookaheadBuffer,
    UINT				LookaheadBufferSize,
    UINT				LookaheadBufferOffset,
    UINT				PacketSize,
    PMDL                pMdl) 
{
  PINTERFACE_CB	srcIf, dstIf;
  PPACKET_TAG	    pktTag;
  PNDIS_PACKET	pktDscr;
  NDIS_STATUS     status;
  UINT			BytesTransferred;
  LARGE_INTEGER	PerfCounter;

  // check that our configuration process has terminated OK
  if (!EnterForwarder ()) {
    return FALSE;
  }

  if (!MeasuringPerformance) {
    PerfCounter.QuadPart = 0;
  }
  else {
#if DBG
    static LONGLONG LastCall = 0;
    KIRQL	oldIRQL;
#endif
    PerfCounter = KeQueryPerformanceCounter (NULL);
#if DBG
    KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
    ASSERT (PerfCounter.QuadPart-LastCall<ActivityTreshhold);
    LastCall = PerfCounter.QuadPart;
    KeReleaseSpinLock (&PerfCounterLock, oldIRQL);
#endif
  }

  IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION,
		  ("IpxFwd: FwdReceive on %0lx,"
		   " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
		   Context, GETULONG (LookaheadBuffer+IPXH_DESTNET),
		   LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
		   LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
		   LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
		   LookaheadBuffer[IPXH_PKTTYPE]));

#if DBG
  DbgFilterReceivedPacket (LookaheadBuffer);
#endif
  srcIf = InterfaceContextToReference ((PVOID)Context, RemoteAddress->NicId);
  // Check if interface is valid
  if (srcIf!=NULL) {	
    USHORT			pktlen;
    ULONG			dstNet;
    KIRQL			oldIRQL;

    dstNet = GETULONG (LookaheadBuffer + IPXH_DESTNET);
    pktlen = GETUSHORT(LookaheadBuffer + IPXH_LENGTH);

    // check if we got the whole IPX header in the lookahead buffer
    if ((LookaheadBufferSize >= IPXH_HDRSIZE)
	&& (*(LookaheadBuffer + IPXH_XPORTCTL) < 16)
	&& (pktlen<=PacketSize)) {
      // Lock interface CB to ensure coherency of information in it
      KeAcquireSpinLock(&srcIf->ICB_Lock, &oldIRQL);
      // Check if shoud accept packets on this interface
      if (IS_IF_ENABLED(srcIf)
	  && (srcIf->ICB_Stats.OperationalState!=FWD_OPER_STATE_DOWN)
	  && (!ThisMachineOnly
	      || (srcIf->ICB_InterfaceType
		  !=FWD_IF_REMOTE_WORKSTATION))) {
	// Check for looped back packets
	if (IPX_NODE_CMP (RemoteAddress->MacAddress,
			  srcIf->ICB_LocalNode)!=0) {

	  // Separate processing of netbios broadcast packets (20)
	  if (*(LookaheadBuffer + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE) {
	    PFWD_ROUTE		dstRoute;
	    INT				srcListId, dstListId;
	    // Temp IPX bug fix, they shou;d ensure that
	    // we only get packets that can be routed
	    if ((dstNet==srcIf->ICB_Network)
		|| (dstNet==InternalInterface->ICB_Network)) {
	      InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
	      KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	      ReleaseInterfaceReference (srcIf);
	      LeaveForwarder ();
	      return FALSE;
	    }
	    //						ASSERT (dstNet!=srcIf->ICB_Network);
	    //						ASSERT ((InternalInterface==NULL)
	    //									|| (InternalInterface->ICB_Network==0)
	    //									|| (dstNet!=InternalInterface->ICB_Network));
	    // Check if needed route is in cash
	    if ((srcIf->ICB_CashedRoute!=NULL)
		&& (dstNet==srcIf->ICB_CashedRoute->FR_Network)
		// If route was changed or deleted, this will fail
		&& (srcIf->ICB_CashedRoute->FR_InterfaceReference
		    ==srcIf->ICB_CashedInterface)) {
	      dstIf = srcIf->ICB_CashedInterface;
	      dstRoute = srcIf->ICB_CashedRoute;
	      AcquireInterfaceReference (dstIf);
	      AcquireRouteReference (dstRoute);
	      IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION,
			      ("IpxFwd: Destination in cash.\n"));
	    }
	    else {	// Find and cash the route
	      dstIf = FindDestination (dstNet,
				       LookaheadBuffer+IPXH_DESTNODE,
				       &dstRoute
				       );

	      if (dstIf!=NULL) { // If route is found
		IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION,
				("IpxFwd: Found destination %0lx.\n", dstIf));
		// Don't cash global wan clients and
		// routes to the same net
		if ((dstNet!=GlobalNetwork)
		    && (dstIf!=srcIf)) {
		  if (srcIf->ICB_CashedInterface!=NULL)
		    ReleaseInterfaceReference (srcIf->ICB_CashedInterface);
		  if (srcIf->ICB_CashedRoute!=NULL)
		    ReleaseRouteReference (srcIf->ICB_CashedRoute);
		  srcIf->ICB_CashedInterface = dstIf;
		  srcIf->ICB_CashedRoute = dstRoute;
		  AcquireInterfaceReference (dstIf);
		  AcquireRouteReference (dstRoute);
		}
	      }
	      else { // No route
		InterlockedIncrement (&srcIf->ICB_Stats.InNoRoutes);
		KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
		IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
				("IpxFwd: No route for packet on interface %ld (icb:%0lx),"
				 " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				 srcIf->ICB_Index, srcIf, dstNet,
				 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				 LookaheadBuffer[IPXH_PKTTYPE]));
		ReleaseInterfaceReference (srcIf);
		LeaveForwarder ();
		return FALSE;
	      }
	    }
	    srcListId = srcIf->ICB_PacketListId;
	    KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);

	    // Check if destination if can take the packet
	    if (IS_IF_ENABLED (dstIf)
		// If interface is UP check packet againts actual size limit
		&& (((dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)
		     && (PacketSize<=dstIf->ICB_Stats.MaxPacketSize))
		    // if sleeping (WAN), check we can allocate it from WAN list
		    || ((dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_SLEEPING)
			&& (PacketSize<=WAN_PACKET_SIZE))
		    // otherwise, interface is down and we can't take the packet
		    ) ){
	      FILTER_ACTION   action;
	      action = FltFilter (LookaheadBuffer, LookaheadBufferSize,
				  srcIf->ICB_FilterInContext,
				  dstIf->ICB_FilterOutContext);
	      if (action==FILTER_PERMIT) {
		InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
		dstListId = dstIf->ICB_PacketListId;
		// try to get a packet from the rcv pkt pool
		AllocatePacket (srcListId, dstListId, pktTag);
		if (pktTag!=NULL) {
		  // Set destination mac in local target if
		  // possible
		  KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
		  if (dstIf->ICB_InterfaceType==FWD_IF_PERMANENT) {
		    // Permanent interface: send to the next
		    // hop router if net is not directly connected
		    // or to the dest node otherwise
		    if (dstNet!=dstIf->ICB_Network) {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    dstRoute->FR_NextHopAddress);
		    }
		    else {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    LookaheadBuffer+IPXH_DESTNODE);
		    }
		  }
		  else {	// Demand dial interface: assumed to be
		    // point to point connection -> send to
		    // the other party if connection has already
		    // been made, otherwise wait till connected
		    if (dstIf->ICB_Stats.OperationalState
			== FWD_OPER_STATE_UP) {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    dstIf->ICB_RemoteNode);
		    }	// Copy source mac address and nic id in case
		    // we need to spoof this packet
		    else if ((*(LookaheadBuffer+IPXH_PKTTYPE)==0)
			     && (pktlen==IPXH_HDRSIZE+2)
			     && ((LookaheadBufferSize<IPXH_HDRSIZE+2)
				 ||(*(LookaheadBuffer+IPXH_HDRSIZE+1)=='?'))) {
		      IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
				    RemoteAddress->MacAddress);
		      pktTag->PT_SourceIf = srcIf;
		      AcquireInterfaceReference (srcIf);
		      pktTag->PT_Flags |= PT_SOURCE_IF;
		    }

		  }
		  KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
		  ReleaseRouteReference (dstRoute);
		  goto GetPacket;
		}
		else { // Allocation failure
		  InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
		}
	      }
	      else {// Filtered out
		if (action==FILTER_DENY_OUT)
		  InterlockedIncrement (&dstIf->ICB_Stats.OutFiltered);
		else {
		  ASSERT (action==FILTER_DENY_IN);
		  InterlockedIncrement (&srcIf->ICB_Stats.InFiltered);
		}
		IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
				("IpxFwd: Filtered out"
				 " packet on interface %ld (icb:%0lx),"
				 " dst-%ld (icb %08lx) %08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				 srcIf->ICB_Index, srcIf, dstIf->ICB_Index, dstIf, dstNet,
				 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				 LookaheadBuffer[IPXH_PKTTYPE]));
	      }
	    }
	    else {	// Destination interface is down
	      InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
	      InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
	      IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
			      ("IpxFwd: Dest interface %ld (icb %08lx) down"
			       " for packet on interface %ld (icb:%0lx),"
			       " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
			       dstIf->ICB_Index, dstIf, srcIf->ICB_Index, srcIf, dstNet,
			       LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
			       LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
			       LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
			       LookaheadBuffer[IPXH_PKTTYPE]));
	    }
	    ReleaseInterfaceReference (dstIf);
	    ReleaseRouteReference (dstRoute);
	  }
	  else {	// if netbios
	    // check that this is a netbios bcast packet and
	    // didnt exceed the limit of routers to traverse
	    // and we can accept it on this interface
	    if (srcIf->ICB_NetbiosAccept
		&& (*(LookaheadBuffer + IPXH_XPORTCTL) < 8)) {
	      INT				srcListId;
	      srcListId = srcIf->ICB_PacketListId;
	      KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	      // Check if packet is valid
	      if (IPX_NODE_CMP (LookaheadBuffer + IPXH_DESTNODE,
				BROADCAST_NODE)==0) {
		// Check if we haven't exceeded the quota
		if (InterlockedDecrement (&NetbiosPacketsQuota)>=0) {
		  // try to get a packet from the rcv pkt pool
		  AllocatePacket (srcListId, srcListId, pktTag);
		  if (pktTag!=NULL) {
		    dstIf = srcIf;
		    AcquireInterfaceReference (dstIf);
		    goto GetPacket;
		  }
		}
		else {// Netbios quota exceded
		  IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
				  ("IpxFwd: Netbios quota exceded"
				   " for packet on interface %ld (icb:%0lx),"
				   " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				   srcIf->ICB_Index, srcIf, dstNet,
				   LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				   LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				   LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				   LookaheadBuffer[IPXH_PKTTYPE]));
		  InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
		}
		InterlockedIncrement (&NetbiosPacketsQuota);
	      }
	      else {	// Bad netbios packet
		IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
				("IpxFwd: Bad nb packet on interface %ld (icb:%0lx),"
				 " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
				 srcIf->ICB_Index, srcIf, dstNet,
				 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
				 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
				 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
				 LookaheadBuffer[IPXH_PKTTYPE]));
		InterlockedIncrement (&srcIf->ICB_Stats.InHdrErrors);
	      }
	    }
	    else { // Netbios accept disabled or to many routers crossed
	      KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	      InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
	      IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
			      ("IpxFwd: NB packet dropped on disabled interface %ld (icb:%0lx),"
			       " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
			       srcIf->ICB_Index, srcIf, dstNet,
			       LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
			       LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
			       LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
			       LookaheadBuffer[IPXH_PKTTYPE]));
	    }
	  }	// End netbios specific processing (else if netbios)
	}
	else {	// Looped back packets discarded without counting
	  // (We shouldn't get them in IPX stack does the right job)
	  KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	}
      }
      else {	// Interface is down or disabled
	KeReleaseSpinLock(&srcIf->ICB_Lock, oldIRQL);
	InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
	IpxFwdDbgPrint (DBG_RECV, DBG_WARNING,
			("IpxFwd: Packet dropped on disabled interface %ld (icb:%0lx),"
			 " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
			 srcIf->ICB_Index, srcIf, dstNet,
			 LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
			 LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
			 LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
			 LookaheadBuffer[IPXH_PKTTYPE]));
      }
    }
    else {	// Obvious header errors (shouldn't IPX do this for us ?
      InterlockedIncrement (&srcIf->ICB_Stats.InHdrErrors);
      IpxFwdDbgPrint (DBG_RECV, DBG_ERROR,
		      ("IpxFwd: Header errors in packet on interface %ld (icb:%0lx),"
		       " dst-%08lx:%02x%02x%02x%02x%02x%02x, type-%02x.\n",
		       srcIf->ICB_Index, srcIf, dstNet,
		       LookaheadBuffer[IPXH_DESTNODE], LookaheadBuffer[IPXH_DESTNODE+1],
		       LookaheadBuffer[IPXH_DESTNODE+2], LookaheadBuffer[IPXH_DESTNODE+3],
		       LookaheadBuffer[IPXH_DESTNODE+4], LookaheadBuffer[IPXH_DESTNODE+5],
		       LookaheadBuffer[IPXH_PKTTYPE]));
    }
    ReleaseInterfaceReference (srcIf);
  }	// We could not locate the interface from IPX supplied context: there
  // is just a little time window when interface is deleted
  // but IPX had already pushed the context on the stack
  else {
    IpxFwdDbgPrint (DBG_RECV, DBG_ERROR,
		    ("IpxFwd: Receive, type-%02x"
		     " - src interface context is invalid.\n",
		     LookaheadBuffer[IPXH_PKTTYPE]));
  }
  LeaveForwarder ();
  return FALSE ;

	       GetPacket:
	
  InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
  ReleaseInterfaceReference (srcIf);

  pktDscr = CONTAINING_RECORD (pktTag, NDIS_PACKET, ProtocolReserved);
  pktTag->PT_InterfaceReference = dstIf;
  pktTag->PT_PerfCounter = PerfCounter.QuadPart;

  // try to get the packet data
  IPXTransferData(&status,
		  MacBindingHandle,
		  MacReceiveContext,
		  LookaheadBufferOffset,   // start of IPX header
		  PacketSize, 	     // packet size starting at IPX header
		  pktDscr,
		  &BytesTransferred);

  if (status != NDIS_STATUS_PENDING) {
    // complete the frame processing (LeaveForwarder will be called there)
    IpxFwdTransferDataComplete(pktDscr, status, BytesTransferred);
  }
  return FALSE;
}


/*++
*******************************************************************
    F w T r a n s f e r D a t a C o m p l e t e

Routine Description:
	Called by the IPX stack when NIC driver completes data transger.
Arguments:
	pktDscr				- handle of NIC driver
	status				- result of the transfer
	bytesTransferred	- number of bytest trasferred
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdTransferDataComplete (
    PNDIS_PACKET	pktDscr,
	NDIS_STATUS		status,
	UINT			bytesTransferred) 
{
    PPACKET_TAG		pktTag;

    pktTag = (PPACKET_TAG)(&pktDscr->ProtocolReserved);

    // If transfer failed, release the packet and interface
    //
    if (status==NDIS_STATUS_SUCCESS) 
    {
        if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
        {
            // pmay: 260480
            // 
            // Increment the transport control field so that
            // the number of routers that this packet has
            // traversed is increased.  IpxFwdReceive will drop
            // all packets that have traversed more that 15 routers.
            //
            // Netbios packets will have their transport control
            // fields incremented by ProcessNetbiosPacket
            //
            *(pktTag->PT_Data + IPXH_XPORTCTL) += 1;
            
            SendPacket (pktTag->PT_InterfaceReference, pktTag);
        }
        else
        {
            ProcessNetbiosPacket (pktTag->PT_InterfaceReference, pktTag);
        }
    }
    else 
    {
        IpxFwdDbgPrint (DBG_RECV, DBG_ERROR,
            ("IpxFwd: Trans data failed: packet %08lx on if %08lx!\n",
            pktTag, pktTag->PT_InterfaceReference));

        // Record the fact that we're discarding
        //
        if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE) 
        {
            InterlockedIncrement (
            &pktTag->PT_InterfaceReference->ICB_Stats.OutDiscards);
        }

        // For netbios packets interface reference is
        // actually a source interface
        else 
        {	
            InterlockedIncrement (&NetbiosPacketsQuota);
            InterlockedIncrement (
                &pktTag->PT_InterfaceReference->ICB_Stats.InDiscards);
        }

        ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
        FreePacket (pktTag);
    }

    LeaveForwarder ();
    return;
}


/*++
*******************************************************************
    F w R e c e i v e C o m p l e t e

Routine Description:

		This routine receives control from the IPX driver after one or
		more receive operations have completed and no receive is in progress.
		It is called under less severe time constraints than IpxFwdReceive.
		It is used to process netbios queue

Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
IpxFwdReceiveComplete (
		       USHORT NicId
		       ) {

  // check that our configuration process has terminated OK
  if(!EnterForwarder ()) {
    return;
  }
  IpxFwdDbgPrint (DBG_RECV, DBG_INFORMATION, ("IpxFwd: FwdReceiveComplete.\n"));
  ScheduleNetbiosWorker ();
  LeaveForwarder ();
}

/*++
*******************************************************************
    I p x F w d I n t e r n a l R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet destined
	to local client was received by the NIC dirver.
Arguments:
	Context				- forwarder context associated with
							the NIC (interface block pointer)
	RemoteAddress		- sender's address
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
Return Value:
	STATUS_SUCCESS - the packet will be delivered to local destination
	STATUS_UNSUCCESSFUL - the packet will be dropped

*******************************************************************
--*/
NTSTATUS
IpxFwdInternalReceive (
		       IN ULONG_PTR				Context,
		       IN PIPX_LOCAL_TARGET	RemoteAddress,
		       IN PUCHAR				LookAheadBuffer,
		       IN UINT					LookAheadBufferSize
		       ) {
  NTSTATUS	status = STATUS_SUCCESS;
  PINTERFACE_CB	srcIf;

  if (!EnterForwarder ()) {
    return STATUS_UNSUCCESSFUL;
  }
  if (Context!=VIRTUAL_NET_FORWARDER_CONTEXT)	 {
    // Check if interface context supplied by IPX driver is valid
    srcIf = InterfaceContextToReference ((PVOID)Context, RemoteAddress->NicId);
  }
  else {
    srcIf = InternalInterface;
    AcquireInterfaceReference (srcIf);
  }

  if (srcIf!=NULL) {
    // Check if we can accept on this interface
    if (IS_IF_ENABLED (srcIf)
	&& (srcIf->ICB_Stats.OperationalState!=FWD_OPER_STATE_DOWN)
	&& ((*(LookAheadBuffer + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
	    || srcIf->ICB_NetbiosAccept)) {
      // Check if we can accept on internal interface
      if (IS_IF_ENABLED(InternalInterface)) {
	FILTER_ACTION   action;
	action = FltFilter (LookAheadBuffer, LookAheadBufferSize,
			    srcIf->ICB_FilterInContext,
			    InternalInterface->ICB_FilterOutContext);
	// Check the filter
	if (action==FILTER_PERMIT) {
	  // Update source interface statistics
	  InterlockedIncrement (&srcIf->ICB_Stats.InDelivers);
	  // Handle NB packets separatedly
	  if (*(LookAheadBuffer + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE) {
	    InterlockedIncrement (
				  &InternalInterface->ICB_Stats.OutDelivers);
	    IpxFwdDbgPrint (DBG_INT_RECV, DBG_INFORMATION,
			    ("IpxFwd: FwdInternalReceive,"
			     " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
			     " type-%02x.\n",
			     srcIf->ICB_Index, srcIf,
			     LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			     LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			     LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			     LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			     LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
			     LookAheadBuffer[IPXH_PKTTYPE]));
	  }
	  else {
	    // Check if destination netbios name is staticly assigned to
	    // an external interface or netbios delivery options do not
	    // allow us to deliver this packet
	    PINTERFACE_CB	dstIf;
	    USHORT			dstSock = GETUSHORT (LookAheadBuffer+IPXH_DESTSOCK);

	    InterlockedIncrement (&srcIf->ICB_Stats.NetbiosReceived);
	    // First try to find a static name if we have enough data
	    // in the lookahead buffer
	    if ((dstSock==IPX_NETBIOS_SOCKET)
		&& (LookAheadBufferSize>(NB_NAME+16)))
	      dstIf = FindNBDestination (LookAheadBuffer+(NB_NAME-IPXH_HDRSIZE));
	    else if ((dstSock==IPX_SMB_NAME_SOCKET)
		     && (LookAheadBufferSize>(SMB_NAME+16)))
	      dstIf = FindNBDestination (LookAheadBuffer+(SMB_NAME-IPXH_HDRSIZE));
	    else
	      dstIf = NULL;
	    // Now see, if we can deliver the packet
	    if ((((dstIf==NULL) || (dstIf==InternalInterface))
		 && (InternalInterface->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL))
		|| ((dstIf==InternalInterface)
		    && (InternalInterface->ICB_NetbiosDeliver==FWD_NB_DELIVER_STATIC))) {
	      InterlockedIncrement (
				    &InternalInterface->ICB_Stats.NetbiosSent);
	      InterlockedIncrement (
				    &InternalInterface->ICB_Stats.OutDelivers);
	      IpxFwdDbgPrint (DBG_INT_RECV, DBG_INFORMATION,
			      ("IpxFwd: FwdInternalReceive, NB"
			       " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x\n",
			       srcIf->ICB_Index, srcIf,
			       LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			       LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			       LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			       LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			       LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5]));
	    }
	    else {
	      InterlockedIncrement (
				    &InternalInterface->ICB_Stats.OutDiscards);
	      IpxFwdDbgPrint (DBG_INT_RECV, DBG_WARNING,
			      ("IpxFwd: FwdInternalReceive, NB dropped because delivery disabled"
			       " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x\n",
			       srcIf->ICB_Index, srcIf,
			       LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			       LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			       LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			       LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			       LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5]));
	      status = STATUS_UNSUCCESSFUL;
	    }
	    if (dstIf!=NULL)
	      ReleaseInterfaceReference (dstIf);
	  }
	}
	else {// Filtered Out
	  if (action==FILTER_DENY_OUT) {
	    InterlockedIncrement (
				  &InternalInterface->ICB_Stats.OutFiltered);
	    status=STATUS_UNSUCCESSFUL;
	  }
	  else {
	    ASSERT (action==FILTER_DENY_IN);
	    InterlockedIncrement (&srcIf->ICB_Stats.InFiltered);
	    status=STATUS_UNSUCCESSFUL;
	  }
	  IpxFwdDbgPrint (DBG_INT_RECV, DBG_WARNING,
			  ("IpxFwd: FwdInternalReceive, filtered out"
			   " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
			   " type-%02x.\n",
			   srcIf->ICB_Index, srcIf,
			   LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			   LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			   LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			   LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			   LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
			   LookAheadBuffer[IPXH_PKTTYPE]));
	}
      }
      else {// Internal interface is disabled
	InterlockedIncrement (
			      &InternalInterface->ICB_Stats.OutDiscards);
	status = STATUS_UNSUCCESSFUL;
	IpxFwdDbgPrint (DBG_INT_RECV, DBG_WARNING,
			("IpxFwd: FwdInternalReceive, internal if disabled"
			 " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
			 " type-%02x.\n",
			 srcIf->ICB_Index, srcIf,
			 LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
			 LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
			 LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
			 LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
			 LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
			 LookAheadBuffer[IPXH_PKTTYPE]));
      }
    }
    else {	// Disabled source interface
      InterlockedIncrement (&srcIf->ICB_Stats.InDiscards);
      IpxFwdDbgPrint (DBG_INT_RECV, DBG_ERROR,
		      ("IpxFwd: FwdInternalReceive, source if disabled"
		       " from %d(%lx)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
		       " type-%02x.\n",
		       srcIf->ICB_Index, srcIf,
		       LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
		       LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
		       LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
		       LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
		       LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
		       LookAheadBuffer[IPXH_PKTTYPE]));
      status = STATUS_UNSUCCESSFUL;
    }
    ReleaseInterfaceReference (srcIf);
  }
  else {	// Invalid source interface context
    IpxFwdDbgPrint (DBG_INT_RECV, DBG_ERROR,
		    ("IpxFwd: FwdInternalReceive, source if context is invalid"
		     " from (%lx:%d)-%.2x%.2x%.2x%.2x:%.2x%.2x%.2x%.2x%.2x%.2x,"
		     " type-%02x.\n",
		     Context, RemoteAddress->NicId,
		     LookAheadBuffer[IPXH_SRCNET],LookAheadBuffer[IPXH_SRCNET+1],
		     LookAheadBuffer[IPXH_SRCNET+2],LookAheadBuffer[IPXH_SRCNET+3],
		     LookAheadBuffer[IPXH_SRCNODE],LookAheadBuffer[IPXH_SRCNODE+1],
		     LookAheadBuffer[IPXH_SRCNODE+2],LookAheadBuffer[IPXH_SRCNODE+3],
		     LookAheadBuffer[IPXH_SRCNODE+4],LookAheadBuffer[IPXH_SRCNODE+5],
		     LookAheadBuffer[IPXH_PKTTYPE]));
    status = STATUS_UNSUCCESSFUL;
  }
  LeaveForwarder ();
  return status;
}

/*++
*******************************************************************
    D e l e t e R e c v Q u e u e

Routine Description:
	Initializes the netbios bradcast queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteRecvQueue (
		 void
		 ) {
  //	while (!IsListEmpty (&RecvQueue)) {
  //		PPACKET_TAG pktTag = CONTAINING_RECORD (RecvQueue.Flink,
  //											PACKET_TAG,
  //											PT_QueueLink);
  //		RemoveEntryList (&pktTag->PT_QueueLink);
  //		if (pktTag->PT_InterfaceReference!=NULL) {
  //			ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
  //		}
  //		FreePacket (pktTag);
  //	}
}
#if DBG

ULONG	  DbgFilterTrap = 0;  // 1 - on dst and src (net + node),
// 2 - on dst (net + node),
// 3 - on src (net + node),
// 4 - on dst (net + node + socket)

UCHAR	  DbgFilterDstNet[4];
UCHAR	  DbgFilterDstNode[6];
UCHAR	  DbgFilterDstSocket[2];
UCHAR	  DbgFilterSrcNet[4];
UCHAR	  DbgFilterSrcNode[6];
UCHAR	  DbgFilterSrcSocket[2];
PUCHAR	  DbgFilterFrame;

VOID
DbgFilterReceivedPacket(PUCHAR	    hdrp)
{
  switch(DbgFilterTrap) {

  case 1:

    if(!memcmp(hdrp + IPXH_DESTNET, DbgFilterDstNet, 4) &&
       !memcmp(hdrp + IPXH_DESTNODE, DbgFilterDstNode, 6) &&
       !memcmp(hdrp + IPXH_SRCNET, DbgFilterSrcNet, 4) &&
       !memcmp(hdrp + IPXH_SRCNODE, DbgFilterSrcNode, 6)) {

      DbgBreakPoint();
    }

    break;

  case 2:

    if(!memcmp(hdrp + IPXH_DESTNET, DbgFilterDstNet, 4) &&
       !memcmp(hdrp + IPXH_DESTNODE, DbgFilterDstNode, 6)) {

      DbgBreakPoint();
    }

    break;

  case 3:

    if(!memcmp(hdrp + IPXH_SRCNET, DbgFilterSrcNet, 4) &&
       !memcmp(hdrp + IPXH_SRCNODE, DbgFilterSrcNode, 6)) {

      DbgBreakPoint();
    }

    break;

  case 4:

    if(!memcmp(hdrp + IPXH_DESTNET, DbgFilterDstNet, 4) &&
       !memcmp(hdrp + IPXH_DESTNODE, DbgFilterDstNode, 6) &&
       !memcmp(hdrp + IPXH_DESTSOCK, DbgFilterDstSocket, 2)) {

      DbgBreakPoint();
    }

    break;

  default:

    break;
  }

  DbgFilterFrame = hdrp;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\rcvind.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\rcvind.h

Abstract:
	Receive indication processing

Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_RCVIND
#define _IPXFWD_RCVIND

// Doesn't allow accepting packets (for routing) from dial-in clients
extern BOOLEAN	ThisMachineOnly;

/*++
*******************************************************************
    I n i t i a l i z e R e c v Q u e u e

Routine Description:
	Initializes recv queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
//VOID
//DeleteRecvQueue (
//	void
//	)
#define InitializeRecvQueue()	{				\
}

/*++
*******************************************************************
    D e l e t e R e c v Q u e u e

Routine Description:
	Deletes recv queue
Arguments:
	None
Return Value:
	None

*******************************************************************
--*/
VOID
DeleteRecvQueue (
	void
	);
	
/*++
*******************************************************************
    F w R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet was
	received by the NIC dirver.  Only external destined packets are
	indicated by this routine (with the exception of Netbios boradcasts
	that indicated both for internal and external handlers)
Arguments:
	MacBindingHandle	- handle of NIC driver
	MaxReceiveContext	- NIC driver context
	Context				- forwarder context associated with
							the NIC (interface block pointer)
	RemoteAddress		- sender's address
	MacOptions			-
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
	LookaheadBufferOffset - offset of lookahead buffer in the physical
							packet
Return Value:
	None

*******************************************************************
--*/
BOOLEAN
IpxFwdReceive (
	NDIS_HANDLE			MacBindingHandle,
	NDIS_HANDLE			MacReceiveContext,
	ULONG_PTR			Context,
	PIPX_LOCAL_TARGET	RemoteAddress,
	ULONG				MacOptions,
	PUCHAR				LookaheadBuffer,
	UINT				LookaheadBufferSize,
	UINT				LookaheadBufferOffset,
	UINT				PacketSize,
    PMDL                pMdl

	);


/*++
*******************************************************************
    F w T r a n s f e r D a t a C o m p l e t e

Routine Description:
	Called by the IPX stack when NIC driver completes data transger.
Arguments:
	pktDscr				- handle of NIC driver
	status				- result of the transfer
	bytesTransferred	- number of bytest trasferred
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdTransferDataComplete (
	PNDIS_PACKET	pktDscr,
	NDIS_STATUS		status,
	UINT			bytesTransferred
	);


/*++
*******************************************************************
    F w T r a n s f e r D a t a C o m p l e t e

Routine Description:

		This routine receives control from the IPX driver after one or
		more receive operations have completed and no receive is in progress.
		It is called under less severe time constraints than IpxFwdReceive.
		It is used to process netbios queue

Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
IpxFwdReceiveComplete (
	USHORT	NicId
	);

/*++
*******************************************************************
    F w R e c e i v e

Routine Description:
	Called by the IPX stack to indicate that the IPX packet destined
	to local client was received by the NIC dirver.
Arguments:
	Context				- forwarder context associated with
							the NIC (interface block pointer)
	RemoteAddress		- sender's address
	LookaheadBuffer		- packet lookahead buffer that contains complete
							IPX header
	LookaheadBufferSize	- its size (at least 30 bytes)
Return Value:
	STATUS_SUCCESS - the packet will be delivered to local destination
	STATUS_UNSUCCESSFUL - the packet will be dropped

*******************************************************************
--*/
NTSTATUS
IpxFwdInternalReceive (
	IN ULONG_PTR			FwdAdapterContext,
	IN PIPX_LOCAL_TARGET	RemoteAddress,
	IN PUCHAR				LookAheadBuffer,
	IN UINT					LookAheadBufferSize
	);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\registry.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\registry.h

Abstract:
    IPX Forwarder Driver registry interface


Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef _IPXFWD_REGISTRY_
#define _IPXFWD_REGISTRY_

/*++
*******************************************************************
    R e a d I p x D e v i c e N a m e

Routine Description:
	Allocates buffer and reads device name exported by the IPX stack
	into it
Arguments:
	FileName - pointer to variable to hold the name buffer
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
	STATUS_OBJECT_NAME_NOT_FOUND - if name value is not found
*******************************************************************
--*/
NTSTATUS
ReadIpxDeviceName (
	PWSTR		*FileName
	);

/*++
*******************************************************************
	G e t R o u t e r P a r a m e t e r s

Routine Description:
	Reads the parameters from the registry or sets the defaults
Arguments:
	RegistryPath - where to read from.
Return Value:
    STATUS_SUCCESS
*******************************************************************
--*/
NTSTATUS
GetForwarderParameters (
	IN PUNICODE_STRING RegistryPath
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\rwlock.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\rwlock.h

Abstract:
    Reader-Writer lock macros


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFWD_RWLOCK_
#define _IPXFWD_RWLOCK_

typedef volatile LONG VOLCTR, *PVOLCTR;
typedef PVOLCTR RWCOOKIE, *PRWCOOKIE;

// Reader- writer lock.
// Allows no-lock access to the tables for readers - they merely
// increment the counter to record their presence upon entrance
// and decrement the same counter as they leave.
// Writers are supposed to be serialized (externally) and their
// actions are limited to ATOMIC insertions of new elements and
// ATOMIC removals/replacements. The removals/replacements MUST
// be followed by a wait for all potential readers who might still
// be using the element that was removed/replaced

typedef struct _RW_LOCK {
        KEVENT                          Event;                  // Event to release waiting writer
        VOLCTR                          Ctr1;                   // Two alternating
        VOLCTR                          Ctr2;                   // reader counters
        volatile PVOLCTR        CurCtr;                 // Counter currently in use
} RW_LOCK, *PRW_LOCK;


/*++
*******************************************************************
    I n i t i a l i z e R W L o c k

Routine Description:
        Initializes RW lock
Arguments:
        lock - pointer to lock to initialize
Return Value:
        None
*******************************************************************
--*/
//VOID
//InitializeRWLock (
//      PRW_LOCK        lock
//      );
#define InitializeRWLock(lock)  {                       \
        KeInitializeEvent (&(lock)->Event,              \
                                SynchronizationEvent,           \
                                FALSE);                                         \
        (lock)->Ctr1 = (lock)->Ctr2 = 0;                \
        (lock)->CurCtr = &(lock)->Ctr1;                 \
}

/*++
*******************************************************************
    A c q u i r e R e a d e r A c c e s s

Routine Description:
        Acquires reader access to resource protected by the lock
Arguments:
        lock - pointer to lock
        cookie - pointer to buffer to store lock state for subsequent
                        release operation
Return Value:
        None
*******************************************************************
--*/
//VOID
//AcquireReaderAccess (
//      IN      PRW_LOCK        lock,
//      OUT     RWCOOKIE        cookie
//      );
#define AcquireReaderAccess(lock,cookie)                                                        \
    do {                                                                                                                        \
                register LONG   local,local1;                                                           \
            cookie = (lock)->CurCtr;    /*Get current counter pointer*/ \
                local = *(cookie);                      /*Copy counter value*/                  \
        local1 = local + 1;                                         \
                if ((local>=0)                          /*If counter is valid*/                 \
                                                                        /*and it hasn't changed while*/ \
                                                                        /*we were checking and trying*/ \
                                                                        /*to increment it,*/                    \
                                && (InterlockedCompareExchange (                                        \
                                                (PLONG)(cookie),                                                      \
                                                local1,                                                        \
                                                local)                                                           \
                                        ==local))                                                                \
                        break;                                  /*then we obtained the access*/ \
        } while (1)     /*otherwise, we have to do it again (possibly with*/\
                                /*the other counter if writer switched it on us)*/


/*++
*******************************************************************
    R e l e a s e R e a d e r A c c e s s

Routine Description:
        Releases reader access to resource protected by the lock
Arguments:
        lock - pointer to lock
        cookie - lock state for subsequent stored during acquire operation
Return Value:
        None
*******************************************************************
--*/
//VOID
//ReleaseReaderAccess (
//      IN      PRW_LOCK        lock,
//      IN      RWCOOKIE        cookie
//      );
#define ReleaseReaderAccess(lock,cookie) {                                              \
        /*If counter drops below 0, we have to signal the writer*/      \
        if (InterlockedDecrement((PLONG)cookie)<0) {                            \
                LONG    res;                                                                                    \
                ASSERT (*(cookie)==-1);                                                                 \
                res = KeSetEvent (&(lock)->Event, 0, FALSE);                    \
                ASSERT (res==0);                                                                                \
        }                                                                                                                       \
}

/*++
*******************************************************************
    W a i t F o r A l l R e a d e r s

Routine Description:
        Waits for all readers that were accessing the resource prior
        to the call to exit (New readers are not included)
Arguments:
        lock - pointer to lock
Return Value:
        None
*******************************************************************
--*/
//VOID
//WaitForAllReaders (
//      PRW_LOCK                lock
//      );
#define WaitForAllReaders(lock)                 {       \
        RWCOOKIE        prevCtr = (lock)->CurCtr;       \
                /*Switch the counter first*/            \
        if (prevCtr==&(lock)->Ctr1) {                   \
                (lock)->Ctr2 = 0;                                       \
                (lock)->CurCtr = &(lock)->Ctr2;         \
        }                                                                               \
        else {                                                                  \
                ASSERT (prevCtr==&(lock)->Ctr2);        \
                (lock)->Ctr1 = 0;                                       \
                (lock)->CurCtr = &(lock)->Ctr1;         \
        }                                                                               \
                /* If not all readers are gone, we'll have to wait for them*/   \
        if (InterlockedDecrement((PLONG)prevCtr)>=0) {  \
                NTSTATUS status                                         \
                         = KeWaitForSingleObject (              \
                                                &(lock)->Event,         \
                                                Executive,                      \
                                                ExGetPreviousMode(),\
                                                FALSE,                          \
                                                0);                                     \
                ASSERT (NT_SUCCESS(status));            \
                ASSERT (*prevCtr==-1);                          \
        }                                                                               \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\send.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\send.c

Abstract:
	Send routines

Author:

    Vadim Eydelman

Revision History:

--*/
#ifndef IPXFWD_SEND
#define IPXFWD_SEND

typedef struct _INTERNAL_PACKET_TAG {
	LIST_ENTRY			IPT_QueueLink;
	PNDIS_PACKET		IPT_Packet;
	PUCHAR				IPT_DataPtr;
	ULONG				IPT_Length;
	PINTERFACE_CB		IPT_InterfaceReference;
	IPX_LOCAL_TARGET	IPT_Target;
} INTERNAL_PACKET_TAG, *PINTERNAL_PACKET_TAG;


#define DEF_SPOOFING_TIMEOUT	(120*60)	// Seconds
extern ULONG			SpoofingTimeout;
extern LIST_ENTRY		SpoofingQueue;
extern KSPIN_LOCK		SpoofingQueueLock;
extern WORK_QUEUE_ITEM	SpoofingWorker;
extern BOOLEAN			SpoofingWorkerActive;
extern ULONG			DontSuppressNonAgentSapAdvertisements;
VOID
Spoofer (
	PVOID	Context
	);
	
#define InitializeSendQueue() {								\
	InitializeListHead (&SpoofingQueue);					\
	KeInitializeSpinLock (&SpoofingQueueLock);				\
	ExInitializeWorkItem (&SpoofingWorker, Spoofer, NULL);	\
	SpoofingWorkerActive = FALSE;							\
}

#define DeleteSendQueue()	{											\
	while (!IsListEmpty (&SpoofingQueue)) {								\
		PPACKET_TAG pktTag = CONTAINING_RECORD (SpoofingQueue.Flink,	\
										PACKET_TAG,						\
										PT_QueueLink);					\
		RemoveEntryList (&pktTag->PT_QueueLink);						\
		if (pktTag->PT_InterfaceReference!=NULL)						\
			ReleaseInterfaceReference (pktTag->PT_InterfaceReference);	\
		FreePacket (pktTag);											\
	}																	\
}
	

/*++
*******************************************************************
    S e n d P a c k e t 

Routine Description:
	Enqueues packets to be sent by IPX stack
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	None

*******************************************************************
--*/
VOID
SendPacket (
	PINTERFACE_CB		dstIf,
	PPACKET_TAG		    pktTag
	);

/*++
*******************************************************************
    F w S e n d C o m p l e t e

Routine Description:
	Called by IPX stack when send completes asynchronously
Arguments:
	pktDscr	- descriptor of the completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdSendComplete (
	PNDIS_PACKET	pktDscr,
	NDIS_STATUS		NdisStatus
	);

/*++
*******************************************************************
	
	F w I n t e r n a l S e n d

Routine Description:
	Filter and routes packets sent by IPX stack
Arguments:
   LocalTarget		- the NicId and next hop router MAC address
   Context			- preferred interface on which to send
   Packet			- packet to be sent
   ipxHdr			- pointer to ipx header inside the packet
   PacketLength		- length of the packet
   fIterate         - a flag to indicate if this is a packet for the 
                        iteration of which the Fwd takes responsibility
                        - typically type 20 NetBIOS frames

Return Value:

   STATUS_SUCCESS - if the preferred NIC was OK and packet passed filtering
   STATUS_NETWORK_UNREACHABLE - if the preferred was not OK or packet failed filtering
   STATUS_PENDING - packet was queued until connection is established
*******************************************************************
--*/
NTSTATUS
IpxFwdInternalSend (
	IN OUT PIPX_LOCAL_TARGET	LocalTarget,
	IN ULONG_PTR				Context,
	IN PNDIS_PACKET				pktDscr,
	IN PUCHAR					ipxHdr,
	IN PUCHAR					data,
	IN ULONG					PacketLength,
    IN BOOLEAN                  fIterate
	);

/*++
*******************************************************************

	P r o c e s s I n t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface internal queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessInternalQueue (
	PINTERFACE_CB	dstIf
	);


/*++
*******************************************************************

	P r o c e s s E x t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface external queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessExternalQueue (
	PINTERFACE_CB	dstIf
	);
/*++
*******************************************************************
    D o S e n d 

Routine Description:
	Prepares and sends packet.  Interface lock must be help while
	callin this routine
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	result returned by IPX

*******************************************************************
--*/
NDIS_STATUS
DoSend (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	KIRQL			oldIRQL
	);

/*++
*******************************************************************
    P r o c e s s S e n t P a c k e t

Routine Description:
	Process completed sent packets
Arguments:
	dstIf	- interface over which packet was sent
	pktTag	- completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessSentPacket (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	NDIS_STATUS		status
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\tables.c ===
#include "precomp.h"

// Memory zone for interfaces
ZONE_HEADER		InterfaceZone;
// Segment size in interface sone
ULONG			InterfaceSegmentSize=
			sizeof(INTERFACE_CB)*NUM_INTERFACES_PER_SEGMENT
			+sizeof (ZONE_SEGMENT_HEADER);
KSPIN_LOCK		InterfaceZoneLock;

// Interface tables
LIST_ENTRY		*InterfaceIndexHash;	// Hash by interface index
PINTERFACE_CB	*ClientNodeHash;	// Hash by node on qlobal net
INTERFACE_CB	TheInternalInterface; // The internal interface
PINTERFACE_CB	InternalInterface=&TheInternalInterface; 
KSPIN_LOCK	InterfaceTableLock;	// Protection for interface hash tables

// Memory Zone for routes
ZONE_HEADER		RouteZone;
// Segment size in route sone
ULONG			RouteSegmentSize=DEF_ROUTE_SEGMENT_SIZE;
KSPIN_LOCK		RouteZoneLock;

// Route tables
PFWD_ROUTE		*RouteHash;
PFWD_ROUTE	GlobalRoute;
ULONG		GlobalNetwork;


// NB Route table
PNB_ROUTE		*NBRouteHash;


// Reader-writer lock to wait for all readers to drain when
// updating the route tables
RW_LOCK			RWLock;
// Mutex to serialize writers to route tables
FAST_MUTEX		WriterMutex;


// Sizes of the tables
ULONG			RouteHashSize;		// Must be specified
ULONG			InterfaceHashSize=DEF_INTERFACE_HASH_SIZE;
ULONG			ClientHashSize=DEF_CLIENT_HASH_SIZE;
ULONG			NBRouteHashSize=DEF_NB_ROUTE_HASH_SIZE;

//*** max send pkts queued limit: over this limit the send pkts get discarded
ULONG	MaxSendPktsQueued = MAX_SEND_PKTS_QUEUED;
INT		WanPacketListId = -1;

// Initial memory block allocated for the tables
CHAR	*TableBlock = NULL;

ULONG InterfaceAllocCount = 0;
ULONG InterfaceFreeCount = 0;

// Hash functions
#define InterfaceIndexHashFunc(Interface) (Interface%InterfaceHashSize)
#define ClientNodeHashFunc(Node64) ((UINT)(Node64%ClientHashSize))
#define NetworkNumberHashFunc(Network) (Network%RouteHashSize)
#define NetbiosNameHashFunc(Name128) ((UINT)(Name128[0]+Name128[1])%NBRouteHashSize)

/*++
*******************************************************************
    A l l o c a t e R o u t e

Routine Description:
    Allocates memory for route from memory zone reserved
	for route storage.  Extends zone if there are no
	free blocks in currently allocated segements.
Arguments:
    None
Return Value:
	Pointer to allocated route

*******************************************************************
--*/
PFWD_ROUTE
AllocateRoute (
	void
	) {
	PFWD_ROUTE	fwRoute;
	KIRQL		oldIRQL;

	KeAcquireSpinLock (&RouteZoneLock, &oldIRQL);
		// Check if there are free blocks in the zone
	if (ExIsFullZone (&RouteZone)) {
			// Try to allocate new segment if not
		NTSTATUS	status;
		PVOID	segment = ExAllocatePoolWithTag
					(NonPagedPool, RouteSegmentSize, FWD_POOL_TAG);
		if (segment==NULL) {
			KeReleaseSpinLock (&RouteZoneLock, oldIRQL);
			IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Can't allocate route zone segment.\n"));
			return NULL;
		}
		status = ExExtendZone (&RouteZone, segment, RouteSegmentSize);
		ASSERTMSG ("Could not extend RouteZone ", NT_SUCCESS (status));
	}
	fwRoute = (PFWD_ROUTE)ExAllocateFromZone (&RouteZone);
	KeReleaseSpinLock (&RouteZoneLock, oldIRQL);
	return fwRoute;
}

/*++
*******************************************************************
    F r e e R o u t e

Routine Description:
    Releases memory allocated for route to route memory
	zone.
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
VOID
FreeRoute (
	PFWD_ROUTE	fwRoute
	) {
	IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_INFORMATION,
		("IpxFwd: Freeing route block %08lx.\n", fwRoute));
	ASSERT (fwRoute->FR_InterfaceReference==NULL);
	ExInterlockedFreeToZone(&RouteZone,fwRoute,&RouteZoneLock);
}


/*++
*******************************************************************
    A l l o c a t e I n t e r f a c e

Routine Description:
    Allocates memory for interface from memory zone reserved
	for interface storage.  Extends zone if there are no
	free blocks in currently allocated segements.
Arguments:
    None
Return Value:
	Pointer to allocated route

*******************************************************************
--*/
PINTERFACE_CB
AllocateInterface (
	void
	) {
	PINTERFACE_CB	ifCB;
	KIRQL		oldIRQL;

	KeAcquireSpinLock (&RouteZoneLock, &oldIRQL);
		// Check if there are free blocks in the zone
	if (ExIsFullZone (&InterfaceZone)) {
			// Try to allocate new segment if not
		NTSTATUS	status;
		PVOID	segment = ExAllocatePoolWithTag
					(NonPagedPool, InterfaceSegmentSize, FWD_POOL_TAG);
		if (segment==NULL) {
			KeReleaseSpinLock (&RouteZoneLock, oldIRQL);
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR, 
					("IpxFwd: Can't allocate interface zone segment.\n"));
			return NULL;
		}
		status = ExExtendZone (&InterfaceZone, segment, InterfaceSegmentSize);
		ASSERTMSG ("Could not extend InterfaceZone ", NT_SUCCESS (status));
	}
	ifCB = (PINTERFACE_CB)ExAllocateFromZone (&InterfaceZone);
	KeReleaseSpinLock (&RouteZoneLock, oldIRQL);

    InterlockedIncrement(&InterfaceAllocCount);
	
	return ifCB;
}

/*++
*******************************************************************
    F r e e I n t e r f a c e

Routine Description:
    Releases memory allocated for interface to interface memory
	zone.
Arguments:
	fwRoute - route block to release
Return Value:
	None
*******************************************************************
--*/
VOID
FreeInterface (
	PINTERFACE_CB	ifCB
	) {
	KIRQL		oldIRQL;

	IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
		("IpxFwd: Freeing icb %08lx.\n", ifCB));

	ASSERT(ifCB->ICB_Stats.OperationalState==FWD_OPER_STATE_DOWN);
	KeAcquireSpinLock (&InterfaceZoneLock, &oldIRQL);
	ExFreeToZone(&InterfaceZone, ifCB);
	KeReleaseSpinLock (&InterfaceZoneLock, oldIRQL);


	InterlockedIncrement(&InterfaceFreeCount);

}

/*++
*******************************************************************
    C r e a t e T a b l e s

Routine Description:
	Allocates and intializes all hash tables and related structures
Arguments:
	None
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
*******************************************************************
--*/
NTSTATUS
CreateTables (
	void
	) {
	UINT		i;
	CHAR 		*segment;
	NTSTATUS	status;
	ULONG		blockSize;

	ASSERT (TableBlock==NULL);

	blockSize = (ULONG) ROUND_TO_PAGES (
					InterfaceHashSize*sizeof(*InterfaceIndexHash)
					+ClientHashSize*sizeof(*ClientNodeHash)
					+RouteHashSize*sizeof(*RouteHash)
					+NBRouteHashSize*sizeof(*NBRouteHash)
					+InterfaceSegmentSize
					+RouteSegmentSize
					);

		// Allocate first segment for route zone
	TableBlock = segment = (CHAR *)ExAllocatePoolWithTag (
						NonPagedPool, blockSize, FWD_POOL_TAG);
	if (segment!=NULL) {
		InterfaceIndexHash = (LIST_ENTRY *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(InterfaceIndexHash+InterfaceHashSize),ULONGLONG);

		ClientNodeHash = (PINTERFACE_CB *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(ClientNodeHash+ClientHashSize),ULONGLONG);
		
		RouteHash = (PFWD_ROUTE *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(RouteHash + RouteHashSize),ULONGLONG);

		NBRouteHash = (PNB_ROUTE *)segment;
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(NBRouteHash + NBRouteHashSize),ULONGLONG);

		status = ExInitializeZone (&InterfaceZone,
								ALIGN_UP(sizeof (INTERFACE_CB),ULONGLONG),
								segment,
								InterfaceSegmentSize);
		ASSERTMSG ("Could not initalize InterfaceZone ",
										NT_SUCCESS (status));
		segment = (CHAR *)ALIGN_UP((ULONG_PTR)(segment+InterfaceSegmentSize),ULONGLONG);

		status = ExInitializeZone (&RouteZone,
									ALIGN_UP(sizeof (FWD_ROUTE), ULONGLONG),
									segment,
									blockSize - (ULONG)(segment - TableBlock));

		ASSERTMSG ("Could not initalize RouteZone ", NT_SUCCESS (status));
			
		
		// No global route yet
		GlobalRoute = NULL;
		GlobalNetwork = 0xFFFFFFFF;

		InternalInterface = &TheInternalInterface;
		InitICB (InternalInterface,
					FWD_INTERNAL_INTERFACE_INDEX,
					FWD_IF_PERMANENT,
					TRUE,
					FWD_NB_DELIVER_ALL);
#if DBG
		InitializeListHead (&InternalInterface->ICB_InSendQueue);
#endif

		KeInitializeSpinLock (&InterfaceTableLock);
		KeInitializeSpinLock (&InterfaceZoneLock);
		KeInitializeSpinLock (&RouteZoneLock);
		InitializeRWLock (&RWLock);
		ExInitializeFastMutex (&WriterMutex);

			// Initialize hash tables buckets
		for (i=0; i<InterfaceHashSize; i++)
			InitializeListHead (&InterfaceIndexHash[i]);

		for (i=0; i<ClientHashSize; i++) {
			ClientNodeHash[i] = NULL;
		}

		for (i=0; i<RouteHashSize; i++) {
			RouteHash[i] = NULL;
		}

		for (i=0; i<NBRouteHashSize; i++) {
			NBRouteHash[i] = NULL;
		}
		return STATUS_SUCCESS;
	}
	else {
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Could not allocate table block!\n"));
	}

	return STATUS_INSUFFICIENT_RESOURCES;
}

/*++
*******************************************************************
    D e l e t e T a b l e s

Routine Description:
	Releases resources allocated for all hash tables
Arguments:
	None
Return Value:
	STATUS_SUCCESS - tables were freed ok
*******************************************************************
--*/
NTSTATUS
DeleteTables (
	void
	) {
	UINT		i;
	PVOID		segment;


	if (TableBlock==NULL) {
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR, ("Tables already deleted.\n"));
		return STATUS_SUCCESS;
	}
		// First get rid of all routes
		// (that should release all references to interface
		// control blocks
	for (i=0; i<RouteHashSize; i++) {
		while (RouteHash[i]!=NULL) {
			PFWD_ROUTE	fwRoute = RouteHash[i];
			RouteHash[i] = fwRoute->FR_Next;
			if (fwRoute->FR_InterfaceReference!=GLOBAL_INTERFACE_REFERENCE) {
				ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
			}
			fwRoute->FR_InterfaceReference = NULL;
			ReleaseRouteReference (fwRoute);
		}
	}
		// Don't forget about global route
	if (GlobalRoute!=NULL) {
		GlobalRoute->FR_InterfaceReference = NULL;
		ReleaseRouteReference (GlobalRoute);
		GlobalRoute = NULL;
		GlobalNetwork = 0xFFFFFFFF;
	}

		// Now we should be able to release all interfaces
	for (i=0; i<InterfaceHashSize; i++) {
		while (!IsListEmpty (&InterfaceIndexHash[i])) {
			PINTERFACE_CB ifCB = CONTAINING_RECORD (InterfaceIndexHash[i].Flink,
														INTERFACE_CB,
														ICB_IndexHashLink);
			RemoveEntryList (&ifCB->ICB_IndexHashLink);
			if (ifCB->ICB_Stats.OperationalState==FWD_OPER_STATE_UP) {
				switch (ifCB->ICB_InterfaceType) {
				case FWD_IF_PERMANENT:
					DeregisterPacketConsumer (ifCB->ICB_PacketListId);
					break;
				case FWD_IF_DEMAND_DIAL:
				case FWD_IF_LOCAL_WORKSTATION:
				case FWD_IF_REMOTE_WORKSTATION:
					break;
				default:
					ASSERTMSG ("Invalid interface type ", FALSE);
					break;
				}
				if (ifCB->ICB_CashedInterface!=NULL)
					ReleaseInterfaceReference (ifCB->ICB_CashedInterface);
				ifCB->ICB_CashedInterface = NULL;
				if (ifCB->ICB_CashedRoute!=NULL)
					ReleaseRouteReference (ifCB->ICB_CashedRoute);
				ifCB->ICB_CashedRoute = NULL;
				if (ifCB->ICB_Network==GlobalNetwork)
					DeleteGlobalNetClient (ifCB);
				IPXCloseAdapterProc (ifCB->ICB_AdapterContext);
                ReleaseInterfaceReference (ifCB);   // Binding reference
			}

			if (IS_IF_CONNECTING (ifCB)) {
				SET_IF_NOT_CONNECTING (ifCB);
				DequeueConnectionRequest (ifCB);
			}

			while (!IsListEmpty (&ifCB->ICB_ExternalQueue)) {
				PPACKET_TAG					pktTag;

				pktTag = CONTAINING_RECORD (ifCB->ICB_ExternalQueue.Flink,
											PACKET_TAG, PT_QueueLink);
				RemoveEntryList (&pktTag->PT_QueueLink);
				ReleaseInterfaceReference (pktTag->PT_InterfaceReference);
				FreePacket (pktTag);
			}

			while (!IsListEmpty (&ifCB->ICB_InternalQueue)) {
				PINTERNAL_PACKET_TAG		pktTag;

				pktTag = CONTAINING_RECORD (ifCB->ICB_InternalQueue.Flink,
									INTERNAL_PACKET_TAG, IPT_QueueLink);
				RemoveEntryList (&pktTag->IPT_QueueLink);
				IPXInternalSendCompletProc (&pktTag->IPT_Target,
							pktTag->IPT_Packet,
							pktTag->IPT_Length,
							STATUS_NETWORK_UNREACHABLE);
				ReleaseInterfaceReference (pktTag->IPT_InterfaceReference);
				ExFreePool (pktTag);
			}

			ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
			if (ifCB->ICB_NBRoutes!=NULL) {
				DeleteNBRoutes (ifCB->ICB_NBRoutes, ifCB->ICB_NBRouteCount);
				ifCB->ICB_NBRoutes = NULL;
			}
			ReleaseInterfaceReference (ifCB);
		}
	}

	if (InternalInterface->ICB_NBRoutes!=NULL) {
		DeleteNBRoutes (InternalInterface->ICB_NBRoutes,
							InternalInterface->ICB_NBRouteCount);
		InternalInterface->ICB_NBRoutes = NULL;
	}
    if (InternalInterface->ICB_Stats.OperationalState==FWD_OPER_STATE_UP) {
        InternalInterface->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;
        ReleaseInterfaceReference (InternalInterface);  // Binding reference
    }
	ReleaseInterfaceReference (InternalInterface);



		// Release extra memory segments used for route table entries
	segment = PopEntryList (&RouteZone.SegmentList);
	while (RouteZone.SegmentList.Next!=NULL) {
		ExFreePool (segment);
		segment = PopEntryList (&RouteZone.SegmentList);
	}

		// Release extra memory segments used for interface table entries
	segment = PopEntryList (&InterfaceZone.SegmentList);
	while (InterfaceZone.SegmentList.Next!=NULL) {
		ExFreePool (segment);
		segment = PopEntryList (&InterfaceZone.SegmentList);
	}

	ExFreePool (TableBlock);
	TableBlock = NULL;
	return STATUS_SUCCESS;
}

/*++
*******************************************************************
    L o c a t e I n t e r f a c e

Routine Description:
	Finds interface control block in interface
	index hash table.  Optionally returns the 
	insertion point pointer if interface block
	with given index is not in the table.
Arguments:
	InterfaceIndex - unique id of the interface
	insertBefore - buffer to place the pointer to
					hash table element where interface
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to interface control block if found
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
LocateInterface (
	ULONG			InterfaceIndex,
	PLIST_ENTRY		*insertBefore OPTIONAL
	) {
	PLIST_ENTRY		cur;
	PINTERFACE_CB	ifCB;
	PLIST_ENTRY		HashList;

	ASSERT (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX);

		// Find hash bucket
	HashList = &InterfaceIndexHash[InterfaceIndexHashFunc(InterfaceIndex)];
	cur = HashList->Flink;
		// Walk the list
	while (cur!=HashList) {
		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);

		if (ifCB->ICB_Index==InterfaceIndex)
				// Found, return it (insertion point is irrelevant)
			return ifCB;
		else if (ifCB->ICB_Index>InterfaceIndex)
				// No chance to find it
			break;
		cur = cur->Flink;
	}
		// Return insertion point if asked
	if (ARGUMENT_PRESENT(insertBefore))
		*insertBefore = cur;
	return NULL;
}

/*++
*******************************************************************
    L o c a t e C l i e n t I n t e r f a c e

Routine Description:
	Finds interface control block in client
	node hash bucket.  Optionally returns the 
	insertion point pointer if interface block
	with given node is not in the table
Arguments:
	ClientNode - node address of the client on global network
	insertBefore - buffer to place the pointer to
					hash table element where interface
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to interface control block if found
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
LocateClientInterface (
	ULONGLONG		*NodeAddress64,
	PINTERFACE_CB	**prevLink OPTIONAL
	) {
	PINTERFACE_CB	cur, *prev;

	prev = &ClientNodeHash[ClientNodeHashFunc (*NodeAddress64)];
	cur = *prev;
	while (cur!=NULL) {
		if (*NodeAddress64==cur->ICB_ClientNode64[0])
			break;
		else if (*NodeAddress64>cur->ICB_ClientNode64[0]) {
			// No chance to find it
			cur = NULL;
			break;
		}
		prev = &cur->ICB_NodeHashLink;
		cur = cur->ICB_NodeHashLink;
	}
	if (ARGUMENT_PRESENT(prevLink))
		*prevLink = prev;
	return cur;
}

/*++
*******************************************************************
    L o c a t e R o u t e

Routine Description:
	Finds route block in network number
	hash table.  Optionally returns the 
	insertion point pointer if route
	for given destination netowrk is not in the table
Arguments:
	Network - destination netowork number
	insertBefore - buffer to place the pointer to
					hash table element where route
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to route block if found
	NULL otherwise
*******************************************************************
--*/
PFWD_ROUTE
LocateRoute (
	ULONG			Network,
	PFWD_ROUTE		**prevLink OPTIONAL
	) {
	PFWD_ROUTE		cur, *prev;

	prev = &RouteHash[NetworkNumberHashFunc(Network)];
	cur = *prev;

	while (cur!=NULL) {
		if (cur->FR_Network==Network)
			break;
		else if (cur->FR_Network>Network) {
			cur = NULL;
				// No chance to find it
			break;
		}
		prev = &cur->FR_Next;
		cur = *prev;
	}
	if (ARGUMENT_PRESENT(prevLink))
		*prevLink = prev;

	return cur;
}

/*++
*******************************************************************
    L o c a t e N B R o u t e

Routine Description:
	Finds nb route block in nb name
	hash table.  Optionally returns the 
	insertion point pointer if nb route
	for given name is not in the table
Arguments:
	Name - netbios name
	insertBefore - buffer to place the pointer to
					hash table element where route
					block should be inserted if it is not
					already in the table
Return Value:
	Pointer to nb route block if found
	NULL otherwise
*******************************************************************
--*/
PNB_ROUTE
LocateNBRoute (
	ULONGLONG		*Name128,
	PNB_ROUTE		**prevLink OPTIONAL
	) {
	PNB_ROUTE		cur, *prev;

	prev = &NBRouteHash[NetbiosNameHashFunc(Name128)];
	cur = *prev;

	while (cur!=NULL) {
		if ((cur->NBR_Name128[0]==Name128[0])
				&& (cur->NBR_Name128[1]==Name128[1]))
			break;
		else if ((cur->NBR_Name128[0]>Name128[0])
				|| ((cur->NBR_Name128[0]==Name128[0])
					&& (cur->NBR_Name128[1]>Name128[1]))) {
			cur = NULL;
				// No chance to find it
			break;
		}
		prev = &cur->NBR_Next;
		cur = *prev;
	}
	if (ARGUMENT_PRESENT(prevLink))
		*prevLink = prev;

	return cur;
}

/*++
*******************************************************************
    G e t I n t e r f a c e R e f e r e n c e

Routine Description:
	Returns reference interface based on its index
Arguments:
	InterfaceIndex - unique id of the interface
Return Value:
	Pointer to interface control block if there is one in the table
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
GetInterfaceReference (
	ULONG			InterfaceIndex
	) {
	KIRQL			oldIRQL;
	PINTERFACE_CB	ifCB;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
		ifCB = LocateInterface (InterfaceIndex, NULL);
	else
		ifCB = InternalInterface;

	if (ifCB!=NULL) {
		AcquireInterfaceReference (ifCB);
		//if (ifCB->ICB_Index > 1)
		//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
		//                ("IpxFwd: GetInterfaceReference: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
    }
	else {
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Could not get interface reference %ld.\n", InterfaceIndex));
	}
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
	return ifCB;
}

//
//  Function    IncrementNicIds
//
//  Increments the nic id of every nic in the interface table
//  whose id is greater than or equal to the given threshold.
//
NTSTATUS IncrementNicids (USHORT usThreshold) {
	KIRQL oldIRQL;
	PINTERFACE_CB ifCB;
	PLIST_ENTRY	cur;
	PLIST_ENTRY	HashList;
	ULONG i;

    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                   ("IpxFwd: Incrementing all nic id's >= %d", usThreshold));
                   
	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
    
    // Walk through all of the hash buckets
    for (i = 0; i < InterfaceHashSize; i++) {
    	HashList = &InterfaceIndexHash[i];
    	cur = HashList->Flink;
    	
    	// Walk the list in this bucket updating as needed
    	while (cur!=HashList) {
    		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);
    		if ((ifCB->ICB_NicId != INVALID_NIC_ID) && (ifCB->ICB_NicId >= usThreshold)) {   
                IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                               ("IpxFwd: Incrementing nic id %d", ifCB->ICB_NicId));
    		    ifCB->ICB_NicId++;
    		    *((USHORT*)&ifCB->ICB_AdapterContext) = ifCB->ICB_NicId;
    		}
    		cur = cur->Flink;
    	}
    }
	
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

    return STATUS_SUCCESS;
}

//
//  Function    DecrementNicIds
//
//  Decrements the nic id of every nic in the interface table
//  whose id is greater than the given threshold.
//
NTSTATUS DecrementNicids (USHORT usThreshold) {
	KIRQL oldIRQL;
	PINTERFACE_CB ifCB;
	PLIST_ENTRY	cur;
	PLIST_ENTRY	HashList;
	ULONG i;

    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                   ("IpxFwd: Decrementing all nic id's > %d", usThreshold));

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
    
    // Walk through all of the hash buckets
    for (i = 0; i < InterfaceHashSize; i++) {
    	HashList = &InterfaceIndexHash[i];
    	cur = HashList->Flink;
    	
    	// Walk the list in this bucket updating as needed
    	while (cur!=HashList) {
    		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);
    		// If this is a bound interface
    		if (ifCB->ICB_NicId != INVALID_NIC_ID) {
    		    // If it's bound to a nic greater than the threshold, update
    		    // the nicid
    		    if (ifCB->ICB_NicId > usThreshold) {
                    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                                   ("IpxFwd: Decrementing nic id %d", ifCB->ICB_NicId));
        		    ifCB->ICB_NicId--;
        		}
        		// The if with bound to the threshold is now unbound.
        		else if (ifCB->ICB_NicId == usThreshold) {
                    IpxFwdDbgPrint (DBG_IPXBIND, DBG_INFORMATION, 
                                   ("IpxFwd: Marking interface %d as unbound", ifCB->ICB_Index));
        		    ifCB->ICB_NicId = INVALID_NIC_ID;
        		}
    		    *((USHORT*)&ifCB->ICB_AdapterContext) = ifCB->ICB_NicId;
    		}
    		cur = cur->Flink;
    	}
    }
	
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

    return STATUS_SUCCESS;
}

// 
// Puts as much of the interface table into the buffer pointed to by 
// pRows as there is space.
//
NTSTATUS DoGetIfTable (FWD_INTERFACE_TABLE * pTable, 
                       ULONG dwRowBufferSize)
{
	KIRQL oldIRQL;
	PINTERFACE_CB ifCB;
	PLIST_ENTRY	cur;
	PLIST_ENTRY	HashList;
	ULONG i, j = 0;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);

    // Walk through all of the hash buckets
    for (i = 0; i < InterfaceHashSize; i++) {
    	HashList = &InterfaceIndexHash[i];
    	cur = HashList->Flink;
    	
    	// Walk the list in this bucket updating as needed
    	while (cur!=HashList) {
    		ifCB = CONTAINING_RECORD(cur, INTERFACE_CB, ICB_IndexHashLink);

            // Validate the size of the return buffer
            if (dwRowBufferSize < 
                    (sizeof(FWD_INTERFACE_TABLE) + 
                     (sizeof(FWD_INTERFACE_TABLE_ROW) * (j + 1))))
            {
                break;
            }

            // Validate the number of rows
    		if (j >= pTable->dwNumRows)
    		    break;

            // Copy over the interface information
            pTable->pRows[j].dwIndex = ifCB->ICB_Index;
            pTable->pRows[j].dwNetwork = ifCB->ICB_Network;
            memcpy (pTable->pRows[j].uNode, ifCB->ICB_LocalNode, 6);
            memcpy (pTable->pRows[j].uRemoteNode, ifCB->ICB_RemoteNode, 6);
            pTable->pRows[j].usNicId = ifCB->ICB_NicId;
            pTable->pRows[j].ucType = ifCB->ICB_InterfaceType;
            j++;

            // Advance the current row and interface
    		cur = cur->Flink;
    	}
    }
	
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

	pTable->dwNumRows = j;

    return STATUS_SUCCESS;
}

/*++
*******************************************************************
    G e t N e x t I n t e r f a c e R e f e r e n c e

Routine Description:
	Returns reference to the next interface in the table
	Reference to the provided interface is released
Arguments:
	ifCB - interface to start with or NULL to start from the
			beginning of the interface table
Return Value:
	Pointer to interface control block if thare are any more interfaces
	in the table
	NULL otherwise
*******************************************************************
--*/
PINTERFACE_CB
GetNextInterfaceReference (
	PINTERFACE_CB	ifCB
	) {
	PLIST_ENTRY		cur;
	PLIST_ENTRY		HashList;
	KIRQL			oldIRQL;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (ifCB!=NULL) {
		// Find hash bucket
		ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		HashList = &InterfaceIndexHash[InterfaceIndexHashFunc(ifCB->ICB_Index)];
		if (LocateInterface (ifCB->ICB_Index, &cur)!=NULL)
			cur = ifCB->ICB_IndexHashLink.Flink;
		ReleaseInterfaceReference (ifCB);
		ifCB = NULL;
	}
	else
		cur = HashList = InterfaceIndexHash-1;

	if (cur==HashList) {
		do {
			HashList += 1;
			if (HashList==&InterfaceIndexHash[InterfaceHashSize]) {
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
				return NULL;
			}
		} while (IsListEmpty (HashList));
		cur = HashList->Flink;
	}
	ifCB = CONTAINING_RECORD (cur, INTERFACE_CB, ICB_IndexHashLink);
	AcquireInterfaceReference (ifCB);
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);

	return ifCB;
}


/*++
*******************************************************************
        A d d I n t e r f a c e

Routine Description:
	Adds interface control block to the table.
Arguments:
	InterfaceIndex - unique if of the interface
	Info - interface paramters
Return Value:
	STATUS_SUCCESS - interface added ok
	STATUS_UNSUCCESSFUL - interface is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				interface CB
*******************************************************************
--*/
NTSTATUS
AddInterface (
	ULONG		InterfaceIndex,
	UCHAR		InterfaceType,
	BOOLEAN		NetbiosAccept,
	UCHAR		NetbiosDeliver
	) {
	PINTERFACE_CB	ifCB;
	PLIST_ENTRY		cur;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_SUCCESS;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
		ifCB = LocateInterface (InterfaceIndex, &cur);
		if (ifCB==NULL) {
			ifCB = AllocateInterface ();
			if (ifCB!=NULL)
				NOTHING;
			else {
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto AddEnd;
			}
		}
		else {
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
				("IpxFwd: Interface %ld is already in the table!\n", InterfaceIndex));
			status = STATUS_UNSUCCESSFUL;
			goto AddEnd;
		}
	}
	else
		ifCB = InternalInterface;

	InitICB (ifCB, InterfaceIndex,InterfaceType,NetbiosAccept,NetbiosDeliver);
#if DBG
	InitializeListHead (&ifCB->ICB_InSendQueue);
#endif

	switch (InterfaceType) {
	case FWD_IF_PERMANENT:
		break;
	case FWD_IF_DEMAND_DIAL:
	case FWD_IF_LOCAL_WORKSTATION:
	case FWD_IF_REMOTE_WORKSTATION:
		ASSERT (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX);
		if (WanPacketListId==-1) {
			status = RegisterPacketConsumer (
							WAN_PACKET_SIZE,
							&WanPacketListId);
			if (!NT_SUCCESS (status)) {
				WanPacketListId = -1;
				break;
			}
		}
		ifCB->ICB_PacketListId = WanPacketListId;
		break;
	}

	if (NT_SUCCESS (status)) {
		if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
			InsertTailList (cur, &ifCB->ICB_IndexHashLink);
		}
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Adding interface %d (icb: %08lx, plid: %d)\n",
			InterfaceIndex, ifCB, ifCB->ICB_PacketListId));
	}
	else 
		FreeInterface (ifCB);

AddEnd:
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
	return status;
}


/*++
*******************************************************************
    A d d G l o b a l N e t C l i e n t

Routine Description:
	Adds interface control block to the table of
	clients on the global network (should be done when
	client connects)
Arguments:
	ifCB - interface control block to add to the table
Return Value:
	STATUS_SUCCESS - interface was added ok
	STATUS_UNSUCCESSFUL - another interface with the same
					node address is already in the table
*******************************************************************
--*/
NTSTATUS
AddGlobalNetClient (
	PINTERFACE_CB	ifCB
	) {
	KIRQL			oldIRQL;
	RWCOOKIE		cookie;
	PINTERFACE_CB	*prev;
	NTSTATUS		status = STATUS_SUCCESS;

	ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);

	AcquireReaderAccess (&RWLock, cookie);
	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	if (LocateClientInterface (ifCB->ICB_ClientNode64, &prev)==NULL) {
		ifCB->ICB_NodeHashLink = *prev;
		*prev = ifCB;
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		ReleaseReaderAccess (&RWLock, cookie);
		AcquireInterfaceReference (ifCB); // To make sure that
							// interface block does not
							// get deleted until it is
							// removed from the node table
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Adding interface %ld (icb: %08lx, ref=%ld)"
			" to global client table.\n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount, ifCB));
	}
	else {
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		ReleaseReaderAccess (&RWLock, cookie);
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Interface %ld (icb: %08lx)"
			" is already in the global client table.\n",
			ifCB->ICB_Index, ifCB));
		status = STATUS_UNSUCCESSFUL;
	}

	return status;
}

/*++
*******************************************************************
    D e l e t e G l o b a l N e t C l i e n t

Routine Description:
	Removes interface control block from the table of
	clients on the global network (should be done when
	client disconnects)
Arguments:
	ifCB - interface control block to remove from the table
Return Value:
	STATUS_SUCCESS - interface was removed ok
*******************************************************************
--*/
NTSTATUS
DeleteGlobalNetClient (
	PINTERFACE_CB	ifCB
	) {
	KIRQL			oldIRQL;
	RWCOOKIE		cookie;
	PINTERFACE_CB	cur, *prev;

	IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Deleting interface %ld (icb: %08lx)"
			" from global client table.\n", ifCB->ICB_Index, ifCB));

	ASSERT (ifCB->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);

	AcquireReaderAccess (&RWLock, cookie);
	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
	cur = LocateClientInterface (ifCB->ICB_ClientNode64, &prev);
	ASSERT (cur==ifCB);
	*prev = ifCB->ICB_NodeHashLink;
	KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
	ReleaseReaderAccess (&RWLock, cookie);

	ReleaseInterfaceReference (ifCB);
	return STATUS_SUCCESS;
}


/*++
*******************************************************************
    D e l e t e I n t e r f a c e

Routine Description:
	Deletes interface control block (the block is not actually 
	disposed of until all references to it are released).
Arguments:
	InterfaceIndex - unique if of the interface
Return Value:
	STATUS_SUCCESS - interface info retreived ok
	STATUS_UNSUCCESSFUL - interface is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteInterface (
	ULONG		InterfaceIndex
	) {
	PINTERFACE_CB	ifCB;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_SUCCESS;

	KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);

	if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
		ifCB = LocateInterface (InterfaceIndex, NULL);
	else
		ifCB = InternalInterface;
	if (ifCB!=NULL) {
		if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX) {
			RemoveEntryList (&ifCB->ICB_IndexHashLink);
		}
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		if (ifCB->ICB_Stats.OperationalState == FWD_OPER_STATE_UP) {
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
				("IpxFwd: Interface %ld (icb: %08lx) was still bound"
				" when asked to delete it.\n",
				ifCB->ICB_Index, ifCB));
			UnbindInterface (ifCB);
		}
		else if (IS_IF_CONNECTING (ifCB)) {
			IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
				("IpxFwd: Interface %ld (icb: %08lx) was still being connected"
				" when asked to delete it.\n",
					ifCB->ICB_Index, ifCB));
			SET_IF_NOT_CONNECTING (ifCB);
			DequeueConnectionRequest (ifCB);
			ProcessInternalQueue (ifCB);
			ProcessExternalQueue (ifCB);
		}

		ifCB->ICB_Stats.OperationalState = FWD_OPER_STATE_DOWN;

		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING,
			("IpxFwd: Deleting interface %ld (icb: %08lx).\n",
			ifCB->ICB_Index, ifCB));

		if (ifCB->ICB_NBRoutes!=NULL) {
			DeleteNBRoutes (ifCB->ICB_NBRoutes, ifCB->ICB_NBRouteCount);
			ifCB->ICB_NBRoutes = NULL;
		}

		FltInterfaceDeleted (ifCB);
		ReleaseInterfaceReference (ifCB);
	}
	else {
		KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
		IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_ERROR,
			("IpxFwd: Could not delete interface %ld because it is not found.\n",
			InterfaceIndex));
		status = STATUS_UNSUCCESSFUL;
	}
	return status;

}

/*++
*******************************************************************
    A d d R o u t e

Routine Description:
	Adds route to the hash table and finds and stores the reference
	to the associated interface control block in the route.
Arguments:
	Network - route's destination network
	NextHopAddress - mac address of next hop router if network is not
						directly connected
	TickCount - ticks to reach the destination net
	HopCount - hopss to reach the destination net
	InterfaceIndex - index of the associated interface (through which
						packets destined to the network are to be sent)
Return Value:
	STATUS_SUCCESS - route was added ok
	STATUS_UNSUCCESSFUL - route is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				route block
*******************************************************************
--*/
NTSTATUS
AddRoute (
	ULONG	Network,
	UCHAR	*NextHopAddress,
	USHORT	TickCount,
	USHORT	HopCount,
	ULONG	InterfaceIndex
	) {
	PFWD_ROUTE		fwRoute;
	PFWD_ROUTE		*prev;
	NTSTATUS		status = STATUS_SUCCESS;
	KIRQL			oldIRQL;

		// Assume success, allocate route and intialize it
		// (the goal is to spend as little time as possible
		// inside exclusive usage zone)
	fwRoute = AllocateRoute ();
	if (fwRoute!=NULL) {
		fwRoute->FR_Network = Network;
		IPX_NODE_CPY (fwRoute->FR_NextHopAddress, NextHopAddress);
		fwRoute->FR_TickCount = TickCount;
		fwRoute->FR_HopCount = HopCount;
		fwRoute->FR_ReferenceCount = 0;

		if (InterfaceIndex!=0xFFFFFFFF) {
				// See if interface is there
			KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
			if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
				fwRoute->FR_InterfaceReference
					= LocateInterface (InterfaceIndex, NULL);
			else
				fwRoute->FR_InterfaceReference = InternalInterface;
			if (fwRoute->FR_InterfaceReference!=NULL) {
				AcquireInterfaceReference (fwRoute->FR_InterfaceReference);
				//if (fwRoute->FR_InterfaceReference->ICB_Index > 1)
            	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
            	//                ("IpxFwd: AddRoute: Aquired if #%ld (%ld) \n", 
            	//                fwRoute->FR_InterfaceReference->ICB_Index, 
            	//                fwRoute->FR_InterfaceReference->ICB_ReferenceCount));
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
				
				ExAcquireFastMutex (&WriterMutex);
					// Check if route is already there
				if (LocateRoute (Network, &prev)==NULL) {
					fwRoute->FR_Next = *prev;
					*prev = fwRoute;
				}
				else {
					ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
					fwRoute->FR_InterfaceReference = NULL;
					IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
						("IpxFwd: Route for net %08lx"
						" is already in the table!\n", Network));
					status = STATUS_UNSUCCESSFUL;
				}

				ExReleaseFastMutex (&WriterMutex);
			}
			else {
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
				IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Interface %ld for route for net %08lx"
					" is not in the table!\n", InterfaceIndex, Network));
				status = STATUS_UNSUCCESSFUL;
			}
		}
		else {
			ExAcquireFastMutex (&WriterMutex);
				// Just check if we do not have it already
			if (GlobalRoute==NULL) {
				fwRoute->FR_InterfaceReference = GLOBAL_INTERFACE_REFERENCE;
				GlobalNetwork = Network;
				GlobalRoute = fwRoute;
			}
			else {
				IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Route for global net %08lx"
					" is already in the table!\n", Network));
				status = STATUS_UNSUCCESSFUL;
			}
			ExReleaseFastMutex (&WriterMutex);
		}

		if (NT_SUCCESS (status)) {
			IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_WARNING,
				("IpxFwd: Adding route for net %08lx"
				" (rb: %08lx, NHA: %02x%02x%02x%02x%02x%02x,"
				" if: %ld, icb: %08lx).\n",
				Network, fwRoute,
				NextHopAddress[0], NextHopAddress[1],
					NextHopAddress[2], NextHopAddress[3],
					NextHopAddress[4],  NextHopAddress[5],
				InterfaceIndex, fwRoute->FR_InterfaceReference));
		}
		else {
			FreeRoute (fwRoute);
		}
	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;

	return status;
}

/*++
*******************************************************************
    D e l e t e R o u t e

Routine Description:
	Deletes route from the hash table and releases the reference
	to the interface control block associated with the route.
Arguments:
	Network - route's destination network
Return Value:
	STATUS_SUCCESS - route was deleted ok
	STATUS_UNSUCCESSFUL - route is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteRoute (
	ULONG	Network
	) {
	PFWD_ROUTE	fwRoute, *prev;
	NTSTATUS	status = STATUS_SUCCESS;

	ExAcquireFastMutex (&WriterMutex);
	
	if ((GlobalRoute!=NULL)
			&& (GlobalNetwork==Network)) {
		fwRoute = GlobalRoute;
		GlobalNetwork = 0xFFFFFFFF;
		GlobalRoute = NULL;
	}
	else if ((fwRoute=LocateRoute (Network, &prev))!=NULL) {
		*prev = fwRoute->FR_Next;
	}

	if (fwRoute!=NULL) {
		IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_WARNING,
			("IpxFwd: Deleting route for net %08lx (rb: %08lx).\n",
				Network, fwRoute));
		WaitForAllReaders (&RWLock);
		if (fwRoute->FR_InterfaceReference!=GLOBAL_INTERFACE_REFERENCE) {
			ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
		}
		fwRoute->FR_InterfaceReference = NULL;
		ReleaseRouteReference (fwRoute);
	}
	else {
		IpxFwdDbgPrint (DBG_ROUTE_TABLE, DBG_ERROR,
			("IpxFwd: Could not delete route for net %08lx because it is not in the table.\n",
				Network));
		status = STATUS_UNSUCCESSFUL;
	}

	ExReleaseFastMutex (&WriterMutex);
	return status;
}

	
/*++
*******************************************************************
    U p d a t e R o u t e

Routine Description:
	Updates route in the hash table
Arguments:
	Network - route's destination network
	NextHopAddress - mac address of next hop router if network is not
						directly connected
	TickCount - ticks to reach the destination net
	HopCount - hopss to reach the destination net
	InterfaceIndex - index of the associated interface (through which
						packets destined to the network are to be sent)
Return Value:
	STATUS_SUCCESS - interface info retreived ok
	STATUS_UNSUCCESSFUL - interface is not in the table
*******************************************************************
--*/
NTSTATUS
UpdateRoute (
	ULONG	Network,
	UCHAR	*NextHopAddress,
	USHORT	TickCount,
	USHORT	HopCount,
	ULONG	InterfaceIndex
	) {
	PFWD_ROUTE		fwRoute = NULL, newRoute, *prev;
	PINTERFACE_CB	ifCB = NULL;
	KIRQL			oldIRQL;
	NTSTATUS		status = STATUS_SUCCESS;


	ExAcquireFastMutex (&WriterMutex);
	
	if ((GlobalRoute!=NULL)
			&& (GlobalNetwork==Network)) {
		InterfaceIndex = 0xFFFFFFFF;
		fwRoute = GlobalRoute;
	}
	else {
		ASSERT (InterfaceIndex!=0xFFFFFFFF);
		fwRoute = LocateRoute (Network, &prev);
	    if ((fwRoute != NULL) && (fwRoute->FR_InterfaceReference == GLOBAL_INTERFACE_REFERENCE))
	    {
    		status = STATUS_UNSUCCESSFUL;
    		goto ExitUpdate;
	    }
	}

	if (fwRoute!=NULL) {
		if (InterfaceIndex!=0xFFFFFFFF) {
			if (fwRoute->FR_InterfaceReference->ICB_Index!=InterfaceIndex) {
				// Get a reference to new interface
				KeAcquireSpinLock (&InterfaceTableLock, &oldIRQL);
				if (InterfaceIndex!=FWD_INTERNAL_INTERFACE_INDEX)
					ifCB = LocateInterface (InterfaceIndex, NULL);
				else
					ifCB = InternalInterface;
				if (ifCB!=NULL) {
					AcquireInterfaceReference (ifCB);
            		//if (ifCB->ICB_Index > 1)
                	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
                	//                ("IpxFwd: UpdateRoute: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
				}
				else {
					KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
					status = STATUS_UNSUCCESSFUL;
					goto ExitUpdate;
				}
				KeReleaseSpinLock (&InterfaceTableLock, oldIRQL);
			}
			else {
				ifCB = fwRoute->FR_InterfaceReference;
				AcquireInterfaceReference (ifCB);
        		//if (ifCB->ICB_Index > 1)
            	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
            	//                ("IpxFwd: UpdateRoute(2): Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
            }
		}
		else
			ifCB = GLOBAL_INTERFACE_REFERENCE;
		newRoute = AllocateRoute ();
		if (newRoute!=NULL) {
			newRoute->FR_Network = Network;
			IPX_NODE_CPY (newRoute->FR_NextHopAddress, NextHopAddress);
			newRoute->FR_TickCount = TickCount;
			newRoute->FR_HopCount = HopCount;
			newRoute->FR_ReferenceCount = 0;
			newRoute->FR_InterfaceReference = ifCB;
				// Lock the table only when updating it
			if (InterfaceIndex!=0xFFFFFFFF) {
				newRoute->FR_Next = fwRoute->FR_Next;
				*prev = newRoute;
			}
			else
				GlobalRoute = newRoute;

			WaitForAllReaders (&RWLock)
			if (fwRoute->FR_InterfaceReference!=GLOBAL_INTERFACE_REFERENCE) {
				ReleaseInterfaceReference (fwRoute->FR_InterfaceReference);
			}
			fwRoute->FR_InterfaceReference = NULL;
			ReleaseRouteReference (fwRoute);

		}
		else
			status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
		status = STATUS_UNSUCCESSFUL;

ExitUpdate:
	ExReleaseFastMutex (&WriterMutex);
	return status;
}


/*++
*******************************************************************
    F i n d D e s t i n a t i o n

Routine Description:
	Finds destination interface for IPX address and
	returns reference to its control block.
Arguments:
	Network - destination network
	Node	- destination node (needed in case of global client)
	Route	- buffer to hold reference to route block				
Return Value:
	Reference to destination interface CB
	NULL if route it not found
*******************************************************************
--*/
PINTERFACE_CB
FindDestination (
	IN ULONG			Network,
	IN PUCHAR			Node,
	OUT PFWD_ROUTE		*Route
	) {
	PFWD_ROUTE		fwRoute;
	PINTERFACE_CB	ifCB;
	RWCOOKIE		cookie;

	AcquireReaderAccess (&RWLock, cookie);
	if ((GlobalRoute!=NULL)
			&& (GlobalNetwork==Network)) {
		if (Node!=NULL) {	// If caller did not specify node, 
								// we can't find the route
			union {
				ULONGLONG	Node64[1];
				UCHAR		Node[6];
			} u;
			u.Node64[0] = 0;
			IPX_NODE_CPY (u.Node, Node);

			ifCB = LocateClientInterface (u.Node64, NULL);
			if (ifCB!=NULL) {
				AcquireRouteReference (GlobalRoute);
				*Route = GlobalRoute;
				AcquireInterfaceReference (ifCB);
        		//if (ifCB->ICB_Index > 1)
            	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
            	//                ("IpxFwd: FindDestination: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
			}
			else
				*Route = NULL;
		}
		else {
			ifCB = NULL;
			*Route = NULL;
		}
	}
	else {
		*Route = fwRoute = LocateRoute (Network, NULL);
		if (fwRoute!=NULL) {
			AcquireRouteReference (fwRoute);
			ifCB = fwRoute->FR_InterfaceReference;
			AcquireInterfaceReference (ifCB);
    		//if (ifCB->ICB_Index > 1)
        	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
        	//                ("IpxFwd: FindDestination(2): Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
		}
		else
			ifCB = NULL;
	}	
	ReleaseReaderAccess (&RWLock, cookie);
	return ifCB;
}

/*++
*******************************************************************
    A d d N B R o u t e s

Routine Description:
	Adds netbios names associated with interface to netbios
	route hash table
Arguments:
	ifCB	- interface with which names are associated
	Names	- array of names
	Count	- number of names in the array
	routeArray - buffer to place allocated array of routes
Return Value:
	STATUS_SUCCESS - names were added ok
	STATUS_UNSUCCESSFUL - one of the names is already in the table
	STATUS_INSUFFICIENT_RESOURCES - can't allocate memory for
				route array
*******************************************************************
--*/
NTSTATUS
AddNBRoutes (
	PINTERFACE_CB	ifCB,
	FWD_NB_NAME		Names[],
	ULONG			Count,
	PNB_ROUTE		*routeArray
	) {
	PNB_ROUTE		nbRoutes, *prev;
	NTSTATUS		status = STATUS_SUCCESS;

	nbRoutes = (PNB_ROUTE)ExAllocatePoolWithTag  (
					NonPagedPool, sizeof (NB_ROUTE)*Count, FWD_POOL_TAG);
	if (nbRoutes!=NULL) {
		ULONG	i;

		ExAcquireFastMutex (&WriterMutex);

		for (i=0; i<Count; i++) {
			nbRoutes[i].NBR_Name128[0] = nbRoutes[i].NBR_Name128[1] = 0;
			NB_NAME_CPY (nbRoutes[i].NBR_Name, &Names[i]);
				// Check if route is already there
			if (LocateNBRoute (nbRoutes[i].NBR_Name128, &prev)==NULL) {
				nbRoutes[i].NBR_Destination = ifCB;
				nbRoutes[i].NBR_Next = *prev;
				*prev = &nbRoutes[i];
				IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_WARNING,
					("IpxFwd: Adding nb route for name %16s.\n",Names[i]));
			}
			else {
				IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Route for nb name %16s"
					" is already in the table!\n", Names[i]));
				break;
			}
		}
		ExReleaseFastMutex (&WriterMutex);
		if (i==Count) {
			*routeArray = nbRoutes;
			status = STATUS_SUCCESS;

		}
		else {
			status = STATUS_UNSUCCESSFUL;
			DeleteNBRoutes (nbRoutes, i);
		}
	}
	else {
		IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_ERROR,
					("IpxFwd: Could allocate nb route array for if: %ld"
						" (icb: %08lx).\n", ifCB->ICB_Index, ifCB));
		status = STATUS_INSUFFICIENT_RESOURCES;
	}
	return status;
}

/*++
*******************************************************************
    D e l e t e N B R o u t e s

Routine Description:
	Deletes nb routes in the array from the route table and frees
	the array
Arguments:
	nbRoutes - array of routes
	Count	- number of routes in the array
Return Value:
	STATUS_SUCCESS - route was deleted ok
	STATUS_UNSUCCESSFUL - route is not in the table
*******************************************************************
--*/
NTSTATUS
DeleteNBRoutes (
	PNB_ROUTE		nbRoutes,
	ULONG			Count
	) {
	PNB_ROUTE	*prev;
	NTSTATUS	status = STATUS_SUCCESS;
	ULONG		i;

	ExAcquireFastMutex (&WriterMutex);
	for (i=0; i<Count; i++) {
		PNB_ROUTE	cur = LocateNBRoute (nbRoutes[i].NBR_Name128, &prev);
		ASSERT (cur==&nbRoutes[i]);
		*prev = nbRoutes[i].NBR_Next;
		IpxFwdDbgPrint (DBG_NBROUTE_TABLE, DBG_WARNING,
					("IpxFwd: Deleting nb route for name %16s.\n",
							nbRoutes[i].NBR_Name));
	}

	WaitForAllReaders (&RWLock);
	ExReleaseFastMutex (&WriterMutex);

	ExFreePool (nbRoutes);

	return STATUS_SUCCESS;
}

	
/*++
*******************************************************************
    F i n d N B D e s t i n a t i o n

Routine Description:
	Finds destination interface for nb name and
	returns reference to its control block.
Arguments:
	Name	- name to look for
Return Value:
	Reference to destination interface CB
	NULL if route it not found
*******************************************************************
--*/
PINTERFACE_CB
FindNBDestination (
	IN PUCHAR		Name
	) {
	PNB_ROUTE		nbRoute;
	PINTERFACE_CB	ifCB;
	RWCOOKIE		cookie;
	union {
		ULONGLONG	Name128[2];
		UCHAR		Name[16];
	} u;
	u.Name128[0] = u.Name128[1] = 0;
	NB_NAME_CPY (u.Name, Name);

	AcquireReaderAccess (&RWLock, cookie);
	nbRoute = LocateNBRoute (u.Name128, NULL);
	if (nbRoute!=NULL) {
		ifCB = nbRoute->NBR_Destination;
		AcquireInterfaceReference (ifCB);
		//if (ifCB->ICB_Index > 1)
    	//IpxFwdDbgPrint (DBG_INTF_TABLE, DBG_WARNING, 
    	//                ("IpxFwd: FindNBDestination: Aquired if #%ld (%ld) \n", ifCB->ICB_Index, ifCB->ICB_ReferenceCount));
	}
	else
		ifCB = NULL;
	ReleaseReaderAccess (&RWLock, cookie);
	return ifCB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\send.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntos\tdi\isn\fwd\send.c

Abstract:
	Send routines

Author:

    Vadim Eydelman

Revision History:

--*/

#include    "precomp.h"


ULONG			SpoofingTimeout=DEF_SPOOFING_TIMEOUT;
LIST_ENTRY		SpoofingQueue;
KSPIN_LOCK		SpoofingQueueLock;
WORK_QUEUE_ITEM	SpoofingWorker;
BOOLEAN			SpoofingWorkerActive = FALSE;
ULONG			DontSuppressNonAgentSapAdvertisements = 0;

#define IsLocalSapNonAgentAdvertisement(hdr,data,ln,ifCB) (		\
	(DontSuppressNonAgentSapAdvertisements==0)					\
	&& (GETUSHORT(hdr+IPXH_DESTSOCK)==IPX_SAP_SOCKET)			\
	&& (GETUSHORT(hdr+IPXH_SRCSOCK)!=IPX_SAP_SOCKET)			\
	&& (ln>=IPXH_HDRSIZE+2)										\
	&& (GETUSHORT(data)==2)										\
	&& ((IPX_NODE_CMP(hdr+IPXH_DESTNODE,BROADCAST_NODE)==0)		\
        || (IPX_NODE_CMP(hdr+IPXH_DESTNODE,ifCB->ICB_RemoteNode)==0)) \
)

/*++
*******************************************************************
    D o S e n d

Routine Description:
	Prepares and sends packet.  Interface lock must be help while
	callin this routine
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	result returned by IPX

*******************************************************************
--*/
NDIS_STATUS
DoSend (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	KIRQL			oldIRQL
	) {
	NDIS_STATUS			status;
	PNDIS_PACKET		pktDscr;
	PNDIS_BUFFER		bufDscr, aDscr;
	UINT				dataLen;
	ULONG				dstNet = GETULONG (pktTag->PT_Data+IPXH_DESTNET);

	if (dstIf!=InternalInterface) {
        ADAPTER_CONTEXT_TO_LOCAL_TARGET (dstIf->ICB_AdapterContext,
										&pktTag->PT_Target);
    }
    else {
		CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (
                        VIRTUAL_NET_ADAPTER_CONTEXT,
										&pktTag->PT_Target);
    }

#if DBG
		// Keep track of packets being processed by IPX stack
	InsertTailList (&dstIf->ICB_InSendQueue, &pktTag->PT_QueueLink);
#endif
	KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
	
	if (pktTag->PT_Flags&PT_SOURCE_IF)
		ReleaseInterfaceReference (pktTag->PT_SourceIf);
	pktTag->SEND_RESERVED[0] = pktTag->SEND_RESERVED[1] = 0;
	pktDscr = CONTAINING_RECORD(pktTag, NDIS_PACKET, ProtocolReserved);
    NdisQueryPacket(pktDscr, NULL, NULL, &bufDscr, NULL);
#if DBG
	{		// Verify packet integrity
		PUCHAR	dataPtr;
		UINT	bufLen;
		ASSERT (NDIS_BUFFER_LINKAGE (bufDscr)==NULL);
		NdisQueryBuffer (bufDscr, &dataPtr, &bufLen);
		ASSERT (dataPtr==pktTag->PT_Data);
		ASSERT (bufLen==pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
	}
#endif
			// Prepare packet for IPX stack (mac header buffer goes in
			// front and packet length adjusted to reflect the size of the data
	dataLen = GETUSHORT(pktTag->PT_Data+IPXH_LENGTH);
    NdisAdjustBufferLength(bufDscr, dataLen);
	NdisChainBufferAtFront(pktDscr, pktTag->PT_MacHdrBufDscr);


	if (EnterForwarder ()) {// To make sure that we won't unload
							// until IPX driver has a chance to call us back
		status = IPXSendProc (&pktTag->PT_Target, pktDscr, dataLen, 0);

		if (status!=NDIS_STATUS_PENDING) {
			LeaveForwarder ();	// No callback

				// Restore original packet structure
			NdisUnchainBufferAtFront (pktDscr, &aDscr);
#if DBG
				// Make sure IPX stack did not mess our packet
			ASSERT (aDscr==pktTag->PT_MacHdrBufDscr);
		    NdisQueryPacket(pktDscr, NULL, NULL, &aDscr, NULL);
			ASSERT (aDscr==bufDscr);
			ASSERT (NDIS_BUFFER_LINKAGE (aDscr)==NULL);
#endif
				// Restore original packet size
			NdisAdjustBufferLength(bufDscr,
						pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
#if DBG
				// Remove packet from temp queue
			KeAcquireSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, &oldIRQL);
			RemoveEntryList (&pktTag->PT_QueueLink);
			KeReleaseSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, oldIRQL);
#endif
		}
	}
	else {
			// We are going down, restore the packet
		NdisUnchainBufferAtFront (pktDscr, &aDscr);
		NdisAdjustBufferLength(bufDscr,
						pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
		NdisRecalculatePacketCounts (pktDscr);
		status = STATUS_UNSUCCESSFUL;
#if DBG
		KeAcquireSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, &oldIRQL);
		RemoveEntryList (&pktTag->PT_QueueLink);
		KeReleaseSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, oldIRQL);
#endif
	}
	return status;
}


/*++
*******************************************************************
    P r o c e s s S e n t P a c k e t

Routine Description:
	Process completed sent packets
Arguments:
	dstIf	- interface over which packet was sent
	pktTag	- completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
ProcessSentPacket (
	PINTERFACE_CB	dstIf,
	PPACKET_TAG		pktTag,
	NDIS_STATUS		status
	) {
	KIRQL			oldIRQL;

		// Packet processing is completed -> can take more packets
	InterlockedIncrement (&dstIf->ICB_PendingQuota);

	if (*(pktTag->PT_Data+IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
            // Continue processing netbios packets
		if (status==NDIS_STATUS_SUCCESS) {
		    IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
			    ("IpxFwd: NB Packet %08lx sent.", pktTag));
    		InterlockedIncrement (&dstIf->ICB_Stats.OutDelivers);
			InterlockedIncrement (&dstIf->ICB_Stats.NetbiosSent);
        }
        else {
		    IpxFwdDbgPrint (DBG_NETBIOS, DBG_ERROR,
			    ("IpxFwd: NB Packet %08lx send failed with error: %08lx.\n",
			    pktTag, status));
        }
			// Queue nb packet for further processing (broadcast on all interfaces)
		QueueNetbiosPacket (pktTag);
	}
	else {
			// Destroy completed packet
	    if (status==NDIS_STATUS_SUCCESS) {
    		InterlockedIncrement (&dstIf->ICB_Stats.OutDelivers);
		    IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
			    ("IpxFwd: Packet %08lx sent.", pktTag));
	    }
	    else {
		    InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
		    IpxFwdDbgPrint (DBG_SEND, DBG_ERROR,
			    ("IpxFwd: Packet %08lx send failed with error: %08lx.\n",
			    pktTag, status));
	    }
		ReleaseInterfaceReference (dstIf);
		if (MeasuringPerformance
			&& (pktTag->PT_PerfCounter!=0)) {
			LARGE_INTEGER	PerfCounter = KeQueryPerformanceCounter (NULL);
			PerfCounter.QuadPart -= pktTag->PT_PerfCounter;
			KeAcquireSpinLock (&PerfCounterLock, &oldIRQL);
			ASSERT (PerfCounter.QuadPart<ActivityTreshhold);
			PerfBlock.TotalPacketProcessingTime += PerfCounter.QuadPart;
			PerfBlock.PacketCounter += 1;
			if (PerfBlock.MaxPacketProcessingTime < PerfCounter.QuadPart)
				PerfBlock.MaxPacketProcessingTime = PerfCounter.QuadPart;
			KeReleaseSpinLock (&PerfCounterLock, oldIRQL);
		}
		FreePacket (pktTag);
	}
}

/*++
*******************************************************************
    S e n d P a c k e t

Routine Description:
	Enqueues packets to be sent by IPX stack
Arguments:
	dstIf	- over which interface to send
	pktTag	- packet to send
Return Value:
	None

*******************************************************************
--*/
VOID
SendPacket (
	PINTERFACE_CB		dstIf,
	PPACKET_TAG		    pktTag
	) {
    NDIS_STATUS			status;
	KIRQL				oldIRQL;


	ASSERT (dstIf->ICB_Index!=FWD_INTERNAL_INTERFACE_INDEX);
		// Make sure we have not exceded the quota of pending packets on the interface
	if (InterlockedDecrement (&dstIf->ICB_PendingQuota)>=0) {
		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
			// Decide what to do with the packet based on the interface state
		switch (dstIf->ICB_Stats.OperationalState) {
		case FWD_OPER_STATE_UP:
			if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
				NOTHING;
			else {
				PUTULONG (dstIf->ICB_Network, pktTag->PT_Data+IPXH_DESTNET);
			}
			status = DoSend (dstIf, pktTag, oldIRQL);
			IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
				("IpxFwd: Sent external packet %08lx on if %ld.\n",
				pktTag, dstIf->ICB_Index));
			break;
		case FWD_OPER_STATE_SLEEPING:
			if ((*(pktTag->PT_Data+IPXH_PKTTYPE)!=0)
					|| (GETUSHORT(pktTag->PT_Data+IPXH_LENGTH)!=IPXH_HDRSIZE+2)
					|| (*(pktTag->PT_Data+IPXH_HDRSIZE+1)!='?')) {
					// Queue this packet on the interface until it is connected
					// by Router Manager (DIM) if this is not a NCP keepalive
					// (watchdog)
				InsertTailList (&dstIf->ICB_ExternalQueue, &pktTag->PT_QueueLink);
				if (!IS_IF_CONNECTING (dstIf)) {
						// Ask for connection if interface is not in the connection
						// queue yet
					QueueConnectionRequest (dstIf,
                        CONTAINING_RECORD (pktTag,
                                            NDIS_PACKET,
                                            ProtocolReserved),
                        pktTag->PT_Data,
                        oldIRQL);
					IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
						("IpxFwd: Queued dd request on if %ld (ifCB:%08lx)"
						" for packet to %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x"
						" from %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x\n",
						dstIf->ICB_Index, dstIf,
						*(pktTag->PT_Data+6),*(pktTag->PT_Data+7),
								*(pktTag->PT_Data+8),*(pktTag->PT_Data+9),
							*(pktTag->PT_Data+10),*(pktTag->PT_Data+11),
								*(pktTag->PT_Data+12),*(pktTag->PT_Data+13),
								*(pktTag->PT_Data+14),*(pktTag->PT_Data+15),
							*(pktTag->PT_Data+16),*(pktTag->PT_Data+17),
						*(pktTag->PT_Data+18),*(pktTag->PT_Data+19),
								*(pktTag->PT_Data+20),*(pktTag->PT_Data+21),
							*(pktTag->PT_Data+22),*(pktTag->PT_Data+23),
								*(pktTag->PT_Data+24),*(pktTag->PT_Data+25),
								*(pktTag->PT_Data+26),*(pktTag->PT_Data+27),
							*(pktTag->PT_Data+28),*(pktTag->PT_Data+29)));
				}
				else
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
				IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
					("IpxFwd: Queued external packet %08lx on if %ld.\n",
					pktTag, dstIf->ICB_Index));
				if (*(pktTag->PT_Data + IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
					NOTHING;
				else if (!(pktTag->PT_Flags&PT_NB_DESTROY)) {
						// If this nb packet is not to be destroyed after this
						// send, we have to make a copy of it to send on
						// other interfaces while the original is waiting
						// for connection
					PPACKET_TAG	newPktTag;
					DuplicatePacket (pktTag, newPktTag);
					if (newPktTag!=NULL) {
						UINT			bytesCopied;
						PNDIS_PACKET	packet = CONTAINING_RECORD (pktTag,
														NDIS_PACKET,
														ProtocolReserved);
						PNDIS_PACKET	newPacket = CONTAINING_RECORD (newPktTag,
														NDIS_PACKET,
														ProtocolReserved);
						NdisCopyFromPacketToPacket (newPacket, 0,
									GETUSHORT(pktTag->PT_Data+IPXH_LENGTH),
									packet, 0, &bytesCopied);

						ASSERT (bytesCopied==GETUSHORT(pktTag->PT_Data+IPXH_LENGTH));
						IpxFwdDbgPrint (DBG_NETBIOS,
							DBG_INFORMATION,
							("IpxFwd: Duplicated queued nb packet"
							" %08lx -> %08lx on if %ld.\n",
							pktTag, newPktTag, dstIf->ICB_Index));
						AcquireInterfaceReference (dstIf);
						newPktTag->PT_InterfaceReference = dstIf;
						newPktTag->PT_PerfCounter = pktTag->PT_PerfCounter;
						QueueNetbiosPacket (newPktTag);
							// The original copy will have to be
							// destroyed after it is sent on the
							// connected interface
						pktTag->PT_Flags |= PT_NB_DESTROY;
					}
				}
				status = NDIS_STATUS_PENDING;
				break;
			}
			else {	// Process keepalives
				LONGLONG	curTime;
				KeQuerySystemTime ((PLARGE_INTEGER)&curTime);
				if (((curTime-dstIf->ICB_DisconnectTime)/10000000) < SpoofingTimeout) {
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
					IpxFwdDbgPrint (DBG_SPOOFING, DBG_INFORMATION,
						("IpxFwd: Queueing reply to keepalive from server"
						" on if %ld (ifCB %lx)"
						" at %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x.\n",
						dstIf->ICB_Index, dstIf,
						*(pktTag->PT_Data+IPXH_SRCNET),*(pktTag->PT_Data+IPXH_SRCNET+1),
							*(pktTag->PT_Data+IPXH_SRCNET+2),*(pktTag->PT_Data+IPXH_SRCNET+3),
						*(pktTag->PT_Data+IPXH_SRCNODE),*(pktTag->PT_Data+IPXH_SRCNODE+1),
							*(pktTag->PT_Data+IPXH_SRCNODE+2),*(pktTag->PT_Data+IPXH_SRCNODE+3),
							*(pktTag->PT_Data+IPXH_SRCNODE+4),*(pktTag->PT_Data+IPXH_SRCNODE+5),
						*(pktTag->PT_Data+IPXH_SRCSOCK),*(pktTag->PT_Data+IPXH_SRCNODE+1)));
						// Spoof the packet if timeout has not been exceeded
					KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
					InsertTailList (&SpoofingQueue, &pktTag->PT_QueueLink);
					if (!SpoofingWorkerActive
							&& EnterForwarder()) {
						SpoofingWorkerActive = TRUE;
						ExQueueWorkItem (&SpoofingWorker, DelayedWorkQueue);
					}
					KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
						// We will actually send this packet though
						// in other direction, so mark it as pending
						// to prevent ProcessSentPacket to be called
					status = NDIS_STATUS_PENDING;
					break;
				}
				// else don't spoof (fall through and fail the packet)
			}
		case FWD_OPER_STATE_DOWN:
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			status = NDIS_STATUS_ADAPTER_NOT_READY;
			IpxFwdDbgPrint (DBG_SEND, DBG_WARNING,
				("IpxFwd: Failed external packet %08lx on if %ld(down?).\n",
				pktTag, dstIf->ICB_Index));
			break;
		default:
		    status = STATUS_UNSUCCESSFUL;
			ASSERTMSG ("Invalid operational state ", FALSE);
		}
	}
	else {
		IpxFwdDbgPrint (DBG_SEND, DBG_WARNING,
			("IpxFwd: Could not send packet %08lx on if %ld (quota exceeded).\n",
			pktTag, dstIf->ICB_Index));
		status = NDIS_STATUS_RESOURCES;
	}

	if (status!=NDIS_STATUS_PENDING)
		ProcessSentPacket (dstIf, pktTag, status);
}

/*++
*******************************************************************
    F w S e n d C o m p l e t e

Routine Description:
	Called by IPX stack when send completes asynchronously
Arguments:
	pktDscr	- descriptor of the completed packet
	status	- result of send operation
Return Value:
	None

*******************************************************************
--*/
VOID
IpxFwdSendComplete (
	PNDIS_PACKET	pktDscr,
	NDIS_STATUS		status
	) {
	PPACKET_TAG     pktTag;
	PNDIS_BUFFER	bufDscr;

	pktTag = (PPACKET_TAG)pktDscr->ProtocolReserved;

	NdisUnchainBufferAtFront (pktDscr, &bufDscr);
	ASSERT (bufDscr==pktTag->PT_MacHdrBufDscr);

	NdisQueryPacket(pktDscr,
            NULL,
            NULL,
            &bufDscr,
            NULL);
    NdisAdjustBufferLength(bufDscr,
		pktTag->PT_Segment->PS_SegmentList->SL_BlockSize);
	NdisRecalculatePacketCounts (pktDscr);
#if DBG
	{
	KIRQL			oldIRQL;
	KeAcquireSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, &oldIRQL);
	RemoveEntryList (&pktTag->PT_QueueLink);
	KeReleaseSpinLock (&pktTag->PT_InterfaceReference->ICB_Lock, oldIRQL);
	}
#endif
	ProcessSentPacket (pktTag->PT_InterfaceReference, pktTag, status);
	LeaveForwarder (); // Entered before calling IpxSendPacket
}


/*++
*******************************************************************
	
	F w I n t e r n a l S e n d

Routine Description:
	Filter and routes packets sent by IPX stack
Arguments:
   LocalTarget		- the NicId and next hop router MAC address
   Context			- preferred interface on which to send
   Packet			- packet to be sent
   ipxHdr			- pointer to ipx header inside the packet
   PacketLength		- length of the packet
   fIterate         - a flag to indicate if this is a packet for the
                        iteration of which the Fwd takes responsibility
                        - typically type 20 NetBIOS frames
Return Value:

   STATUS_SUCCESS - if the preferred NIC was OK and packet passed filtering
   STATUS_NETWORK_UNREACHABLE - if the preferred was not OK or packet failed filtering
   STATUS_PENDING - packet was queued until connection is established
*******************************************************************
--*/
NTSTATUS
IpxFwdInternalSend (
	IN OUT PIPX_LOCAL_TARGET	LocalTarget,
	IN ULONG_PTR				Context,
	IN PNDIS_PACKET				pktDscr,
	IN PUCHAR					ipxHdr,
	IN PUCHAR					data,
	IN ULONG					PacketLength,
    IN BOOLEAN                  fIterate
	) {
	PINTERFACE_CB				dstIf = NULL, // Initialized to indicate
                                // first path through the iteration
                                // as well as the fact the we do not
                                // know it initially
                                stDstIf = NULL;    // Static destination for
                                // NetBIOS names
	PFWD_ROUTE					fwRoute = NULL;
	ULONG						dstNet;
    USHORT                      dstSock;
	NTSTATUS					status;

	if (!EnterForwarder())
		return STATUS_NETWORK_UNREACHABLE;

	if (IS_IF_ENABLED(InternalInterface)
            && ((*(ipxHdr+IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
                || InternalInterface->ICB_NetbiosAccept)) {

        // Print out the fact that we're going to send and display the nic id's
	    IpxFwdDbgPrint (DBG_INT_SEND, DBG_INFORMATION,
		    ("IpxFwd: InternalSend entered: nicid= %d  if= %d  ifnic= %d  fIterate: %d",
		      LocalTarget->NicId,
		      ((Context!=INVALID_CONTEXT_VALUE) & (Context!=VIRTUAL_NET_FORWARDER_CONTEXT)) ? ((PINTERFACE_CB)Context)->ICB_Index : -1,
		      ((Context!=INVALID_CONTEXT_VALUE) & (Context!=VIRTUAL_NET_FORWARDER_CONTEXT)) ? ((PINTERFACE_CB)Context)->ICB_NicId : -1,
		      fIterate
		      ));

        do { // Big loop used to iterate over interfaces
            status = STATUS_SUCCESS;    // Assume success

            // fIterate is normally set to false and so the following codepath
            // is the most common.  The only time fIterate is set to true is when
            // this is a type 20 broadcast that needs to be sent over each interface.
		    if (!fIterate) {
    		    dstNet = GETULONG (ipxHdr+IPXH_DESTNET);

			    if (Context!=INVALID_CONTEXT_VALUE) {
                    if (Context!=VIRTUAL_NET_FORWARDER_CONTEXT) {
					    // IPX driver supplied interface context, just verify that it
					    // exists and can be used to reach the destination network
				        dstIf = InterfaceContextToReference ((PVOID)Context,
												    LocalTarget->NicId);
                    }
                    else {
                        dstIf = InternalInterface;
                        AcquireInterfaceReference (dstIf);
                    }
				    if (dstIf!=NULL) {
						    // It does exist
						    // First process direct connections
					    if ((dstNet==0)
							    || (dstNet==dstIf->ICB_Network)) {
						    NOTHING;
					    }
					    else { // Network is not connected directly
						    PINTERFACE_CB	dstIf2;
							    // Verify the route
						    dstIf2 = FindDestination (dstNet,
											    ipxHdr+IPXH_DESTNODE,
												    &fwRoute);
						    if (dstIf==dstIf2) {
								    // Route OK, release the extra interface reference
							    ReleaseInterfaceReference (dstIf2);
						    }
						    else {
								    // Route not OK, release interface/route references
							    InterlockedIncrement (&InternalInterface->ICB_Stats.InNoRoutes);
							    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
								    ("IpxFwd: Failed direct internal send on"
								    " if %ld to %08lx:%02x%02x%02x%02x%02x%02x"
								    " (no route).\n",
								    dstIf->ICB_Index, dstNet,
								    LocalTarget->MacAddress[0],
									    LocalTarget->MacAddress[1],
									    LocalTarget->MacAddress[2],
									    LocalTarget->MacAddress[3],
									    LocalTarget->MacAddress[4],
									    LocalTarget->MacAddress[5]));
							    if (dstIf2!=NULL) {
								    ReleaseInterfaceReference (dstIf2);
							    }
							    status = STATUS_NETWORK_UNREACHABLE;
                                break;
						    }
					    }
				    }
				    else {
					    InterlockedIncrement (&InternalInterface->ICB_Stats.InDiscards);
					    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
						    ("IpxFwd: Invalid interface context (%08lx)"
						    " from IPX driver on internal send to"
						    " %08lx:%02x%02x%02x%02x%02x%02x.\n",
						    Context,  dstNet,
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));
                        status = STATUS_NO_SUCH_DEVICE;
                        break;
				    }
			    }
			    else {// No interface context supplied by IPX driver, have to find the route
				    dstIf = FindDestination (dstNet, ipxHdr+IPXH_DESTNODE,
										    &fwRoute);
				    if (dstIf!=NULL)
					    NOTHING;
				    else {
					    InterlockedIncrement (&InternalInterface->ICB_Stats.InNoRoutes);
					    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
						    ("IpxFwd: Failed internal send because no route to"
						    " %08lx:%02x%02x%02x%02x%02x%02x exists.\n",
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));
					    status = STATUS_NETWORK_UNREACHABLE;
                        break;
				    }
			    }
    		    InterlockedIncrement (&InternalInterface->ICB_Stats.InDelivers);
		    }

            // fIterate was set to true.
		    // In this case, the stack is calling the forwarder with fIterate set
            // to true until the fwd returns STATUS_NETWORK_UNREACHABLE.  It is
            // the fwd's job to return the NEXT nicid over which to send each time
            // it is called.  This allows the fwd to not enumerate interfaces which
            // have been disabled for netbios delivery.
		    else {
		        dstNet = 0;	// Don't care, it must be a local send

		        // See if it's a type 20 broadcast
			    if (*(ipxHdr+IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
			
			        // dstIf is initialized to null.  The only way it
			        // would be non-null is if this is not our first time through
			        // the big do-while loop in this function and if on the last
			        // time through this big loop, we found an interface that we
			        // can't send the packet over so we're looking for the next
			        // one now.
                    if (dstIf==NULL) { // First time through internal loop
   			            dstSock = GETUSHORT (ipxHdr+IPXH_DESTSOCK);

					        // See if we can get a static route for this packet
				        if (dstSock==IPX_NETBIOS_SOCKET)
					        stDstIf = FindNBDestination (data+(NB_NAME-IPXH_HDRSIZE));
				        else if (dstSock==IPX_SMB_NAME_SOCKET)
					        stDstIf = FindNBDestination (data+(SMB_NAME-IPXH_HDRSIZE));
                        else
                            stDstIf = NULL;
                    }

                    // The first time the stack calls us with fIterate==TRUE, it will
                    // give us an INVALID_CONTEXT_VALUE so we can tell it which is the
                    // first nic id in the iteration as per our interface table.
                    if ((Context==INVALID_CONTEXT_VALUE) && (dstIf==NULL)) {
                        // First time through the loop, increment counters
                    	InterlockedIncrement (&InternalInterface->ICB_Stats.InDelivers);
                    	InterlockedIncrement (&InternalInterface->ICB_Stats.NetbiosSent);

                        // stDstIf is the interface to use if there is a static route
                        // to the given network.
                        if (stDstIf!=NULL) {
                            dstIf = stDstIf;
				            IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					            ("IpxFwd: Allowed internal NB broadcast (1st iteration) on if %d (%lx)"
					            " to static name %.16s.\n",
                                dstIf->ICB_Index, dstIf,
					            (dstSock==IPX_NETBIOS_SOCKET)
						            ? data+(NB_NAME-IPXH_HDRSIZE)
						            : ((dstSock==IPX_SMB_NAME_SOCKET)
							            ? data+(SMB_NAME-IPXH_HDRSIZE)
							            : "Not a name frame")
					            ));
                        }

                        // There is no static route.  Tell the stack to use the
                        // next interface in this enumeration.
                        else {
                            dstIf = GetNextInterfaceReference (NULL);
                            if (dstIf!=NULL)
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: Allowed internal nb broadcast (1st iteration) on if %d (%lx),"
					                " to name %.16s.\n",
                                    dstIf->ICB_Index, dstIf,
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                            else {
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: Nb broadcast no destinations"
                                    " to name %.16s.\n",
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                                status = STATUS_NETWORK_UNREACHABLE;
                                break;
                            }
                        }
                    }

                    // The following path is taken if the stack provided a
                    // valid context and set fIterate to true.  Our job here
                    // is to return the next nic id according to our interface
                    // table over which to send the pack.
                    else {

                        // This path is taken if there is no static netbios route
                        if (stDstIf==NULL) {
                            // dstIf will be null if this is the first time through the
                            // big do-while loop in this function.
                            if (dstIf==NULL)
                                dstIf = InterfaceContextToReference ((PVOID)Context,
												            LocalTarget->NicId);
                            dstIf = GetNextInterfaceReference (dstIf);

                            // If we find a next interface over which to send we'll
                            // put the nic id of that interface into the local target
                            // after exiting the big do-while loop.
                            if (dstIf!=NULL) {
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: Allowed internal NB broadcast (1+ iteration)"
                                    " on if %d (%lx, ctx: %08lx, nic: %d)"
                                    " to name %.16s.\n",
                                    dstIf->ICB_Index, dstIf,
                                    Context, LocalTarget->NicId,
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                            }

                            // Otherwise, we'll break out here and return
                            // STATUS_NETWORK_UNREACHABLE which will signal to the
                            // stack that we have finished the iteration.
                            else {
				                IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					                ("IpxFwd: NB broadcast no more iterations"
                                    " for ctx: %08lx, nic: %d"
                                    " to name %.16s.\n",
                                    Context, LocalTarget->NicId,
					                (dstSock==IPX_NETBIOS_SOCKET)
						                ? data+(NB_NAME-IPXH_HDRSIZE)
						                : ((dstSock==IPX_SMB_NAME_SOCKET)
							                ? data+(SMB_NAME-IPXH_HDRSIZE)
							                : "Not a name frame")
					                ));
                                status = STATUS_NETWORK_UNREACHABLE;
                                break;
                            }
                        }

                        // This path is taken if there is a static netbios route.  In this
                        // case, we don't need to iterate over all interfaces so we break
                        // and tell the stack that we finished our iteration.
                        else {
				            IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					            ("IpxFwd: Static NB broadcast (1+ iteration)"
                                " on if %d (%lx, ctx: %08lx, nic: %d)"
                                " to name %.16s.\n",
                                stDstIf->ICB_Index, stDstIf,
                                Context, LocalTarget->NicId,
					            (dstSock==IPX_NETBIOS_SOCKET)
						            ? data+(NB_NAME-IPXH_HDRSIZE)
						            : ((dstSock==IPX_SMB_NAME_SOCKET)
							            ? data+(SMB_NAME-IPXH_HDRSIZE)
							            : "Not a name frame")
					            ));
                            ReleaseInterfaceReference (stDstIf);
                            status = STATUS_NETWORK_UNREACHABLE;
                            break;
                        }
                    }
                }

                // This path is taken if fIterate was set to true but this
                // is not a type 20 broadcast.  I doubt that this path is
                // ever even taken since for general broadcasts, the stack
                // handles the iteration.
                else {
                    if ((dstIf==NULL)
                            && (Context!=INVALID_CONTEXT_VALUE))
                        dstIf = InterfaceContextToReference ((PVOID)Context,
												        LocalTarget->NicId);
                    dstIf = GetNextInterfaceReference (dstIf);
                    if (dstIf!=NULL) {
				        IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					        ("IpxFwd: Allowed internal iterative send"
                            " on if %d (%lx, ctx: %08lx, nic: %d)"
						    " to %02x%02x%02x%02x%02x%02x.\n",
                            dstIf->ICB_Index, dstIf,
                            Context, LocalTarget->NicId,
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));

                    }
                    else {
				        IpxFwdDbgPrint (DBG_NETBIOS, DBG_INFORMATION,
					        ("IpxFwd: No destinations to internal iterative send"
                            " for ctx: %08lx, nic: %d"
						    " to %02x%02x%02x%02x%02x%02x.\n",
                            Context, LocalTarget->NicId,
						    LocalTarget->MacAddress[0],
							    LocalTarget->MacAddress[1],
							    LocalTarget->MacAddress[2],
							    LocalTarget->MacAddress[3],
							    LocalTarget->MacAddress[4],
							    LocalTarget->MacAddress[5]));
                        status = STATUS_NETWORK_UNREACHABLE;
                        break;
                    }
                }

	        }	// End iterative send processing

		    // We were able to find a destination interface
		    if (IS_IF_ENABLED (dstIf)
                    && ((*(ipxHdr+IPXH_PKTTYPE) != IPX_NETBIOS_TYPE)
                        || (dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_ALL)
                        || ((dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_IF_UP)
				            && (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP))
                        || ((stDstIf!=NULL)
                            && (dstIf->ICB_NetbiosDeliver==FWD_NB_DELIVER_STATIC)))) {
            	KIRQL			oldIRQL;
                FILTER_ACTION   action;

                // In/Out filter check and statistics update

                action = FltFilter (ipxHdr, IPXH_HDRSIZE,
						    InternalInterface->ICB_FilterInContext,
						    dstIf->ICB_FilterOutContext);
			    if (action==FILTER_PERMIT) {
                    NOTHING;
			    }
			    else {
                    InterlockedIncrement (&dstIf->ICB_Stats.OutFiltered);
				    status = STATUS_NETWORK_UNREACHABLE;
                    break;
			    }

        		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
				// All set, try to send now
	    		switch (dstIf->ICB_Stats.OperationalState) {
		    	case FWD_OPER_STATE_UP:
					    // Interface is up, let it go right away
					    // Set NIC ID
                    if (dstIf!=InternalInterface) {
				        ADAPTER_CONTEXT_TO_LOCAL_TARGET (
								        dstIf->ICB_AdapterContext,
								        LocalTarget);
                    }
                    else {
				        CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET (
								        VIRTUAL_NET_ADAPTER_CONTEXT,
								        LocalTarget);
                    }
					    // Set destination node
				    if (IsLocalSapNonAgentAdvertisement (ipxHdr,data,PacketLength,dstIf)) {
						    // Loop back sap ads from non-sap socket
					    IPX_NODE_CPY (&LocalTarget->MacAddress,
                                        dstIf->ICB_LocalNode);
                    }
				    else if ((dstNet==0) || (dstNet==dstIf->ICB_Network)) {
						    // Direct connection: send to destination specified
						    // in the header
					    IPX_NODE_CPY (LocalTarget->MacAddress,
									    ipxHdr+IPXH_DESTNODE);
				    }
				    else {	// Indirect connection: send to next hop router
					    if (dstIf->ICB_InterfaceType==FWD_IF_PERMANENT) {
						    ASSERT (fwRoute!=NULL);
						    IPX_NODE_CPY (LocalTarget->MacAddress,
									    fwRoute->FR_NextHopAddress);
					    }
					    else {
							    // Only one peer on the other side
						    IPX_NODE_CPY (LocalTarget->MacAddress,
									    dstIf->ICB_RemoteNode);
					    }
				    }
				    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
					    // Update statistics
				    InterlockedIncrement (
					    &dstIf->ICB_Stats.OutDelivers);
				    if (*(ipxHdr+IPXH_PKTTYPE)==IPX_NETBIOS_TYPE)
					    InterlockedIncrement (
						    &dstIf->ICB_Stats.NetbiosSent);

				    IpxFwdDbgPrint (DBG_INT_SEND, DBG_INFORMATION,
					    ("IpxFwd: Allowed internal send:"
					    " %ld-%08lx:%02x%02x%02x%02x%02x%02x.\n",
					    dstIf->ICB_Index, dstNet,
					    LocalTarget->MacAddress[0],
						    LocalTarget->MacAddress[1],
						    LocalTarget->MacAddress[2],
						    LocalTarget->MacAddress[3],
						    LocalTarget->MacAddress[4],
						    LocalTarget->MacAddress[5]));
				    // status = STATUS_SUCCESS;	// Let it go
				    break;
			    case FWD_OPER_STATE_SLEEPING:
					    // Interface is disconnected, queue the packet and try to connecte
				    if ((*(ipxHdr+IPXH_PKTTYPE)!=0)
						    || (*(ipxHdr+IPXH_LENGTH)!=IPXH_HDRSIZE+2)
						    || (*(data+1)!='?')) {
						    // Not a keep-alive packet,
					    if (((*(ipxHdr+IPXH_PKTTYPE)!=IPX_NETBIOS_TYPE))
							    || (dstIf->ICB_NetbiosDeliver!=FWD_NB_DELIVER_IF_UP)) {
							    // Not a netbios broadcast or we are allowed to connect
							    // the interface to deliver netbios broadcasts
						    if (InterlockedDecrement (&dstIf->ICB_PendingQuota)>=0) {
							    PINTERNAL_PACKET_TAG	pktTag;
								    // Create a queue element to enqueue the packet
							    pktTag = (PINTERNAL_PACKET_TAG)ExAllocatePoolWithTag (
														    NonPagedPool,
														    sizeof (INTERNAL_PACKET_TAG),
														    FWD_POOL_TAG);
							    if (pktTag!=NULL) {
								    pktTag->IPT_Packet = pktDscr;
								    pktTag->IPT_Length = PacketLength;
								    pktTag->IPT_DataPtr = ipxHdr;
									    // Save next hop address if after connection is
									    // established we determine that destination net
									    // is not connected directly
								    if (fwRoute!=NULL)
									    IPX_NODE_CPY (pktTag->IPT_Target.MacAddress,
													    fwRoute->FR_NextHopAddress);
								    AcquireInterfaceReference (dstIf);	// To make sure interface
												    // block won't go away until we are done with
												    // the packet
								    pktTag->IPT_InterfaceReference = dstIf;
								    InsertTailList (&dstIf->ICB_InternalQueue,
														    &pktTag->IPT_QueueLink);
								    if (!IS_IF_CONNECTING (dstIf)) {
									    QueueConnectionRequest (dstIf, pktDscr, ipxHdr, oldIRQL);
									    IpxFwdDbgPrint (DBG_DIALREQS, DBG_WARNING,
										    ("IpxFwd: Queued dd request on if %ld (ifCB:%08lx)"
										    " for internal packet"
										    " to %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%02x%02x"
										    " from socket:%02x%02x\n",
										    dstIf->ICB_Index, dstIf,
										    *(ipxHdr+6),*(ipxHdr+7),
												    *(ipxHdr+8),*(ipxHdr+9),
											    *(ipxHdr+10),*(ipxHdr+11),
												    *(ipxHdr+12),*(ipxHdr+13),
												    *(ipxHdr+14),*(ipxHdr+15),
											    *(ipxHdr+16),*(ipxHdr+17),
										    *(ipxHdr+28),*(ipxHdr+29)));
								    }
								    else
									    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
								    IpxFwdDbgPrint (DBG_INT_SEND, DBG_INFORMATION,
									    ("IpxFwd: Queueing internal send packet %08lx on if %ld.\n",
									    pktTag, dstIf->ICB_Index));
								    status = STATUS_PENDING;
								    break;
							    }
							    else {
								    IpxFwdDbgPrint (DBG_INT_SEND, DBG_ERROR,
									    ("IpxFwd: Could not allocate"
									    " internal packet tag.\n"));
							    }
						    }
						    InterlockedIncrement (&dstIf->ICB_PendingQuota);
					    }
					    else {
						    IpxFwdDbgPrint (DBG_NETBIOS, DBG_WARNING,
							    ("IpxFwd: Droped internal NB packet"
							    " because FWD_NB_DELIVER_IF_UP.\n"));
					    }
				    }
				    else { // Process keep-alives
					    LONGLONG	curTime;
					    KeQuerySystemTime ((PLARGE_INTEGER)&curTime);
					    if (((curTime-dstIf->ICB_DisconnectTime)/10000000) < SpoofingTimeout) {
						    PPACKET_TAG pktTag;
							    // Spoofing timeout has not been exceeded,
							    // Create a reply packet
						    AllocatePacket (WanPacketListId,
								    WanPacketListId,
								    pktTag);
						    if (pktTag!=NULL) {
							    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
							    PUTUSHORT (0xFFFF, pktTag->PT_Data+IPXH_CHECKSUM);
							    PUTUSHORT ((IPXH_HDRSIZE+2), pktTag->PT_Data+IPXH_LENGTH);
							    *(pktTag->PT_Data+IPXH_XPORTCTL) = 0;
							    *(pktTag->PT_Data+IPXH_PKTTYPE) = 0;
							    memcpy (pktTag->PT_Data+IPXH_DESTADDR,
									    ipxHdr+IPXH_SRCADDR,
									    12);
							    memcpy (pktTag->PT_Data+IPXH_SRCADDR,
									    ipxHdr+IPXH_DESTADDR,
									    12);
							    *(pktTag->PT_Data+IPXH_HDRSIZE) = *data;
							    *(pktTag->PT_Data+IPXH_HDRSIZE+1) = 'Y';
								    // Destination for this packet will have to
								    // be the first active LAN adapter in the system
								    // SHOULD BE REMOVED WHEN LOOPBACK SUPPORT US ADDED BY IPX

							    pktTag->PT_InterfaceReference = NULL;
							    IpxFwdDbgPrint (DBG_SPOOFING, DBG_INFORMATION,
								    ("IpxFwd: Queueing reply to keepalive from internal server"
								    " at %02x%02x.\n",*(ipxHdr+IPXH_DESTSOCK),*(ipxHdr+IPXH_DESTSOCK+1)));
								    // Enqueue to spoofing queue to be sent back
								    // to the server
							    KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
							    InsertTailList (&SpoofingQueue, &pktTag->PT_QueueLink);
								    // Start worker if not running already
							    if (!SpoofingWorkerActive
									    && EnterForwarder()) {
								    SpoofingWorkerActive = TRUE;
								    ExQueueWorkItem (&SpoofingWorker, DelayedWorkQueue);
							    }
							    KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
							    status = STATUS_DROP_SILENTLY;
							    break;
						    }
						    else {
							    IpxFwdDbgPrint (DBG_SPOOFING, DBG_ERROR,
								    ("IpxFwd: Could not allocate"
								    " packet tag for spoofing.\n"));
						    }
					    }
					    else {
						    IpxFwdDbgPrint (DBG_SPOOFING, DBG_WARNING,
							    ("IpxFwd: Internal spoofing"
							    " timeout exceded.\n"));
					    }
				    }
			    case FWD_OPER_STATE_DOWN:
					    // Interface down or send failed
				    KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
				    if (*(ipxHdr+IPXH_PKTTYPE)!=IPX_NETBIOS_TYPE)
    				    InterlockedIncrement (
						    &dstIf->ICB_Stats.OutDiscards);
				    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
					    ("IpxFwd: Internal send not allowed"
					    " on if %ld (down?).\n", dstIf->ICB_Index));
				    status = STATUS_NETWORK_UNREACHABLE;
				    break;
			    default:
				    ASSERTMSG ("Invalid operational state ", FALSE);
			    }
		    }
		    else {// Interface is disabled
    		    if (*(ipxHdr+IPXH_PKTTYPE)!=IPX_NETBIOS_TYPE)
	    		    InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
			    IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
				    ("IpxFwd: Internal send not allowed"
				    " on because dst if (or Netbios deliver on it) %ld (ifCB: %08lx) is disabled.\n",
				    dstIf->ICB_Index, dstIf));
                status = STATUS_NETWORK_UNREACHABLE;
		    }

		
	    }
        while (fIterate && (status!=STATUS_SUCCESS) && (status!=STATUS_PENDING));

        if (dstIf!=NULL)
		    ReleaseInterfaceReference (dstIf);
		if (fwRoute!=NULL)
			ReleaseRouteReference (fwRoute);
    }
	else {	// Internal interface is disabled
		IpxFwdDbgPrint (DBG_INT_SEND, DBG_WARNING,
			("IpxFwd: Internal send not allowed"
			" because internal if (or Netbios accept on it) is disabled.\n"));
		InterlockedIncrement (
				&InternalInterface->ICB_Stats.InDiscards);
		status = STATUS_NETWORK_UNREACHABLE;
	}

	LeaveForwarder ();
	return status;
}


/*++
*******************************************************************

	P r o c e s s I n t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface internal queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessInternalQueue (
	PINTERFACE_CB	dstIf
	) {
	KIRQL						oldIRQL;
	LIST_ENTRY					tempQueue;

	KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
	InsertHeadList (&dstIf->ICB_InternalQueue, &tempQueue);
	RemoveEntryList (&dstIf->ICB_InternalQueue);
	InitializeListHead (&dstIf->ICB_InternalQueue);
	KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);

	while (!IsListEmpty (&tempQueue)) {
		PINTERNAL_PACKET_TAG		pktTag;
		PLIST_ENTRY					cur;
		NTSTATUS					status;

		cur = RemoveHeadList (&tempQueue);
		pktTag = CONTAINING_RECORD (cur, INTERNAL_PACKET_TAG, IPT_QueueLink);
		InterlockedIncrement (&dstIf->ICB_PendingQuota);

		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
		if (IS_IF_ENABLED(dstIf)
				&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)) {
			IPX_NODE_CPY (pktTag->IPT_Target.MacAddress,
								dstIf->ICB_RemoteNode);
			ADAPTER_CONTEXT_TO_LOCAL_TARGET (
									dstIf->ICB_AdapterContext,
									&pktTag->IPT_Target);
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			InterlockedIncrement (&dstIf->ICB_Stats.OutDelivers);
			if (*(pktTag->IPT_DataPtr + IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
				InterlockedIncrement (&dstIf->ICB_Stats.NetbiosSent);
			}
			status = STATUS_SUCCESS;
		}
		else {
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
			status = STATUS_NETWORK_UNREACHABLE;
		}

		IPXInternalSendCompletProc (&pktTag->IPT_Target,
							pktTag->IPT_Packet,
							pktTag->IPT_Length,
							status);
		IpxFwdDbgPrint (DBG_INT_SEND,
				NT_SUCCESS (status) ? DBG_INFORMATION : DBG_WARNING,
				("IpxFwd: Returned internal packet %08lx"
				" for send on if %ld with status %08lx.\n",
				pktTag, dstIf->ICB_Index, status));
		ReleaseInterfaceReference (pktTag->IPT_InterfaceReference);
		ExFreePool (pktTag);
	}
}
			
		

/*++
*******************************************************************

	P r o c e s s E x t e r n a l Q u e u e

Routine Description:
	Processes packets in the interface external queue.
	Called when connection request completes
Arguments:
	dstIf - interface to process
Return Value:
	None
*******************************************************************
--*/
VOID
ProcessExternalQueue (
	PINTERFACE_CB	dstIf
	) {
	KIRQL						oldIRQL;
	LIST_ENTRY					tempQueue;

	KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
	InsertHeadList (&dstIf->ICB_ExternalQueue, &tempQueue);
	RemoveEntryList (&dstIf->ICB_ExternalQueue);
	InitializeListHead (&dstIf->ICB_ExternalQueue);
	KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);

	while (!IsListEmpty (&tempQueue)) {
		PPACKET_TAG					pktTag;
		PLIST_ENTRY					cur;
		NDIS_STATUS					status;

		cur = RemoveHeadList (&tempQueue);
		pktTag = CONTAINING_RECORD (cur, PACKET_TAG, PT_QueueLink);

		KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
		if (IS_IF_ENABLED(dstIf)
				&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)) {
			IPX_NODE_CPY (pktTag->PT_Target.MacAddress,
								dstIf->ICB_RemoteNode);
			if (*(pktTag->PT_Data + IPXH_PKTTYPE) == IPX_NETBIOS_TYPE) {
				PUTULONG (dstIf->ICB_Network, pktTag->PT_Data+IPXH_DESTNET);
			}
			status = DoSend (dstIf, pktTag, oldIRQL);
			IpxFwdDbgPrint (DBG_SEND, DBG_INFORMATION,
				("IpxFwd: Sent queued external packet %08lx if %ld.\n",
				pktTag, dstIf->ICB_Index));
		}
		else {
			KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			IpxFwdDbgPrint (DBG_SEND, DBG_WARNING,
				("IpxFwd: Dropped queued external packet %08lx on dead if %ld.\n",
				pktTag, dstIf->ICB_Index));
			status = STATUS_UNSUCCESSFUL;
		}

		if (status!=STATUS_PENDING)
			ProcessSentPacket (dstIf, pktTag, status);
	}
}
			
		
/*++
*******************************************************************

	S p o o f e r

Routine Description:
	Processes packets in spoofing queue
Arguments:
	None
Return Value:
	None
*******************************************************************
--*/
VOID
Spoofer (
	PVOID	Context
	) {
	KIRQL		oldIRQL;
	NTSTATUS	status;
	UNREFERENCED_PARAMETER (Context);

	KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
		// Keep going till queue is empty
	while (!IsListEmpty (&SpoofingQueue)) {
		PINTERFACE_CB dstIf;
		PPACKET_TAG pktTag = CONTAINING_RECORD (SpoofingQueue.Flink,
										PACKET_TAG,
										PT_QueueLink);
		RemoveEntryList (&pktTag->PT_QueueLink);
		KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
		dstIf = pktTag->PT_InterfaceReference;
		if (dstIf==NULL) {
				// Replies for internal server require first active LAN adapter
				// SHOULD BE REMOVED WHEN LOOPBACK SUPPORT US ADDED BY IPX
			while ((dstIf=GetNextInterfaceReference (dstIf))!=NULL) {
				KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
				if (IS_IF_ENABLED (dstIf)
						&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)
						&& (dstIf->ICB_InterfaceType==FWD_IF_PERMANENT)) {
					pktTag->PT_InterfaceReference = dstIf;
					IPX_NODE_CPY (&pktTag->PT_Target.MacAddress, dstIf->ICB_LocalNode);
					status = DoSend (dstIf, pktTag, oldIRQL);	// releases spin lock
					if (status!=STATUS_PENDING)
						ProcessSentPacket (dstIf, pktTag, status);
					break;
				}
				else
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
			}
			if (dstIf==NULL) {
				FreePacket (pktTag);
			}

		}
		else {	// Reply for external server, interface is already known
			UCHAR	addr[12];
            FILTER_ACTION   action;
			pktTag->PT_Flags &= (~PT_SOURCE_IF);
			
				// Switch source and destination
			memcpy (addr, pktTag->PT_Data+IPXH_DESTADDR, 12);
			memcpy (pktTag->PT_Data+IPXH_DESTADDR,
				pktTag->PT_Data+IPXH_SRCADDR, 12);
			memcpy (pktTag->PT_Data+IPXH_SRCADDR, addr, 12);
				// Say yes in reply
			*(pktTag->PT_Data+IPXH_HDRSIZE+1) = 'Y';

            action = FltFilter (pktTag->PT_Data,
					GETUSHORT (pktTag->PT_Data+IPXH_LENGTH),
					dstIf->ICB_FilterInContext,
					pktTag->PT_SourceIf->ICB_FilterOutContext);
			if (action==FILTER_PERMIT) {

					// Release destination if and use source as destination
				ReleaseInterfaceReference (dstIf);
				dstIf = pktTag->PT_InterfaceReference = pktTag->PT_SourceIf;
				// Send the packet if we can
				KeAcquireSpinLock (&dstIf->ICB_Lock, &oldIRQL);
				if (IS_IF_ENABLED (dstIf)
					&& (dstIf->ICB_Stats.OperationalState==FWD_OPER_STATE_UP)) {
					status = DoSend (dstIf, pktTag, oldIRQL);
					if (status!=STATUS_PENDING)
						ProcessSentPacket (dstIf, pktTag, status);
				}
				else {
					KeReleaseSpinLock (&dstIf->ICB_Lock, oldIRQL);
					InterlockedIncrement (&dstIf->ICB_Stats.OutDiscards);
					ReleaseInterfaceReference (dstIf);
					FreePacket (pktTag);
				}
			}
			else {
                if (action==FILTER_DENY_OUT)
				    InterlockedIncrement (&pktTag->PT_SourceIf->ICB_Stats.OutFiltered);
                else {
                    ASSERT (action==FILTER_DENY_IN);
				    InterlockedIncrement (&dstIf->ICB_Stats.InFiltered);
                }
				ReleaseInterfaceReference (dstIf);
				ReleaseInterfaceReference (pktTag->PT_SourceIf);
				FreePacket (pktTag);
			}
		}
		KeAcquireSpinLock (&SpoofingQueueLock, &oldIRQL);
	} // end while
	SpoofingWorkerActive = FALSE;
	KeReleaseSpinLock (&SpoofingQueueLock, oldIRQL);
	LeaveForwarder ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\fwd\registry.c ===
/*******************************************************************/
/*	      Copyright(c)  1993 Microsoft Corporation		   */
/*******************************************************************/

//***
//
// Filename:	registry.c
//
// Description: routines for reading the registry configuration
//
// Author:	Stefan Solomon (stefans)    November 9, 1993.
//
// Revision History:
//		Updated to read parameters of new forwarder driver (11/95)
//
//***

#include    "precomp.h"

NTSTATUS
SetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

/*++
*******************************************************************
    R e a d I p x D e v i c e N a m e

Routine Description:
	Allocates buffer and reads device name exported by the IPX stack
	into it
Arguments:
	FileName - pointer to buffer to hold the name
Return Value:
	STATUS_SUCCESS - tables were created ok
	STATUS_INSUFFICIENT_RESOURCES - resource allocation failed
	STATUS_OBJECT_NAME_NOT_FOUND - if name value is not found
*******************************************************************
--*/
NTSTATUS
ReadIpxDeviceName (
	PWSTR		*FileName
	) {
    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWSTR Export = L"Export";
    PWSTR IpxRegistryPath = L"NwLnkIpx\\Linkage";

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Call SetIpxDeviceName for the string in "Export"
    //

    QueryTable[0].QueryRoutine = SetIpxDeviceName;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = Export;
    QueryTable[0].EntryContext = FileName;
    QueryTable[0].DefaultType = 0;

    //
    // 2) Stop
    //

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_SERVICES,
		 IpxRegistryPath,
         QueryTable,
		 NULL,
         NULL);

    return Status;
}


/*++
*******************************************************************
	S e t I p x D e v i c e N a m e

Routine Description:
    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string and
    saves the information in a ConfigurationInfo structure.
Arguments:
    ValueName - The name of the value ("Export" -- ignored).
    ValueType - The type of the value (REG_SZ -- ignored).
    ValueData - The null-terminated data for the value.
    ValueLength - The length of ValueData.
    Context - NULL.
    EntryContext - file name pointer.
Return Value:
    STATUS_SUCCESS - name was allocated and copied OK
	STATUS_INSUFFICIENT_RESOURCES - name allocation failed
*******************************************************************
--*/
NTSTATUS
SetIpxDeviceName(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    ) {
	PWSTR	*FileName = (PWSTR *)EntryContext;

	ASSERT (ValueType==REG_SZ);
    *FileName = (PWSTR)ExAllocatePoolWithTag(NonPagedPool,
								ValueLength, FWD_POOL_TAG);
    if (*FileName != NULL) {
		RtlCopyMemory (*FileName, ValueData, ValueLength);
	    return STATUS_SUCCESS;
	}
	else
		return STATUS_INSUFFICIENT_RESOURCES;

}

/*++
*******************************************************************
	G e t R o u t e r P a r a m e t e r s

Routine Description:
	Reads the parameters from the registry or sets the defaults
Arguments:
	RegistryPath - where to read from.
Return Value:
    STATUS_SUCCESS
*******************************************************************
--*/
NTSTATUS
GetForwarderParameters (
	IN PUNICODE_STRING RegistryPath
	) {
    NTSTATUS Status;
    PWSTR RegistryPathBuffer;
    PWSTR Parameters = L"Parameters";
    RTL_QUERY_REGISTRY_TABLE	paramTable[11]; // table size = nr of params + 1

    RegistryPathBuffer = (PWSTR)ExAllocatePool(NonPagedPool, RegistryPath->Length + sizeof(WCHAR));

    if (RegistryPathBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    RtlZeroMemory(&paramTable[0], sizeof(paramTable));

    paramTable[0].QueryRoutine = NULL;
    paramTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    paramTable[0].Name = Parameters;

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"MaxRcvPktPoolSize";
    paramTable[1].EntryContext = &MaxRcvPktsPoolSize;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &MaxRcvPktsPoolSize;
    paramTable[1].DefaultLength = sizeof(ULONG);
        
    paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name = L"RcvPktsPerSegment";
    paramTable[2].EntryContext = &RcvPktsPerSegment;
    paramTable[2].DefaultType = REG_DWORD;
    paramTable[2].DefaultData = &RcvPktsPerSegment;
    paramTable[2].DefaultLength = sizeof(ULONG);

    paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name = L"RouteTableSegmentSize";
    paramTable[3].EntryContext = &RouteSegmentSize;
    paramTable[3].DefaultType = REG_DWORD;
    paramTable[3].DefaultData = &RouteSegmentSize;
    paramTable[3].DefaultLength = sizeof(ULONG);

    paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name = L"MaxSendPktsQueued";
    paramTable[4].EntryContext = &MaxSendPktsQueued;
    paramTable[4].DefaultType = REG_DWORD;
    paramTable[4].DefaultData = &MaxSendPktsQueued;
    paramTable[4].DefaultLength = sizeof(ULONG);

    paramTable[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[5].Name = L"ClientHashSize";
    paramTable[5].EntryContext = &ClientHashSize;
    paramTable[5].DefaultType = REG_DWORD;
    paramTable[5].DefaultData = &ClientHashSize;
    paramTable[5].DefaultLength = sizeof(ULONG);

    paramTable[6].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[6].Name = L"InterfaceHashSize";
    paramTable[6].EntryContext = &InterfaceHashSize;
    paramTable[6].DefaultType = REG_DWORD;
    paramTable[6].DefaultData = &InterfaceHashSize;
    paramTable[6].DefaultLength = sizeof(ULONG);

    paramTable[7].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[7].Name = L"MaxNetbiosPacketsQueued";
    paramTable[7].EntryContext = &MaxNetbiosPacketsQueued;
    paramTable[7].DefaultType = REG_DWORD;
    paramTable[7].DefaultData = &MaxNetbiosPacketsQueued;
    paramTable[7].DefaultLength = sizeof(ULONG);

    paramTable[8].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[8].Name = L"SpoofingTimeout";
    paramTable[8].EntryContext = &SpoofingTimeout;
    paramTable[8].DefaultType = REG_DWORD;
    paramTable[8].DefaultData = &SpoofingTimeout;
    paramTable[8].DefaultLength = sizeof(ULONG);

    paramTable[9].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[9].Name = L"DontSuppressNonAgentSapAdvertisements";
    paramTable[9].EntryContext = &DontSuppressNonAgentSapAdvertisements;
    paramTable[9].DefaultType = REG_DWORD;
    paramTable[9].DefaultData = &DontSuppressNonAgentSapAdvertisements;
    paramTable[9].DefaultLength = sizeof(ULONG);

    Status = RtlQueryRegistryValues(
		 RTL_REGISTRY_ABSOLUTE,
		 RegistryPathBuffer,
		 paramTable,
		 NULL,
		 NULL);

    if(!NT_SUCCESS(Status)) {

	IpxFwdDbgPrint (DBG_REGISTRY, DBG_WARNING,
		("IpxFwd: Missing Parameters key in the registry\n"));
    }

    ExFreePool(RegistryPathBuffer);

    if ((RcvPktsPerSegment > MAX_RCV_PKTS_PER_SEGMENT) ||
			(RcvPktsPerSegment < MIN_RCV_PKTS_PER_SEGMENT)) {

       RcvPktsPerSegment = DEF_RCV_PKTS_PER_SEGMENT;
    }

    if ((RouteSegmentSize > MAX_ROUTE_SEGMENT_SIZE) ||
			(RouteSegmentSize < MIN_ROUTE_SEGMENT_SIZE)) {

       RouteSegmentSize = DEF_ROUTE_SEGMENT_SIZE;
    }
	else
		RouteSegmentSize = (ULONG) ROUND_TO_PAGES(RouteSegmentSize);

    if ((InterfaceHashSize > MAX_INTERFACE_HASH_SIZE) ||
			(InterfaceHashSize < MIN_INTERFACE_HASH_SIZE)) {

       InterfaceHashSize = DEF_INTERFACE_HASH_SIZE;
    }

    if ((ClientHashSize > MAX_CLIENT_HASH_SIZE) ||
			(ClientHashSize < MIN_CLIENT_HASH_SIZE)) {

       ClientHashSize = DEF_CLIENT_HASH_SIZE;
    }
    // even if the RtlQueryRegistryValues has failed, we return success and will
    // use the defaults.
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\inc\bind.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    bind.h

Abstract:

    Private include file for the ISN transport. It defines the
    structures used for binding between IPX and the upper drivers.

Author:

    Adam Barr (adamba) 04-Oct-1993

Revision History:

   Sanjay Anand (SanjayAn) 5-July-1995
   Bug fixes - tagged [SA]

   Ting Cai (TingCai) Sept-18-1998
   Port the to 64-bit environment
   #ifdef SUNDOWN
      ULONG FwdAdapterContext	
   #else
      ULONG_PTR FwdAdapterContext			
   #endif
   
--*/

#ifndef _ISN_BIND_
#define _ISN_BIND_

//
// Retrieve the common definitions.
//

#include <isnkrnl.h>


//
// Define the IOCTL used for binding between the upper
// drivers and IPX.
//

#define _IPX_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)

#define IOCTL_IPX_INTERNAL_BIND      _IPX_CONTROL_CODE( 0x1234, METHOD_BUFFERED )


//
// [FW] Error codes - reusing NTSTATUS codes
//

#define  STATUS_ADAPTER_ALREADY_OPENED    STATUS_UNSUCCESSFUL
#define  STATUS_ADAPTER_ALREADY_CLOSED    STATUS_UNSUCCESSFUL
#define  STATUS_FILTER_FAILED             STATUS_UNSUCCESSFUL
#define  STATUS_DROP_SILENTLY             STATUS_UNSUCCESSFUL

//
// Identifier for the drivers in ISN.
//

#define IDENTIFIER_NB  0
#define IDENTIFIER_SPX 1
#define IDENTIFIER_RIP 2
#define IDENTIFIER_IPX 3

#ifdef	_PNP_POWER
//
// This the number of PVOIDs in the beginning of the SEND_RESERVED
// section of a packet header, to be set aside by the ISN clients (NB/SPX)
// for IPX's private use.
//
#define	SEND_RESERVED_COMMON_SIZE	8
#endif

//
// Definition of a RIP router table entry.
//

typedef struct _IPX_ROUTE_ENTRY {
    UCHAR Network[4];
    USHORT NicId;
    UCHAR NextRouter[6];
    NDIS_HANDLE NdisBindingContext;
    USHORT Flags;
    USHORT Timer;
    UINT Segment;
    USHORT TickCount;
    USHORT HopCount;
    LIST_ENTRY AlternateRoute;
    LIST_ENTRY NicLinkage;
    struct {
        LIST_ENTRY Linkage;
        ULONG Reserved[1];
    } PRIVATE;
} IPX_ROUTE_ENTRY, * PIPX_ROUTE_ENTRY;

//
// Definition of the Flags values.
//

#define IPX_ROUTER_PERMANENT_ENTRY    0x0001    // entry should never be deleted
#define IPX_ROUTER_LOCAL_NET          0x0002    // locally attached network
#define IPX_ROUTER_SCHEDULE_ROUTE     0x0004    // call ScheduleRouteHandler after using
#define IPX_ROUTER_GLOBAL_WAN_NET     0x0008    // this is for rip's global network number


//
// Definition of the structure provided on a find
// route/find route completion call.
//

//
// [SA] Bug #15094 added node number to the structure.
//

//
// [FW] Added Hop and Tick counts so this structure can be passed
// as such to the Forwarder - hop and tick counts are queried in actions
//

typedef struct _IPX_FIND_ROUTE_REQUEST {
    UCHAR Network[4];
    UCHAR Node[6] ;
    IPX_LOCAL_TARGET LocalTarget;
    USHORT TickCount;   // [FW]
    USHORT HopCount;    // [FW]
    UCHAR Identifier;
    UCHAR Type;
    UCHAR Reserved1[2];
    PVOID Reserved2;
    LIST_ENTRY Linkage;
} IPX_FIND_ROUTE_REQUEST, *PIPX_FIND_ROUTE_REQUEST;

//
// Definitions for the Type value.
//

#define IPX_FIND_ROUTE_NO_RIP        1  // fail if net is not in database
#define IPX_FIND_ROUTE_RIP_IF_NEEDED 2  // return net if in database, otherwise RIP out
#define IPX_FIND_ROUTE_FORCE_RIP     3  // re-RIP even if net is in database


//
// Structure used when querying the line information
// for a specific NID ID.
//

typedef struct _IPX_LINE_INFO {
    UINT LinkSpeed;
    UINT MaximumPacketSize;
    UINT MaximumSendSize;
    UINT MacOptions;
} IPX_LINE_INFO, *PIPX_LINE_INFO;



//
// Functions provided by the upper driver.
//

//
// [FW] Added the ForwarderAdapterContext to the paramters
// SPX/NB can ignore this for now
//

typedef BOOLEAN
(*IPX_INTERNAL_RECEIVE) (
    IN NDIS_HANDLE MacBindingHandle,
    IN NDIS_HANDLE MacReceiveContext,
    IN ULONG_PTR FwdAdapterContext,  // [FW]
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN ULONG MacOptions,
    IN PUCHAR LookaheadBuffer,
    IN UINT LookaheadBufferSize,
    IN UINT LookaheadBufferOffset,
    IN UINT PacketSize,
    IN PMDL pMdl
);

typedef VOID
(*IPX_INTERNAL_RECEIVE_COMPLETE) (
    IN USHORT NicId
);

//
// [FW] Status and ScheduleRoute removed from the bind input
// [ZZZZZZZZZ]

typedef VOID
(*IPX_INTERNAL_STATUS) (
    IN USHORT NicId,
    IN NDIS_STATUS GeneralStatus,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferLength
);

typedef VOID
(*IPX_INTERNAL_SCHEDULE_ROUTE) (
    IN PIPX_ROUTE_ENTRY RouteEntry
);

typedef VOID
(*IPX_INTERNAL_SEND_COMPLETE) (
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
);

typedef VOID
(*IPX_INTERNAL_TRANSFER_DATA_COMPLETE) (
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status,
    IN UINT BytesTransferred
);

typedef VOID
(*IPX_INTERNAL_FIND_ROUTE_COMPLETE) (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest,
    IN BOOLEAN FoundRoute
);

typedef VOID
(*IPX_INTERNAL_LINE_UP) (
    IN USHORT NicId,
    IN PIPX_LINE_INFO LineInfo,
    IN NDIS_MEDIUM DeviceType,
    IN PVOID ConfigurationData
);

typedef VOID
(*IPX_INTERNAL_LINE_DOWN) (
    IN USHORT NicId,
    IN ULONG_PTR  FwdAdapterContext
);

#if defined(_PNP_POWER)

//
// following opcodes are used when calling the
// above handler.
//
typedef enum _IPX_PNP_OPCODE {
    IPX_PNP_ADD_DEVICE,         // 0 - addition of the first adapter
    IPX_PNP_DELETE_DEVICE,      // 1 - deletion of the last adapter
    IPX_PNP_TRANSLATE_DEVICE,   // 2 - translate device resource
    IPX_PNP_TRANSLATE_ADDRESS,  // 3 - translate address resource
    IPX_PNP_ADDRESS_CHANGE,     // 4 - Adapter address or Reserved address changed
    IPX_PNP_QUERY_POWER,        // 5 - NDIS queries if power can go off
    IPX_PNP_SET_POWER,          // 6 - NDIS tells that power is going off
    IPX_PNP_QUERY_REMOVE,       // 7 - NDIS queries if adapter can be removed
    IPX_PNP_CANCEL_REMOVE,       // 8 - NDIS cancels the query_remove
    IPX_PNP_MAX_OPCODES,        // 9
} IPX_PNP_OPCODE, *PIPX_PNP_OPCODE;

//
// PnP event notification handler.
//
typedef NTSTATUS
(*IPX_INTERNAL_PNP_NOTIFICATION) (
    IN      IPX_PNP_OPCODE      PnPOpcode,
    IN OUT  PVOID               PnpData
);

//
// Pointer to this structure is passed in PnPData portion of
// the above handler when the opcode is ADD_DEVICE or DELETE_DEVICE.
//
typedef struct _IPX_PNP_INFO {
    ULONG   NetworkAddress;
    UCHAR   NodeAddress[6];
    BOOLEAN NewReservedAddress;  // where the above is a new reserved
                                // address for the Ipx clients.
    BOOLEAN FirstORLastDevice;  // is this a first card arrival or last card deletion.
    IPX_LINE_INFO   LineInfo;   // New LineInfo.
    NIC_HANDLE NicHandle;
} IPX_PNP_INFO, *PIPX_PNP_INFO;

#endif  _PNP_POWER

//
// [FW] New entry points provided by the Kernel Forwarder.
// These are not filled in by NB and SPX.
//

/*++

Routine Description:

   This routine is provided by the Kernel Forwarder to filter packets being sent out
   by NB/SPX/TDI thru' IPX - does not include those sent out by the Forwarder (external sends)

Arguments:

   LocalTarget - the NicId and next hop router MAC address

   FwdAdapterContext - Forwarder's context - preferred NIC if not INVALID_CONTEXT_VALUE

   Packet - packet to be sent out

   IpxHeader - points to the IPX header

   Data - points to after the IPX header - needed in spoofing of keepalives.

   PacketLength - length of the packet

   fIterate - a flag to indicate if this is a packet for the iteration of which the
                Fwd takes responsibility - typically type 20 NetBIOS frames


Return Value:

   STATUS_SUCCESS - if the preferred NIC was OK and packet passed filtering
   STATUS_NETWORK_UNREACHABLE - if the preferred was not OK or packet failed filtering
   STATUS_PENDING - if preferred NIC was OK but line down

   Forwarder should give us a different status than STATUS_NETWORK_UNREACHABLE for changed NIC
--*/
typedef NTSTATUS
(*IPX_FW_INTERNAL_SEND) (
   IN OUT   PIPX_LOCAL_TARGET LocalTarget,
   IN    ULONG_PTR         FwdAdapterContext,
   IN    PNDIS_PACKET      Packet,
   IN    PUCHAR            IpxHeader,
   IN    PUCHAR            Data,
   IN    ULONG             PacketLength,
   IN    BOOLEAN           fIterate
);

/*++

Routine Description:

   This routine is provided by the Kernel Forwarder to find the route to a given node and network

Arguments:

   Network - the destination network

   Node - destination node

   RouteEntry - filled in by the Forwarder if a route exists

Return Value:

   STATUS_SUCCESS
   STATUS_NETWORK_UNREACHABLE - if the findroute failed

--*/
typedef NTSTATUS
(*IPX_FW_FIND_ROUTE) (
   IN    PUCHAR   Network,
   IN    PUCHAR   Node,
   OUT   PIPX_FIND_ROUTE_REQUEST RouteEntry
);

/*++

Routine Description:

   This routine is provided by the Kernel Forwarder to find the route to a given node and network

Arguments:

   FwdAdapterContext - Forwarder's context

   RemoteAddress - the address the packet came on

   LookAheadBuffer - packet header that came in

   LookAheadBufferSize - size of the lookaheadbuffer

Return Value:

   STATUS_SUCCESS
   STATUS_FILTER_FAILED - if the packet was not allowed by the filter

--*/
typedef NTSTATUS
(*IPX_FW_INTERNAL_RECEIVE) (
   IN ULONG_PTR            FwdAdapterContext,
   IN PIPX_LOCAL_TARGET    RemoteAddress,
   IN PUCHAR               LookAheadBuffer,
   IN UINT                 LookAheadBufferSize
);

//
// Input to the bind IOCTL
//

//
// [FW] Removed the status and schedule route handlers
//
typedef struct _IPX_INTERNAL_BIND_INPUT {
    USHORT Version;
    UCHAR Identifier;
    BOOLEAN BroadcastEnable;
    UINT LookaheadRequired;
    UINT ProtocolOptions;
    IPX_INTERNAL_RECEIVE ReceiveHandler;
    IPX_INTERNAL_RECEIVE_COMPLETE ReceiveCompleteHandler;
    IPX_INTERNAL_STATUS StatusHandler;
    IPX_INTERNAL_SEND_COMPLETE SendCompleteHandler;
    IPX_INTERNAL_TRANSFER_DATA_COMPLETE TransferDataCompleteHandler;
    IPX_INTERNAL_FIND_ROUTE_COMPLETE FindRouteCompleteHandler;
    IPX_INTERNAL_LINE_UP LineUpHandler;
    IPX_INTERNAL_LINE_DOWN LineDownHandler;
    IPX_INTERNAL_SCHEDULE_ROUTE ScheduleRouteHandler;
#if defined(_PNP_POWER)
    IPX_INTERNAL_PNP_NOTIFICATION PnPHandler;
#endif _PNP_POWER
    IPX_FW_INTERNAL_SEND   InternalSendHandler;
    IPX_FW_FIND_ROUTE   FindRouteHandler;
    IPX_FW_INTERNAL_RECEIVE   InternalReceiveHandler;
    ULONG RipParameters;
} IPX_INTERNAL_BIND_INPUT, * PIPX_INTERNAL_BIND_INPUT;

#if     defined(_PNP_POWER)
#define ISN_VERSION 2
#endif  _PNP_POWER


//
// Bit mask values for RipParameters.
//

#define IPX_RIP_PARAM_GLOBAL_NETWORK  0x00000001   // single network for all WANS



//
// Functions provided by the lower driver.
//

typedef NDIS_STATUS
(*IPX_INTERNAL_SEND) (
    IN PIPX_LOCAL_TARGET RemoteAddress,
    IN PNDIS_PACKET Packet,
    IN ULONG PacketLength,
    IN ULONG IncludedHeaderLength
);

typedef VOID
(*IPX_INTERNAL_FIND_ROUTE) (
    IN PIPX_FIND_ROUTE_REQUEST FindRouteRequest
);

typedef NTSTATUS
(*IPX_INTERNAL_QUERY) (
    IN ULONG InternalQueryType,
#if defined(_PNP_POWER)
    IN PNIC_HANDLE NicHandle OPTIONAL,
#else
    IN USHORT   NicId OPTIONAL,
#endif  _PNP_POWER
    IN OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BufferLengthNeeded OPTIONAL
);

typedef VOID
(*IPX_INTERNAL_TRANSFER_DATA)(
	OUT PNDIS_STATUS Status,
	IN NDIS_HANDLE NdisBindingHandle,
	IN NDIS_HANDLE MacReceiveContext,
	IN UINT ByteOffset,
	IN UINT BytesToTransfer,
	IN OUT PNDIS_PACKET Packet,
	OUT PUINT BytesTransferred
    );

typedef VOID 
(*IPX_INTERNAL_PNP_COMPLETE) (
                              IN PNET_PNP_EVENT NetPnPEvent,
                              IN NTSTATUS       Status
                              );
//
// Definitions of the internal query types. In all cases
// STATUS_SUCCESS is returned if the request succeeds, and
// STATUS_BUFFER_TOO_SMALL is returned, and BufferLengthNeeded
// set if specified, if the buffer is too short. Other
// return codes are defined below. The routine never pends.
//

//
// This is used to query the line info. NicId specifies which one
// to query. Buffer contains an IPX_LINE_INFO structure which is
// used to return the information. Other return values:
//
// STATUS_INVALID_PARAMETER - NicId is invalid.
//

#define IPX_QUERY_LINE_INFO             1

//
// This is used to query the maximum NicId. NicId is unused. The
// Buffer contains a USHORT which is used to return the information.
//

#define IPX_QUERY_MAXIMUM_NIC_ID        2

//
// This is used to determine if the IPX address specified was sent
// by our local machine. If the address is the source address of a
// received frame, NicId should be the ID that was indicated; otherwise
// it should be set to 0. Buffer holds a TDI_ADDRESS_IPX. This
// call returns STATUS_SUCCESS if the address is local, and
// STATUS_NO_SUCH_DEVICE if not.
//

#define IPX_QUERY_IS_ADDRESS_LOCAL      3

//
// This is used to query the receive buffer space of a given NicId.
// Buffer contains a ULONG which is used to return the information.
// It returns STATUS_INVALID_PARAMETER if NicId is invalid.
//

#define IPX_QUERY_RECEIVE_BUFFER_SPACE  4

//
// This is used to query the local IPX address of a given NicId.
// Buffer contains a TDI_ADDRESS_IPX structure (the Socket is
// returned as 0). If it is queried on net 0 it returns the
// virtual network if there is one, otherwise STATUS_INVALID_PARAMETER.
// It returns STATUS_INVALID_PARAMETER if NicId is invalid.
//

#define IPX_QUERY_IPX_ADDRESS           5

//
// This is used to return the source routing information for
// a give remote address. NicId will be the NIC the packet was
// received from. The IPX_SOURCE_ROUTING_QUERY is contained
// in Buffer. Always returns STATUS_SUCCESS, although the
// SourceRoutingLength may be 0 for unknown remotes.
//
// The source routing is return in the direction it was received
// from the remote, not the direction used in replying. The
// MaximumSendSize includes the IPX header (as it does in
// IPX_LINE_INFO).
//

#define IPX_QUERY_SOURCE_ROUTING        6

typedef struct _IPX_SOURCE_ROUTING_INFO {
    USHORT Identifier;            // input: the caller's IDENTIFIER_SPX, _NB, etc.
    UCHAR RemoteAddress[6];       // input: the remote address
    UCHAR SourceRouting[18];      // output: room for the maximum source route
    USHORT SourceRoutingLength;   // output: the valid length of source route
    ULONG MaximumSendSize;        // output: based on nic and source routing
} IPX_SOURCE_ROUTING_INFO, * PIPX_SOURCE_ROUTING_INFO;

//
// This is used to query the maximum NicId over which outgoing type
// 20 packets should be sent. It will be less than or equal to
// the IPX_QUERY_MAXIMUM_NIC_ID value. What's excluded are down wan
// lines and dialin wan lines if DisableDialinNetbios bit 1 is set.
//

#define IPX_QUERY_MAX_TYPE_20_NIC_ID    7

#if defined(_PNP_POWER)

//
// This are used by NB to pass down these TDI queries which cannot
// be completed in NB.
//

#define IPX_QUERY_DATA_LINK_ADDRESS     8
#define IPX_QUERY_NETWORK_ADDRESS       9

#endif  _PNP_POWER

#define IPX_QUERY_MEDIA_TYPE           10

#define IPX_QUERY_DEVICE_RELATION      11 

//
// Output of a non-RIP bind.
//

typedef struct _IPX_INTERNAL_BIND_OUTPUT {
    USHORT Version;
    UCHAR Node[6];
    UCHAR Network[4];
    USHORT MacHeaderNeeded;
    USHORT IncludedHeaderOffset;
    IPX_LINE_INFO LineInfo;
    IPX_INTERNAL_SEND SendHandler;
    IPX_INTERNAL_FIND_ROUTE FindRouteHandler;
    IPX_INTERNAL_QUERY QueryHandler;
    IPX_INTERNAL_TRANSFER_DATA  TransferDataHandler;
    IPX_INTERNAL_PNP_COMPLETE   PnPCompleteHandler;
} IPX_INTERNAL_BIND_OUTPUT, * PIPX_INTERNAL_BIND_OUTPUT;



//
// Lower driver functions provided only for RIP.
//

typedef UINT
(*IPX_INTERNAL_GET_SEGMENT) (
    IN UCHAR Network[4]
);

typedef PIPX_ROUTE_ENTRY
(*IPX_INTERNAL_GET_ROUTE) (
    IN UINT Segment,
    IN UCHAR Network[4]
);

typedef BOOLEAN
(*IPX_INTERNAL_ADD_ROUTE) (
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
);

typedef BOOLEAN
(*IPX_INTERNAL_DELETE_ROUTE) (
    IN UINT Segment,
    IN PIPX_ROUTE_ENTRY RouteEntry
);

typedef PIPX_ROUTE_ENTRY
(*IPX_INTERNAL_GET_FIRST_ROUTE) (
    IN UINT Segment
);

typedef PIPX_ROUTE_ENTRY
(*IPX_INTERNAL_GET_NEXT_ROUTE) (
    IN UINT Segment
);

typedef VOID
(*IPX_INTERNAL_INCREMENT_WAN_INACTIVITY) (
#ifdef	_PNP_LATER
	IN	NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif
);

typedef ULONG
(*IPX_INTERNAL_QUERY_WAN_INACTIVITY) (
#ifdef	_PNP_LATER
	IN	NIC_HANDLE	NicHandle
#else
    IN USHORT NicId
#endif

);

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to open an adapter

Arguments:

   AdapterIndex - index of the adapter to open (NICid for now - will change to a struct
                  with a version number, signature and the NicId
   FwdAdapterContext - Forwarder's context
   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version #)

Return Value:

   STATUS_INVALID_HANDLE   if the AdapterIndex handle was invalid
   STATUS_ADAPTER_ALREADY_OPENED    if the Adapter is being opened a second time
   STATUS_SUCCESS

--*/
typedef NTSTATUS
(*IPX_FW_OPEN_ADAPTER) (
   IN    NIC_HANDLE     AdapterIndex,
   IN    ULONG_PTR      FwdAdapterContext,
   OUT   PNIC_HANDLE    IpxAdapterContext
);

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to close an adapter

Arguments:

   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version#)

Return Value:

   STATUS_ADAPTER_ALREADY_CLOSED - if the adapter is being closed a second time
   STATUS_SUCCESS

--*/
typedef NTSTATUS
(*IPX_FW_CLOSE_ADAPTER) (
   IN NIC_HANDLE  IpxAdapterContext
);

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to indicate that a pending
   internal send to it has completed.

Arguments:

   LocalTarget - if Status is OK, this has the local target for the send.

   Packet - A pointer to the NDIS_PACKET that we sent.

   PacketLength - length of the packet (including the IPX header)

   Status - the completion status of the send - STATUS_SUCCESS or STATUS_NETWORK_UNREACHABLE

Return Value:

   none.

--*/
typedef VOID
(*IPX_FW_INTERNAL_SEND_COMPLETE) (
   IN PIPX_LOCAL_TARGET LocalTarget,
   IN PNDIS_PACKET      Packet,
   IN ULONG             PacketLength,
   IN NTSTATUS          Status
);

//
// Describes a single network.
//

typedef struct _IPX_NIC_DATA {
    USHORT NicId;
    UCHAR Node[6];
    UCHAR Network[4];
    IPX_LINE_INFO LineInfo;
    NDIS_MEDIUM DeviceType;
    ULONG EnableWanRouter;
} IPX_NIC_DATA, * PIPX_NIC_DATA;


//
// Describes all networks.
//

typedef struct _IPX_NIC_INFO_BUFFER {
    USHORT NicCount;
    USHORT VirtualNicId;
    UCHAR VirtualNetwork[4];
    IPX_NIC_DATA NicData[1];
} IPX_NIC_INFO_BUFFER, * PIPX_NIC_INFO_BUFFER;


//
// Output from a RIP bind (the actual structure size is
// based on the number of IPX_NIC_DATA elements in the
// final IPX_NIC_INFO_BUFFER structure).
//

typedef struct _IPX_INTERNAL_BIND_RIP_OUTPUT {
    USHORT Version;
    USHORT MaximumNicCount;
    USHORT MacHeaderNeeded;
    USHORT IncludedHeaderOffset;
    IPX_INTERNAL_SEND SendHandler;
    UINT SegmentCount;
    KSPIN_LOCK * SegmentLocks;
    IPX_INTERNAL_GET_SEGMENT GetSegmentHandler;
    IPX_INTERNAL_GET_ROUTE GetRouteHandler;
    IPX_INTERNAL_ADD_ROUTE AddRouteHandler;
    IPX_INTERNAL_DELETE_ROUTE DeleteRouteHandler;
    IPX_INTERNAL_GET_FIRST_ROUTE GetFirstRouteHandler;
    IPX_INTERNAL_GET_NEXT_ROUTE GetNextRouteHandler;
    IPX_INTERNAL_INCREMENT_WAN_INACTIVITY IncrementWanInactivityHandler;
    IPX_INTERNAL_QUERY_WAN_INACTIVITY QueryWanInactivityHandler;
    IPX_INTERNAL_TRANSFER_DATA  TransferDataHandler;
    IPX_FW_OPEN_ADAPTER OpenAdapterHandler;
    IPX_FW_CLOSE_ADAPTER   CloseAdapterHandler;
    IPX_FW_INTERNAL_SEND_COMPLETE   InternalSendCompleteHandler;
    IPX_NIC_INFO_BUFFER NicInfoBuffer;
} IPX_INTERNAL_BIND_RIP_OUTPUT, * PIPX_INTERNAL_BIND_RIP_OUTPUT;

//
// [FW] Used by the forwarder to fill up the localtarget
//

#ifdef _PNP_LATER
#define NIC_HANDLE_FROM_NIC(_nichandle, _nic) \
	_nichandle.NicId = _nic; \
	_nichandle.Signature = IPX_BINDING_SIGNATURE; \
	if (_nic == 0) { \
		_nichandle.Version = 0; \
	} else { \
		_nichandle.Version = IpxDevice->Bindings[_nic].Version; \
	}

#else

#define NIC_HANDLE_FROM_NIC(_nichandle, _nic) \
	_nichandle.NicId = (USHORT)_nic;

#endif

//
// VOID
// ADAPTER_CONTEXT_TO_LOCAL_TARGET(
//     IN NIC_HANDLE   _context;
//     IN PIPX_LOCAL_TARGET   _localtarget;
// );
//
#define  ADAPTER_CONTEXT_TO_LOCAL_TARGET(_context, _localtarget)  \
    (_localtarget)->NicHandle.NicId = (_context).NicId;

//
// VOID
// CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET(
//     IN NIC_HANDLE   _context;
//     IN PIPX_LOCAL_TARGET   _localtarget;
// );
//
#define  CONSTANT_ADAPTER_CONTEXT_TO_LOCAL_TARGET(_context, _localtarget)  \
    (_localtarget)->NicHandle.NicId = (USHORT)(_context);


//
// [FW] Used to indicate to the Forwarder that a preferred NIC is not given
// in InternalSend
//
#define  INVALID_CONTEXT_VALUE   0xffffffff

//
// [FW] This is the value returned (in FindRoute) to IPX from the Forwarder in case of a demand dial Nic.
// On an InternalSend, this is passed up to the FWD, which brings up the line and returns the good LocalTarget
//
#define  DEMAND_DIAL_ADAPTER_CONTEXT   0xffffffff

//
// Adapter context used by the FWD to represent a send to the virtual net.
// IPX maps this to the loopback adapter.
//
#define  VIRTUAL_NET_ADAPTER_CONTEXT   0x1 //0xfffffffe   // -2

//
// Context passed up to the FWD on a loopback send.
//
#define  VIRTUAL_NET_FORWARDER_CONTEXT 0x1 //  0xfffffffe   // -2

//
// Special NIC id used by NB/SPX to send packets over all NICs.
//
#define ITERATIVE_NIC_ID    0xfffd  // -3

#endif // _ISN_BIND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\inc\ioctls.h ===
#define VER_IOCH "@(#)MCS ipx/h/ioctls.h     1.00.00 - 08 APR 1993";

/****************************************************************************
* (c) Copyright 1990, 1993 Micro Computer Systems, Inc. All rights reserved.
*****************************************************************************
*
*   Title:    IPX/SPX Driver for Windows NT
*
*   Module:   ipx/h/ioctls.h
*
*   Version:  1.00.00
*
*   Date:     04-08-93
*
*   Author:   Brian Walker
*
*****************************************************************************
*
*   Change Log:
*
*   Date     DevSFC   Comment
*   -------- ------   -------------------------------------------------------
*****************************************************************************
*
*   Functional Description:
*
*   IOCTL defines
*
****************************************************************************/

/** Ioctls for IPX - (X) = User callable **/

/**
    ioctls will values 100 - 150 were added for the NT port.
**/

#define I_MIPX          (('I' << 24) | ('D' << 16) | ('P' << 8))
#define MIPX_SETNODEADDR   I_MIPX | 0   /* Set the node address */
#define MIPX_SETNETNUM     I_MIPX | 1   /* Set the network number */
#define MIPX_SETPTYPE      I_MIPX | 2   /* (X) Set the packet type */
#define MIPX_SENTTYPE      I_MIPX | 3   /* (X) Set the xport type */
#define MIPX_SETPKTSIZE    I_MIPX | 4   /* Set the packet size */
#define MIPX_SETSAP        I_MIPX | 5   /* Set the sap/type field */
#define MIPX_SENDOPTS      I_MIPX | 6   /* (X) Send options on recv */
#define MIPX_NOSENDOPTS    I_MIPX | 7   /* (X) Don't send options on recv */
#define MIPX_SENDSRC       I_MIPX | 8   /* (X) Send source address up */
#define MIPX_NOSENDSRC     I_MIPX | 9   /* (X) Don't Send source address up */
#define MIPX_CONVBCAST     I_MIPX | 10  /* Convert TKR bcast to func addr */
#define MIPX_NOCONVBCAST   I_MIPX | 11  /* Don't cnvrt TKR bcast to funcaddr */
#define MIPX_SETCARDTYPE   I_MIPX | 12  /* Set 802.3 or ETH type */
#define MIPX_STARGROUP     I_MIPX | 13  /* This is stargroup */
#define MIPX_SWAPLENGTH    I_MIPX | 14  /* Set flag for swapping 802.3 length */
#define MIPX_SENDDEST      I_MIPX | 15  /* (X) Send dest. address up */
#define MIPX_NOSENDDEST    I_MIPX | 16  /* (X) Don't send dest. address up */
#define MIPX_SENDFDEST     I_MIPX | 17  /* (X) Send final dest. address up */
#define MIPX_NOSENDFDEST   I_MIPX | 18  /* (X) Don't send final dest. up */

/** Added for NT port **/

#define MIPX_SETVERSION    I_MIPX | 100 /* Set card version */
#define MIPX_GETSTATUS     I_MIPX | 101
#define MIPX_SENDADDROPT   I_MIPX | 102 /* (X) Send ptype w/addr on recv */
#define MIPX_NOSENDADDROPT I_MIPX | 103 /* (X) Stop sending ptype on recv */
#define MIPX_CHECKSUM      I_MIPX | 104 /* Enable/Disable checksum      */
#define MIPX_GETPKTSIZE    I_MIPX | 105 /* Get max packet size          */
#define MIPX_SENDHEADER    I_MIPX | 106 /* Send header with data        */
#define MIPX_NOSENDHEADER  I_MIPX | 107 /* Don't send header with data  */
#define MIPX_SETCURCARD    I_MIPX | 108 /* Set current card for IOCTLs  */
#define MIPX_SETMACTYPE    I_MIPX | 109 /* Set the Cards MAC type       */
#define MIPX_DOSROUTE      I_MIPX | 110 /* Do source routing on this card*/
#define MIPX_NOSROUTE      I_MIPX | 111 /* Don't source routine the card*/
#define MIPX_SETRIPRETRY   I_MIPX | 112 /* Set RIP retry count          */
#define MIPX_SETRIPTO      I_MIPX | 113 /* Set RIP timeout              */
#define MIPX_SETTKRSAP     I_MIPX | 114 /* Set the token ring SAP       */
#define MIPX_SETUSELLC     I_MIPX | 115 /* Put LLC hdr on packets       */
#define MIPX_SETUSESNAP    I_MIPX | 116 /* Put SNAP hdr on packets      */
#define MIPX_8023LEN       I_MIPX | 117 /* 1=make even, 0=dont make even*/
#define MIPX_SENDPTYPE     I_MIPX | 118 /* Send ptype in options on recv*/
#define MIPX_NOSENDPTYPE   I_MIPX | 119 /* Don't send ptype in options  */
#define MIPX_FILTERPTYPE   I_MIPX | 120 /* Filter on recv ptype         */
#define MIPX_NOFILTERPTYPE I_MIPX | 121 /* Don't Filter on recv ptype   */
#define MIPX_SETSENDPTYPE  I_MIPX | 122 /* Set pkt type to send with    */
#define MIPX_GETCARDINFO   I_MIPX | 123 /* Get info on a card           */
#define MIPX_SENDCARDNUM   I_MIPX | 124 /* Send card num up in options  */
#define MIPX_NOSENDCARDNUM I_MIPX | 125 /* Dont send card num in options*/
#define MIPX_SETROUTER     I_MIPX | 126 /* Set router enabled flag      */
#define MIPX_SETRIPAGE     I_MIPX | 127 /* Set RIP age timeout          */
#define MIPX_SETRIPUSAGE   I_MIPX | 128 /* Set RIP usage timeout        */
#define MIPX_SETSROUTEUSAGE I_MIPX| 129 /* Set the SROUTE usage timeout */
#define MIPX_SETINTNET     I_MIPX | 130 /* Set internal network number  */
#define MIPX_NOVIRTADDR    I_MIPX | 131 /* Turn off virtual net num     */
#define MIPX_VIRTADDR      I_MIPX | 132 /* Turn on  virtual net num     */
#define MIPX_SETBCASTFLAG  I_MIPX | 133 /* Turn on bcast flag in addr   */
#define MIPX_NOBCASTFLAG   I_MIPX | 134 /* Turn off bcast flag in addr  */
#define MIPX_GETNETINFO    I_MIPX | 135 /* Get info on a network num    */
#define MIPX_SETDELAYTIME  I_MIPX | 136 /* Set cards delay time         */
#define MIPX_SETROUTEADV   I_MIPX | 137 /* Route advertise timeout      */
#define MIPX_SETSOCKETS    I_MIPX | 138 /* Set default sockets          */
#define MIPX_SETLINKSPEED  I_MIPX | 139 /* Set the link speed for a card*/
#define MIPX_SETWANFLAG    I_MIPX | 140
#define MIPX_GETCARDCHANGES I_MIPX | 141 /* Wait for card changes	*/
#define MIPX_GETMAXADAPTERS I_MIPX | 142
#define MIPX_REUSEADDRESS   I_MIPX | 143
#define MIPX_RERIPNETNUM    I_MIPX | 144 /* ReRip a network         */

/** For Source Routing Support **/

#define MIPX_SRCLEAR       I_MIPX | 200 /* Clear the source routing table*/
#define MIPX_SRDEF         I_MIPX | 201 /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRBCAST       I_MIPX | 202 /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRMULTI       I_MIPX | 203 /* 0=Single Rte, 1=All Routes   */
#define MIPX_SRREMOVE      I_MIPX | 204 /* Remove a node from the table */
#define MIPX_SRLIST        I_MIPX | 205 /* Get the source routing table */
#define MIPX_SRGETPARMS    I_MIPX | 206 /* Get source routing parms     */

#define MIPX_SETSHOULDPUT  I_MIPX | 210 /* Turn on should put call      */
#define MIPX_DELSHOULDPUT  I_MIPX | 211 /* Turn off should put call     */
#define MIPX_GETSHOULDPUT  I_MIPX | 212 /* Get ptr to mipx_shouldput    */

/** Added for ISN **/

#define MIPX_RCVBCAST      I_MIPX | 300 /* (X) Enable broadcast reception */
#define MIPX_NORCVBCAST    I_MIPX | 301 /* (X) Disable broadcast reception */
#define MIPX_ADAPTERNUM    I_MIPX | 302 /* Get maximum adapter number */
#define MIPX_NOTIFYCARDINFO I_MIPX | 303 /* Pend until card info changes */
#define MIPX_LOCALTARGET   I_MIPX | 304 /* Get local target for address */
#define MIPX_NETWORKINFO   I_MIPX | 305 /* Return info about remote net */
#define MIPX_ZEROSOCKET    I_MIPX | 306 /* Use 0 as source socket on sends */

/** Ioctls for SPX **/

#define I_MSPX          (('S' << 24) | ('P' << 16) | ('P' << 8))
#define MSPX_SETADDR       I_MSPX | 0   /* Set the network address      */
#define MSPX_SETPKTSIZE    I_MSPX | 1   /* Set the packet size per card */
#define MSPX_SETDATASTREAM I_MSPX | 2   /* Set datastream type          */

/** Added for NT port **/

#define MSPX_SETASLISTEN   I_MSPX | 100 /* Set as a listen socket       */
#define MSPX_GETSTATUS     I_MSPX | 101 /* Get running status           */
#define MSPX_GETQUEUEPTR   I_MSPX | 102 /* Get ptr to the streams queue */
#define MSPX_SETDATAACK    I_MSPX | 103 /* Set DATA ACK option          */
#define MSPX_NODATAACK     I_MSPX | 104 /* Turn off DATA ACK option     */
#define MSPX_SETMAXPKTSOCK I_MSPX | 105 /* Set the packet size per socket */
#define MSPX_SETWINDOWCARD I_MSPX | 106 /* Set window size for card     */
#define MSPX_SETWINDOWSOCK I_MSPX | 107 /* Set window size for 1 socket */
#define MSPX_SENDHEADER    I_MSPX | 108 /* Send header with data        */
#define MSPX_NOSENDHEADER  I_MSPX | 109 /* Don't send header with data  */
#define MSPX_GETPKTSIZE    I_MSPX | 110 /* Get the packet size per card */
#define MSPX_SETCONNCNT    I_MSPX | 111 /* Set the conn req count       */
#define MSPX_SETCONNTO     I_MSPX | 112 /* Set the conn req timeout     */
#define MSPX_SETALIVECNT   I_MSPX | 113 /* Set the keepalive count      */
#define MSPX_SETALIVETO    I_MSPX | 114 /* Set the keepalive timeout    */
#define MSPX_SETALWAYSEOM  I_MSPX | 115 /* Turn on always EOM flag      */
#define MSPX_NOALWAYSEOM   I_MSPX | 116 /* Turn off always EOM flag     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\inc\isn.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    isn.h

Abstract:

    Private include file for the ISN transport.

Author:

    Adam Barr (adamba) 08-Sep-1993

Revision History:

--*/


#define ISN_NT 1


//
// These are needed for CTE
//

#if DBG
#define DEBUG 1
#endif

#define NT 1


#include <ntddk.h>
#include <tdikrnl.h>
#include <ndis.h>
#include <cxport.h>
#include <bind.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\inc\isnnb.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    isnnb.h

Abstract:

    This module contains definitions specific to the
    Netbios module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:


--*/


#define NB_MAXIMUM_MAC   40

#define NB_SOCKET       0x5504

#if     defined(_PNP_POWER)
#define NB_NETBIOS_NAME_SIZE    16

#define LOCK_ACQUIRED      TRUE
#define LOCK_NOT_ACQUIRED  FALSE
#endif  _PNP_POWER

//
// Defined granularity of find name timeouts in milliseconds --
// we make this the same as the spec'ed RIP gap to avoid
// flooding routers.
//

#define FIND_NAME_GRANULARITY  55


//
// Defines the number of milliseconds between expirations of the
// short and long timers.
//

#define MILLISECONDS         10000     // number of NT time units in one

#define SHORT_TIMER_DELTA      100
#define LONG_TIMER_DELTA      2000


//
// Convert a ushort netware order <-> machine order
//

#define REORDER_USHORT(_Ushort) ((((_Ushort) & 0xff00) >> 8) | (((_Ushort) & 0x00ff) << 8))

//
// Convert a ulong netware order <-> machine order
//

#define REORDER_ULONG(_Ulong) \
    ((((_Ulong) & 0xff000000) >> 24) | \
     (((_Ulong) & 0x00ff0000) >> 8) | \
     (((_Ulong) & 0x0000ff00) << 8) | \
     (((_Ulong) & 0x000000ff) << 24))



#include <packon.h>

#ifdef _PNP_POWER_
//
// This is the packaging for the data we send to TDI in TdiRegisterNetAddress
//
typedef struct _NBIPX_PNP_CONTEXT_
{
    TDI_PNP_CONTEXT TDIContext;
    PVOID           ContextData;
} NBIPX_PNP_CONTEXT, *PNBIPX_PNP_CONTEXT;
#endif  // _PNP_POWER_

//
// Definition of the Netbios header for name frames.
//

typedef struct _NB_NAME_FRAME {
    union {
        struct {
            UCHAR ConnectionControlFlag;
            UCHAR DataStreamType;
        };
        UCHAR RoutingInfo[32];
    };
    UCHAR NameTypeFlag;
    UCHAR DataStreamType2;
    UCHAR Name[16];
} NB_NAME_FRAME, *PNB_NAME_FRAME;

//
// Definition of the Netbios header for directed datagrams.
//

typedef struct _NB_DATAGRAM {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
    UCHAR SourceName[16];
    UCHAR DestinationName[16];
} NB_DATAGRAM, *PNB_DATAGRAM;

//
// Definition of the Netbios header for a status query.
//

typedef struct _NB_STATUS_QUERY {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
    UCHAR Padding[14];
} NB_STATUS_QUERY, *PNB_STATUS_QUERY;

//
// Definition of the Netbios header for a status response
// (this does not include the status buffer itself).
//

typedef struct _NB_STATUS_RESPONSE {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
} NB_STATUS_RESPONSE, *PNB_STATUS_RESPONSE;


//
// Definition of the general Netbios connectionless header.
//

typedef struct _NB_CONNECTIONLESS {
    IPX_HEADER IpxHeader;
    union {
        NB_NAME_FRAME NameFrame;
        NB_DATAGRAM Datagram;
        NB_STATUS_QUERY StatusQuery;
        NB_STATUS_RESPONSE StatusResponse;
    };
} NB_CONNECTIONLESS, *PNB_CONNECTIONLESS;


//
// Definition of the Netbios session frame.
//

typedef struct _NB_SESSION {
    UCHAR ConnectionControlFlag;
    UCHAR DataStreamType;
    USHORT SourceConnectionId;
    USHORT DestConnectionId;
    USHORT SendSequence;
    USHORT TotalDataLength;
    USHORT Offset;
    USHORT DataLength;
    USHORT ReceiveSequence;
    union {
        USHORT BytesReceived;
        USHORT ReceiveSequenceMax;
    };
} NB_SESSION, *PNB_SESSION;


//
// Definition of the extra fields in a Netbios
// session frame for session init and session init
// ack.
//

typedef struct _NB_SESSION_INIT {
    UCHAR SourceName[16];
    UCHAR DestinationName[16];
    USHORT MaximumDataSize;
    USHORT MaximumPacketTime;
    USHORT StartTripTime;
} NB_SESSION_INIT, *PNB_SESSION_INIT;


//
// Definition of the general Netbios connection-oriented header.
//

typedef struct _NB_CONNECTION {
    IPX_HEADER IpxHeader;
    NB_SESSION Session;
} NB_CONNECTION, *PNB_CONNECTION;


//
// Definition of a Netbios packet.
//

typedef union _NB_FRAME {
    NB_CONNECTIONLESS Connectionless;
    NB_CONNECTION Connection;
} NB_FRAME, *PNB_FRAME;

#include <packoff.h>


//
// Definitions for the DataStreamType field, with the
// format used shown in the comment afterward.
//

#define NB_CMD_FIND_NAME           0x01   // NAME_FRAME
#define NB_CMD_NAME_RECOGNIZED     0x02   // NAME_FRAME
#define NB_CMD_ADD_NAME            0x03   // NAME_FRAME
#define NB_CMD_NAME_IN_USE         0x04   // NAME_FRAME
#define NB_CMD_DELETE_NAME         0x05   // NAME_FRAME
#define NB_CMD_SESSION_DATA        0x06   // SESSION
#define NB_CMD_SESSION_END         0x07   // SESSION
#define NB_CMD_SESSION_END_ACK     0x08   // SESSION
#define NB_CMD_STATUS_QUERY        0x09   // STATUS_QUERY
#define NB_CMD_STATUS_RESPONSE     0x0a   // STATUS_RESPONSE
#define NB_CMD_DATAGRAM            0x0b   // DATAGRAM
#define NB_CMD_BROADCAST_DATAGRAM  0x0c   // BROADCAST_DATAGRAM

#ifdef RSRC_TIMEOUT_DBG
#define NB_CMD_DEATH_PACKET        0x99   //
#endif // RSRC_TIMEOUT_DBG

//
// Bit values in the NameTypeFlag of NB_NAME_FRAME frames.
//

#define NB_NAME_UNIQUE        0x00
#define NB_NAME_GROUP         0x80
#define NB_NAME_USED          0x40
#define NB_NAME_REGISTERED    0x04
#define NB_NAME_DUPLICATED    0x02
#define NB_NAME_DEREGISTERED  0x01

//
// Bit values in the ConnectionControlFlag.
//

#define NB_CONTROL_SYSTEM     0x80
#define NB_CONTROL_SEND_ACK   0x40
#define NB_CONTROL_ATTENTION  0x20
#define NB_CONTROL_EOM        0x10
#define NB_CONTROL_RESEND     0x08
#define NB_CONTROL_NEW_NB     0x01



#define NB_DEVICE_SIGNATURE             0x1401
#if defined(_PNP_POWER)
#define NB_ADAPTER_ADDRESS_SIGNATURE    0x1403
#endif  _PNP_POWER
#define NB_ADDRESS_SIGNATURE            0x1404
#define NB_ADDRESSFILE_SIGNATURE        0x1405
#define NB_CONNECTION_SIGNATURE         0x1406


//
// Useful in various places.
//
#if     defined(_PNP_POWER)
extern IPX_LOCAL_TARGET BroadcastTarget;
#endif  _PNP_POWER
extern UCHAR BroadcastAddress[6];
extern UCHAR NetbiosBroadcastName[16];


//
// Contains the default handler for each of the TDI event types
// that are supported.
//

extern PVOID TdiDefaultHandlers[6];


//
// Define a structure that can track lock acquire/release.
//

typedef struct _NB_LOCK {
    CTELock Lock;
#if DBG
    ULONG LockAcquired;
    UCHAR LastAcquireFile[8];
    ULONG LastAcquireLine;
    UCHAR LastReleaseFile[8];
    ULONG LastReleaseLine;
#endif
} NB_LOCK, *PNB_LOCK;



#if DBG

extern ULONG NbiDebug;
extern ULONG NbiDebug2;
extern ULONG NbiMemoryDebug;

#define NB_MEMORY_LOG_SIZE 128
#define MAX_ARGLEN      80
#define TEMP_BUF_LEN    150

extern UCHAR NbiDebugMemory[NB_MEMORY_LOG_SIZE][MAX_ARGLEN];
extern PUCHAR NbiDebugMemoryLoc;
extern PUCHAR NbiDebugMemoryEnd;

VOID
NbiDebugMemoryLog(
    IN PUCHAR FormatString,
    ...
);

#define NB_DEBUG(_Flag, _Print) { \
    if (NbiDebug & (NB_DEBUG_ ## _Flag)) { \
        DbgPrint ("NBI: "); \
        DbgPrint _Print; \
    } \
    if (NbiMemoryDebug & (NB_DEBUG_ ## _Flag)) { \
        NbiDebugMemoryLog _Print; \
    } \
}

#define NB_DEBUG2(_Flag, _Print) { \
    if (NbiDebug2 & (NB_DEBUG_ ## _Flag)) { \
        DbgPrint ("NBI: "); \
        DbgPrint _Print; \
    } \
    if (NbiMemoryDebug & (NB_DEBUG_ ## _Flag)) { \
        NbiDebugMemoryLog _Print; \
    } \
}

#else

#define NB_DEBUG(_Flag, _Print)
#define NB_DEBUG2(_Flag, _Print)

#endif


//
// These definitions are for abstracting IRPs from the
// transport for portability.
//

#if ISN_NT

typedef IRP REQUEST, *PREQUEST;
typedef struct _REQUEST_LIST_HEAD {
    PREQUEST Head;   // list is empty if this is NULL
    PREQUEST Tail;   // undefined if the list is empty.
} REQUEST_LIST_HEAD, *PREQUEST_LIST_HEAD;


//
// PREQUEST
// NbiAllocateRequest(
//     IN PDEVICE Device,
//     IN PIRP Irp
// );
//
// Allocates a request for the system-specific request structure.
//

#define NbiAllocateRequest(_Device,_Irp) \
    (_Irp)


//
// BOOLEAN
// IF_NOT_ALLOCATED(
//     IN PREQUEST Request
// );
//
// Checks if a request was not successfully allocated.
//

#define IF_NOT_ALLOCATED(_Request) \
    if (0)


//
// VOID
// NbiFreeRequest(
//     IN PDEVICE Device,
//     IN PREQUEST Request
// );
//
// Frees a previously allocated request.
//

#define NbiFreeRequest(_Device,_Request) \
    ;


//
// VOID
// MARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will pend.
//

#define MARK_REQUEST_PENDING(_Request) \
    IoMarkIrpPending(_Request)


//
// VOID
// UNMARK_REQUEST_PENDING(
//     IN PREQUEST Request
// );
//
// Marks that a request will not pend.
//

#define UNMARK_REQUEST_PENDING(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->Control) &= ~SL_PENDING_RETURNED)


//
// UCHAR
// REQUEST_MAJOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the major function code of a request.
//

#define REQUEST_MAJOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MajorFunction)


//
// UCHAR
// REQUEST_MINOR_FUNCTION
//     IN PREQUEST Request
// );
//
// Returns the minor function code of a request.
//

#define REQUEST_MINOR_FUNCTION(_Request) \
    ((IoGetCurrentIrpStackLocation(_Request))->MinorFunction)


//
// PNDIS_BUFFER
// REQUEST_NDIS_BUFFER
//     IN PREQUEST Request
// );
//
// Returns the NDIS buffer chain associated with a request.
//

#define REQUEST_NDIS_BUFFER(_Request) \
    ((PNDIS_BUFFER)((_Request)->MdlAddress))


//
// PVOID
// REQUEST_OPEN_CONTEXT(
//     IN PREQUEST Request
// );
//
// Gets the context associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_CONTEXT(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext)


//
// PVOID
// REQUEST_OPEN_TYPE(
//     IN PREQUEST Request
// );
//
// Gets the type associated with an opened address/connection/control channel.
//

#define REQUEST_OPEN_TYPE(_Request) \
    (((IoGetCurrentIrpStackLocation(_Request))->FileObject)->FsContext2)


//
// PFILE_FULL_EA_INFORMATION
// OPEN_REQUEST_EA_INFORMATION(
//     IN PREQUEST Request
// );
//
// Returns the EA information associated with an open/close request.
//

#define OPEN_REQUEST_EA_INFORMATION(_Request) \
    ((PFILE_FULL_EA_INFORMATION)((_Request)->AssociatedIrp.SystemBuffer))


//
// PTDI_REQUEST_KERNEL
// REQUEST_PARAMETERS(
//     IN PREQUEST Request
// );
//
// Obtains a pointer to the parameters of a request.
//

#define REQUEST_PARAMETERS(_Request) \
    (&((IoGetCurrentIrpStackLocation(_Request))->Parameters))


//
// PLIST_ENTRY
// REQUEST_LINKAGE(
//     IN PREQUEST Request
// );
//
// Returns a pointer to a linkage field in the request.
//

#define REQUEST_LINKAGE(_Request) \
    (&((_Request)->Tail.Overlay.ListEntry))


//
// PREQUEST
// REQUEST_SINGLE_LINKAGE(
//     IN PREQUEST Request
// );
//
// Used to access a single list linkage field in the request.
//

#define REQUEST_SINGLE_LINKAGE(_Request) \
    (*((PREQUEST *)&((_Request)->Tail.Overlay.ListEntry.Flink)))


//
// ULONG
// REQUEST_REFCOUNT(
//     IN PREQUEST Request
// );
//
// Used to access a field in the request which can be used for
// the reference count, as long as it is on a REQUEST_LIST.
//

#define REQUEST_REFCOUNT(_Request) \
    (*((PULONG)&((_Request)->Tail.Overlay.ListEntry.Blink)))


//
// VOID
// REQUEST_LIST_INSERT_TAIL(
//     IN PREQUEST_LIST_HEAD Head,
//     IN PREQUEST Entry
// );
//
// Inserts a request into a single list linkage queue.
//

#define REQUEST_LIST_INSERT_TAIL(_Head,_Entry) { \
    if ((_Head)->Head == NULL) { \
        (_Head)->Head = (_Entry); \
        (_Head)->Tail = (_Entry); \
    } else { \
        REQUEST_SINGLE_LINKAGE((_Head)->Tail) = (_Entry); \
        (_Head)->Tail = (_Entry); \
    } \
}


//
// PREQUEST
// LIST_ENTRY_TO_REQUEST(
//     IN PLIST_ENTRY ListEntry
// );
//
// Returns a request given a linkage field in it.
//

#define LIST_ENTRY_TO_REQUEST(_ListEntry) \
    ((PREQUEST)(CONTAINING_RECORD(_ListEntry, REQUEST, Tail.Overlay.ListEntry)))


//
// NTSTATUS
// REQUEST_STATUS(
//     IN PREQUEST Request
// );
//
// Used to access the status field of a request.
//

#define REQUEST_STATUS(_Request) \
    (_Request)->IoStatus.Status

//
// NTSTATUS
// REQUEST_STATUSPTR(
//     IN PREQUEST Request
// );
//
// Used to access the status field of a request.
//

#define REQUEST_STATUSPTR(_Request) \
    (_Request)->IoStatus.Pointer


//
// ULONG
// REQUEST_INFORMATION(
//     IN PREQUEST Request)
// );
//
// Used to access the information field of a request.
//

#define REQUEST_INFORMATION(_Request) \
    (_Request)->IoStatus.Information


//
// VOID
// NbiCompleteRequest(
//     IN PREQUEST Request
// );
//
// Completes a request whose status and information fields have
// been filled in.
//

#define NbiCompleteRequest(_Request) \
    IoCompleteRequest (_Request, IO_NETWORK_INCREMENT)

#else

//
// These routines must be defined for portability to a VxD.
//

#endif

//
// some utility macros.

// Minimum of two
//
#define NB_MIN( _a , _b )    ( ( (_a) < (_b) ) ? (_a) : (_b) )

//
// Swap the _s1 and _s2 of Type _T
//

#define NB_SWAP(_s1, _s2, _T) {                         \
    _T  _temp;                                          \
    _temp   = (_s1);                                    \
    (_s1)   = (_s2);                                    \
    (_s2)   = _temp;                                    \
}

#define NB_SWAP_IRQL( _s1, _s2 )   NB_SWAP( _s1, _s2, CTELockHandle )

//
// Define our own spinlock routines.
//

#if DBG

#define NB_GET_LOCK(_Lock, _LockHandle) { \
    CTEGetLock(&(_Lock)->Lock, _LockHandle); \
    (_Lock)->LockAcquired = TRUE; \
    strncpy((_Lock)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastAcquireLine = __LINE__; \
}

#define NB_FREE_LOCK(_Lock, _LockHandle) { \
    (_Lock)->LockAcquired = FALSE; \
    strncpy((_Lock)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastReleaseLine = __LINE__; \
    CTEFreeLock(&(_Lock)->Lock, _LockHandle); \
}

#define NB_GET_LOCK_DPC(_Lock) { \
    ExAcquireSpinLockAtDpcLevel(&(_Lock)->Lock); \
    (_Lock)->LockAcquired = TRUE; \
    strncpy((_Lock)->LastAcquireFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastAcquireLine = __LINE__; \
}

#define NB_FREE_LOCK_DPC(_Lock) { \
    (_Lock)->LockAcquired = FALSE; \
    strncpy((_Lock)->LastReleaseFile, strrchr(__FILE__,'\\')+1, 7); \
    (_Lock)->LastReleaseLine = __LINE__; \
    ExReleaseSpinLockFromDpcLevel(&(_Lock)->Lock); \
}

#else

#define NB_GET_LOCK(_Lock, _LockHandle) CTEGetLock(&(_Lock)->Lock, _LockHandle)
#define NB_FREE_LOCK(_Lock, _LockHandle) CTEFreeLock(&(_Lock)->Lock, _LockHandle)
#define NB_GET_LOCK_DPC(_Lock) ExAcquireSpinLockAtDpcLevel(&(_Lock)->Lock)
#define NB_FREE_LOCK_DPC(_Lock) ExReleaseSpinLockFromDpcLevel(&(_Lock)->Lock)

#endif


#define NB_GET_CANCEL_LOCK( _LockHandle ) IoAcquireCancelSpinLock( _LockHandle )

#define NB_FREE_CANCEL_LOCK( _LockHandle ) IoReleaseCancelSpinLock( _LockHandle )


//
// Routines to optimize for a uni-processor environment.
//


#define NB_INCREMENT(_Long, _Lock)  InterlockedIncrement(_Long)
#define NB_DECREMENT(_Long, _Lock)  InterlockedDecrement(_Long)

#define NB_ADD_ULONG(_Pulong, _Ulong, _Lock)  ExInterlockedAddUlong(_Pulong, _Ulong, &(_Lock)->Lock)

#define NB_DEFINE_SYNC_CONTEXT(_SyncContext)
#define NB_BEGIN_SYNC(_SyncContext)
#define NB_END_SYNC(_SyncContext)

#define NB_DEFINE_LOCK_HANDLE(_LockHandle) CTELockHandle _LockHandle;

//
// Make these be NB_XXX_LOCK_DPC calls -- then the definitions
// of the NB_SYNC_XXX_LOCK calls can be changed to not need _LockHandle
// and many of the functions won't need that as a parameter.
//

#define NB_SYNC_GET_LOCK(_Lock, _LockHandle) NB_GET_LOCK(_Lock, _LockHandle)
#define NB_SYNC_FREE_LOCK(_Lock, _LockHandle) NB_FREE_LOCK(_Lock, _LockHandle)

#define NB_REMOVE_HEAD_LIST(_Queue, _Lock)   ExInterlockedRemoveHeadList(_Queue, &(_Lock)->Lock)
#define NB_LIST_WAS_EMPTY(_Queue, _OldHead)  ((_OldHead) == NULL)
#define NB_INSERT_HEAD_LIST(_Queue, _Entry, _Lock)   ExInterlockedInsertHeadList(_Queue, _Entry, &(_Lock)->Lock)
#define NB_INSERT_TAIL_LIST(_Queue, _Entry, _Lock)   ExInterlockedInsertTailList(_Queue, _Entry, &(_Lock)->Lock)

#define NB_POP_ENTRY_LIST(_Queue, _Lock)           ExInterlockedPopEntryList(_Queue, &(_Lock)->Lock)
#define NB_PUSH_ENTRY_LIST(_Queue, _Entry, _Lock)  ExInterlockedPushEntryList(_Queue, _Entry, &(_Lock)->Lock)

#define NB_LOCK_HANDLE_PARAM(_LockHandle)   , IN CTELockHandle _LockHandle
#define NB_LOCK_HANDLE_ARG(_LockHandle)     , (_LockHandle)

#define NB_SYNC_SWAP_IRQL( _s1, _s2 )   NB_SWAP( _s1, _s2, CTELockHandle )


//
// This macro adds a ULONG to a LARGE_INTEGER (should be
// called with a spinlock held).
//

#define ADD_TO_LARGE_INTEGER(_LargeInteger,_Ulong) \
    ExInterlockedAddLargeStatistic((_LargeInteger),(ULONG)(_Ulong))

#define NB_DEBUG_DEVICE              0x00000001
#define NB_DEBUG_ADDRESS             0x00000004
#define NB_DEBUG_SEND                0x00000008
#define NB_DEBUG_RECEIVE             0x00000020
#define NB_DEBUG_CONFIG              0x00000040
#define NB_DEBUG_PACKET              0x00000080
#define NB_DEBUG_BIND                0x00000200
#define NB_DEBUG_ADDRESS_FRAME       0x00000400
#define NB_DEBUG_CONNECTION          0x00000800
#define NB_DEBUG_QUERY               0x00001000
#define NB_DEBUG_DRIVER              0x00002000
#define NB_DEBUG_CACHE               0x00004000
#define NB_DEBUG_DATAGRAM            0x00008000
#define NB_DEBUG_TIMER               0x00010000
#define NB_DEBUG_SEND_WINDOW         0x00020000



//
// NB_GET_NBHDR_BUFF - gets the nb header in the packet.  It is always the
// second buffer.
//
#define  NB_GET_NBHDR_BUFF(Packet)  (NDIS_BUFFER_LINKAGE((Packet)->Private.Head))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\inc\ipxfltif.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    private\inc\ipxfltif.h

Abstract:
    IPX Filter driver interface with forwarder


Author:

    Vadim Eydelman

Revision History:

--*/

#ifndef _IPXFLTIF_
#define _IPXFLTIF_

	// No filter context means that packets should not
	// be passed for filtering
#define NO_FILTER_CONTEXT ((PVOID)0)


	// Forwarder Driver Entry Points:
	// ==============================
/*++
	S E T _ I F _ I N _ C O N T E X T _ H A N D L E R

Routine Description:
	Associates filter driver context with
	the packets received on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifInContext		- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
typedef
NTSTATUS
(*PSET_IF_IN_CONTEXT_HANDLER) (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifInContext
	);

/*++
	S E T _ I F _ O U T _ C O N T E X T _ H A N D L E R

Routine Description:
	Associates filter driver context with
	the packets sent on the interface
Arguments:
	InterfaceIndex	- index of the interface
	ifOutContext	- filter driver context
Return Value:
	STATUS_SUCCESS	- context associated ok
	STATUS_UNSUCCESSFUL - interface does not exist
--*/
typedef
NTSTATUS
(*PSET_IF_OUT_CONTEXT_HANDLER) (
	IN ULONG	InterfaceIndex,
	IN PVOID	ifOutContext
	);

typedef enum {
	FILTER_DENY_IN = -2,
    FILTER_DENY_OUT = -1,
    FILTER_DENY = 1,
	FILTER_PERMIT = 0
} FILTER_ACTION;
#define NOT_FILTER_ACTION(action) (!action)
#define IS_FILTERED(action) (action!=FILTER_PERMIT)


	// Forwarder Driver Entry Points:
	// ==============================
/*++
	F i l t e r H a n d l e r

Routine Description:
	
	Filters the packet supplied by the forwarder

Arguments:
	ipxHdr			- pointer to packet header
	ipxHdrLength	- size of the header buffer (must be at least 30)
	ifInContext		- context associated with interface on which packet
						was received
	ifOutContext	- context associated with interface on which packet
						will be sent
Return Value:
	FILTER_PERMIT		- packet should be passed on by the forwarder
	FILTER_DENY_IN		- packet should be dropped because of input filter
	FILTER_DENY_OUT		- packet should be dropped because of output filter

--*/
typedef
FILTER_ACTION
(*PFILTER_HANDLER) (
	IN PUCHAR	ipxHdr,
	IN ULONG	ipxHdrLength,
	IN PVOID	ifInContext,
	IN PVOID	ifOutContex
	);

/*++
	I n t e r f a c e D e l e t e d H a n d l e r

Routine Description:
	
	Frees interface filters blocks when forwarder indicates that
	interface is deleted
Arguments:
	ifInContext		- context associated with input filters block	
	ifOutContext	- context associated with output filters block
Return Value:
	None

--*/
typedef
VOID
(*PINTERFACE_DELETED_HANDLER) (
	IN PVOID	ifInContext,
	IN PVOID	ifOutContext
	);

// Binds filter driver to forwarder
// IPX_FLT_BIND_INPUT should be passed in the input buffer and
// IPX_FLT_BINF_OUTPUT will be returned in the output buffer
#define IOCTL_FWD_INTERNAL_BIND_FILTER	\
	CTL_CODE(FILE_DEVICE_IPXFWD,IPXFWD_IOCTL_INDEX+16,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _IPX_FLT_BIND_INPUT {
	PFILTER_HANDLER				FilterHandler;
	PINTERFACE_DELETED_HANDLER	InterfaceDeletedHandler;
} IPX_FLT_BIND_INPUT, *PIPX_FLT_BIND_INPUT;

typedef struct _IPX_FLT_BIND_OUTPUT {
	ULONG						Size;
	PSET_IF_IN_CONTEXT_HANDLER	SetIfInContextHandler;
	PSET_IF_OUT_CONTEXT_HANDLER	SetIfOutContextHandler;
} IPX_FLT_BIND_OUTPUT, *PIPX_FLT_BIND_OUTPUT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\config.c ===
/*++


Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This contains all routines necessary for the support of the dynamic
    configuration of the ISN IPX module.

Revision History:

   Sanjay Anand (SanjayAn) 19-Sept-1995
   Changes to support Plug and Play

--*/

#include "precomp.h"
#pragma hdrstop


//
// Local functions used to access the registry.
//

NTSTATUS
IpxGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxGetBindingValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxGetFrameType(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
IpxReadLinkageInformation(
    IN PCONFIG Config
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,IpxGetConfiguration)
#pragma alloc_text(INIT,IpxFreeConfiguration)

#pragma alloc_text(INIT,IpxAddBind)
#pragma alloc_text(INIT,IpxAddExport)
#pragma alloc_text(INIT,IpxReadLinkageInformation)
#endif
#define MAX_PATH 260


NTSTATUS
IpxGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    )

/*++

Routine Description:

    This routine is called by IPX to get information from the configuration
    management routines. We read the registry, starting at RegistryPath,
    to get the parameters. If they don't exist, we use the defaults
    set in ipxcnfg.h file. A list of adapters to bind to is chained
    on to the config information.

Arguments:

    DriverObject - Used for logging errors.

    RegistryPath - The name of IPX's node in the registry.

    ConfigPtr - Returns the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_INSUFFICIENT_RESOURCES
            otherwise.

--*/

{
    PWSTR RegistryPathBuffer;
    PCONFIG Config;
    RTL_QUERY_REGISTRY_TABLE QueryTable[CONFIG_PARAMETERS+2];
    NTSTATUS Status;
    ULONG Zero = 0;
    ULONG One = 1;
    ULONG Five = 5;
    ULONG Eight = 8;
    ULONG Ten = 10;
    ULONG Fifteen = 15;
    ULONG Fifty = 50;
    ULONG DefaultSocketStart = 0x4000;
    ULONG DefaultSocketEnd = 0x8000;
    ULONG RipSegments = RIP_SEGMENTS;
    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[CONFIG_PARAMETERS] = {
        { L"DedicatedRouter",      &Zero } ,
        { L"InitDatagrams",        &Ten } ,
        { L"MaxDatagrams",         &Fifty } ,
        { L"RipAgeTime",           &Five } ,    //  minutes
        { L"RipCount",             &Five } ,
        { L"RipTimeout",           &One } ,     //  half-second
        { L"RipUsageTime",         &Fifteen } , //  minutes
        { L"SourceRouteUsageTime", &Ten } ,     //  minutes
        { L"SocketUniqueness",     &Eight } ,
        { L"SocketStart",          &DefaultSocketStart } ,
        { L"SocketEnd",            &DefaultSocketEnd } ,
        { L"VirtualNetworkNumber", &Zero } ,
        { L"MaxMemoryUsage",       &Zero } ,
        { L"RipTableSize",         &RipSegments } ,
        { L"VirtualNetworkOptional", &One } ,
        { L"EthernetPadToEven",    &One } ,
        { L"EthernetExtraPadding", &Zero } ,
        { L"SingleNetworkActive",  &Zero } ,
        { L"DisableDialoutSap",    &Zero } ,
        { L"DisableDialinNetbios", &One } ,
        { L"VerifySourceAddress",  &One } };

    UINT i;


    //
    // Allocate memory for the main config structure.
    //

    Config = IpxAllocateMemory (sizeof(CONFIG), MEMORY_CONFIG, "Config");
    if (Config == NULL) {
        IpxWriteResourceErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            sizeof(CONFIG),
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Config->DeviceName.Buffer = NULL;
    InitializeListHead (&Config->BindingList);
    Config->DriverObject = DriverObject;

    //
    // Read in the NDIS binding information.
    //
    // IpxReadLinkageInformation expects a null-terminated path,
    // so we have to create one from the UNICODE_STRING.
    //

    RegistryPathBuffer = (PWSTR)IpxAllocateMemory(RegistryPath->Length + sizeof(WCHAR),
                                                      MEMORY_CONFIG, "RegistryPathBuffer");
    if (RegistryPathBuffer == NULL) {
        IpxFreeConfiguration(Config);
        IpxWriteResourceErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            RegistryPath->Length + sizeof(WCHAR),
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory (RegistryPathBuffer, RegistryPath->Buffer, RegistryPath->Length);
    *(PWCHAR)(((PUCHAR)RegistryPathBuffer)+RegistryPath->Length) = (WCHAR)'\0';

    Config->RegistryPathBuffer = RegistryPathBuffer;

    //
    // Determine what name to export and who to bind to.
    //

    Status = IpxReadLinkageInformation (Config);
    if (Status != STATUS_SUCCESS) {

        //
        // It logged an error if it failed.
        //
        IpxFreeMemory (Config->RegistryPathBuffer,
                       RegistryPath->Length + sizeof(WCHAR),
                       MEMORY_CONFIG,
                       "RegistryPathBuffer");
        IpxFreeConfiguration(Config);
        return Status;
    }

    //
    // Read the per-transport (as opposed to per-binding)
    // parameters.
    //

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Parameters key below IPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    //
    // 2-14) Call IpxGetConfigValue for each of the keys we
    // care about.
    //

    for (i = 0; i < CONFIG_PARAMETERS; i++) {

        QueryTable[i+1].QueryRoutine = IpxGetConfigValue;
        QueryTable[i+1].Flags = 0;
        QueryTable[i+1].Name = ParameterValues[i].KeyName;
        QueryTable[i+1].EntryContext = UlongToPtr(i);
        QueryTable[i+1].DefaultType = REG_DWORD;
        QueryTable[i+1].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+1].DefaultLength = sizeof(ULONG);

    }

    //
    // 15) Stop
    //

    QueryTable[CONFIG_PARAMETERS+1].QueryRoutine = NULL;
    QueryTable[CONFIG_PARAMETERS+1].Flags = 0;
    QueryTable[CONFIG_PARAMETERS+1].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        IpxFreeMemory (Config->RegistryPathBuffer,
                       RegistryPath->Length + sizeof(WCHAR),
                       MEMORY_CONFIG,
                       "RegistryPathBuffer");
        IpxFreeConfiguration(Config);

        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            905,
            Status,
            Parameters,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

	//
    // For PnP, we need to keep this path around
    //

    *ConfigPtr = Config;

    return STATUS_SUCCESS;

}   /* IpxGetConfiguration */


VOID
IpxFreeConfiguration (
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by IPX to get free any storage that was allocated
    by IpxGetConfiguration in producing the specified CONFIG structure.

Arguments:

    Config - A pointer to the configuration information structure.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PBINDING_CONFIG Binding;

    while (!IsListEmpty (&Config->BindingList)) {
        p = RemoveHeadList (&Config->BindingList);
        Binding = CONTAINING_RECORD (p, BINDING_CONFIG, Linkage);
        IpxFreeMemory (Binding->AdapterName.Buffer, Binding->AdapterName.MaximumLength, MEMORY_CONFIG, "NameBuffer");
        IpxFreeMemory (Binding, sizeof(BINDING_CONFIG), MEMORY_CONFIG, "Binding");
    }

    if (Config->DeviceName.Buffer) {
        IpxFreeMemory (Config->DeviceName.Buffer, Config->DeviceName.MaximumLength, MEMORY_CONFIG, "DeviceName");
    }

    IpxFreeMemory (Config, sizeof(CONFIG), MEMORY_CONFIG, "Config");

}   /* IpxFreeConfiguration */


NTSTATUS
IpxGetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the CONFIG structure.

    EntryContext - The index in Config->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            904,
            STATUS_INVALID_PARAMETER,
            ValueName,
            0,
            NULL);
        return STATUS_INVALID_PARAMETER;
    }
#ifdef SUNDOWN
     IPX_DEBUG (CONFIG, ("Config parameter %d, value %lx\n",
                            (ULONG_PTR)EntryContext, *(UNALIGNED ULONG *)ValueData));
     Config->Parameters[(ULONG_PTR)EntryContext] = *(UNALIGNED ULONG *)ValueData;
#else
     IPX_DEBUG (CONFIG, ("Config parameter %d, value %lx\n",
                            (ULONG)EntryContext, *(UNALIGNED ULONG *)ValueData));
     Config->Parameters[(ULONG)EntryContext] = *(UNALIGNED ULONG *)ValueData;
#endif

   
    

    return STATUS_SUCCESS;

}   /* IpxGetConfigValue */


NTSTATUS
IpxGetBindingValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the NetConfig\DriverNN
    node to set the per-binding values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value (REG_DWORD -- ignored).

    ValueData - The data for the value.

    ValueLength - The length of ValueData (ignored).

    Context - A pointer to the BINDING_CONFIG structure.

    EntryContext - The index in Binding->Parameters to save the value.

Return Value:

    STATUS_SUCCESS

--*/

{
    PBINDING_CONFIG Binding = (PBINDING_CONFIG)Context;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);
    UNREFERENCED_PARAMETER(ValueLength);

    if ((ValueType != REG_DWORD) || (ValueLength != sizeof(ULONG))) {

        IpxWriteGeneralErrorLog(
            (PVOID)Binding->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            903,
            STATUS_INVALID_PARAMETER,
            ValueName,
            0,
            NULL);
        return STATUS_INVALID_PARAMETER;
    }
#ifdef SUNDOWN
    IPX_DEBUG (CONFIG, ("Binding parameter %d, value %lx\n",
                            (ULONG_PTR)EntryContext, *(UNALIGNED ULONG *)ValueData));
    Binding->Parameters[(ULONG_PTR)EntryContext] = *(UNALIGNED ULONG *)ValueData;	
#else
    IPX_DEBUG (CONFIG, ("Binding parameter %d, value %lx\n",
                            (ULONG)EntryContext, *(UNALIGNED ULONG *)ValueData));
    Binding->Parameters[(ULONG)EntryContext] = *(UNALIGNED ULONG *)ValueData;
#endif

    
    

    return STATUS_SUCCESS;

}   /* IpxGetBindingValue */


NTSTATUS
IpxGetFrameType(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues.
    It is called for each of the entry in the "PktType" and
    "NetworkNumber" multi-strings for a given binding.

Arguments:

    ValueName - The name of the value ("PktType" or "NetworkNumber" -- ignored).

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the BINDING_CONFIG structure.

    EntryContext - A pointer to a count of multi-string entries.

Return Value:

    STATUS_SUCCESS

--*/

{
    PBINDING_CONFIG Binding = (PBINDING_CONFIG)Context;
    ULONG IntegerValue;
    PWCHAR Cur;
    PULONG Count = (PULONG)EntryContext;

    ASSERT(Binding->DriverObject != NULL); 

    if ((ValueType != REG_SZ) ||
        (*Count >= 4)) {

        IpxWriteGeneralErrorLog(
            (PVOID)Binding->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            903,
            STATUS_INVALID_PARAMETER,
            ValueName,
            0,
            NULL);
        return STATUS_INVALID_PARAMETER;
    }

    IntegerValue = 0;
    for (Cur = (PWCHAR)(ValueData); ; Cur++) {
        if (*Cur >= L'0' && *Cur <= L'9') {
            IntegerValue = (IntegerValue * 16) + (*Cur - L'0');
        } else if (*Cur >= L'A' && *Cur <= L'F') {
            IntegerValue = (IntegerValue * 16) + (*Cur - L'A' + 10);
        } else if (*Cur >= L'a' && *Cur <= L'f') {
            IntegerValue = (IntegerValue * 16) + (*Cur - L'a' + 10);
        } else {
            break;
        }
    }

    if (((PWCHAR)ValueName)[0] == L'P') {

        //
        // PktType. We map arcnet to 802_3 so the code around
        // here can assume there are only four packets type --
        // the frame type is ignored later for arcnet.
        //

        if ((IntegerValue > ISN_FRAME_TYPE_ARCNET) &&
            (IntegerValue != ISN_FRAME_TYPE_AUTO)) {

            IpxWriteGeneralErrorLog(
                (PVOID)Binding->DriverObject,
                EVENT_IPX_ILLEGAL_CONFIG,
                903,
                STATUS_INVALID_PARAMETER,
                ValueName,
                0,
                NULL);
            return STATUS_INVALID_PARAMETER;
        }

        IPX_DEBUG (CONFIG, ("PktType(%d) is %lx\n", *Count, IntegerValue));
        if (IntegerValue == ISN_FRAME_TYPE_ARCNET) {
            Binding->FrameType[*Count] = ISN_FRAME_TYPE_802_3;
        } else {
            Binding->FrameType[*Count] = IntegerValue;
        }

    } else {

        //
        // NetworkNumber
        //

        IPX_DEBUG (CONFIG, ("NetworkNumber(%d) is %d\n", *Count, IntegerValue));
        Binding->NetworkNumber[*Count] = IntegerValue;

    }

    ++(*Count);

    return STATUS_SUCCESS;

}   /* IpxGetFrameType */


NTSTATUS
IpxAddBind(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Bind" multi-string and
    saves the information in a Config structure. It
    also queries the per-binding information and stores it.

Arguments:

    ValueName - The name of the value ("Bind" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the Config structure.

    EntryContext - A pointer to a count of binds that is incremented.

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    PBINDING_CONFIG Binding;
    PULONG CurBindNum = ((PULONG)EntryContext);
    RTL_QUERY_REGISTRY_TABLE QueryTable[BINDING_PARAMETERS+4];
    ULONG FrameTypeCount, NetworkNumberCount;
    ULONG StringLoc;
    BOOLEAN AutoDetect;
    ULONG AutoDetectLoc;
    ULONG SlideCount;
    PWCHAR NameBuffer;
    NTSTATUS Status;
    BOOLEAN FrameTypeUsed[ISN_FRAME_TYPE_MAX];
    ULONG Zero = 0;
    ULONG One = 1;
    ULONG DefaultBindSap = 0x8137;
    ULONG DefaultAutoDetectType = ISN_FRAME_TYPE_802_2;
    WCHAR Subkey[MAX_PATH];// = L"Parameters\\Adapters\\12345678901234567890";
    PWSTR ValueDataWstr = (PWSTR)ValueData;
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[BINDING_PARAMETERS] = {
        { L"MaxPktSize",       &Zero } ,
        { L"BindSap",          &DefaultBindSap } ,
        { L"DefaultAutoDetectType", &DefaultAutoDetectType } ,
        { L"SourceRouting",    &One } ,
        { L"SourceRouteDef",   &Zero } ,
        { L"SourceRouteBcast", &Zero } ,
        { L"SourceRouteMcast", &Zero } ,
        { L"EnableFuncaddr",   &One } ,
        { L"EnableWanRouter",  &One } };
    ULONG BindingPreference[ISN_FRAME_TYPE_MAX] = {
        ISN_FRAME_TYPE_802_2,
        ISN_FRAME_TYPE_802_3,
        ISN_FRAME_TYPE_ETHERNET_II,
        ISN_FRAME_TYPE_SNAP };

    UINT i, j, k;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);


    Binding = (PBINDING_CONFIG)IpxAllocateMemory (sizeof(BINDING_CONFIG), MEMORY_CONFIG, "Binding");
    if (Binding == NULL) {
        IpxWriteResourceErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            sizeof(BINDING_CONFIG),
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NameBuffer = (PWCHAR)IpxAllocateMemory (ValueLength, MEMORY_CONFIG, "NameBuffer");
    if (NameBuffer == NULL) {
        IpxFreeMemory (Binding, sizeof(BINDING_CONFIG), MEMORY_CONFIG, "Binding");
        IpxWriteResourceErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            ValueLength,
            MEMORY_CONFIG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (NameBuffer, ValueData, ValueLength);
    Binding->AdapterName.Buffer = NameBuffer;
    Binding->AdapterName.Length = (USHORT)(ValueLength - sizeof(WCHAR));
    Binding->AdapterName.MaximumLength = (USHORT)ValueLength;

    Binding->DriverObject = Config->DriverObject;

    FrameTypeCount = 0;
    NetworkNumberCount = 0;

    //
    // The structure is allocated OK, insert it into the list.
    //

    InsertTailList (&Config->BindingList, &Binding->Linkage);
    ++(*CurBindNum);


    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the NetConfig\XXXX key below IPX
    //    (we construct the right name in Subkey,
    //    first scan back to find the \, then copy
    //    the rest over, including the final '\0').
    //

    StringLoc = (ValueLength / sizeof(WCHAR)) - 2;
    while (ValueDataWstr[StringLoc] != L'\\') {
        --StringLoc;
    }

    RtlCopyMemory(&Subkey, L"Parameters\\Adapters\\12345678901234567890", 40);
    RtlCopyMemory(&Subkey[20], &ValueDataWstr[StringLoc+1], ValueLength - ((StringLoc+1) * sizeof(WCHAR)));
    KdPrint(("Subkey:%ws\n", Subkey));

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call IpxGetFrameType for each part of the
    // "PktType" multi-string.
    //

    QueryTable[1].QueryRoutine = IpxGetFrameType;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = L"PktType";
    QueryTable[1].EntryContext = &FrameTypeCount;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Call IpxGetFrameType for each part of the
    // "NetworkNumber" multi-string.
    //

    QueryTable[2].QueryRoutine = IpxGetFrameType;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[2].Name = L"NetworkNumber";
    QueryTable[2].EntryContext = &NetworkNumberCount;
    QueryTable[2].DefaultType = REG_NONE;

    //
    // 4-11) Call IpxGetBindingValue for each of the keys we
    // care about.
    //

    for (i = 0; i < BINDING_PARAMETERS; i++) {

        QueryTable[i+3].QueryRoutine = IpxGetBindingValue;
        QueryTable[i+3].Flags = 0;
        QueryTable[i+3].Name = ParameterValues[i].KeyName;
        QueryTable[i+3].EntryContext = UlongToPtr(i);
        QueryTable[i+3].DefaultType = REG_DWORD;
        QueryTable[i+3].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+3].DefaultLength = sizeof(ULONG);

    }

    //
    // 12) Stop
    //

    QueryTable[BINDING_PARAMETERS+3].QueryRoutine = NULL;
    QueryTable[BINDING_PARAMETERS+3].Flags = 0;
    QueryTable[BINDING_PARAMETERS+3].Name = NULL;


    IPX_DEBUG (CONFIG, ("Read bind key for %ws (%ws)\n", ValueData, Subkey));

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Binding,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        //
        // The binding will get freed during cleanup.
        //

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            906,
            Status,
            Subkey,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (FrameTypeCount == 0) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_NO_FRAME_TYPES,
            907,
            Status,
            Subkey + 10,
            0,
            NULL);
    }

    if (FrameTypeCount > NetworkNumberCount) {
        for (i = NetworkNumberCount; i <FrameTypeCount; i++) {
            Binding->NetworkNumber[i] = 0;
        }
    }
    Binding->FrameTypeCount = FrameTypeCount;

    //
    // Go through and eliminate duplicates from the frame
    // type array.
    //

    for (i = 0; i < Binding->FrameTypeCount; i++) {

        for (j = i+1; j < Binding->FrameTypeCount; j++) {

            if (Binding->FrameType[j] == Binding->FrameType[i]) {

                IPX_DEBUG (CONFIG, ("Frame types %d and %d identical\n", i, j));

                //
                // A duplicate, slide everything else down.
                //

                for (k = j+1; k < Binding->FrameTypeCount; k++) {
                    Binding->FrameType[k-1] = Binding->FrameType[k];
                    Binding->NetworkNumber[k-1] = Binding->NetworkNumber[k];
                }
                --Binding->FrameTypeCount;

                --j;   // so we check whoever just moved into this spot.
            }
        }
    }


    //
    // Mark all the explicitly configured frame types, and
    // see if we have to auto-detect.
    //

    for (i = 0; i < 4; i++) {
        FrameTypeUsed[i] = FALSE;
    }

    AutoDetect = FALSE;
    for (i = 0; i < Binding->FrameTypeCount; i++) {
        if (Binding->FrameType[i] == ISN_FRAME_TYPE_AUTO) {
            AutoDetectLoc = i;
            AutoDetect = TRUE;
        } else {
            Binding->AutoDetect[i] = FALSE;
            Binding->DefaultAutoDetect[i] = FALSE;
            FrameTypeUsed[Binding->FrameType[i]] = TRUE;
        }
    }

    if (!AutoDetect) {
        IPX_DEBUG (AUTO_DETECT, ("No bindings auto-detected\n"));
        return STATUS_SUCCESS;
    }

    //
    // Slide everything that is past the auto-detect point up
    // to the end.
    //

    SlideCount = Binding->FrameTypeCount - AutoDetectLoc - 1;
    for (j = 3; j > 3 - SlideCount; j--) {
        Binding->FrameType[j] = Binding->FrameType[j-(3-Binding->FrameTypeCount)];
        Binding->NetworkNumber[j] = Binding->NetworkNumber[j-(3-Binding->FrameTypeCount)];
        Binding->AutoDetect[j] = Binding->AutoDetect[j-(3-Binding->FrameTypeCount)];
        Binding->DefaultAutoDetect[j] = Binding->DefaultAutoDetect[j-(3-Binding->FrameTypeCount)];
    }

    //
    // Now fill in any frame types that are not hard-coded,
    // this will start at AutoDetectLoc and exactly fill up
    // the gap created when we slid things up above. We
    // first put the default auto-detect at the first spot.
    //

    if (!FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]]) {
        Binding->FrameType[AutoDetectLoc] = Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT];
        Binding->NetworkNumber[AutoDetectLoc] = 0;
        Binding->AutoDetect[AutoDetectLoc] = TRUE;
        Binding->DefaultAutoDetect[AutoDetectLoc] = TRUE;
        ++AutoDetectLoc;
        FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]] = TRUE;
    }

    //
    // Now fill in the array, using the preference order in
    // the BindingPreference array (this comes into effect
    // because the first frame type in our list that we
    // find is used).
    //

    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {

        if (!FrameTypeUsed[BindingPreference[i]]) {
            Binding->FrameType[AutoDetectLoc] = BindingPreference[i];
            Binding->NetworkNumber[AutoDetectLoc] = 0;
            Binding->AutoDetect[AutoDetectLoc] = TRUE;
            Binding->DefaultAutoDetect[AutoDetectLoc] = FALSE;
            ++AutoDetectLoc;
        }
    }

    Binding->FrameTypeCount = ISN_FRAME_TYPE_MAX;

#if DBG
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
        IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d, defaultautodetect %d\n",
            i, Binding->FrameType[i], Binding->NetworkNumber[i], Binding->AutoDetect[i], Binding->DefaultAutoDetect[i]));
    }
#endif

    return STATUS_SUCCESS;

}   /* IpxAddBind */


NTSTATUS
IpxAddExport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each piece of the "Export" multi-string. It
    saves the first callback string in the Config structure.

Arguments:

    ValueName - The name of the value ("Export" -- ignored).

    ValueType - The type of the value (REG_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - A pointer to the Config structure.

    EntryContext - A pointer to a ULONG that goes to 1 after the
       first call to this routine (so we know to ignore other ones).

Return Value:

    STATUS_SUCCESS

--*/

{
    PCONFIG Config = (PCONFIG)Context;
    PULONG ValueReadOk = ((PULONG)EntryContext);
    PWCHAR NameBuffer;

    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueType);

    if (*ValueReadOk == 0) {

        IPX_DEBUG (CONFIG, ("Read export value %ws\n", ValueData));

        NameBuffer = (PWCHAR)IpxAllocateMemory (ValueLength, MEMORY_CONFIG, "DeviceName");
        if (NameBuffer == NULL) {
            IpxWriteResourceErrorLog(
                (PVOID)Config->DriverObject,
                EVENT_TRANSPORT_RESOURCE_POOL,
                ValueLength,
                MEMORY_CONFIG);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory (NameBuffer, ValueData, ValueLength);
        Config->DeviceName.Buffer = NameBuffer;
        Config->DeviceName.Length = (USHORT)(ValueLength - sizeof(WCHAR));
        Config->DeviceName.MaximumLength = (USHORT)ValueLength;

        //
        // Set this to ignore any other callbacks and let the
        // caller know we read something.
        //

        *ValueReadOk = 1;

    }

    return STATUS_SUCCESS;

}   /* IpxAddExport */


NTSTATUS
IpxReadLinkageInformation(
    IN PCONFIG Config
    )

/*++

Routine Description:

    This routine is called by IPX to read its linkage information
    from the registry.

Arguments:

    Config - The config structure which will have per-binding information
        linked on to it.

Return Value:

    The status of the operation.

--*/

{

    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWSTR Subkey = L"Linkage";
    PWSTR Bind = L"Bind";
    PWSTR Export = L"Export";
    ULONG ValueReadOk;

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Linkage key below IPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 1) Call IpxAddExport for each string in "Export"
    //

    QueryTable[1].QueryRoutine = IpxAddExport;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = Export;
    QueryTable[1].EntryContext = (PVOID)&ValueReadOk;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 2) Stop
    //

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;


    ValueReadOk = 0;

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if ((Status != STATUS_SUCCESS) || (ValueReadOk == 0)) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            901,
            Status,
            Export,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return STATUS_SUCCESS;

}   /* IpxReadLinkageInformation */


VOID
IpxWriteDefaultAutoDetectType(
    IN PUNICODE_STRING RegistryPath,
    IN struct _ADAPTER * Adapter,
    IN ULONG FrameType
    )

/*++

Routine Description:

    This routine is called when we were unable to detect the default
    auto-detect type and instead found a different one. We update
    the "DefaultAutoDetectType" in the registry.

Arguments:

    RegistryPath - The name of IPX's node in the registry.

    Adapter - The adapter which we auto-detected on.

    FrameType - The new auto-detected value.

Return Value:

    None.

--*/

{
    PWSTR FullRegistryPath;
    PUCHAR CurRegistryPath;
    ULONG FullRegistryPathLength;
    ULONG AdapterNameLength;
    WCHAR Adapters[] = L"\\Parameter\\Adapters\\";
    static PWCHAR FrameTypeNames[4] = { L"Ethernet II", L"802.3", L"802.2", L"SNAP" };
    PWCHAR CurAdapterName;
    NTSTATUS Status;


    //
    // We need to allocate a buffer which contains the registry path,
    // followed by "\Parameters\Adapters\", followed by the adapter name, and
    // then NULL-terminated.
    //

    CurAdapterName = &Adapter->AdapterName[(Adapter->AdapterNameLength/sizeof(WCHAR))-2];
    while (*CurAdapterName != L'\\') {
        --CurAdapterName;
    }

    // AdapterNameLength is unlikely to exceed 32-bit, RtlCopyMemory takes 32-bit only, so we cast it to ULONG
    AdapterNameLength = (ULONG) (Adapter->AdapterNameLength - ((CurAdapterName - Adapter->AdapterName) * sizeof(WCHAR)) - sizeof(WCHAR));

    FullRegistryPathLength = RegistryPath->Length + sizeof(Adapters) + AdapterNameLength;

    FullRegistryPath = (PWSTR)IpxAllocateMemory (FullRegistryPathLength, MEMORY_CONFIG, "FullRegistryPath");
    if (FullRegistryPath == NULL) {
        IpxWriteResourceErrorLog(
            IpxDevice->DeviceObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            FullRegistryPathLength,
            MEMORY_CONFIG);
        return;
    }

    CurRegistryPath = (PUCHAR)FullRegistryPath;
    RtlCopyMemory (CurRegistryPath, RegistryPath->Buffer, RegistryPath->Length);
    CurRegistryPath += RegistryPath->Length;
    RtlCopyMemory (CurRegistryPath, Adapters, sizeof(Adapters) - sizeof(WCHAR));
    CurRegistryPath += (sizeof(Adapters) - sizeof(WCHAR));
    RtlCopyMemory (CurRegistryPath, CurAdapterName, AdapterNameLength);
    CurRegistryPath += AdapterNameLength;
    *(PWCHAR)CurRegistryPath = L'\0';

    Status = RtlWriteRegistryValue(
                 RTL_REGISTRY_ABSOLUTE,
                 FullRegistryPath,
                 L"DefaultAutoDetectType",
                 REG_DWORD,
                 &FrameType,
                 sizeof(ULONG));

    IpxFreeMemory (FullRegistryPath, FullRegistryPathLength, MEMORY_CONFIG, "FullRegistryPath");

    IpxWriteGeneralErrorLog(
        IpxDevice->DeviceObject,
        EVENT_IPX_NEW_DEFAULT_TYPE,
        888,
        STATUS_SUCCESS,
        FrameTypeNames[FrameType],
        0,
        NULL);

}   /* IpxWriteDefaultAutoDetectType */


//
// Vnet# and VnetOptional
//
#define VIRTUAL_NETWORK_PARAMETERS  2

NTSTATUS
IpxPnPGetVirtualNetworkNumber (
    IN	PCONFIG	Config
    )

/*++

Routine Description:

    This routine is called by IPX to read the virtual network number
    from the registry. This is called on appearance/disappearance of an
    adapter from the system. We read the registry, starting at RegistryPath,
    to get the value of the VirtualNetworkNumber parameter. If it doesn't
    exist, we use the default set in ipxcnfg.h file.
	Adapted from IpxGetConfiguration().

Arguments:

    Config - Contians the configuration information.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_DEVICE_CONFIGURATION_ERROR
            otherwise.

--*/

{
    RTL_QUERY_REGISTRY_TABLE QueryTable[VIRTUAL_NETWORK_PARAMETERS+2];
    NTSTATUS Status;
    ULONG Zero = 0;
    ULONG One = 1;
    PWSTR Parameters = L"Parameters";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[VIRTUAL_NETWORK_PARAMETERS] = {
        { L"VirtualNetworkNumber", &Zero } ,
        { L"VirtualNetworkOptional", &One } };
    UINT i;

    //
    // Read the virtual net number from the parameters.
    //

    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the Parameters key below IPX
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Parameters;

    //
    // 2) Call IpxGetConfigValue for the virtual net number key
    //

    QueryTable[1].QueryRoutine = IpxGetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = ParameterValues[0].KeyName;
    QueryTable[1].EntryContext = (PVOID)CONFIG_VIRTUAL_NETWORK;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = (PVOID)(ParameterValues[0].DefaultValue);
    QueryTable[1].DefaultLength = sizeof(ULONG);

    //
    // 2) Call IpxGetConfigValue for the virtual net optional key
    //

    QueryTable[2].QueryRoutine = IpxGetConfigValue;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = ParameterValues[1].KeyName;
    QueryTable[2].EntryContext = (PVOID)CONFIG_VIRTUAL_OPTIONAL;
    QueryTable[2].DefaultType = REG_DWORD;
    QueryTable[2].DefaultData = (PVOID)(ParameterValues[1].DefaultValue);
    QueryTable[2].DefaultLength = sizeof(ULONG);

    //
    // 15) Stop
    //

    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = NULL;


    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Config,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            905,
            Status,
            Parameters,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return STATUS_SUCCESS;

}   /* IpxPnPGetNetworkNumber */

#define IPX_REG_KEY_CONFIG_NAME L"Parameters\\Adapters\\12345678901234567890"
#define IPX_REG_KEY_CONFIG_DUMMY_LENGTH 40
#define IPX_REG_KEY_CONFIG_LENGTH 20


NTSTATUS
IpxPnPGetAdapterParameters(
	IN		PCONFIG			Config,
	IN		PNDIS_STRING	DeviceName,
	IN OUT	PBINDING_CONFIG	Binding
	)
/*++

Routine Description:

    This routine is called by IPX to read the adapter-specific parameters
    from the registry on PnP appearance of an adapter in the system.
	We read the registry, starting at RegistryPath\NetConfig\DeviceName.

	Adapted from IpxAddBind().

Arguments:

    Config - Config structure - supplies the DeviceObject and RegistryPathBuffer.

    DeviceName - name of the adapter that was added.

    Binding - Returns the configuration information per adapter.

Return Value:

    Status - STATUS_SUCCESS if everything OK, STATUS_DEVICE_CONFIGURATION_ERROR
            otherwise.

--*/
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[BINDING_PARAMETERS+4];
    ULONG FrameTypeCount, NetworkNumberCount;
    ULONG StringLoc;
    BOOLEAN AutoDetect;
    ULONG AutoDetectLoc;
    ULONG SlideCount;
    PWCHAR NameBuffer;
    NTSTATUS Status;
    BOOLEAN FrameTypeUsed[ISN_FRAME_TYPE_MAX];
    ULONG Zero = 0;
    ULONG One = 1;
    ULONG DefaultBindSap = 0x8137;
    ULONG DefaultAutoDetectType = ISN_FRAME_TYPE_802_2;
    WCHAR Subkey[MAX_PATH];// = L"NetConfig\\12345678901234567890";
    struct {
        PWSTR KeyName;
        PULONG DefaultValue;
    } ParameterValues[BINDING_PARAMETERS] = {
        { L"MaxPktSize",       &Zero } ,
        { L"BindSap",          &DefaultBindSap } ,
        { L"DefaultAutoDetectType", &DefaultAutoDetectType } ,
        { L"SourceRouting",    &One } ,
        { L"SourceRouteDef",   &Zero } ,
        { L"SourceRouteBcast", &Zero } ,
        { L"SourceRouteMcast", &Zero } ,
        { L"EnableFuncaddr",   &One } ,
        { L"EnableWanRouter",  &One } };
    ULONG BindingPreference[ISN_FRAME_TYPE_MAX] = {
        ISN_FRAME_TYPE_802_2,
        ISN_FRAME_TYPE_802_3,
        ISN_FRAME_TYPE_ETHERNET_II,
        ISN_FRAME_TYPE_SNAP };

    UINT i, j, k;

    ASSERT(Binding->DriverObject != NULL); 
    
    FrameTypeCount = 0;
    NetworkNumberCount = 0;

    //
    // The structure is allocated OK, insert it into the list.
    //

//  InsertTailList (&Config->BindingList, &Binding->Linkage);
//  ++(*CurBindNum);


    //
    // Set up QueryTable to do the following:
    //

    //
    // 1) Switch to the NetConfig\XXXX key below IPX
    //    (we construct the right name in Subkey,
    //    first scan back to find the \, then copy
    //    the rest over, including the final '\0').
    //
    StringLoc = (DeviceName->Length / sizeof(WCHAR)) - 2;
    while (DeviceName->Buffer[StringLoc] != L'\\') {
        --StringLoc;
    }

    RtlCopyMemory(&Subkey, IPX_REG_KEY_CONFIG_NAME, IPX_REG_KEY_CONFIG_DUMMY_LENGTH);
    RtlCopyMemory(&Subkey[IPX_REG_KEY_CONFIG_LENGTH], &DeviceName->Buffer[StringLoc+1], DeviceName->Length - ((StringLoc+1) * sizeof(WCHAR)));
    
    Subkey[IPX_REG_KEY_CONFIG_LENGTH + (DeviceName->Length / sizeof (WCHAR)) - (StringLoc+1) ] = L'\0';
    
    IPX_DEBUG(CONFIG, ("Subkey:%ws\n", Subkey));
//RtlCopyMemory(&Subkey[10], &DeviceName->Buffer[StringLoc+1], DeviceName->MaximumLength - ((StringLoc+1) * sizeof(WCHAR)));

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = Subkey;

    //
    // 2) Call IpxGetFrameType for each part of the
    // "PktType" multi-string.
    //

    QueryTable[1].QueryRoutine = IpxGetFrameType;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[1].Name = L"PktType";
    QueryTable[1].EntryContext = &FrameTypeCount;
    QueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Call IpxGetFrameType for each part of the
    // "NetworkNumber" multi-string.
    //

    QueryTable[2].QueryRoutine = IpxGetFrameType;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[2].Name = L"NetworkNumber";
    QueryTable[2].EntryContext = &NetworkNumberCount;
    QueryTable[2].DefaultType = REG_NONE;

    //
    // 4-11) Call IpxGetBindingValue for each of the keys we
    // care about.
    //

    for (i = 0; i < BINDING_PARAMETERS; i++) {

        QueryTable[i+3].QueryRoutine = IpxGetBindingValue;
        QueryTable[i+3].Flags = 0;
        QueryTable[i+3].Name = ParameterValues[i].KeyName;
        QueryTable[i+3].EntryContext = UlongToPtr(i);
        QueryTable[i+3].DefaultType = REG_DWORD;
        QueryTable[i+3].DefaultData = (PVOID)(ParameterValues[i].DefaultValue);
        QueryTable[i+3].DefaultLength = sizeof(ULONG);

    }

    //
    // 12) Stop
    //

    QueryTable[BINDING_PARAMETERS+3].QueryRoutine = NULL;
    QueryTable[BINDING_PARAMETERS+3].Flags = 0;
    QueryTable[BINDING_PARAMETERS+3].Name = NULL;


    IPX_DEBUG (CONFIG, ("Read bind key for %ws (%ws)\n", DeviceName->Buffer, Subkey));

    Status = RtlQueryRegistryValues(
                 RTL_REGISTRY_ABSOLUTE,
                 Config->RegistryPathBuffer,
                 QueryTable,
                 (PVOID)Binding,
                 NULL);

    if (Status != STATUS_SUCCESS) {

        //
        // The binding will get freed during cleanup.
        //

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_ILLEGAL_CONFIG,
            906,
            Status,
            Subkey,
            0,
            NULL);
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (FrameTypeCount == 0) {

        IpxWriteGeneralErrorLog(
            (PVOID)Config->DriverObject,
            EVENT_IPX_NO_FRAME_TYPES,
            907,
            Status,
            Subkey + 10,
            0,
            NULL);
    }

    if (FrameTypeCount > NetworkNumberCount) {
        for (i = NetworkNumberCount; i <FrameTypeCount; i++) {
            Binding->NetworkNumber[i] = 0;
        }
    }
    Binding->FrameTypeCount = FrameTypeCount;

    //
    // Go through and eliminate duplicates from the frame
    // type array.
    //

    for (i = 0; i < Binding->FrameTypeCount; i++) {

        for (j = i+1; j < Binding->FrameTypeCount; j++) {

            if (Binding->FrameType[j] == Binding->FrameType[i]) {

                IPX_DEBUG (CONFIG, ("Frame types %d and %d identical\n", i, j));

                //
                // A duplicate, slide everything else down.
                //

                for (k = j+1; k < Binding->FrameTypeCount; k++) {
                    Binding->FrameType[k-1] = Binding->FrameType[k];
                    Binding->NetworkNumber[k-1] = Binding->NetworkNumber[k];
                }
                --Binding->FrameTypeCount;

                --j;   // so we check whoever just moved into this spot.
            }
        }
    }


    //
    // Mark all the explicitly configured frame types, and
    // see if we have to auto-detect.
    //

    for (i = 0; i < 4; i++) {
        FrameTypeUsed[i] = FALSE;
    }

    AutoDetect = FALSE;
    for (i = 0; i < Binding->FrameTypeCount; i++) {
        if ((Binding->FrameType[i] == ISN_FRAME_TYPE_AUTO)) {
            AutoDetectLoc = i;
            AutoDetect = TRUE;
        } else {
            Binding->AutoDetect[i] = FALSE;
            Binding->DefaultAutoDetect[i] = FALSE;
            FrameTypeUsed[Binding->FrameType[i]] = TRUE;
        }
    }

    if (!AutoDetect) {
        IPX_DEBUG (AUTO_DETECT, ("No bindings auto-detected\n"));
#if DBG
	for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
	   IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d, default auto detect %d\n",
				    i, Binding->FrameType[i], Binding->NetworkNumber[i], Binding->AutoDetect[i], Binding->DefaultAutoDetect[i]));
	}
#endif
        return STATUS_SUCCESS;
    }

    //
    // Slide everything that is past the auto-detect point up
    // to the end.
    //

    //
    // Fixed this loop which can spill over if the FrameTypeCount is 4 and the SlideCount > 0.
    // Here, the FrameTypeCount is 1-based, whereas the indices are 0-based, we need to make
    // the index 1-based for this to work. So, instead of (3-Binding->FrameTypeCount), we use
    // (4-Binding->FrameTypeCount). This loop copies all the non-auto-detect frametypes down to
    // the bottom of the array to make space after the last auto-detect frame-type for filling
    // in the frametypes in the preference order.
    //
#if 0
    SlideCount = Binding->FrameTypeCount - AutoDetectLoc - 1;
    for (j = 3; j > 3 - SlideCount; j--) {
        Binding->FrameType[j] = Binding->FrameType[j-(3-Binding->FrameTypeCount)];
        Binding->NetworkNumber[j] = Binding->NetworkNumber[j-(3-Binding->FrameTypeCount)];
        Binding->AutoDetect[j] = Binding->AutoDetect[j-(3-Binding->FrameTypeCount)];
        Binding->DefaultAutoDetect[j] = Binding->DefaultAutoDetect[j-(3-Binding->FrameTypeCount)];
    }
#else
    SlideCount = Binding->FrameTypeCount - AutoDetectLoc - 1;
    for (j = 3; j > 3 - SlideCount; j--) {
        Binding->FrameType[j] = Binding->FrameType[j-(4-Binding->FrameTypeCount)];
        Binding->NetworkNumber[j] = Binding->NetworkNumber[j-(4-Binding->FrameTypeCount)];
        Binding->AutoDetect[j] = Binding->AutoDetect[j-(4-Binding->FrameTypeCount)];
        Binding->DefaultAutoDetect[j] = Binding->DefaultAutoDetect[j-(4-Binding->FrameTypeCount)];
    }
#endif

    //
    // Now fill in any frame types that are not hard-coded,
    // this will start at AutoDetectLoc and exactly fill up
    // the gap created when we slid things up above. We
    // first put the default auto-detect at the first spot.
    //

    if (!FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]]) {
        Binding->FrameType[AutoDetectLoc] = Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT];
        Binding->NetworkNumber[AutoDetectLoc] = 0;
        Binding->AutoDetect[AutoDetectLoc] = TRUE;
        Binding->DefaultAutoDetect[AutoDetectLoc] = TRUE;
        ++AutoDetectLoc;
        FrameTypeUsed[Binding->Parameters[BINDING_DEFAULT_AUTO_DETECT]] = TRUE;
    }

    //
    // Now fill in the array, using the preference order in
    // the BindingPreference array (this comes into effect
    // because the first frame type in our list that we
    // find is used).
    //

    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {

        if (!FrameTypeUsed[BindingPreference[i]]) {
            Binding->FrameType[AutoDetectLoc] = BindingPreference[i];
            Binding->NetworkNumber[AutoDetectLoc] = 0;
            Binding->AutoDetect[AutoDetectLoc] = TRUE;
            Binding->DefaultAutoDetect[AutoDetectLoc] = FALSE;
            ++AutoDetectLoc;
        }
    }

    Binding->FrameTypeCount = ISN_FRAME_TYPE_MAX;

#if DBG
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
       IPX_DEBUG (AUTO_DETECT, ("%d: type %d, net %d, auto %d, default auto detect %d\n",
				i, Binding->FrameType[i], Binding->NetworkNumber[i], Binding->AutoDetect[i], Binding->DefaultAutoDetect[i]));
  }
#endif

    return STATUS_SUCCESS;
} /* IpxPnPGetAdapterParameters */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\adapter.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    adapter.c

Abstract:

    This module contains code which implements the ADAPTER object.
    Routines are provided to reference, and dereference transport
    adapter objects.

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// local function prototypes
//
VOID
IpxDelayedFreeAdapter(
    IN PVOID	Param
);

//********** Pageable Routine Declarations  *****
//************************* PAGEIPX **********************************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEIPX, IpxDelayedFreeAdapter)
#endif
//********** Pageable Routine Declarations *****



//
// These are init only until binding is really dynamic.
//

//
// [FW] So, later we can change this to pnp-compatible value
//

//
// ULONG
// ADAPTER_INDEX_TO_FWCONTEXT(
//    IN ULONG _adapterindex;
// );
//

#define ADAPTER_INDEX_TO_FWCONTEXT(_adapterindex) _adapterindex


VOID
IpxRefBinding(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine increments the reference count on a device context.

Arguments:

    Binding - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    CTEAssert (Binding->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement (&Binding->ReferenceCount);

}   /* IpxRefBinding */


VOID
IpxDerefBinding(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Binding - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;

    result = InterlockedDecrement (&Binding->ReferenceCount);

    CTEAssert (result >= 0);

    if (result == 0) {
        IpxDestroyBinding (Binding);
    }

}   /* IpxDerefBinding */


NTSTATUS
IpxCreateAdapter(
    IN PDEVICE Device,
    IN PUNICODE_STRING AdapterName,
    IN OUT PADAPTER *AdapterPtr
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Adapter - Pointer to a pointer to a transport device context object.

    AdapterName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    PADAPTER Adapter;
#if 0
    UINT i, j;
#endif

    Adapter = (PADAPTER)IpxAllocateMemory (sizeof(ADAPTER) + AdapterName->Length + sizeof(WCHAR), MEMORY_ADAPTER, "Adapter");

    if (Adapter == NULL) {
		if (KeGetCurrentIrql() == 0) {
			IPX_DEBUG (ADAPTER, ("Create adapter %ws failed\n", AdapterName));
		} else {
			IPX_DEBUG (ADAPTER, ("Create adapter %lx failed\n", AdapterName));
		}
		return STATUS_INSUFFICIENT_RESOURCES;
	}

    IPX_DEBUG (ADAPTER, ("Create adapter %lx %lx succeeded\n", Adapter, AdapterName));

    RtlZeroMemory(Adapter, sizeof(ADAPTER));

    //
    // Copy over the adapter name.
    //

    Adapter->AdapterNameLength = AdapterName->Length + sizeof(WCHAR);
    Adapter->AdapterName = (PWCHAR)(Adapter+1);
    RtlCopyMemory(
        Adapter->AdapterName,
        AdapterName->Buffer,
        AdapterName->Length);
    Adapter->AdapterName[AdapterName->Length/sizeof(WCHAR)] = UNICODE_NULL;


#if DBG
    RtlCopyMemory(Adapter->Signature1, "IAD1", 4);
#endif

    Adapter->Type = IPX_ADAPTER_SIGNATURE;
    Adapter->Size = sizeof(ADAPTER);

    CTEInitLock (&Adapter->Lock);

    InitializeListHead (&Adapter->RequestCompletionQueue);

    InitializeListHead (&Adapter->ReceiveBufferPoolList);

    ExInitializeSListHead (&Adapter->ReceiveBufferList);

    Adapter->Device = Device;
    Adapter->DeviceLock = &Device->Lock;
    IpxReferenceDevice (Device, DREF_ADAPTER);

    Adapter->Disabled = ENABLED;                // used iu NDIS_MEDIA_SENSE ...

#if 0
    Adapter->ReceiveBufferPool.Next = NULL;
    for (i = 0; i < ISN_FRAME_TYPE_MAX; i++) {
        Adapter->Bindings[i] = NULL;
    }
    Adapter->BindingCount = 0;

    for (i = 0; i < IDENTIFIER_TOTAL; i++) {
        for (j = 0; j < SOURCE_ROUTE_HASH_SIZE; j++) {
            Adapter->SourceRoutingHeads[i][j] = (PSOURCE_ROUTE)NULL;
        }
    }
#endif

    //
    // For the moment, we have to do the source
    // routing operation on any type where broadcast
    // may not be used for discovery -- improve this
    // hopefully.
    //

    Adapter->SourceRoutingEmpty[IDENTIFIER_RIP] = FALSE;
    Adapter->SourceRoutingEmpty[IDENTIFIER_IPX] = FALSE;
    Adapter->SourceRoutingEmpty[IDENTIFIER_SPX] = FALSE;
    Adapter->SourceRoutingEmpty[IDENTIFIER_NB] = TRUE;

	//
	// Lock here? Added lock. [TC]
	//

    KeInitializeEvent(
        &Adapter->NdisEvent,
        NotificationEvent,
        FALSE
    );

    InterlockedExchange(&(Adapter->ReferenceCount),1);
#if DBG
    InterlockedExchange(&(Adapter->RefTypes[ADAP_REF_CREATE]),1);
#endif
    *AdapterPtr = Adapter;

    return STATUS_SUCCESS;

}   /* IpxCreateAdapter */


VOID
IpxDestroyAdapter(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Adapter - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    ULONG Database, Hash;
    PSOURCE_ROUTE Current;
    ULONG ReceiveBufferPoolSize;
    PIPX_RECEIVE_BUFFER ReceiveBuffer;
    PIPX_RECEIVE_BUFFER_POOL ReceiveBufferPool;
    PDEVICE Device = Adapter->Device;
    PLIST_ENTRY p;
    UINT i;
    PIPX_DELAYED_FREE_ITEM  DelayedFreeItem;

    IPX_DEBUG (ADAPTER, ("Destroy adapter %lx\n", Adapter));

    //
    // Free any receive buffer pools this adapter has.
    //

    ReceiveBufferPoolSize = FIELD_OFFSET (IPX_RECEIVE_BUFFER_POOL, Buffers[0]) +
                       (sizeof(IPX_RECEIVE_BUFFER) * Device->InitReceiveBuffers) +
                       (Adapter->MaxReceivePacketSize * Device->InitReceiveBuffers);

    while (!IsListEmpty (&Adapter->ReceiveBufferPoolList)) {

        p = RemoveHeadList (&Adapter->ReceiveBufferPoolList);
        ReceiveBufferPool = CONTAINING_RECORD (p, IPX_RECEIVE_BUFFER_POOL, Linkage);

        for (i = 0; i < ReceiveBufferPool->BufferCount; i++) {

            ReceiveBuffer = &ReceiveBufferPool->Buffers[i];
            IpxDeinitializeReceiveBuffer (Adapter, ReceiveBuffer, Adapter->MaxReceivePacketSize);

        }

        IPX_DEBUG (PACKET, ("Free buffer pool %lx\n", ReceiveBufferPool));
        IpxFreeMemory (ReceiveBufferPool, ReceiveBufferPoolSize, MEMORY_PACKET, "ReceiveBufferPool");
    }

    //
    // Free all the source routing information for this adapter.
    //

    for (Database = 0; Database < IDENTIFIER_TOTAL; Database++) {

        for (Hash = 0; Hash < SOURCE_ROUTE_HASH_SIZE; Hash++) {

            while (Adapter->SourceRoutingHeads[Database][Hash]) {

                Current = Adapter->SourceRoutingHeads[Database][Hash];
                Adapter->SourceRoutingHeads[Database][Hash] = Current->Next;

                IpxFreeMemory (Current, SOURCE_ROUTE_SIZE (Current->SourceRoutingLength), MEMORY_SOURCE_ROUTE, "SourceRouting");
            }
        }
    }

    //
    // I am moving the following line to the workerthread, so that 
    // the device can go away only after the worker thread completes. [MS]
    //
    // IpxDereferenceDevice (Adapter->Device, DREF_ADAPTER);

    //
    // Free the adapter on a delayed queue so that all
    // the threads inside this would have come out of it.
    // allocate a work item and queue it on a delayed queue.
    //
    DelayedFreeItem = (PIPX_DELAYED_FREE_ITEM)IpxAllocateMemory (
                                        sizeof(IPX_DELAYED_FREE_ITEM),
                                        MEMORY_WORK_ITEM,
                                        "Work Item");
    if ( DelayedFreeItem ) {
        DelayedFreeItem->Context = (PVOID)Adapter;
        DelayedFreeItem->ContextSize = sizeof(ADAPTER) + Adapter->AdapterNameLength;
        ExInitializeWorkItem(
            &DelayedFreeItem->WorkItem,
            IpxDelayedFreeAdapter,
            (PVOID)DelayedFreeItem);

        ExQueueWorkItem(
            &DelayedFreeItem->WorkItem,
            DelayedWorkQueue);

    } else {
        //
        // oh well, tough luck. Just delay this thread and then
        // destroy the adapter.
        //
        LARGE_INTEGER   Delay;
	PDEVICE 	Device; 

        Delay.QuadPart = -10*10000;  // Ten second.
	Device = Adapter->Device; 

        KeDelayExecutionThread(
            KernelMode,
            FALSE,
            &Delay);

        IpxFreeMemory (Adapter, sizeof(ADAPTER) + Adapter->AdapterNameLength, MEMORY_ADAPTER, "Adapter");

	// We need to dereference the adapter in the failure case as well. [TingCai]
	IpxDereferenceDevice (Device, DREF_ADAPTER);
    }

}   /* IpxDestroyAdapter */


VOID
IpxDelayedFreeAdapter(
    IN PVOID	Param
)

/*++

Routine Description:

	This routine frees an adapter on the delayed queue.  We wait long enough
    before freeing an adapter to make sure that no threads are accessing it
    This allows us to access the Adapter without the use of spinlocks.

Arguments:

    Param - pointer to the work item.

Return Value:

    None.

--*/
{
    LARGE_INTEGER   Delay;
    PIPX_DELAYED_FREE_ITEM DelayedFreeItem = (PIPX_DELAYED_FREE_ITEM) Param;
    PADAPTER      Adapter;
    PDEVICE	  Device; 

    Adapter = (PADAPTER) DelayedFreeItem->Context;

    // Keep a pointer, as we need it in IpxDereferenceDevice after we free the memory.[TC]
    Device = Adapter->Device;  


    Delay.QuadPart = -10*10000;  // Ten second.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &Delay);
    
    // IpxFreeMemory needs to access Device structure, so delay the following line
    // to the end of this function. 
    // IpxDereferenceDevice (Adapter->Device, DREF_ADAPTER);

    IpxFreeMemory (
        DelayedFreeItem->Context,
        DelayedFreeItem->ContextSize,
        MEMORY_ADAPTER,
        "Adapter");

    IpxFreeMemory (
        DelayedFreeItem,
        sizeof (IPX_DELAYED_FREE_ITEM),
        MEMORY_WORK_ITEM,
        "Work Item");

    IpxDereferenceDevice (Device, DREF_ADAPTER);

} /* IpxDelayedFreeAdapter */



NTSTATUS
IpxCreateBinding(
    IN PDEVICE Device,
    IN PBINDING_CONFIG ConfigBinding OPTIONAL,
    IN ULONG NetworkNumberIndex,
    IN PWCHAR AdapterName,
    IN OUT PBINDING *BindingPtr
    )

/*++

Routine Description:

    This routine creates and initializes a binding structure.

Arguments:

    Device - The device.

    ConfigBinding - Information about this binding. If this is
        NULL then this is a WAN binding and all the relevant
        information will be filled in by the caller.

    NetworkNumberIndex - The index in the frame type array for
        ConfigBinding indicating which frame type this binding is for.
        Not used if ConfigBinding is not provided.

    AdapterName - Used for error logging.

    BindingPtr - Returns the allocated binding structure.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    PBINDING Binding;
    PSINGLE_LIST_ENTRY s;

    s = IPX_POP_ENTRY_LIST(
            &Device->BindingList,
            &Device->SListsLock);

    if (s != NULL) {
         goto GotBinding;
    }

    //
    // This function tries to allocate another packet pool.
    //

    s = IpxPopBinding(Device);

    //
    // Possibly we should queue the packet up to wait
    // for one to become free.
    //

    if (s == NULL) {

#if DBG
        if (KeGetCurrentIrql() == 0) {
            IPX_DEBUG (ADAPTER, ("Create binding %ws failed\n", AdapterName));
        } else {
            IPX_DEBUG (ADAPTER, ("Create binding WAN failed\n"));
        }
#endif
        return STATUS_INSUFFICIENT_RESOURCES;
    }

GotBinding:

    Binding = CONTAINING_RECORD (s, BINDING, PoolLinkage);


#if DBG
    if (KeGetCurrentIrql() == 0) {
        IPX_DEBUG (ADAPTER, ("Create binding %ws succeeded, %lx\n", AdapterName, Binding));
    } else {
        IPX_DEBUG (ADAPTER, ("Create binding WAN succeeded\n"));
    }
#endif

    RtlZeroMemory(Binding, sizeof(BINDING));

    //
    // Initialize the reference count.
    //

    Binding->ReferenceCount = 1;
#if DBG
    Binding->RefTypes[BREF_BOUND] = 1;
#endif

#if DBG
    RtlCopyMemory(Binding->Signature1, "IBI1", 4);
#endif

    Binding->Type = IPX_BINDING_SIGNATURE;
    Binding->Size = sizeof(BINDING);

    Binding->Device = Device;
    Binding->DeviceLock = &Device->Lock;

    if (ConfigBinding != NULL) {

        ULONG Temp = ConfigBinding->NetworkNumber[NetworkNumberIndex];
        Binding->ConfiguredNetworkNumber = REORDER_ULONG (Temp);

        Binding->AutoDetect = ConfigBinding->AutoDetect[NetworkNumberIndex];
        Binding->DefaultAutoDetect = ConfigBinding->DefaultAutoDetect[NetworkNumberIndex];

        Binding->AllRouteDirected = (BOOLEAN)ConfigBinding->Parameters[BINDING_ALL_ROUTE_DEF];
        Binding->AllRouteBroadcast = (BOOLEAN)ConfigBinding->Parameters[BINDING_ALL_ROUTE_BC];
        Binding->AllRouteMulticast = (BOOLEAN)ConfigBinding->Parameters[BINDING_ALL_ROUTE_MC];

    }

    Binding->ReceiveBroadcast = TRUE;
    IPX_DEBUG(ADAPTER, (" %x set to TRUE\n", Binding));

#if 0
    Binding->BindingSetMember = FALSE;
    Binding->NextBinding = (PBINDING)NULL;
    Binding->DialOutAsync = FALSE;
#endif

    Binding->TdiRegistrationHandle = NULL;
    Binding->fInfoIndicated = FALSE;
    Binding->PastAutoDetection = FALSE;
    //
    // We set Binding->FrameType later, after we can map it based on the
    // media type of the adapter we bind to.
    //

    *BindingPtr = Binding;

    return STATUS_SUCCESS;

}   /* IpxCreateBinding */


VOID
IpxDestroyBinding(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine destroys a binding structure.

Arguments:

    Binding - Pointer to a transport binding structure.

Return Value:

    None.

--*/

{
    IPX_DEBUG (ADAPTER, ("Destroy binding %lx\n", Binding));


    IPX_PUSH_ENTRY_LIST(
        &IpxDevice->BindingList,
        &Binding->PoolLinkage,
        &IpxDevice->SListsLock);

}   /* IpxDestroyBinding */


VOID
IpxAllocateBindingPool(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine adds 10 bindings to the pool for this device.

Arguments:

    Device - The device.

Return Value:

    None.

--*/

{
    PIPX_BINDING_POOL BindingPool;
    UINT BindingPoolSize;
    UINT BindingNum;
    PBINDING Binding;
    CTELockHandle LockHandle;

    BindingPoolSize = FIELD_OFFSET (IPX_BINDING_POOL, Bindings[0]) +
                       (sizeof(BINDING) * Device->InitBindings);

    BindingPool = (PIPX_BINDING_POOL)IpxAllocateMemory (BindingPoolSize, MEMORY_PACKET, "BindingPool");

    if (BindingPool == NULL) {
        IPX_DEBUG (PNP, ("Could not allocate binding pool memory\n"));
        return;
    }


    IPX_DEBUG (PNP, ("Initializing Binding pool %lx, %d bindings\n",
                             BindingPool, Device->InitBindings));

    BindingPool->BindingCount = Device->InitBindings;

    CTEGetLock (&Device->Lock, &LockHandle);

    for (BindingNum = 0; BindingNum < BindingPool->BindingCount; BindingNum++) {

        Binding = &BindingPool->Bindings[BindingNum];
        IPX_PUSH_ENTRY_LIST (&Device->BindingList, &Binding->PoolLinkage, &Device->SListsLock);

#ifdef IPX_TRACK_POOL
        Binding->Pool = BindingPool;
#endif
    }

    InsertTailList (&Device->BindingPoolList, &BindingPool->Linkage);

    Device->AllocatedBindings += BindingPool->BindingCount;

    CTEFreeLock (&Device->Lock, LockHandle);

}   /* IpxAllocateBindingPool */


PSINGLE_LIST_ENTRY
IpxPopBinding(
    PDEVICE Device
    )

/*++

Routine Description:

    This routine allocates a binding from the device context's pool.
    If there are no bindings in the pool, it allocates one up to
    the configured limit.

Arguments:

    Device - Pointer to our device to charge the packet to.

Return Value:

    The pointer to the Linkage field in the allocated binding.

--*/

{
    PSINGLE_LIST_ENTRY s;

    s = IPX_POP_ENTRY_LIST(
            &Device->BindingList,
            &Device->SListsLock);

    if (s != NULL) {
        return s;
    }

    //
    // No packets in the pool, see if we can allocate more.
    //

    if (Device->AllocatedBindings < Device->MaxPoolBindings) {

        //
        // Allocate a pool and try again.
        //

        IpxAllocateBindingPool (Device);
        s = IPX_POP_ENTRY_LIST(
                &Device->BindingList,
                &Device->SListsLock);

        return s;

    } else {

        return NULL;

    }

}   /* IpxPopBinding */

//
// [FW]
//
#ifdef SUNDOWN
NTSTATUS
IpxOpenAdapter(
   IN    NIC_HANDLE  AdapterIndex1,
   IN    ULONG_PTR   FwdAdapterContext,
   OUT   PNIC_HANDLE IpxAdapterContext
   )
#else
NTSTATUS
IpxOpenAdapter(
   IN    NIC_HANDLE  AdapterIndex1,
   IN    ULONG       FwdAdapterContext,
   OUT   PNIC_HANDLE IpxAdapterContext
   )
#endif



/*++

Routine Description:

   This routine is called by the Kernel Forwarder to open an adapter

Arguments:

   AdapterIndex - index of the adapter to open (NICid for now - will change to a struct
                  with a version number, signature and the NicId
   FwdAdapterContext - Forwarder's context
   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version #)

Return Value:

   STATUS_INVALID_HANDLE   if the AdapterIndex handle was invalid
   STATUS_ADAPTER_ALREADY_OPENED    if the Adapter is being opened a second time
   STATUS_SUCCESS

--*/

{
   PBINDING Binding;
   PDEVICE  Device = IpxDevice;
   USHORT   AdapterIndex = AdapterIndex1.NicId;

   IPX_DEBUG(ADAPTER, ("IPX: Entered IpxOpenAdapter\n"));

   //
   // Return error if the AdapterIndex is out of range.
   // We do indicate the slave bindings to NB/SPX (but not to RIP)
   // Hence, the index should be less than  HighestExternalNicId (not ValidBindings)
   //

   if (AdapterIndex > Device->HighestExternalNicId) {
      return STATUS_INVALID_HANDLE;
   }


   //
   // Fill up our context to be returned to the Forwarder
   //
   NIC_HANDLE_FROM_NIC((*IpxAdapterContext), AdapterIndex);

   //
   // If AdapterIndex is 0, it is for the virtual net
   // Will the forwarder open this at all?
   //

   if (AdapterIndex == 0) {
      return STATUS_SUCCESS;
   }

   //
   // Get the binding pointer
   //

   Binding = NIC_ID_TO_BINDING(IpxDevice, AdapterIndex);

   if (Binding == NULL) {
      return STATUS_INVALID_HANDLE; 
   }

   //
   // Return error if adapter is being opened a second time (or more times)
   //

   if (GET_LONG_VALUE(Binding->ReferenceCount) >= 2) {
      return STATUS_ADAPTER_ALREADY_OPENED;
   }

   //
   // Store the Forwarder's Adapter Context in the binding
   //

   Binding->FwdAdapterContext = FwdAdapterContext;

   //
   // Reference the Binding
   //

   IpxReferenceBinding(Binding, BREF_FWDOPEN);

   return STATUS_SUCCESS;

}

NTSTATUS
IpxCloseAdapter(
   IN NIC_HANDLE  IpxAdapterContext
   )

/*++

Routine Description:

   This routine is called by the Kernel Forwarder to close an adapter

Arguments:

   IpxAdapterContext - our context (for now we use the NICid - for pnp will change
                       this to contain a signature and version#)

Return Value:

   STATUS_ADAPTER_ALREADY_CLOSED - if the adapter is being closed a second time
   STATUS_SUCCESS

--*/

{

   PBINDING Binding;

   IPX_DEBUG(ADAPTER, ("IPX: Entered IpxCloseAdapter\n"));

   Binding = NIC_ID_TO_BINDING(IpxDevice, IpxAdapterContext.NicId);

   if (Binding == NULL) {
      ASSERT(FALSE); 
      return  STATUS_UNSUCCESSFUL; 
   }
   //
   // Either the adapter is around (count = 2)
   // or it went away (count = 1). The latter cannot happen now.
   //

   if (GET_LONG_VALUE(Binding->ReferenceCount) <= 1) {
      return STATUS_ADAPTER_ALREADY_CLOSED;
   }

   //
   // Dereference the Binding so it can be deleted
   //

   IpxDereferenceBinding(Binding, BREF_FWDOPEN);


   //
   // Clear the Forwarder's Adapter Context in the binding
   //

   Binding->FwdAdapterContext = 0;

   return STATUS_SUCCESS;
}


VOID
IpxRefAdapter(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine increments the reference count on a adapter context.

Arguments:

    Adapter - Pointer to a transport adapter context object.

Return Value:

    none.

--*/

{
    CTEAssert (Adapter->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement(&Adapter->ReferenceCount);

}   /* IpxRefAdapter */


VOID
IpxDerefAdapter(
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine dereferences a adapter context by decrementing the
    reference count contained in the structure.  

Arguments:

    Adapter - Pointer to a transport adapter context object.

Return Value:

    none.

--*/

{
    LONG result;


    result = InterlockedDecrement (&Adapter->ReferenceCount);

    CTEAssert (result >= 0);

    if (result == 0) {
       KeSetEvent(&Adapter->NdisEvent, 0L, FALSE); 
    }

}   /* IpxDerefAdapter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\action.c ===
/*++
Copyright (c) 1989-1993 Microsoft Corporation

Module Name:

    action.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiAction

Environment:

    Kernel mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <packon.h>

//
// Line ups when indicated up should have this length subtracted from the
// max. send size that ndis indicated to us for the line
//
#define HDR_LEN_802_3                14
#define ASYNC_MEDIUM_HDR_LEN         HDR_LEN_802_3

typedef struct _GET_PKT_SIZE {
    ULONG Unknown;
    ULONG MaxDatagramSize;
} GET_PKT_SIZE, *PGET_PKT_SIZE;


//
// These structures are used to set and query information
// about our source routing table.
//

typedef struct _SR_GET_PARAMETERS {
    ULONG BoardNumber;    // 0-based
    ULONG SrDefault;      // 0 = single route, 1 = all routes
    ULONG SrBroadcast;
    ULONG SrMulticast;
} SR_GET_PARAMETERS, *PSR_GET_PARAMETERS;

typedef struct _SR_SET_PARAMETER {
    ULONG BoardNumber;    // 0-based
    ULONG Parameter;      // 0 = single route, 1 = all routes
} SR_SET_PARAMETER, *PSR_SET_PARAMETER;

typedef struct _SR_SET_REMOVE {
    ULONG BoardNumber;    // 0-based
    UCHAR MacAddress[6];  // remote to drop routing for
} SR_SET_REMOVE, *PSR_SET_REMOVE;

typedef struct _SR_SET_CLEAR {
    ULONG BoardNumber;    // 0-based
} SR_SET_CLEAR, *PSR_SET_CLEAR;

#include <packoff.h>

NTSTATUS
IpxTdiAction(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiAction request for the transport
    provider.

Arguments:

    Device - The device for the operation.

    Request - Describes the action request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    PADDRESS_FILE AddressFile;
    UINT BufferLength;
    UINT DataLength;
    PNDIS_BUFFER NdisBuffer;
    CTELockHandle LockHandle;
    PBINDING Binding, MasterBinding;
    PADAPTER Adapter;
    union {
        PISN_ACTION_GET_LOCAL_TARGET GetLocalTarget;
        PISN_ACTION_GET_NETWORK_INFO GetNetworkInfo;
        PISN_ACTION_GET_DETAILS GetDetails;
        PSR_GET_PARAMETERS GetSrParameters;
        PSR_SET_PARAMETER SetSrParameter;
        PSR_SET_REMOVE SetSrRemove;
        PSR_SET_CLEAR SetSrClear;
        PIPX_ADDRESS_DATA IpxAddressData;
        PGET_PKT_SIZE GetPktSize;
        PIPX_NETNUM_DATA IpxNetnumData;
        PIPX_QUERY_WAN_INACTIVITY   QueryWanInactivity;
        PIPXWAN_CONFIG_DONE IpxwanConfigDone;
    } u;    // Make these unaligned??
    PIPX_ROUTE_ENTRY RouteEntry;
    PNWLINK_ACTION NwlinkAction;
    ULONG Segment;
    ULONG AdapterNum;
    static UCHAR BogusId[4] = { 0x01, 0x00, 0x00, 0x00 };   // old nwrdr uses this
    IPX_FIND_ROUTE_REQUEST routeEntry;

	IPX_DEFINE_LOCK_HANDLE(LockHandle1)

    //
    // To maintain some compatibility with the NWLINK streams-
    // based transport, we use the streams header format for
    // our actions. The old transport expected the action header
    // to be in InputBuffer and the output to go in OutputBuffer.
    // We follow the TDI spec, which states that OutputBuffer
    // is used for both input and output. Since IOCTL_TDI_ACTION
    // is method out direct, this means that the output buffer
    // is mapped by the MDL chain; for action the chain will
    // only have one piece so we use it for input and output.
    //

    NdisBuffer = REQUEST_NDIS_BUFFER(Request);
    if (NdisBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, NormalPagePriority);

    if (NwlinkAction == NULL) {
       return STATUS_INSUFFICIENT_RESOURCES; 
    } 

    //
    // Make sure we have enough room for just the header not
    // including the data.
    //

    if (BufferLength < (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]))) {
        IPX_DEBUG (ACTION, ("Nwlink action failed, buffer too small\n"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    if ((!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), "MISN", 4)) &&
        (!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), "MIPX", 4)) &&
        (!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), "XPIM", 4)) &&
        (!RtlEqualMemory ((PVOID) (UNALIGNED ULONG *) (&NwlinkAction->Header.TransportId), BogusId, 4))) {

        return STATUS_NOT_SUPPORTED;
    }

    DataLength = BufferLength - FIELD_OFFSET(NWLINK_ACTION, Data[0]);


    //
    // Make sure that the correct file object is being used.
    //

    if (NwlinkAction->OptionType == NWLINK_OPTION_ADDRESS) {

        if (REQUEST_OPEN_TYPE(Request) != (PVOID)TDI_TRANSPORT_ADDRESS_FILE) {
            IPX_DEBUG (ACTION, ("Nwlink action failed, not address file\n"));
            return STATUS_INVALID_HANDLE;
        }

        AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

        if ((AddressFile->Size != sizeof (ADDRESS_FILE)) ||
            (AddressFile->Type != IPX_ADDRESSFILE_SIGNATURE)) {

            IPX_DEBUG (ACTION, ("Nwlink action failed, bad address file\n"));
            return STATUS_INVALID_HANDLE;
        }

    } else if (NwlinkAction->OptionType != NWLINK_OPTION_CONTROL) {

        IPX_DEBUG (ACTION, ("Nwlink action failed, option type %d\n", NwlinkAction->OptionType));
        return STATUS_NOT_SUPPORTED;
    }


    //
    // Handle the requests based on the action code. For these
    // requests ActionHeader->ActionCode is 0, we use the
    // Option field in the streams header instead.
    //


    Status = STATUS_SUCCESS;

    switch (NwlinkAction->Option) {

       IPX_DEBUG (ACTION, ("NwlinkAction->Option is (%x)\n", NwlinkAction->Option));
    //DbgPrint("NwlinkAction->Option is (%x)\n", NwlinkAction->Option);
    //
    // This first group support the winsock helper dll.
    // In most cases the corresponding sockopt is shown in
    // the comment, as well as the contents of the Data
    // part of the action buffer.
    //

    case MIPX_SETSENDPTYPE:

        //
        // IPX_PTYPE: Data is a single byte packet type.
        //

        if (DataLength >= 1) {
            IPX_DEBUG (ACTION, ("%lx: MIPX_SETSENDPTYPE %x\n", AddressFile, NwlinkAction->Data[0]));
            AddressFile->DefaultPacketType = NwlinkAction->Data[0];
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_FILTERPTYPE:

        //
        // IPX_FILTERPTYPE: Data is a single byte to filter on.
        //

        if (DataLength >= 1) {
            IPX_DEBUG (ACTION, ("%lx: MIPX_FILTERPTYPE %x\n", AddressFile, NwlinkAction->Data[0]));
            AddressFile->FilteredType = NwlinkAction->Data[0];
            AddressFile->FilterOnPacketType = TRUE;
            AddressFile->SpecialReceiveProcessing = TRUE;
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_NOFILTERPTYPE:

        //
        // IPX_STOPFILTERPTYPE.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOFILTERPTYPE\n", AddressFile));
        AddressFile->FilterOnPacketType = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ExtendedAddressing || AddressFile->ReceiveFlagsAddressing ||
            AddressFile->ReceiveIpxHeader || AddressFile->IsSapSocket);
        break;

    case MIPX_SENDADDROPT:

        //
        // IPX_EXTENDED_ADDRESS (TRUE).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SENDADDROPT\n", AddressFile));
        AddressFile->ExtendedAddressing = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NOSENDADDROPT:

        //
        // IPX_EXTENDED_ADDRESS (FALSE).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOSENDADDROPT\n", AddressFile));
        AddressFile->ExtendedAddressing = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ReceiveFlagsAddressing || AddressFile->ReceiveIpxHeader ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket);
        break;

#if 0
    case MIPX_SETNIC:

        //
        // IPX_NIC_ADDRESS TRUE
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SETNIC\n", AddressFile));
        AddressFile->NicAddressing            = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NOSETNIC:

        //
        // IPX_NIC_ADDRESS (FALSE).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOSETNIC\n", AddressFile));
        AddressFile->NicAddressing = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ReceiveFlagsAddressing ||
                    AddressFile->ReceiveIpxHeader ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket ||
             AddressFile->NicAddressing);
        break;
#endif

    case MIPX_SETRCVFLAGS:

        //
        // No sockopt yet.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SETRCVFLAGS\n", AddressFile));
        AddressFile->ReceiveFlagsAddressing = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NORCVFLAGS:

        //
        // No sockopt yet.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NORCVFLAGS\n", AddressFile));
        AddressFile->ReceiveFlagsAddressing = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ExtendedAddressing || AddressFile->ReceiveIpxHeader ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket);
        break;

    case MIPX_SENDHEADER:

        //
        // IPX_RECVHDR (TRUE);
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_SENDHEADER\n", AddressFile));
        AddressFile->ReceiveIpxHeader = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
        break;

    case MIPX_NOSENDHEADER:

        //
        // IPX_RECVHDR (FALSE);
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOSENDHEADER\n", AddressFile));
        AddressFile->ReceiveIpxHeader = FALSE;
        AddressFile->SpecialReceiveProcessing = (BOOLEAN)
            (AddressFile->ExtendedAddressing || AddressFile->ReceiveFlagsAddressing ||
            AddressFile->FilterOnPacketType || AddressFile->IsSapSocket);
        break;

    case MIPX_RCVBCAST:

        //
        // Broadcast reception enabled.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_RCVBCAST\n", AddressFile));
        
        //
        // It's enabled by default now
        // 
        /*

        CTEGetLock (&Device->Lock, &LockHandle);

        if (!AddressFile->EnableBroadcast) {

            AddressFile->EnableBroadcast = TRUE;
            IpxAddBroadcast (Device);
        }

        CTEFreeLock (&Device->Lock, LockHandle);
        */
        break;

    case MIPX_NORCVBCAST:

        //
        // Broadcast reception disabled.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NORCVBCAST\n", AddressFile));
        //
        // It's enabled by default now
        // 
        /*

        CTEGetLock (&Device->Lock, &LockHandle);

        if (AddressFile->EnableBroadcast) {

            AddressFile->EnableBroadcast = FALSE;
            IpxRemoveBroadcast (Device);
        }

        CTEFreeLock (&Device->Lock, LockHandle);
        */
        break;

    case MIPX_GETPKTSIZE:

        //
        // IPX_MAXSIZE.
        //
        // Figure out what the first length is for.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_GETPKTSIZE\n", AddressFile));
        if (DataLength >= sizeof(GET_PKT_SIZE)) {
            u.GetPktSize = (PGET_PKT_SIZE)(NwlinkAction->Data);
            u.GetPktSize->Unknown = 0;
            u.GetPktSize->MaxDatagramSize = Device->Information.MaxDatagramSize;
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_ADAPTERNUM:

        //
        // IPX_MAX_ADAPTER_NUM.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_ADAPTERNUM\n", AddressFile));
        if (DataLength >= sizeof(ULONG)) {
            *(UNALIGNED ULONG *)(NwlinkAction->Data) = Device->SapNicCount;
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_ADAPTERNUM2:

        //
        // IPX_MAX_ADAPTER_NUM.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_ADAPTERNUM2\n", AddressFile));
        if (DataLength >= sizeof(ULONG)) {
            *(UNALIGNED ULONG *)(NwlinkAction->Data) = MIN (Device->MaxBindings, Device->ValidBindings);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case MIPX_GETCARDINFO:
    case MIPX_GETCARDINFO2:

        //
        // GETCARDINFO is IPX_ADDRESS.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_GETCARDINFO (%d)\n",
                    AddressFile, *(UNALIGNED UINT *)NwlinkAction->Data));
        if (DataLength >= sizeof(IPX_ADDRESS_DATA)) {
            u.IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);
            AdapterNum = u.IpxAddressData->adapternum+1;

            if (((AdapterNum >= 1) && (AdapterNum <= Device->SapNicCount)) ||
                ((NwlinkAction->Option == MIPX_GETCARDINFO2) && (AdapterNum <= (ULONG) MIN (Device->MaxBindings, Device->ValidBindings)))) {

// Get lock
				IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                Binding = NIC_ID_TO_BINDING(Device, AdapterNum);
                if (Binding == NULL) {

                    //
                    // This should be a binding in the WAN range
                    // of an adapter which is currently not
                    // allocated. We scan back to the previous
                    // non-NULL binding, which should be on the
                    // same adapter, and return a down line with
                    // the same characteristics as that binding.
                    //

                    UINT i = AdapterNum;

                    do {
                        --i;
                        Binding = NIC_ID_TO_BINDING(Device, i);
                    } while (Binding == NULL);

                    //CTEAssert (Binding->Adapter->MacInfo.MediumAsync);
                    //CTEAssert (i >= Binding->Adapter->FirstWanNicId);
                    //CTEAssert (AdapterNum <= Binding->Adapter->LastWanNicId);
                    // take out assertion because srv might have gotten the number
                    // of adapters before we finished bindadapters.

                    u.IpxAddressData->status = FALSE;
                    *(UNALIGNED ULONG *)u.IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;

                } else {

                    if ((Binding->Adapter->MacInfo.MediumAsync) &&
                        (Device->WanGlobalNetworkNumber)) {

                        //
                        // In this case we make it look like one big wan
                        // net, so the line is "up" or "down" depending
                        // on whether we have given him the first indication
                        // or not.
                        //

                        u.IpxAddressData->status = Device->GlobalNetworkIndicated;
                        *(UNALIGNED ULONG *)u.IpxAddressData->netnum = Device->GlobalWanNetwork;

                    } else {
#ifdef SUNDOWN
			      u.IpxAddressData->status = (unsigned char) Binding->LineUp;
#else
			      u.IpxAddressData->status = Binding->LineUp;
#endif

                       
                        *(UNALIGNED ULONG *)u.IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
                    }

                }

                RtlCopyMemory(u.IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);

                Adapter = Binding->Adapter;
                u.IpxAddressData->wan = Adapter->MacInfo.MediumAsync;
                u.IpxAddressData->maxpkt =
                    (NwlinkAction->Option == MIPX_GETCARDINFO) ?
                        Binding->AnnouncedMaxDatagramSize :
                        Binding->RealMaxDatagramSize;
                u.IpxAddressData->linkspeed = Binding->MediumSpeed;
			   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            } else {

                Status = STATUS_INVALID_PARAMETER;
            }

        } else {
#if 1
            //
            // Support the old format query for now.
            //

            typedef struct _IPX_OLD_ADDRESS_DATA {
                UINT adapternum;
                UCHAR netnum[4];
                UCHAR nodenum[6];
            } IPX_OLD_ADDRESS_DATA, *PIPX_OLD_ADDRESS_DATA;

            if (DataLength >= sizeof(IPX_OLD_ADDRESS_DATA)) {
                u.IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);
                AdapterNum = u.IpxAddressData->adapternum+1;

                if ((AdapterNum >= 1) && (AdapterNum <= Device->SapNicCount)) {
					IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
					if (Binding = NIC_ID_TO_BINDING(Device, AdapterNum)) {
						*(UNALIGNED ULONG *)u.IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
						RtlCopyMemory(u.IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);
					} else {
						Status = STATUS_INVALID_PARAMETER;
					}
					IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
               } else {
                    Status = STATUS_INVALID_PARAMETER;
               }
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
#else
            Status = STATUS_BUFFER_TOO_SMALL;
#endif
        }
        break;

    case MIPX_NOTIFYCARDINFO:

        //
        // IPX_ADDRESS_NOTIFY.
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_NOTIFYCARDINFO (%lx)\n", AddressFile, Request));

        CTEGetLock (&Device->Lock, &LockHandle);

        //
        // If the device is open and there is room in the
        // buffer for the data, insert it in our queue.
        // It will be completed when a change happens or
        // the driver is unloaded.
        //

        if (Device->State == DEVICE_STATE_OPEN) {
            if (DataLength >= sizeof(IPX_ADDRESS_DATA)) {
                InsertTailList(
                    &Device->AddressNotifyQueue,
                    REQUEST_LINKAGE(Request)
                );
                IoSetCancelRoutine (Request, IpxCancelAction);

		// If IO Manager calls the cancel routine, then it will
		// set the cancel routine to be NULL. 
		// IoSetCancelRoutine returns the previous cancel 
		// routine, if the return value is null, then IO Manager
		// has called the cancel routine. If not null, then 
		// the cancel routine has not been called and the irp 
		// was canceled before we set the cancel routine. 

                if (Request->Cancel && 
		    IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL) != NULL) {

                    (VOID)RemoveTailList (&Device->AddressNotifyQueue);
                    Status = STATUS_CANCELLED;
                
		} else {
                    IpxReferenceDevice (Device, DREF_ADDRESS_NOTIFY);
                    Status = STATUS_PENDING;
                }
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        } else {
            Status = STATUS_DEVICE_NOT_READY;
        }

        CTEFreeLock (&Device->Lock, LockHandle);

        break;

    case MIPX_LINECHANGE:

        //
        // IPX_ADDRESS_NOTIFY.
        //

        IPX_DEBUG (ACTION, ("MIPX_LINECHANGE (%lx)\n", Request));

        CTEGetLock (&Device->Lock, &LockHandle);

        //
        // If the device is open and there is room in the
        // buffer for the data, insert it in our queue.
        // It will be completed when a change happens or
        // the driver is unloaded.
        //

        if (Device->State == DEVICE_STATE_OPEN) {

            InsertTailList(
                &Device->LineChangeQueue,
                REQUEST_LINKAGE(Request)
            );

            IoSetCancelRoutine (Request, IpxCancelAction);
            if (Request->Cancel && 
		IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL) != NULL) {

                (VOID)RemoveTailList (&Device->LineChangeQueue);
                Status = STATUS_CANCELLED;
            
	    } else {
                IpxReferenceDevice (Device, DREF_LINE_CHANGE);
                Status = STATUS_PENDING;
            }
        } else {
            Status = STATUS_DEVICE_NOT_READY;
        }

        CTEFreeLock (&Device->Lock, LockHandle);

        break;

    case MIPX_GETNETINFO_NR:

        //
        // A request for network information about the immediate
        // route to a network (this is called by sockets apps).
        //

        if (DataLength < sizeof(IPX_NETNUM_DATA)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.IpxNetnumData = (PIPX_NETNUM_DATA)(NwlinkAction->Data);

        //
        // A query on network 0 means that the caller wants
        // information about our directly attached net.
        //

        if (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum == 0) {

            //
            // The tick count is the number of 1/18.21 second ticks
            // it takes to deliver a 576-byte packet. Our link speed
            // is in 100 bit-per-second units. We calculate it as
            // follows (LS is the LinkSpeed):
            //
            // 576 bytes   8 bits       1 second     1821 ticks
            //           * ------  * ------------- * ----------
            //             1 byte    LS * 100 bits   100 seconds
            //
            // which becomes 839 / LinkSpeed -- we add LinkSpeed
            // to the top to round up.
            //

            if (Device->LinkSpeed == 0) {
                u.IpxNetnumData->netdelay = 16;
            } else {
                u.IpxNetnumData->netdelay = (USHORT)((839 + Device->LinkSpeed) /
                                                         (Device->LinkSpeed));
            }
            u.IpxNetnumData->hopcount = 0;
            u.IpxNetnumData->cardnum = 0;
            RtlMoveMemory (u.IpxNetnumData->router, Device->SourceAddress.NodeAddress, 6);

        } else {


            if (Device->ForwarderBound) {
                //
                // [FW] Call the Forwarder's FindRoute if installed
                //

                //
                // What about the node number here?
                //
                Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                 u.IpxNetnumData->netnum,
                                 NULL,  // FindRouteRequest->Node,
                                 &routeEntry);

                if (Status != STATUS_SUCCESS) {
                   IPX_DEBUG (ACTION, (" MIPX_GETNETINFO_NR failed net %lx",
                              REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                   Status = STATUS_BAD_NETWORK_PATH;
                } else {
                   //
                   // Fill in the information
                   //
                   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                   if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                      u.IpxNetnumData->hopcount = routeEntry.HopCount;
                      u.IpxNetnumData->netdelay = routeEntry.TickCount;
                      if (Binding->BindingSetMember) {
                         u.IpxNetnumData->cardnum = (INT)(Binding->MasterBinding->NicId - 1);
                      } else {
                         u.IpxNetnumData->cardnum = (INT)(routeEntry.LocalTarget.NicId - 1);
                      }

                      // RtlMoveMemory (u.IpxNetnumData->router, routeEntry.LocalTarget.MacAddress, 6);

                      *((UNALIGNED ULONG *)u.IpxNetnumData->router) =
                            *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                      *((UNALIGNED ULONG *)(u.IpxNetnumData->router+4)) =
                            *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
                   }
                   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }


            } else {
                Segment = RipGetSegment(u.IpxNetnumData->netnum);

                //
                // To maintain the lock order: BindAccessLock > RIP table
                //
                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, u.IpxNetnumData->netnum);
                if ((RouteEntry != NULL) &&
                    (Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId))) {

                    u.IpxNetnumData->hopcount = RouteEntry->HopCount;
                    u.IpxNetnumData->netdelay = RouteEntry->TickCount;
                    if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(MIN (Device->MaxBindings, Binding->MasterBinding->NicId) - 1);
                    } else {
                        u.IpxNetnumData->cardnum = (INT)(RouteEntry->NicId - 1);
                    }
                    RtlMoveMemory (u.IpxNetnumData->router, RouteEntry->NextRouter, 6);

                } else {

                    //
                    // Fail the call, we don't have a route yet.
                    //

                    IPX_DEBUG (ACTION, ("MIPX_GETNETINFO_NR failed net %lx\n",
                        REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                    Status = STATUS_BAD_NETWORK_PATH;

                }
                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
             }

        }

        break;

    case MIPX_RERIPNETNUM:

        //
        // We dont really support Re-RIP in the case of Forwarder above us
        //

        //
        // A request for network information about the immediate
        // route to a network (this is called by sockets apps).
        //

        if (DataLength < sizeof(IPX_NETNUM_DATA)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.IpxNetnumData = (PIPX_NETNUM_DATA)(NwlinkAction->Data);

        //
        // Allow net 0 queries??
        //

        if (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum == 0) {

            if (Device->LinkSpeed == 0) {
                u.IpxNetnumData->netdelay = 16;
            } else {
                u.IpxNetnumData->netdelay = (USHORT)((839 + Device->LinkSpeed) /
                                                         (Device->LinkSpeed));
            }
            u.IpxNetnumData->hopcount = 0;
            u.IpxNetnumData->cardnum = 0;
            RtlMoveMemory (u.IpxNetnumData->router, Device->SourceAddress.NodeAddress, 6);

        } else {


             if (Device->ForwarderBound) {

                //
                // [FW] Call the Forwarder's FindRoute if installed
                //

                //
                // What about the node number here?
                //
                Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                 u.IpxNetnumData->netnum,
                                 NULL,  // FindRouteRequest->Node,
                                 &routeEntry);

                if (Status != STATUS_SUCCESS) {
                   IPX_DEBUG (ACTION, (" MIPX_RERIPNETNUM failed net %lx",
                              REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                   Status = STATUS_BAD_NETWORK_PATH;
                } else {
                   //
                   // Fill in the information
                   //
    			   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                   if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                      u.IpxNetnumData->hopcount = routeEntry.HopCount;
                      u.IpxNetnumData->netdelay = routeEntry.TickCount;
                      if (Binding->BindingSetMember) {
                         u.IpxNetnumData->cardnum = (INT)(Binding->MasterBinding->NicId - 1);
                      } else {
                         u.IpxNetnumData->cardnum = (INT)(routeEntry.LocalTarget.NicId - 1);
                      }

                      // RtlMoveMemory (u.IpxNetnumData->router, routeEntry.LocalTarget.MacAddress, 6);

                      *((UNALIGNED ULONG *)u.IpxNetnumData->router) =
                            *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                      *((UNALIGNED ULONG *)(u.IpxNetnumData->router+4)) =
                            *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
                   }
    			    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }

             } else {
                Segment = RipGetSegment(u.IpxNetnumData->netnum);
    			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, u.IpxNetnumData->netnum);

                if ((RouteEntry != NULL) &&
                    (Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId)) &&
                    (RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY)) {

                    u.IpxNetnumData->hopcount = RouteEntry->HopCount;
                    u.IpxNetnumData->netdelay = RouteEntry->TickCount;

                    if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(MIN (Device->MaxBindings, Binding->MasterBinding->NicId) - 1);
                    } else {
                        u.IpxNetnumData->cardnum = (INT)(RouteEntry->NicId - 1);
                    }
                    RtlMoveMemory (u.IpxNetnumData->router, RouteEntry->NextRouter, 6);

                } else {

                    //
                    // This call will return STATUS_PENDING if we successfully
                    // queue a RIP request for the packet.
                    //

                    Status = RipQueueRequest (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum, RIP_REQUEST);
                    CTEAssert (Status != STATUS_SUCCESS);

                    if (Status == STATUS_PENDING) {

                        //
                        // A RIP request went out on the network; we queue
                        // this request for completion when the RIP response
                        // arrives. We save the network in the information
                        // field for easier retrieval later.
                        //
#ifdef SUNDOWN
						REQUEST_INFORMATION(Request) = (ULONG_PTR)u.IpxNetnumData;
#else
						REQUEST_INFORMATION(Request) = (ULONG)u.IpxNetnumData;
#endif

                        
                        InsertTailList(
                            &Device->Segments[Segment].WaitingReripNetnum,
                            REQUEST_LINKAGE(Request));

                        IPX_DEBUG (ACTION, ("MIPX_RERIPNETNUM queued net %lx\n",
                            REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));

                    }

                }

                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        }

        break;

    case MIPX_GETNETINFO:

        //
        // A request for network information about the immediate
        // route to a network (this is called by sockets apps).
        //

        if (DataLength < sizeof(IPX_NETNUM_DATA)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.IpxNetnumData = (PIPX_NETNUM_DATA)(NwlinkAction->Data);

        //
        // Allow net 0 queries??
        //

        if (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum == 0) {

            if (Device->LinkSpeed == 0) {
                u.IpxNetnumData->netdelay = 16;
            } else {
                u.IpxNetnumData->netdelay = (USHORT)((839 + Device->LinkSpeed) /
                                                         (Device->LinkSpeed));
            }
            u.IpxNetnumData->hopcount = 0;
            u.IpxNetnumData->cardnum = 0;
            RtlMoveMemory (u.IpxNetnumData->router, Device->SourceAddress.NodeAddress, 6);

        } else {


            if (Device->ForwarderBound) {

               //
               // [FW] Call the Forwarder's FindRoute if installed
               //

               //
               // What about the node number here?
               //
               Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                u.IpxNetnumData->netnum,
                                NULL,  // FindRouteRequest->Node,
                                &routeEntry);

               if (Status != STATUS_SUCCESS) {
                  IPX_DEBUG (ACTION, (" MIPX_GETNETINFO failed net %lx",
                             REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));
                  Status = STATUS_BAD_NETWORK_PATH;
               } else {
                  //
                  // Fill in the information
                  //
    			  IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

                  if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                     u.IpxNetnumData->hopcount = routeEntry.HopCount;
                     u.IpxNetnumData->netdelay = routeEntry.TickCount;
                     if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(Binding->MasterBinding->NicId - 1);
                     } else {
                        u.IpxNetnumData->cardnum = (INT)(routeEntry.LocalTarget.NicId - 1);
                     }

                     // RtlMoveMemory (u.IpxNetnumData->router, routeEntry.LocalTarget.MacAddress, 6);

                     *((UNALIGNED ULONG *)u.IpxNetnumData->router) =
                           *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                     *((UNALIGNED ULONG *)(u.IpxNetnumData->router+4)) =
                           *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
                  }

    			  IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
               }
            } else {
                Segment = RipGetSegment(u.IpxNetnumData->netnum);
    			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, u.IpxNetnumData->netnum);

                if ((RouteEntry != NULL) &&
                    (Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId))) {

                    u.IpxNetnumData->hopcount = RouteEntry->HopCount;
                    u.IpxNetnumData->netdelay = RouteEntry->TickCount;

                    if (Binding->BindingSetMember) {
                        u.IpxNetnumData->cardnum = (INT)(MIN (Device->MaxBindings, Binding->MasterBinding->NicId) - 1);
                    } else {
                        u.IpxNetnumData->cardnum = (INT)(RouteEntry->NicId - 1);
                    }
                    RtlMoveMemory (u.IpxNetnumData->router, RouteEntry->NextRouter, 6);

                } else {

                    //
                    // This call will return STATUS_PENDING if we successfully
                    // queue a RIP request for the packet.
                    //

                    Status = RipQueueRequest (*(UNALIGNED ULONG *)u.IpxNetnumData->netnum, RIP_REQUEST);
                    CTEAssert (Status != STATUS_SUCCESS);

                    if (Status == STATUS_PENDING) {

                        //
                        // A RIP request went out on the network; we queue
                        // this request for completion when the RIP response
                        // arrives. We save the network in the information
                        // field for easier retrieval later.
                        //
#ifdef SUNDOWN
						REQUEST_INFORMATION(Request) = (ULONG_PTR)u.IpxNetnumData;
#else
						REQUEST_INFORMATION(Request) = (ULONG)u.IpxNetnumData;
#endif

                        
                        InsertTailList(
                            &Device->Segments[Segment].WaitingReripNetnum,
                            REQUEST_LINKAGE(Request));

                        IPX_DEBUG (ACTION, ("MIPX_GETNETINFO queued net %lx\n",
                            REORDER_ULONG(*(UNALIGNED ULONG *)(u.IpxNetnumData->netnum))));

                    }

                }

                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        }

        break;

    case MIPX_SENDPTYPE:
    case MIPX_NOSENDPTYPE:

        //
        // For the moment just use OptionsLength >= 1 to indicate
        // that the send options include the packet type.
        //
        // Do we need to worry about card num being there?
        //

#if 0
        IPX_DEBUG (ACTION, ("%lx: MIPS_%sSENDPTYPE\n", AddressFile,
                        NwlinkAction->Option == MIPX_SENDPTYPE ? "" : "NO"));
#endif
        break;

    case MIPX_ZEROSOCKET:

        //
        // Sends from this address should be from socket 0;
        // This is done the simple way by just putting the
        // information in the address itself, instead of
        // making it per address file (this is OK since
        // this call is not exposed through winsock).
        //

        IPX_DEBUG (ACTION, ("%lx: MIPX_ZEROSOCKET\n", AddressFile));
        AddressFile->Address->SendSourceSocket = 0;
        AddressFile->Address->LocalAddress.Socket = 0;
        break;


    //
    // This next batch are the source routing options. They
    // are submitted by the IPXROUTE program.
    //
    // Do we expose all binding set members to this?

    case MIPX_SRGETPARMS:

        if (DataLength >= sizeof(SR_GET_PARAMETERS)) {
            u.GetSrParameters = (PSR_GET_PARAMETERS)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            if (Binding = NIC_ID_TO_BINDING(Device, u.GetSrParameters->BoardNumber+1)) {

                IPX_DEBUG (ACTION, ("MIPX_SRGETPARMS (%d)\n", u.GetSrParameters->BoardNumber+1));
                u.GetSrParameters->SrDefault = (Binding->AllRouteDirected) ? 1 : 0;
                u.GetSrParameters->SrBroadcast = (Binding->AllRouteBroadcast) ? 1 : 0;
                u.GetSrParameters->SrMulticast = (Binding->AllRouteMulticast) ? 1 : 0;

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MIPX_SRDEF:
    case MIPX_SRBCAST:
    case MIPX_SRMULTI:

        if (DataLength >= sizeof(SR_SET_PARAMETER)) {
            u.SetSrParameter = (PSR_SET_PARAMETER)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);

            if (Binding = NIC_ID_TO_BINDING(Device, u.SetSrParameter->BoardNumber+1)) {
                if (NwlinkAction->Option == MIPX_SRDEF) {

                    //
                    // The compiler generates strange
                    // code which always makes this path be
                    // taken????
                    //

                    IPX_DEBUG (ACTION, ("MIPX_SRDEF %d (%d)\n",
                        u.SetSrParameter->Parameter, u.SetSrParameter->BoardNumber+1));
                    Binding->AllRouteDirected = (BOOLEAN)u.SetSrParameter->Parameter;

                } else if (NwlinkAction->Option == MIPX_SRBCAST) {

                    IPX_DEBUG (ACTION, ("MIPX_SRBCAST %d (%d)\n",
                        u.SetSrParameter->Parameter, u.SetSrParameter->BoardNumber+1));
                    Binding->AllRouteBroadcast = (BOOLEAN)u.SetSrParameter->Parameter;

                } else {

                    IPX_DEBUG (ACTION, ("MIPX_SRMCAST %d (%d)\n",
                        u.SetSrParameter->Parameter, u.SetSrParameter->BoardNumber+1));
                    Binding->AllRouteMulticast = (BOOLEAN)u.SetSrParameter->Parameter;

                }

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MIPX_SRREMOVE:

        if (DataLength >= sizeof(SR_SET_REMOVE)) {
            u.SetSrRemove = (PSR_SET_REMOVE)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
            if (Binding = NIC_ID_TO_BINDING(Device, u.SetSrRemove->BoardNumber+1)) {

                IPX_DEBUG (ACTION, ("MIPX_SRREMOVE %2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x (%d)\n",
                    u.SetSrRemove->MacAddress[0],
                    u.SetSrRemove->MacAddress[1],
                    u.SetSrRemove->MacAddress[2],
                    u.SetSrRemove->MacAddress[3],
                    u.SetSrRemove->MacAddress[4],
                    u.SetSrRemove->MacAddress[5],
                    u.SetSrRemove->BoardNumber+1));
                MacSourceRoutingRemove (Binding, u.SetSrRemove->MacAddress);

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
        } else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;

    case MIPX_SRCLEAR:

        if (DataLength >= sizeof(SR_SET_CLEAR)) {
            u.SetSrClear = (PSR_SET_CLEAR)(NwlinkAction->Data);
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);	
            if (Binding = NIC_ID_TO_BINDING(Device, u.SetSrClear->BoardNumber+1)) {

                IPX_DEBUG (ACTION, ("MIPX_SRCLEAR (%d)\n", u.SetSrClear->BoardNumber+1));
                MacSourceRoutingClear (Binding);

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
		} else {
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        break;


    //
    // These are new for ISN (not supported in NWLINK).
    //

    case MIPX_LOCALTARGET:

        //
        // A request for the local target for an IPX address.
        //

        if (DataLength < sizeof(ISN_ACTION_GET_LOCAL_TARGET)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetLocalTarget = (PISN_ACTION_GET_LOCAL_TARGET)(NwlinkAction->Data);

        if (Device->ForwarderBound) {

            //
            // [FW] Call the Forwarder's FindRoute if installed
            //

            //
            // What about the node number here?
            //
            Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                        (PUCHAR)&u.GetLocalTarget->IpxAddress.NetworkAddress,
                        NULL,  // FindRouteRequest->Node,
                        &routeEntry);

            if (Status != STATUS_SUCCESS) {
               IPX_DEBUG (ACTION, (" MIPX_LOCALTARGET failed net %lx",
                  REORDER_ULONG(u.GetLocalTarget->IpxAddress.NetworkAddress)));
               Status = STATUS_BAD_NETWORK_PATH;
            } else {
               //
               // Fill in the information
               //

               IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
               //
               // What about check for IPX_ROUTER_LOCAL_NET
               //
               if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                  if (Binding->BindingSetMember) {

                       //
                       // It's a binding set member, we round-robin the
                       // responses across all the cards to distribute
                       // the traffic.
                       //

                       MasterBinding = Binding->MasterBinding;
                       Binding = MasterBinding->CurrentSendBinding;
                       MasterBinding->CurrentSendBinding = Binding->NextBinding;

                       u.GetLocalTarget->LocalTarget.NicId = Binding->NicId;

                   } else {

                       u.GetLocalTarget->LocalTarget.NicId = routeEntry.LocalTarget.NicId;
                   }

                  *((UNALIGNED ULONG *)u.GetLocalTarget->LocalTarget.MacAddress) =
                     *((UNALIGNED ULONG *)routeEntry.LocalTarget.MacAddress);
                  *((UNALIGNED ULONG *)(u.GetLocalTarget->LocalTarget.MacAddress+4)) =
                     *((UNALIGNED ULONG *)(routeEntry.LocalTarget.MacAddress+4));
               }

               IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        } else {
            Segment = RipGetSegment((PUCHAR)&u.GetLocalTarget->IpxAddress.NetworkAddress);

            CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

            //
            // See if this route is local.
            //

            RouteEntry = RipGetRoute (Segment, (PUCHAR)&u.GetLocalTarget->IpxAddress.NetworkAddress);

            if ((RouteEntry != NULL) &&
                (RouteEntry->Flags & IPX_ROUTER_PERMANENT_ENTRY)) {

                //
                // This is a local net, to send to it you just use
                // the appropriate NIC ID and the real MAC address.
                //

                if ((RouteEntry->Flags & IPX_ROUTER_LOCAL_NET) == 0) {

                    //
                    // It's the virtual net, send via the first card.
                    //
                    FILL_LOCAL_TARGET(&u.GetLocalTarget->LocalTarget, 1);
    				CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);

                } else {


    				CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    				IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    				Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId);

                    if (Binding->BindingSetMember) {

                        //
                        // It's a binding set member, we round-robin the
                        // responses across all the cards to distribute
                        // the traffic.
                        //

                        MasterBinding = Binding->MasterBinding;
                        Binding = MasterBinding->CurrentSendBinding;
                        MasterBinding->CurrentSendBinding = Binding->NextBinding;

                        FILL_LOCAL_TARGET(&u.GetLocalTarget->LocalTarget, MIN( Device->MaxBindings, Binding->NicId));

                    } else {

                        FILL_LOCAL_TARGET(&u.GetLocalTarget->LocalTarget, RouteEntry->NicId);

                    }
    				IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                }

                RtlCopyMemory(
                    u.GetLocalTarget->LocalTarget.MacAddress,
                    u.GetLocalTarget->IpxAddress.NodeAddress,
                    6);

            } else {

                //
                // This call will return STATUS_PENDING if we successfully
                // queue a RIP request for the packet.
                //

                Status = RipQueueRequest (u.GetLocalTarget->IpxAddress.NetworkAddress, RIP_REQUEST);
                CTEAssert (Status != STATUS_SUCCESS);

                if (Status == STATUS_PENDING) {

                    //
                    // A RIP request went out on the network; we queue
                    // this request for completion when the RIP response
                    // arrives. We save the network in the information
                    // field for easier retrieval later.
                    //
#ifdef SUNDOWN
					REQUEST_INFORMATION(Request) = (ULONG_PTR)u.GetLocalTarget;
#else
					REQUEST_INFORMATION(Request) = (ULONG)u.GetLocalTarget;
#endif

                    
                    InsertTailList(
                        &Device->Segments[Segment].WaitingLocalTarget,
                        REQUEST_LINKAGE(Request));

                }

    			CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
            }

        }

        break;

    case MIPX_NETWORKINFO:

        //
        // A request for network information about the immediate
        // route to a network.
        //

        if (DataLength < sizeof(ISN_ACTION_GET_NETWORK_INFO)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetNetworkInfo = (PISN_ACTION_GET_NETWORK_INFO)(NwlinkAction->Data);

        if (u.GetNetworkInfo->Network == 0) {

            //
            // This is information about the local card.
            //

            u.GetNetworkInfo->LinkSpeed = Device->LinkSpeed * 12;
            u.GetNetworkInfo->MaximumPacketSize = Device->Information.MaxDatagramSize;

        } else {

            if (Device->ForwarderBound) {

                //
                // [FW] Call the Forwarder's FindRoute if installed
                //

                //
                // What about the node number here?
                //
                Status = (*Device->UpperDrivers[IDENTIFIER_RIP].FindRouteHandler) (
                                 (PUCHAR)&u.GetNetworkInfo->Network,
                                 NULL,  // FindRouteRequest->Node,
                                 &routeEntry);

                if (Status != STATUS_SUCCESS) {
                   IPX_DEBUG (ACTION, (" MIPX_GETNETINFO_NR failed net %lx",
                              REORDER_ULONG(u.GetNetworkInfo->Network)));
                   Status = STATUS_BAD_NETWORK_PATH;
                } else {
                   //
                   // Fill in the information
                   //

    			   IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                   if (Binding = NIC_ID_TO_BINDING(Device, routeEntry.LocalTarget.NicId)) {
                      //
                      // Our medium speed is stored in 100 bps, we
                      // convert to bytes/sec by multiplying by 12
                      // (should really be 100/8 = 12.5).
                      //

                      u.GetNetworkInfo->LinkSpeed = Binding->MediumSpeed * 12;
                      u.GetNetworkInfo->MaximumPacketSize = Binding->AnnouncedMaxDatagramSize;
                   }
    			   IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }
            } else {
                Segment = RipGetSegment((PUCHAR)&u.GetNetworkInfo->Network);

    			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                CTEGetLock (&Device->SegmentLocks[Segment], &LockHandle);

                //
                // See which net card this is routed on.
                //

                RouteEntry = RipGetRoute (Segment, (PUCHAR)&u.GetNetworkInfo->Network);

                if ((RouteEntry != NULL) &&
    				(Binding = NIC_ID_TO_BINDING(Device, RouteEntry->NicId))) {

                    //
                    // Our medium speed is stored in 100 bps, we
                    // convert to bytes/sec by multiplying by 12
                    // (should really be 100/8 = 12.5).
                    //

                    u.GetNetworkInfo->LinkSpeed = Binding->MediumSpeed * 12;
                    u.GetNetworkInfo->MaximumPacketSize = Binding->AnnouncedMaxDatagramSize;

                } else {

                    //
                    // Fail the call, we don't have a route yet.
                    // This requires that a packet has been
                    // sent to this net already; nwrdr says this is
                    // OK, they will send their connect request
                    // before they query. On the server it should
                    // have RIP running so all nets should be in
                    // the database.
                    //

                    Status = STATUS_BAD_NETWORK_PATH;

                }

                CTEFreeLock (&Device->SegmentLocks[Segment], LockHandle);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
            }
        }

        break;

    case MIPX_CONFIG:

        //
        // A request for details on every binding.
        //

        if (DataLength < sizeof(ISN_ACTION_GET_DETAILS)) {
	   IPX_DEBUG(ACTION, ("Not enought buffer %d < %d\n", DataLength,sizeof(ISN_ACTION_GET_DETAILS) )); 
	   return STATUS_BUFFER_TOO_SMALL;
        }

        u.GetDetails = (PISN_ACTION_GET_DETAILS)(NwlinkAction->Data);

        if (u.GetDetails->NicId == 0) {

            //
            // This is information about the local card. We also
            // tell him the total number of bindings in NicId.
            //

            u.GetDetails->NetworkNumber = Device->VirtualNetworkNumber;
            u.GetDetails->NicId = (USHORT)MIN (Device->MaxBindings, Device->ValidBindings);

        } else {
			IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
	        Binding = NIC_ID_TO_BINDING(Device, u.GetDetails->NicId);

            if ((Binding != NULL) &&
                (u.GetDetails->NicId <= MIN (Device->MaxBindings, Device->ValidBindings))) {

                ULONG StringLoc;
    			IpxReferenceBinding1(Binding, BREF_DEVICE_ACCESS);
    			IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                u.GetDetails->NetworkNumber = Binding->LocalAddress.NetworkAddress;
                if (Binding->Adapter->MacInfo.MediumType == NdisMediumArcnet878_2) {
                    u.GetDetails->FrameType = ISN_FRAME_TYPE_ARCNET;
                } else {
                    u.GetDetails->FrameType = Binding->FrameType;
                }
                u.GetDetails->BindingSet = Binding->BindingSetMember;
                if (Binding->Adapter->MacInfo.MediumAsync) {
                    if (Binding->LineUp) {
                        u.GetDetails->Type = 2;
                    } else {
                        u.GetDetails->Type = 3;
                    }
                } else {
                    u.GetDetails->Type = 1;
                }

                RtlCopyMemory (u.GetDetails->Node, Binding->LocalMacAddress.Address, 6);

                //
                // Copy the adapter name, including the final NULL.
                //

                StringLoc = (Binding->Adapter->AdapterNameLength / sizeof(WCHAR)) - 2;
                while (Binding->Adapter->AdapterName[StringLoc] != L'\\') {
                    --StringLoc;
                }
                RtlCopyMemory(
                    u.GetDetails->AdapterName,
                    &Binding->Adapter->AdapterName[StringLoc+1],
                    Binding->Adapter->AdapterNameLength - ((StringLoc+1) * sizeof(WCHAR)));

    			IpxDereferenceBinding1(Binding, BREF_DEVICE_ACCESS);
            } else {
	       IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
	       IPX_DEBUG(ACTION, ("Bad nic id %d\n",u.GetDetails->NicId)); 
	       Status = STATUS_INVALID_PARAMETER;
            }
        }

        break;


        //
        // Return new nic info to the requestor. Currently, no check for
        // who retrieved the info earlier.
        //
        case MIPX_GETNEWNICINFO:

            IPX_DEBUG (ACTION, ("%lx: MIPX_GETNEWNICINFO (%lx)\n", AddressFile,
                                Request));
            //
            // a request for details on new bindings.
            //
            Status = GetNewNics(Device, Request, TRUE, NwlinkAction, BufferLength, FALSE);
            break;

        //
        // In case a LineUp occurs with the IpxwanConfigRequired, this is used
        // to indicate to IPX that the config is done and that the LineUp
        // can be indicated to the other clients.
        //
        case MIPX_IPXWAN_CONFIG_DONE:

            IPX_DEBUG (ACTION, ("MIPX_IPXWAN_CONFIG_DONE (%lx)\n", Request));

            if (DataLength < sizeof(IPXWAN_CONFIG_DONE)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            u.IpxwanConfigDone = (PIPXWAN_CONFIG_DONE)(NwlinkAction->Data);
            Status = IpxIndicateLineUp( IpxDevice,
                                        u.IpxwanConfigDone->NicId,
                                        u.IpxwanConfigDone->Network,
                                        u.IpxwanConfigDone->LocalNode,
                                        u.IpxwanConfigDone->RemoteNode);
            break;

        //
        // Used to query the WAN inactivity counter for a given NicId
        //
        case MIPX_QUERY_WAN_INACTIVITY: {

            USHORT   NicId;

            IPX_DEBUG (ACTION, ("MIPX_QUERY_WAN_INACTIVITY (%lx)\n", Request));

            if (DataLength < sizeof(IPX_QUERY_WAN_INACTIVITY)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            u.QueryWanInactivity = (PIPX_QUERY_WAN_INACTIVITY)(NwlinkAction->Data);

            //
            // If this is an invalid Nic, then we need to associate a Nic with the ConnectionId that
            // was passed in.
            // This should happen only once per line up.
            //
            if (u.QueryWanInactivity->NicId == INVALID_NICID) {
                PBINDING    Binding;
                {
                ULONG   Index = MIN (Device->MaxBindings, Device->HighestExternalNicId);

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                for ( NicId = Device->HighestLanNicId+1;NicId < Index;NicId++ ) {
                    Binding = NIC_ID_TO_BINDING(Device, NicId);
                    if (Binding && (Binding->ConnectionId == u.QueryWanInactivity->ConnectionId)) {
                        CTEAssert(Binding->Adapter->MacInfo.MediumAsync);
                        if (Binding->LineUp != LINE_CONFIG) {
                            IPX_DEBUG (WAN, ("Binding is not in config state yet got QUERY_WAN_INACTIVITY %lx %lx", Binding, Request));
                            NicId = 0;
                        }
                        u.QueryWanInactivity->NicId = NicId;
                        break;
                    }
                }
			    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
                }
            }

            if (NicId) {
                u.QueryWanInactivity->WanInactivityCounter = IpxInternalQueryWanInactivity(NicId);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

    //
    // The Option was not supported, so fail.
    //

    default:

        Status = STATUS_NOT_SUPPORTED;
        break;


    }   // end of the long switch on NwlinkAction->Option


#if DBG
    if (!NT_SUCCESS(Status)) {
        IPX_DEBUG (ACTION, ("Nwlink action %lx failed, status %lx\n", NwlinkAction->Option, Status));
    }
#endif

    return Status;

}   /* IpxTdiAction */


VOID
IpxCancelAction(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to cancel an Action.
    What is done to cancel it is specific to each action.

    NOTE: This routine is called with the CancelSpinLock held and
    is responsible for releasing it.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    none.

--*/

{
    PDEVICE Device = IpxDevice;
    PREQUEST Request = (PREQUEST)Irp;
    CTELockHandle LockHandle;
    PLIST_ENTRY p;
    BOOLEAN Found;
    UINT IOCTLType;

    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    //
    // Find the request on the address notify queue.
    //

    Found = FALSE;

    CTEGetLock (&Device->Lock, &LockHandle);

    for (p = Device->AddressNotifyQueue.Flink;
         p != &Device->AddressNotifyQueue;
         p = p->Flink) {

         if (LIST_ENTRY_TO_REQUEST(p) == Request) {

             RemoveEntryList (p);
             Found = TRUE;
             IOCTLType = MIPX_NOTIFYCARDINFO;
             break;
         }
    }

    if (!Found) {
        for (p = Device->LineChangeQueue.Flink;
             p != &Device->LineChangeQueue;
             p = p->Flink) {

             if (LIST_ENTRY_TO_REQUEST(p) == Request) {

                 RemoveEntryList (p);
                 Found = TRUE;
                 IOCTLType = MIPX_LINECHANGE;
                 break;
             }
        }
    }

    if (!Found) {
        for (p = Device->NicNtfQueue.Flink;
             p != &Device->NicNtfQueue;
             p = p->Flink) {

             if (LIST_ENTRY_TO_REQUEST(p) == Request) {

                 RemoveEntryList (p);
                 Found = TRUE;
                 IOCTLType = MIPX_GETNEWNICINFO;
                 break;
             }
        }
    }

    CTEFreeLock (&Device->Lock, LockHandle);
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    if (Found) {


        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        IpxCompleteRequest (Request);
        IpxFreeRequest(Device, Request);
        if (IOCTLType == MIPX_NOTIFYCARDINFO) {
            IPX_DEBUG(ACTION, ("Cancelled action NOTIFYCARDINFO %lx\n", Request));
            IpxDereferenceDevice (Device, DREF_ADDRESS_NOTIFY);
        } else {
            if (IOCTLType == MIPX_LINECHANGE) {
                IPX_DEBUG(ACTION, ("Cancelled action LINECHANGE %lx\n", Request));
                IpxDereferenceDevice (Device, DREF_LINE_CHANGE);
            } else {
                IPX_DEBUG(ACTION, ("Cancelled action LINECHANGE %lx\n", Request));
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
            }
        }

    }
#if DBG
       else {
        IPX_DEBUG(ACTION, ("Cancelled action orphan %lx\n", Request));
    }
#endif

}   /* IpxCancelAction */


VOID
IpxAbortLineChanges(
    IN PVOID ControlChannelContext
    )

/*++

Routine Description:

    This routine aborts any line change IRPs posted by the
    control channel with the specified open context. It is
    called when a control channel is being shut down.

Arguments:

    ControlChannelContext - The context assigned to the control
        channel when it was opened.

Return Value:

    none.

--*/

{
    PDEVICE Device = IpxDevice;
    CTELockHandle LockHandle;
    LIST_ENTRY AbortList;
    PLIST_ENTRY p;
    PREQUEST Request;
    KIRQL irql;


    InitializeListHead (&AbortList);

    IoAcquireCancelSpinLock( &irql );
    CTEGetLock (&Device->Lock, &LockHandle);

    p = Device->LineChangeQueue.Flink;

    while (p != &Device->LineChangeQueue) {
        LARGE_INTEGER   ControlChId;

        Request = LIST_ENTRY_TO_REQUEST(p);

        CCID_FROM_REQUEST(ControlChId, Request);

        p = p->Flink;

        if (ControlChId.QuadPart == ((PLARGE_INTEGER)ControlChannelContext)->QuadPart) {
            RemoveEntryList (REQUEST_LINKAGE(Request));
            InsertTailList (&AbortList, REQUEST_LINKAGE(Request));
        }
    }

    while (!IsListEmpty (&AbortList)) {

        p = RemoveHeadList (&AbortList);
        Request = LIST_ENTRY_TO_REQUEST(p);

        IPX_DEBUG(ACTION, ("Aborting line change %lx\n", Request));

        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        CTEFreeLock(&Device->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );

        IpxCompleteRequest (Request);
        IpxFreeRequest(Device, Request);

        IpxDereferenceDevice (Device, DREF_LINE_CHANGE);

        IoAcquireCancelSpinLock( &irql );
        CTEGetLock(&Device->Lock, &LockHandle);
    }

    CTEFreeLock(&Device->Lock, LockHandle);
    IoReleaseCancelSpinLock( irql );
}   /* IpxAbortLineChanges */

#define ROUTER_INFORMED_OF_NIC_CREATION 2


NTSTATUS
GetNewNics(
    PDEVICE  Device,
    IN PREQUEST Request,
    BOOLEAN fCheck,
    PNWLINK_ACTION NwlinkAction,
    UINT BufferLength,
    BOOLEAN OldIrp
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT DataLength;
    PNDIS_BUFFER NdisBuffer;
    CTELockHandle LockHandle;
    CTELockHandle LockHandle1;
    PBINDING Binding;
    ULONG NoOfNullNics = 0;
    PIPX_NICS   pNics;
    PIPX_NIC_INFO pNicInfo;
    PIPX_NIC_INFO pLastNicInfo;
    UINT          LengthOfHeader;
    ULONG n, i;
    KIRQL OldIrql;
    BOOLEAN     fIncDec = FALSE;
    ULONG StringLoc = 0;

    LengthOfHeader =  (UINT)(FIELD_OFFSET(NWLINK_ACTION, Data[0]));
    if (fCheck)
    {
       if (BufferLength < (LengthOfHeader + FIELD_OFFSET(IPX_NICS, Data[0]) + sizeof(IPX_NIC_INFO)))
      {
          IPX_DEBUG (ACTION, ("Nwlink action failed, buffer too small for even one NICs info\n"));
          return STATUS_BUFFER_TOO_SMALL;
      }
    }
    else
    {
        NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, NormalPagePriority);
	if (NwlinkAction == NULL) {
	   return STATUS_INSUFFICIENT_RESOURCES; 
	}

    }
    pNics = (PIPX_NICS)(NwlinkAction->Data);
    pNicInfo = (PIPX_NIC_INFO)(pNics->Data);
    pLastNicInfo = pNicInfo  + ((BufferLength - LengthOfHeader - FIELD_OFFSET(IPX_NICS, Data[0]))/sizeof(IPX_NIC_INFO)) - 1;

    IPX_DEBUG(BIND, ("GetNewNicInfo: pNicInfo=(%x), pLastNicInfo=(%x),LengthOfHeader=(%x), BindingCount=(%x)\n", pNicInfo, pLastNicInfo, LengthOfHeader, Device->ValidBindings));
    IPX_DEBUG(BIND, ("BufferLength is (%d). Length for storing NICS is (%d)\n", BufferLength, (BufferLength - LengthOfHeader - FIELD_OFFSET(IPX_NICS, Data[0]))));
    

    if (pNics->fAllNicsDesired) {
        IPX_DEBUG(BIND, ("Yes, All NICs desired\n"));    
    } else {
        IPX_DEBUG(BIND, ("No, All NICs NOT desired\n"));    

    }

    //
    // Optimize since we don't want to go over the array all the time.
    //

    CTEGetLock (&Device->Lock, &LockHandle);

    {
    ULONG   Index = MIN (Device->MaxBindings, Device->ValidBindings);


    //
    // If all nics are desired, then mark them ALL as dirty,
    // for the subsequent IRPs that do not have this flag.
    //

    if (pNics->fAllNicsDesired) {
        
        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
        
        for (n=0, i=LOOPBACK_NIC_ID; i<=Index; i++) {

            Binding =  NIC_ID_TO_BINDING(Device, i);
    
            if (Binding) {

                Binding->fInfoIndicated = FALSE;

            }
        }
        
        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

    }

    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
    for (n=0, i=LOOPBACK_NIC_ID; i<=Index; i++)
    {
       Binding =  NIC_ID_TO_BINDING(Device, i);

       if (!Binding)
       {
             NoOfNullNics++;
             continue;
       }

       //
       // If the binding is of type autodetect *and* we haven't gotten a response on the adapter, 
       // that means IPX is still Autodetecting for this card. Do NOT tell FWD about it [shreem]
       //
       if (!Binding->PastAutoDetection) {
           
           IPX_DEBUG(BIND, ("Binding[%d] Dont Tell FWD!\n", i));
           NoOfNullNics++;
           continue;

       } else {
           
           IPX_DEBUG(BIND, ("Binding[%d] Tell FWD about it (past auto detect)!\n", i));

       }

       //
       // If we have already indicated info about this NIC, go on to the
       // next nic.
       //
       if ((Binding->fInfoIndicated && !pNics->fAllNicsDesired)
                     || (pNicInfo > pLastNicInfo))
       {
           if (Binding->fInfoIndicated) {
               IPX_DEBUG(BIND, ("-------------------------> %d already indicated\n", i));
           } else {
               IPX_DEBUG(BIND, ("*********** Continue for another reason! (%d) \n", i));
           }

           if (pNicInfo > pLastNicInfo) {
               IPX_DEBUG(BIND, ("pNicInfo: %x  pLastNicInfo %x\n", pNicInfo, pLastNicInfo));
           }           
           
           continue;
       }

       //
       // If we have a WAN nic, indicate the line up/down status.  Also,
       // copy the remote address into the app. field
       //
       if (Binding->Adapter->MacInfo.MediumAsync)
       {
            RtlCopyMemory(pNicInfo->RemoteNodeAddress, Binding->WanRemoteNode, HARDWARE_ADDRESS_LENGTH);
            if (Binding->LineUp)
            {
                 // pNicInfo->Status = NIC_LINE_UP;

                    pNicInfo->Status = NIC_CREATED;
                    //fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;
            }
            else
            {
                 // pNicInfo->Status = NIC_LINE_DOWN;

                    pNicInfo->Status = NIC_DELETED;
                    //fIncDec          = NIC_OPCODE_DECREMENT_NICIDS;
            }

            pNicInfo->InterfaceIndex = Binding->InterfaceIndex;
            pNicInfo->MaxPacketSize =
                    Binding->MaxSendPacketSize - ASYNC_MEDIUM_HDR_LEN;
       }
       else
       {
                 if (Binding->LocalAddress.NetworkAddress == 0)
                 {

                    pNicInfo->Status = NIC_CREATED;

		     if (ROUTER_INFORMED_OF_NIC_CREATION != Binding->PastAutoDetection) {
		       IPX_DEBUG(BIND, ("!!!!!!!---- Increment on Binding %x, index (%d)\n", Binding,i));
		       fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;                        
                    
                     } else {
		       IPX_DEBUG(BIND, ("Already informed. No increment on Binding %x, index (%d)\n", Binding,i));
		     }
                 }
                 else
                 {
                    pNicInfo->Status = NIC_CONFIGURED;

                    //
                    // IPX might have already informed the Router of the
                    // creation of this NicId, in which case, we dont ask
                    // it to increment the NicIds [ShreeM]
                    //
                    if (ROUTER_INFORMED_OF_NIC_CREATION != Binding->PastAutoDetection) {
		       IPX_DEBUG(BIND, ("!!!!!!!!! --------Increment on Binding %x, index (%d)\n", Binding,i));
		       fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;                        
                    
                    }

                 }

                 //
                 // Router pnp changes [ShreeM]
                 // 
                 if (FALSE == Binding->LineUp) {

                     pNicInfo->Status = NIC_DELETED;
                     fIncDec          = NIC_OPCODE_DECREMENT_NICIDS;
                 
                 }
                 
                 //
                 // Loopback Adapter
                 //
                 if (LOOPBACK_NIC_ID == Binding->NicId) {

                     pNicInfo->Status = NIC_CONFIGURED;
                     fIncDec          = NIC_OPCODE_INCREMENT_NICIDS;

                 }

                 //
                 // RealMaxDatagramSize does not include space for ipx
                 // header. The forwarder needs to have it included since
                 // we give the entire packet (mimus the mac header) to
                 // the forwarder
                 //
                 pNicInfo->MaxPacketSize =
                    Binding->RealMaxDatagramSize + sizeof(IPX_HEADER);
       }

       pNicInfo->NdisMediumType= Binding->Adapter->MacInfo.RealMediumType;
       pNicInfo->LinkSpeed     = Binding->MediumSpeed;
       pNicInfo->PacketType    = Binding->FrameType;
       
       //
       // Zero the stuff out and then set fields that make sense.
       //
       RtlZeroMemory(&pNicInfo->Details, sizeof(ISN_ACTION_GET_DETAILS));

       pNicInfo->Details.NetworkNumber = Binding->LocalAddress.NetworkAddress;
       RtlCopyMemory(pNicInfo->Details.Node, Binding->LocalAddress.NodeAddress, HARDWARE_ADDRESS_LENGTH);
       pNicInfo->Details.NicId         = Binding->NicId;
       pNicInfo->Details.BindingSet    = Binding->BindingSetMember;
       pNicInfo->Details.FrameType     = Binding->FrameType;

       if (Binding->Adapter->MacInfo.MediumAsync) {
           if (Binding->LineUp) {
               pNicInfo->Details.Type = 2;
           } else {
               pNicInfo->Details.Type = 3;
           }
       } else {
           pNicInfo->Details.Type = 1;
       }

       //
       // Copy the adapter name, including the final NULL.
       //

       StringLoc = (Binding->Adapter->AdapterNameLength / sizeof(WCHAR)) - 2;
       while (Binding->Adapter->AdapterName[StringLoc] != L'\\') {
           --StringLoc;
       }

       RtlCopyMemory(
           pNicInfo->Details.AdapterName,
           &Binding->Adapter->AdapterName[StringLoc+1],
           Binding->Adapter->AdapterNameLength - ((StringLoc+1) * sizeof(WCHAR)));
       
       // 
       // Tell the forwarder that the rest of the NICIDs are to be moved up/down
       // only if it is not asking for ALL of them
       //
       if (!pNics->fAllNicsDesired) { 
           pNicInfo->Status |= fIncDec;
       }

       pNicInfo->ConnectionId  = Binding->ConnectionId;
       pNicInfo->IpxwanConfigRequired = Binding->IpxwanConfigRequired;

#if DBG
       //
       // Dump the IPX_NIC_INFO Structure.
       //

       IPX_DEBUG(BIND, ("%d.\nNICID= %d, Interface Index  = %d\n", i, pNicInfo->Details.NicId, pNicInfo->InterfaceIndex));

       IPX_DEBUG(BIND, ("Interface Index  = %d\n", pNicInfo->InterfaceIndex));
       IPX_DEBUG(BIND, ("LinkSpeed             = %d\n", pNicInfo->LinkSpeed));
       IPX_DEBUG(BIND, ("PacketType            = %d\n", pNicInfo->PacketType));
       IPX_DEBUG(BIND, ("MaxPacketSize         = %d\n", pNicInfo->MaxPacketSize));
       IPX_DEBUG(BIND, ("NdisMediumType        = %d\n", pNicInfo->NdisMediumType));
       IPX_DEBUG(BIND, ("NdisMediumSubtype     = %d\n", pNicInfo->NdisMediumSubtype));
       IPX_DEBUG(BIND, ("Status                = %d\n", (ULONG) pNicInfo->Status));
       IPX_DEBUG(BIND, ("ConnectionID          = %d\n", pNicInfo->ConnectionId));
       IPX_DEBUG(BIND, ("IpxwanConfigRequired  = %d\n", pNicInfo->IpxwanConfigRequired));
       
       IPX_DEBUG(BIND, ("FrameType             = %d\n", pNicInfo->Details.FrameType));
       IPX_DEBUG(BIND, ("Type                  = %d\n", pNicInfo->Details.Type));
       IPX_DEBUG(BIND, ("NetworkNumber         = %d\n", pNicInfo->Details.NetworkNumber));
       IPX_DEBUG(BIND, ("BindingSet            = %d\n", pNicInfo->Details.BindingSet));
       IPX_DEBUG(BIND, ("LocalNode = %x-%x-%x-%x-%x-%x\n",  pNicInfo->Details.Node[0], 
                                                            pNicInfo->Details.Node[1],
                                                            pNicInfo->Details.Node[2],
                                                            pNicInfo->Details.Node[3],
                                                            pNicInfo->Details.Node[4],
                                                            pNicInfo->Details.Node[5]));

       IPX_DEBUG(BIND, ("RemoteNode = %x-%x-%x-%x-%x-%x\n",  pNicInfo->RemoteNodeAddress[0], 
                                                            pNicInfo->RemoteNodeAddress[1],
                                                            pNicInfo->RemoteNodeAddress[2],
                                                            pNicInfo->RemoteNodeAddress[3],
                                                            pNicInfo->RemoteNodeAddress[4],
                                                            pNicInfo->RemoteNodeAddress[5]));
       
       //IPX_DEBUG(BIND, ("AdadpterName = %ws\n", pNicInfo->Details.AdapterName));

#endif

       pNicInfo++;  //increment to store next nic info
       n++;         //indicates the # of nics processed so far.
       Binding->fInfoIndicated = TRUE;
       Binding->PastAutoDetection = ROUTER_INFORMED_OF_NIC_CREATION;
       IPX_DEBUG(BIND, ("Iteration no = (%d) complete : reporting NicId:(%lx)\n", n, Binding->NicId));


    }
    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);
    }
    CTEFreeLock (&Device->Lock, LockHandle);

    pNics->NoOfNics = n;
    pNics->TotalNoOfNics = Device->ValidBindings - NoOfNullNics;

    //
    // If no nics. to report, queue the request
    //
    if (!n) {

      IPX_DEBUG(BIND, ("GetNewNicInfo: Inserting Irp\n"));
      CTEGetLock (&Device->Lock, &LockHandle);

      InsertTailList( &Device->NicNtfQueue, REQUEST_LINKAGE(Request) );

      if (!OldIrp)
      {
        IoSetCancelRoutine (Request, IpxCancelAction);
      }
      if (Request->Cancel && 
	  IoSetCancelRoutine(Request, (PDRIVER_CANCEL)NULL)) {
	 
	 IPX_DEBUG(BIND, ("GetNewNicInfo:Cancelling Irp\n"));
	 (VOID)RemoveTailList (&Device->NicNtfQueue);
	 CTEFreeLock (&Device->Lock, LockHandle);
	 Status = STATUS_CANCELLED;
      
      } else {
	 if (!OldIrp)
	 {
	    IpxReferenceDevice (Device, DREF_NIC_NOTIFY);
	 }
	 Status = STATUS_PENDING;
	 CTEFreeLock (&Device->Lock, LockHandle);
      }
    }
    else
    {
       IPX_DEBUG(BIND, ("Reporting (%d) nics\n", n));
    }

    return(Status);
}


VOID
IpxAbortNtfChanges(
    IN PVOID ControlChannelContext
    )

/*++

Routine Description:

    This routine aborts any line change IRPs posted by the
    control channel with the specified open context. It is
    called when a control channel is being shut down.

Arguments:

    ControlChannelContext - The context assigned to the control
        channel when it was opened.

Return Value:

    none.

--*/

{
    PDEVICE Device = IpxDevice;
    CTELockHandle LockHandle;
    LIST_ENTRY AbortList;
    PLIST_ENTRY p;
    PREQUEST Request;
    KIRQL irql;


    InitializeListHead (&AbortList);

    IoAcquireCancelSpinLock( &irql );
    CTEGetLock (&Device->Lock, &LockHandle);

    p = Device->NicNtfQueue.Flink;

    while (p != &Device->NicNtfQueue) {
        LARGE_INTEGER   ControlChId;

        Request = LIST_ENTRY_TO_REQUEST(p);

        CCID_FROM_REQUEST(ControlChId, Request);

        IPX_DEBUG(BIND, ("IpxAbortNtfChange: There is at least one IRP in the queue\n"));
        p = p->Flink;

        if (ControlChId.QuadPart == ((PLARGE_INTEGER)ControlChannelContext)->QuadPart) {
            IPX_DEBUG(BIND, ("IpxAbortNtfChanges: Dequeing an Irp\n"));
            RemoveEntryList (REQUEST_LINKAGE(Request));
            InsertTailList (&AbortList, REQUEST_LINKAGE(Request));
        }
    }

    while (!IsListEmpty (&AbortList)) {

        p = RemoveHeadList (&AbortList);
        Request = LIST_ENTRY_TO_REQUEST(p);

        IPX_DEBUG(ACTION, ("Aborting line change %lx\n", Request));

        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_CANCELLED;

        CTEFreeLock(&Device->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );

        IPX_DEBUG(BIND, ("IpxAbortNtfChanges: Cancelling the dequeued Irp\n"));
        IpxCompleteRequest (Request);
        IpxFreeRequest(Device, Request);

        IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);

        IoAcquireCancelSpinLock( &irql );
        CTEGetLock(&Device->Lock, &LockHandle);
    }

    CTEFreeLock(&Device->Lock, LockHandle);
    IoReleaseCancelSpinLock( irql );
}   /* IpxAbortNtfChanges */

NTSTATUS
IpxIndicateLineUp(
    IN  PDEVICE Device,
    IN  USHORT  NicId,
    IN  ULONG   Network,
    IN  UCHAR   LocalNode[6],
    IN  UCHAR   RemoteNode[6]
    )
/*++

Routine Description:

    This routine indicates a line-up to all the concerned clients once
    the line is up.
    For now, called only if the MIPX_IPXWAN_CONFIG_DONE IOCTL is received.


Arguments:

    Device - The device for the operation.

    NicId  - The NicId corresponding to the binding that is up.

    Network, LocalNode, RemoteNode - addresses corresponding to this lineup.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    PBINDING    Binding = NIC_ID_TO_BINDING(Device, NicId);
    IPX_LINE_INFO LineInfo;
    USHORT  i;
    PLIST_ENTRY p;
    PREQUEST Request;
    PNDIS_BUFFER NdisBuffer;
    PNWLINK_ACTION NwlinkAction;
    UINT BufferLength;
    PIPX_ADDRESS_DATA IpxAddressData;
    IPXCP_CONFIGURATION Configuration;
    KIRQL irql, OldIrq;
    NTSTATUS    Status;
    NTSTATUS    ntStatus;
    KIRQL   OldIrql;

    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    if (!(Binding &&
          Binding->Adapter->MacInfo.MediumAsync &&
          Binding->LineUp == LINE_CONFIG)) {
        IPX_DEBUG(WAN, ("Indicate line up on invalid line: %lu\n", NicId));
        return STATUS_INVALID_PARAMETER;
    }

    // take bindaccesslock here...
    //

    //
    // If we are here, then this flag was set on a line up.
    // We turn it off now so that the adapter dll above us can decide
    // to indicate this lineup to the router module instead of the IpxWan module
    //

    CTEAssert(Binding->IpxwanConfigRequired);

    Binding->IpxwanConfigRequired = 0;

    Binding->LineUp = LINE_UP;

    //
    // Indicate to the upper drivers.
    //

    LineInfo.LinkSpeed = Binding->MediumSpeed;
    LineInfo.MaximumPacketSize = Binding->MaxSendPacketSize - 14;
    LineInfo.MaximumSendSize = Binding->MaxSendPacketSize - 14;
    LineInfo.MacOptions = Binding->Adapter->MacInfo.MacOptions;

    //
    // Fill-in the addresses into the bindings
    //
    Binding->LocalAddress.NetworkAddress = Network;

    *(UNALIGNED ULONG *)Binding->LocalAddress.NodeAddress = *(UNALIGNED ULONG *)LocalNode;
    *(UNALIGNED ULONG *)(Binding->LocalAddress.NodeAddress+4) = *(UNALIGNED ULONG *)(LocalNode+4);

    *(UNALIGNED ULONG *)Binding->WanRemoteNode = *(UNALIGNED ULONG *)RemoteNode;
    *(UNALIGNED ULONG *)(Binding->WanRemoteNode+4) = *(UNALIGNED ULONG *)(RemoteNode+4);

    //
    // Fill in the IPXCP_CONFIGURATION structure from the binding.
    //
    *(UNALIGNED ULONG *)Configuration.Network = Binding->LocalAddress.NetworkAddress;

    *(UNALIGNED ULONG *)Configuration.LocalNode = *(UNALIGNED ULONG *)Binding->LocalAddress.NodeAddress;
    *(UNALIGNED USHORT *)(Configuration.LocalNode+4) = *(UNALIGNED USHORT *)(Binding->LocalAddress.NodeAddress+4);

    *(UNALIGNED ULONG *)Configuration.RemoteNode = *(UNALIGNED ULONG *)RemoteNode;
    *(UNALIGNED USHORT *)(Configuration.RemoteNode+4) = *(UNALIGNED USHORT *)(RemoteNode+4);

    Configuration.InterfaceIndex = Binding->InterfaceIndex;
    Configuration.ConnectionClient = Binding->DialOutAsync;


        //
        // We dont give lineups; instead indicate only if the PnP reserved address
        // changed to SPX. NB gets all PnP indications with the reserved address case
        // marked out.
        //
        {
            IPX_PNP_INFO    NBPnPInfo;

            if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == 1)) {

                //
                // NB's reserved address changed.
                //
                NBPnPInfo.NewReservedAddress = TRUE;

                if (!Device->VirtualNetwork) {
                    //
                    // Let SPX know because it fills in its own headers.
                    //
                    if (Device->UpperDriverBound[IDENTIFIER_SPX]) {
                        IPX_DEFINE_LOCK_HANDLE(LockHandle1)
                        IPX_PNP_INFO    IpxPnPInfo;

                        IpxPnPInfo.NewReservedAddress = TRUE;
                        IpxPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                        IpxPnPInfo.FirstORLastDevice = FALSE;

                        IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                        RtlCopyMemory(IpxPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                        NIC_HANDLE_FROM_NIC(IpxPnPInfo.NicHandle, Binding->NicId);
                        IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                        //
                        // give the PnP indication
                        //
                        (*Device->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
                            IPX_PNP_ADDRESS_CHANGE,
                            &IpxPnPInfo);

                        IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADDRESS_CHANGED to SPX: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
                    }
                }
            } else {
                    NBPnPInfo.NewReservedAddress = FALSE;
            }

            if (Device->UpperDriverBound[IDENTIFIER_NB]) {
                IPX_DEFINE_LOCK_HANDLE(LockHandle1)

                Binding->IsnInformed[IDENTIFIER_NB] = TRUE;

            	NBPnPInfo.LineInfo.LinkSpeed = Device->LinkSpeed;
            	NBPnPInfo.LineInfo.MaximumPacketSize =
            		Device->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
            	NBPnPInfo.LineInfo.MaximumSendSize =
            		Device->Information.MaxDatagramSize + sizeof(IPX_HEADER);
            	NBPnPInfo.LineInfo.MacOptions = Device->MacOptions;

                NBPnPInfo.NetworkAddress = Binding->LocalAddress.NetworkAddress;
                NBPnPInfo.FirstORLastDevice = FALSE;

                IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle1);
                RtlCopyMemory(NBPnPInfo.NodeAddress, Binding->LocalAddress.NodeAddress, 6);
                NIC_HANDLE_FROM_NIC(NBPnPInfo.NicHandle, Binding->NicId);
                IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // give the PnP indication
                //
                (*Device->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
                    IPX_PNP_ADD_DEVICE,
                    &NBPnPInfo);

                IPX_DEBUG(AUTO_DETECT, ("IPX_PNP_ADD_DEVICE (lineup) to NB: net addr: %lx\n", Binding->LocalAddress.NetworkAddress));
            }

            //
            // Register this address with the TDI clients.
            //
            RtlCopyMemory (Device->TdiRegistrationAddress->Address, &Binding->LocalAddress, sizeof(TDI_ADDRESS_IPX));

            if ((ntStatus = TdiRegisterNetAddress(
                            Device->TdiRegistrationAddress,
#if     defined(_PNP_POWER_)
                            &IpxDeviceName,
                            NULL,
#endif _PNP_POWER_
                            &Binding->TdiRegistrationHandle)) != STATUS_SUCCESS) {

                IPX_DEBUG(PNP, ("TdiRegisterNetAddress failed: %lx", ntStatus));
            }
        }

        //
        // Indicate to the upper drivers.
        //
        //
        // Give line up to RIP as it is not PnP aware.
        //
        if (Device->UpperDriverBound[IDENTIFIER_RIP]) {
                Binding->IsnInformed[IDENTIFIER_RIP] = TRUE;
                (*Device->UpperDrivers[IDENTIFIER_RIP].LineUpHandler)(
                    Binding->NicId,
                    &LineInfo,
                    NdisMediumWan,
                    &Configuration);
        }

    //
    // Add router entry for this net since it was not done on LineUp.
    // Also, update the addresses' pre-constructed local IPX address.
    //
    {
        ULONG CurrentHash;
        PADAPTER    Adapter = Binding->Adapter;
        PADDRESS    Address;

        //
        // Add a router entry for this net if there is no router.
        // We want the number of ticks for a 576-byte frame,
        // given the link speed in 100 bps units, so we calculate
        // as:
        //
        //        seconds          18.21 ticks   4608 bits
        // --------------------- * ----------- * ---------
        // link_speed * 100 bits     second        frame
        //
        // to get the formula
        //
        // ticks/frame = 839 / link_speed.
        //
        // We add link_speed to the numerator also to ensure
        // that the value is at least 1.
        //

        if ((!Device->UpperDriverBound[IDENTIFIER_RIP]) &&
            (*(UNALIGNED ULONG *)Configuration.Network != 0)) {

            if (RipInsertLocalNetwork(
                     *(UNALIGNED ULONG *)Configuration.Network,
                     Binding->NicId,
                     Adapter->NdisBindingHandle,
                     (USHORT)((839 + Binding->MediumSpeed) / Binding->MediumSpeed)) != STATUS_SUCCESS) {

                //
                // This means we couldn't allocate memory, or
                // the entry already existed. If it already
                // exists we can ignore it for the moment.
                //
                // Now it will succeed if the network exists.
                //

                IPX_DEBUG (WAN, ("Line up, could not insert local network\n"));
                // [FW] Binding->LineUp = FALSE;
                Binding->LineUp = LINE_DOWN;
                return STATUS_SUCCESS;
            }
        }

        //
        // Update the device node and all the address
        // nodes if we have only one bound, or this is
        // binding one.
        //

        if (!Device->VirtualNetwork) {

            if ((!Device->MultiCardZeroVirtual) || (Binding->NicId == 1)) {
                Device->SourceAddress.NetworkAddress = *(UNALIGNED ULONG *)(Configuration.Network);
                RtlCopyMemory (Device->SourceAddress.NodeAddress, Configuration.LocalNode, 6);
            }

            //
            // Scan through all the addresses that exist and modify
            // their pre-constructed local IPX address to reflect
            // the new local net and node.
            //

            IPX_GET_LOCK (&Device->Lock, &LockHandle);

            for (CurrentHash = 0; CurrentHash < IPX_ADDRESS_HASH_COUNT; CurrentHash++) {

                for (p = Device->AddressDatabases[CurrentHash].Flink;
                     p != &Device->AddressDatabases[CurrentHash];
                     p = p->Flink) {

                     Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

                     Address->LocalAddress.NetworkAddress = *(UNALIGNED ULONG *)Configuration.Network;
                     RtlCopyMemory (Address->LocalAddress.NodeAddress, Configuration.LocalNode, 6);
                }
            }

            IPX_FREE_LOCK (&Device->Lock, LockHandle);

        }
    }



    //
    // [FW] IpxWan config state will not be entered if only the line params are getting
    // updated.
    //
    // if (!UpdateLineUp) {

        //
        // Instead of the check for ConnectionClient, use the DialOutAsync flag
        //
        if ((Device->SingleNetworkActive) &&
            /*(LineUp->Configuration.ConnectionClient == 1)*/
            Binding->DialOutAsync) {

            //
            // Drop all entries in the database if rip is not bound.
            //

            if (!Device->UpperDriverBound[IDENTIFIER_RIP]) {
                RipDropRemoteEntries();
            }

            Device->ActiveNetworkWan = TRUE;

            //
            // Find a queued line change and complete it.
            //

            if ((p = ExInterlockedRemoveHeadList(
                           &Device->LineChangeQueue,
                           &Device->Lock)) != NULL) {

                Request = LIST_ENTRY_TO_REQUEST(p);

                IoAcquireCancelSpinLock( &irql );
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock( irql );

                REQUEST_STATUS(Request) = STATUS_SUCCESS;

                //
                // NwRdr assumes that Line-up completions are at DPC
                //
                KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
                IpxCompleteRequest (Request);
                KeLowerIrql(OldIrql);

                IpxFreeRequest (Device, Request);

                IpxDereferenceDevice (Device, DREF_LINE_CHANGE);

            }

        }

	//
	// If we have a virtual net, do a broadcast now so
	// the router on the other end will know about us.
	//
	// Use RipSendResponse, and do it even
	// if SingleNetworkActive is FALSE??
	//

	if (Device->RipResponder && Binding->DialOutAsync) {
	    (VOID)RipQueueRequest (Device->VirtualNetworkNumber, RIP_RESPONSE);
	}

        //
        // Find a queued address notify and complete it.
        // If WanGlobalNetworkNumber is TRUE, we only do
        // this when the first dialin line comes up.
        //

        if ((!Device->WanGlobalNetworkNumber ||
             (!Device->GlobalNetworkIndicated && !Binding->DialOutAsync))
                            &&
            ((p = ExInterlockedRemoveHeadList(
                       &Device->AddressNotifyQueue,
                       &Device->Lock)) != NULL)) {

            if (Device->WanGlobalNetworkNumber) {
                Device->GlobalWanNetwork = Binding->LocalAddress.NetworkAddress;
                Device->GlobalNetworkIndicated = TRUE;
            }

            Request = LIST_ENTRY_TO_REQUEST(p);
            NdisBuffer = REQUEST_NDIS_BUFFER(Request);
            NdisQueryBufferSafe (REQUEST_NDIS_BUFFER(Request), (PVOID *)&NwlinkAction, &BufferLength, HighPagePriority);

	    if (NwlinkAction == NULL) {
	       return STATUS_INSUFFICIENT_RESOURCES; 
	    }

            IpxAddressData = (PIPX_ADDRESS_DATA)(NwlinkAction->Data);

            if (Device->WanGlobalNetworkNumber) {
                IpxAddressData->adapternum = Device->SapNicCount - 1;
            } else {
                IpxAddressData->adapternum = Binding->NicId - 1;
            }
            *(UNALIGNED ULONG *)IpxAddressData->netnum = Binding->LocalAddress.NetworkAddress;
            RtlCopyMemory(IpxAddressData->nodenum, Binding->LocalAddress.NodeAddress, 6);
            IpxAddressData->wan = TRUE;
            IpxAddressData->status = TRUE;
            IpxAddressData->maxpkt = Binding->AnnouncedMaxDatagramSize; // Use real?
            IpxAddressData->linkspeed = Binding->MediumSpeed;

            IoAcquireCancelSpinLock( &irql );
            IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
            IoReleaseCancelSpinLock( irql );

            REQUEST_STATUS(Request) = STATUS_SUCCESS;
            IpxCompleteRequest (Request);
            IpxFreeRequest (Device, Request);

            IpxDereferenceDevice (Device, DREF_ADDRESS_NOTIFY);
        }

        Binding->fInfoIndicated = FALSE;
        if ((p = ExInterlockedRemoveHeadList(
                &Device->NicNtfQueue,
                &Device->Lock)) != NULL)
        {
            Request = LIST_ENTRY_TO_REQUEST(p);

            IPX_DEBUG(BIND, ("IpxStatus: WAN LINE UP\n"));
            Status = GetNewNics(Device, Request, FALSE, NULL, 0, TRUE);
            if (Status == STATUS_PENDING)
            {
                IPX_DEBUG(BIND, ("WANLineUp may not be responding properly\n"));
            }
            else
            {
                IoAcquireCancelSpinLock(&OldIrq);
                IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
                IoReleaseCancelSpinLock(OldIrq);

                REQUEST_STATUS(Request) = Status;
                IpxCompleteRequest (Request);
                IpxFreeRequest (Device, Request);
                IpxDereferenceDevice (Device, DREF_NIC_NOTIFY);
            }
        }
//  }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\address.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    address.c

Abstract:

    This module contains code which implements the ADDRESS object.
    Routines are provided to create, destroy, reference, and dereference,
    transport address objects.

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

	Sanjay Anand (SanjayAn) 3-Oct-1995
	Changes to support transfer of buffer ownership to transports - tagged [CH]

--*/

#include "precomp.h"
#pragma hdrstop


//
// Map all generic accesses to the same one.
//

static GENERIC_MAPPING AddressGenericMapping =
       { READ_CONTROL, READ_CONTROL, READ_CONTROL, READ_CONTROL };



TDI_ADDRESS_IPX UNALIGNED *
IpxParseTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress
    )

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, looking for an address
    of type TDI_ADDRESS_TYPE_IPX.

Arguments:

    Transport - The generic TDI address.

Return Value:

    A pointer to the IPX address, or NULL if none is found.

--*/

{
    TA_ADDRESS * addressName;
    INT i;

    addressName = &TransportAddress->Address[0];

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the IPX one.
    //

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->AddressType == TDI_ADDRESS_TYPE_IPX) {
            if (addressName->AddressLength >= sizeof(TDI_ADDRESS_IPX)) {
                return ((TDI_ADDRESS_IPX UNALIGNED *)(addressName->Address));
            }
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }
    return NULL;

}   /* IpxParseTdiAddress */


BOOLEAN
IpxValidateTdiAddress(
    IN TRANSPORT_ADDRESS UNALIGNED * TransportAddress,
    IN ULONG TransportAddressLength
    )

/*++

Routine Description:

    This routine scans a TRANSPORT_ADDRESS, verifying that the
    components of the address do not extend past the specified
    length.

Arguments:

    TransportAddress - The generic TDI address.

    TransportAddressLength - The specific length of TransportAddress.

Return Value:

    TRUE if the address is valid, FALSE otherwise.

--*/

{
    PUCHAR AddressEnd = ((PUCHAR)TransportAddress) + TransportAddressLength;
    TA_ADDRESS * addressName;
    INT i;

    if (TransportAddressLength < sizeof(TransportAddress->TAAddressCount)) {
        IpxPrint0 ("IpxValidateTdiAddress: runt address\n");
        return FALSE;
    }

    addressName = &TransportAddress->Address[0];

    for (i=0;i<TransportAddress->TAAddressCount;i++) {
        if (addressName->Address > AddressEnd) {
            IpxPrint0 ("IpxValidateTdiAddress: address too short\n");
            return FALSE;
        }
        addressName = (TA_ADDRESS *)(addressName->Address +
                                                addressName->AddressLength);
    }

    if ((PUCHAR)addressName > AddressEnd) {
        IpxPrint0 ("IpxValidateTdiAddress: address too short\n");
        return FALSE;
    }
    return TRUE;

}   /* IpxValidateTdiAddress */

#if DBG

VOID
IpxBuildTdiAddress(
    IN PVOID AddressBuffer,
    IN ULONG Network,
    IN UCHAR Node[6],
    IN USHORT Socket
    )

/*++

Routine Description:

    This routine fills in a TRANSPORT_ADDRESS in the specified
    buffer, given the socket, network and node.

Arguments:

    AddressBuffer - The buffer that will hold the address.

    Network - The network number.

    Node - The node address.

    Socket - The socket.

Return Value:

    None.

--*/

{
    TA_IPX_ADDRESS UNALIGNED * IpxAddress;

    IpxAddress = (TA_IPX_ADDRESS UNALIGNED *)AddressBuffer;

    IpxAddress->TAAddressCount = 1;
    IpxAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    IpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    IpxAddress->Address[0].Address[0].NetworkAddress = Network;
    IpxAddress->Address[0].Address[0].Socket = Socket;
    RtlCopyMemory(IpxAddress->Address[0].Address[0].NodeAddress, Node, 6);

}   /* IpxBuildTdiAddress */
#endif


NTSTATUS
IpxOpenAddress(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

{
   return(IpxOpenAddressM(Device, Request, 0));
}



NTSTATUS
IpxOpenAddressM(
    IN PDEVICE Device,
    IN PREQUEST Request,
    IN ULONG     Index
    )
/*++

Routine Description:

    This routine opens a file that points to an existing address object, or, if
    the object doesn't exist, creates it (note that creation of the address
    object includes registering the address, and may take many seconds to
    complete, depending upon system configuration).

    If the address already exists, and it has an ACL associated with it, the
    ACL is checked for access rights before allowing creation of the address.

Arguments:

    Device - pointer to the device describing the IPX transport.

    Request - a pointer to the request used for the creation of the address.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS status;
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    PFILE_FULL_EA_INFORMATION ea;
    TRANSPORT_ADDRESS UNALIGNED *name;
    TA_ADDRESS *AddressName;
    USHORT Socket;
    ULONG DesiredShareAccess;
    CTELockHandle LockHandle;
    PACCESS_STATE AccessState;
    ACCESS_MASK GrantedAccess;
    BOOLEAN AccessAllowed;
    int i;
    BOOLEAN found = FALSE;
#ifdef ISN_NT
    PIRP Irp = (PIRP)Request;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
#endif
    INT Size = 0;

    //
    // If we are a dedicated router, we cannot let addresses
    // be opened.
    //

    if (Device->DedicatedRouter  && (REQUEST_CODE(Request) != MIPX_RT_CREATE)) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // The network name is in the EA, passed in the request.
    //

    ea = OPEN_REQUEST_EA_INFORMATION(Request);
    if (ea == NULL) {
        IpxPrint1("OpenAddress: REQUEST %lx has no EA\n", Request);
        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    //
    // this may be a valid name; parse the name from the EA and use it if OK.
    //

    name = (PTRANSPORT_ADDRESS)&ea->EaName[ea->EaNameLength+1];

    //
    // 126042
    //
    if (ea->EaValueLength < (sizeof(TRANSPORT_ADDRESS) -1)) {

        IPX_DEBUG(ADDRESS, ("The ea value length does not match the TA address length\n"));
        DbgPrint("IPX: STATUS_INVALID_EA_NAME - 1\n");
        return STATUS_INVALID_EA_NAME;

    }

    AddressName = (PTA_ADDRESS)&name->Address[0];
    Size = FIELD_OFFSET(TRANSPORT_ADDRESS, Address) + FIELD_OFFSET(TA_ADDRESS, Address) + AddressName->AddressLength;

    //
    // The name can be passed with multiple entries; we'll take and use only
    // the first one of type IPX.
    //

    //DbgPrint("Size (%d) & EaValueLength (%d)", Size, ea->EaValueLength);
    if (Size > ea->EaValueLength) {
        DbgPrint("EA:%lx, Name:%lx, AddressName:%lx\n", ea, name, AddressName);
        CTEAssert(FALSE);
    }

    for (i=0;i<name->TAAddressCount;i++) {

        //
        // 126042
        //
        if (Size > ea->EaValueLength) {

            IPX_DEBUG(ADDRESS, ("The EA value length does not match the TA address length (2)\n"));

            DbgPrint("IPX: STATUS_INVALID_EA_NAME - 2\n");

            return STATUS_INVALID_EA_NAME;

        }

        if (AddressName->AddressType == TDI_ADDRESS_TYPE_IPX) {
            if (AddressName->AddressLength >= sizeof(TDI_ADDRESS_IPX)) {
                Socket = ((TDI_ADDRESS_IPX UNALIGNED *)&AddressName->Address[0])->Socket;
                found = TRUE;
            }
            break;

        } else {

            AddressName = (PTA_ADDRESS)(AddressName->Address +
                                        AddressName->AddressLength);

            Size += FIELD_OFFSET(TA_ADDRESS, Address);

            if (Size < ea->EaValueLength) {

                Size += AddressName->AddressLength;

            } else {

                break;

            }

        }


    }

    if (!found) {
        IPX_DEBUG (ADDRESS, ("OpenAddress, request %lx has no IPX Address\n", Request));
        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    if (Socket == 0) {

        Socket = IpxAssignSocket (Device);

        if (Socket == 0) {
            IPX_DEBUG (ADDRESS, ("OpenAddress, no unique socket found\n"));
#ifdef  SNMP
            ++IPX_MIB_ENTRY(Device, SysOpenSocketFails);
#endif  SNMP
            return STATUS_INSUFFICIENT_RESOURCES;
        } else {
            IPX_DEBUG (ADDRESS, ("OpenAddress, assigned socket %lx\n", REORDER_USHORT(Socket)));
        }

    } else {

        IPX_DEBUG (ADDRESS, ("OpenAddress, socket %lx\n", REORDER_USHORT(Socket)));

    }

    //
    // get an address file structure to represent this address.
    //

    AddressFile = IpxCreateAddressFile (Device);

    if (AddressFile == (PADDRESS_FILE)NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // We mark this socket specially.
    //

    if (Socket == SAP_SOCKET) {
        AddressFile->IsSapSocket = TRUE;
        AddressFile->SpecialReceiveProcessing = TRUE;
    }

    //
    // See if this address is already established.  This call automatically
    // increments the reference count on the address so that it won't disappear
    // from underneath us after this call but before we have a chance to use it.
    //
    // To ensure that we don't create two address objects for the
    // same address, we hold the device context addressResource until
    // we have found the address or created a new one.
    //

    KeEnterCriticalRegion(); 

    ExAcquireResourceExclusiveLite (&Device->AddressResource, TRUE);

    CTEGetLock (&Device->Lock, &LockHandle);

    Address = IpxLookupAddress (Device, Socket);

    if (Address == NULL) {

        CTEFreeLock (&Device->Lock, LockHandle);

        //
        // This address doesn't exist. Create it.
        // registering it.
        //

        Address = IpxCreateAddress (
                    Device,
                    Socket);

        if (Address != (PADDRESS)NULL) {

            //
            // Set this now in case we have to deref.
            //

            AddressFile->AddressLock = &Address->Lock;

            if (REQUEST_CODE(Request) == MIPX_RT_CREATE) {
               Address->RtAdd = TRUE;
               Address->Index = Index;
            } else {
               Address->RtAdd = FALSE;
            }

#ifdef ISN_NT

            //
            // Initialize the shared access now. We use read access
            // to control all access.
            //

            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            IoSetShareAccess(
                FILE_READ_DATA,
                DesiredShareAccess,
                IrpSp->FileObject,
                &Address->u.ShareAccess);


            //
            // Assign the security descriptor (need to do this with
            // the spinlock released because the descriptor is not
            // mapped).
            //

            AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

            status = SeAssignSecurity(
                         NULL,                       // parent descriptor
                         AccessState->SecurityDescriptor,
                         &Address->SecurityDescriptor,
                         FALSE,                      // is directory
                         &AccessState->SubjectSecurityContext,
                         &AddressGenericMapping,
                         NonPagedPool);

            if (!NT_SUCCESS(status)) {

                //
                // Error, return status.
                //

                IoRemoveShareAccess (IrpSp->FileObject, &Address->u.ShareAccess);
                ExReleaseResourceLite (&Device->AddressResource);
		KeLeaveCriticalRegion(); 
                IpxDereferenceAddress (Address, AREF_ADDRESS_FILE);
                IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);
                return status;

            }

#endif

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion(); 

            //
            // if the adapter isn't ready, we can't do any of this; get out
            //

            if (Device->State == DEVICE_STATE_STOPPING) {
                IpxDereferenceAddress (Address, AREF_ADDRESS_FILE);
                IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);
                status = STATUS_DEVICE_NOT_READY;

            } else {

                REQUEST_OPEN_CONTEXT(Request) = (PVOID)AddressFile;
                REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;
#ifdef ISN_NT
                AddressFile->FileObject = IrpSp->FileObject;
#endif
                AddressFile->Request = Request;
                AddressFile->Address = Address;

                CTEGetLock (&Address->Lock, &LockHandle);
                InsertTailList (&Address->AddressFileDatabase, &AddressFile->Linkage);
                CTEFreeLock (&Address->Lock, LockHandle);

                AddressFile->Request = NULL;
                AddressFile->State = ADDRESSFILE_STATE_OPEN;
                status = STATUS_SUCCESS;

            }

        } else {

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion(); 

            //
            // If the address could not be created, and is not in the
            // process of being created, then we can't open up an address.
            // Since we can't use the AddressLock to deref, we just destroy
            // the address file.
            //

            IpxDestroyAddressFile (AddressFile);

	    // 288208
	    status = STATUS_INSUFFICIENT_RESOURCES; 
	    
        }

    } else {

        CTEFreeLock (&Device->Lock, LockHandle);

        IPX_DEBUG (ADDRESS, ("Add to address %lx\n", Address));

        //
        // We never allow shared access to a RT address.  So, check that
        // we don't have a "RT address create" request and also that the
        // address has not only been taken up by a RT Address request. If
        // and only if both the above
        //
        if ((REQUEST_CODE(Request) != MIPX_RT_CREATE) && (!Address->RtAdd))
        {
        //
        // Set this now in case we have to deref.
        //

        AddressFile->AddressLock = &Address->Lock;

        //
        // The address already exists.  Check the ACL and see if we
        // can access it.  If so, simply use this address as our address.
        //

#ifdef ISN_NT

        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

        AccessAllowed = SeAccessCheck(
                            Address->SecurityDescriptor,
                            &AccessState->SubjectSecurityContext,
                            FALSE,                   // tokens locked
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                            (ACCESS_MASK)0,             // previously granted
                            NULL,                    // privileges
                            &AddressGenericMapping,
                            Irp->RequestorMode,
                            &GrantedAccess,
                            &status);

#else   // ISN_NT

        AccessAllowed = TRUE;

#endif  // ISN_NT

        if (!AccessAllowed) {

            ExReleaseResourceLite (&Device->AddressResource);
            KeLeaveCriticalRegion(); 

            IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

        } else {

#ifdef ISN_NT

            //
            // NtBug: 132051. Make sure you dont give more access than reqd.
            //
            AccessState->PreviouslyGrantedAccess |= GrantedAccess;
            AccessState->RemainingDesiredAccess &= ~( GrantedAccess | MAXIMUM_ALLOWED );

            //
            // Now check that we can obtain the desired share
            // access. We use read access to control all access.
            //

            DesiredShareAccess = (ULONG)
                (((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
                  (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) ?
                        FILE_SHARE_READ : 0);

            status = IoCheckShareAccess(
                         FILE_READ_DATA,
                         DesiredShareAccess,
                         IrpSp->FileObject,
                         &Address->u.ShareAccess,
                         TRUE);

#else   // ISN_NT

            status = STATUS_SUCCESS;

#endif  // ISN_NT

            if (!NT_SUCCESS (status)) {

                ExReleaseResourceLite (&Device->AddressResource);
                KeLeaveCriticalRegion(); 

                IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

            } else {

                ExReleaseResourceLite (&Device->AddressResource);
                KeLeaveCriticalRegion(); 

                CTEGetLock (&Address->Lock, &LockHandle);

                InsertTailList (
                    &Address->AddressFileDatabase,
                    &AddressFile->Linkage);

                AddressFile->Request = NULL;
                AddressFile->Address = Address;
#ifdef ISN_NT
                AddressFile->FileObject = IrpSp->FileObject;
#endif
                AddressFile->State = ADDRESSFILE_STATE_OPEN;

                IpxReferenceAddress (Address, AREF_ADDRESS_FILE);

                REQUEST_OPEN_CONTEXT(Request) = (PVOID)AddressFile;
                REQUEST_OPEN_TYPE(Request) = (PVOID)TDI_TRANSPORT_ADDRESS_FILE;

                CTEFreeLock (&Address->Lock, LockHandle);

                status = STATUS_SUCCESS;

            }
        }
        }
        else
        {
                    DbgPrint("IpxOpenAddress: ACCESS DENIED - duplicate address\n");
                    status = STATUS_ACCESS_DENIED;
                    ExReleaseResourceLite (&Device->AddressResource);
                    KeLeaveCriticalRegion(); 
                    IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

        }

        //
        // Remove the reference from IpxLookupAddress.
        //

        IpxDereferenceAddress (Address, AREF_LOOKUP);
    }

    return status;

}   /* IpxOpenAddress */



USHORT
IpxAssignSocket(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine assigns a socket that is unique within a range
    of SocketUniqueness.

Arguments:

    Device - Pointer to the device context.

Return Value:

    The assigned socket number, or 0 if a unique one cannot
    be found.

--*/

{
    USHORT InitialSocket, CurrentSocket, AddressSocket;
    ULONG CurrentHash;
    BOOLEAN Conflict;
    PLIST_ENTRY p;
    PADDRESS Address;
    CTELockHandle LockHandle;

    //
    // Loop through all possible sockets, starting at
    // Device->CurrentSocket, looking for a suitable one.
    // Device->CurrentSocket rotates through the possible
    // sockets to improve the chances of finding one
    // quickly.
    //

    CTEGetLock (&Device->Lock, &LockHandle);

    InitialSocket = Device->CurrentSocket;
    Device->CurrentSocket = (USHORT)(Device->CurrentSocket + Device->SocketUniqueness);
    if ((USHORT)(Device->CurrentSocket+Device->SocketUniqueness) > Device->SocketEnd) {
        Device->CurrentSocket = Device->SocketStart;
    }

    CurrentSocket = InitialSocket;

    do {

        //
        // Scan all addresses; if we find one with a socket
        // that conflicts with this one, we can't use it.
        //
        // NOTE: Device->Lock is acquired here.
        //

        Conflict = FALSE;

        for (CurrentHash = 0; CurrentHash < IPX_ADDRESS_HASH_COUNT; CurrentHash++) {

            for (p = Device->AddressDatabases[CurrentHash].Flink;
                 p != &Device->AddressDatabases[CurrentHash];
                 p = p->Flink) {

                 Address = CONTAINING_RECORD (p, ADDRESS, Linkage);
                 AddressSocket = REORDER_USHORT(Address->Socket);

                 if ((AddressSocket + Device->SocketUniqueness > CurrentSocket) &&
                         (AddressSocket < CurrentSocket + Device->SocketUniqueness)) {
                     Conflict = TRUE;
                     break;
                 }
            }

            //
            // If we've found a conflict, no need to check the other
            // queues.
            //

            if (Conflict) {
                break;
            }
        }

        CTEFreeLock (&Device->Lock, LockHandle);

        //
        // We intentionally free the lock here so that we
        // never spend too much time with it held.
        //

        if (!Conflict) {

            //
            // We went through the address list without
            // finding a conflict; use this socket.
            //

            return REORDER_USHORT(CurrentSocket);
        }

        CurrentSocket = (USHORT)(CurrentSocket + Device->SocketUniqueness);
        if ((USHORT)(CurrentSocket+Device->SocketUniqueness) > Device->SocketEnd) {
            CurrentSocket = Device->SocketStart;
        }

        CTEGetLock (&Device->Lock, &LockHandle);

    } while (CurrentSocket != InitialSocket);

    CTEFreeLock (&Device->Lock, LockHandle);

    //
    // Could not find one to assign.
    //

    return (USHORT)0;

}   /* IpxAssignSocket */


PADDRESS
IpxCreateAddress(
    IN PDEVICE Device,
    IN USHORT Socket
    )

/*++

Routine Description:

    This routine creates a transport address and associates it with
    the specified transport device context.  The reference count in the
    address is automatically set to 1, and the reference count of the
    device context is incremented.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

    Socket - The socket to assign to this address.

Return Value:

    The newly created address, or NULL if none can be allocated.

--*/

{
    PADDRESS Address;
    PIPX_SEND_RESERVED SendReserved;
    PIPX_RECEIVE_RESERVED ReceiveReserved;
    NDIS_STATUS Status;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    Address = (PADDRESS)IpxAllocateMemory (sizeof(ADDRESS), MEMORY_ADDRESS, "Address");
    if (Address == NULL) {
        IPX_DEBUG (ADDRESS, ("Create address %lx failed\n", REORDER_USHORT(Socket)));
        return NULL;
    }

    IPX_DEBUG (ADDRESS, ("Create address %lx (%lx)\n", Address, REORDER_USHORT(Socket)));
    RtlZeroMemory (Address, sizeof(ADDRESS));

#ifndef IPX_OWN_PACKETS
    IpxAllocateSingleSendPacket(Device, &Address->SendPacket, &Status);
    if (Status != NDIS_STATUS_SUCCESS) {
        goto Fail1;
    }
#endif

    if (IpxInitializeSendPacket (Device, &Address->SendPacket, Address->SendPacketHeader) != STATUS_SUCCESS) {
#ifndef IPX_OWN_PACKETS
Fail1:
#endif
        Address->SendPacketInUse = TRUE;
    } else {
        SendReserved = SEND_RESERVED(&Address->SendPacket);
        SendReserved->Address = Address;
        SendReserved->OwnedByAddress = TRUE;
        Address->SendPacketInUse = FALSE;
#ifdef IPX_TRACK_POOL
        SendReserved->Pool = NULL;
#endif
    }


#if BACK_FILL
    {
       PIPX_SEND_RESERVED BackFillReserved;

#ifndef IPX_OWN_PACKETS
        IpxAllocateSingleSendPacket(Device, &Address->BackFillPacket, &Status);
        if (Status != NDIS_STATUS_SUCCESS) {
            goto Fail2;
        }
#endif
       if (IpxInitializeBackFillPacket (Device, &Address->BackFillPacket, NULL) != STATUS_SUCCESS) {
#ifndef IPX_OWN_PACKETS
Fail2:
#endif
           Address->BackFillPacketInUse = TRUE;
       } else {
        BackFillReserved = SEND_RESERVED(&Address->BackFillPacket);
        BackFillReserved->Address = Address;
        Address->BackFillPacketInUse = FALSE;
        BackFillReserved->OwnedByAddress = TRUE;
#ifdef IPX_TRACK_POOL
        BackFillReserved->Pool = NULL;
#endif
       }
    }
#endif

#ifndef IPX_OWN_PACKETS
    IpxAllocateSingleReceivePacket(Device, &Address->ReceivePacket, &Status);
    if (Status != NDIS_STATUS_SUCCESS) {
        goto Fail3;
    }
#endif
    if (IpxInitializeReceivePacket (Device, &Address->ReceivePacket) != STATUS_SUCCESS) {
#ifndef IPX_OWN_PACKETS
Fail3:
#endif
        Address->ReceivePacketInUse = TRUE;
    } else {
        ReceiveReserved = RECEIVE_RESERVED(&Address->ReceivePacket);
        ReceiveReserved->Address = Address;
        ReceiveReserved->OwnedByAddress = TRUE;
        Address->ReceivePacketInUse = FALSE;
#ifdef IPX_TRACK_POOL
        ReceiveReserved->Pool = NULL;
#endif
    }

    Address->Type = IPX_ADDRESS_SIGNATURE;
    Address->Size = sizeof (ADDRESS);

    Address->Device = Device;
    Address->DeviceLock = &Device->Lock;
    CTEInitLock (&Address->Lock);

    InitializeListHead (&Address->AddressFileDatabase);

    Address->ReferenceCount = 1;
#if DBG
    Address->RefTypes[AREF_ADDRESS_FILE] = 1;
#endif
    Address->Socket = Socket;
    Address->SendSourceSocket = Socket;

    //
    // Save our local address for building datagrams quickly.
    //

    RtlCopyMemory (&Address->LocalAddress, &Device->SourceAddress, FIELD_OFFSET(TDI_ADDRESS_IPX,Socket));
    Address->LocalAddress.Socket = Socket;

    //
    // Now link this address into the specified device context's
    // address database.  To do this, we need to acquire the spin lock
    // on the device context.
    //

    IPX_GET_LOCK (&Device->Lock, &LockHandle);
    InsertTailList (&Device->AddressDatabases[IPX_HASH_SOCKET(Socket)], &Address->Linkage);
    IPX_FREE_LOCK (&Device->Lock, LockHandle);

    IpxReferenceDevice (Device, DREF_ADDRESS);

    return Address;

}   /* IpxCreateAddress */


NTSTATUS
IpxVerifyAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine is called to verify that the pointer given us in a file
    object is in fact a valid address file object. We also verify that the
    address object pointed to by it is a valid address object, and reference
    it to keep it from disappearing while we use it.

Arguments:

    AddressFile - potential pointer to a ADDRESS_FILE object

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INVALID_ADDRESS otherwise

--*/

{
    CTELockHandle LockHandle;
    NTSTATUS status = STATUS_SUCCESS;
    PADDRESS Address;

    //
    // try to verify the address file signature. If the signature is valid,
    // verify the address pointed to by it and get the address spinlock.
    // check the address's state, and increment the reference count if it's
    // ok to use it. Note that the only time we return an error for state is
    // if the address is closing.
    //

    try {

        if ((AddressFile->Size == sizeof (ADDRESS_FILE)) &&
            (AddressFile->Type == IPX_ADDRESSFILE_SIGNATURE) ) {
//            (AddressFile->State != ADDRESSFILE_STATE_CLOSING) ) {

            Address = AddressFile->Address;

            if ((Address->Size == sizeof (ADDRESS)) &&
                (Address->Type == IPX_ADDRESS_SIGNATURE)    ) {

                CTEGetLock (&Address->Lock, &LockHandle);

                if (!Address->Stopping) {

                    IpxReferenceAddressFileLock (AddressFile, AFREF_VERIFY);

                } else {

                    IpxPrint1("IpxVerifyAddressFile: A %lx closing\n", Address);
                    status = STATUS_INVALID_ADDRESS;
                }

                CTEFreeLock (&Address->Lock, LockHandle);

            } else {

                IpxPrint1("IpxVerifyAddressFile: A %lx bad signature\n", Address);
                status = STATUS_INVALID_ADDRESS;
            }

        } else {

            IpxPrint1("IpxVerifyAddressFile: AF %lx bad signature\n", AddressFile);
            status = STATUS_INVALID_ADDRESS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

         IpxPrint1("IpxVerifyAddressFile: AF %lx exception\n", Address);
         return GetExceptionCode();
    }

    return status;

}   /* IpxVerifyAddressFile */


VOID
IpxDestroyAddress(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This routine destroys a transport address and removes all references
    made by it to other objects in the transport.  The address structure
    is returned to nonpaged system pool. It is assumed
    that the caller has already removed all addressfile structures associated
    with this address.

    It is called from a worker thread queue by IpxDerefAddress when
    the reference count goes to 0.

    This thread is only queued by IpxDerefAddress.  The reason for
    this is that there may be multiple streams of execution which are
    simultaneously referencing the same address object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    Address - Pointer to a transport address structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PADDRESS Address = (PADDRESS)Parameter;
    PDEVICE Device = Address->Device;
    CTELockHandle LockHandle;

    IPX_DEBUG (ADDRESS, ("Destroy address %lx (%lx)\n", Address, REORDER_USHORT(Address->Socket)));

    SeDeassignSecurity (&Address->SecurityDescriptor);

    //
    // Delink this address from its associated device context's address
    // database.  To do this we must spin lock on the device context object,
    // not on the address.
    //

    CTEGetLock (&Device->Lock, &LockHandle);
    RemoveEntryList (&Address->Linkage);
    CTEFreeLock (&Device->Lock, LockHandle);

    if (!Address->SendPacketInUse) {
        IpxDeinitializeSendPacket (Device, &Address->SendPacket);
#ifndef  IPX_OWN_PACKETS
        IpxFreeSingleSendPacket (Device, Address->SendPacket);
#endif
    }

    if (!Address->ReceivePacketInUse) {
        IpxDeinitializeReceivePacket (Device, &Address->ReceivePacket);
#ifndef  IPX_OWN_PACKETS
        IpxFreeSingleReceivePacket (Device, Address->ReceivePacket);
#endif
    }

#if BACK_FILL
    if (!Address->BackFillPacketInUse) {
        IpxDeinitializeBackFillPacket (Device, &Address->BackFillPacket);
#ifndef  IPX_OWN_PACKETS
        IpxFreeSingleSendPacket (Device, Address->BackFillPacket);
#endif
    }
#endif
    IpxFreeMemory (Address, sizeof(ADDRESS), MEMORY_ADDRESS, "Address");

    IpxDereferenceDevice (Device, DREF_ADDRESS);

}   /* IpxDestroyAddress */


#if DBG
VOID
IpxRefAddress(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement(&Address->ReferenceCount);

}   /* IpxRefAddress */


VOID
IpxRefAddressLock(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine increments the reference count on a transport address
    when the device lock is already held.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{

    CTEAssert (Address->ReferenceCount > 0);    // not perfect, but...

    // ++Address->ReferenceCount;
    (VOID)InterlockedIncrement(&Address->ReferenceCount);

}   /* IpxRefAddressLock */
#endif


VOID
IpxDerefAddress(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddress to remove it from the system.

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &Address->ReferenceCount,
                (ULONG)-1,
                Address->DeviceLock);

    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue != 0);

    if (oldvalue == 1) {

#if ISN_NT
        ExInitializeWorkItem(
            &Address->u.DestroyAddressQueueItem,
            IpxDestroyAddress,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.DestroyAddressQueueItem, DelayedWorkQueue);
#else
        IpxDestroyAddress(Address);
#endif

    }

}   /* IpxDerefAddress */


VOID
IpxDerefAddressSync(
    IN PADDRESS Address
    )

/*++

Routine Description:

    This routine dereferences a transport address by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddress to remove it from the system. This routine can
    only be called when we are synchronized (inside an IPX_SYNC_START/
    IPX_SYNC_END pair, with a lock held, or in an indication).

Arguments:

    Address - Pointer to a transport address object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &Address->ReferenceCount,
                (ULONG)-1,
                Address->DeviceLock);

    //
    // If we have deleted all references to this address, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue != 0);

    if (oldvalue == 1) {

#if ISN_NT
        ExInitializeWorkItem(
            &Address->u.DestroyAddressQueueItem,
            IpxDestroyAddress,
            (PVOID)Address);
        ExQueueWorkItem(&Address->u.DestroyAddressQueueItem, DelayedWorkQueue);
#else
        IpxDestroyAddress(Address);
#endif

    }

}   /* IpxDerefAddressSync */


PADDRESS_FILE
IpxCreateAddressFile(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine creates an address file from the pool of ther
    specified device context. The reference count in the
    address is automatically set to 1.

Arguments:

    Device - Pointer to the device context (which is really just
        the device object with its extension) to be associated with the
        address.

Return Value:

    The allocate address file or NULL.

--*/

{
    CTELockHandle LockHandle;
    PADDRESS_FILE AddressFile;

    AddressFile = (PADDRESS_FILE)IpxAllocateMemory (sizeof(ADDRESS_FILE), MEMORY_ADDRESS, "AddressFile");
    if (AddressFile == NULL) {
        IPX_DEBUG (ADDRESS, ("Create address file failed\n"));
        return NULL;
    }

    IPX_DEBUG (ADDRESS, ("Create address file %lx\n", AddressFile));

    RtlZeroMemory (AddressFile, sizeof(ADDRESS_FILE));

    AddressFile->Type = IPX_ADDRESSFILE_SIGNATURE;
    AddressFile->Size = sizeof (ADDRESS_FILE);

    CTEGetLock (&Device->Lock, &LockHandle);

    InitializeListHead (&AddressFile->ReceiveDatagramQueue);

    CTEFreeLock (&Device->Lock, LockHandle);

#if 0
    AddressFile->SpecialReceiveProcessing = FALSE;
    AddressFile->ExtendedAddressing = FALSE;
    AddressFile->ReceiveIpxHeader = FALSE;
    AddressFile->FilterOnPacketType = FALSE;
    AddressFile->DefaultPacketType = 0;
    AddressFile->Address = NULL;
#ifdef ISN_NT
    AddressFile->FileObject = NULL;
#endif
#endif

    AddressFile->Device = Device;
    AddressFile->State = ADDRESSFILE_STATE_OPENING;
    AddressFile->ReferenceCount = 1;
#if DBG
    AddressFile->RefTypes[AFREF_CREATE] = 1;
#endif
    AddressFile->CloseRequest = (PREQUEST)NULL;

    //
    // Initialize the request handlers.
    //

    AddressFile->RegisteredReceiveDatagramHandler = FALSE;
    AddressFile->ReceiveDatagramHandler = TdiDefaultRcvDatagramHandler;
    AddressFile->ReceiveDatagramHandlerContext = NULL;

	//
	// [CH] Added these handlers for chained buffer receives
	//
	AddressFile->RegisteredChainedReceiveDatagramHandler = FALSE;
    AddressFile->ChainedReceiveDatagramHandler = TdiDefaultChainedRcvDatagramHandler;
    AddressFile->ChainedReceiveDatagramHandlerContext = NULL;

    AddressFile->RegisteredErrorHandler = FALSE;
    AddressFile->ErrorHandler = TdiDefaultErrorHandler;
    AddressFile->ErrorHandlerContext = NULL;

    return AddressFile;

}   /* IpxCreateAddressFile */


NTSTATUS
IpxDestroyAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine destroys an address file and removes all references
    made by it to other objects in the transport.

    This routine is only called by IpxDereferenceAddressFile. The reason
    for this is that there may be multiple streams of execution which are
    simultaneously referencing the same address file object, and it should
    not be deleted out from under an interested stream of execution.

Arguments:

    AddressFile Pointer to a transport address file structure to be destroyed.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    CTELockHandle LockHandle, LockHandle1;
    PADDRESS Address;
    PDEVICE Device;
    PREQUEST CloseRequest;

    IPX_DEBUG (ADDRESS, ("Destroy address file %lx\n", AddressFile));

    Address = AddressFile->Address;
    Device = AddressFile->Device;

    if (Address) {

        //
        // This addressfile was associated with an address.
        //

        CTEGetLock (&Address->Lock, &LockHandle);

        //
        // remove this addressfile from the address list and disassociate it from
        // the file handle.
        //

        RemoveEntryList (&AddressFile->Linkage);
        InitializeListHead (&AddressFile->Linkage);

        if (Address->AddressFileDatabase.Flink == &Address->AddressFileDatabase) {

            //
            // This is the last open of this address, it will close
            // due to normal dereferencing but we have to set the
            // CLOSING flag too to stop further references.
            //

            CTEGetLock (&Device->Lock, &LockHandle1);
            Address->Stopping = TRUE;
            if (Device->LastAddress == Address) {
                Device->LastAddress = NULL;
            }
            CTEFreeLock (&Device->Lock, LockHandle1);

        }

        AddressFile->Address = NULL;

#ifdef ISN_NT
        AddressFile->FileObject->FsContext = NULL;
        AddressFile->FileObject->FsContext2 = NULL;
#endif

        CTEFreeLock (&Address->Lock, LockHandle);

        //
        // We will already have been removed from the ShareAccess
        // of the owning address.
        //

        //
        // Now dereference the owning address.
        //

        IpxDereferenceAddress (Address, AREF_ADDRESS_FILE);

    }

    //
    // Save this for later completion.
    //

    CloseRequest = AddressFile->CloseRequest;

    //
    // return the addressFile to the pool of address files
    //

    IpxFreeMemory (AddressFile, sizeof(ADDRESS_FILE), MEMORY_ADDRESS, "AddressFile");

    if (CloseRequest != (PREQUEST)NULL) {
        REQUEST_INFORMATION(CloseRequest) = 0;
        REQUEST_STATUS(CloseRequest) = STATUS_SUCCESS;
        IpxCompleteRequest (CloseRequest);
        IpxFreeRequest (Device, CloseRequest);
    }

    return STATUS_SUCCESS;

}   /* IpxDestroyAddressFile */


#if DBG
VOID
IpxRefAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...

    (VOID)IPX_ADD_ULONG (
            &AddressFile->ReferenceCount,
            1,
            AddressFile->AddressLock);

}   /* IpxRefAddressFile */


VOID
IpxRefAddressFileLock(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.
    IT IS CALLED WITH THE ADDRESS LOCK HELD.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...

    //++AddressFile->ReferenceCount;
    (VOID)InterlockedIncrement(&AddressFile->ReferenceCount);

}   /* IpxRefAddressFileLock */


VOID
IpxRefAddressFileSync(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine increments the reference count on an address file.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{

    CTEAssert (AddressFile->ReferenceCount > 0);   // not perfect, but...

    (VOID)IPX_ADD_ULONG (
            &AddressFile->ReferenceCount,
            1,
            AddressFile->AddressLock);

}   /* IpxRefAddressFileSync */


VOID
IpxDerefAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddressFile to remove it from the system.

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &AddressFile->ReferenceCount,
                (ULONG)-1,
                AddressFile->AddressLock);

    //
    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue > 0);

    if (oldvalue == 1) {
        IpxDestroyAddressFile (AddressFile);
    }

}   /* IpxDerefAddressFile */


VOID
IpxDerefAddressFileSync(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine dereferences an address file by decrementing the
    reference count contained in the structure.  If, after being
    decremented, the reference count is zero, then this routine calls
    IpxDestroyAddressFile to remove it from the system. This routine
    can only be called when we are synchronized (inside an IPX_SYNC_START/
    IPX_SYNC_END pair, with a lock held, or in an indication).

Arguments:

    AddressFile - Pointer to a transport address file object.

Return Value:

    none.

--*/

{
    ULONG oldvalue;

    oldvalue = IPX_ADD_ULONG (
                &AddressFile->ReferenceCount,
                (ULONG)-1,
                AddressFile->AddressLock);

    //
    // If we have deleted all references to this address file, then we can
    // destroy the object.  It is okay to have already released the spin
    // lock at this point because there is no possible way that another
    // stream of execution has access to the address any longer.
    //

    CTEAssert (oldvalue > 0);

    if (oldvalue == 1) {
        IpxDestroyAddressFile (AddressFile);
    }

}   /* IpxDerefAddressFileSync */
#endif


PADDRESS
IpxLookupAddress(
    IN PDEVICE Device,
    IN USHORT Socket
    )

/*++

Routine Description:

    This routine scans the transport addresses defined for the given
    device context and compares them with the specified NETWORK
    NAME values.  If an exact match is found, then a pointer to the
    ADDRESS object is returned, and as a side effect, the reference
    count to the address object is incremented.  If the address is not
    found, then NULL is returned.

    NOTE: This routine must be called with the Device
    spinlock held.

Arguments:

    Device - Pointer to the device object and its extension.

    Socket - The socket to look up.

Return Value:

    Pointer to the ADDRESS object found, or NULL if not found.

--*/

{
    PADDRESS Address;
    PLIST_ENTRY p;
    ULONG Hash = IPX_HASH_SOCKET (Socket);

    p = Device->AddressDatabases[Hash].Flink;

    for (p = Device->AddressDatabases[Hash].Flink;
         p != &Device->AddressDatabases[Hash];
         p = p->Flink) {

        Address = CONTAINING_RECORD (p, ADDRESS, Linkage);

        if (Address->Stopping) {
            continue;
        }

        if (Address->Socket == Socket) {

            //
            // We found the match.  Bump the reference count on the address, and
            // return a pointer to the address object for the caller to use.
            //

            IpxReferenceAddressLock (Address, AREF_LOOKUP);
            return Address;

        }

    }

    //
    // The specified address was not found.
    //

    return NULL;

}   /* IpxLookupAddress */


NTSTATUS
IpxStopAddressFile(
    IN PADDRESS_FILE AddressFile
    )

/*++

Routine Description:

    This routine is called to terminate all activity on an AddressFile and
    destroy the object.  We remove every connection and datagram associated
    with this addressfile from the address database and terminate their
    activity. Then, if there are no other outstanding addressfiles open on
    this address, the address will go away.

Arguments:

    AddressFile - pointer to the addressFile to be stopped

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the request
    is not for a real address.

--*/

{
    CTELockHandle LockHandle;
    PREQUEST Request;
    PADDRESS Address = AddressFile->Address;
    PLIST_ENTRY p;
    KIRQL irql;


    IoAcquireCancelSpinLock( &irql );
    CTEGetLock (&Address->Lock, &LockHandle);

    if (AddressFile->State == ADDRESSFILE_STATE_CLOSING) {
        CTEFreeLock (&Address->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );
        return STATUS_SUCCESS;
    }


    AddressFile->State = ADDRESSFILE_STATE_CLOSING;

    while (!(IsListEmpty(&AddressFile->ReceiveDatagramQueue))) {

        p = RemoveHeadList (&AddressFile->ReceiveDatagramQueue);
        Request = LIST_ENTRY_TO_REQUEST (p);

        REQUEST_INFORMATION(Request) = 0;
        REQUEST_STATUS(Request) = STATUS_NETWORK_NAME_DELETED;
        IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);

        CTEFreeLock(&Address->Lock, LockHandle);
        IoReleaseCancelSpinLock( irql );

        IpxCompleteRequest (Request);
        IpxFreeRequest (Device, Request);

        IpxDereferenceAddressFile (AddressFile, AFREF_RCV_DGRAM);

        IoAcquireCancelSpinLock( &irql );
        CTEGetLock(&Address->Lock, &LockHandle);

    }

    CTEFreeLock(&Address->Lock, LockHandle);
    IoReleaseCancelSpinLock( irql );

    return STATUS_SUCCESS;
}   /* IpxStopAddressFile */


NTSTATUS
IpxCloseAddressFile(
    IN PDEVICE Device,
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine is called to close the addressfile pointed to by a file
    object. If there is any activity to be run down, we will run it down
    before we terminate the addressfile. We remove every connection and
    datagram associated with this addressfile from the address database
    and terminate their activity. Then, if there are no other outstanding
    addressfiles open on this address, the address will go away.

Arguments:

    Request - the close request.

Return Value:

    STATUS_SUCCESS if all is well, STATUS_INVALID_HANDLE if the
    request does not point to a real address.

--*/

{
    PADDRESS Address;
    PADDRESS_FILE AddressFile;
    CTELockHandle LockHandle;

    AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
    AddressFile->CloseRequest = Request;

    //
    // We assume that addressFile has already been verified
    // at this point.
    //

    Address = AddressFile->Address;
    CTEAssert (Address);

    //
    // Remove us from the access info for this address.
    //

    KeEnterCriticalRegion(); 

    ExAcquireResourceExclusiveLite (&Device->AddressResource, TRUE);
#ifdef ISN_NT
    IoRemoveShareAccess (AddressFile->FileObject, &Address->u.ShareAccess);
#endif
    ExReleaseResourceLite (&Device->AddressResource);

    KeLeaveCriticalRegion(); 

    //
    // If this address file had broadcasts enabled, turn it off.
    //

    //
    // Not needed anymore
    //
    /*
    CTEGetLock (&Device->Lock, &LockHandle);
    if (AddressFile->EnableBroadcast) {
        AddressFile->EnableBroadcast = FALSE;
        IpxRemoveBroadcast (Device);
    }
    CTEFreeLock (&Device->Lock, LockHandle);
    */
    IpxStopAddressFile (AddressFile);
    IpxDereferenceAddressFile (AddressFile, AFREF_CREATE);

    return STATUS_PENDING;

}   /* IpxCloseAddressFile */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\config.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Private include file for the ISN IPX module.
    file defines all constants and structures necessary for support of
    the dynamic configuration of ST.

Revision History:

--*/


//
// These are used to index into the Parameters array in CONFIG.
//

#define CONFIG_DEDICATED_ROUTER  0
#define CONFIG_INIT_DATAGRAMS    1
#define CONFIG_MAX_DATAGRAMS     2
#define CONFIG_RIP_AGE_TIME      3
#define CONFIG_RIP_COUNT         4
#define CONFIG_RIP_TIMEOUT       5
#define CONFIG_RIP_USAGE_TIME    6
#define CONFIG_ROUTE_USAGE_TIME  7
#define CONFIG_SOCKET_UNIQUENESS 8
#define CONFIG_SOCKET_START      9
#define CONFIG_SOCKET_END       10
#define CONFIG_VIRTUAL_NETWORK  11
#define CONFIG_MAX_MEMORY_USAGE 12
#define CONFIG_RIP_TABLE_SIZE   13
#define CONFIG_VIRTUAL_OPTIONAL 14
#define CONFIG_ETHERNET_PAD     15
#define CONFIG_ETHERNET_LENGTH  16
#define CONFIG_SINGLE_NETWORK   17
#define CONFIG_DISABLE_DIALOUT_SAP 18
#define CONFIG_DISABLE_DIALIN_NB 19
#define CONFIG_VERIFY_SOURCE_ADDRESS 20

#define CONFIG_PARAMETERS       21

//
// Main configuration structure.
//

typedef struct _CONFIG {

    ULONG Parameters[CONFIG_PARAMETERS];  // index defined above
    NDIS_STRING DeviceName;               // device name exported
    PWSTR RegistryPathBuffer;             // path to config info
    ULONG BindCount;                      // entries in BindingList
    LIST_ENTRY BindingList;               // one per binding
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} CONFIG, * PCONFIG;


//
// These are used to index into the Parameters array in BINDING_CONFIG.
//

#define BINDING_MAX_PKT_SIZE        0
#define BINDING_BIND_SAP            1
#define BINDING_DEFAULT_AUTO_DETECT 2
#define BINDING_SOURCE_ROUTE        3
#define BINDING_ALL_ROUTE_DEF       4
#define BINDING_ALL_ROUTE_BC        5
#define BINDING_ALL_ROUTE_MC        6
#define BINDING_ENABLE_FUNC_ADDR    7
#define BINDING_ENABLE_WAN          8

#define BINDING_PARAMETERS          9


//
// One of these is allocated per adapter we are to bind to.
//

typedef struct _BINDING_CONFIG {

    LIST_ENTRY Linkage;                   // for chaining on BindingList
    NDIS_STRING AdapterName;              // NDIS adapter to bind to
    ULONG FrameTypeCount;                 // number of frame types defined (max. 4)
                                          //  == number of valid entries in arrays:
    ULONG FrameType[ISN_FRAME_TYPE_MAX];  // ISN_FRAME_TYPE_XXX
    ULONG NetworkNumber[ISN_FRAME_TYPE_MAX]; // may be 0
    BOOLEAN AutoDetect[ISN_FRAME_TYPE_MAX]; // remove if net number can't be found
    BOOLEAN DefaultAutoDetect[ISN_FRAME_TYPE_MAX]; // use this if multiple or none found
    ULONG Parameters[BINDING_PARAMETERS]; // index defined above
    PDRIVER_OBJECT DriverObject;          // used for logging errors

} BINDING_CONFIG, * PBINDING_CONFIG;


NTSTATUS
IpxGetConfiguration (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PCONFIG * ConfigPtr
    );

VOID
IpxFreeConfiguration (
    IN PCONFIG Config
    );

VOID
IpxWriteDefaultAutoDetectType(
    IN PUNICODE_STRING RegistryPath,
    IN struct _ADAPTER * Adapter,
    IN ULONG FrameType
    );

NTSTATUS
IpxPnPGetVirtualNetworkNumber (
    IN	PCONFIG	Config
    );

NTSTATUS
IpxPnPGetAdapterParameters(
	IN		PCONFIG			Config,
	IN		PNDIS_STRING	DeviceName,
	IN OUT	PBINDING_CONFIG	Binding
	);

//
// Reconfig info from NCPA --> NDIS --> IPXPnPHandler
// We get a pointer to the RECONFIG Structure in the NET_PNP_EVENT Structure
// This structure is defined below - an array of BOOLEANs.
//

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

typedef struct _RECONFIG {
   ULONG       ulVersion;
   BOOLEAN     VirtualNetworkNumber;
   BOOLEAN     AdapterParameters[RECONFIG_PARAMETERS];
} RECONFIG, *PRECONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\device.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains code which implements the DEVICE_CONTEXT object.
    Routines are provided to reference, and dereference transport device
    context objects.

    The transport device context object is a structure which contains a
    system-defined DEVICE_OBJECT followed by information which is maintained
    by the transport provider, called the context.

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,IpxCreateDevice)
#endif



VOID
IpxRefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine increments the reference count on a device context.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    CTEAssert (Device->ReferenceCount > 0);    // not perfect, but...

    (VOID)InterlockedIncrement(&Device->ReferenceCount);

}   /* IpxRefDevice */


VOID
IpxDerefDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine dereferences a device context by decrementing the
    reference count contained in the structure.  Currently, we don't
    do anything special when the reference count drops to zero, but
    we could dynamically unload stuff then.

Arguments:

    Device - Pointer to a transport device context object.

Return Value:

    none.

--*/

{
    LONG result;
#if DBG
    int i; 
#endif

    result = InterlockedDecrement (&Device->ReferenceCount);

    CTEAssert (result >= 0);
    
    if (result == 0) {
#if DBG
       for (i = 0; i < DREF_TOTAL; i++) {
	  CTEAssert(Device->RefTypes[i] == 0);
       }
#endif
       IpxDestroyDevice (Device);
    }

}   /* IpxDerefDevice */


NTSTATUS
IpxCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING DeviceName,
    IN ULONG SegmentCount,
    IN OUT PDEVICE *DevicePtr
    )

/*++

Routine Description:

    This routine creates and initializes a device context structure.

Arguments:


    DriverObject - pointer to the IO subsystem supplied driver object.

    Device - Pointer to a pointer to a transport device context object.

    SegmentCount - The number of segments in the RIP router table.

    DeviceName - pointer to the name of the device this device object points to.

Return Value:

    STATUS_SUCCESS if all is well; STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE Device;
    ULONG DeviceSize;
    ULONG LocksOffset;
    ULONG SegmentsOffset;
    ULONG DeviceNameOffset;
    UINT i;


    //
    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors) and the RIP fields.
    //

    DeviceSize = sizeof(DEVICE) +
                 (sizeof(CTELock) * SegmentCount) +
                 (sizeof(ROUTER_SEGMENT) * SegmentCount) +
                 DeviceName->Length + sizeof(UNICODE_NULL);

    status = IoCreateDevice(
                 DriverObject,
                 DeviceSize,
                 DeviceName,
                 FILE_DEVICE_TRANSPORT,
                 FILE_DEVICE_SECURE_OPEN,
                 FALSE,
                 &deviceObject);

    if (!NT_SUCCESS(status)) {
        IPX_DEBUG(DEVICE, ("Create device %ws failed %lx\n", DeviceName->Buffer, status));
        return status;
    }

    deviceObject->Flags |= DO_DIRECT_IO;

    Device = (PDEVICE)deviceObject->DeviceExtension;

    IPX_DEBUG(DEVICE, ("Create device %ws succeeded %lx\n", DeviceName->Buffer,Device));

    //
    // Initialize our part of the device context.
    //

    RtlZeroMemory(
        ((PUCHAR)Device) + sizeof(DEVICE_OBJECT),
        sizeof(DEVICE) - sizeof(DEVICE_OBJECT));

    Device->DeviceObject = deviceObject;

    LocksOffset = sizeof(DEVICE);
    SegmentsOffset = LocksOffset + (sizeof(CTELock) * SegmentCount);
    DeviceNameOffset = SegmentsOffset + (sizeof(ROUTER_SEGMENT) * SegmentCount);

    //
    // Set some internal pointers.
    //

    Device->SegmentLocks = (CTELock *)(((PUCHAR)Device) + LocksOffset);
    Device->Segments = (PROUTER_SEGMENT)(((PUCHAR)Device) + SegmentsOffset);
    Device->SegmentCount = SegmentCount;

    for (i = 0; i < SegmentCount; i++) {

        CTEInitLock (&Device->SegmentLocks[i]);
        InitializeListHead (&Device->Segments[i].WaitingForRoute);
        InitializeListHead (&Device->Segments[i].FindWaitingForRoute);
        InitializeListHead (&Device->Segments[i].WaitingLocalTarget);
        InitializeListHead (&Device->Segments[i].WaitingReripNetnum);
        InitializeListHead (&Device->Segments[i].Entries);
        Device->Segments[i].EnumerateLocation = &Device->Segments[i].Entries;

    }

    //
    // Copy over the device name.
    //

    Device->DeviceNameLength = DeviceName->Length + sizeof(WCHAR);
    Device->DeviceName = (PWCHAR)(((PUCHAR)Device) + DeviceNameOffset);
    RtlCopyMemory(
        Device->DeviceName,
        DeviceName->Buffer,
        DeviceName->Length);
    Device->DeviceName[DeviceName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Initialize the reference count.
    //

    Device->ReferenceCount = 1;
#if DBG
    Device->RefTypes[DREF_CREATE] = 1;
#endif

#if DBG
    RtlCopyMemory(Device->Signature1, "IDC1", 4);
    RtlCopyMemory(Device->Signature2, "IDC2", 4);
#endif

    Device->Information.Version = 0x0100;
    Device->Information.MaxSendSize = 0;   // no sends allowed
    Device->Information.MaxDatagramSize = 500;   // 500 bytes
    Device->Information.MaxConnectionUserData = 0;
    Device->Information.ServiceFlags =
        TDI_SERVICE_CONNECTIONLESS_MODE | TDI_SERVICE_BROADCAST_SUPPORTED |
        TDI_SERVICE_ROUTE_DIRECTED | TDI_SERVICE_FORCE_ACCESS_CHECK;
    Device->Information.MinimumLookaheadData = 128;
    Device->Information.NumberOfResources = IPX_TDI_RESOURCES;
    KeQuerySystemTime (&Device->Information.StartTime);

    Device->Statistics.Version = 0x0100;

#if 0
    //
    // These will be filled in after all the binding is done.
    //

    Device->Information.MaxDatagramSize = 0;
    Device->Information.MaximumLookaheadData = 0;


    Device->SourceRoutingUsed = FALSE;
    Device->SourceRoutingTime = 0;
    Device->RipPacketCount = 0;

    Device->RipShortTimerActive = FALSE;
    Device->RipSendTime = 0;
#endif


    //
    // Initialize the resource that guards address ACLs.
    //

    ExInitializeResourceLite (&Device->AddressResource);

	//
	// Init the resource that guards the binding array/indices
	//
	// CTEInitLock (&Device->BindAccessLock);

    InitializeListHead (&Device->WaitingRipPackets);
    CTEInitTimer (&Device->RipShortTimer);
    CTEInitTimer (&Device->RipLongTimer);

    CTEInitTimer (&Device->SourceRoutingTimer);

    //
    // [FW] Initialize the timer used to update inactivity counters
    // on WAN lines.
    //
    CTEInitTimer (&Device->WanInactivityTimer);

    //
    // initialize the various fields in the device context
    //

    CTEInitLock (&Device->Interlock);
    CTEInitLock (&Device->Lock);
    CTEInitLock (&Device->SListsLock);

    Device->ControlChannelIdentifier.QuadPart = 1;

    InitializeListHead (&Device->GlobalSendPacketList);
    InitializeListHead (&Device->GlobalReceivePacketList);
    InitializeListHead (&Device->GlobalReceiveBufferList);
#if BACK_FILL
    InitializeListHead (&Device->GlobalBackFillPacketList);
#endif

    InitializeListHead (&Device->AddressNotifyQueue);
    InitializeListHead (&Device->LineChangeQueue);

    for (i = 0; i < IPX_ADDRESS_HASH_COUNT; i++) {
        InitializeListHead (&Device->AddressDatabases[i]);
    }

#if BACK_FILL
    InitializeListHead (&Device->BackFillPoolList);
#endif
    InitializeListHead (&Device->SendPoolList);
    InitializeListHead (&Device->ReceivePoolList);

    InitializeListHead (&Device->BindingPoolList);

    ExInitializeSListHead (&Device->SendPacketList);
    ExInitializeSListHead (&Device->ReceivePacketList);
#if BACK_FILL
    ExInitializeSListHead (&Device->BackFillPacketList);
#endif

    ExInitializeSListHead (&Device->BindingList);

#if 0
    Device->MemoryUsage = 0;
    Device->SendPacketList.Next = NULL;
    Device->ReceivePacketList.Next = NULL;
    Device->Bindings = NULL;
    Device->BindingCount = 0;
#endif

    KeQuerySystemTime (&Device->IpxStartTime);

    Device->State = DEVICE_STATE_CLOSED;
    Device->AutoDetectState = AUTO_DETECT_STATE_INIT;
    Device->NetPnPEvent = NULL;
    Device->Type = IPX_DEVICE_SIGNATURE;
    Device->Size = sizeof (DEVICE);

#ifdef  SNMP
    //
    // what are the values for these?
    //
    IPX_MIB_ENTRY(Device, SysInstance) = 0;
    IPX_MIB_ENTRY(Device, SysExistState) = 0;
#endif SNMP

    *DevicePtr = Device;
    return STATUS_SUCCESS;

}   /* IpxCreateDevice */


VOID
IpxDestroyDevice(
    IN PDEVICE Device
    )

/*++

Routine Description:

    This routine destroys a device context structure.

Arguments:

    Device - Pointer to a pointer to a transport device context object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY p;
    PSINGLE_LIST_ENTRY s;
    PIPX_SEND_POOL SendPool;
    PIPX_SEND_PACKET SendPacket;
    PIPX_RECEIVE_POOL ReceivePool;
    PIPX_RECEIVE_PACKET ReceivePacket;
    PIPX_ROUTE_ENTRY RouteEntry;
    UINT SendPoolSize;
    UINT ReceivePoolSize;
    UINT i;
#if BACK_FILL
    PIPX_SEND_POOL BackFillPool;
    UINT BackFillPoolSize;
    PIPX_SEND_PACKET BackFillPacket;
#endif

    PIPX_BINDING_POOL BindingPool;
    UINT BindingPoolSize;
    PBINDING Binding;

    CTELockHandle LockHandle;

    IPX_DEBUG (DEVICE, ("Destroy device %lx\n", Device));

    //
    // Take all the packets out of its pools.
    //

    BindingPoolSize = FIELD_OFFSET (IPX_BINDING_POOL, Bindings[0]) +
                       (sizeof(BINDING) * Device->InitBindings);

    while (!IsListEmpty (&Device->BindingPoolList)) {

        p = RemoveHeadList (&Device->BindingPoolList);
        BindingPool = CONTAINING_RECORD (p, IPX_BINDING_POOL, Linkage);
        IPX_DEBUG (PACKET, ("Free binding pool %lx\n", BindingPool));
        IpxFreeMemory (BindingPool, BindingPoolSize, MEMORY_PACKET, "BindingPool");

    }

#if BACK_FILL

    while (s = IPX_POP_ENTRY_LIST(&Device->BackFillPacketList, &Device->Lock)) {
        PIPX_SEND_RESERVED  Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
        IPX_SEND_PACKET BackFillPacket;

        BackFillPacket.Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        IpxDeinitializeBackFillPacket (Device, &BackFillPacket);
        Device->MemoryUsage -= sizeof(IPX_SEND_RESERVED);
    }

    while (!IsListEmpty (&Device->BackFillPoolList)) {

        p = RemoveHeadList (&Device->BackFillPoolList);
        BackFillPool = CONTAINING_RECORD (p, IPX_SEND_POOL, Linkage);

        IPX_DEBUG (PACKET, ("Free packet pool %lx\n", BackFillPool));
        NdisFreePacketPool (BackFillPool->PoolHandle);

        IpxFreeMemory (BackFillPool, sizeof(IPX_SEND_POOL), MEMORY_PACKET, "BafiPool");
    }
#endif

    while (s = IPX_POP_ENTRY_LIST(&Device->SendPacketList, &Device->Lock)){
        PIPX_SEND_RESERVED  Reserved = CONTAINING_RECORD (s, IPX_SEND_RESERVED, PoolLinkage);
        IPX_SEND_PACKET SendPacket;
        PUCHAR  Header = Reserved->Header;

        SendPacket.Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        IpxDeinitializeSendPacket (Device, &SendPacket);
        Device->MemoryUsage -= sizeof(IPX_SEND_RESERVED);
    }

    while (!IsListEmpty (&Device->SendPoolList)) {

        p = RemoveHeadList (&Device->SendPoolList);
        SendPool = CONTAINING_RECORD (p, IPX_SEND_POOL, Linkage);

        IPX_DEBUG (PACKET, ("Free packet pool %lx\n", SendPool));
        NdisFreePacketPool (SendPool->PoolHandle);

        IpxFreeMemory (SendPool->Header, PACKET_HEADER_SIZE * Device->InitDatagrams, MEMORY_PACKET, "SendPool");

        IpxFreeMemory (SendPool, sizeof(IPX_SEND_POOL), MEMORY_PACKET, "SendPool");
    }

    while (s = IPX_POP_ENTRY_LIST(&Device->ReceivePacketList, &Device->Lock)){
        PIPX_RECEIVE_RESERVED Reserved = CONTAINING_RECORD (s, IPX_RECEIVE_RESERVED, PoolLinkage);
        IPX_RECEIVE_PACKET  ReceivePacket;

        ReceivePacket.Packet = CONTAINING_RECORD (Reserved, NDIS_PACKET, ProtocolReserved[0]);

        IpxDeinitializeReceivePacket (Device, &ReceivePacket);
        Device->MemoryUsage -= sizeof(IPX_RECEIVE_RESERVED);
    }

    while (!IsListEmpty (&Device->ReceivePoolList)) {

        p = RemoveHeadList (&Device->ReceivePoolList);
        ReceivePool = CONTAINING_RECORD (p, IPX_RECEIVE_POOL, Linkage);

        IPX_DEBUG (PACKET, ("Free packet pool %lx\n", ReceivePool));
        NdisFreePacketPool (ReceivePool->PoolHandle);

        IpxFreeMemory (ReceivePool, sizeof(IPX_RECEIVE_POOL), MEMORY_PACKET, "ReceivePool");
    }

    //
    // Destroy all rip table entries.
    //

    for (i = 0; i < Device->SegmentCount; i++) {

        RouteEntry = RipGetFirstRoute(i);
        while (RouteEntry != NULL) {

            (VOID)RipDeleteRoute(i, RouteEntry);
            IpxFreeMemory(RouteEntry, sizeof(IPX_ROUTE_ENTRY), MEMORY_RIP, "RouteEntry");
            RouteEntry = RipGetNextRoute(i);

        }

    }

    IPX_DEBUG (DEVICE, ("Final memory use is %d\n", Device->MemoryUsage));
#if DBG
    for (i = 0; i < MEMORY_MAX; i++) {
        if (IpxMemoryTag[i].BytesAllocated != 0) {
            IPX_DEBUG (DEVICE, ("Tag %d: %d bytes left\n", i, IpxMemoryTag[i].BytesAllocated));
        }
    }
#endif

    //
    // If we are being unloaded then someone is waiting for this
    // event to finish the cleanup, since we may be at DISPATCH_LEVEL;
    // otherwise it is during load and we can just kill ourselves here.
    //


    CTEGetLock (&Device->Lock, &LockHandle);

    
    if (Device->UnloadWaiting) {

       CTEFreeLock (&Device->Lock, LockHandle);
       KeSetEvent(
            &Device->UnloadEvent,
            0L,
            FALSE);

    } else {
       CTEFreeLock (&Device->Lock, LockHandle);
       
       CTEAssert (KeGetCurrentIrql() < DISPATCH_LEVEL);
       ExDeleteResourceLite (&Device->AddressResource);
       IoDeleteDevice (Device->DeviceObject);
    }

}   /* IpxDestroyDevice */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\event.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains code which performs the following TDI services:

        o   TdiSetEventHandler

Environment:

    Kernel mode

Revision History:

   Sanjay Anand (SanjayAn) 3-Oct-1995
   Changes to support transfer of buffer ownership to transports

   1. Added a new event type - TDI_EVENT_CHAINED_RECEIVE_DATAGRAM
--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
IpxTdiSetEventHandler(
    IN PREQUEST Request
    )

/*++

Routine Description:

    This routine performs the TdiSetEventHandler request for the
    transport provider.  The caller (request dispatcher) verifies
    that this routine will not be executed on behalf of a user-mode
    client, as this request enables direct callouts at DISPATCH_LEVEL.

Arguments:

    Request - Pointer to the request

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status;
    CTELockHandle LockHandle;
    PTDI_REQUEST_KERNEL_SET_EVENT Parameters;
    PADDRESS_FILE AddressFile;

    //
    // Get the Address this is associated with; if there is none, get out.
    //

    AddressFile  = REQUEST_OPEN_CONTEXT(Request);
    Status = IpxVerifyAddressFile (AddressFile);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    CTEGetLock (&AddressFile->Address->Lock, &LockHandle);

    Parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)REQUEST_PARAMETERS(Request);

    switch (Parameters->EventType) {

    case TDI_EVENT_RECEIVE_DATAGRAM:

        if (Parameters->EventHandler == NULL) {
            AddressFile->ReceiveDatagramHandler =
                (PTDI_IND_RECEIVE_DATAGRAM)TdiDefaultRcvDatagramHandler;
            AddressFile->ReceiveDatagramHandlerContext = NULL;
            AddressFile->RegisteredReceiveDatagramHandler = FALSE;
        } else {
            AddressFile->ReceiveDatagramHandler =
                (PTDI_IND_RECEIVE_DATAGRAM)Parameters->EventHandler;
            AddressFile->ReceiveDatagramHandlerContext = Parameters->EventContext;
            AddressFile->RegisteredReceiveDatagramHandler = TRUE;
        }

        break;
    //
    // [SA] New event handler to receive chained buffers
    //
    case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:

        if (Parameters->EventHandler == NULL) {
            AddressFile->ChainedReceiveDatagramHandler =
                (PTDI_IND_CHAINED_RECEIVE_DATAGRAM)TdiDefaultChainedRcvDatagramHandler;
            AddressFile->ChainedReceiveDatagramHandlerContext = NULL;
            AddressFile->RegisteredChainedReceiveDatagramHandler = FALSE;
        } else {
            AddressFile->ChainedReceiveDatagramHandler =
                (PTDI_IND_CHAINED_RECEIVE_DATAGRAM)Parameters->EventHandler;
            AddressFile->ChainedReceiveDatagramHandlerContext = Parameters->EventContext;
            AddressFile->RegisteredChainedReceiveDatagramHandler = TRUE;
        }

        break;

    case TDI_EVENT_ERROR:

        if (Parameters->EventHandler == NULL) {
            AddressFile->ErrorHandler =
                (PTDI_IND_ERROR)TdiDefaultErrorHandler;
            AddressFile->ErrorHandlerContext = NULL;
            AddressFile->RegisteredErrorHandler = FALSE;
        } else {
            AddressFile->ErrorHandler =
                (PTDI_IND_ERROR)Parameters->EventHandler;
            AddressFile->ErrorHandlerContext = Parameters->EventContext;
            AddressFile->RegisteredErrorHandler = TRUE;
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;

    } /* switch */

    CTEFreeLock (&AddressFile->Address->Lock, LockHandle);

    IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);

    REQUEST_INFORMATION(Request) = 0;

    return Status;

}   /* IpxTdiSetEventHandler */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\nwlink\ipx\driver.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module contains the DriverEntry and other initialization
    code for the IPX module of the ISN transport.

Author:

    Adam Barr (adamba) 2-September-1993

Environment:

    Kernel mode

Revision History:

	Sanjay Anand (SanjayAn) - 22-Sept-1995
	BackFill optimization changes added under #if BACK_FILL

	Sanjay Anand (SanjayAn) 18-Sept-1995
	Changes to support Plug and Play

--*/

#include "precomp.h"
#pragma hdrstop
#define	MODULE	0x60000

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

extern NDIS_HANDLE IpxNdisProtocolHandle; 

#ifdef _PNP_POWER_
#include "ipxpnp.h"
void
IpxDoPnPEvent(
    IN CTEEvent *WorkerThreadEvent,
    IN PVOID Context);

#endif //_PNP_POWER_
//
// Local Function prototypes
//

PWSTR IpxDeviceNameString = L"\\Device\\Nwlnkipx";

VOID
IpxDelayedFreeBindingsArray(
    IN PVOID	Param
);

VOID
IpxPnPCompletionHandler(
                        IN PNET_PNP_EVENT   pnp,
                        IN NTSTATUS         status
                        );

//********** Pageable Routine Declarations  *****
//************************* PAGEIPX **********************************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEIPX, IpxDelayedFreeBindingsArray )
#endif
//********** Pageable Routine Declarations *****


PDEVICE IpxDevice = NULL;
PIPX_PADDING_BUFFER IpxPaddingBuffer = NULL;

#if DBG

UCHAR  IpxTempDebugBuffer[300];
ULONG IpxDebug = 0x0;
ULONG IpxMemoryDebug = 0xffffffd3;
UCHAR IpxDebugMemory[IPX_MEMORY_LOG_SIZE][192];
PUCHAR IpxDebugMemoryLoc = IpxDebugMemory[0];
PUCHAR IpxDebugMemoryEnd = IpxDebugMemory[IPX_MEMORY_LOG_SIZE];

VOID
IpxDebugMemoryLog(
    IN PUCHAR FormatString,
    ...
)

{
    INT ArgLen;
    va_list ArgumentPointer;

    va_start(ArgumentPointer, FormatString);

    //
    // To avoid any overflows, copy this in a temp buffer first.
    RtlZeroMemory (IpxTempDebugBuffer, 300);
    ArgLen = vsprintf(IpxTempDebugBuffer, FormatString, ArgumentPointer);
    va_end(ArgumentPointer);

    if ( ArgLen > 192 ) {
        CTEAssert( FALSE );
    } else {
        RtlZeroMemory (IpxDebugMemoryLoc, 192);
        RtlCopyMemory( IpxDebugMemoryLoc, IpxTempDebugBuffer, ArgLen );

        IpxDebugMemoryLoc += 192;
        if (IpxDebugMemoryLoc >= IpxDebugMemoryEnd) {
            IpxDebugMemoryLoc = IpxDebugMemory[0];
        }
    }
}


DEFINE_LOCK_STRUCTURE(IpxMemoryInterlock);
MEMORY_TAG IpxMemoryTag[MEMORY_MAX];

#endif

DEFINE_LOCK_STRUCTURE(IpxGlobalInterlock);

#if DBG

//
// Use for debug printouts
//

PUCHAR FrameTypeNames[5] = { "Ethernet II", "802.3", "802.2", "SNAP", "Arcnet" };
#define OutputFrameType(_Binding) \
    (((_Binding)->Adapter->MacInfo.MediumType == NdisMediumArcnet878_2) ? \
         FrameTypeNames[4] : \
         FrameTypeNames[(_Binding)->FrameType])
#endif


#ifdef IPX_PACKET_LOG

ULONG IpxPacketLogDebug = IPX_PACKET_LOG_RCV_OTHER | IPX_PACKET_LOG_SEND_OTHER;
USHORT IpxPacketLogSocket = 0;
DEFINE_LOCK_STRUCTURE(IpxPacketLogLock);
IPX_PACKET_LOG_ENTRY IpxPacketLog[IPX_PACKET_LOG_LENGTH];
PIPX_PACKET_LOG_ENTRY IpxPacketLogLoc = IpxPacketLog;
PIPX_PACKET_LOG_ENTRY IpxPacketLogEnd = &IpxPacketLog[IPX_PACKET_LOG_LENGTH];

VOID
IpxLogPacket(
    IN BOOLEAN Send,
    IN PUCHAR DestMac,
    IN PUCHAR SrcMac,
    IN USHORT Length,
    IN PVOID IpxHeader,
    IN PVOID Data
    )

{

    CTELockHandle LockHandle;
    PIPX_PACKET_LOG_ENTRY PacketLog;
    LARGE_INTEGER TickCount;
    ULONG DataLength;

    CTEGetLock (&IpxPacketLogLock, &LockHandle);

    PacketLog = IpxPacketLogLoc;

    ++IpxPacketLogLoc;
    if (IpxPacketLogLoc >= IpxPacketLogEnd) {
        IpxPacketLogLoc = IpxPacketLog;
    }
    *(UNALIGNED ULONG *)IpxPacketLogLoc->TimeStamp = 0x3e3d3d3d;    // "===>"

    CTEFreeLock (&IpxPacketLogLock, LockHandle);

    RtlZeroMemory (PacketLog, sizeof(IPX_PACKET_LOG_ENTRY));

    PacketLog->SendReceive = Send ? '>' : '<';

    KeQueryTickCount(&TickCount);
    _itoa (TickCount.LowPart % 100000, PacketLog->TimeStamp, 10);

    RtlCopyMemory(PacketLog->DestMac, DestMac, 6);
    RtlCopyMemory(PacketLog->SrcMac, SrcMac, 6);
    PacketLog->Length[0] = Length / 256;
    PacketLog->Length[1] = Length % 256;

    if (Length < sizeof(IPX_HEADER)) {
        RtlCopyMemory(&PacketLog->IpxHeader, IpxHeader, Length);
    } else {
        RtlCopyMemory(&PacketLog->IpxHeader, IpxHeader, sizeof(IPX_HEADER));
    }

    DataLength = Length - sizeof(IPX_HEADER);
    if (DataLength < 14) {
        RtlCopyMemory(PacketLog->Data, Data, DataLength);
    } else {
        RtlCopyMemory(PacketLog->Data, Data, 14);
    }

}   /* IpxLogPacket */

#endif // IPX_PACKET_LOG


//
// Forward declaration of various routines used in this module.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// This is now shared with other modules
//

VOID
IpxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IpxDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IpxDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IpxDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

//
// These routines can be called at any time in case of PnP.
//

#endif

UCHAR VirtualNode[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };

//
// This prevents us from having a bss section.
//

ULONG _setjmpexused = 0;

ULONG IpxFailLoad = FALSE;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine performs initialization of the IPX ISN module.
    It creates the device objects for the transport
    provider and performs other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - The name of IPX's node in the registry.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UINT SuccessfulOpens, ValidBindings;
    static const NDIS_STRING ProtocolName = NDIS_STRING_CONST("NWLNKIPX");
    PDEVICE Device;
    PBINDING Binding;
    PADAPTER Adapter;
    ULONG BindingCount, BindingIndex;
    PLIST_ENTRY p;
    ULONG AnnouncedMaxDatagram, RealMaxDatagram, MaxLookahead;
    ULONG LinkSpeed, MacOptions;
    ULONG Temp;
    UINT i;
    BOOLEAN CountedWan;

    PCONFIG Config = NULL;
    PBINDING_CONFIG ConfigBinding;

#if 0
    DbgPrint ("IPX: FailLoad at %lx\n", &IpxFailLoad);

    if (IpxFailLoad) {
        return STATUS_UNSUCCESSFUL;
    }
#endif

    // DbgBreakPoint();
    //
    // This ordering matters because we use it to quickly
    // determine if packets are internally generated or not.
    //

    CTEAssert (IDENTIFIER_NB < IDENTIFIER_IPX);
    CTEAssert (IDENTIFIER_SPX < IDENTIFIER_IPX);
    CTEAssert (IDENTIFIER_RIP < IDENTIFIER_IPX);
    CTEAssert (IDENTIFIER_RIP_INTERNAL > IDENTIFIER_IPX);

    //
    // We assume that this structure is not packet in between
    // the fields.
    //

    CTEAssert (FIELD_OFFSET (TDI_ADDRESS_IPX, Socket) + sizeof(USHORT) == 12);


    //
    // Initialize the Common Transport Environment.
    //

    if (CTEInitialize() == 0) {

        IPX_DEBUG (DEVICE, ("CTEInitialize() failed\n"));
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            101,
            STATUS_UNSUCCESSFUL,
            NULL,
            0,
            NULL);
        return STATUS_UNSUCCESSFUL;
    }

#if DBG
    CTEInitLock (&IpxGlobalInterlock);
    CTEInitLock (&IpxMemoryInterlock);
    for (i = 0; i < MEMORY_MAX; i++) {
        IpxMemoryTag[i].Tag = i;
        IpxMemoryTag[i].BytesAllocated = 0;
    }
#endif
#ifdef IPX_PACKET_LOG
    CTEInitLock (&IpxPacketLogLock);
#endif

#ifdef  IPX_OWN_PACKETS
    CTEAssert (NDIS_PACKET_SIZE == FIELD_OFFSET(NDIS_PACKET, ProtocolReserved[0]));
#endif

    IPX_DEBUG (DEVICE, ("IPX loaded\n"));

    //
    // This allocates the CONFIG structure and returns
    // it in Config.
    //

    status = IpxGetConfiguration(DriverObject, RegistryPath, &Config);

    if (!NT_SUCCESS (status)) {

        //
        // If it failed, it logged an error.
        //

        PANIC (" Failed to initialize transport, IPX initialization failed.\n");
        return status;

    }

    //
    // Initialize the TDI layer.
    //
    
    TdiInitialize();

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction [IRP_MJ_CREATE] = IpxDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLOSE] = IpxDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_CLEANUP] = IpxDispatchOpenClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] = IpxDispatchOpenClose; 
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = IpxDispatchInternal;
    DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = IpxDispatchDeviceControl;

    DriverObject->DriverUnload = IpxUnload;

    SuccessfulOpens = 0;

    status = IpxCreateDevice(
                 DriverObject,
                 &Config->DeviceName,
                 Config->Parameters[CONFIG_RIP_TABLE_SIZE],
                 &Device);

    if (!NT_SUCCESS (status)) {

        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_CREATE_DEVICE,
            801,
            status,
            NULL,
            0,
            NULL);

        IpxFreeConfiguration(Config);
        IpxDeregisterProtocol();
        return status;
    }

    IpxDevice = Device;

    RtlInitUnicodeString(&IpxDeviceName, IpxDeviceNameString);

    //
    // Initialize and keep track of the Init Time Adapters and such.
    //
    IpxDevice->InitTimeAdapters = 1;
    IpxDevice->NoMoreInitAdapters = FALSE;


    status = TdiRegisterProvider(&IpxDeviceName, &IpxDevice->TdiProviderReadyHandle);
	if (!NT_SUCCESS(status))
	{
        IpxFreeConfiguration(Config);
        IpxDeregisterProtocol();
        return status;
	}

    //
    // Save the relevant configuration parameters.
    //

    Device->DedicatedRouter = (BOOLEAN)(Config->Parameters[CONFIG_DEDICATED_ROUTER] != 0);
    Device->InitDatagrams = Config->Parameters[CONFIG_INIT_DATAGRAMS];
    Device->MaxDatagrams = Config->Parameters[CONFIG_MAX_DATAGRAMS];
    Device->RipAgeTime = Config->Parameters[CONFIG_RIP_AGE_TIME];
    Device->RipCount = Config->Parameters[CONFIG_RIP_COUNT];
    Device->RipTimeout =
        ((Config->Parameters[CONFIG_RIP_TIMEOUT] * 500) + (RIP_GRANULARITY/2)) /
            RIP_GRANULARITY;
    Device->RipUsageTime = Config->Parameters[CONFIG_RIP_USAGE_TIME];
    Device->SourceRouteUsageTime = Config->Parameters[CONFIG_ROUTE_USAGE_TIME];
    Device->SocketUniqueness = Config->Parameters[CONFIG_SOCKET_UNIQUENESS];
    Device->SocketStart = (USHORT)Config->Parameters[CONFIG_SOCKET_START];
    Device->SocketEnd = (USHORT)Config->Parameters[CONFIG_SOCKET_END];
    Device->MemoryLimit = Config->Parameters[CONFIG_MAX_MEMORY_USAGE];
    Device->VerifySourceAddress = (BOOLEAN)(Config->Parameters[CONFIG_VERIFY_SOURCE_ADDRESS] != 0);

    Device->InitReceivePackets = (Device->InitDatagrams + 1) / 2;
    Device->InitReceiveBuffers = (Device->InitDatagrams + 1) / 2;

    Device->MaxReceivePackets = 10;
    Device->MaxReceiveBuffers = 10;

    InitializeListHead(&Device->NicNtfQueue);
    InitializeListHead(&Device->NicNtfComplQueue);

    Device->InitBindings = 5;

    //
    // RAS max is 240 (?) + 10 max LAN
    //
    Device->MaxPoolBindings = 250;

#ifdef  SNMP
    IPX_MIB_ENTRY(Device, SysConfigSockets) = (Device->SocketEnd - Device->SocketStart)
                / ((Device->SocketUniqueness > 1) ? Device->SocketUniqueness : 1);
             ;
#endif  SNMP

    //
    // Have to reverse this.
    //

    Device->VirtualNetworkOptional = (BOOLEAN)(Config->Parameters[CONFIG_VIRTUAL_OPTIONAL] != 0);

    Device->CurrentSocket = Device->SocketStart;

    Device->EthernetPadToEven = (BOOLEAN)(Config->Parameters[CONFIG_ETHERNET_PAD] != 0);
    Device->EthernetExtraPadding = (Config->Parameters[CONFIG_ETHERNET_LENGTH] & 0xfffffffe) + 1;

    Device->SingleNetworkActive = (BOOLEAN)(Config->Parameters[CONFIG_SINGLE_NETWORK] != 0);
    Device->DisableDialoutSap = (BOOLEAN)(Config->Parameters[CONFIG_DISABLE_DIALOUT_SAP] != 0);
    Device->DisableDialinNetbios = (UCHAR)(Config->Parameters[CONFIG_DISABLE_DIALIN_NB]);

    //
    // Used later to access the registry.
    //
    Device->RegistryPathBuffer = Config->RegistryPathBuffer;
	Device->RegistryPath.Length = RegistryPath->Length;
	Device->RegistryPath.MaximumLength = RegistryPath->MaximumLength;
	Device->RegistryPath.Buffer = Device->RegistryPathBuffer;

    //
    // Initialize the BroadcastCount now and so, we dont have to
    // init this field per adapter [MS]
    //
    Device->EnableBroadcastCount = 0;

    //
    // ActiveNetworkWan will start as FALSE, which is correct.
    //

    //
    // Allocate our initial packet pool. We do not allocate
    // receive and receive buffer pools until we need them,
    // because in many cases we never do.
    //

#if BACK_FILL
    IpxAllocateBackFillPool (Device);
#endif

    IpxAllocateSendPool (Device);

    IpxAllocateBindingPool (Device);

    //
    // Allocate one 1-byte buffer for odd length packets.
    //

    IpxPaddingBuffer = IpxAllocatePaddingBuffer(Device);

    if ( IpxPaddingBuffer == (PIPX_PADDING_BUFFER)NULL ) {
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_RESOURCE_POOL,
            801,
            STATUS_INSUFFICIENT_RESOURCES,
            NULL,
            0,
            NULL);

        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
        IpxFreeConfiguration(Config);
        IpxDeregisterProtocol();
        return  STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the loopback structures
    //
    IpxInitLoopback();

// NIC_HANDLE
// All this will be done on appearance of adapters.
//

{
	PBIND_ARRAY_ELEM	BindingArray;
    PTA_ADDRESS         TdiRegistrationAddress;

	//
	// Pre-allocate the binding array
	// Later, we will allocate the LAN/WAN and SLAVE bindings separately
	// Read the array size from registry?
	//
	BindingArray = (PBIND_ARRAY_ELEM)IpxAllocateMemory (
										MAX_BINDINGS * sizeof(BIND_ARRAY_ELEM),
										MEMORY_BINDING,
										"Binding array");

	if (BindingArray == NULL) {
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_NO_ADAPTERS,
            802,
            STATUS_DEVICE_DOES_NOT_EXIST,
            NULL,
            0,
            NULL);
        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
		IpxDereferenceDevice (Device, DREF_CREATE);
		return STATUS_DEVICE_DOES_NOT_EXIST;
	}

    Device->MaxBindings = MAX_BINDINGS - EXTRA_BINDINGS;

    //
    // Allocate the TA_ADDRESS structure - this will be used in all TdiRegisterNetAddress
    // notifications.
    //
	TdiRegistrationAddress = (PTA_ADDRESS)IpxAllocateMemory (
										    (2 * sizeof(USHORT) + sizeof(TDI_ADDRESS_IPX)),
										    MEMORY_ADDRESS,
										    "Tdi Address");

	if (TdiRegistrationAddress == NULL) {
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_IPX_NO_ADAPTERS,
            802,
            STATUS_DEVICE_DOES_NOT_EXIST,
            NULL,
            0,
            NULL);
        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
        IpxFreeMemory(BindingArray, sizeof(BindingArray), MEMORY_BINDING, "Binding Array");
		IpxDereferenceDevice (Device, DREF_CREATE);
		return STATUS_DEVICE_DOES_NOT_EXIST;
	}

	RtlZeroMemory (BindingArray, MAX_BINDINGS * sizeof(BIND_ARRAY_ELEM));
	RtlZeroMemory (TdiRegistrationAddress, 2 * sizeof(USHORT) + sizeof(TDI_ADDRESS_IPX));

    //
    // We keep BindingArray[-1] as a placeholder for demand dial bindings.
    // This NicId is returned by the Fwd when a FindRoute is done on a demand
    // dial Nic. At the time of the InternalSend, the true Nic is returned.
    // We create a placeholder here to avoid special checks in the critical send path.
    //
    // NOTE: we need to free this demand dial binding as well as ensure that the
    // true binding array pointer is freed at Device Destroy time.
    //
    //
    // Increment beyond the first pointer - we will refer to the just incremented
    // one as Device->Bindings[-1].
    //
    BindingArray += EXTRA_BINDINGS;

	Device->Bindings = BindingArray;

    TdiRegistrationAddress->AddressLength = sizeof(TDI_ADDRESS_IPX);
    TdiRegistrationAddress->AddressType = TDI_ADDRESS_TYPE_IPX;

    //
    // Store the pointer in the Device.
    //
    Device->TdiRegistrationAddress = TdiRegistrationAddress;

	//
	// Device state is loaded, but not opened. It is opened when at least
	// one adapter has appeared.
	//
	Device->State = DEVICE_STATE_LOADED;

    Device->FirstLanNicId = Device->FirstWanNicId = (USHORT)1; // will be changed later

	IpxFreeConfiguration(Config);

    //
    // We use this event when unloading to signal that we
    // can proceed...initialize it here so we know it is
    // ready to go when unload is called.
    //

    KeInitializeEvent(
        &IpxDevice->UnloadEvent,
        NotificationEvent,
        FALSE
    );

    KeInitializeEvent(
        &IpxDevice->NbEvent,
        NotificationEvent,
        FALSE
    );

    //
    // Create a loopback adapter right here. [NtBug - 110010]
    //
    status = IpxBindLoopbackAdapter();

    if (status != STATUS_SUCCESS) {

        PANIC ("IpxCreateLoopback adapter failed!\n");
        
        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            607,
            status,
            NULL,
            0,
            NULL);
        
        TdiDeregisterProvider(IpxDevice->TdiProviderReadyHandle);
        return status;

    } else {

        IPX_DEBUG(DEVICE, ("Created LOOPBACK ADAPTER!\n"));

    }

    //
    // make ourselves known to the NDIS wrapper.
    //

    status = IpxRegisterProtocol ((PNDIS_STRING)&ProtocolName);

    if (!NT_SUCCESS (status)) {

        IpxFreeConfiguration(Config);
        DbgPrint ("IpxInitialize: RegisterProtocol failed with status %x!\n", status);

        IpxWriteGeneralErrorLog(
            (PVOID)DriverObject,
            EVENT_TRANSPORT_REGISTER_FAILED,
            607,
            status,
            NULL,
            0,
            NULL);

       return status;
    }
	return STATUS_SUCCESS;
}
}   /* DriverEntry */


ULONG
IpxResolveAutoDetect(
    IN PDEVICE Device,
    IN ULONG ValidBindings,
	IN CTELockHandle	*LockHandle1,
    IN PUNICODE_STRING RegistryPath,
    IN PADAPTER Adapter
    )

/*++

Routine Description:

    This routine is called for auto-detect bindings to
    remove any bindings that were not successfully found.
    It also updates "DefaultAutoDetectType" in the registry
    if needed.

Arguments:

    Device - The IPX device object.

    ValidBindings - The total number of bindings present.

    RegistryPath - The path to the ipx registry, used if we have
        to write a value back.

Return Value:

    The updated number of bindings.

--*/

{
    PBINDING Binding, TmpBinding;
    UINT i, j;

    //
    // Get rid of any auto-detect devices which we
    // could not find nets for. We also remove any
    // devices which are not the first ones
    // auto-detected on a particular adapter.
    //

    for (i = FIRST_REAL_BINDING; i <= ValidBindings; i++) {
        Binding = NIC_ID_TO_BINDING(Device, i);

        if (!Binding) {
            continue;
        }

        //
        // If this was auto-detected and was not the default,
        // or it was the default, but nothing was detected for
        // it *and* something else *was* detected (which means
        // we will use that frame type when we get to it),
        // we may need to remove this binding.
        //
		  // TINGCAI: If users do not set DefaultAutoDetectType in the
		  // registry, the default is 802.2. For 802.3, 
		  

        if (Binding->AutoDetect &&
            (!Binding->DefaultAutoDetect ||
             (Binding->DefaultAutoDetect &&
              (Binding->LocalAddress.NetworkAddress == 0) &&
              Binding->Adapter->AutoDetectResponse))) {

            if ((Binding->LocalAddress.NetworkAddress == 0) ||
                (Binding->Adapter->AutoDetectFoundOnBinding && 
					 Binding->Adapter->AutoDetectFoundOnBinding != Binding)) {

                //
                // Remove this binding.
                //

                if (Binding->LocalAddress.NetworkAddress == 0) {
                    IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) no net found\n",
                                                i, Binding->FrameType));
                } else {
                    IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) adapter already auto-detected\n",
                                                i, Binding->FrameType));
                }

                CTEAssert (Binding->NicId == i);
                CTEAssert (!Binding->Adapter->MacInfo.MediumAsync);

                //
                // Remove any routes through this NIC, and
                // adjust any NIC ID's above this one in the
                // database down by one.
                //

                RipAdjustForBindingChange (Binding->NicId, 0, IpxBindingDeleted);

                Binding->Adapter->Bindings[Binding->FrameType] = NULL;
                for (j = i+1; j <= ValidBindings; j++) {
					TmpBinding = NIC_ID_TO_BINDING(Device, j);
					INSERT_BINDING(Device, j-1, TmpBinding);
                    if (TmpBinding) {
                        if ((TmpBinding->Adapter->MacInfo.MediumAsync) &&
                            (TmpBinding->Adapter->FirstWanNicId == TmpBinding->NicId)) {
                            --TmpBinding->Adapter->FirstWanNicId;
                            --TmpBinding->Adapter->LastWanNicId;
                        }
                        --TmpBinding->NicId;
                    }
                }
                INSERT_BINDING(Device, ValidBindings, NULL);
                --Binding->Adapter->BindingCount;
                --ValidBindings;

                --i;   // so we check the binding that was just moved.

                //
                // Wait 100 ms before freeing the binding,
                // in case an indication is using it.
                //

                KeStallExecutionProcessor(100000);

                IpxDestroyBinding (Binding);

            } else {

                IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) auto-detected OK\n",
                                                i, Binding->FrameType));

#if DBG
                DbgPrint ("IPX: Auto-detected non-default frame type %s, net %lx\n",
                    OutputFrameType(Binding),
                    REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif

                //
                // Save it in the registry for the next boot.
                //
//
// This cannot be done at DPC, so, drop the IRQL
//
				IPX_FREE_LOCK1(&Device->BindAccessLock, *LockHandle1);
				IpxWriteDefaultAutoDetectType(
					RegistryPath,
					Binding->Adapter,
					Binding->FrameType);
				IPX_GET_LOCK1(&Device->BindAccessLock, LockHandle1);

                //
                // Now, we know for sure that NB needs to be told of this.
                // Set to TRUE in IpxBindToAdapter line 1491
 
                if (Binding->Adapter == Adapter) {
                    Binding->IsnInformed[IDENTIFIER_NB] = FALSE;
                    Binding->IsnInformed[IDENTIFIER_SPX] = FALSE;
                }

                Binding->Adapter->AutoDetectFoundOnBinding = Binding;
            }

        } else {

            if (Binding->AutoDetect) {

                IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) auto-detect default\n",
                                               i, Binding->FrameType));

#if DBG
                if (Binding->LocalAddress.NetworkAddress != 0) {
                    IPX_DEBUG (AUTO_DETECT, ("IPX: Auto-detected default frame type %s, net %lx\n",
                        OutputFrameType(Binding),
                        REORDER_ULONG (Binding->LocalAddress.NetworkAddress)));
                } else {
                    IPX_DEBUG (AUTO_DETECT, ("IPX: Using default auto-detect frame type %s\n",
                        OutputFrameType(Binding)));
                }
#endif

                Binding->Adapter->AutoDetectFoundOnBinding = Binding;

            } else {

                IPX_DEBUG (AUTO_DETECT, ("Binding %d (%d) not auto-detected\n",
                                               i, Binding->FrameType));
            }
            
            //
            // Now, we know for sure that NB needs to be told of this.
            //
            
            if (Binding->Adapter == Adapter) {
                Binding->IsnInformed[IDENTIFIER_NB] = FALSE;
                Binding->IsnInformed[IDENTIFIER_SPX] = FALSE;
            }
        }

    }


    for (i = 1; i <= ValidBindings; i++) {
        if (Binding = NIC_ID_TO_BINDING(Device, i)) {
            CTEAssert (Binding->NicId == i);
            IPX_DEBUG (AUTO_DETECT, ("Binding %lx, type %d, auto %d\n",
                            Binding, Binding->FrameType, Binding->AutoDetect));
        }

    }

    return ValidBindings;

}   /* IpxResolveAutoDetect */


VOID
IpxResolveBindingSets(
    IN PDEVICE Device,
    IN ULONG ValidBindings
    )

/*++

Routine Description:

    This routine is called to determine if we have any
    binding sets and rearrange the bindings the way we
    like. The order is as follows:

    - First comes the first binding to each LAN network
    - Following that are all WAN bindings
    - Following that are any duplicate bindings to LAN networks
        (the others in the "binding set").

    If "global wan net" is true we will advertise up to
    and including the first wan binding as the highest nic
    id; otherwise we advertise up to and including the last
    wan binding. In all cases the duplicate bindings are
    hidden.

Arguments:

    Device - The IPX device object.

    ValidBindings - The total number of bindings present.

Return Value:

    None.

--*/

{
    PBINDING Binding, MasterBinding, TmpBinding;
    UINT i, j;
    ULONG WanCount, DuplicateCount;

    //
    // First loop through and push all the wan bindings
    // to the end.
    //

    WanCount = Device->HighestExternalNicId - Device->HighestLanNicId;

    //
    // Now go through and find the LAN duplicates and
    // create binding sets from them.
    //

    DuplicateCount = 0;

    for (i = FIRST_REAL_BINDING; i <= (ValidBindings-(WanCount+DuplicateCount)); ) {

		Binding = NIC_ID_TO_BINDING(Device, i);
        CTEAssert (Binding != NULL);    // because we are only looking at LAN bindings

        CTEAssert (!Binding->Adapter->MacInfo.MediumAsync);

        if (Binding->LocalAddress.NetworkAddress == 0) {
            i++;
            continue;
        }

        //
        // See if any previous bindings match the
        // frame type, medium type, and number of
        // this network (for the moment we match on
        // frame type and medium type too so that we
        // don't have to worry about different frame
        // formats and header offsets within a set).
        //

        for (j = FIRST_REAL_BINDING; j < i; j++) {
          	MasterBinding = NIC_ID_TO_BINDING(Device, j);
            if ((MasterBinding->LocalAddress.NetworkAddress == Binding->LocalAddress.NetworkAddress) &&
                (MasterBinding->FrameType == Binding->FrameType) &&
                (MasterBinding->Adapter->MacInfo.MediumType == Binding->Adapter->MacInfo.MediumType)) {
                break;
            }

        }

        if (j == i) {
            i++;
            continue;
        }

        //
        // We have a duplicate. First slide it down to the
        // end. Note that we change any router entries that
        // use our real NicId to use the real NicId of the
        // master (there should be no entries in the rip
        // database that have the NicId of a binding slave).
        //

        RipAdjustForBindingChange (Binding->NicId, MasterBinding->NicId, IpxBindingMoved);

        for (j = i+1; j <= ValidBindings; j++) {
			TmpBinding = NIC_ID_TO_BINDING(Device, j);
            INSERT_BINDING(Device, j-1, TmpBinding);
            if (TmpBinding) {
                if ((TmpBinding->Adapter->MacInfo.MediumAsync) &&
                    (TmpBinding->Adapter->FirstWanNicId == TmpBinding->NicId)) {
                    --TmpBinding->Adapter->FirstWanNicId;
                    --TmpBinding->Adapter->LastWanNicId;
                }
                --TmpBinding->NicId;
            }
        }
        INSERT_BINDING(Device, ValidBindings, Binding);

        Binding->NicId = (USHORT)ValidBindings;
        ++DuplicateCount;

	if (Binding->TdiRegistrationHandle != NULL) {
	   NTSTATUS    ntStatus;
	   ntStatus = TdiDeregisterNetAddress(Binding->TdiRegistrationHandle);
           if (ntStatus != STATUS_SUCCESS) {
              IPX_DEBUG(PNP, ("TdiDeRegisterNetAddress failed: %lx", ntStatus));
           } else {
	      Binding->TdiRegistrationHandle = NULL; 
	   }
	}

        //
        // Now make MasterBinding the head of a binding set.
        //

        if (MasterBinding->BindingSetMember) {

            //
            // Just insert ourselves in the chain.
            //

#if DBG
            DbgPrint ("IPX: %lx is also on network %lx\n",
                Binding->Adapter->AdapterName,
                REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif
            IPX_DEBUG (AUTO_DETECT, ("Add %lx to binding set of %lx\n", Binding, MasterBinding));

            CTEAssert (MasterBinding->CurrentSendBinding);
            Binding->NextBinding = MasterBinding->NextBinding;

        } else {

            //
            // Start the chain with the two bindings in it.
            //

#if DBG
            DbgPrint ("IPX: %lx and %lx are on the same network %lx, will load balance\n",
                MasterBinding->Adapter->AdapterName, Binding->Adapter->AdapterName,
                REORDER_ULONG (Binding->LocalAddress.NetworkAddress));
#endif
            IPX_DEBUG (AUTO_DETECT, ("Create new %lx in binding set of %lx\n", Binding, MasterBinding));

            MasterBinding->BindingSetMember = TRUE;
            MasterBinding->CurrentSendBinding = MasterBinding;
            MasterBinding->MasterBinding = MasterBinding;
            Binding->NextBinding = MasterBinding;

        }

        MasterBinding->NextBinding = Binding;
        Binding->BindingSetMember = TRUE;
        Binding->ReceiveBroadcast = FALSE;
        Binding->CurrentSendBinding = NULL;
        Binding->MasterBinding = MasterBinding;

        //
        // Since the master binding looks like all members of
        // the binding set to people querying from above, we have
        // to make it the worst-case of all the elements. Generally
        // these will be equal since the frame type and media is
        // the same.
        //

        if (Binding->MaxLookaheadData > MasterBinding->MaxLookaheadData) {
            MasterBinding->MaxLookaheadData = Binding->MaxLookaheadData;
        }
        if (Binding->AnnouncedMaxDatagramSize < MasterBinding->AnnouncedMaxDatagramSize) {
            MasterBinding->AnnouncedMaxDatagramSize = Binding->AnnouncedMaxDatagramSize;
        }
        if (Binding->RealMaxDatagramSize < MasterBinding->RealMaxDatagramSize) {
            MasterBinding->RealMaxDatagramSize = Binding->RealMaxDatagramSize;
        }
        if (Binding->MediumSpeed < MasterBinding->MediumSpeed) {
            MasterBinding->MediumSpeed = Binding->MediumSpeed;
        }

        //
        // Keep i the same, to check the new binding at
        // this position.
        //

    }
	Device->HighestLanNicId -= (USHORT)DuplicateCount;

	if (Device->HighestLanNicId == 0) {
        CTEAssert(FALSE);
	}

	Device->HighestExternalNicId -= (USHORT)DuplicateCount;
	Device->HighestType20NicId -= (USHORT)DuplicateCount;
	Device->SapNicCount -= (USHORT)DuplicateCount;
}   /* IpxResolveBindingSets */


NTSTATUS
IpxBindToAdapter(
    IN PDEVICE Device,
    IN PBINDING_CONFIG ConfigBinding,
	IN PADAPTER	*AdapterPtr,
    IN ULONG FrameTypeIndex
    )

/*++

Routine Description:

    This routine handles binding the transport to a new
    adapter. It can be called at any point during the life
    of the transport.

Arguments:

    Device - The IPX device object.

    ConfigBinding - The configuration info for this binding.

	AdapterPtr - pointer to the adapter to bind to in case of PnP.

	FrameTypeIndex - The index into ConfigBinding's array of frame
        types for this adapter. The routine is called once for
        every valid frame type.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;

	PADAPTER Adapter = *AdapterPtr;

    PBINDING Binding, OldBinding;
    ULONG FrameType, MappedFrameType;
    PLIST_ENTRY p;

    //
    // We can't bind more than one adapter unless we have a
    // virtual network configured or we are allowed to run
    // with a virtual network of 0.
    //

    if (Device->BindingCount == 1) {
        if ((Device->VirtualNetworkNumber == 0) &&
            (!Device->VirtualNetworkOptional)) {

            IPX_DEBUG (ADAPTER, ("Cannot bind to more than one adapter\n"));
            DbgPrint ("IPX: Disallowing multiple bind ==> VirtualNetwork is 0\n");
            IpxWriteGeneralErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_BINDING_FAILED,
                666,
                STATUS_NOT_SUPPORTED,
                ConfigBinding->AdapterName.Buffer,
                0,
                NULL);

            return STATUS_NOT_SUPPORTED;
        }
    }


    //
    // First allocate the memory for the binding.
    //

    status = IpxCreateBinding(
                 Device,
                 ConfigBinding,
                 FrameTypeIndex,
                 ConfigBinding->AdapterName.Buffer,
                 &Binding);

    if (status != STATUS_SUCCESS) {
       IpxWriteGeneralErrorLog(
	  (PVOID)IpxDevice->DeviceObject,
	  EVENT_TRANSPORT_RESOURCE_POOL,
	  812,
	  status,
	  L"IpxBindToAdapter: failed to create binding",
	  0,
	  NULL);
       DbgPrint("IPX: IpxCreateBinding failed with status %x\n.",status);  
       return status;
    }

    FrameType = ConfigBinding->FrameType[FrameTypeIndex];

//
// In PnP case, we dont need to check for existing adapters since
// we supply a NULL adapter in the parameters if it needs to be created
//

    if (Adapter == NULL) {

        //
        // No binding to this adapter exists, so create a
        // new one.
        //

        status = IpxCreateAdapter(
                     Device,
                     &ConfigBinding->AdapterName,
                     &Adapter);

        if (status != STATUS_SUCCESS) {
            IpxDestroyBinding(Binding);
            return status;
        }

        //
        // Save these now (they will be the same for all bindings
        // on this adapter).
        //

        Adapter->ConfigMaxPacketSize = ConfigBinding->Parameters[BINDING_MAX_PKT_SIZE];
        Adapter->SourceRouting = (BOOLEAN)ConfigBinding->Parameters[BINDING_SOURCE_ROUTE];
        Adapter->EnableFunctionalAddress = (BOOLEAN)ConfigBinding->Parameters[BINDING_ENABLE_FUNC_ADDR];
        Adapter->EnableWanRouter = (BOOLEAN)ConfigBinding->Parameters[BINDING_ENABLE_WAN];

        Adapter->BindSap = (USHORT)ConfigBinding->Parameters[BINDING_BIND_SAP];
        Adapter->BindSapNetworkOrder = REORDER_USHORT(Adapter->BindSap);
        CTEAssert (Adapter->BindSap == 0x8137);
        CTEAssert (Adapter->BindSapNetworkOrder == 0x3781);

        //
        // Now fire up NDIS so this adapter talks
        //

        status = IpxInitializeNdis(
                    Adapter,
                    ConfigBinding);

        if (!NT_SUCCESS (status)) {

            //
            // Log an error.
            //

            IpxWriteGeneralErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_BINDING_FAILED,
                601,
                status,
                ConfigBinding->AdapterName.Buffer,
                0,
                NULL);


	    IpxDereferenceAdapter1(Adapter,ADAP_REF_CREATE); 
	    IpxDestroyAdapter (Adapter);
	    IpxDestroyBinding (Binding);

            //
            // Returning this status informs the caller to not
            // try any more frame types on this adapter.
            //

            return STATUS_DEVICE_DOES_NOT_EXIST;

        }

        //
        // For 802.5 bindings we need to start the source routing
        // timer to time out old entries.
        //

        if ((Adapter->MacInfo.MediumType == NdisMedium802_5) &&
            (Adapter->SourceRouting)) {

            if (!Device->SourceRoutingUsed) {

                Device->SourceRoutingUsed = TRUE;
                IpxReferenceDevice (Device, DREF_SR_TIMER);

                CTEStartTimer(
                    &Device->SourceRoutingTimer,
                    60000,                     // one minute timeout
                    MacSourceRoutingTimeout,
                    (PVOID)Device);
            }
        }

        MacMapFrameType(
            Adapter->MacInfo.RealMediumType,
            FrameType,
            &MappedFrameType);

        IPX_DEBUG (ADAPTER, ("Create new bind to adapter %ws, type %d\n",
                              ConfigBinding->AdapterName.Buffer,
                              MappedFrameType));

        IpxAllocateReceiveBufferPool (Adapter);

		*AdapterPtr = Adapter;
    }
	else {
		//
		// get the mapped frame type
		//
        MacMapFrameType(
            Adapter->MacInfo.RealMediumType,
            FrameType,
            &MappedFrameType);

        if (Adapter->Bindings[MappedFrameType] != NULL) {

            IPX_DEBUG (ADAPTER, ("Bind to adapter %ws, type %d exists\n",
                                  Adapter->AdapterName,
                                  MappedFrameType));

            //
            // If this was the auto-detect default for this
            // adapter and it failed, we need to make the
            // previous one the default, so that at least
            // one binding will stick around.
            //

            if (ConfigBinding->DefaultAutoDetect[FrameTypeIndex]) {
                IPX_DEBUG (ADAPTER, ("Default auto-detect changed from %d to %d\n",
                                          FrameType, MappedFrameType));
                Adapter->Bindings[MappedFrameType]->DefaultAutoDetect = TRUE;
            }

            IpxDestroyBinding (Binding);

            return STATUS_NOT_SUPPORTED;
        }

        IPX_DEBUG (ADAPTER, ("Using existing bind to adapter %ws, type %d\n",
                              Adapter->AdapterName,
                              MappedFrameType));
	}

    //
    // The local node address starts out the same as the
    // MAC address of the adapter (on WAN this will change).
    // The local MAC address can also change for WAN.
    //

    RtlCopyMemory (Binding->LocalAddress.NodeAddress, Adapter->LocalMacAddress.Address, 6);
    RtlCopyMemory (Binding->LocalMacAddress.Address, Adapter->LocalMacAddress.Address, 6);


    //
    // Save the send handler.
    //

    Binding->SendFrameHandler = NULL;
    Binding->FrameType = MappedFrameType;

    //
    // Put this in InitializeBindingInfo.
    //

    switch (Adapter->MacInfo.RealMediumType) {
    case NdisMedium802_3:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_3: Binding->SendFrameHandler = IpxSendFrame802_3802_3; break;
        case ISN_FRAME_TYPE_802_2: Binding->SendFrameHandler = IpxSendFrame802_3802_2; break;
        case ISN_FRAME_TYPE_ETHERNET_II: Binding->SendFrameHandler = IpxSendFrame802_3EthernetII; break;
        case ISN_FRAME_TYPE_SNAP: Binding->SendFrameHandler = IpxSendFrame802_3Snap; break;
        }
        break;
    case NdisMedium802_5:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_2: Binding->SendFrameHandler = IpxSendFrame802_5802_2; break;
        case ISN_FRAME_TYPE_SNAP: Binding->SendFrameHandler = IpxSendFrame802_5Snap; break;
        }
        break;
    case NdisMediumFddi:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_3: Binding->SendFrameHandler = IpxSendFrameFddi802_3; break;
        case ISN_FRAME_TYPE_802_2: Binding->SendFrameHandler = IpxSendFrameFddi802_2; break;
        case ISN_FRAME_TYPE_SNAP: Binding->SendFrameHandler = IpxSendFrameFddiSnap; break;
        }
        break;
    case NdisMediumArcnet878_2:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_802_3: Binding->SendFrameHandler = IpxSendFrameArcnet878_2; break;
        }
        break;
    case NdisMediumWan:
        switch (MappedFrameType) {
        case ISN_FRAME_TYPE_ETHERNET_II: Binding->SendFrameHandler = IpxSendFrameWanEthernetII; break;
        }
        break;
    }

    if (Binding->SendFrameHandler == NULL) {
        DbgPrint ("SendFrameHandler is NULL\n");
    }

    Adapter->Bindings[MappedFrameType] = Binding;
    ++Adapter->BindingCount;

    Binding->Adapter = Adapter;


    //
    // NicId and ExternalNicId will be filled in later when the binding
    // is assigned a spot in the Device->Bindings array.
    //

    //
    // Initialize the per-binding MAC information
    //

    if ((Adapter->ConfigMaxPacketSize == 0) ||
        (Adapter->MaxSendPacketSize < Adapter->ConfigMaxPacketSize)) {
        Binding->MaxSendPacketSize = Adapter->MaxSendPacketSize;
    } else {
        Binding->MaxSendPacketSize = Adapter->ConfigMaxPacketSize;
    }
    Binding->MediumSpeed = Adapter->MediumSpeed;
    if (Adapter->MacInfo.MediumAsync) {
        Binding->LineUp = FALSE;
    } else {
        //
        // Lets do this until we know for sure that we are done with autodetect.
        // [ShreeM]
        //
        // Only for LAN as we don't do auto detect for WAN lines. 276128
        Binding->IsnInformed[IDENTIFIER_NB] = TRUE;
        Binding->IsnInformed[IDENTIFIER_SPX] = TRUE;
        Binding->LineUp = TRUE;
    }

    MacInitializeBindingInfo(
        Binding,
        Adapter);

    return STATUS_SUCCESS;

}   /* IpxBindToAdapter */


BOOLEAN
IpxIsAddressLocal(
    IN TDI_ADDRESS_IPX UNALIGNED * SourceAddress
    )

/*++

Routine Description:

    This routine returns TRUE if the specified SourceAddress indicates
    the packet was sent by us, and FALSE otherwise.

Arguments:

    SourceAddress - The source IPX address.

Return Value:

    TRUE if the address is local.

--*/

{
    PBINDING Binding;
    UINT i;

    PDEVICE Device = IpxDevice; 

    CTELockHandle LockHandle;
    
    CTEGetLock (&Device->Lock, &LockHandle);
    //
    // First see if it is a virtual network address or not.
    //

    if (RtlEqualMemory (VirtualNode, SourceAddress->NodeAddress, 6)) {

        //
        // This is us if we have a virtual network configured.
        // If we don't have a virtual node, we fall through to the
        // other check -- an arcnet card configured as node 1 will
        // have what we think of as the "virtual node" as its
        // real node address.
        //

        if ((IpxDevice->VirtualNetwork) &&
            (IpxDevice->VirtualNetworkNumber == SourceAddress->NetworkAddress)) {
	    CTEFreeLock (&Device->Lock, LockHandle);
            return TRUE;
        }

    }

    //
    // Check through our list of adapters to see if one of
    // them is the source node.
    //
    {
    ULONG   Index = MIN (IpxDevice->MaxBindings, IpxDevice->ValidBindings);

    for (i = FIRST_REAL_BINDING; i <= Index; i++) {
        if (((Binding = NIC_ID_TO_BINDING(IpxDevice, i)) != NULL) &&
            (RtlEqualMemory (Binding->LocalAddress.NodeAddress, SourceAddress->NodeAddress, 6))) {
	    CTEFreeLock (&Device->Lock, LockHandle);
	    return TRUE;
        }
    }
    }

    CTEFreeLock (&Device->Lock, LockHandle);
    
    return FALSE;

}   /* IpxIsAddressLocal */


NTSTATUS
IpxUnBindFromAdapter(
    IN PBINDING Binding
    )

/*++

Routine Description:

    This routine handles unbinding the transport from an
    adapter. It can be called at any point during the life
    of the transport.

Arguments:

    Binding - The adapter to unbind.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PADAPTER Adapter = Binding->Adapter;

    
    IpxDereferenceBinding (Binding, BREF_BOUND);

    if (NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID) != Binding) {
       
       Adapter->Bindings[Binding->FrameType] = NULL;
       --Adapter->BindingCount;
    
    } else {

       IPX_DEBUG(PNP, ("Loopback Binding : dont decrement adapter's bindingcount, just return\n"));
       return STATUS_SUCCESS;

    }

    if (Adapter->BindingCount == 0) {

        //
        // DereferenceAdapter is a NULL macro for load-only.
        //
#ifdef _PNP_LATER
        //
        // Take away the creation reference. When the in-use ref is taken off,
        // we destroy this adapter.
        //
        IpxDereferenceAdapter(Adapter);
#else
        IpxDestroyAdapter (Adapter);

#endif
    }

    return STATUS_SUCCESS;

}   /* IpxUnBindFromAdapter */

VOID
IpxNdisUnload() {
   
   PBINDING Loopback=NULL;
   NTSTATUS ntStatus = STATUS_SUCCESS;
   NDIS_STATUS ndisStatus;
   IPX_PNP_INFO IpxPnPInfo;
   PREQUEST Request;
   PLIST_ENTRY p;
   KIRQL irql;

   NDIS_HANDLE LocalNdisProtocolHandle; 

   IPX_DEBUG(PNP, ("IpxNdisUnload is being called\n")); 

   IpxDevice->State = DEVICE_STATE_STOPPING;

   
   LocalNdisProtocolHandle = InterlockedExchangePointer(&IpxNdisProtocolHandle, NULL); 
 
   if (LocalNdisProtocolHandle != (NDIS_HANDLE)NULL) {
       NdisDeregisterProtocol (&ndisStatus, LocalNdisProtocolHandle);
       ASSERT(ndisStatus == NDIS_STATUS_SUCCESS);  
   }
   
   //
   // Complete any pending address notify requests.
   //

   while ((p = ExInterlockedRemoveHeadList(
					   &IpxDevice->AddressNotifyQueue,
					   &IpxDevice->Lock)) != NULL) {

      Request = LIST_ENTRY_TO_REQUEST(p);	
      REQUEST_STATUS(Request) = STATUS_DEVICE_NOT_READY;
      
      // AcquireCancelSpinLock to force the cancel routine to release the lock if it was
      // fired after we remove it from the queue
      IoAcquireCancelSpinLock( &irql );
      IoSetCancelRoutine (Request, (PDRIVER_CANCEL)NULL);
      IoReleaseCancelSpinLock( irql );
      IpxCompleteRequest (Request);
      IpxFreeRequest (IpxDevice, Request);
      
      IpxDereferenceDevice (IpxDevice, DREF_ADDRESS_NOTIFY);
   }


   Loopback = NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID);

   if (Loopback != NULL) {

      if (Loopback->TdiRegistrationHandle) {
      
	 if ((ntStatus = TdiDeregisterNetAddress(Loopback->TdiRegistrationHandle)) != STATUS_SUCCESS) {
            DbgPrint("IPX: IpxNdisUnload: TdiDeRegisterNetAddress failed: %lx\n", ntStatus);
	 } else {
	    IPX_DEBUG(PNP, ("TdiDeRegisterNetAddress Loopback Address: %lx\n", Loopback->LocalAddress.NetworkAddress));
	    Loopback->TdiRegistrationHandle = NULL; 
	 }	
      }	
   }

   //
   // Inform TDI clients about the close of our device object.
   //

   // If TdiRegisterDeviceObject failed, the handle would be null. 
   if (IpxDevice->TdiRegistrationHandle != NULL) {
      if (IpxDevice->TdiRegistrationHandle == (PVOID) TDI_DEREGISTERED_COOKIE) {
	 DbgPrint("IPX: IpxNdisUnload: NDIS is calling us AGAIN (%p) !!!!\n, IpxDevice->TdiRegistrationHandle");  
	 DbgBreakPoint(); 
      } else {
	 ntStatus = TdiDeregisterDeviceObject(IpxDevice->TdiRegistrationHandle); 
	 if (ntStatus != STATUS_SUCCESS) {
	    DbgPrint("IPX: TdiDeRegisterDeviceObject failed: %lx\n", ntStatus);
	 } else {
	    IpxDevice->TdiRegistrationHandle = (HANDLE) TDI_DEREGISTERED_COOKIE; 
	 }
      }
   }
   

   IpxPnPInfo.LineInfo.LinkSpeed = IpxDevice->LinkSpeed;
   IpxPnPInfo.LineInfo.MaximumPacketSize =
      IpxDevice->Information.MaximumLookaheadData + sizeof(IPX_HEADER);
   IpxPnPInfo.LineInfo.MaximumSendSize =
      IpxDevice->Information.MaxDatagramSize + sizeof(IPX_HEADER);
   IpxPnPInfo.LineInfo.MacOptions = IpxDevice->MacOptions;
   
   IpxPnPInfo.FirstORLastDevice = TRUE;
   
   if (Loopback != NULL) {
      if (IpxDevice->UpperDriverBound[IDENTIFIER_SPX] && (*IpxDevice->UpperDrivers[IDENTIFIER_SPX].PnPHandler)) {
	 if (Loopback->IsnInformed[IDENTIFIER_SPX]) {

      
	    (*IpxDevice->UpperDrivers[IDENTIFIER_SPX].PnPHandler) (
								   IPX_PNP_DELETE_DEVICE,
								   &IpxPnPInfo);

	    Loopback->IsnInformed[IDENTIFIER_SPX] = FALSE; 
	 }
      }        
       
      if (IpxDevice->UpperDriverBound[IDENTIFIER_NB] && (*IpxDevice->UpperDrivers[IDENTIFIER_NB].PnPHandler)) {
	 if (Loopback->IsnInformed[IDENTIFIER_NB]) {

	    (*IpxDevice->UpperDrivers[IDENTIFIER_NB].PnPHandler) (
								  IPX_PNP_DELETE_DEVICE,
								  &IpxPnPInfo);

	    Loopback->IsnInformed[IDENTIFIER_NB] = FALSE; 
	    IPX_DEBUG(PNP,("Indicate to NB IPX_PNP_DELETE_DEVICE with FirstORLastDevice = (%d)",IpxPnPInfo.FirstORLastDevice));  
	 }
      }
   }
}


VOID
IpxUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine unloads the sample transport driver.
    It unbinds from any NDIS drivers that are open and frees all resources
    associated with the transport. The I/O system will not call us until
    nobody above has IPX open.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/

{

    PBINDING Binding, Loopback=NULL;
 
    UINT i;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LARGE_INTEGER   Delay;

    CTELockHandle LockHandle;

    UNREFERENCED_PARAMETER (DriverObject);
    
    //
    // Cancel the source routing timer if used.
    //
    if (IpxDevice->SourceRoutingUsed) {

        IpxDevice->SourceRoutingUsed = FALSE;
        if (CTEStopTimer (&IpxDevice->SourceRoutingTimer)) {
            IpxDereferenceDevice (IpxDevice, DREF_SR_TIMER);
        }
    }

    //
    // Cancel the RIP long timer, and if we do that then
    // send a RIP DOWN message if needed.
    //
    if (CTEStopTimer (&IpxDevice->RipLongTimer)) {

        if (IpxDevice->RipResponder) {

            if (RipQueueRequest (IpxDevice->VirtualNetworkNumber, RIP_DOWN) == STATUS_PENDING) {

                //
                // If we queue a request, it will stop the timer.
                //

                KeWaitForSingleObject(
                    &IpxDevice->UnloadEvent,
                    Executive,
                    KernelMode,
                    TRUE,
                    (PLARGE_INTEGER)NULL
                    );
            }
        }

        IpxDereferenceDevice (IpxDevice, DREF_LONG_TIMER);

    } else {

        //
        // We couldn't stop the timer, which means it is running,
        // so we need to wait for the event that is kicked when
        // the RIP DOWN messages are done.
        //

        if (IpxDevice->RipResponder) {
	    
	   KeWaitForSingleObject(
                &IpxDevice->UnloadEvent,
                Executive,
                KernelMode,
                TRUE,
                (PLARGE_INTEGER)NULL
                );
        }
    }

    IPX_DEBUG(PNP, ("Going back to loaded state\n"));

    // Free loopback binding and adapter
    IpxDereferenceAdapter1(NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID)->Adapter,ADAP_REF_CREATE);
    IpxDestroyAdapter(NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID)->Adapter);
    IpxDestroyBinding(NIC_ID_TO_BINDING(IpxDevice, LOOPBACK_NIC_ID));

    //
    // Walk the list of device contexts.
    //
    for (i = FIRST_REAL_BINDING; i <= IpxDevice->ValidBindings; i++) {
        if ((Binding = NIC_ID_TO_BINDING(IpxDevice, i)) != NULL) {

	   // This function will skip NdisCloseAdapter if it has already done so.
	   IpxCloseNdis(Binding->Adapter);

	   INSERT_BINDING(IpxDevice, i, NULL);

	   // Deref the binding and free its adapter if the binding count goes to 0.
	   IpxUnBindFromAdapter (Binding);

        }
    }

    //
    // Backup the pointer to free the demand dial location.
    //
    IpxDevice->Bindings -= EXTRA_BINDINGS;

    IpxFreeMemory ( IpxDevice->Bindings,
                    IpxDevice->MaxBindings * sizeof(BIND_ARRAY_ELEM),
                    MEMORY_BINDING,
                    "Binding array");

    //
    // Deallocate the TdiRegistrationAddress and RegistryPathBuffer.
    //
    IpxFreeMemory ( IpxDevice->TdiRegistrationAddress,
                    (2 * sizeof(USHORT) + sizeof(TDI_ADDRESS_IPX)),
                    MEMORY_ADDRESS,
                    "Tdi Address");

    IpxFreeMemory ( IpxDevice->RegistryPathBuffer,
                    IpxDevice->RegistryPath.Length + sizeof(WCHAR),
                    MEMORY_CONFIG,
                    "RegistryPathBuffer");


    KeResetEvent(&IpxDevice->UnloadEvent);

    CTEGetLock (&IpxDevice->Lock, &LockHandle);
    IpxDevice->UnloadWaiting = TRUE;
    CTEFreeLock (&IpxDevice->Lock, LockHandle);

    //
    // Remove the reference for us being loaded.
    //
    IpxDereferenceDevice (IpxDevice, DREF_CREATE);

    //
    // Wait for our count to drop to zero.
    //
    // If KeWaitForSingleObject returns STATUS_ALERTED, we should keep waiting. [TC]
    //
    while (KeWaitForSingleObject(
				 &IpxDevice->UnloadEvent,
				 Executive,
				 KernelMode,
				 TRUE,
				 (PLARGE_INTEGER)NULL
				 ) 
	   == STATUS_ALERTED) {
       IPX_DEBUG(DEVICE, ("KeWaitForSingleObject returned STATUS_ALERTED")); 
    };


    // Let the thread that set the UnloadEvent exit. 269061
    Delay.QuadPart = -10*1000;  // One second.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &Delay);

    //
    // Now free the padding buffer.
    //
    IpxFreePaddingBuffer (IpxDevice);

    //
    // Now do the cleanup that has to happen at IRQL 0.
    //
    ExDeleteResourceLite (&IpxDevice->AddressResource);
    IoDeleteDevice (IpxDevice->DeviceObject);

    //
    // Finally, remove ourselves as an NDIS protocol.
    //
    IpxDeregisterProtocol();

}   /* IpxUnload */

NTSTATUS
IpxDispatchPnP(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PREQUEST         Request
    )
{
    PIO_STACK_LOCATION  pIrpSp;
    PDEVICE_RELATIONS   pDeviceRelations = NULL;
    PVOID               pnpDeviceContext = NULL;
    NTSTATUS 		Status = STATUS_INVALID_DEVICE_REQUEST;
    PADDRESS_FILE	AddressFile; 
    PDEVICE		Device = IpxDevice; 

    pIrpSp = IoGetCurrentIrpStackLocation(Request);

    //
    // Allocate a request to track this IRP.
    //

    switch(pIrpSp->MinorFunction) {  
       
       case IRP_MN_QUERY_DEVICE_RELATIONS:                                        
       if (pIrpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {
/*
	 354517 nwrdr passes neither a connection nor an address file object.
	 If nwrdr gives an address object, 
	 IPX should look up which nic this address is bound to and 
	 gives the PDO of that NIC.  
*/
/*
	    if (PtrToUlong(pIrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
	       DbgPrint("IPX: Received IRP_MJ_PNP, Connectoin File\n");
	       Status = STATUS_INVALID_HANDLE; 
	       break;  
	    } else if ( PtrToUlong(pIrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {
	       DbgPrint("IPX: Received IRP_MJ_PNP, Address File\n"); 
	       AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
	    } else {
	       Status = STATUS_INVALID_HANDLE; 
	       break; 
	    }

	    //
	    // This creates a reference to AddressFile->Address
	    // which is removed by IpxCloseAddressFile.
	    //

	    Status = IpxVerifyAddressFile(AddressFile);


	    if (!NT_SUCCESS (Status)) {
               DbgPrint("IPX: Received IRP_MJ_PNP, Invalid Address File\n"); 
	       Status = STATUS_INVALID_HANDLE;
	    } else {
*/	       
	       PBINDING Binding = NIC_ID_TO_BINDING(Device, FIRST_REAL_BINDING); 

	       if (Binding == NULL) {
		  Status = STATUS_INVALID_HANDLE; 
	       } else {
		  pnpDeviceContext = Binding->Adapter->PNPContext;
		  pDeviceRelations = (PDEVICE_RELATIONS) IpxAllocateMemory (sizeof (DEVICE_RELATIONS),
									 MEMORY_ADAPTER,
									 "Query Device Relation"); 
									 
		  if (pDeviceRelations != NULL) {

		     ObReferenceObject (pnpDeviceContext);
		     
		     //
		     // TargetDeviceRelation allows exactly one PDO. fill it up.
		     //
		     pDeviceRelations->Count  =   1;
		     pDeviceRelations->Objects[0] = pnpDeviceContext;

		     //
		     // invoker of this irp will free the information buffer.
		     //

		     REQUEST_INFORMATION(Request) = (ULONG_PTR) pDeviceRelations;

		     Status = STATUS_SUCCESS;

		  } else {
		     Status = STATUS_INSUFFICIENT_RESOURCES;
		  } 
/*
	       }
 	       IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY); 
*/
	       } 
       }
       break; 

    default:
       break; 
    }

    return Status; 
}


NTSTATUS
IpxDispatchOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the IPX device driver.
    It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    CTELockHandle LockHandle;
    PDEVICE Device = IpxDevice;
    NTSTATUS Status;
    PFILE_FULL_EA_INFORMATION openType;
    BOOLEAN found;
    PADDRESS_FILE AddressFile;
    PREQUEST Request;
    UINT i;
#ifdef SUNDOWN
    ULONG_PTR Type;
#else
    ULONG Type;
#endif



    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    
    // We should allow clients such as NB to CLOSE and CLEANUP even when we are stopping. 
    // Only disable CREATE when stopping. [TC]

    if (Device->State == DEVICE_STATE_CLOSED) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }

    #ifdef DBG
    if (Device->State == DEVICE_STATE_STOPPING) {
       IPX_DEBUG(DEVICE, ("Got IRP in STOPPING state. IRP(%p)", Irp)); 
    }
    #endif
    //
    // Allocate a request to track this IRP.
    //

    Request = IpxAllocateRequest (Device, Irp);
    IF_NOT_ALLOCATED(Request) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Make sure status information is consistent every time.
    //

    MARK_REQUEST_PENDING(Request);
    REQUEST_STATUS(Request) = STATUS_PENDING;
    REQUEST_INFORMATION(Request) = 0;

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //


    switch (REQUEST_MAJOR_FUNCTION(Request)) {


    case IRP_MJ_PNP:

       Status = IpxDispatchPnP(DeviceObject, Request);                                    
       break;                                                                 

    //
    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    //

    case IRP_MJ_CREATE:

       // We should reject CREATE when we are stopping

       if (Device->State == DEVICE_STATE_STOPPING) {
	  Status = STATUS_INVALID_DEVICE_STATE;
	  break; 
       }

        openType = OPEN_REQUEST_EA_INFORMATION(Request);

        if (openType != NULL) {

            found = FALSE;

	    if (strncmp(openType->EaName, TdiTransportAddress,
                            openType->EaNameLength) == 0)
            {
               found = TRUE;
            }

            if (found) {
                Status = IpxOpenAddress (Device, Request);
                break;
            }

            //
            // Router
            //
            if (strncmp(openType->EaName, ROUTER_INTERFACE,
                            openType->EaNameLength) == 0)
            {
               found = TRUE;
            }

            if (found) {
                Status = OpenRtAddress (Device, Request);
                break;
            }
            //
            // Connection?
            //

	    if (strncmp(openType->EaName, TdiConnectionContext,
                            openType->EaNameLength) == 0)
            {
               found = TRUE;
            }

            if (found) {
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            else
            {
               Status = STATUS_NONEXISTENT_EA_ENTRY;

            }

        } else {

            CTEGetLock (&Device->Lock, &LockHandle);

            //
            // LowPart is in the OPEN_CONTEXT directly.
            // HighPart goes into the upper 2 bytes of the OPEN_TYPE.
            //
#ifdef _WIN64             
	    REQUEST_OPEN_CONTEXT(Request) = (PVOID)(Device->ControlChannelIdentifier.QuadPart);
	    (ULONG_PTR)(REQUEST_OPEN_TYPE(Request)) = IPX_FILE_TYPE_CONTROL;
#else
	    REQUEST_OPEN_CONTEXT(Request) = (PVOID)(Device->ControlChannelIdentifier.LowPart);
            (ULONG)(REQUEST_OPEN_TYPE(Request)) = (Device->ControlChannelIdentifier.HighPart << 16);
            (ULONG)(REQUEST_OPEN_TYPE(Request)) |= IPX_FILE_TYPE_CONTROL;
#endif

            ++(Device->ControlChannelIdentifier.QuadPart);

            if (Device->ControlChannelIdentifier.QuadPart > MAX_CCID) {
                Device->ControlChannelIdentifier.QuadPart = 1;
            }

            CTEFreeLock (&Device->Lock, LockHandle);

            Status = STATUS_SUCCESS;
        }

        break;

    case IRP_MJ_CLOSE:

        //
        // The Close function closes a transport endpoint, terminates
        // all outstanding transport activity on the endpoint, and unbinds
        // the endpoint from its transport address, if any.  If this
        // is the last transport endpoint bound to the address, then
        // the address is removed from the provider.
        //
#ifdef _WIN64
        switch (Type = ((ULONG_PTR)(REQUEST_OPEN_TYPE(Request)))) {
#else
        switch (Type = ((ULONG)(REQUEST_OPEN_TYPE(Request)) & IPX_CC_MASK)) {
#endif
        default:
             if ((Type >= ROUTER_ADDRESS_FILE) &&
                    (Type <= (ROUTER_ADDRESS_FILE + IPX_RT_MAX_ADDRESSES)))
             {
                CloseRtAddress(Device, Request);
             }
             else
             {
                 Status = STATUS_INVALID_HANDLE;
                 break;
             }

             // fall through
        case TDI_TRANSPORT_ADDRESS_FILE:

            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);

            //
            // This creates a reference to AddressFile->Address
            // which is removed by IpxCloseAddressFile.
            //

            Status = IpxVerifyAddressFile(AddressFile);

            if (!NT_SUCCESS (Status)) {
                Status = STATUS_INVALID_HANDLE;
            } else {
                Status = IpxCloseAddressFile (Device, Request);
                IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);

            }

            break;

        case IPX_FILE_TYPE_CONTROL:
            {
                LARGE_INTEGER   ControlChannelId;

                CCID_FROM_REQUEST(ControlChannelId, Request);

                //
                // See if it is one of the upper driver's control channels.
                //

                Status = STATUS_SUCCESS;

                IPX_DEBUG (DEVICE, ("CCID: (%d, %d)\n", ControlChannelId.HighPart, ControlChannelId.LowPart));

		/*
		
		// Move to IRP_MJ_CLEANUP 360966
                for (i = 0; i < UPPER_DRIVER_COUNT; i++) {
                    if (Device->UpperDriverControlChannel[i].QuadPart ==
                            ControlChannelId.QuadPart) {
                        Status = IpxInternalUnbind (Device, i);
                        break;
                    }
                }
		*/

                break;
            }
        }

        break;

    case IRP_MJ_CLEANUP:

        //
        // Handle the two stage IRP for a file close operation. When the first
        // stage hits, run down all activity on the object of interest. This
        // do everything to it but remove the creation hold. Then, when the
        // CLOSE irp hits, actually close the object.
        //
#ifdef _WIN64
        switch (Type = ((ULONG_PTR)REQUEST_OPEN_TYPE(Request))) {
#else
        switch (Type = ((ULONG)(REQUEST_OPEN_TYPE(Request)) & IPX_CC_MASK)) {
#endif


        default:

             if ((Type >= ROUTER_ADDRESS_FILE) &&
                         (Type <= (ROUTER_ADDRESS_FILE + IPX_RT_MAX_ADDRESSES)))
             {
                CleanupRtAddress(Device, Request);
             }
             else
             {
                 Status = STATUS_INVALID_HANDLE;
                 break;
             }


            //
            // fall through
            //
        case TDI_TRANSPORT_ADDRESS_FILE:
            AddressFile = (PADDRESS_FILE)REQUEST_OPEN_CONTEXT(Request);
            Status = IpxVerifyAddressFile(AddressFile);
            if (!NT_SUCCESS (Status)) {

                Status = STATUS_INVALID_HANDLE;

            } else {

                IpxStopAddressFile (AddressFile);
                IpxDereferenceAddressFile (AddressFile, AFREF_VERIFY);
                Status = STATUS_SUCCESS;
            }

            break;

        case IPX_FILE_TYPE_CONTROL:
            {
                LARGE_INTEGER   ControlChannelId;

                CCID_FROM_REQUEST(ControlChannelId, Request);

		IPX_DEBUG (DEVICE, ("CCID: (%d, %d)\n", ControlChannelId.HighPart, ControlChannelId.LowPart));
                //
                // Check for any line change IRPs submitted by this
                // address.
                //

                IpxAbortLineChanges ((PVOID)&ControlChannelId);
                IpxAbortNtfChanges ((PVOID)&ControlChannelId);

		Status = STATUS_SUCCESS;
		
		for (i = 0; i < UPPER_DRIVER_COUNT; i++) {
		   if (Device->UpperDriverControlChannel[i].QuadPart ==
		       ControlChannelId.QuadPart) {
			if (Irp->RequestorMode == KernelMode) {
			   Status = IpxInternalUnbind (Device, i);
			} else {
			   DbgPrint("!!!! IPX:Rejected non-kernel-mode component's attemp to close handles. !!!!\n"); 
			   Status = STATUS_UNSUCCESSFUL; 
			}
			break;
                    }
                }


                break;
            }
        }

        break;


    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;

    } /* major function switch */

    if (Status != STATUS_PENDING) {
        UNMARK_REQUEST_PENDING(Request);
        REQUEST_STATUS(Request) = Status;
        IpxCompleteRequest (Request);
        IpxFreeRequest (Device, Request);
    }

    //
    // Return the immediate status code to the caller.
    //

    return Status;

}   /* IpxDispatchOpenClose */

#define IOCTL_IPX_LOAD_SPX      _IPX_CONTROL_CODE( 0x5678, METHOD_BUFFERED )

NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
    IN PUNICODE_STRING DriverServiceName
    );


NTSTATUS
IpxDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE Device = IpxDevice;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    static NDIS_STRING SpxServiceName = NDIS_STRING_CONST ("\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NwlnkSpx");
    KPROCESSOR_MODE PreviousMode;

    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    //
    // Branch to the appropriate request handler.  Preliminary checking of
    // the size of the request block is performed here so that it is known
    // in the handlers that the minimum input parameters are readable.  It
    // is *not* determined here whether variable length input fields are
    // passed correctly; this is a check which must be made within each routine.
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER: {


#ifdef SUNDOWN
           PULONG_PTR EntryPoint; 
#else
	   PULONG EntryPoint;
#endif



            //
            // This is the LanmanServer trying to get the send
            // entry point.
            //

            IPX_DEBUG (BIND, ("Direct send entry point being returned\n"));

            EntryPoint = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            
            //
            //  96390: SEC PROBES [ShreeM]
            //

            //
            // Get previous processor mode
            //
        
            PreviousMode = ExGetPreviousMode();
            
            if (PreviousMode != KernelMode) {
                
                try {

                 
#ifdef SUNDOWN
		   ProbeForWrite( EntryPoint,
                                  sizeof( ULONG_PTR ),
                                  TYPE_ALIGNMENT( ULONG_PTR )
                                 );
                    *EntryPoint = (ULONG_PTR)IpxTdiSendDatagram;
#else
		    ProbeForWrite( EntryPoint,
                                   sizeof( ULONG ),
                                   sizeof( ULONG )
                                 );
                    *EntryPoint = (ULONG)IpxTdiSendDatagram;
#endif



                } except( EXCEPTION_EXECUTE_HANDLER ) {
                      
                      Status = GetExceptionCode();
                      Irp->IoStatus.Status = Status;
                      IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

                      return( Status );

                }
            } else {
#ifdef SUNDOWN
                *EntryPoint = (ULONG_PTR)IpxTdiSendDatagram;
#else
                *EntryPoint = (ULONG)IpxTdiSendDatagram;
#endif



            }

                    
            Status = STATUS_SUCCESS;
            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            break;
        }

        case IOCTL_IPX_INTERNAL_BIND:

            //
            // This is a client trying to bind.
            //

            CTEAssert ((IOCTL_IPX_INTERNAL_BIND & 0x3) == METHOD_BUFFERED);
            CTEAssert (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

            
            if ((Device->State == DEVICE_STATE_CLOSED) ||
				(Device->State == DEVICE_STATE_STOPPING)) {
	        DbgPrint("IPX:IpxDispatchDeviceControl:Invalid Device state, skip internal bind\n"); 
                Status = STATUS_INVALID_DEVICE_STATE;

            } else {
	       PreviousMode = ExGetPreviousMode();	       
	       if (PreviousMode == KernelMode) {
		  Status = IpxInternalBind (Device, Irp);
	       } else {
		  DbgPrint("IPX:Caller is not in kernel mode.\n"); 
		  Status = STATUS_UNSUCCESSFUL; 
	       }

            }

            CTEAssert (Status != STATUS_PENDING);

            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            break;

        case IOCTL_IPX_LOAD_SPX:

            //
            // The SPX helper dll is asking us to load SPX.
            //

            Status = ZwLoadDriver (&SpxServiceName);

            Irp->IoStatus.Status = Status;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            break;

#ifdef  SNMP
        case    IOCTL_IPX_MIB_GET: {

            //
            // Get the Base MIB entries out of the device. All Host-side
            // entries, appearing in the MS and Novell MIBs are returned.
            //
            PNOVIPXMIB_BASE    UserBuffer;

            UserBuffer = (PNOVIPXMIB_BASE)Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = sizeof(NOVIPXMIB_BASE);

            RtlCopyMemory(  UserBuffer,
                            &Device->MibBase,
                            sizeof(NOVIPXMIB_BASE));

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            Status = STATUS_SUCCESS;

            break;
        }
#endif SNMP

        case MIPX_SEND_DATAGRAM:
            MARK_REQUEST_PENDING(Irp);
            Status = SendIrpFromRt (Device, Irp);
            if (Status == STATUS_PENDING) {
                return STATUS_PENDING;
            } else {
                UNMARK_REQUEST_PENDING(Irp);
                REQUEST_STATUS(Irp) = Status;
                IpxCompleteRequest (Irp);
                IpxFreeRequest (Device, Irp);
                return Status;
            }

            break;

        case MIPX_RCV_DATAGRAM:
            MARK_REQUEST_PENDING(Irp);
            Status =  RcvIrpFromRt (Device, Irp);
            if (Status == STATUS_PENDING) {
                return STATUS_PENDING;
            } else {
                UNMARK_REQUEST_PENDING(Irp);
                REQUEST_STATUS(Irp) = Status;
                IpxCompleteRequest (Irp);
                IpxFreeRequest (Device, Irp);
                return Status;
            }

            break;


        default:

            //
            // Convert the user call to the proper internal device call.
            //

            Status = TdiMapUserRequest (DeviceObject, Irp, IrpSp);

            if (Status == STATUS_SUCCESS) {

                //
                // If TdiMapUserRequest returns SUCCESS then the IRP
                // has been converted into an IRP_MJ_INTERNAL_DEVICE_CONTROL
                // IRP, so we dispatch it as usual. The IRP will
                // be completed by this call.
                //

                Status = IpxDispatchInternal (DeviceObject, Irp);

            } else {

                Irp->IoStatus.Status = Status;
                IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);

            }

            break;
    }
    return Status;

}   /* IpxDispatchDeviceControl */


NTSTATUS
IpxDispatchInternal (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches TDI request types to different handlers based
    on the minor IOCTL function code in the IRP's current stack location.
    In addition to cracking the minor function code, this routine also
    reaches into the IRP and passes the packetized parameters stored there
    as parameters to the various TDI request handlers so that they are
    not IRP-dependent.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;
    PDEVICE Device = IpxDevice;
    PREQUEST Request;

    ASSERT( DeviceObject->DeviceExtension == IpxDevice );

    if (Device->State == DEVICE_STATE_OPEN) {

        //
        // Allocate a request to track this IRP.
        //

        Request = IpxAllocateRequest (Device, Irp);

        IF_NOT_ALLOCATED(Request) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // Make sure status information is consistent every time.
        //

        MARK_REQUEST_PENDING(Request);
#if DBG
        REQUEST_STATUS(Request) = STATUS_PENDING;
        REQUEST_INFORMATION(Request) = 0;
#endif

        //
        // Branch to the appropriate request handler.  Preliminary checking of
        // the size of the request block is performed here so that it is known
        // in the handlers that the minimum input parameters are readable.  It
        // is *not* determined here whether variable length input fields are
        // passed correctly; this is a check which must be made within each routine.
        //

        switch (REQUEST_MINOR_FUNCTION(Request)) {

            case TDI_SEND_DATAGRAM:
                Status = IpxTdiSendDatagram (DeviceObject, Request);
                break;

            case TDI_ACTION:
                Status = IpxTdiAction (Device, Request);
                break;

            case TDI_QUERY_INFORMATION:
                Status = IpxTdiQueryInformation (Device, Request);
                break;

            case TDI_RECEIVE_DATAGRAM:
                Status =  IpxTdiReceiveDatagram (Request);
                break;

            case TDI_SET_EVENT_HANDLER:
                Status = IpxTdiSetEventHandler (Request);
                break;

            case TDI_SET_INFORMATION:
                Status = IpxTdiSetInformation (Device, Request);
                break;


            //
            // Something we don't know about was submitted.
            //

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // Return the immediate status code to the caller.
        //

        if (Status == STATUS_PENDING) {

            return STATUS_PENDING;

        } else {

            UNMARK_REQUEST_PENDING(Request);
            REQUEST_STATUS(Request) = Status;
            IpxCompleteRequest (Request);
            IpxFreeRequest (Device, Request);
            return Status;
        }


    } else {

        //
        // The device was not open.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }



}   /* IpxDispatchInternal */


PVOID
IpxpAllocateMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN BOOLEAN ChargeDevice
    )

/*++

Routine Description:

    This routine allocates memory, making sure it is within
    the limit allowed by the device.

Arguments:

    BytesNeeded - The number of bytes to allocated.

    ChargeDevice - TRUE if the device should be charged.

Return Value:

    None.

--*/

{
    PVOID Memory;
    PDEVICE Device = IpxDevice;

    if (ChargeDevice) {
        if ((Device->MemoryLimit != 0) &&
                (((LONG)(Device->MemoryUsage + BytesNeeded) >
                    Device->MemoryLimit))) {

            IpxPrint1 ("IPX: Could not allocate %d: limit\n", BytesNeeded);
            IpxWriteResourceErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_RESOURCE_POOL,
                BytesNeeded,
                Tag);

            return NULL;
        }
    }

#if ISN_NT
    Memory = ExAllocatePoolWithTag (NonPagedPool, BytesNeeded, ' XPI');
#else
    Memory = CTEAllocMem (BytesNeeded);
#endif

    if (Memory == NULL) {

        IpxPrint1("IPX: Could not allocate %d: no pool\n", BytesNeeded);
        if (ChargeDevice) {
            IpxWriteResourceErrorLog(
                Device->DeviceObject,
                EVENT_TRANSPORT_RESOURCE_POOL,
                BytesNeeded,
                Tag);
        }

        return NULL;
    }

    if (ChargeDevice) {
        Device->MemoryUsage += BytesNeeded;
    }

    return Memory;
}   /* IpxpAllocateMemory */


VOID
IpxpFreeMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN BOOLEAN ChargeDevice
    )

/*++

Routine Description:

    This routine frees memory allocated with IpxpAllocateMemory.

Arguments:

    Memory - The memory allocated.

    BytesAllocated - The number of bytes to freed.

    ChargeDevice - TRUE if the device should be charged.

Return Value:

    None.

--*/

{
    PDEVICE Device = IpxDevice;

#if ISN_NT
    ExFreePool (Memory);
#else
    CTEFreeMem (Memory);
#endif
    if (ChargeDevice) {
        Device->MemoryUsage -= BytesAllocated;
    }

}   /* IpxpFreeMemory */

#if DBG


PVOID
IpxpAllocateTaggedMemory(
    IN ULONG BytesNeeded,
    IN ULONG Tag,
    IN PUCHAR Description
    )

/*++

Routine Description:

    This routine allocates memory, charging it to the device.
    If it cannot allocate memory it uses the Tag and Descriptor
    to log an error.

Arguments:

    BytesNeeded - The number of bytes to allocated.

    Tag - A unique ID used in the error log.

    Description - A text description of the allocation.

Return Value:

    None.

--*/

{
    PVOID Memory;

    UNREFERENCED_PARAMETER(Description);

    Memory = IpxpAllocateMemory(BytesNeeded, Tag, (BOOLEAN)(Tag != MEMORY_CONFIG));

    if (Memory) {
        (VOID)IPX_ADD_ULONG(
            &IpxMemoryTag[Tag].BytesAllocated,
            BytesNeeded,
            &IpxMemoryInterlock);
    }

    return Memory;

}   /* IpxpAllocateTaggedMemory */


VOID
IpxpFreeTaggedMemory(
    IN PVOID Memory,
    IN ULONG BytesAllocated,
    IN ULONG Tag,
    IN PUCHAR Description
    )

/*++

Routine Description:

    This routine frees memory allocated with IpxpAllocateTaggedMemory.

Arguments:

    Memory - The memory allocated.

    BytesAllocated - The number of bytes to freed.

    Tag - A unique ID used in the error log.

    Description - A text description of the allocation.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Description);

    (VOID)IPX_ADD_ULONG(
        &IpxMemoryTag[Tag].BytesAllocated,
        (ULONG)(-(LONG)BytesAllocated),
        &IpxMemoryInterlock);

    IpxpFreeMemory (Memory, BytesAllocated, (BOOLEAN)(Tag != MEMORY_CONFIG));

}   /* IpxpFreeTaggedMemory */

#endif


VOID
IpxWriteResourceErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG BytesNeeded,
    IN ULONG UniqueErrorValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry which has
    a %3 value that needs to be converted to a string. It is currently
    used for EVENT_TRANSPORT_RESOURCE_POOL and EVENT_IPX_INTERNAL_NET_
    INVALID.

Arguments:

    DeviceObject - Pointer to the system device object.

    ErrorCode - The transport event code.

    BytesNeeded - If applicable, the number of bytes that could not
        be allocated -- will be put in the dump data.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet and converted for use as the %3 string.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    PUCHAR StringLoc;
    ULONG TempUniqueError;
    PDEVICE Device = IpxDevice;
    static WCHAR UniqueErrorBuffer[9] = L"00000000";
    UINT CurrentDigit;
    INT i;


    //
    // Convert the error value into a buffer.
    //

    TempUniqueError = UniqueErrorValue;
    i = 8;
    do {
        CurrentDigit = TempUniqueError & 0xf;
        TempUniqueError >>= 4;
        i--;
        if (CurrentDigit >= 0xa) {
            UniqueErrorBuffer[i] = (WCHAR)(CurrentDigit - 0xa + L'A');
        } else {
            UniqueErrorBuffer[i] = (WCHAR)(CurrentDigit + L'0');
        }
    } while (TempUniqueError);

	// cast to UCHAR to avoid 64-bit warning. 
    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
						 Device->DeviceNameLength +
						 sizeof(UniqueErrorBuffer) - (i * sizeof(WCHAR)));

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        EntrySize
    );

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = sizeof(ULONG);
        errorLogEntry->NumberOfStrings = 2;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DumpData[0] = BytesNeeded;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;

        // This routine may be called before IpxDevice is created. 
        if (Device != NULL) {
           RtlCopyMemory (StringLoc, Device->DeviceName, Device->DeviceNameLength);

           StringLoc += Device->DeviceNameLength;
        } 

        RtlCopyMemory (StringLoc, UniqueErrorBuffer + i, sizeof(UniqueErrorBuffer) - (i * sizeof(WCHAR)));

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* IpxWriteResourceErrorLog */


VOID
IpxWriteGeneralErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PWSTR SecondString,
    IN ULONG DumpDataCount,
    IN ULONG DumpData[]
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a general problem as indicated by the parameters. It handles
    event codes REGISTER_FAILED, BINDING_FAILED, ADAPTER_NOT_FOUND,
    TRANSFER_DATA, TOO_MANY_LINKS, and BAD_PROTOCOL. All these
    events have messages with one or two strings in them.

Arguments:

    DeviceObject - Pointer to the system device object, or this may be
        a driver object instead.

    ErrorCode - The transport event code.

    UniqueErrorValue - Used as the UniqueErrorValue in the error log
        packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    SecondString - If not NULL, the string to use as the %3
        value in the error log packet.

    DumpDataCount - The number of ULONGs of dump data.

    DumpData - Dump data for the packet.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG SecondStringSize;
    PUCHAR StringLoc;
    PDEVICE Device = IpxDevice;
    static WCHAR DriverName[9] = L"NwlnkIpx";

#if DBG
	if ((sizeof(IO_ERROR_LOG_PACKET) + (DumpDataCount * sizeof(ULONG))) > 255) {
		DbgPrint("IPX: Data size is greater than the maximum size allowed by UCHAR\n"); 
	} 
#endif

    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
                (DumpDataCount * sizeof(ULONG)));

    if (DeviceObject->Type == IO_TYPE_DEVICE) {
        EntrySize += (UCHAR)Device->DeviceNameLength;
    } else {
        EntrySize += sizeof(DriverName);
    }

    if (SecondString) {
        SecondStringSize = (wcslen(SecondString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
        EntrySize += (UCHAR)SecondStringSize;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        EntrySize
    );

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = (USHORT)(DumpDataCount * sizeof(ULONG));
        errorLogEntry->NumberOfStrings = (SecondString == NULL) ? 1 : 2;
        errorLogEntry->StringOffset = (USHORT) 
            (sizeof(IO_ERROR_LOG_PACKET) + ((DumpDataCount-1) * sizeof(ULONG)));
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        if (DumpDataCount) {
            RtlCopyMemory(errorLogEntry->DumpData, DumpData, DumpDataCount * sizeof(ULONG));
        }

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        if (DeviceObject->Type == IO_TYPE_DEVICE) {
            RtlCopyMemory (StringLoc, Device->DeviceName, Device->DeviceNameLength);
            StringLoc += Device->DeviceNameLength;
        } else {
            RtlCopyMemory (StringLoc, DriverName, sizeof(DriverName));
            StringLoc += sizeof(DriverName);
        }
        if (SecondString) {
            RtlCopyMemory (StringLoc, SecondString, SecondStringSize);
        }

        IoWriteErrorLogEntry(errorLogEntry);

    } else {
       DbgPrint("IPX: Failed to allocate %d bytes for IO error log entry.\n", EntrySize); 
    }

}   /* IpxWriteGeneralErrorLog */


VOID
IpxWriteOidErrorLog(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS FinalStatus,
    IN PWSTR AdapterString,
    IN ULONG OidValue
    )

/*++

Routine Description:

    This routine allocates and writes an error log entry indicating
    a problem querying or setting an OID on an adapter. It handles
    event codes SET_OID_FAILED and QUERY_OID_FAILED.

Arguments:

    DeviceObject - Pointer to the system device object.

    ErrorCode - Used as the ErrorCode in the error log packet.

    FinalStatus - Used as the FinalStatus in the error log packet.

    AdapterString - The name of the adapter we were bound to.

    OidValue - The OID which could not be set or queried.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    UCHAR EntrySize;
    ULONG AdapterStringSize;
    PUCHAR StringLoc;
    PDEVICE Device = IpxDevice;
    static WCHAR OidBuffer[9] = L"00000000";
    INT i;
    UINT CurrentDigit;

    AdapterStringSize = (wcslen(AdapterString)*sizeof(WCHAR)) + sizeof(UNICODE_NULL);
    EntrySize = (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) -
						 sizeof(ULONG) +
						 Device->DeviceNameLength +
						 AdapterStringSize +
						 sizeof(OidBuffer));

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceObject,
        EntrySize
    );

    //
    // Convert the OID into a buffer.
    //

    for (i=7; i>=0; i--) {
        CurrentDigit = OidValue & 0xf;
        OidValue >>= 4;
        if (CurrentDigit >= 0xa) {
            OidBuffer[i] = (WCHAR)(CurrentDigit - 0xa + L'A');
        } else {
            OidBuffer[i] = (WCHAR)(CurrentDigit + L'0');
        }
    }

    if (errorLogEntry != NULL) {

        errorLogEntry->MajorFunctionCode = (UCHAR)-1;
        errorLogEntry->RetryCount = (UCHAR)-1;
        errorLogEntry->DumpDataSize = 0;
        errorLogEntry->NumberOfStrings = 3;
        errorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        errorLogEntry->EventCategory = 0;
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->SequenceNumber = (ULONG)-1;
        errorLogEntry->IoControlCode = 0;

        StringLoc = ((PUCHAR)errorLogEntry) + errorLogEntry->StringOffset;
        RtlCopyMemory (StringLoc, Device->DeviceName, Device->DeviceNameLength);
        StringLoc += Device->DeviceNameLength;

        RtlCopyMemory (StringLoc, OidBuffer, sizeof(OidBuffer));
        StringLoc += sizeof(OidBuffer);

        RtlCopyMemory (StringLoc, AdapterString, AdapterStringSize);

        IoWriteErrorLogEntry(errorLogEntry);

    }

}   /* IpxWriteOidErrorLog */


VOID
IpxPnPUpdateDevice(
    IN  PDEVICE Device
    )

/*++

Routine Description:

	Updates datagram sizes, lookahead sizes, etc. in the Device as a result
    of a new binding coming in.

Arguments:

    Device - The IPX device object.

Return Value:

    None.

--*/
{
    ULONG AnnouncedMaxDatagram = 0, RealMaxDatagram = 0, MaxLookahead = 0;
    ULONG LinkSpeed = 0, MacOptions = 0;
    ULONG i;
    PBINDING    Binding;
    IPX_DEFINE_LOCK_HANDLE (LockHandle)

    IPX_GET_LOCK1(&Device->BindAccessLock, &LockHandle);

    if (Device->ValidBindings) {

       //
       // Calculate some values based on all the bindings.
       //
       
       MaxLookahead = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->MaxLookaheadData; // largest binding value
       AnnouncedMaxDatagram = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->AnnouncedMaxDatagramSize;   // smallest binding value
       RealMaxDatagram = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->RealMaxDatagramSize;   // smallest binding value
   
       if (NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->LineUp) {
           LinkSpeed = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->MediumSpeed;  // smallest binding value
       } else {
           LinkSpeed = 0xffffffff;
       }
       MacOptions = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->Adapter->MacInfo.MacOptions; // AND of binding values
   
       for (i = FIRST_REAL_BINDING; i <= Device->ValidBindings; i++) {
   
           Binding = NIC_ID_TO_BINDING_NO_ILOCK(Device, i);
   
           if (!Binding) {
               continue;
           }
   
           if (Binding->MaxLookaheadData > MaxLookahead) {
               MaxLookahead = Binding->MaxLookaheadData;
           }
           if (Binding->AnnouncedMaxDatagramSize < AnnouncedMaxDatagram) {
               AnnouncedMaxDatagram = Binding->AnnouncedMaxDatagramSize;
           }
           if (Binding->RealMaxDatagramSize < RealMaxDatagram) {
               RealMaxDatagram = Binding->RealMaxDatagramSize;
           }
   
           if (Binding->LineUp && (Binding->MediumSpeed < LinkSpeed)) {
               LinkSpeed = Binding->MediumSpeed;
           }
           MacOptions &= Binding->Adapter->MacInfo.MacOptions;
   
       }
       
       //
       // If we couldn't find anything better, use the speed from
       // the first binding.
       //
   
       if (LinkSpeed == 0xffffffff) {
           Device->LinkSpeed = NIC_ID_TO_BINDING_NO_ILOCK(Device, 1)->MediumSpeed;
       } else {
           Device->LinkSpeed = LinkSpeed;
       }
       
       Device->MacOptions = MacOptions;
       
    } else {
       
       //
       // zero bindings means LinkSpeed = 0;
       //
       Device->LinkSpeed = 0;
    }
    
    Device->Information.MaxDatagramSize = AnnouncedMaxDatagram;
    Device->RealMaxDatagramSize = RealMaxDatagram;
    Device->Information.MaximumLookaheadData = MaxLookahead;
   

    IPX_FREE_LOCK1(&Device->BindAccessLock, LockHandle);
}

VOID
IpxPnPUpdateBindingArray(
    IN PDEVICE Device,
    IN PADAPTER	Adapter,
    IN PBINDING_CONFIG  ConfigBinding
    )

/*++

Routine Description:

    This routine is called to update the binding array to
	add the new bindings that appeared in this PnP event.
    The order of bindings in the array is as follows:

    - First comes the first binding to each LAN network
    - Following that are all WAN bindings
    - Following that are any duplicate bindings to LAN networks
        (the others in the "binding set").

	This routine inserts the bindings while maintaining this
	order by resolving binding sets.

	The bindings are also inserted into the RIP database.

    If "global wan net" is true we will advertis