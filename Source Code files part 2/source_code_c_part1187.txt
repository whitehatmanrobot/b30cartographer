   PptDetermineFifoDepth( Fdx );

        if( 0 == Fdx->PnpInfo.FifoDepth ) {
            // Probe for FIFO depth failed - mark ECP as bad chip mode
            Fdx->PnpInfo.HardwareCapabilities &= ~(PPT_ECP_PRESENT);
        }
    }
    
    // return ecr to original
    P5WritePortUchar( wPortECR, ecrLast );

    return;
}

VOID
PptDetectEppPortIfDot3DevicePresent(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    If a 1284.3 daisy chain device is present, use the dot3 device to screen
    any printer from signal leakage while doing EPP detection. Otherwise
    abort detection.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    NTSTATUS status;
    PUCHAR   Controller = Fdx->PortInfo.Controller;
    PARALLEL_1284_COMMAND Command;

    if( 0 == Fdx->PnpInfo.Ieee1284_3DeviceCount ) {
        // No dot3 DC device present - aborting - unsafe for some printers if we check for EPP here
        return;
    }
        
    //
    // 1284.3 daisy chain device is present. Use device to screen printer from
    //   possible signal leakage.
    //

    //
    // Select 1284.3 daisy chain  device
    //
    Command.ID           = 0;
    Command.Port         = 0;
    Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    status = PptTrySelectDevice( Fdx, &Command );
    if( !NT_SUCCESS( status ) ) {
        // unable to select device - something is wrong - just bail out
        return;
    }

    //
    // do the detection for chipset EPP capability
    //
    // DOT3 Device Present and selected
    PptDetectEppPort( Fdx );

    //
    // Deselect 1284.3 daisy chain device
    //
    Command.ID           = 0;
    Command.Port         = 0;
    Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    status = PptDeselectDevice( Fdx, &Command );
    if( !NT_SUCCESS( status ) ) {
        // deselect failed??? - this shouldn't happen - our daisy chain interface is likely hung
        DD((PCE)Fdx,DDE,"PptDetectEppPort - deselect of 1284.3 device FAILED - Controller=%x\n", Controller);
    }
    
    return;
}

VOID
PptDetectEppPortIfUserRequested(
    IN  PFDO_EXTENSION   Fdx
    )
/*++
      
Routine Description:
      
    If user explicitly requested Generic EPP detection then do the check.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
{
    ULONG RequestEppTest = 0;
    PptRegGetDeviceParameterDword( Fdx->PhysicalDeviceObject, (PWSTR)L"RequestEppTest", &RequestEppTest );
    if( RequestEppTest ) {
        DD((PCE)Fdx,DDT,"-- User Requested EPP detection - %x\n", RequestEppTest);
        PptDetectEppPort( Fdx );
    } else {
        DD((PCE)Fdx,DDT,"-- User did not request EPP detection\n");
    }
    return;
}

VOID
PptDetectEppPort(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine checks for EPP capable port after ECP was found.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    PUCHAR   Controller;
    UCHAR    dcr, i;
    UCHAR    Reverse = (UCHAR)(DCR_DIRECTION | DCR_NOT_INIT | DCR_AUTOFEED | DCR_DSTRB);
    UCHAR    Forward = (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED | DCR_DSTRB);

    ASSERTMSG(FALSE, "PptDetectEppPort shouldn't be called in current driver version");

    DD((PCE)Fdx,DDT,"-- PptDetectEppPort - Enter\n");
    DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: Enter\n");

    Controller = Fdx->PortInfo.Controller;
    
    // Get current DCR
    dcr = P5ReadPortUchar( Controller + DCR_OFFSET );

    //
    // Temporarily set capability to true to bypass PptEcrSetMode validity
    //   check. We'll clear the flag before we return if EPP test fails.
    //
    Fdx->PnpInfo.HardwareCapabilities |= PPT_EPP_PRESENT;

    // Setting EPP mode
    DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: Setting EPP Mode\n");
    PptEcrSetMode( Fdx, ECR_EPP_PIO_MODE );

    //
    // Testing the hardware for EPP capable
    //
    for ( i = 0x01; i <= 0x02; i++ ) {
        // Put it into reverse phase so it doesn't talk to a device
        P5WritePortUchar( Controller + DCR_OFFSET, Reverse );
        KeStallExecutionProcessor( 5 );
        P5WritePortUchar( Controller + EPP_OFFSET, (UCHAR)i );

        // put it back into forward phase to read the byte we put out there
        P5WritePortUchar( Controller + DCR_OFFSET, Forward );
        KeStallExecutionProcessor( 5 );
        if ( P5ReadPortUchar( Controller ) != i ) {
            // failure so clear EPP flag
            Fdx->PnpInfo.HardwareCapabilities &= ~PPT_EPP_PRESENT;
            break;
        }
    }

    // Clearing EPP Mode
    PptEcrClearMode( Fdx );
    // Restore DCR
    P5WritePortUchar( Controller + DCR_OFFSET, dcr );

    Fdx->CheckedForGenericEpp = TRUE; // check is complete

    if( Fdx->PnpInfo.HardwareCapabilities & PPT_EPP_PRESENT ) {
        DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: EPP present - Controller=%x\n", Controller);
        DD((PCE)Fdx,DDT,"-- PptDetectEppPort - HAVE Generic EPP\n");
    } else {
        DD((PCE)Fdx,DDT,"ParMode::PptDetectEppPort: EPP NOT present - Controller=%x\n", Controller);
        DD((PCE)Fdx,DDT,"-- PptDetectEppPort - DON'T HAVE Generic EPP\n");
    }

    DD((PCE)Fdx,DDT,"-- PptDetectEppPort - Exit\n");
    return;
}

VOID
PptDetectBytePort(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine check to see if the port is Byte capable.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Fdx,DDT,"ParMode::PptDetectBytePort Enter.\n" );

    Status = PptSetByteMode( Fdx, ECR_BYTE_PIO_MODE );

    if ( NT_SUCCESS(Status) ) {
        // Byte Mode found
        DD((PCE)Fdx,DDT,"ParMode::PptDetectBytePort: Byte Found\n");
        Fdx->PnpInfo.HardwareCapabilities |= PPT_BYTE_PRESENT;
    } else {
        // Byte Mode Not Found
        DD((PCE)Fdx,DDT,"ParMode::PptDetectBytePort: Byte Not Found\n");
    }    
    
    (VOID)PptClearByteMode( Fdx );

}

VOID PptDetermineFifoDepth(
    IN PFDO_EXTENSION   Fdx
    )
{
    PUCHAR  Controller;
    PUCHAR  wPortECR;       // IO address of Extended Control Register (ECR)
    PUCHAR  wPortDFIFO;
    UCHAR   ecr, ecrLast;
    ULONG   wFifoDepth;
    UCHAR   writeFifoDepth;     // Depth calculated while writing FIFO
    UCHAR   readFifoDepth;      // Depth calculated while reading FIFO
    ULONG   limitCount;         // Prevents infinite looping on FIFO status
    UCHAR   testData;
    
    Controller = Fdx->PortInfo.Controller;
    wPortECR =  Fdx->PnpInfo.EcpController+ ECR_OFFSET;
    wPortDFIFO = Fdx->PnpInfo.EcpController;
    wFifoDepth = 0;

    ecrLast = P5ReadPortUchar(wPortECR );

    P5WritePortUchar(wPortECR, DEFAULT_ECR_TEST );

    ecr = P5ReadPortUchar(wPortECR );
    
    if ( TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) ) {
    
        // Write bytes into the FIFO until it indicates full.
        writeFifoDepth = 0;
        limitCount     = 0;
        
        while (((P5ReadPortUchar (wPortECR) & ECR_FIFO_MASK) != ECR_FIFO_FULL ) &&
                    (limitCount <= ECP_MAX_FIFO_DEPTH)) {
                    
            P5WritePortUchar( wPortDFIFO, (UCHAR)(writeFifoDepth & 0xFF) );
            writeFifoDepth++;
            limitCount++;
        }
        
        DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth::  write fifo depth = %d\r\n", writeFifoDepth);

        // Now read the bytes back, comparing what comes back.
        readFifoDepth = 0;
        limitCount    = 0;
        
        while (((P5ReadPortUchar( wPortECR ) & ECR_FIFO_MASK ) != ECR_FIFO_EMPTY ) &&
                    (limitCount <= ECP_MAX_FIFO_DEPTH)) {
                    
            testData = P5ReadPortUchar( wPortDFIFO );
            if ( testData != (readFifoDepth & (UCHAR)0xFF )) {
            
                // Data mismatch indicates problems...
                // FIFO status didn't pan out, may not be an ECP chip after all
                P5WritePortUchar( wPortECR, ecrLast);
                DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth:::  data mismatch\n");
                return;
            }
            
            readFifoDepth++;
            limitCount++;
        }

        DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth:::  read fifo depth = %d\r\n", readFifoDepth);

        // The write depth should match the read depth...
        if ( writeFifoDepth == readFifoDepth ) {
        
            wFifoDepth = readFifoDepth;
            
        } else {
        
            // Assume no FIFO
            P5WritePortUchar( wPortECR, ecrLast);
            DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth:::  No Fifo\n");
            return;
        }
                
    } else {
    
        // FIFO status didn't pan out, may not be an ECP chip after all
        DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoDepth::  Bad Fifo\n");
        P5WritePortUchar(wPortECR, ecrLast);
        return;
    }

    // put chip into spp mode
    P5WritePortUchar( wPortECR, ecrLast );
    Fdx->PnpInfo.FifoDepth = wFifoDepth;
}

VOID
PptDetermineFifoWidth(
    IN PFDO_EXTENSION   Fdx
    )
{
    PUCHAR Controller;
    UCHAR   bConfigA;
    PUCHAR wPortECR;

    DD((PCE)Fdx,DDT,"ParMode::PptDetermineFifoWidth: Start\n");
    Controller = Fdx->PortInfo.Controller;

    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    // Put chip into configuration mode so we can access the ConfigA register
    P5WritePortUchar( wPortECR, DEFAULT_ECR_CONFIGURATION );

    // The FIFO width is bits <6:4> of the ConfigA register.
    bConfigA = P5ReadPortUchar( Fdx->PnpInfo.EcpController );
    Fdx->PnpInfo.FifoWidth = (ULONG)(( bConfigA & CNFGA_IMPID_MASK ) >> CNFGA_IMPID_SHIFT);

    // Put the chip back in compatibility mode.
    P5WritePortUchar(wPortECR, DEFAULT_ECR_COMPATIBILITY );
    return;
}

NTSTATUS
PptSetChipMode (
    IN  PFDO_EXTENSION  Fdx,
    IN  UCHAR              ChipMode
    )

/*++

Routine Description:

    This function will put the current parallel chip into the
    given mode if supported.  The determination of supported mode 
    was in the PptDetectPortType function.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    UCHAR EcrMode = (UCHAR)( ChipMode & ~ECR_MODE_MASK );

    // Also allow PptSetChipMode from PS/2 mode - we need this for HWECP
    //   bus flip from Forward to Reverse in order to meet the required
    //   sequence specified in the Microsoft ECP Port Spec version 1.06,
    //   July 14, 1993, to switch directly from PS/2 mode with output 
    //   drivers disabled (direction bit set to "read") to HWECP via 
    //   the ECR. Changed 2000-02-11.
    if ( Fdx->PnpInfo.CurrentMode != INITIAL_MODE && Fdx->PnpInfo.CurrentMode != ECR_BYTE_MODE ) {

        DD((PCE)Fdx,DDW,"PptSetChipMode - CurrentMode invalid\n");

        // Current mode is not valid to put in EPP or ECP mode
        Status = STATUS_INVALID_DEVICE_STATE;

        goto ExitSetChipModeNoChange;
    }

    // need to find out what mode it was and try to take it out of it
    
    // Check to see if we need to use the filter to set the mode
    if ( Fdx->FilterMode ) {
        Status = Fdx->ChipInfo.ParChipSetMode ( Fdx->ChipInfo.Context, ChipMode );
    } else {

        // If asked for ECP check to see if we can do it
        if ( EcrMode == ECR_ECP_MODE ) {
            if ((Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT) ^ PPT_ECP_PRESENT) {
                // ECP Not Present
                return STATUS_NO_SUCH_DEVICE;
            }
            Status = PptEcrSetMode ( Fdx, ChipMode );
            goto ExitSetChipModeWithChanges;
        }
        
        // If asked for EPP check to see if we can do it
        if ( EcrMode == ECR_EPP_MODE ) {
            if ((Fdx->PnpInfo.HardwareCapabilities & PPT_EPP_PRESENT) ^ PPT_EPP_PRESENT) {
                // EPP Not Present
                return STATUS_NO_SUCH_DEVICE;
            }
            Status = PptEcrSetMode ( Fdx, ChipMode );
            goto ExitSetChipModeWithChanges;
        }

        // If asked for Byte Mode check to see if it is still enabled
        if ( EcrMode == ECR_BYTE_MODE ) {
            if ((Fdx->PnpInfo.HardwareCapabilities & PPT_BYTE_PRESENT) ^ PPT_BYTE_PRESENT) {
                // BYTE Not Present
                return STATUS_NO_SUCH_DEVICE;
            }
            Status = PptSetByteMode ( Fdx, ChipMode );
            goto ExitSetChipModeWithChanges;
        }
    }
    
ExitSetChipModeWithChanges:

    if ( NT_SUCCESS(Status) ) {
        Fdx->PnpInfo.CurrentMode = EcrMode;
    } else {
        DD((PCE)Fdx,DDW,"PptSetChipMode - failed w/status = %x\n",Status);
    }

ExitSetChipModeNoChange:

    return Status;
}

NTSTATUS
PptClearChipMode (
    IN  PFDO_EXTENSION  Fdx,
    IN  UCHAR              ChipMode
    )
/*++

Routine Description:

    This routine Clears the Given chip mode.

Arguments:

    Fdx   - Supplies the device extension.
    ChipMode    - The given mode to clear from the Chip

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    ULONG EcrMode = ChipMode & ~ECR_MODE_MASK;

    // make sure we have a mode to clear
    if ( EcrMode != Fdx->PnpInfo.CurrentMode ) {
                
        DD((PCE)Fdx,DDW,"ParMode::PptClearChipMode: Mode to Clear != CurrentModen");

        // Current mode is not the same as requested to take it out of
        Status = STATUS_INVALID_DEVICE_STATE;

        goto ExitClearChipModeNoChange;
    }

    // need to find out what mode it was and try to take it out of it
    
    // check to see if we used the filter to set the mode
    if ( Fdx->FilterMode ) {
        Status = Fdx->ChipInfo.ParChipClearMode ( Fdx->ChipInfo.Context, ChipMode );
    } else {

        // If ECP mode check to see if we can clear it
        if ( EcrMode == ECR_ECP_MODE ) {
            Status = PptEcrClearMode( Fdx );
            goto ExitClearChipModeWithChanges;
        }
    
        // If EPP mode check to see if we can clear it
        if ( EcrMode == ECR_EPP_MODE ) {
            Status = PptEcrClearMode( Fdx );
            goto ExitClearChipModeWithChanges;
        }

        // If BYTE mode clear it if use ECR register
        if ( EcrMode == ECR_BYTE_MODE ) {
            Status = PptClearByteMode( Fdx );
            goto ExitClearChipModeWithChanges;
        }    
    }
    
ExitClearChipModeWithChanges:

    if( NT_SUCCESS(Status) ) {
        Fdx->PnpInfo.CurrentMode = INITIAL_MODE;
    }

ExitClearChipModeNoChange:

    return Status;
}

NTSTATUS
PptEcrSetMode(
    IN  PFDO_EXTENSION   Fdx,
    IN  UCHAR               ChipMode
    )

/*++

Routine Description:

    This routine enables EPP mode through the ECR register.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{

    UCHAR   ecr;
    PUCHAR  Controller;
    PUCHAR  wPortECR;
            
    Controller = Fdx->PortInfo.Controller;
    
    //
    // Store the prior mode.
    //
    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    ecr = P5ReadPortUchar( wPortECR );
    Fdx->EcrPortData = ecr;
    
    // get rid of prior mode which is the top three bits
    ecr &= ECR_MODE_MASK;

    // Write out SPP mode first to the chip
    P5WritePortUchar( wPortECR, (UCHAR)(ecr | ECR_BYTE_MODE) );

    // Write new mode to ECR register    
    P5WritePortUchar( wPortECR, ChipMode );
    
    return STATUS_SUCCESS;

}

NTSTATUS
PptSetByteMode( 
    IN  PFDO_EXTENSION   Fdx,
    IN  UCHAR               ChipMode
    )

/*++

Routine Description:

    This routine enables Byte mode either through the ECR register 
    (if available).  Or just checks it to see if it works

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/
{
    NTSTATUS    Status;
    
    // Checking to see if ECR register is there and if there use it
    if ( Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {
        Status = PptEcrSetMode( Fdx, ChipMode );    
    }
    
    Status = PptCheckByteMode( Fdx );

    return Status;

}    

NTSTATUS
PptClearByteMode( 
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine Clears Byte mode through the ECR register if there otherwise
    just returns success because nothing needs to be done.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // Put ECR register back to original if it was there
    if ( Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {
        Status = PptEcrClearMode( Fdx );    
    }
    
    return Status;
}    

NTSTATUS
PptCheckByteMode(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine checks to make sure we are still Byte capable before doing
    any transfering of data.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    PUCHAR  Controller;
    UCHAR   dcr;
    
    Controller = Fdx->PortInfo.Controller;

    //
    // run the test again to make sure somebody didn't take us out of a
    // bi-directional capable port.
    //
    // 1. put in extended read mode.
    // 2. write data pattern
    // 3. read data pattern
    // 4. if bi-directional capable, then data patterns will be different.
    // 5. if patterns are the same, then check one more pattern.
    // 6. if patterns are still the same, then port is NOT bi-directional.
    //

    // get the current control port value for later restoration
    dcr = P5ReadPortUchar( Controller + DCR_OFFSET );

    // put port into extended read mode
    P5WritePortUchar( Controller + DCR_OFFSET, (UCHAR)(dcr | DCR_DIRECTION) );

    // write the first pattern to the port
    P5WritePortUchar( Controller, (UCHAR)0x55 );
    if ( P5ReadPortUchar( Controller ) == (UCHAR)0x55 ) {
        // same pattern, try the second pattern
        P5WritePortUchar( Controller, (UCHAR)0xaa );
        if ( P5ReadPortUchar( Controller ) == (UCHAR)0xaa ) {
            // the port is NOT bi-directional capable
            return STATUS_UNSUCCESSFUL;
        }
    }

    // restore the control port to its original value
    P5WritePortUchar( Controller + DCR_OFFSET, (UCHAR)dcr );

    return STATUS_SUCCESS;

}

NTSTATUS
PptEcrClearMode(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine disables EPP or ECP mode whichever one the chip
    was in through the ECR register.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if it was successful.
   !STATUS_SUCCESS  - otherwise.

--*/

{

    UCHAR   ecr;
    PUCHAR  Controller;
    PUCHAR  wPortECR;
    
    Controller = Fdx->PortInfo.Controller;
    
    //
    // Restore the prior mode.
    //

    // Get original ECR register
    ecr = Fdx->EcrPortData;
    Fdx->EcrPortData = 0;

    // some chips require to change modes only after 
    // you put it into spp mode

    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    P5WritePortUchar( wPortECR, (UCHAR)(ecr & ECR_MODE_MASK) );

    // Back to original mode
    P5WritePortUchar( wPortECR, ecr );
    
    return STATUS_SUCCESS;

}


NTSTATUS
PptBuildResourceList(
    IN  PFDO_EXTENSION   Fdx,
    IN  ULONG               Partial,
    IN  PUCHAR             *Addresses,
    OUT PCM_RESOURCE_LIST   Resources
    )

/*++

Routine Description:

    This routine Builds a CM_RESOURCE_LIST with 1 Full Resource
    Descriptor and as many Partial resource descriptors as you want
    with the same parameters for the Full.  No Interrupts or anything
    else just IO addresses.

Arguments:

    Fdx   - Supplies the device extension.
    Partial     - Number (array size) of partial descriptors in Addresses[]
    Addresses   - Pointer to an Array of addresses of the partial descriptors
    Resources   - The returned CM_RESOURCE_LIST

Return Value:

    STATUS_SUCCESS       - if the building of the list was successful.
    STATUS_UNSUCCESSFUL  - otherwise.

--*/

{

    UCHAR       i;

    //
    // Number of Full Resource descriptors
    //
    Resources->Count = 1;
    
    Resources->List[0].InterfaceType = Fdx->InterfaceType;
    Resources->List[0].BusNumber = Fdx->BusNumber;
    Resources->List[0].PartialResourceList.Version = 0;
    Resources->List[0].PartialResourceList.Revision = 0;
    Resources->List[0].PartialResourceList.Count = Partial;

    //
    // Going through the loop for each partial descriptor
    //
    for ( i = 0; i < Partial ; i++ ) {

        //
        // Setup port
        //
        Resources->List[0].PartialResourceList.PartialDescriptors[i].Type = CmResourceTypePort;
        Resources->List[0].PartialResourceList.PartialDescriptors[i].ShareDisposition = CmResourceShareDriverExclusive;
        Resources->List[0].PartialResourceList.PartialDescriptors[i].Flags = CM_RESOURCE_PORT_IO;
        Resources->List[0].PartialResourceList.PartialDescriptors[i].u.Port.Start.QuadPart = (ULONG_PTR)Addresses[i];
        Resources->List[0].PartialResourceList.PartialDescriptors[i].u.Port.Length = (ULONG)2;

    }


    return ( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File: debug.h
//
//--------------------------------------------------------------------------

#ifndef _DEBUG_H_
#define _DEBUG_H_

//
// Debug Defines and Macros
//   

extern ULONG d1;
extern ULONG d2;
extern ULONG d3;
extern ULONG d4;
extern ULONG d5;
extern ULONG d6;
extern ULONG d7;
extern ULONG d8;
extern ULONG d9;

extern ULONG Trace;
extern ULONG Break;

extern ULONG AllowAsserts;

//
// set bits using DD_* bit defs to mask off debug spew for a specific device
//
extern ULONG DbgMaskFdo;
extern ULONG DbgMaskRawPort;
extern ULONG DbgMaskDaisyChain0;
extern ULONG DbgMaskDaisyChain1;
extern ULONG DbgMaskEndOfChain;
extern ULONG DbgMaskLegacyZip;
extern ULONG DbgMaskNoDevice;

#define PptAssert(_expr_) if( AllowAsserts ) ASSERT((_expr_))
#define PptAssertMsg(_msg_,_expr_) if( AllowAsserts ) ASSERTMSG((_msg_),(_expr_))

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

//
// Break bit definitions:
//
#define PPT_BREAK_ON_DRIVER_ENTRY 0x00000001

#define PptBreakOnRequest( BREAK_CONDITION, STRING) \
                if( Break & (BREAK_CONDITION) ) { \
                    DbgPrint STRING; \
                    DbgBreakPoint(); \
                }

// driver logic analyzer - show data bytes xfer'd in NIBBLE and/or BECP/HWECP modes
// 1 == ON
// 0 == OFF
#define DBG_SHOW_BYTES 0
#if 1 == DBG_SHOW_BYTES
extern ULONG DbgShowBytes;
#endif

#if DBG
#define PptEnableDebugSpew 1
#else
#define PptEnableDebugSpew 0
#endif

#if 1 == PptEnableDebugSpew
#define DD PptPrint
#else
#define DD
#define P5ReadPortUchar( _PORT_ ) READ_PORT_UCHAR( (_PORT_) )
#define P5ReadPortBufferUchar( _PORT_, _BUFFER_, _COUNT_ ) READ_PORT_BUFFER_UCHAR( (_PORT_), (_BUFFER_), (_COUNT_) )
#define P5WritePortUchar( _PORT_, _VALUE_ ) WRITE_PORT_UCHAR( (_PORT_), (_VALUE_) )
#define P5WritePortBufferUchar( _PORT_, _BUFFER_, _COUNT_ ) WRITE_PORT_BUFFER_UCHAR( (_PORT_), (_BUFFER_), (_COUNT_) )
#define PptFdoDumpPnpIrpInfo( _FDO_, _IRP_ ) 
#define PptPdoDumpPnpIrpInfo( _PDO_, _IRP_ )
#define P5TraceIrpArrival( _DEVOBJ_, _IRP_ )
#define P5TraceIrpCompletion( _IRP_ )
#define PptAcquireRemoveLock( _REMOVELOCK_, _TAG_ ) IoAcquireRemoveLock( (_REMOVELOCK_), (_TAG_) )
#define PptReleaseRemoveLock( _REMOVELOCK_, _TAG_ ) IoReleaseRemoveLock( (_REMOVELOCK_), (_TAG_) )
#define PptReleaseRemoveLockAndWait( _REMOVELOCK_, _TAG_ ) IoReleaseRemoveLockAndWait( (_REMOVELOCK_), (_TAG_) )
#define P5SetPhase( _PDX_, _PHASE_ ) (_PDX_)->CurrentPhase = (_PHASE_)
#define P5BSetPhase( _IEEESTATE_, _PHASE_ ) (_IEEESTATE_)->CurrentPhase = (_PHASE_)
#endif

VOID
PptPrint( PCOMMON_EXTENSION Ext, ULONG Flags, PCHAR FmtStr, ... );

//
// Trace bit definitions:
//
#define DDE     0x00000001 // Error messages
#define DDW     0x00000002 // Warning messages
#define DDT     0x00000004 // program Trace messages
#define DDINFO  0x00000008 // Informational messages

#define DDP     0x00000010 // Pnp and Power messages
#define DDC     0x00000020 // daisy Chain messages - select/deselect
#define DDA     0x00000040 // port Arbitration messages - acquire/release of port
#define DDR     0x00000080 // Registry access

#define DD_SEL  0x01000000 // Acquire/Release port & DaisyChain Select/Deselect device
#define DD_DL   0x02000000 // 1284.3 DataLink (for dot4)

#define DDB     0x00000100 // show Bytes written to / read from i/o ports
#define DD_IU   0x00000200 // Init(DriverEntry)/Unload
#define DD_PNP1 0x00000400 // PnP on FDO
#define DD_PNP2 0x00000800 // PnP on PDO

#define DD_OC1  0x00001000 // Open/Close/Cleanup on FDO
#define DD_OC2  0x00002000 // Open/Close/Cleanup on PDO
#define DD_RW   0x00004000 // Read/Write
#define DD_RWV  0x00008000 // Read/Write Verbose

#define DD_IEEE 0x00010000 // IEEE negotiation/termination etc.
#define DD_CHIP 0x00020000 // parallel port chip info
#define DD_ERR  0x00040000 // Error detected
#define DD_WRN  0x00080000 // Warning

#define DD_CAN  0x00200000 // Cancel
#define DD_SM   0x00400000 // IEEE state machine (state & phase)
#define DD_EX   0x00800000 // Exported functions (to ppa/ppa3)

#define DD_TMP1 0x10000000 // temp 1 - used for temporary debugging
#define DD_TMP2 0x20000000 // temp 2 - used for temporary debugging

#define DD_VERB 0x80000000 // Verbose

#define DDPrint( _b_, _x_ ) if( (_b_) & Trace ) DbgPrint _x_

// 
// Specific Diagnostics
// 

//
// DVRH_SHOW_BYTE_LOG   0 - Byte Log off
//                      1 - Byte Log on
#define DVRH_SHOW_BYTE_LOG  0

//
// DVRH_PAR_LOGFILE is used to allow for debug logging to a file
//  This functionality is for debugging purposes only.
//          0 - off
//          1 - on
#define DVRH_PAR_LOGFILE    0

//
// DVRH_BUS_RESET_ON_ERROR
//  This functionality is for debugging purposes only.
// Holds a bus reset for 100us when a handshaking error
// is discovered. This is useful for triggering the
// logic analyzer
//          0 - off
//          1 - on
#define DVRH_BUS_RESET_ON_ERROR    0

#if (1 == DVRH_PAR_LOGFILE)
#define DEFAULT_LOG_FILE_NAME	L"\\??\\C:\\tmp\\parport.log"
#define DbgPrint   DVRH_LogMessage
BOOLEAN DVRH_LogMessage(PCHAR szFormat, ...);
#endif

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\epp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    epp.c

Abstract:

    This module contains the common code to perform all EPP related tasks 
    for EPP Software and EPP Hardware modes.

Author:

    Don Redford - July 29, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

NTSTATUS
ParEppSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    );
    

NTSTATUS
ParEppSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets an EPP Address.
    
Arguments:

    Pdx           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    PUCHAR  Controller;
    UCHAR   dcr;
    
    DD((PCE)Pdx,DDT,"ParEppSetAddress: Entering\n");

    Controller = Pdx->Controller;

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    
    dcr = GetControl (Controller);
    
    P5WritePortUchar(Controller + DATA_OFFSET, Address);
    
    //
    // Event 56
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE );
    StoreControl (Controller, dcr);
            
    //
    // Event 58
    //
    if( !CHECK_DSR(Controller, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DEFAULT_RECEIVE_TIMEOUT) ) {

        //
        // Return the device to Idle.
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE );

        StoreControl (Controller, dcr);
            
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE );
        StoreControl (Controller, dcr);
            
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

        DD((PCE)Pdx,DDE,"ParEppSetAddress: Leaving with IO Device Error Event 58\n");

        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 59
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE );
    StoreControl (Controller, dcr);
            
    //
    // Event 60
    //
    if( !CHECK_DSR(Controller, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DEFAULT_RECEIVE_TIMEOUT) ) {

        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE );
        StoreControl (Controller, dcr);

        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

        DD((PCE)Pdx,DDE,"ParEppSetAddress - Leaving with IO Device Error Event 60\n");

        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 61
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE );
    StoreControl( Controller, dcr );

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return STATUS_SUCCESS;
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdoclose.c ===
#include "pch.h"

NTSTATUS
PptFdoClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
{
    PFDO_EXTENSION   fdx = DeviceObject->DeviceExtension;
    NTSTATUS            status;
    
    PAGED_CODE();

    //
    // Verify that our device has not been SUPRISE_REMOVED. Generally
    //   only parallel ports on hot-plug busses (e.g., PCMCIA) and
    //   parallel ports in docking stations will be surprise removed.
    //
    if( fdx->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        //
        // Our device has been SURPRISE removed, but since this is only 
        //   a CLOSE, SUCCEED anyway.
        //
        status = P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );

        goto target_exit;
    }


    //
    // Try to acquire RemoveLock to prevent the device object from going
    //   away while we're using it.
    //
    status = PptAcquireRemoveLock(&fdx->RemoveLock, Irp);
    if( !NT_SUCCESS( status ) ) {
        // Our device has been removed, but since this is only a CLOSE, SUCCEED anyway.
        status = STATUS_SUCCESS;
        goto target_exit;
    }

    //
    // We have the RemoveLock
    //

    ExAcquireFastMutex(&fdx->OpenCloseMutex);
    if( fdx->OpenCloseRefCount > 0 ) {
        //
        // prevent rollover -  strange as it may seem, it is perfectly
        //   legal for us to receive more closes than creates - this
        //   info came directly from Mr. PnP himself
        //
        if( ((LONG)InterlockedDecrement(&fdx->OpenCloseRefCount)) < 0 ) {
            // handle underflow
            InterlockedIncrement(&fdx->OpenCloseRefCount);
        }
    }
    ExReleaseFastMutex(&fdx->OpenCloseMutex);
    
target_exit:

    DD((PCE)fdx,DDT,"PptFdoClose - OpenCloseRefCount after close = %d\n",fdx->OpenCloseRefCount);

    return P4CompleteRequestReleaseRemLock( Irp, STATUS_SUCCESS, 0, &fdx->RemoveLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\ecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    ecp.c

Abstract:

    Enhanced Capabilities Port (ECP)
    
    This module contains the common routines that aue used/ reused
    by swecp and hwecp.

Author:

    Robbie Harris (Hewlett-Packard) - May 27, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//=========================================================
// ECP::EnterForwardPhase
//
// Description : Do what is necessary to enter forward phase for ECP
//
// Input Parameters : Controller,  pPortInfoStruct
//
// Modifies : ECR, DCR
//
//=========================================================
NTSTATUS
ParEcpEnterForwardPhase(IN  PPDO_EXTENSION  Pdx)
{
    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    return STATUS_SUCCESS;
}

// =========================================================
// ECP::EnterReversePhase
//
// Description : Move from the common phase (FwdIdle, wPortHWMode=PS2)
//               to ReversePhase.  
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies : pPortInfoStruct->CurrentPhase, DCR
//
// Pre-conditions : CurrentPhase == PHASE_FORWARD_IDLE
//                  wPortHWMode == HW_MODE_PS2
//
// Post-conditions : Bus is in ECP State 40
//                   CurrentPhase = PHASE_REVERSE_IDLE
//
// Returns : status of operation
//
//=========================================================
NTSTATUS ParEcpEnterReversePhase(IN  PPDO_EXTENSION   Pdx)
{
    // Assume that we are in the common entry phase (FWDIDLE, and ECR mode=PS/2)
    // EnterReversePhase assumes that we are in PHASE_FORWARD_IDLE,
    // and that the ECPMode is set to PS/2 mode at entry.
    
    // Setup the status to indicate successful
    NTSTATUS status = STATUS_SUCCESS;
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    PUCHAR wPortECR;       // I/O address of ECR
    UCHAR dcr;

    // Calculate I/O port addresses for common registers
    wPortDCR = Pdx->Controller + OFFSET_DCR;
    
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    
    // Now, Check the current state to make sure that we are ready for
    // a change to reverse phase.
    if ( PHASE_FORWARD_IDLE == Pdx->CurrentPhase ) {
        // Okay, we are ready to proceed.  Set the CurrentPhase and go on to 
        // state 47
        //----------------------------------------------------------------------
        // Set CurrentPhase to indicate Forward To Reverse Mode.
        //----------------------------------------------------------------------
        P5SetPhase( Pdx, PHASE_FWD_TO_REV );
        
        //----------------------------------------------------------------------
        // Set Dir=1 in DCR for reading.
        //----------------------------------------------------------------------
        dcr = P5ReadPortUchar(wPortDCR);     // Get content of DCR.
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
        
        // Set the data port bits to 1 so that other circuits can control them
        //P5WritePortUchar(Controller + OFFSET_DATA, 0xFF);
        
        //----------------------------------------------------------------------
        // Assert HostAck low.  (ECP State 38)
        //----------------------------------------------------------------------
        Pdx->CurrentEvent = 38;
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
        
        // REVISIT: Should use TICKCount to get a finer granularity.
        // According to the spec we need to delay at least .5 us
        KeStallExecutionProcessor((ULONG) 1);       // Stall for 1 us
        
        //----------------------------------------------------------------------
        // Assert nReverseRequest low.  (ECP State 39)
        //----------------------------------------------------------------------
        Pdx->CurrentEvent = 39;
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
        
        // NOTE: Let the caller check for State 40, since the error handling for
        // State 40 is different between hwecp and swecp.

    } else {

        DD((PCE)Pdx,DDE,"ParEcpEnterReversePhase - Invalid Phase on entry - broken state machine\n");
        PptAssertMsg("ParEcpEnterReversePhase - Invalid Phase on entry - broken state machine",FALSE);
        status = STATUS_LINK_FAILED;
    }
    
    return status;
}	

//=========================================================
// ECP::ExitReversePhase
//
// Description : Transition from the ECP reverse Phase to the 
//               common phase for all entry functions
//
// Input Parameters : Controller - offset to the I/O ports
//			pPortInfoStruct - pointer to port information
//
// Modifies : CurrentPhase, DCR
//
// Pre-conditions :
//
// Post-conditions : NOTE: This function does not completely move to 
//                   the common phase for entry functions.  Both the
//                   HW and SW ECP classes must do extra work
//
// Returns : Status of the operation
//
//=========================================================
NTSTATUS ParEcpExitReversePhase(IN  PPDO_EXTENSION   Pdx)
{
    NTSTATUS       status = STATUS_SUCCESS;
    PUCHAR         Controller = Pdx->Controller;
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    PUCHAR wPortECR;       // I/O address of ECR
    UCHAR          dcr;

    wPortDCR = Controller + OFFSET_DCR;
    wPortECR = Pdx->EcrController + ECR_OFFSET;


    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse To Forward Mode.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_REV_TO_FWD );


    //----------------------------------------------------------------------
    // Set HostAck high
    //----------------------------------------------------------------------
    dcr = P5ReadPortUchar(wPortDCR);
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE );
    P5WritePortUchar(wPortDCR, dcr);


    //----------------------------------------------------------------------
    // Set nReverseRequest high.  (State 47)
    //----------------------------------------------------------------------
    Pdx->CurrentEvent = 47;
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE );
    P5WritePortUchar(wPortDCR, dcr);

    //----------------------------------------------------------------------
    // Check first for PeriphAck low and PeriphClk high. (State 48)
    //----------------------------------------------------------------------
    Pdx->CurrentEvent = 48;
    if( ! CHECK_DSR(Controller, INACTIVE, ACTIVE, DONT_CARE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
        // Bad things happened - timed out on this state,
        // Mark Status as bad and let our mgr kill ECP mode.
        // status = SLP_RecoverPort( pSDCB, RECOVER_18 );   // Reset port.
        status = STATUS_LINK_FAILED;
    	DD((PCE)Pdx,DDE,"ParEcpExitReversePhase - state 48 Timeout\n");
        goto ParEcpExitReversePhase;
    }
    
    //----------------------------------------------------------------------
    // Check next for nAckReverse high.  (State 49) 
    //----------------------------------------------------------------------
    Pdx->CurrentEvent = 49;
    if ( ! CHECK_DSR(Controller ,INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL ) ) {
        // Bad things happened - timed out on this state,
        // Mark Status as bad and let our mgr kill ECP mode.
        //nError = RecoverPort( pSDCB, RECOVER_19 );   // Reset port.
        status = STATUS_LINK_FAILED;
    	DD((PCE)Pdx,DDE,"ParEcpExitReversePhase:state 49 Timeout\n");
        goto ParEcpExitReversePhase;
    }
    
    // Warning: Don't assume that the ECR is in PS/2 mode here.
    // You cannot change the direction in this routine.  It must be
    // done elsewhere (SWECP or HWECP).
    
ParEcpExitReversePhase:

    DD((PCE)Pdx,DDT,"ParEcpExitReversePhase - exit w/status=%x\n",status);
    return status;
}	

BOOLEAN
ParEcpHaveReadData (
    IN  PPDO_EXTENSION  Pdx
    )
{
    return ( (UCHAR)0 == (P5ReadPortUchar(Pdx->Controller + OFFSET_DSR) & DSR_NOT_PERIPH_REQUEST) );
}

NTSTATUS
ParEcpSetupPhase(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine performs 1284 Setup Phase.

Arguments:

    Controller      - Supplies the port address.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    PUCHAR         Controller;
    UCHAR          dcr;

    // The negotiation succeeded.  Current mode and phase.
    //
    P5SetPhase( Pdx, PHASE_SETUP );
    Controller = Pdx->Controller;
    // Negoiate leaves us in state 6, we need to be in state 30 to
    // begin transfer. Note that I am assuming that the controller
    // is already set as it should be for state 6.
    //

    // *************** State 30 Setup Phase ***************8
    //  DIR                     = Don't Care
    //  IRQEN                   = Don't Care
    //  1284/SelectIn           = High
    //  nReverseReq/**(ECP only)= High
    //  HostAck/HostBusy        = Low  (Signals state 30)
    //  HostClk/nStrobe         = High
    //
    Pdx->CurrentEvent = 30;
    dcr = P5ReadPortUchar(Controller + OFFSET_DCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, INACTIVE, ACTIVE);
    P5WritePortUchar(Controller + OFFSET_DCR, dcr);

    // *************** State 31 Setup Phase ***************8
    // PeriphAck/PtrBusy        = low
    // PeriphClk/PtrClk         = high
    // nAckReverse/AckDataReq   = high  (Signals state 31)
    // XFlag                    = high
    // nPeriphReq/nDataAvail    = Don't Care
    Pdx->CurrentEvent = 31;
    if (!CHECK_DSR(Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL)) {
        // Bad things happened - timed out on this state.
        // Set status to an error and let PortTuple kill ECP mode (Terminate).
        DD((PCE)Pdx,DDE,"ParEcpSetupPhase - State 31 Failed - dcr=%x\n",dcr);
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        return STATUS_IO_DEVICE_ERROR;
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    DD((PCE)Pdx,DDT,"ParEcpSetupPhase - exit - STATUS_SUCCESS\n");
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\errlog.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       errlog.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
PptLogError(
            IN  PDRIVER_OBJECT      DriverObject,
            IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
            IN  PHYSICAL_ADDRESS    P1,
            IN  PHYSICAL_ADDRESS    P2,
            IN  ULONG               SequenceNumber,
            IN  UCHAR               MajorFunctionCode,
            IN  UCHAR               RetryCount,
            IN  ULONG               UniqueErrorValue,
            IN  NTSTATUS            FinalStatus,
            IN  NTSTATUS            SpecificIOStatus
            )
    
/*++
      
Routine Description:
      
    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.
      
Arguments:
      
    DriverObject        - Supplies a pointer to the driver object for the device
      
    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.
      
    P1,P2               - Supplies the physical addresses for the controller
                            ports involved with the error if they are available
                            and puts them through as dump data.
      
    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.
      
    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.
      
    RetryCount          - Supplies the number of times a particular operation
                            has been retried.
      
    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.
      
    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.
      
    SpecificIOStatus    - Supplies the IO status for this particular error.
      
Return Value:
      
    None.
      
--*/
    
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;
    
    DD(NULL,DDE,"PptLogError()\n");
    
    if (ARGUMENT_PRESENT(DeviceObject)) {
        ObjectToUse = DeviceObject;
    } else {
        ObjectToUse = DriverObject;
    }
    
    DumpToAllocate = 0;
    
    if (P1.LowPart != 0 || P1.HighPart != 0) {
        DumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }
    
    if (P2.LowPart != 0 || P2.HighPart != 0) {
        DumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }
    
    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
                                            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));
    
    if (!ErrorLogEntry) {
        return;
    }
    
    ErrorLogEntry->ErrorCode = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount = RetryCount;
    ErrorLogEntry->UniqueErrorValue = UniqueErrorValue;
    ErrorLogEntry->FinalStatus = FinalStatus;
    ErrorLogEntry->DumpDataSize = DumpToAllocate;
    
    if (DumpToAllocate) {

        RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));
        
        if (DumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {
            
            RtlCopyMemory(((PUCHAR) ErrorLogEntry->DumpData) +
                          sizeof(PHYSICAL_ADDRESS), &P2,
                          sizeof(PHYSICAL_ADDRESS));
        }
    }
    
    IoWriteErrorLogEntry(ErrorLogEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdoioctl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ioctl.c
//
//--------------------------------------------------------------------------

#include "pch.h"

NTSTATUS
PptFdoInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++
      
Routine Description:
      
    This routine is the dispatch routine for IRP_MJ_INTERNAL_DEVICE_CONTROL.
      
Arguments:
      
    DeviceObject    - Supplies the device object.
      
    Irp             - Supplies the I/O request packet.
      
Return Value:
      
    STATUS_SUCCESS              - Success.
    STATUS_UNSUCCESSFUL         - The request was unsuccessful.
    STATUS_PENDING              - The request is pending.
    STATUS_INVALID_PARAMETER    - Invalid parameter.
    STATUS_CANCELLED            - The request was cancelled.
    STATUS_BUFFER_TOO_SMALL     - The supplied buffer is too small.
    STATUS_INVALID_DEVICE_STATE - The current chip mode is invalid to change to asked mode
    
--*/
    
{
    PIO_STACK_LOCATION                  IrpSp;
    PFDO_EXTENSION                      Extension = DeviceObject->DeviceExtension;
    NTSTATUS                            Status;
    PPARALLEL_PORT_INFORMATION          PortInfo;
    PPARALLEL_PNP_INFORMATION           PnpInfo;
    PMORE_PARALLEL_PORT_INFORMATION     MorePortInfo;
    KIRQL                               CancelIrql;
    SYNCHRONIZED_COUNT_CONTEXT          SyncContext;
    PPARALLEL_INTERRUPT_SERVICE_ROUTINE IsrInfo;
    PPARALLEL_INTERRUPT_INFORMATION     InterruptInfo;
    PISR_LIST_ENTRY                     IsrListEntry;
    SYNCHRONIZED_LIST_CONTEXT           ListContext;
    SYNCHRONIZED_DISCONNECT_CONTEXT     DisconnectContext;
    BOOLEAN                             DisconnectInterrupt;

    //
    // Verify that our device has not been SUPRISE_REMOVED. Generally
    //   only parallel ports on hot-plug busses (e.g., PCMCIA) and
    //   parallel ports in docking stations will be surprise removed.
    //
    // dvdf - RMT - It would probably be a good idea to also check
    //   here if we are in a "paused" state (stop-pending, stopped, or
    //   remove-pending) and queue the request until we either return to
    //   a fully functional state or are removed.
    //
    if( Extension->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }


    //
    // Try to acquire RemoveLock to prevent the device object from going
    //   away while we're using it.
    //
    Status = PptAcquireRemoveLockOrFailIrp( DeviceObject, Irp );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    
    Irp->IoStatus.Information = 0;
    

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        
    case IOCTL_INTERNAL_DISABLE_END_OF_CHAIN_BUS_RESCAN:

        Extension->DisableEndOfChainBusRescan = TRUE;
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_ENABLE_END_OF_CHAIN_BUS_RESCAN:

        Extension->DisableEndOfChainBusRescan = FALSE;
        Status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_PARALLEL_PORT_FREE:

        PptFreePort(Extension);
        PptReleaseRemoveLock(&Extension->RemoveLock, Irp);
        return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );

    case IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE:
        
        IoAcquireCancelSpinLock(&CancelIrql);
        
        if( Irp->Cancel ) {
            
            Status = STATUS_CANCELLED;
            
        } else {
            
            SyncContext.Count = &Extension->WorkQueueCount;
            
            if( Extension->InterruptRefCount ) {
                
                KeSynchronizeExecution( Extension->InterruptObject, PptSynchronizedIncrement, &SyncContext );

            } else {
                
                PptSynchronizedIncrement( &SyncContext );

            }
            
            if (SyncContext.NewCount) {
                
                // someone else currently has the port, queue request
                PptSetCancelRoutine( Irp, PptCancelRoutine );
                IoMarkIrpPending( Irp );
                InsertTailList( &Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry );
                Status = STATUS_PENDING;

            } else {
                // port aquired
                Extension->WmiPortAllocFreeCounts.PortAllocates++;
                Status = STATUS_SUCCESS;
            }
        } // endif Irp->Cancel
        
        IoReleaseCancelSpinLock(CancelIrql);

        break;
        
    case IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO:
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARALLEL_PORT_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Irp->IoStatus.Information = sizeof(PARALLEL_PORT_INFORMATION);
            PortInfo = Irp->AssociatedIrp.SystemBuffer;
            *PortInfo = Extension->PortInfo;
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO:
        
        Status = STATUS_SUCCESS;
        break;
        
    case IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO:
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARALLEL_PNP_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Irp->IoStatus.Information = sizeof(PARALLEL_PNP_INFORMATION);
            PnpInfo  = Irp->AssociatedIrp.SystemBuffer;
            *PnpInfo = Extension->PnpInfo;
            
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO:
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MORE_PARALLEL_PORT_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Irp->IoStatus.Information = sizeof(MORE_PARALLEL_PORT_INFORMATION);
            MorePortInfo = Irp->AssociatedIrp.SystemBuffer;
            MorePortInfo->InterfaceType = Extension->InterfaceType;
            MorePortInfo->BusNumber = Extension->BusNumber;
            MorePortInfo->InterruptLevel = Extension->InterruptLevel;
            MorePortInfo->InterruptVector = Extension->InterruptVector;
            MorePortInfo->InterruptAffinity = Extension->InterruptAffinity;
            MorePortInfo->InterruptMode = Extension->InterruptMode;
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE:
        
        //
        // Port already acquired?
        //
        // Make sure right parameters are sent in
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PARALLEL_CHIP_MODE) ) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = PptSetChipMode (Extension, 
                                ((PPARALLEL_CHIP_MODE)Irp->AssociatedIrp.SystemBuffer)->ModeFlags );
        } // end check input buffer
        
        break;
        
    case IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE:
        
        //
        // Port already acquired?
        //
        // Make sure right parameters are sent in
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(PARALLEL_CHIP_MODE) ){
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = PptClearChipMode (Extension, ((PPARALLEL_CHIP_MODE)Irp->AssociatedIrp.SystemBuffer)->ModeFlags);
        } // end check input buffer
        
        break;
        
    case IOCTL_INTERNAL_INIT_1284_3_BUS:

        // Initialize the 1284.3 bus

        // RMT - Port is locked out already?

        Extension->PnpInfo.Ieee1284_3DeviceCount = PptInitiate1284_3( Extension );

        Status = STATUS_SUCCESS;
        
        break;
            
    case IOCTL_INTERNAL_SELECT_DEVICE:
        // Takes a flat namespace Id for the device, also acquires the
        //   port unless HAVE_PORT_KEEP_PORT Flag is set
        

        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PARALLEL_1284_COMMAND) ) {

            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            if ( Irp->Cancel ) {
                Status = STATUS_CANCELLED;
            } else {
                // Call Function to try to select device
                Status = PptTrySelectDevice( Extension, Irp->AssociatedIrp.SystemBuffer );

                IoAcquireCancelSpinLock(&CancelIrql);
                if ( Status == STATUS_PENDING ) {
                    PptSetCancelRoutine(Irp, PptCancelRoutine);
                    IoMarkIrpPending(Irp);
                    InsertTailList(&Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry);
                }
                IoReleaseCancelSpinLock(CancelIrql);
            }
        }
        
        break;
        
    case IOCTL_INTERNAL_DESELECT_DEVICE:
        // Deselects the current device, also releases the port unless HAVE_PORT_KEEP_PORT Flag set
        
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PARALLEL_1284_COMMAND) ) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            Status = PptDeselectDevice( Extension, Irp->AssociatedIrp.SystemBuffer );

        }
        break;
        
    case IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT:
        
        {
            //
            // Verify that this interface has been explicitly enabled via the registry flag, otherwise
            //   FAIL the request with STATUS_UNSUCCESSFUL
            //
            ULONG EnableConnectInterruptIoctl = 0;
            PptRegGetDeviceParameterDword( Extension->PhysicalDeviceObject, 
                                           (PWSTR)L"EnableConnectInterruptIoctl", 
                                           &EnableConnectInterruptIoctl );
            if( 0 == EnableConnectInterruptIoctl ) {
                Status = STATUS_UNSUCCESSFUL;
                goto targetExit;
            }
        }


        //
        // This interface has been explicitly enabled via the registry flag, process request.
        //

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength  < sizeof(PARALLEL_INTERRUPT_SERVICE_ROUTINE) ||
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARALLEL_INTERRUPT_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            IsrInfo = Irp->AssociatedIrp.SystemBuffer;
            InterruptInfo = Irp->AssociatedIrp.SystemBuffer;
            IoAcquireCancelSpinLock(&CancelIrql);
            
            if (Extension->InterruptRefCount) {
                
                ++Extension->InterruptRefCount;
                IoReleaseCancelSpinLock(CancelIrql);
                Status = STATUS_SUCCESS;
                
            } else {
                
                IoReleaseCancelSpinLock(CancelIrql);
                Status = PptConnectInterrupt(Extension);
                if (NT_SUCCESS(Status)) {
                    IoAcquireCancelSpinLock(&CancelIrql);
                    ++Extension->InterruptRefCount;
                    IoReleaseCancelSpinLock(CancelIrql);
                }
            }
            
            if (NT_SUCCESS(Status)) {
                
                IsrListEntry = ExAllocatePool(NonPagedPool, sizeof(ISR_LIST_ENTRY));
                
                if (IsrListEntry) {
                    
                    IsrListEntry->ServiceRoutine           = IsrInfo->InterruptServiceRoutine;
                    IsrListEntry->ServiceContext           = IsrInfo->InterruptServiceContext;
                    IsrListEntry->DeferredPortCheckRoutine = IsrInfo->DeferredPortCheckRoutine;
                    IsrListEntry->CheckContext             = IsrInfo->DeferredPortCheckContext;
                    
                    // Put the ISR_LIST_ENTRY onto the ISR list.
                    
                    ListContext.List = &Extension->IsrList;
                    ListContext.NewEntry = &IsrListEntry->ListEntry;
                    KeSynchronizeExecution(Extension->InterruptObject, PptSynchronizedQueue, &ListContext);
                    
                    InterruptInfo->InterruptObject                 = Extension->InterruptObject;
                    InterruptInfo->TryAllocatePortAtInterruptLevel = PptTryAllocatePortAtInterruptLevel;
                    InterruptInfo->FreePortFromInterruptLevel      = PptFreePortFromInterruptLevel;
                    InterruptInfo->Context                         = Extension;
                    
                    Irp->IoStatus.Information = sizeof(PARALLEL_INTERRUPT_INFORMATION);
                    Status = STATUS_SUCCESS;
                    
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        break;
        
    case IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT:
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PARALLEL_INTERRUPT_SERVICE_ROUTINE)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            IsrInfo = Irp->AssociatedIrp.SystemBuffer;
            
            // Take the ISR out of the ISR list.
            
            IoAcquireCancelSpinLock(&CancelIrql);
            
            if (Extension->InterruptRefCount) {
                
                IoReleaseCancelSpinLock(CancelIrql);
                
                DisconnectContext.Extension = Extension;
                DisconnectContext.IsrInfo = IsrInfo;
                
                if (KeSynchronizeExecution(Extension->InterruptObject, PptSynchronizedDisconnect, &DisconnectContext)) {
                    
                    Status = STATUS_SUCCESS;
                    IoAcquireCancelSpinLock(&CancelIrql);
                    
                    if (--Extension->InterruptRefCount == 0) {
                        DisconnectInterrupt = TRUE;
                    } else {
                        DisconnectInterrupt = FALSE;
                    }
                    
                    IoReleaseCancelSpinLock(CancelIrql);
                    
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                    DisconnectInterrupt = FALSE;
                }
                
            } else {
                IoReleaseCancelSpinLock(CancelIrql);
                DisconnectInterrupt = FALSE;
                Status = STATUS_INVALID_PARAMETER;
            }
            
            //
            // Disconnect the interrupt if appropriate.
            //
            if (DisconnectInterrupt) {
                PptDisconnectInterrupt(Extension);
            }
        }
        break;

    default:
        
        DD((PCE)Extension,DDE,"PptDispatchDeviceControl - default case - invalid/unsupported request\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
targetExit:

    if( Status != STATUS_PENDING ) {
        PptReleaseRemoveLock(&Extension->RemoveLock, Irp);
        P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdocleanup.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    parport.sys

File Name:

    cleanup.c

Abstract:

    This file contains the dispatch routine for handling IRP_MJ_CLEANUP.

Exports:

     - PptDispatchCleanup() - The dispatch routine for cleanup.

--*/

#include "pch.h"

NTSTATUS
PptFdoCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++dvdf3
      
Routine Description:
      
    This is the dispatch routine for handling IRP_MJ_CLEANUP IRPs.

    This routine cancels all of the IRPs currently queued on
      for the specified device.
      
Arguments:
      
    DeviceObject    - Supplies the device object.
      
    Irp             - Supplies the cleanup IRP.
      
Return Value:
      
    STATUS_SUCCESS  - Success.
      
--*/
    
{
    PFDO_EXTENSION   fdx   = DeviceObject->DeviceExtension;
    PIRP                nextIrp;
    KIRQL               cancelIrql;
    
    DD((PCE)fdx,DDT,"PptFdoCleanup\n");
    
    //
    // Verify that our device has not been SUPRISE_REMOVED. If we
    //   have been SUPRISE_REMOVED then we have already cleaned up
    //   as part of the handling of the surprise removal.
    //
    if( fdx->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        goto targetExit;
    }

    IoAcquireCancelSpinLock( &cancelIrql );
    
    while( !IsListEmpty( &fdx->WorkQueue ) ) {
        
        nextIrp = CONTAINING_RECORD(fdx->WorkQueue.Blink, IRP, Tail.Overlay.ListEntry);
        
        nextIrp->Cancel        = TRUE;
        nextIrp->CancelIrql    = cancelIrql;
        nextIrp->CancelRoutine = NULL;

        PptCancelRoutine(DeviceObject, nextIrp);
        
        // need to reacquire because PptCancelRoutine() releases the SpinLock
        IoAcquireCancelSpinLock(&cancelIrql);
    }
    
    IoReleaseCancelSpinLock( cancelIrql );
    
targetExit:

    return P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdocreate.c ===
#include "pch.h"

NTSTATUS
PptFdoCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
      
Routine Description:
      
    This is the dispatch function for IRP_MJ_CREATE.
      
Arguments:
      
    DeviceObject    - The target device object for the request.

    Irp             - The I/O request packet.
      
Return Value:
      
    STATUS_SUCCESS        - If Success.

    STATUS_DELETE_PENDING - If this device is in the process of being removed 
                              and will go away as soon as all outstanding
                              requests are cleaned up.
      
--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;
    NTSTATUS          status    = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Verify that our device has not been SUPRISE_REMOVED. Generally
    //   only parallel ports on hot-plug busses (e.g., PCMCIA) and
    //   parallel ports in docking stations will be surprise removed.
    //
    // dvdf - RMT - It would probably be a good idea to also check
    //   here if we are in a "paused" state (stop-pending, stopped, or
    //   remove-pending) and queue the request until we either return to
    //   a fully functional state or are removed.
    //
    if( fdx->PnpState & PPT_DEVICE_SURPRISE_REMOVED ) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }


    //
    // Try to acquire RemoveLock to prevent the device object from going
    //   away while we're using it.
    //
    status = PptAcquireRemoveLockOrFailIrp( DeviceObject, Irp );
    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // We have the RemoveLock - handle CREATE
    //
    ExAcquireFastMutex(&fdx->OpenCloseMutex);
    InterlockedIncrement(&fdx->OpenCloseRefCount);
    ExReleaseFastMutex(&fdx->OpenCloseMutex);

    DD((PCE)fdx,DDT,"PptFdoCreateOpen - SUCCEED - new OpenCloseRefCount=%d\n",fdx->OpenCloseRefCount);

    PptReleaseRemoveLock(&fdx->RemoveLock, Irp);

    P4CompleteRequest( Irp, status, 0 );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\driverentry.c ===
/***************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:

        Parport.sys - Parallel port (IEEE 1284, IEEE 1284.3) driver.

File Name:

        driverEntry.c

Abstract:

        DriverEntry routine - driver initialization

Environment:

        Kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.

Revision History:

        2000-07-25 - Doug Fritz
         - code cleanup, add comments, add copyright

Author(s):

        Doug Fritz

****************************************************************************/

#include "pch.h"


/************************************************************************/
/* DriverEntry                                                          */
/************************************************************************/
//
// Routine Description:
//
//     This is the DriverEntry routine -- the first function called
//       after the driver has been loaded into memory.
//
// Arguments:
//
//     DriverObject - points to the DRIVER_OBJECT for this driver
//     RegPath      - the service registry key for this driver
//
// Return Value:
//
//     STATUS_SUCCESS   - on success
//     STATUS_NO_MEMORY - if unable to allocate pool
//
// Notes:
//
// Log:
//
/************************************************************************/
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegPath
    )
{
    //
    // Save a copy of *RegPath in driver global RegistryPath for future reference.
    //
    // UNICODE_NULL terminate the path so that we can safely use RegistryPath.Buffer
    //   as a PWSTR.
    //
    {
        USHORT size = RegPath->Length + sizeof(WCHAR);
        RegistryPath.Buffer = ExAllocatePool( (PagedPool | POOL_COLD_ALLOCATION), size );

        if( NULL == RegistryPath.Buffer ) {
            return STATUS_NO_MEMORY;
        }

        RegistryPath.Length        = 0;
        RegistryPath.MaximumLength = size;
        RtlCopyUnicodeString( &RegistryPath, RegPath );
        RegistryPath.Buffer[ size/sizeof(WCHAR) - 1 ] = UNICODE_NULL;
    }



    //
    // Initialize Driver Globals
    //

    // Non-zero means don't raise IRQL from PASSIVE_LEVEL to DISPATCH_LEVEL
    //   when doing CENTRONICS mode (SPP) writes.
    SppNoRaiseIrql = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"SppNoRaiseIrql", &SppNoRaiseIrql );

    // Non-zero means override CENTRONICS as the default Forward mode and/or NIBBLE as
    //   the default Reverse mode. Valid modes are those defined in ntddpar.h as
    //   parameters for IOCTL_IEEE1284_NEGOTIATE.
    // *** Warning: invalid settings and/or setting/device incompatibilities can render
    //       the port unusable until the settings are corrected
    DefaultModes = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DefaultModes", &DefaultModes );

    // Set tracing level for driver DbgPrint messages. Trace values defined in debug.h.
    // Zero means no trace output.
    Trace = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"Trace", &Trace );

    // Request DbgBreakPoint on driver events. Event values defined in debug.h.
    // Zero means no breakpoints requested.
    Break = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"Break", &Break );

    // Mask OFF debug spew for specific devices. See debug.h for flag definitions
    //  0 means allow debug spew for that device
    // ~0 means mask OFF all (show NO) debug spew for that device type
    DbgMaskFdo = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskFdo", &DbgMaskFdo );

    DbgMaskRawPort = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskRawPort", &DbgMaskRawPort );

    DbgMaskDaisyChain0 = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskDaisyChain0", &DbgMaskDaisyChain0 );

    DbgMaskDaisyChain1 = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskDaisyChain1", &DbgMaskDaisyChain1 );

    DbgMaskEndOfChain = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskEndOfChain", &DbgMaskEndOfChain );

    DbgMaskLegacyZip = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskLegacyZip", &DbgMaskLegacyZip );

    DbgMaskNoDevice = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgMaskNoDevice", &DbgMaskNoDevice );

#if 1 == DBG_SHOW_BYTES
    DbgShowBytes = 1;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DbgShowBytes", &DbgShowBytes );
#endif

    //
    // Allow asserts? non-zero means allow assertions
    //
    AllowAsserts = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"AllowAsserts", &AllowAsserts );

    // Non-zero means enable detection of Iomega Legacy Zip-100 drives that use
    //   an Iomega proprietary Select/Deselect mechanism rather than the Select/Deselect
    //   mechanism defined by IEEE 1284.3. (These drives pre-date IEEE 1284.3)
    // *** Note: if zero, this registry setting is checked again during every PnP QDR/BusRelations
    //       query to see if the user has enabled detection via the Ports property page "Enable
    //       legacy Plug and Play detection" checkbox.
    ParEnableLegacyZip = 0;
    PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );

    // Default timeout when trying to acquire exclusive access to the (shared) port
    {
        const ULONG halfSecond  =  500; // in milliseconds
        const ULONG fiveSeconds = 5000;

        ULONG requestedTimeout  = halfSecond;

        PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"AcquirePortTimeout", &requestedTimeout );

        if( requestedTimeout < halfSecond ) {
            requestedTimeout = halfSecond;
        } else if( requestedTimeout > fiveSeconds ) {
            requestedTimeout = fiveSeconds;
        }

        PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS( AcquirePortTimeout, requestedTimeout );
    }

    {
        //
        // register for callbacks so that we can detect switch between
        // AC and battery power and tone done "polling for printers"
        // when machine switches to battery power.
        //
        OBJECT_ATTRIBUTES objAttributes;
        UNICODE_STRING    callbackName;
        NTSTATUS          localStatus;

        RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");
        
        InitializeObjectAttributes(&objAttributes,
                                   &callbackName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        
        localStatus = ExCreateCallback(&PowerStateCallbackObject,
                                       &objAttributes,
                                       FALSE,
                                       TRUE);
        
        if( STATUS_SUCCESS == localStatus ) {
            PowerStateCallbackRegistration = ExRegisterCallback(PowerStateCallbackObject,
                                                                PowerStateCallback,
                                                                NULL);
        }
    }



    //
    // Set dispatch table entries for IRP_MJ_* functions that we handle
    //
    DriverObject->MajorFunction[ IRP_MJ_CREATE                  ] = PptDispatchCreateOpen;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE                   ] = PptDispatchClose;
    DriverObject->MajorFunction[ IRP_MJ_CLEANUP                 ] = PptDispatchCleanup;

    DriverObject->MajorFunction[ IRP_MJ_READ                    ] = PptDispatchRead;
    DriverObject->MajorFunction[ IRP_MJ_WRITE                   ] = PptDispatchWrite;

    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL          ] = PptDispatchDeviceControl;
    DriverObject->MajorFunction[ IRP_MJ_INTERNAL_DEVICE_CONTROL ] = PptDispatchInternalDeviceControl;

    DriverObject->MajorFunction[ IRP_MJ_QUERY_INFORMATION       ] = PptDispatchQueryInformation;
    DriverObject->MajorFunction[ IRP_MJ_SET_INFORMATION         ] = PptDispatchSetInformation;

    DriverObject->MajorFunction[ IRP_MJ_PNP                     ] = PptDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER                   ] = PptDispatchPower;

    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL          ] = PptDispatchSystemControl;

    DriverObject->DriverExtension->AddDevice                      = P5AddDevice;
    DriverObject->DriverUnload                                    = PptUnload;



    //
    // Break on user request
    //   (typically via registry setting ...\Services\Parport\Parameters : Break : REG_DWORD : 0x1)
    //
    // This is a useful breakpoint in order to manually set appropriate breakpoints elsewhere in the driver.
    //
    PptBreakOnRequest( PPT_BREAK_ON_DRIVER_ENTRY, ("PPT_BREAK_ON_DRIVER_ENTRY - BreakPoint requested") );


    DD(NULL,DDT,"Parport DriverEntry - SUCCESS\n");

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdothread.c ===
#include "pch.h"

// experimental vars - to tweek debugging for this thread
ULONG x1; // set nonzero to disable port acquisition
ULONG x2; // set nonzero to try to select LPT1.0 and negotiate/terminate ECP_HW_NOIRQ
ULONG x3; // set nonzero to try to negotiate the periph to ECP and then terminate
ULONG x4;

ULONG t1; // timeout between thread polls (in ms)
ULONG t2; // time to sit on port before releasing it (in ms)

VOID
P5FdoThread(
    IN  PFDO_EXTENSION Fdx
    )
{
    LARGE_INTEGER   timeOut1;
    NTSTATUS        status;
    UCHAR           deviceStatus;
    PCHAR           devId;
    BOOLEAN         requestRescan;
    const ULONG     pollingFailureThreshold = 10; // pick an arbitrary but reasonable number

    do {

        if( PowerStateIsAC ) {

            PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS( timeOut1, (WarmPollPeriod * 1000) );

        } else {

            // running on batteries - use a longer (4x) timeout
            PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS( timeOut1, (WarmPollPeriod * 1000 * 4) );

        }

        status = KeWaitForSingleObject(&Fdx->FdoThreadEvent, Executive, KernelMode, FALSE, &timeOut1);

        if( Fdx->TimeToTerminateThread ) {

            //
            // another thread (PnP REMOVE handler) has requested that we die and is likely waiting on us to do so
            //
            DD((PCE)Fdx,DDT,"P5FdoThread - killing self\n");
            PsTerminateSystemThread( STATUS_SUCCESS );

        }

        if( !PowerStateIsAC ) {
            // Still on Batteries - don't "poll for printers" - just go back to sleep
            continue;
        }

        if( STATUS_TIMEOUT == status ) {

            if( NULL == Fdx->EndOfChainPdo ) {

                // try to acquire port
                if( PptTryAllocatePort( Fdx ) ) {
                
                    DD((PCE)Fdx,DDT,"P5FdoThread - port acquired\n");

                    requestRescan = FALSE;

                    // check for something connected
                    deviceStatus = GetStatus(Fdx->PortInfo.Controller);

                    if( PAR_POWERED_OFF(deviceStatus)   ||
                        PAR_NOT_CONNECTED(deviceStatus) ||
                        PAR_NO_CABLE(deviceStatus) ) {
                        
                        // doesn't appear to be anything connected - do nothing
                        DD((PCE)Fdx,DDT,"P5FdoThread - nothing connected? - deviceStatus = %02x\n",deviceStatus);

                    } else {

                        // we might have something connected

                        // try a device ID to confirm

                        DD((PCE)Fdx,DDT,"P5FdoThread - might be something connected - deviceStatus = %02x\n",deviceStatus);                        

                        devId = P4ReadRawIeee1284DeviceId( Fdx->PortInfo.Controller );

                        if( devId ) {

                            PCHAR  mfg, mdl, cls, des, aid, cid;

                            // RawIeee1284 string includes 2 bytes of length data at beginning
                            DD((PCE)Fdx,DDT,"P5FdoThread - EndOfChain device detected <%s>\n",(devId+2));

                            ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, devId+2 );

                            if( mfg && mdl ) {
                                DD((PCE)Fdx,DDT,"P5FdoThread - found mfg - <%s>\n",mfg);
                                DD((PCE)Fdx,DDT,"P5FdoThread - found mdl - <%s>\n",mdl);
                                requestRescan = TRUE;
                            }

                            ExFreePool( devId );

                        } else {
                            DD((PCE)Fdx,DDT,"P5FdoThread - no EndOfChain device detected - NULL devId\n");
                        }

                        if( requestRescan ) {

                            // we appear to have retrieved a valid 1284 ID, reset failure counter
                            Fdx->PollingFailureCounter = 0;

                        } else {

                            // Our heuristics tell us that there is something
                            // connected to the port but we are unable to retrieve
                            // a valid IEEE 1284 Device ID

                            if( ++(Fdx->PollingFailureCounter) > pollingFailureThreshold ) {

                                // too many consecutive failures - we're burning CPU for no good reason, give up and die
                                Fdx->TimeToTerminateThread = TRUE;

                                // don't delay before killing self
                                KeSetEvent( &Fdx->FdoThreadEvent, 0, FALSE );

                            }

                        } 

                    }

                    DD((PCE)Fdx,DDT,"P5FdoThread - freeing port\n");
                    PptFreePort( Fdx );

                    if( requestRescan ) {
                        DD((PCE)Fdx,DDT,"P5FdoThread - requesting Rescan\n");
                        IoInvalidateDeviceRelations( Fdx->PhysicalDeviceObject, BusRelations );
                    }

                } else {
                    DD((PCE)Fdx,DDT,"P5FdoThread - unable to acquire port\n");
                }

            } else {
                DD((PCE)Fdx,DDT,"P5FdoThread - already have EndOfChain device\n");
            }

        }

    } while( TRUE );

}

NTSTATUS
P5FdoCreateThread(
    PFDO_EXTENSION Fdx
    )
{
    NTSTATUS        status;
    HANDLE          handle;
    OBJECT_ATTRIBUTES objAttrib;

    DD((PCE)Fdx,DDT,"P5CreateFdoWorkerThread - %s - enter\n",Fdx->Location);

    // Start the thread - save referenced pointer to thread in our extension
    InitializeObjectAttributes( &objAttrib, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );

    status = PsCreateSystemThread( &handle, THREAD_ALL_ACCESS, &objAttrib, NULL, NULL, P5FdoThread, Fdx );

    if( STATUS_SUCCESS == status ) {

        // We've got the thread.  Now get a pointer to it.

        status = ObReferenceObjectByHandle( handle, THREAD_ALL_ACCESS, NULL, KernelMode, &Fdx->ThreadObjectPointer, NULL );

        if( STATUS_SUCCESS == status ) {
            // Now that we have a reference to the thread we can simply close the handle.
            ZwClose(handle);

        } else {
            Fdx->TimeToTerminateThread = TRUE;
        }

        DD((PCE)Fdx,DDT,"ParCreateSystemThread - %s - SUCCESS\n",Fdx->Location);

    } else {
        DD((PCE)Fdx,DDT,"ParCreateSystemThread - %s FAIL - status = %x\n",Fdx->Location, status);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdopower.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       power.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
PowerStateCallback(
    IN  PVOID CallbackContext,
    IN  PVOID Argument1,
    IN  PVOID Argument2
    )
{
    ULONG_PTR   action = (ULONG_PTR)Argument1;
    ULONG_PTR   state  = (ULONG_PTR)Argument2;

    UNREFERENCED_PARAMETER(CallbackContext);

    if( PO_CB_AC_STATUS == action ) {

        //
        // AC <-> DC Transition has occurred
        // state == TRUE if on AC, else FALSE.
        //
        PowerStateIsAC = (BOOLEAN)state;
        // DbgPrint("PowerState is now %s\n",PowerStateIsAC?"AC":"Battery");
    }

    return;
}


NTSTATUS
PptPowerComplete (
                  IN PDEVICE_OBJECT       pDeviceObject,
                  IN PIRP                 pIrp,
                  IN PFDO_EXTENSION    Fdx
                  )

/*++
      
Routine Description:
      
    This routine handles all IRP_MJ_POWER IRPs.
  
Arguments:
  
    pDeviceObject           - represents the port device
  
    pIrp                    - PNP irp
  
    Fdx               - Device Extension
  
Return Value:
  
    Status
  
--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;
    
    UNREFERENCED_PARAMETER( pDeviceObject );

    if( pIrp->PendingReturned ) {
        IoMarkIrpPending( pIrp );
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    
    powerType = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;
    
    switch (pIrpStack->MinorFunction) {
        
    case IRP_MN_QUERY_POWER:
        
        ASSERTMSG ("Invalid power completion minor code: Query Power\n", FALSE);
        break;
        
    case IRP_MN_SET_POWER:
        
        DD((PCE)Fdx,DDT,"Power - Setting %s state to %d\n", 
               ( (powerType == SystemPowerState) ?  "System" : "Device" ), powerState.SystemState);
        
        switch (powerType) {
        case DevicePowerState:
            if (Fdx->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                
                ASSERTMSG ("Invalid power completion Device Down\n", FALSE);
                
            } else if (powerState.DeviceState < Fdx->DeviceState) {
                //
                // Powering Up
                //
                PoSetPowerState (Fdx->DeviceObject, powerType, powerState);
                
                if (PowerDeviceD0 == Fdx->DeviceState) {
                    
                    //
                    // Do the power on stuff here.
                    //
                    
                }
                Fdx->DeviceState = powerState.DeviceState;
            }
            break;
            
        case SystemPowerState:
            
            if (Fdx->SystemState < powerState.SystemState) {
                //
                // Powering down
                //
                
                ASSERTMSG ("Invalid power completion System Down\n", FALSE);
                
            } else if (powerState.SystemState < Fdx->SystemState) {
                //
                // Powering Up
                //
                if (PowerSystemWorking == powerState.SystemState) {
                    
                    //
                    // Do the system start up stuff here.
                    //
                    
                    powerState.DeviceState = PowerDeviceD0;
                    PoRequestPowerIrp (Fdx->DeviceObject,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       NULL, // no completion function
                                       NULL, // and no context
                                       NULL);
                }
                
                Fdx->SystemState = powerState.SystemState;
            }
            break;
        }
        
        
        break;
        
    default:
        ASSERTMSG ("Power Complete: Bad Power State", FALSE);
    }
    
    PoStartNextPowerIrp (pIrp);
    
    return STATUS_SUCCESS;
}


NTSTATUS
PptFdoPower (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++
      
Routine Description:
      
    This routine handles all IRP_MJ_POWER IRPs.
      
Arguments:
      
    pDeviceObject           - represents the port device
      
    pIrp                    - PNP irp
      
Return Value:
      
    Status
      
--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;
    NTSTATUS            status;
    PFDO_EXTENSION      fdx;
    BOOLEAN             hookit   = FALSE;
    BOOLEAN             bogusIrp = FALSE;
    
    //
    // WORKWORK.  THIS CODE DOESN'T DO MUCH...NEED TO CHECK OUT FULL POWER FUNCTIONALITY.
    //
    
    fdx = pDeviceObject->DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    
    status = PptAcquireRemoveLock(&fdx->RemoveLock, pIrp);
    if( !NT_SUCCESS(status) ) {
        PoStartNextPowerIrp(pIrp);
        return P4CompleteRequest( pIrp, status, pIrp->IoStatus.Information );
    }

    powerType = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;
    
    switch (pIrpStack->MinorFunction) {
        
    case IRP_MN_QUERY_POWER:
        
        status = STATUS_SUCCESS;
        break;
        
    case IRP_MN_SET_POWER:
        
        DD((PCE)fdx,DDT,"Power - Setting %s state to %d\n",
               ( (powerType == SystemPowerState) ?  "System" : "Device" ), powerState.SystemState);
        
        status = STATUS_SUCCESS;

        switch (powerType) {
        case DevicePowerState:
            if (fdx->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                
                PoSetPowerState (fdx->DeviceObject, powerType, powerState);
                
                if (PowerDeviceD0 == fdx->DeviceState) {
                    
                    //
                    // Do the power on stuff here.
                    //
                    
                }
                fdx->DeviceState = powerState.DeviceState;
                
            } else if (powerState.DeviceState < fdx->DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;

            }
            
            break;
            
        case SystemPowerState:
            
            if (fdx->SystemState < powerState.SystemState) {
                //
                // Powering down
                //
                if (PowerSystemWorking == fdx->SystemState) {
                    
                    //
                    // Do the system shut down stuff here.
                    //
                    
                }
                
                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (fdx->DeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   NULL, // no completion function
                                   NULL, // and no context
                                   NULL);
                fdx->SystemState = powerState.SystemState;
                
            } else if (powerState.SystemState < fdx->SystemState) {
                //
                // Powering Up
                //
                hookit = TRUE;
            }
            break;
        }
        
        break;
        
    default:
        bogusIrp = TRUE;
        status = STATUS_NOT_SUPPORTED;
    }
    
    IoCopyCurrentIrpStackLocationToNext (pIrp);
    
    if (!NT_SUCCESS (status)) {

        PoStartNextPowerIrp (pIrp);

        if( bogusIrp ) {
            status = PoCallDriver( fdx->ParentDeviceObject, pIrp );
        } else {
            P4CompleteRequest( pIrp, status, pIrp->IoStatus.Information );
        }
        
    } else if (hookit) {
        
        IoSetCompletionRoutine( pIrp, PptPowerComplete, fdx, TRUE, TRUE, TRUE );
        status = PoCallDriver (fdx->ParentDeviceObject, pIrp);
        
    } else {

        PoStartNextPowerIrp (pIrp);
        status = PoCallDriver (fdx->ParentDeviceObject, pIrp);

    }
    
    PptReleaseRemoveLock(&fdx->RemoveLock, pIrp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdopnp.c ===
#include "pch.h"

VOID
PptDellNationalPC87364WorkAround( PUCHAR EcpController )
{
    PUCHAR  ecr      = EcpController+2;  // generic chipset Extended Control Register
    PUCHAR  eir      = EcpController+3;  // PC87364 chipset Extended Index   Register
    PUCHAR  edr      = EcpController+4;  // PC87364 chipset Extended Data    Register
    ULONG   delay    = 5;                // in microseconds (arbitrary - this seems to work)
    KIRQL   oldIrql;

    //
    // Raise IRQL to prevent BIOS from touching the registers at the
    // same time that we're updating them. This is a complete hack
    // since according to PnP we own the registers, but do it anyway
    // since we know that BIOS touches these same registers.
    //
    KeRaiseIrql( HIGH_LEVEL, &oldIrql );

    KeStallExecutionProcessor( delay );
    P5WritePortUchar( ecr, 0x15 );
    KeStallExecutionProcessor( delay );
    P5WritePortUchar( eir, 0x02 );
    KeStallExecutionProcessor( delay );
    P5WritePortUchar( edr, 0x90 );
    KeStallExecutionProcessor( delay );

    KeLowerIrql( oldIrql );
}

NTSTATUS
PptFdoStartDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_START IRPs.

     - Wait for the bus driver and any drivers beneath 
         us in the driver stack to handle this first.
     - Get, validate, and save the resources given to us by PnP.
     - Assign IDs to and get a count of 1284.3 daisy chain devices
         connected to the port.
     - Determine the capabilities of the chipset (BYTE, EPP, ECP).
     - Set our PnP device interface state to trigger
         an interface arrival callback to anyone listening 
         on our GUID.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    PFDO_EXTENSION  fdx = DeviceObject->DeviceExtension;
    NTSTATUS        status;
    BOOLEAN         foundPort = FALSE;
    BOOLEAN         foundIrq  = FALSE;
    BOOLEAN         foundDma  = FALSE;


    //
    // This IRP must be handled first by the parent bus driver
    //   and then by each higher driver in the device stack.
    //
    status = PptPnpBounceAndCatchPnpIrp(fdx, Irp);
    if( !NT_SUCCESS( status ) && ( status != STATUS_NOT_SUPPORTED ) ) {
        // Someone below us in the driver stack explicitly failed the START.
        goto targetExit;
    }

    //
    // Extract resources from CM_RESOURCE_LIST and save them in our extension.
    //
    status = PptPnpStartScanCmResourceList(fdx, Irp, &foundPort, &foundIrq, &foundDma);
    if( !NT_SUCCESS( status ) ) {
        goto targetExit;
    }

    //
    // Do our resources appear to be valid?
    //
    status = PptPnpStartValidateResources(DeviceObject, foundPort, foundIrq, foundDma);
    if( !NT_SUCCESS( status ) ) {
        goto targetExit;
    }


    //
    // Check if ACPI set a flag for us based on entries in
    // BIOSINFO.INF to indicate that we are running on a Dell machine
    // with an incorrectly programmed National PC87364 SuperIO
    // chipset. If so try to work around the problem here so that the
    // user doesn't need to flash the BIOS to get the parallel port to
    // work.
    //
    // Symptoms of the problem are that the parallel port Data Lines
    // are wedged to all zeros regardless of the setting of the bits
    // in the parallel port data register or the Direction bit in the
    // control register.
    //
    // If the port base address is 0x3BC then this won't work and the
    // user will need to go to Device Manager and change the LPT port
    // resource settings to either 0x378 or 0x278 for the base
    // register address. We believe that ACPI defaults to a port base
    // address of 0x378 so this workaround should generally work.
    //
    {
        ULONG DellNationalPC87364 = 0;

        //
        // Check registry to see if ACPI set the flag based on
        // BIOSINFO.INF to indicate that we should try the workaround.
        //
        PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DellNationalPC87364", &DellNationalPC87364 );

        if( DellNationalPC87364 ) {

            //
            // we have a Dell machine with a National PC87364 chipset
            // and a version of BIOS that we believe doesn't
            // initialize the parallel port so that it works under
            // Win2k or WinXP.
            //

            if( fdx->PnpInfo.SpanOfEcpController > 4 ) {

                //
                // We have the extra Ecp registers needed to try the
                // workaround without stepping on I/O register space
                // owned by someone else.
                //

                if( ( (PUCHAR)0x678 == fdx->PnpInfo.EcpController ) ||
                    ( (PUCHAR)0x778 == fdx->PnpInfo.EcpController ) ) {

                    //
                    // The parallel port base register and ECP
                    // registers are located at one of the two
                    // traditional address ranges: ECP at 0x400 offset
                    // from base register address of 0x278 or 0x378,
                    // so let's try the workaround to try to unwedge
                    // the port data lines.
                    //

                    PptDellNationalPC87364WorkAround( fdx->PnpInfo.EcpController );
                }
            }
        }

    } // end new block scope for Dell/National chipset workaround


    //
    // Initialize the IEEE 1284.3 "bus" by assigning IDs [0..3] to 
    //   the 1284.3 daisy chain devices connected to the port. This
    //   function also gives us a count of the number of such 
    //   devices connected to the port.
    //
    fdx->PnpInfo.Ieee1284_3DeviceCount = PptInitiate1284_3( fdx );
    
    //
    // Determine the hardware modes supported (BYTE, ECP, EPP) by
    //   the parallel port chipset and save this information in our extension.
    //

    // Check to see if the filter parchip is there and use the modes it can set
    status = PptDetectChipFilter( fdx );

    // if filter driver was not found use our own generic port detection
    if ( !NT_SUCCESS( status ) ) {
        PptDetectPortType( fdx );
    }

    
    //
    // Register w/WMI
    //
    status = PptWmiInitWmi( DeviceObject );
    if( !NT_SUCCESS( status ) ) {
        goto targetExit;
    }


    //
    // Signal those who registered for PnP interface change notification 
    //   on our GUID that we have STARTED (trigger an INTERFACE_ARRIVAL
    //   PnP callback).
    //
    status = IoSetDeviceInterfaceState( &fdx->DeviceInterface, TRUE );
    if( !NT_SUCCESS(status) ) {
        status = STATUS_NOT_SUPPORTED;
    } else {
        fdx->DeviceInterfaceState = TRUE;
    }

targetExit:

    if( NT_SUCCESS( status ) ) {

        // 
        // Note in our extension that we have successfully STARTED.
        //
        ExAcquireFastMutex( &fdx->ExtensionFastMutex );
        PptSetFlags( fdx->PnpState, PPT_DEVICE_STARTED );
        ExReleaseFastMutex( &fdx->ExtensionFastMutex );

        // create warm poll thread to poll for printer arrivals
        if( NULL == fdx->ThreadObjectPointer ) {

            ULONG DisableWarmPoll;

            fdx->PollingFailureCounter = 0; // reset counter

            // check for registry flag to disable "polling for printers"
            DisableWarmPoll = 0;      // if non-zero then do not poll for printer arrivals
            PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"DisableWarmPoll", &DisableWarmPoll );

            if( 0 == DisableWarmPoll ) {

                // how frequently should we check for printer arrivals? (in seconds)
                // (WarmPollPeriod is a driver global)
                PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"WarmPollPeriod", &WarmPollPeriod );
                if( WarmPollPeriod < 5 ) {
                    WarmPollPeriod = 5;
                } else {
                    if( WarmPollPeriod > 20 ) {
                        WarmPollPeriod = 20;
                    }
                }
                DD((PCE)fdx,DDT,"P5FdoThread - WarmPollPeriod = %d seconds\n",WarmPollPeriod);
            
                // side effect: set fdx->ThreadObjectPointer on SUCCESS
                P5FdoCreateThread( fdx );
            }

        }

    }

    P4CompleteRequest( Irp, status, 0 );

    PptReleaseRemoveLock( &fdx->RemoveLock, Irp );

    return status;
}


NTSTATUS
PptFdoQueryRemove(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_QUERY_REMOVE_DEVICE.

    FAIL the request if there are open handles, SUCCEED otherwise.
    
    This function is identical to PptPnpQueryStopDevice() except
      for the flag that gets set in fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS     - No open handles - SUCCEED IRP
    STATUS_DEVICE_BUSY - Open handles - FAIL IRP

--*/
{
    //
    // Always succeed query - PnP will veto Query Remove on our behalf if 
    //   there are open handles
    //

    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    PptSetFlags( fdx->PnpState, ( PPT_DEVICE_REMOVE_PENDING | PPT_DEVICE_PAUSED ) );
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;

    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}


NTSTATUS
PptFdoRemoveDevice(
    IN PDEVICE_OBJECT Fdo, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_REMOVE_DEVICE.

    Notify those listening on our device interface GUID that 
      we have gone away, wait until all other IRPs that the
      device is processing have drained, and clean up.

Arguments:

    Fdo - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = Fdo->DeviceExtension;
    NTSTATUS          status;

    //
    // clean up any child PDOs that are still here
    //
    if( fdx->RawPortPdo ) {
        PDEVICE_OBJECT pdo = fdx->RawPortPdo;
        DD((PCE)fdx,DDT,"PptFdoRemoveDevice - have RawPortPdo - cleaning up\n");
        P4DestroyPdo( pdo );
        fdx->RawPortPdo = NULL;
    }

    if( fdx->EndOfChainPdo ) {
        PDEVICE_OBJECT pdo = fdx->EndOfChainPdo;
        DD((PCE)fdx,DDT,"PptFdoRemoveDevice - have EndOfChainPdo - cleaning up\n");
        P4DestroyPdo( pdo );
        fdx->EndOfChainPdo = NULL;
    }

    {
        LONG        daisyChainId;
        const LONG  daisyChainMaxId = 1;

        for( daisyChainId = 0 ; daisyChainId <= daisyChainMaxId ; ++daisyChainId ) {

            if( fdx->DaisyChainPdo[ daisyChainId ] ) {
                PDEVICE_OBJECT pdo = fdx->DaisyChainPdo[ daisyChainId ];
                DD((PCE)fdx,DDT,"PptFdoRemoveDevice - have DaisyChainPdo[%d] - cleaning up\n",daisyChainId);
                P4DestroyPdo( pdo );
                fdx->DaisyChainPdo[ daisyChainId ] = NULL;
            }
        }
    }


    //
    // RMT - if fdx->DevDeletionListHead non-empty - clean it up?
    //
    PptAssert( IsListEmpty( &fdx->DevDeletionListHead) );

    //
    // Set flags in our extension to indicate that we have received 
    //   IRP_MN_REMOVE_DEVICE so that we can fail new requests as appropriate.
    //
    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    PptSetFlags( fdx->PnpState, PPT_DEVICE_REMOVED );
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    //
    // if we still have a worker thread, kill it
    //
    {
        PVOID threadObjPointer = InterlockedExchangePointer( &fdx->ThreadObjectPointer, NULL );
        
        if( threadObjPointer ) {
            
            // set the flag for the worker thread to kill itself
            fdx->TimeToTerminateThread = TRUE;
            
            // wake thread so it can kill self
            KeSetEvent( &fdx->FdoThreadEvent, 0, TRUE );
            
            // wait for the thread to die
            KeWaitForSingleObject( threadObjPointer, Executive, KernelMode, FALSE, NULL );
            
            // allow the system to release the thread object
            ObDereferenceObject( threadObjPointer );

        }
    }

    //
    // Unregister w/WMI
    //
    IoWMIRegistrationControl(Fdo, WMIREG_ACTION_DEREGISTER);

    //
    // Tell those listening on our device interface GUID that we have
    //   gone away. Ignore status from the call since we can do
    //   nothing on failure.
    //
    IoSetDeviceInterfaceState( &fdx->DeviceInterface, FALSE );
    fdx->DeviceInterfaceState = FALSE;

    //
    // Pass the IRP down the stack and wait for all other IRPs
    //   that are being processed by the device to drain.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( fdx->ParentDeviceObject, Irp );
    PptReleaseRemoveLockAndWait( &fdx->RemoveLock, Irp );

    //
    // Clean up pool allocations
    // 
    RtlFreeUnicodeString( &fdx->DeviceName);
    RtlFreeUnicodeString( &fdx->DeviceInterface );
    if( fdx->PnpInfo.PortName ) {
        ExFreePool( fdx->PnpInfo.PortName );
        fdx->PnpInfo.PortName = NULL;
    }
    if( fdx->Location ) {
        ExFreePool( fdx->Location );
        fdx->Location = NULL;
    }

    //
    // Detach and delete our device object.
    //
    IoDetachDevice( fdx->ParentDeviceObject );
    IoDeleteDevice( Fdo );
    
    return status;
}


NTSTATUS
PptFdoCancelRemove(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_CANCEL_REMOVE_DEVICE.

    If we previously SUCCEEDed a QUERY_REMOVE (PPT_DEVICE_REMOVE_PENDING 
      flag is set) then we reset the appropriate device state flags 
      and resume normal operation. Otherwise treat this as an
      informational message. 

    This function is identical to PptPnpCancelStopDevice() except for
      the fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    if( fdx->PnpState & PPT_DEVICE_REMOVE_PENDING ) {
        PptClearFlags( fdx->PnpState, ( PPT_DEVICE_REMOVE_PENDING | PPT_DEVICE_PAUSED ) );
    }
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}


NTSTATUS
PptFdoStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_STOP_DEVICE.

    We previously SUCCEEDed QUERY_STOP. Set flags
      to indicate that we are now STOPPED.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );

    //
    // Assert that we are in a STOP_PENDING state.
    //
    ASSERT( fdx->PnpState & PPT_DEVICE_STOP_PENDING );
    ASSERT( fdx->PnpState & PPT_DEVICE_PAUSED );

    //
    // PPT_DEVICE_PAUSED remains set
    //
    PptSetFlags( fdx->PnpState,   PPT_DEVICE_STOPPED );
    PptClearFlags( fdx->PnpState, ( PPT_DEVICE_STOP_PENDING | PPT_DEVICE_STARTED ) );

    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock(fdx, Irp);
}


NTSTATUS
PptFdoQueryStop(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_QUERY_STOP_DEVICE.

    FAIL the request if there are open handles, SUCCEED otherwise.
    
    Other drivers may cache pointers to the parallel port registers that 
      they obtained via IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO and there
      is currently no mechanism to find and inform all such drivers that the 
      parallel port registers have changed and their their cached pointers are 
      now invalid without breaking legacy drivers.

    This function is identical to PptPnpQueryStopDevice() except
      for the flag that gets set in fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS     - No open handles - SUCCEED IRP
    STATUS_DEVICE_BUSY - Open handles - FAIL IRP

--*/
{
    NTSTATUS          status       = STATUS_SUCCESS;
    PFDO_EXTENSION fdx    = DeviceObject->DeviceExtension;
    BOOLEAN           handlesOpen;

    //
    // RMT - dvdf - race condition - small timing window - sequence:
    //   1. Test indicates no open handles - decide to SUCCEED QUERY_STOP
    //   2. CREATE arrives and is SUCCEEDED - open handle
    //   3. We SUCCEED QUERY_STOP
    //   4. Client obtains register addresses via IOCTL
    //   5. PnP Rebalances us - registers change
    //   6. Client acquires port via IOCTL
    //   7. Client tries to access registers at pre-rebalance location
    //   8. BOOM!!!
    //

    ExAcquireFastMutex( &fdx->OpenCloseMutex );
    handlesOpen = (BOOLEAN)( fdx->OpenCloseRefCount > 0 );
    ExReleaseFastMutex( &fdx->OpenCloseMutex );

    if( handlesOpen ) {
        
        status = STATUS_DEVICE_BUSY;
        P4CompleteRequest( Irp, status, Irp->IoStatus.Information );
        PptReleaseRemoveLock( &fdx->RemoveLock, Irp );

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );

        ExAcquireFastMutex( &fdx->ExtensionFastMutex );
        PptSetFlags( fdx->PnpState, ( PPT_DEVICE_STOP_PENDING | PPT_DEVICE_PAUSED ) );
        ExReleaseFastMutex( &fdx->ExtensionFastMutex );
    }
    
    return status;
}


NTSTATUS
PptFdoCancelStop(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_CANCEL_STOP_DEVICE.

    If we previously SUCCEEDed a QUERY_STOP (PPT_DEVICE_STOP_PENDING 
      flag is set) then we reset the appropriate device state flags 
      and resume normal operation. Otherwise treat this as an
      informational message. 

    This function is identical to PptPnpCancelRemoveDevice() except for
      the fdx->PnpState.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    if( fdx->PnpState & PPT_DEVICE_STOP_PENDING ) {
        PptClearFlags( fdx->PnpState, ( PPT_DEVICE_STOP_PENDING | PPT_DEVICE_PAUSED ) );
    }
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}


NTSTATUS
PptFdoQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )

/*++

Routine Description:

    This function handles PnP IRP_MN_QUERY_DEVICE_RELATIONS.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    PIO_STACK_LOCATION   irpSp = IoGetCurrentIrpStackLocation( Irp );
    DEVICE_RELATION_TYPE type  = irpSp->Parameters.QueryDeviceRelations.Type;

    if( BusRelations == type ) {
        return PptFdoHandleBusRelations( DeviceObject, Irp );
    } else {
        return PptPnpPassThroughPnpIrpAndReleaseRemoveLock(DeviceObject->DeviceExtension, Irp);
    }
}


NTSTATUS
PptFdoFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    ) 
/*++dvdf8

Routine Description:

    This function handles PnP IRP_MN_FILTER_RESOURCE_REQUIREMENTS IRPs.

     - Wait for the bus driver and any drivers beneath 
         us in the driver stack to handle this first.
     - Query the registry to find the type of filtering desired.
     - Filter out IRQ resources as specified by the registry setting.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    PFDO_EXTENSION              fdx               = DeviceObject->DeviceExtension;
    ULONG                          filterResourceMethod    = PPT_FORCE_USE_NO_IRQ;
    PIO_RESOURCE_REQUIREMENTS_LIST pResourceRequirementsIn;
    NTSTATUS                       status;


    //
    // DDK Rule: Add on the way down, modify on the way up. We are modifying
    //   the resource list so let the drivers beneath us handle this IRP first.
    //
    status    = PptPnpBounceAndCatchPnpIrp(fdx, Irp);
    if( !NT_SUCCESS(status) && (status != STATUS_NOT_SUPPORTED) ) {
        // Someone below us in the driver stack explicitly failed the IRP.
        goto targetExit;
    }


    //
    // Find the "real" resource requirments list, either the PnP list
    //   or the list created by another driver in the stack.
    //
    if ( Irp->IoStatus.Information == 0 ) {
        //
        // No one else has created a new resource list. Use the original 
        //   list from the PnP Manager.
        //
        PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation( Irp );
        pResourceRequirementsIn = IrpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if (pResourceRequirementsIn == NULL) {
            //
            // NULL list, nothing to do.
            //
            goto targetExit;
        }

    } else {
        //
        // Another driver has created a new resource list. Use the list that they created.
        //
        pResourceRequirementsIn = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
    }


    //
    // Check the registry to find out the desired type of resource filtering.
    //
    // The following call sets the default value for filterResourceMethod 
    //   if the registry query fails.
    //
    PptRegGetDeviceParameterDword( fdx->PhysicalDeviceObject,
                                   (PWSTR)L"FilterResourceMethod",
                                   &filterResourceMethod );

    DD((PCE)fdx,DDT,"filterResourceMethod=%x\n",filterResourceMethod);


    //
    // Do filtering based on registry setting.
    //
    switch( filterResourceMethod ) {

    case PPT_FORCE_USE_NO_IRQ: 
        //
        // Registry setting dictates that we should refuse to accept IRQ resources.
        //
        // * This is the default behavior which means that we make the IRQ available 
        //     for legacy net and sound cards that may not work if they cannot get
        //     the IRQ.
        //
        // - If we find a resource alternative that does not contain an IRQ resource
        //     then we remove those resource alternatives that do contain IRQ 
        //     resources from the list of alternatives.
        //
        // - Otherwise we have to play hardball. Since all resource alternatives
        //     contain IRQ resources we simply "nuke" the IRQ resource descriptors
        //     by changing their resource Type from CmResourceTypeInterrupt to
        //     CmResourceTypeNull.
        //

        DD((PCE)fdx,DDT,"PPT_FORCE_USE_NO_IRQ\n");

        if( PptPnpFilterExistsNonIrqResourceList( pResourceRequirementsIn ) ) {

            DD((PCE)fdx,DDT,"Found Resource List with No IRQ - Filtering\n");
            PptPnpFilterRemoveIrqResourceLists( pResourceRequirementsIn );

        } else {

            DD((PCE)fdx,DDT,"Did not find Resource List with No IRQ - Nuking IRQ resource descriptors\n");
            PptPnpFilterNukeIrqResourceDescriptorsFromAllLists( pResourceRequirementsIn );

        }

        break;


    case PPT_TRY_USE_NO_IRQ: 
        //
        // Registry setting dictates that we should TRY to give up IRQ resources.
        //
        // - If we find a resource alternative that does not contain an IRQ resource
        //     then we remove those resource alternatives that do contain IRQ 
        //     resources from the list of alternatives.
        //
        // - Otherwise we do nothing.
        //

        DD((PCE)fdx,DDT,"PPT_TRY_USE_NO_IRQ\n");
        if( PptPnpFilterExistsNonIrqResourceList(pResourceRequirementsIn) ) {

            DD((PCE)fdx,DDT,"Found Resource List with No IRQ - Filtering\n");
            PptPnpFilterRemoveIrqResourceLists(pResourceRequirementsIn);

        } else {

            // leave the IO resource list as is
            DD((PCE)fdx,DDT,"Did not find Resource List with No IRQ - Do nothing\n");

        }
        break;


    case PPT_ACCEPT_IRQ: 
        //
        // Registry setting dictates that we should NOT filter out IRQ resources.
        //
        // - Do nothing.
        //
        DD((PCE)fdx,DDT,"PPT_ACCEPT_IRQ\n");
        break;


    default:
        //
        // Invalid registry setting. 
        //
        // - Do nothing.
        //
        // RMT dvdf - May be desirable to write an error log entry here.
        //
        DD((PCE)fdx,DDE,"ERROR:IGNORED: bad filterResourceMethod=%x\n", filterResourceMethod);
    }

targetExit:

    //
    // Preserve Irp->IoStatus.Information because it may point to a
    //   buffer and we don't want to cause a memory leak.
    //
    P4CompleteRequest( Irp, status, Irp->IoStatus.Information );

    PptReleaseRemoveLock(&fdx->RemoveLock, Irp);

    return status;
}


NTSTATUS
PptFdoSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    )
/*++dvdf6

Routine Description:

    This function handles PnP IRP_MN_SURPRISE_REMOVAL.

    Set flags accordingly in our extension, notify those 
      listening on our device interface GUID that 
      we have gone away, and pass the IRP down the
      driver stack.

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    Status returned from IoCallDriver.

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;

    //
    // Set flags in our extension to indicate that we have received 
    //   IRP_MN_SURPRISE_REMOVAL so that we can fail new requests 
    //   as appropriate.
    //
    ExAcquireFastMutex( &fdx->ExtensionFastMutex );
    PptSetFlags( fdx->PnpState, PPT_DEVICE_SURPRISE_REMOVED );
    ExReleaseFastMutex( &fdx->ExtensionFastMutex );

    //
    // Fail outstanding allocate/select requests for the port
    //
    {
        PIRP                nextIrp;
        KIRQL               cancelIrql;
        
        IoAcquireCancelSpinLock(&cancelIrql);
        
        while( !IsListEmpty( &fdx->WorkQueue ) ) {
                
            nextIrp = CONTAINING_RECORD( fdx->WorkQueue.Blink, IRP, Tail.Overlay.ListEntry );
            nextIrp->Cancel        = TRUE;
            nextIrp->CancelIrql    = cancelIrql;
            nextIrp->CancelRoutine = NULL;
            PptCancelRoutine( DeviceObject, nextIrp );
            
            // PptCancelRoutine() releases the cancel SpinLock so we need to reaquire
            IoAcquireCancelSpinLock( &cancelIrql );
        }
        
        IoReleaseCancelSpinLock( cancelIrql );
    }

    //
    // Tell those listening on our device interface GUID that we have
    //   gone away. Ignore status from the call since we can do
    //   nothing on failure.
    //
    IoSetDeviceInterfaceState( &fdx->DeviceInterface, FALSE );
    fdx->DeviceInterfaceState = FALSE;

    //
    // Succeed, pass the IRP down the stack, and release the RemoveLock.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );
}

NTSTATUS
PptFdoDefaultPnpHandler(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++dvdf8

Routine Description:

    This function is the default handler for PnP IRPs. 
      All PnP IRPs that are not explicitly handled by another 
      routine (via an entry in the PptPnpDispatchFunctionTable[]) are
      handled by this routine.

     - Pass the IRP down the stack to the device below us in the
         driver stack and release our device RemoveLock. 

Arguments:

    DeviceObject - The target device for the IRP
    Irp          - The IRP

Return Value:

    STATUS_SUCCESS              - on success,
    an appropriate error status - otherwise

--*/
{
    return PptPnpPassThroughPnpIrpAndReleaseRemoveLock(DeviceObject->DeviceExtension, Irp);
}


PDRIVER_DISPATCH 
PptFdoPnpDispatchTable[] =
{ 
    PptFdoStartDevice,                // IRP_MN_START_DEVICE                 0x00
    PptFdoQueryRemove,                // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    PptFdoRemoveDevice,               // IRP_MN_REMOVE_DEVICE                0x02
    PptFdoCancelRemove,               // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    PptFdoStopDevice,                 // IRP_MN_STOP_DEVICE                  0x04
    PptFdoQueryStop,                  // IRP_MN_QUERY_STOP_DEVICE            0x05
    PptFdoCancelStop,                 // IRP_MN_CANCEL_STOP_DEVICE           0x06
    PptFdoQueryDeviceRelations,       // IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_INTERFACE              0x08
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_CAPABILITIES           0x09
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_RESOURCES              0x0A
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    PptFdoFilterResourceRequirements, // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    PptFdoDefaultPnpHandler,          // no such PnP request                 0x0E
    PptFdoDefaultPnpHandler,          // IRP_MN_READ_CONFIG                  0x0F
    PptFdoDefaultPnpHandler,          // IRP_MN_WRITE_CONFIG                 0x10
    PptFdoDefaultPnpHandler,          // IRP_MN_EJECT                        0x11
    PptFdoDefaultPnpHandler,          // IRP_MN_SET_LOCK                     0x12
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_ID                     0x13
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    PptFdoDefaultPnpHandler,          // IRP_MN_QUERY_BUS_INFORMATION        0x15
    PptFdoDefaultPnpHandler,          // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    PptFdoSurpriseRemoval,            // IRP_MN_SURPRISE_REMOVAL             0x17
    PptFdoDefaultPnpHandler           // IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
};


NTSTATUS 
PptFdoPnp(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    ) 
{ 
    PFDO_EXTENSION      fdx     = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp   = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS            status;

    // diagnostic
    PptFdoDumpPnpIrpInfo( Fdo, Irp );

    //
    // Acquire RemoveLock to prevent DeviceObject from being REMOVED
    //   while we are using it. If we are unable to acquire the RemoveLock
    //   then the DeviceObject has already been REMOVED.
    //
    status = PptAcquireRemoveLock( &fdx->RemoveLock, Irp);
    if( STATUS_SUCCESS != status ) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }


    //
    // RemoveLock is held. Forward the request to the appropriate handler.
    //
    // Note that the handler must release the RemoveLock prior to returning
    //   control to this function.
    //
    
    if( irpSp->MinorFunction < arraysize(PptFdoPnpDispatchTable) ) {
        return PptFdoPnpDispatchTable[ irpSp->MinorFunction ]( Fdo, Irp );
    } else {
        return PptFdoDefaultPnpHandler( Fdo, Irp );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\hwecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 2000

Module Name:

    hwecp.c

Abstract:

    This module contains code for the host to utilize HardwareECP if it has been
    detected and successfully enabled.

Author:

    Robbie Harris (Hewlett-Packard) 21-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

VOID 
ParCleanupHwEcpPort(
    IN PPDO_EXTENSION  Pdx
)
/*++

Routine Description:

   Cleans up prior to a normal termination from ECP mode.  Puts the
   port HW back into Compatibility mode.

Arguments:

   Controller  - Supplies the parallel port's controller address.

Return Value:

   None.

--*/
{
    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_PS2;
    
    ParCleanupSwEcpPort(Pdx);

    //----------------------------------------------------------------------
    // Set the ECR to mode 000 (Compatibility Mode).
    //----------------------------------------------------------------------
    Pdx->PortHWMode = HW_MODE_COMPATIBILITY;
}

// Drain data from Shadow Buffer
VOID PptEcpHwDrainShadowBuffer(
    IN  Queue  *pShadowBuffer,
    IN  PUCHAR  lpsBufPtr,
    IN  ULONG   dCount,
    OUT ULONG  *fifoCount)
{
    *fifoCount = 0;
    
    if( Queue_IsEmpty( pShadowBuffer ) ) {
        return;
    }

    while( dCount > 0 ) {
        // Break out the Queue_Dequeue from the pointer increment so we can
        // observe the data if needed.
        if( FALSE == Queue_Dequeue( pShadowBuffer, lpsBufPtr ) ) {  // Get byte from queue.
            return;
        }
        ++lpsBufPtr;
        --dCount;                       // Decrement count.
        ++(*fifoCount);
    }
}

//============================================================================
// NAME:    HardwareECP::EmptyFIFO()
//  
//      Empties HW FIFO into a shadow buffer.  This must be done before
//      turning the direction from reverse to forward, if the printer has
//      stuffed data in that no one has read yet.
//
// PARAMETERS: 
//      Controller      - Supplies the base address of the parallel port.
//
// RETURNS: STATUS_SUCCESS or ....
//
// NOTES:
//      Called ZIP_EmptyFIFO in the original 16 bit code.
//
//============================================================================
NTSTATUS ParEcpHwEmptyFIFO(IN  PPDO_EXTENSION   Pdx)
{
    NTSTATUS   nError = STATUS_SUCCESS;
    Queue      *pShadowBuffer;
    UCHAR      bData;
    PUCHAR     wPortDFIFO = Pdx->EcrController;  // IO address of ECP Data FIFO
    PUCHAR     wPortECR = Pdx->EcrController + ECR_OFFSET;    // IO address of Extended Control Register (ECR)
    
    // While data exists in the FIFO, read it and put it into shadow buffer.
    // If the shadow buffer fills up before the FIFO is exhausted, an
    // error condition exists.

    pShadowBuffer = &(Pdx->ShadowBuffer);

#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        DbgPrint("r: ");
    }
#endif

    while ((P5ReadPortUchar(wPortECR) & ECR_FIFO_EMPTY) == 0 ) {
        // Break out the Port Read so we can observe the data if needed
        bData = P5ReadPortUchar(wPortDFIFO);

#if 1 == DBG_SHOW_BYTES
        if( DbgShowBytes ) {
            DbgPrint("%02x ",bData);
        }
#endif

        // Put byte in queue.
        if (FALSE == Queue_Enqueue(pShadowBuffer, bData)) {
            DD((PCE)Pdx,DDT,"ParEcpHwEmptyFIFO - Shadow buffer full, FIFO not empty\n");
            nError = STATUS_BUFFER_OVERFLOW;
            goto ParEcpHwEmptyFIFO_ExitLabel;
        }
    }
    
#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        DbgPrint("zz\n");
    }
#endif

    if( ( !Queue_IsEmpty(pShadowBuffer) && (Pdx->P12843DL.bEventActive) )) {
        KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
    }

ParEcpHwEmptyFIFO_ExitLabel:
    return nError;
}

//=========================================================
// HardwareECP::ExitForwardPhase
//
// Description : Exit from HWECP Forward Phase to the common phase (FWD IDLE, PS/2)
//
//=========================================================
NTSTATUS ParEcpHwExitForwardPhase( IN  PPDO_EXTENSION  Pdx )
{
    NTSTATUS status;

    DD((PCE)Pdx,DDT,"ParEcpHwExitForwardPhase\n");
    
    // First, there could be data in the FIFO.  Wait for it to empty
    // and then put the bus in the common state (PHASE_FORWARD_IDLE with
    // ECRMode set to PS/2
    status = ParEcpHwWaitForEmptyFIFO( Pdx );

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return status;
}	

//=========================================================
// HardwareECP::EnterReversePhase
//
// Description : Go from the common phase to HWECP Reverse Phase
//
//=========================================================
NTSTATUS PptEcpHwEnterReversePhase( IN  PPDO_EXTENSION   Pdx )
{
    NTSTATUS status;
    PUCHAR Controller;
    PUCHAR wPortECR;       // I/O address of Extended Control Register
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    UCHAR  dcr;
    
    Controller = Pdx->Controller;
    wPortECR   = Pdx->EcrController + ECR_OFFSET;
    wPortDCR   = Controller + OFFSET_DCR;


    // EnterReversePhase assumes that we are in PHASE_FORWARD_IDLE,
    // and that the ECPMode is set to PS/2 mode at entry.

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    
    // We need to be in PS/2 (BiDi) mode in order to disable the host
    //   driving the data lines when we flip the direction bit in the DCR.
    //   This is a requirement for entering ECP state 38 in the 1284 spec.
    //   Changed - 2000-02-11
    status = Pdx->TrySetChipMode( Pdx->PortContext, ECR_BYTE_MODE );
    // ignore status - subsequent operations may still work

    Pdx->PortHWMode = HW_MODE_PS2;

    if ( Pdx->ModeSafety == SAFE_MODE ) {

    	// Reverse the bus first (using ECP::EnterReversePhase)
        status = ParEcpEnterReversePhase(Pdx);
    	if ( NT_SUCCESS(status) ) {
            //----------------------------------------------------------------------
            // Wait for nAckReverse low (ECP State 40)
            //----------------------------------------------------------------------
            if ( !CHECK_DSR(Controller, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
                DD((PCE)Pdx,DDT,"PptEcpHwEnterReversePhase: State 40 failed\n");
                status = ParEcpHwRecoverPort( Pdx, RECOVER_28 );
                if ( NT_SUCCESS(status))
                    status = STATUS_LINK_FAILED;
                goto PptEcpHwEnterReversePhase_ExitLabel;
            } else {
                P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
            }
        }
    } else {
        //----------------------------------------------------------------------
        // Set Dir=1 in DCR for reading.
        //----------------------------------------------------------------------
        dcr = P5ReadPortUchar( wPortDCR );     // Get content of DCR.
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, dcr);
    }

    //----------------------------------------------------------------------
    // Set the ECR to mode 011 (ECP Mode).  DmaEnable=0.
    //----------------------------------------------------------------------
    status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );
    if ( !NT_SUCCESS(status) ) {
        DD((PCE)Pdx,DDT,"PptEcpHwEnterReversePhase - TrySetChipMode failed\n");
    }
    Pdx->PortHWMode = HW_MODE_ECP;

    //----------------------------------------------------------------------
    // Set nStrobe=0 and nAutoFd=0 in DCR, so that ECP HW can control.
    //----------------------------------------------------------------------
    dcr = P5ReadPortUchar( wPortDCR );               // Get content of DCR.
    dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar( wPortDCR, dcr );

    // Set the phase variable to ReverseIdle
    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );

PptEcpHwEnterReversePhase_ExitLabel:

    return status;
}

//=========================================================
// HardwareECP::ExitReversePhase
//
// Description : Get out of HWECP Reverse Phase to the common state
//
//=========================================================
NTSTATUS ParEcpHwExitReversePhase( IN  PPDO_EXTENSION  Pdx )
{
    NTSTATUS nError = STATUS_SUCCESS;
    UCHAR    bDCR;
    UCHAR    bECR;
    PUCHAR   wPortECR;
    PUCHAR   wPortDCR;
    PUCHAR   Controller;

    DD((PCE)Pdx,DDT,"ParEcpHwExitReversePhase - enter\n");
    Controller = Pdx->Controller;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortDCR = Controller + OFFSET_DCR;

    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse To Forward Mode.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_REV_TO_FWD );
	
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        //----------------------------------------------------------------------
        // Assert nReverseRequest high.  This should stop further data transfer
        // into the FIFO.  [[REVISIT:  does the chip handle this correctly
        // if it occurs in the middle of a byte transfer (states 43-46)??
        // Answer (10/9/95) no, it doesn't!!]]
        //----------------------------------------------------------------------
        bDCR = P5ReadPortUchar(wPortDCR);               // Get content of DCR.
        bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE );
        P5WritePortUchar(wPortDCR, bDCR );

        //----------------------------------------------------------------------
        // Wait for PeriphAck low and PeriphClk high (ECP state 48) together
        // with nAckReverse high (ECP state 49).
        //----------------------------------------------------------------------
        if( !CHECK_DSR(Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, DEFAULT_RECEIVE_TIMEOUT) ) {
            DD((PCE)Pdx,DDW,"ParEcpHwExitReversePhase: Periph failed state 48/49.\n");
            nError = ParEcpHwRecoverPort( Pdx, RECOVER_37 );   // Reset port.
            if( NT_SUCCESS(nError) ) {
                return STATUS_LINK_FAILED;
            }
            return nError;
        }

        //-----------------------------------------------------------------------
        // Empty the HW FIFO of any bytes that may have already come in.
        // This must be done before changing ECR modes because the FIFO is reset
        // when that occurs.
        //-----------------------------------------------------------------------
        bECR = P5ReadPortUchar(wPortECR);        // Get content of ECR.
        if ((bECR & ECR_FIFO_EMPTY) == 0) {      // Check if FIFO is not empty.
            if( (nError = ParEcpHwEmptyFIFO(Pdx)) != STATUS_SUCCESS ) {
                DD((PCE)Pdx,DDT,"ParEcpHwExitReversePhase: Attempt to empty ECP chip failed.\n");
                return nError;
            }
        }

        //----------------------------------------------------------------------
        // Assert HostAck and HostClk high.  [[REVISIT:  is this necessary? 
        //    should already be high...]]
        //----------------------------------------------------------------------
        bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar(wPortDCR, bDCR );

    } // SAFE_MODE

    //----------------------------------------------------------------------
    // Set the ECR to PS2 Mode so we can change bus direction.
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_PS2;


    //----------------------------------------------------------------------
    // Set Dir=0 (Write) in DCR.
    //----------------------------------------------------------------------
    bDCR = P5ReadPortUchar(wPortDCR);
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    P5WritePortUchar(wPortDCR, bDCR );


    //----------------------------------------------------------------------
    // Set the ECR back to ECP Mode.  DmaEnable=0.
    //----------------------------------------------------------------------
    nError = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_ECP;


    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return nError;
}

BOOLEAN
PptEcpHwHaveReadData (
    IN  PPDO_EXTENSION  Pdx
    )
{
    Queue     *pQueue;

    // check shadow buffer
    pQueue = &(Pdx->ShadowBuffer);
    if (!Queue_IsEmpty(pQueue)) {
        return TRUE;
    }

    // check periph
    if (ParEcpHaveReadData(Pdx))
        return TRUE;

    // Check if FIFO is not empty.
    return (BOOLEAN)( (UCHAR)0 == (P5ReadPortUchar(Pdx->EcrController + ECR_OFFSET) & ECR_FIFO_EMPTY) );
}

NTSTATUS
ParEcpHwHostRecoveryPhase(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS  status = STATUS_SUCCESS;
    PUCHAR    pPortDCR;       // I/O address of Device Control Register
    PUCHAR    pPortDSR;       // I/O address of Device Status Register
    PUCHAR    pPortECR;       // I/O address of Extended Control Register
    UCHAR     bDCR;           // Contents of DCR
    UCHAR     bDSR;           // Contents of DSR

    if( !Pdx->bIsHostRecoverSupported ) {
        return STATUS_SUCCESS;
    }

    DD((PCE)Pdx,DDT,"ParEcpHwHostRecoveryPhase - enter\n");

    // Calculate I/O port addresses for common registers
    pPortDCR = Pdx->Controller + OFFSET_DCR;
    pPortDSR = Pdx->Controller + OFFSET_DSR;
    pPortECR = Pdx->EcrController + ECR_OFFSET;

    // Set the ECR to mode 001 (PS2 Mode)
    // Don't need to flip to Byte mode.  The ECR arbitrator will handle this.
    Pdx->PortHWMode = HW_MODE_PS2;
    
    // Set Dir=1 in DCR to disable host bus drive, because the peripheral may 
    // try to drive the bus during host recovery phase.  We are not really going
    // to let any data handshake across, because we don't set HostAck low, and
    // we don't enable the ECP chip during this phase.
    bDCR = P5ReadPortUchar(pPortDCR);               // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    P5WritePortUchar(pPortDCR, bDCR );
    
    // Check the DCR to see if it has been stomped on
    bDCR = P5ReadPortUchar( pPortDCR );
    if( TEST_DCR( bDCR, DIR_WRITE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE ) ) {
        // DCR ok, now test DSR for valid state, ignoring PeriphAck since it could change
        bDSR = P5ReadPortUchar( pPortDSR );
        // 11/21/95 LLL, CGM: change test to look for XFlag high
        if( TEST_DSR( bDSR, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) ) {
            // Drop ReverseRequest to initiate host recovery
            bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE );
            P5WritePortUchar( pPortDCR, bDCR );
            
            // Wait for nAckReverse response
            // 11/21/95 LLL, CGM: tightened test to include PeriphClk and XFlag.
            //                "ZIP_HRP: state 73, DSR" 
            if( CHECK_DSR( Pdx->Controller, DONT_CARE, ACTIVE, INACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
                // Yes, raise nReverseRequest, HostClk and HostAck (HostAck high so HW can drive)
                bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, ACTIVE );
                P5WritePortUchar( pPortDCR, bDCR );

                // Wait for nAckReverse response
                // 11/21/95 LLL, CGM: tightened test to include XFlag and PeriphClk.
                //         "ZIP_HRP: state 75, DSR"
                if( CHECK_DSR( Pdx->Controller, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, IEEE_MAXTIME_TL) ) {
                    // Let the host drive the bus again.
                    bDCR = P5ReadPortUchar(pPortDCR);               // Get content of DCR.
                    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
                    P5WritePortUchar(pPortDCR, bDCR );
                    
                    // Recovery is complete, let the caller decide what to do now
                    status = STATUS_SUCCESS;
                    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
                } else {
                    status = STATUS_IO_TIMEOUT;
                    DD((PCE)Pdx,DDW,"ParEcpHwHostRecoveryPhase - error prior to state 75\n");
                }
            } else {
                status = STATUS_IO_TIMEOUT;
                DD((PCE)Pdx,DDW,"ParEcpHwHostRecoveryPhase - error prior to state 73\n");
            }
        } else {
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(pPortDCR);  // Pass in the dcr address
#endif
            DD((PCE)Pdx,DDT, "ParEcpHwHostRecoveryPhase: VE_LINK_FAILURE \n");
            status = STATUS_LINK_FAILED;
        }
    } else {
        DD((PCE)Pdx,DDW,"ParEcpHwHostRecoveryPhase: VE_PORT_STOMPED\n");
        status = STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (!NT_SUCCESS(status)) {
        // Make sure both HostAck and HostClk are high before leaving
        // Also let the host drive the bus again.
        bDCR = P5ReadPortUchar( pPortDCR );
        bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar( pPortDCR, bDCR );
        
        // [[REVISIT]] pSDCB->wCurrentPhase = PHASE_UNKNOWN;
    }

    // Set the ECR to ECP mode, disable DMA
    status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );

    Pdx->PortHWMode = HW_MODE_ECP;
    
    DD((PCE)Pdx,DDT,"ParEcpHwHostRecoveryPhase - Exit w/status = %x\n", status);

    return status;
}

NTSTATUS
ParEcpHwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 ECP mode read under Hardware control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    NTSTATUS  status = STATUS_SUCCESS;
    PUCHAR    lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type
    ULONG     dCount = BufferSize;             // Working copy of caller's original request count
    UCHAR     bDSR;               // Contents of DSR
    UCHAR     bPeriphRequest;     // Calculated state of nPeriphReq signal, used in loop
    PUCHAR    wPortDSR = Pdx->Controller + DSR_OFFSET;
    PUCHAR    wPortECR = Pdx->EcrController + ECR_OFFSET;
    PUCHAR    wPortDFIFO = Pdx->EcrController;
    LARGE_INTEGER   WaitPerByteTimer;
    LARGE_INTEGER   StartPerByteTimer;
    LARGE_INTEGER   EndPerByteTimer;
    BOOLEAN         bResetTimer = TRUE;
    ULONG           wBurstCount;        // Calculated amount of data in FIFO
    UCHAR           ecrFIFO;
    
    WaitPerByteTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();
    
    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse Transfer Phase.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    //----------------------------------------------------------------------
    // We've already checked the shadow in ParRead. So go right to the
    // Hardware FIFO and pull more data across.
    //----------------------------------------------------------------------
    KeQueryTickCount(&StartPerByteTimer);   // Start the timer
    
ParEcpHwRead_ReadLoopStart:
    //------------------------------------------------------------------
    // Determine whether the FIFO has any data and respond accordingly
    //------------------------------------------------------------------
    ecrFIFO = (UCHAR)(P5ReadPortUchar(wPortECR) & (UCHAR)ECR_FIFO_MASK);
    
    if (ECR_FIFO_FULL == ecrFIFO) {

        wBurstCount = ( dCount > Pdx->FifoDepth ? Pdx->FifoDepth : dCount );
        dCount -= wBurstCount;
        
        P5ReadPortBufferUchar(wPortDFIFO, lpsBufPtr, wBurstCount);
        lpsBufPtr += wBurstCount;

        bResetTimer = TRUE;

    } else if (ECR_FIFO_SOME_DATA == ecrFIFO) {
        // Read just one byte at a time, since we don't know exactly how much is
        // in the FIFO.
        *lpsBufPtr = P5ReadPortUchar(wPortDFIFO);
        lpsBufPtr++;
        dCount--;

        bResetTimer = TRUE;

    } else {   // ECR_FIFO_EMPTY

        DD((PCE)Pdx,DDW,"ParEcpHwRead - ECR_FIFO_EMPTY - slow or bad periph?\n");
        // Nothing to do. We either have a slow peripheral or a bad peripheral.
        // We don't have a good way to figure out if its bad.  Let's chew up our
        // time and hope for the best.

        bResetTimer = FALSE;

    }   //  ECR_FIFO_EMPTY a.k.a. else clause of (ECR_FIFO_FULL == ecrFIFO)
    
    if (dCount == 0)
        goto ParEcpHwRead_ReadLoopEnd;
    else {

        // Limit the overall time we spend in this loop.
        if (bResetTimer) {
            bResetTimer = FALSE;
            KeQueryTickCount(&StartPerByteTimer);   // Restart the timer
        } else {
            KeQueryTickCount(&EndPerByteTimer);
            if (((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement()) > WaitPerByteTimer.QuadPart)
                goto ParEcpHwRead_ReadLoopEnd;
        }

    }

 goto ParEcpHwRead_ReadLoopStart;

ParEcpHwRead_ReadLoopEnd:

    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
    
    *BytesTransferred  = BufferSize - dCount;      // Set current count.
    
    Pdx->log.HwEcpReadCount += *BytesTransferred;
    
    if (0 == *BytesTransferred) {
        bDSR = P5ReadPortUchar(wPortDSR);
        bPeriphRequest = (UCHAR)TEST_DSR( bDSR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE );
        // Only flag a timeout error if the device still said it had data to send.
        if ( bPeriphRequest ) {
            //
            // Periph still says that it has data, but we timed out trying to read the data.
            //
            DD((PCE)Pdx,DDE,"ParEcpHwRead - read timout with nPeriphRequest asserted and no data read - error - STATUS_IO_TIMEOUT\n");
            status = STATUS_IO_TIMEOUT;
            if ((TRUE == Pdx->P12843DL.bEventActive) ) {
                //
                // Signal transport that it should try another read
                //
                KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
            }
        }
    }

    DD((PCE)Pdx,DDT,"ParEcpHwRead: Exit - status=%x, BytesTransferred[%d] dsr[%02x] dcr[%02x] ecr[%02x]\n",
       status, *BytesTransferred, P5ReadPortUchar(wPortDSR), 
       P5ReadPortUchar(Pdx->Controller + OFFSET_DCR), P5ReadPortUchar(wPortECR));
    
#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        if( NT_SUCCESS( status ) && (*BytesTransferred > 0) ) {
            const ULONG maxBytes = 32;
            ULONG i;
            PUCHAR bytePtr = (PUCHAR)Buffer;
            DbgPrint("R: ");
            for( i=0 ; (i < *BytesTransferred) && (i < maxBytes ) ; ++i ) {
                DbgPrint("%02x ",*bytePtr++);
            }
            if( *BytesTransferred > maxBytes ) {
                DbgPrint("... ");
            }
            DbgPrint("zz\n");
        }
    }
#endif

    return status;
}   // ParEcpHwRead

NTSTATUS
ParEcpHwRecoverPort(
    PPDO_EXTENSION Pdx,
    UCHAR  bRecoverCode
    )
{
    NTSTATUS   status = STATUS_SUCCESS;
    PUCHAR    wPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR    wPortDSR;       // IO address of Device Status Register (DSR)
    PUCHAR    wPortECR;       // IO address of Extended Control Register (ECR)
    PUCHAR    wPortData;      // IO address of Data Register
    UCHAR    bDCR;           // Contents of DCR
    UCHAR    bDSR;           // Contents of DSR
    UCHAR    bDSRmasked;     // DSR after masking low order bits

    DD((PCE)Pdx,DDT,"ParEcpHwRecoverPort:  enter %d\n", bRecoverCode );

    // Calculate I/O port addresses for common registers
    wPortDCR = Pdx->Controller + OFFSET_DCR;
    wPortDSR = Pdx->Controller + OFFSET_DSR;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortData = Pdx->Controller + OFFSET_DATA;


    //----------------------------------------------------------------------
    // Check if port is stomped.
    //----------------------------------------------------------------------
    bDCR = P5ReadPortUchar(wPortDCR);               // Get content of DCR.

    if ( ! TEST_DCR( bDCR, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE ) )
    {
        #if DVRH_BUS_RESET_ON_ERROR
            BusReset(wPortDCR);  // Pass in the dcr address
        #endif
        DD((PCE)Pdx,DDE,"ParEcpHwRecoverPort - port stomped\n");
        status = STATUS_DEVICE_PROTOCOL_ERROR;
    }


    //----------------------------------------------------------------------
    // Attempt a termination phase to get the peripheral recovered.
    // Ignore the error return, we've already got that figured out.
    //----------------------------------------------------------------------
    IeeeTerminate1284Mode(Pdx );

    //----------------------------------------------------------------------
    // Set the ECR to PS2 Mode so we can change bus direction.
    //----------------------------------------------------------------------
    Pdx->ClearChipMode( Pdx->PortContext, ECR_ECP_PIO_MODE );
    Pdx->PortHWMode = HW_MODE_PS2;

    //----------------------------------------------------------------------
    // Assert nSelectIn low, nInit high, nStrobe high, and nAutoFd high.
    //----------------------------------------------------------------------
    bDCR = P5ReadPortUchar(wPortDCR);             // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
    P5WritePortUchar(wPortDCR, bDCR);
    P5WritePortUchar(wPortData, bRecoverCode);      // Output the error ID
    KeStallExecutionProcessor(100);                 // Hold long enough to capture
    P5WritePortUchar(wPortData, 0);                 // Now clear the data lines.


    //----------------------------------------------------------------------
    // Set the ECR to mode 000 (Compatibility Mode).
    //----------------------------------------------------------------------
    // Nothing needs to be done here.
    Pdx->PortHWMode = HW_MODE_COMPATIBILITY;


    //----------------------------------------------------------------------
    // Check for any link errors if nothing bad found yet.
    //----------------------------------------------------------------------
    bDSR = P5ReadPortUchar(wPortDSR);               // Get content of DSR.
    bDSRmasked = (UCHAR)(bDSR | 0x07);              // Set first 3 bits (don't cares).

    if( NT_SUCCESS(status) ) {

        if (bDSRmasked != 0xDF) {

            DD((PCE)Pdx,DDE,"ParEcpHwRecoverPort - DSR Exp value: 0xDF, Act value: 0x%X\n",bDSRmasked);

            // Get DSR again just to make sure...
            bDSR = P5ReadPortUchar(wPortDSR);           // Get content of DSR.
            bDSRmasked = (UCHAR)(bDSR | 0x07);          // Set first 3 bits (don't cares).

            if( (CHKPRNOFF1 == bDSRmasked ) || (CHKPRNOFF2 == bDSRmasked ) ) { // Check for printer off.
                DD((PCE)Pdx,DDW,"ParEcpHwRecoverPort - DSR value: 0x%X, Printer Off\n", bDSRmasked);
                status = STATUS_DEVICE_POWERED_OFF;
            } else {
                if( CHKNOCABLE == bDSRmasked ) {  // Check for cable unplugged.
                    DD((PCE)Pdx,DDW,"ParEcpHwRecoverPort - DSR value: 0x%X, Cable Unplugged\n",bDSRmasked);
                    status = STATUS_DEVICE_NOT_CONNECTED;
                } else {
                    DD((PCE)Pdx,DDW,"ParEcpHwRecoverPort - DSR value: 0x%X, Unknown error\n",bDSRmasked);
                    status = STATUS_LINK_FAILED;
                }
            }
        }
    }

    //----------------------------------------------------------------------
    // Set status byte to indicate Compatibility Mode.
    //----------------------------------------------------------------------
    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return status;

}   // ParEcpHwRecoverPort

NTSTATUS
ParEcpHwSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets the ECP Address.
    
Arguments:

    Pdx           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    NTSTATUS   status = STATUS_SUCCESS;
    PUCHAR    wPortDSR;       // IO address of Device Status Register
    PUCHAR    wPortECR;       // IO address of Extended Control Register
    PUCHAR    wPortAFIFO;     // IO address of ECP Address FIFO
    UCHAR    bDSR;           // Contents of DSR
    UCHAR    bECR;           // Contents of ECR
    BOOLEAN    bDone;

    DD((PCE)Pdx,DDT,"ParEcpHwSetAddress, Start\n");

    // Calculate I/O port addresses for common registers
    wPortDSR = Pdx->Controller + DSR_OFFSET;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortAFIFO = Pdx->Controller + AFIFO_OFFSET;

    //----------------------------------------------------------------------
    // Check for any link errors.
    //----------------------------------------------------------------------
    //ZIP_CHECK_PORT( DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
    //                "ZIP_SCA: init DCR", RECOVER_40, errorExit );

    //ZIP_CHECK_LINK( DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
    //                "ZIP_SCA: init DSR", RECOVER_41, errorExit );


    // Set state to indicate ECP forward transfer phase
    P5SetPhase( Pdx, PHASE_FORWARD_XFER );


    //----------------------------------------------------------------------
    // Send ECP channel address to AFIFO.
    //----------------------------------------------------------------------
    if ( ! ( TEST_ECR_FIFO( P5ReadPortUchar( wPortECR), ECR_FIFO_EMPTY ) ? TRUE : 
             CheckPort( wPortECR, ECR_FIFO_MASK, ECR_FIFO_EMPTY, IEEE_MAXTIME_TL ) ) ) {

        status = ParEcpHwHostRecoveryPhase(Pdx);
        DD((PCE)Pdx,DDT,"ParEcpHwSetAddress: FIFO full, timeout sending ECP channel address\n");
        status = STATUS_IO_DEVICE_ERROR;

    } else {

        // Send the address byte.  The most significant bit must be set to distinquish
        // it as an address (as opposed to a run-length compression count).
        P5WritePortUchar(wPortAFIFO, (UCHAR)(Address | 0x80));
    }

    if ( NT_SUCCESS(status) ) {

        // If there have been no previous errors, and synchronous writes
        // have been requested, wait for the FIFO to empty and the device to
        // complete the last PeriphAck handshake before returning success.

        if ( Pdx->bSynchWrites ) {

            LARGE_INTEGER   Wait;
            LARGE_INTEGER   Start;
            LARGE_INTEGER   End;

            // we wait up to 35 milliseconds.
            Wait.QuadPart = (IEEE_MAXTIME_TL * 10 * 1000) + KeQueryTimeIncrement();  // 35ms

            KeQueryTickCount(&Start);

            bDone = FALSE;
            while ( ! bDone )
            {
                bECR = P5ReadPortUchar( wPortECR );
                bDSR = P5ReadPortUchar( wPortDSR );
                // LLL/CGM 10/9/95: Tighten up link test - PeriphClk high
                if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
                     TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) ) {
                    bDone = TRUE;

                } else {

                    KeQueryTickCount(&End);

                    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
                        DD((PCE)Pdx,DDT,"ParEcpHwSetAddress, timeout during synch\n");
                        bDone = TRUE;
                        status = ParEcpHwHostRecoveryPhase(Pdx);
                        status = STATUS_IO_DEVICE_ERROR;
                    }

                }

            } // of while...

        } // if bSynchWrites...

    }

    if ( NT_SUCCESS(status) ) {
        // Update the state to reflect that we are back in an idle phase
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    } else if ( status == STATUS_IO_DEVICE_ERROR ) {
        // Update the state to reflect that we are back in an idle phase
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    }       

    return status;
}

NTSTATUS
ParEcpHwSetupPhase(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine performs 1284 Setup Phase.

Arguments:

    Controller      - Supplies the port address.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS   Status = STATUS_SUCCESS;
    PUCHAR    pPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR    pPortDSR;       // IO address of Device Status Register (DSR)
    PUCHAR    pPortECR;       // IO address of Extended Control Register (ECR)
    UCHAR    bDCR;           // Contents of DCR

    // Calculate I/O port addresses for common registers
    pPortDCR = Pdx->Controller + OFFSET_DCR;
    pPortDSR = Pdx->Controller + OFFSET_DSR;
    pPortECR = Pdx->EcrController + ECR_OFFSET;

    // Get the DCR and make sure port hasn't been stomped
    //ZIP_CHECK_PORT( DIR_WRITE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
    //                "ZIP_SP: init DCR", RECOVER_44, exit1 );


    // Set HostAck low
    bDCR = P5ReadPortUchar(pPortDCR);               // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
    P5WritePortUchar( pPortDCR, bDCR );

    // for some reason dvdr doesn't want an extra check in UNSAFE_MODE
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        // Wait for nAckReverse to go high
        // LLL/CGM 10/9/95:  look for PeriphAck low, PeriphClk high as per 1284 spec.
        if ( !CHECK_DSR(Pdx->Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
                        IEEE_MAXTIME_TL ) )
        {
            // Any failure leaves us in an unknown state to recover from.
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            Status = STATUS_IO_DEVICE_ERROR;
            goto HWECP_SetupPhaseExitLabel;
        }
    }

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    Status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_ECP_PIO_MODE );            
    // Set DCR:  DIR=0 for output, HostAck and HostClk high so HW can drive
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
    P5WritePortUchar( pPortDCR, bDCR );

    // Set the ECR to ECP mode, disable DMA

    Pdx->PortHWMode = HW_MODE_ECP;

    // If setup was successful, mark the new ECP phase.
    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    Status = STATUS_SUCCESS;

HWECP_SetupPhaseExitLabel:

    DD((PCE)Pdx,DDT,"ParEcpHwSetupPhase - exit w/status=%x\n",Status);

    return Status;
}

NTSTATUS ParEcpHwWaitForEmptyFIFO(IN PPDO_EXTENSION   Pdx)
/*++

Routine Description:

    This routine will babysit the Fifo.

Arguments:

    Pdx  - The device extension.

Return Value:

    NTSTATUS.

--*/
{
    UCHAR           bDSR;         // Contents of DSR
    UCHAR           bECR;         // Contents of ECR
    UCHAR           bDCR;         // Contents of ECR
    BOOLEAN         bDone = FALSE;
    PUCHAR          wPortDSR;
    PUCHAR          wPortECR;
    PUCHAR          wPortDCR;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    NTSTATUS        status = STATUS_SUCCESS;

    // Calculate I/O port addresses for common registers 
    wPortDSR = Pdx->Controller + OFFSET_DSR;
    wPortECR = Pdx->EcrController + ECR_OFFSET;
    wPortDCR = Pdx->Controller + OFFSET_DCR;

    Wait.QuadPart = (330 * 10 * 1000) + KeQueryTimeIncrement();  // 330ms
    
    KeQueryTickCount(&Start);

    //--------------------------------------------------------------------
    // wait for the FIFO to empty and the last
    // handshake of PeriphAck to complete before returning success.
    //--------------------------------------------------------------------

    while ( ! bDone )
    {
        bECR = P5ReadPortUchar(wPortECR);
        bDSR = P5ReadPortUchar(wPortDSR);
        bDCR = P5ReadPortUchar(wPortDCR);
        
#if 0 // one bit differs - keep alternate around until we know which to really use
        if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
            TEST_DCR( bDCR, INACTIVE, ***INACTIVE***, ACTIVE, ACTIVE, DONT_CARE, ACTIVE ) &&
            TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )  {
#else
        if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
            TEST_DCR( bDCR, INACTIVE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, ACTIVE ) &&
            TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )  {
#endif
            
            // FIFO is empty, exit without error.
            bDone = TRUE;

        } else {
        
            KeQueryTickCount(&End);
            
            if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
                
                // FIFO not empty, timeout occurred, exit with error.
                // NOTE: There is not a good way to determine how many bytes
                // are stuck in the fifo
                DD((PCE)Pdx,DDT,"ParEcpHwWaitForEmptyFIFO: timeout during synch\n");
                status = STATUS_IO_TIMEOUT;
                bDone = TRUE;
            }
        }
     } // of while...
     
     return status;
}

NTSTATUS
ParEcpHwWrite(
    IN  PPDO_EXTENSION  Pdx,
    IN  PVOID           Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          BytesTransferred
    )
/*++

Routine Description:

    Writes data to the peripheral using the ECP protocol under hardware
    control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          wPortDSR;
    PUCHAR          wPortECR;
    PUCHAR          wPortDFIFO;
    ULONG           bytesToWrite = BufferSize;
    UCHAR           dsr;
    UCHAR           ecr;
    UCHAR           ecrFIFO;
    LARGE_INTEGER   WaitPerByteTimer;
    LARGE_INTEGER   StartPerByteTimer;
    LARGE_INTEGER   EndPerByteTimer;
    BOOLEAN         bResetTimer = TRUE;
    ULONG           wBurstCount;    // Length of burst to write when FIFO empty
    PUCHAR          pBuffer;
    NTSTATUS        status = STATUS_SUCCESS;
    
    wPortDSR   = Pdx->Controller + DSR_OFFSET;
    wPortECR   = Pdx->EcrController + ECR_OFFSET;
    wPortDFIFO = Pdx->EcrController;
    pBuffer    = Buffer;

    status = ParTestEcpWrite(Pdx);
    if (!NT_SUCCESS(status)) {
        P5SetPhase( Pdx, PHASE_UNKNOWN );                     
        Pdx->Connected = FALSE;                                
        DD((PCE)Pdx,DDT,"ParEcpHwWrite: Invalid Entry State\n");
        goto ParEcpHwWrite_ExitLabel;       // Use a goto so we can see Debug info located at the end of proc!
    }

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    //----------------------------------------------------------------------
    // Setup Timer Stuff.
    //----------------------------------------------------------------------
    // we wait up to 35 milliseconds.
    WaitPerByteTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();  // 35ms

    // Set up the timer that limits the time allowed for per-byte handshakes.
    KeQueryTickCount(&StartPerByteTimer);
    
    //----------------------------------------------------------------------
    // Send the data to the DFIFO.
    //----------------------------------------------------------------------

HWECP_WriteLoop_Start:

    //------------------------------------------------------------------
    // Determine whether the FIFO has space and respond accordingly.
    //------------------------------------------------------------------
    ecrFIFO = (UCHAR)(P5ReadPortUchar(wPortECR) & ECR_FIFO_MASK);

    if ( ECR_FIFO_EMPTY == ecrFIFO ) {
        wBurstCount = (bytesToWrite > Pdx->FifoDepth) ? Pdx->FifoDepth : bytesToWrite;
        bytesToWrite -= wBurstCount;
        
        P5WritePortBufferUchar(wPortDFIFO, pBuffer, wBurstCount);
        pBuffer += wBurstCount;
        
        bResetTimer = TRUE;
    } else if (ECR_FIFO_SOME_DATA == ecrFIFO) {
        // Write just one byte at a time, since we don't know exactly how much
        // room there is in the FIFO.
        P5WritePortUchar(wPortDFIFO, *pBuffer++);
        bytesToWrite--;
        bResetTimer = TRUE;
    } else {    //  ECR_FIFO_FULL
        // Need to figure out whether to keep attempting to send, or to quit
        // with a timeout status.
        
        // Reset the per-byte timer if a byte was received since the last
        // timer check.
        if ( bResetTimer ) {
            KeQueryTickCount(&StartPerByteTimer);
            bResetTimer = FALSE;
        }
        
        KeQueryTickCount(&EndPerByteTimer);
        if ((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement() > WaitPerByteTimer.QuadPart) {
            status = STATUS_TIMEOUT;
            // Peripheral is either busy or stalled.  If the peripheral
            // is busy then they should be using SWECP to allow for
            // relaxed timings.  Let's punt!
            goto HWECP_WriteLoop_End;
        }
    }

    if (bytesToWrite == 0) {
        goto HWECP_WriteLoop_End; // Transfer completed.
    }

    goto HWECP_WriteLoop_Start; // Start over
    
HWECP_WriteLoop_End:

    if ( NT_SUCCESS(status) ) {
        // If there have been no previous errors, and synchronous writes
        // have been requested, wait for the FIFO to empty and the last
        // handshake of PeriphAck to complete before returning success.
        if (Pdx->bSynchWrites ) {
            BOOLEAN         bDone = FALSE;
            

            KeQueryTickCount(&StartPerByteTimer);

            while( !bDone ) {
                ecr = P5ReadPortUchar(wPortECR);
                dsr = P5ReadPortUchar(wPortDSR);
                // LLL/CGM 10/9/95: tighten up DSR test - PeriphClk should be high
                if ( TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) &&
                     TEST_DSR( dsr, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) ) {
                    // FIFO is empty, exit without error.
                    bDone = TRUE;
                } else {

                    KeQueryTickCount(&EndPerByteTimer);
                    if ((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement() > WaitPerByteTimer.QuadPart) {
                        // FIFO not empty, timeout occurred, exit with error.
                        status = STATUS_TIMEOUT;
                        bDone = TRUE;
                    }
                }
            } // of while...
        }
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

ParEcpHwWrite_ExitLabel:

    *BytesTransferred = BufferSize - bytesToWrite;
    
    Pdx->log.HwEcpWriteCount += *BytesTransferred;
    
    DD((PCE)Pdx,DDT,"ParEcpHwWrite: exit w/status=%x, BytesTransferred=%d, dsr=%02x dcr=%02x, ecr=%02x\n",
       status, *BytesTransferred, P5ReadPortUchar(wPortDSR), P5ReadPortUchar(Pdx->Controller + OFFSET_DCR), P5ReadPortUchar(wPortECR));

#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        if( NT_SUCCESS( status ) && (*BytesTransferred > 0) ) {
            const ULONG maxBytes = 32;
            ULONG i;
            PUCHAR bytePtr = (PUCHAR)Buffer;
            DbgPrint("W: ");
            for( i=0 ; (i < *BytesTransferred) && (i < maxBytes) ; ++i ) {
                DbgPrint("%02x ",*bytePtr++);
            }
            if( *BytesTransferred > maxBytes ) {
                DbgPrint("... ");
            }
            DbgPrint("zz\n");
        }
    }
#endif

    return status;
}

NTSTATUS
ParEnterEcpHwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    ECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Controller;

    Controller = Pdx->Controller;

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Pdx, ECP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Pdx, ECP_EXTENSIBILITY);
        }
    } else {
        Pdx->Connected = TRUE;
    }
    
    // LAC ENTEREXIT  5Dec97
    // Make sure that the ECR is in PS/2 mode, and that wPortHWMode
    // has the correct value.  (This is the common entry mode);
    Pdx->PortHWMode = HW_MODE_PS2;

    if (NT_SUCCESS(Status)) {
        Status = ParEcpHwSetupPhase(Pdx);
        Pdx->bSynchWrites = TRUE;     // NOTE this is a temp hack!!!  dvrh
        if (!Pdx->bShadowBuffer)
        {
            Queue_Create(&(Pdx->ShadowBuffer), Pdx->FifoDepth * 2);		
            Pdx->bShadowBuffer = TRUE;
        }
        Pdx->IsIeeeTerminateOk = TRUE;
    }

    return Status;
}

BOOLEAN
ParIsEcpHwSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS Status;

    if (Pdx->BadProtocolModes & ECP_HW_NOIRQ)
        return FALSE;

    if (Pdx->ProtocolModesSupported & ECP_HW_NOIRQ)
        return TRUE;

    if (!(Pdx->HardwareCapabilities & PPT_ECP_PRESENT))
        return FALSE;

    if (0 == Pdx->FifoWidth)
        return FALSE;
        
    if (Pdx->ProtocolModesSupported & ECP_SW)
        return TRUE;

    // Must use HWECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEcpHwMode (Pdx, FALSE);
    ParTerminateHwEcpMode (Pdx);

    if (NT_SUCCESS(Status)) {

        Pdx->ProtocolModesSupported |= ECP_HW_NOIRQ;
        return TRUE;
    }
    return FALSE;
}

VOID
ParTerminateHwEcpMode(
    IN  PPDO_EXTENSION  Pdx
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{

    // Need to check current phase -- if its reverse, need to flip bus
    // If its not forward -- its an incorrect phase and termination will fail.
    if( Pdx->ModeSafety == SAFE_MODE ) {

        switch( Pdx->CurrentPhase ) {

        case  PHASE_FORWARD_IDLE:  // Legal state to terminate from
            break;

        case PHASE_TERMINATE:      // already terminated, nothing to do
            DD((PCE)Pdx,DDW,"ParTerminateHwEcpMode - Already Terminated - Why are we trying to terminate again?\n");
            goto target_exit;
            break;

        case PHASE_REVERSE_IDLE:   // Flip bus to forward so we can terminate
            {
                NTSTATUS status = ParEcpHwExitReversePhase( Pdx );
            	if( STATUS_SUCCESS == status ) {
                    status = ParEcpEnterForwardPhase( Pdx );
                }
            }
            break;

        case  PHASE_FORWARD_XFER:
        case  PHASE_REVERSE_XFER:
        default:
            DD((PCE)Pdx,DDE,"ParTerminateHwEcpMode - Invalid Phase [%x] for termination\n", Pdx->CurrentPhase);
            // Don't know what to do here!?!
        }

        ParEcpHwWaitForEmptyFIFO( Pdx );

        ParCleanupHwEcpPort( Pdx );

        IeeeTerminate1284Mode( Pdx );

    } else {
        // UNSAFE_MODE
        ParCleanupHwEcpPort(Pdx);
        Pdx->Connected = FALSE;
    }

target_exit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\ieee1284.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    ieee1284.c

Abstract:

    This module contains the code to do ieee 1284 negotiation and termination.

Author:

    Timothy T. Wells (v-timtw)          13 Mar 97
    Robbie Harris (Hewlett-Packard)     21 May 98.  Added enough comments to the
                                                    Negotation proc to keep any developer happy.

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

VOID
IeeeTerminate1284Mode(
    IN  PPDO_EXTENSION   Pdx
    );

NTSTATUS
IeeeEnter1284Mode(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Extensibility
    );

//
// Definition of the Forward and Reverse Protocol Arrays
//
extern FORWARD_PTCL    afpForward[] = {

    //
    // Bounded ECP (Hardware)
    //
    PptIsBecpSupported,
    PptEnterBecpMode,
    PptTerminateBecpMode,
    ParEcpHwSetAddress,
    ParEcpEnterForwardPhase,           // Enter Forward
    ParEcpHwExitForwardPhase,           // Exit Forward
    ParEcpHwWrite,
    BOUNDED_ECP,
    FAMILY_BECP,             

    //
    // ECP Hardware
    //
    ParIsEcpHwSupported,        // This is resued for both read/write
    ParEnterEcpHwMode,
    ParTerminateHwEcpMode,
    ParEcpHwSetAddress,           
    ParEcpEnterForwardPhase,  // Enter Forward
    ParEcpHwExitForwardPhase,   // Exit Forward
    ParEcpHwWrite,
    ECP_HW_NOIRQ,
    FAMILY_ECP,

    //
    // Epp Hardware
    //
    ParIsEppHwSupported,
    ParEnterEppHwMode,
    ParTerminateEppHwMode,
    ParEppSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEppHwWrite,
    EPP_HW,
    FAMILY_EPP,

    //
    // Epp Software
    //
    ParIsEppSwWriteSupported,
    ParEnterEppSwMode,
    ParTerminateEppSwMode,
    ParEppSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEppSwWrite,
    EPP_SW,
    FAMILY_EPP,

    //
    // Ecp Software
    //
    ParIsEcpSwWriteSupported,
    ParEnterEcpSwMode,
    ParTerminateEcpMode,
    ParEcpSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEcpSwWrite,
    ECP_SW,
    FAMILY_ECP,

    //
    // IEEE Centronics
    //
    NULL,
    ParEnterSppMode,
    ParTerminateSppMode,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    SppIeeeWrite,
    IEEE_COMPATIBILITY,
    FAMILY_NONE,

    //
    // Centronics
    //
    NULL,
    ParEnterSppMode,
    ParTerminateSppMode,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    SppWrite,
    CENTRONICS,
    FAMILY_NONE,

    //
    // None...
    //
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    NULL,
    NONE,
    FAMILY_NONE
};

extern REVERSE_PTCL    arpReverse[] = {

    //
    // Bounded Ecp Mode
    //
    PptIsBecpSupported,
    PptEnterBecpMode,
    PptTerminateBecpMode,
    NULL,                       // Violates IEEE 1284.3 to set Reverse address for BECP
    PptEcpHwEnterReversePhase,   // Enter Reverse
    PptBecpExitReversePhase,     // Exit Reverse
    PptEcpHwDrainShadowBuffer,  // A read from Cached data
    PptEcpHwHaveReadData,         // Quick peek to see if Periph has reverse data without flipping the bus
                                // NOTE: This is crucial since it violates the 1284.3 BECP to flip
                                // blindly into reverse if the peripheral doesn't have data.
    PptBecpRead,
    BOUNDED_ECP,
    FAMILY_BECP,             

    //
    // Hardware Ecp Mode
    //
    ParIsEcpHwSupported,        // This is resued for both read/write
    ParEnterEcpHwMode,
    ParTerminateHwEcpMode,
    ParEcpHwSetAddress,           // Reuse the one in ecp.c
    PptEcpHwEnterReversePhase,  // Enter Reverse
    ParEcpHwExitReversePhase,   // Exit Reverse
    PptEcpHwDrainShadowBuffer,  // A read from Cached data
    PptEcpHwHaveReadData,       // Quick peek to see if Periph has reverse data without flipping the bus
    ParEcpHwRead,
    ECP_HW_NOIRQ,
    FAMILY_ECP,

    //
    // Epp Hardware
    //
    ParIsEppHwSupported,            // This is resued for both read/write
    ParEnterEppHwMode,
    ParTerminateEppHwMode,
    ParEppSetAddress,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParEppHwRead,
    EPP_HW,
    FAMILY_EPP,

    //
    // Epp Software Mode
    //
    ParIsEppSwReadSupported,
    ParEnterEppSwMode,
    ParTerminateEppSwMode,
    ParEppSetAddress,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParEppSwRead,
    EPP_SW,
    FAMILY_EPP,

    //
    // Ecp Software Mode
    //
    ParIsEcpSwReadSupported,
    ParEnterEcpSwMode,
    ParTerminateEcpMode,
    ParEcpSetAddress,
    ParEcpForwardToReverse,             // Enter Reverse
    ParEcpReverseToForward,             // Exit Reverse
    NULL,                               // A read from Cached data
    ParEcpHaveReadData,                 // Quick peek to see if Periph has reverse data without flipping the bus
    ParEcpSwRead,
    ECP_SW,
    FAMILY_ECP,

    //
    // Byte Mode
    //
    ParIsByteSupported,
    ParEnterByteMode,
    ParTerminateByteMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParByteModeRead,
    BYTE_BIDIR,
    FAMILY_REVERSE_BYTE,

    //
    // Nibble Mode
    //
    ParIsNibbleSupported,
    ParEnterNibbleMode,
    ParTerminateNibbleMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParNibbleModeRead,
    NIBBLE,
    FAMILY_REVERSE_NIBBLE,

    //
    // Channelized Nibble Mode
    //
    ParIsChannelizedNibbleSupported,
    ParEnterChannelizedNibbleMode,
    ParTerminateNibbleMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParNibbleModeRead,
    CHANNEL_NIBBLE,
    FAMILY_REVERSE_NIBBLE,
    
    //
    // None...
    //
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    NULL,
    NONE,
    FAMILY_NONE
};


VOID
IeeeTerminate1284Mode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    PUCHAR Controller;
    PUCHAR wPortDCR;
    UCHAR  dcr, dsrMask, dsrValue;
    BOOLEAN bXFlag;
    BOOLEAN bUseXFlag = FALSE;

    Controller = Pdx->Controller;
    wPortDCR = Controller + OFFSET_DCR;
    dcr = P5ReadPortUchar(wPortDCR);

    if( PHASE_TERMINATE == Pdx->CurrentPhase )	{
        // We are already terminated.  This will fail if we don't
        // just bypass this mess.
        goto Terminate_ExitLabel;
    }

    // Keep Negotiated XFLAG to use for termination.
    //    xFlag,  // Technically we should have
    // cached this value from state
    // 6 of nego. This peripheral's XFlag
    // at pre state 22 should be the
    // same as state 6.
    bXFlag = P5ReadPortUchar(Controller + OFFSET_DSR) & 0x10;

    // REVISIT: Do we need to ensure the preceeding state is a valid
    //          state to terminate from.  In other words, is there there
    //          a black bar on the 1284 line for that state?


    // =============== Host State 22 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low (Signals state 22)
    //  nReverseReq/**(ECP only)    = Don't Care (High for ECP, otherwise unused)
    //  HostAck/HostBusy/nAutoFeed  = High
    //  HostClk/nStrobe             = High
    //
    Pdx->CurrentEvent = 22;
    dcr = P5ReadPortUchar(wPortDCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);

    //
    // Some devices start working if we add a delay here - no idea why
    // this works
    //
    // Make the delay configurable via registry setting so that devices that
    //   don't need this delay aren't penalized
    //
    if( Pdx->Event22Delay != 0 ) {
        if( Pdx->Event22Delay > 1000 ) {
            Pdx->Event22Delay = 1000;
        }
        KeStallExecutionProcessor( Pdx->Event22Delay );
    }

    P5WritePortUchar(wPortDCR, dcr);

    // Clear data lines so we don't have any random spew.
    P5WritePortUchar(Controller + OFFSET_DATA, 0);

    // *************** Periph State 23/24 Termination ***************8
    // PeriphAck/PtrBusy        = High  (Signals state 23 for ECP
    //                                   otherwise already high)
    // PeriphClk/PtrClk         = Low   (Signals state 24 for ecp
    //                                   Signals state 23 for Nibble)
    // nAckRev/AckDataReq/PE    = Don't Care
    // XFlag                    = Low  (ECP and Byte)   (State 24)
    //                          = High (Nibble)         (State 24)
    //                          = Low (All DeviceID Requests including Nibble) (State 24)
    //                          = Undefined (EPP)
    // nPeriphReq/nDataAvail    = High
    //                            Don't check nPeriphReq/nDataAvail
    //                            Since it was in a "Don't Care"
    //                            state (ie. Double bar in the spec)
    //                            until state 23 for ECP mode.
    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE || Pdx->CurrentPhase == PHASE_REVERSE_XFER) {

        // We must be in Nibble Reverse.  Let's double check!!!
        if( FAMILY_REVERSE_NIBBLE == arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily ||
            FAMILY_REVERSE_BYTE   == arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily )
            bUseXFlag = TRUE;   // We're in Nibble or Byte
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?

    } else {

        if (FAMILY_BECP == afpForward[Pdx->IdxForwardProtocol].ProtocolFamily ||
            FAMILY_ECP  == afpForward[Pdx->IdxForwardProtocol].ProtocolFamily )
            bUseXFlag = TRUE;   // We're in an ECP Flavor
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?
    }

    if( bUseXFlag ) {

        dsrMask = DSR_TEST_MASK( DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );

    } else {

        dsrMask = DSR_TEST_MASK( DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
    }

    Pdx->CurrentEvent = 23;

    if( !CheckPort(Controller + OFFSET_DSR, dsrMask, dsrValue, IEEE_MAXTIME_TL)) {
        // We couldn't negotiate back to compatibility mode.
        // just terminate.
        DD((PCE)Pdx,DDW,"IeeeTerminate1284Mode:State 23/24 Failed: Controller %x dsr %x dcr %x\n",
           Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
        goto Terminate_ExitLabel;
    }

    // =============== Host State 25 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = Low (Signals State 25)
    //  HostClk/nStrobe             = High
    //
    Pdx->CurrentEvent = 25;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // =============== State 26 Termination ===============8
    // Do nothing for state 26

    // =============== Periph State 27 Termination ===============8
    // PeriphAck/PtrBusy        = High
    // PeriphClk/PtrClk         = High   (Signals State 27)
    // nAckRev/AckDataReq/PE    = Don't Care  (Invalid from State 23)
    // XFlag                    = Don't Care (All Modes)   (Invlaid at State 27)
    // nPeriphReq/nDataAvial    = Don't Care (Invalid from State 26)
    // dvrh 6/16/97
    Pdx->CurrentEvent = 27;
    if( !CHECK_DSR(Controller, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) ) {
        DD((PCE)Pdx,DDW,"IeeeTerminate1284Mode:State 27 Failed: Controller %x dsr %x dcr %x\n", 
           Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
    }

Terminate_ExitLabel:

    // =============== Host State 28 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = High (Signals State 28)
    //  HostClk/nStrobe             = High
    //
    Pdx->CurrentEvent = 28;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // We are now back in compatibility mode.

    P5SetPhase( Pdx, PHASE_TERMINATE );
    Pdx->Connected = FALSE;
    Pdx->IsIeeeTerminateOk = FALSE;
    DD((PCE)Pdx,DDT,"IeeeTerminate1284Mode - exit - dcr=%x\n", dcr);
    return;
}

NTSTATUS
IeeeEnter1284Mode(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Extensibility
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    PUCHAR          wPortDCR;
    PUCHAR          Controller;
    UCHAR           dcr;
    const USHORT    sPeriphResponseTime = 35;

    Controller = Pdx->Controller;
    wPortDCR = Controller + OFFSET_DCR;

    /* =============== Host Prep for Pre State 0 ===============8
       Set the following just in case someone didn't
       put the port in compatibility mode before we got it.
      
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High for ECP / Don't Care for Nibble
                                    I will do ahead and set it to high
                                    since Nibble doesn't care.
        HostAck/HostBusy        = High
        HostClk/nStrobe         = Don't Care
    ============================================================ */
    dcr = P5ReadPortUchar(wPortDCR);               // Get content of DCR.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, DONT_CARE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);

    /* =============== Host Pre State 0 Negotiation ===============8
        DIR                     = Low ( Don't Care by spec )
        IRQEN                   = Low ( Don't Care by spec )
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High ( Don't Care by spec )
        HostAck/HostBusy        = High
        HostClk/nStrobe         = High
    ============================================================ */
    
    dcr = UPDATE_DCR(dcr, INACTIVE, INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);
    /* =============== Host State 0 Negotiation ===============8
       Place the extensibility request value on the data bus - state 0.
      
    ============================================================ */
    Pdx->CurrentEvent = 0;
    P5WritePortUchar(Controller + DATA_OFFSET, Extensibility);
    KeStallExecutionProcessor(2);

    /* =========== Host State 1 Negotiation Phase ===========8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High  (Signals State 1)
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low   (Signals state 1)
        HostClk/nStrobe         = High
      
    ============================================================ */
    Pdx->CurrentEvent = 1;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* =============== Periph State 2 Negotiation ===============8
       PeriphAck/PtrBusy        = Don't Care
       PeriphClk/PtrClk         = low   Signals State 2
       nAckReverse/AckDataReq   = high  Signals State 2
       XFlag                    = high  Signals State 2
                                    **Note: It is high at state 2
                                            for both ecp and nibble
       nPeriphReq/nDataAvail    = high  Signals State 2
    ============================================================ */
    Pdx->CurrentEvent = 2;
    if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE,
                  sPeriphResponseTime)) {
        KeStallExecutionProcessor(2);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);
        
        DD((PCE)Pdx,DDW,"IeeeEnter1284Mode - controller=%x - extensibility=%x, FAIL - TIMEOUT on Event 2\n",
           Pdx->Controller, Extensibility);

        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->Connected = FALSE;
        Pdx->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    /* =============== Host State 3 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low
        HostClk/nStrobe         = Low (signals State 3)
      
        NOTE: Strobe the Extensibility byte
    ============================================================ */
    Pdx->CurrentEvent = 3;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, INACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // HostClk must be help low for at least .5 microseconds.
    //
    KeStallExecutionProcessor(2);

    /* =============== Host State 4 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = High (signals State 4)
        HostClk/nStrobe         = High (signals State 4)
      
        NOTE: nReverseReq should be high in ECP, but this line is only
                valid for ECP.  Since it isn't used for signaling
                anything in negotiation, let's just ignore it for now.
    ============================================================ */
    Pdx->CurrentEvent = 4;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* ============== Periph State 5/6 Negotiation ===============
       PeriphAck/PtrBusy        = Don't Care. low (ECP) / Don't Care (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       PeriphClk/PtrClk         = high (Signals State 6)
       nAckReverse/AckDataReq   = Don't Care. low (ECP) / high (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       XFlag                    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       nPeriphReq/nDataAvail    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       ============== Periph State 5/6 Negotiation ==============8
      
        NOTES:
                - It's ok to lump states 5 and 6 together.  In state 5 Nibble,
                    the periph will set XFlag low and nPeriphReq/nDataAvail low.
                    The periph will then hold for .5ms then set PeriphClk/PtrClk
                    high.  In ECP, state 5 is nAckReverse/AckDataReq going low and
                    PeriphAck/PtrBusy going low.  Followed by a .5ms pause.
                    Followed by PeriphClk/PtrClk going high.
    ============================================================ */
    Pdx->CurrentEvent = 5;
    if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE,
                  sPeriphResponseTime)) {
                  
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);

        DD((PCE)Pdx,DDW,"IeeeEnter1284Mode- controller=%x - extensibility=%x, FAIL - TIMEOUT on Events 5/6\n",
           Pdx->Controller, Extensibility);

        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->Connected = FALSE;
        Pdx->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    KeStallExecutionProcessor(2);

    P5SetPhase( Pdx, PHASE_NEGOTIATION );
    Pdx->Connected = TRUE;
    return STATUS_SUCCESS;
}

VOID
IeeeDetermineSupportedProtocols(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine walks the list of all ieee1284 modes, and
    flags each of the ones the peripheral supports in
    Pdx->ProtocolModesSupported. This proc is called from
    external IOCTL.

Arguments:

    Pdx - The parallel device extension

Return Value:

--*/
{
    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    // Take CENTRONICS as a given since it is not a
    // mode we can neogitate to.
    //
    // n.b.
    // Let's go ahead and mark IEEE_COMPATIBILITY since we
    // cannot negotiate into it.  But if the someone sets 
    // IEEE_COMPATIBILITY and the peripheral does not support
    // IEEE 1284 compliant compatibility mode then we're gonna
    // create one very unhappy peripheral.      -- dvrh
    Pdx->ProtocolModesSupported = CENTRONICS | IEEE_COMPATIBILITY;

    //
    // Unlikely that we would be connected, but...
    //

    ParTerminate(Pdx);

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (afpForward[fm].fnIsModeSupported)
            afpForward[fm].fnIsModeSupported(Pdx);
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (arpReverse[rm].fnIsModeSupported)
            arpReverse[rm].fnIsModeSupported(Pdx);
    }

    return;
}

NTSTATUS
IeeeNegotiateBestMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    )
/*++

Routine Description:

    This routine walks the list of supported modes, looking for the best
    (fastest) mode.  It will skip any mode(s) mask passed in.

Arguments:

    Pdx - The parallel device extension

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    //
    // A USHORT is provided in the extension so that each of the protocols
    // can decide whether they need to negotiate each time we go through this
    // process...
    //

    //
    // Unlikely that we would be connected, but...
    //

    DD((PCE)Pdx,DDT,"IeeeNegotiateBestMode - skipping Fwd=%x, Rev=%x\n",usWriteMask, usReadMask);

    ParTerminate(Pdx);

    Pdx->IdxForwardProtocol = FORWARD_NONE;
    Pdx->IdxReverseProtocol = REVERSE_NONE;

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (!(afpForward[fm].Protocol & usWriteMask)) {

            if (afpForward[fm].fnIsModeSupported) {

                if (afpForward[fm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxForwardProtocol = (USHORT)fm;
                    break;
                }
            }
        }
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (!(arpReverse[rm].Protocol & usReadMask)) {

            if (arpReverse[rm].fnIsModeSupported) {

                if (arpReverse[rm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxReverseProtocol = (USHORT)rm;
                    break;
                }
            }
        }
    }

    Pdx->fnRead  = arpReverse[Pdx->IdxReverseProtocol].fnRead;
    Pdx->fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;

    DD((PCE)Pdx,DDT,"IeeeNegotiateBestMode - exit - Fwd=%x, Rev=%x\n",fm,rm);

    return STATUS_SUCCESS;
}


NTSTATUS
IeeeNegotiateMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    )

/*++

Routine Description:

    This routine walks the list of supported modes, looking for the best
    (fastest) mode which is also in the mode mask passed in.

Arguments:

    Pdx - The parallel device extension

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{

    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    //
    // A USHORT is provided in the extension so that each of the protocols
    // can decide whether they need to negotiate each time we go through this
    // process...
    //

    //
    // Unlikely that we would be connected, but...
    //

    ParTerminate(Pdx);

    Pdx->IdxForwardProtocol = FORWARD_NONE;
    Pdx->IdxReverseProtocol = REVERSE_NONE;

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (afpForward[fm].Protocol & usWriteMask) {

            if (afpForward[fm].fnIsModeSupported) {

                if (afpForward[fm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxForwardProtocol = (USHORT)fm;
                    break;
                }

            } else {

                Pdx->IdxForwardProtocol = (USHORT)fm;
                break;
            }
        }
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (arpReverse[rm].Protocol & usReadMask) {

            if (arpReverse[rm].fnIsModeSupported) {

                if (arpReverse[rm].fnIsModeSupported(Pdx)) {
                    Pdx->IdxReverseProtocol = (USHORT)rm;
                    break;
                }

            } else {

                Pdx->IdxReverseProtocol = (USHORT)rm;
                break;
            }
        }
    }

    DD((PCE)Pdx,DDT,"IeeeNegotiateMode - Fwd=%x, Rev=%x\n",fm,rm);

    Pdx->fnRead  = arpReverse[Pdx->IdxReverseProtocol].fnRead;
    Pdx->fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\hwepp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epp.c

Abstract:

    This module contains the code to perform all Hardware EPP related tasks.

Author:

    Don Redford - July 30, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


BOOLEAN
ParIsEppHwSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not HW EPP mode is suported
    for either direction by negotiating when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Entering\n");

    // Check to see if the hardware is capable
    if (!(Pdx->HardwareCapabilities & PPT_EPP_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Hardware Not Supported Leaving\n");
        return FALSE;
    }

    if (Pdx->BadProtocolModes & EPP_HW) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Bad Protocol Not Supported Leaving\n");
        return FALSE;
    }
        
    if (Pdx->ProtocolModesSupported & EPP_HW) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Already Checked Supported Leaving\n");
        return TRUE;
    }

    // Must use HWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppHwMode (Pdx, FALSE);
    ParTerminateEppHwMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Negotiated Supported Leaving\n");
        Pdx->ProtocolModesSupported |= EPP_HW;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsEppHwWriteSupported: Not Negotiated Not Supported Leaving\n");
    return FALSE;    
}

NTSTATUS
ParEnterEppHwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    EPP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Entering\n");

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Calling IeeeEnter1284Mode with DEVICE_ID_REQUEST\n");
            Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Calling IeeeEnter1284Mode\n");
            Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY);
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterEppHwMode: In UNSAFE_MODE.\n");
        Pdx->Connected = TRUE;
    }
    
    if (NT_SUCCESS(Status)) {
        Status = Pdx->TrySetChipMode ( Pdx->PortContext, ECR_EPP_PIO_MODE );
        
        if (NT_SUCCESS(Status)) {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: IeeeEnter1284Mode returned success\n");
            P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
            Pdx->IsIeeeTerminateOk = TRUE;
        } else {
            DD((PCE)Pdx,DDT,"ParEnterEppHwMode: TrySetChipMode returned unsuccessful\n");
            ParTerminateEppHwMode ( Pdx );
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            Pdx->IsIeeeTerminateOk = FALSE;
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterEppHwMode: IeeeEnter1284Mode returned unsuccessful\n");
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }
    
    DD((PCE)Pdx,DDT,"ParEnterEppHwMode: Leaving with Status : %x \n", Status);

    return Status; 
}    

VOID
ParTerminateEppHwMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Pdx  - The Device Extension which has the parallel port's controller address.

Return Value:

    None.

--*/

{
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Entering\n");
    Pdx->ClearChipMode( Pdx->PortContext, ECR_EPP_PIO_MODE );
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode ( Pdx );
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateEppMode: In UNSAFE_MODE.\n");
        Pdx->Connected = FALSE;
    }
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Leaving\n");
    return;    
}

NTSTATUS
ParEppHwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the EPP using Hardware flow control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          wPortEPP;
    PUCHAR          pBuffer;
    ULONG           ulongSize = 0;  // represents how many ULONG's we are transfering if enabled
    
    DD((PCE)Pdx,DDT,"ParEppHwWrite: Entering\n");

    wPortEPP    = Pdx->Controller + EPP_OFFSET;
    pBuffer     = Buffer;

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    
    // Check to see if hardware supports 32 bit reads and writes
    if ( Pdx->HardwareCapabilities & PPT_EPP_32_PRESENT ) {
        if ( !(BufferSize % 4) )
            ulongSize = BufferSize >> 2;
    }

    // ulongSize != 0 so EPP 32 bit is enabled and Buffersize / 4
    if ( ulongSize ) {
        WRITE_PORT_BUFFER_ULONG( (PULONG)wPortEPP,
                                 (PULONG)pBuffer,
                                 ulongSize );
    } else {
        P5WritePortBufferUchar( wPortEPP,
                                 (PUCHAR)pBuffer,
                                 BufferSize );
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    *BytesTransferred = BufferSize;

    DD((PCE)Pdx,DDT,"ParEppHwWrite: Leaving with %i Bytes Transferred\n", BufferSize);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ParEppHwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 EPP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          wPortEPP;
    PUCHAR          pBuffer;
    ULONG           ulongSize = 0;  // represents how many ULONG's we are transfering if enabled
    
    DD((PCE)Pdx,DDT,"ParEppHwRead: Entering\n");

    wPortEPP    = Pdx->Controller + EPP_OFFSET;
    pBuffer     = Buffer;
    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    // Check to see if hardware supports 32 bit reads and writes
    if ( Pdx->HardwareCapabilities & PPT_EPP_32_PRESENT ) {
        if ( !(BufferSize % 4) )
            ulongSize = BufferSize >> 2;
    }

    // ulongSize != 0 so EPP 32 bit is enabled and Buffersize / 4
    if ( ulongSize ) {
        READ_PORT_BUFFER_ULONG( (PULONG)wPortEPP,
                                (PULONG)pBuffer,
                                ulongSize );
    } else {
        P5ReadPortBufferUchar( wPortEPP,
                                (PUCHAR)pBuffer,
                                BufferSize );
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    *BytesTransferred = BufferSize;

    DD((PCE)Pdx,DDT,"ParEppHwRead: Leaving with %i Bytes Transferred\n", BufferSize);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\fdowmi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmi.c
//
//--------------------------------------------------------------------------

#include "pch.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEPARWMI0, PptWmiInitWmi)
#pragma alloc_text(PAGEPARWMI0, PptWmiQueryWmiRegInfo)
#pragma alloc_text(PAGEPARWMI0, PptWmiQueryWmiDataBlock)
#endif


//
// Number of WMI GUIDs that we support
//
#define PPT_WMI_PDO_GUID_COUNT               1

//
// Index of GUID PptWmiAllocFreeCountsGuid in the array of supported WMI GUIDs
//
#define PPT_WMI_ALLOC_FREE_COUNTS_GUID_INDEX 0

//
// defined in wmidata.h:
//
// // {4BBB69EA-6853-11d2-8ECE-00C04F8EF481}
// #define PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID {0x4bbb69ea, 0x6853, 0x11d2, 0x8e, 0xce, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x81}
//
// typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS {
// 	ULONG PortAllocates;	// number of Port Allocate requests granted
// 	ULONG PortFrees;	// number of Port Free requests granted
// } PARPORT_WMI_ALLOC_FREE_COUNTS, *PPARPORT_WMI_ALLOC_FREE_COUNTS;
//


//
// Define the (only at the moment) WMI GUID that we support
//
GUID PptWmiAllocFreeCountsGuid = PARPORT_WMI_ALLOCATE_FREE_COUNTS_GUID;


//
// Array of WMI GUIDs supported by driver
//
WMIGUIDREGINFO PptWmiGuidList[ PPT_WMI_PDO_GUID_COUNT ] =
{
    { &PptWmiAllocFreeCountsGuid, 1, 0 }
};


//
// Initialize WMI Context that we pass to WMILIB during the handling of
//   IRP_MJ_SYSTEM_CONTROL. This context lives in our device extension
//
// Register w/WMI that we are able to process WMI IRPs
//
NTSTATUS
PptWmiInitWmi(PDEVICE_OBJECT DeviceObject)
{
    PFDO_EXTENSION devExt     = DeviceObject->DeviceExtension;
    PWMILIB_CONTEXT   wmiContext = &devExt->WmiLibContext;

    PAGED_CODE();

    wmiContext->GuidCount = sizeof(PptWmiGuidList) / sizeof(WMIGUIDREGINFO);
    wmiContext->GuidList  = PptWmiGuidList;

    wmiContext->QueryWmiRegInfo    = PptWmiQueryWmiRegInfo;   // required
    wmiContext->QueryWmiDataBlock  = PptWmiQueryWmiDataBlock; // required
    wmiContext->SetWmiDataBlock    = NULL; // optional
    wmiContext->SetWmiDataItem     = NULL; // optional
    wmiContext->ExecuteWmiMethod   = NULL; // optional
    wmiContext->WmiFunctionControl = NULL; // optional

    // Tell WMI that we can now accept WMI IRPs
    return IoWMIRegistrationControl( DeviceObject, WMIREG_ACTION_REGISTER );
}

NTSTATUS
//
// This is the dispatch routine for IRP_MJ_SYSTEM_CONTROL IRPs. 
//
// We call WMILIB to process the IRP for us. WMILIB returns a disposition
//   that tells us what to do with the IRP.
//
PptFdoSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PFDO_EXTENSION pDevExt = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl( &pDevExt->WmiLibContext, DeviceObject, Irp, &disposition);
    switch(disposition) {
    case IrpProcessed:

        //
        // This irp has been processed and may be completed or pending.
        //
        break;
        
    case IrpNotCompleted:
    
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
        break;
    
    case IrpForward:
    case IrpNotWmi:
    
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(pDevExt->ParentDeviceObject, Irp);
        break;
                                    
    default:

        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(pDevExt->ParentDeviceObject, Irp);
        break;
    }
    
    return status;

}

//
// This is our callback routine that WMI calls when it wants to find out
//   information about the data blocks and/or events that the device provides.
//
NTSTATUS
PptWmiQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
)
{
    PFDO_EXTENSION devExt = PDevObj->DeviceExtension;

    UNREFERENCED_PARAMETER( PInstanceName );
    UNREFERENCED_PARAMETER( MofResourceName );

    PAGED_CODE();

    DD((PCE)devExt,DDT,"wmi::PptWmiQueryWmiRegInfo\n");
    
    *PRegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *PRegistryPath = &RegistryPath;
    *Pdo           = devExt->PhysicalDeviceObject;
    
    return STATUS_SUCCESS;
}

//
// This is our callback routine that WMI calls to query a data block
//
NTSTATUS
PptWmiQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
{
    NTSTATUS          status;
    ULONG             size   = sizeof(PARPORT_WMI_ALLOC_FREE_COUNTS);
    PFDO_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Only ever registers 1 instance per guid
    //
#if DBG
    ASSERT(InstanceIndex == 0 && InstanceCount == 1);
#else
    UNREFERENCED_PARAMETER( InstanceCount );
    UNREFERENCED_PARAMETER( InstanceIndex );
#endif
    
    switch (GuidIndex) {
    case PPT_WMI_ALLOC_FREE_COUNTS_GUID_INDEX:

        //
        // Request is for ParPort Alloc and Free Counts
        //
        // If caller's buffer is large enough then return the info, otherwise
        //   tell the caller how large of a buffer is required so they can
        //   call us again with a buffer of sufficient size.
        //
        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        *( (PPARPORT_WMI_ALLOC_FREE_COUNTS)Buffer ) = devExt->WmiPortAllocFreeCounts;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        break;

    default:

        //
        // Index value larger than our largest supported - invalid request
        //
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, size, IO_NO_INCREMENT );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\funcdecl.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    parport.sys

File Name:

    funcdecl.h

Abstract:

    This file contains the parport function declarations for functions
    that are called from a translation unit other than the one in
    which the function is defined.

--*/

NTSTATUS
P5FdoCreateThread(
    PFDO_EXTENSION Fdx
    );

NTSTATUS
PptAcquirePortViaIoctl(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

VOID
P5SetPhase( PPDO_EXTENSION Pdx, P1284_PHASE Phase );

VOID
P5BSetPhase( PIEEE_STATE IeeeState, P1284_PHASE Phase );

VOID
P5TraceIrpArrival( PDEVICE_OBJECT DevObj, PIRP Irp );

VOID
P5TraceIrpCompletion( PIRP Irp );

// irpQueue.c
VOID
P2InitIrpQueueContext(
    IN PIRPQUEUE_CONTEXT IrpQueueContext
    );

VOID
P2CancelQueuedIrp(
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PIRP               Irp
    );

NTSTATUS 
P2QueueIrp(
    IN  PIRP               Irp,
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PDRIVER_CANCEL     CancelRoutine
    );

PIRP
P2DequeueIrp(
    IN  PIRPQUEUE_CONTEXT IrpQueueContext,
    IN  PDRIVER_CANCEL    CancelRoutine
    );

VOID
P2CancelRoutine(
    IN  PDEVICE_OBJECT  DevObj,
    IN  PIRP            Irp
    );

// test.c


//
// ieee1284.c
//

VOID
IeeeTerminate1284Mode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
IeeeEnter1284Mode(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Extensibility
    );

VOID
IeeeDetermineSupportedProtocols(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
IeeeNegotiateBestMode(
    IN  PPDO_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    );

NTSTATUS
IeeeNegotiateMode(
    IN  PPDO_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    );

//
// port.c
//

VOID
ParReleasePortInfoToPortDevice(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParFreePort(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

BOOLEAN
ParAllocPort(
    IN  PPDO_EXTENSION   Extension
    );



NTSTATUS
PptWmiQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
);

NTSTATUS
PptWmiQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );


NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PPDO_EXTENSION   Extension
    );

VOID
ParReleasePortInfoToPortDevice(
    IN  PPDO_EXTENSION   Extension
    );
    
VOID
ParFreePort(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

BOOLEAN
ParAllocPort(
    IN  PPDO_EXTENSION   Extension
    );

VOID
TstReadDeviceId( PFDO_EXTENSION Ext );

NTSTATUS
P4IeeeEnter1284Mode(
    IN     PUCHAR          Controller,                    
    IN     UCHAR           Extensibility,
    IN OUT PIEEE_STATE     State
    );

VOID
P4IeeeTerminate1284Mode(
    IN PUCHAR           Controller,
    IN OUT PIEEE_STATE  IeeeState,
    IN enum XFlagOnEvent24 XFlagOnEvent24
    );

NTSTATUS
P4NibbleModeRead(
    IN      PUCHAR       Controller,
    IN      PVOID        Buffer,
    IN      ULONG        BufferSize,
    OUT     PULONG       BytesTransferred,
    IN OUT  PIEEE_STATE  IeeeState
    );

VOID
P4MakeClassNameFromPortLptName(
    IN     PWSTR            LptName,
    IN OUT PUNICODE_STRING  ParallelName
    );

VOID
ParMakeClassNameFromNumber(
    IN  ULONG           Number,
    OUT PUNICODE_STRING ClassName
    );

//

NTSTATUS
PptFdoUnhandledRequest( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS 
PptPdoUnhandledRequest( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchPnp( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchPower( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchCreate( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchClose( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchCleanup( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchRead( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchWrite( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptDispatchSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoPnp( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoPower( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoCreateOpen( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoClose( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoCleanup( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoRead( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoWrite( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptFdoSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoPnp( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoPower( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoCreate( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoClose( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoCleanup( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoRead( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoWrite( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptPdoSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp );

NTSTATUS
PptWmiInitWmi(PDEVICE_OBJECT DeviceObject); 

NTSTATUS
PptDispatchSystemControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

//
// pnp.c - dvdf
//
VOID
PptPnpInitDispatchFunctionTable(
    VOID
    );

NTSTATUS
P5AddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
PptDispatchPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

//
//
//

NTSTATUS
PptFailRequest(
    IN PIRP Irp, 
    IN NTSTATUS Status
    );

NTSTATUS
PptDispatchPreProcessIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
PptDispatchPostProcessIrp();


//
// initunld.c
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PptUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );


//
// parport.c
//

NTSTATUS
PptSystemControl (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
PptSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
PptLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
PptConnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDisconnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PptDispatchClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
PptSynchronizedIncrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedDecrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedRead(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedQueue(
    IN  PVOID   Context
    );

BOOLEAN
PptSynchronizedDisconnect(
    IN  PVOID   Context
    );

VOID
PptCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    );

VOID
PptFreePortDpc(
    IN      PKDPC   Dpc,
    IN OUT  PVOID   Extension,
    IN      PVOID   SystemArgument1,
    IN      PVOID   SystemArgument2
    );

BOOLEAN
PptTryAllocatePortAtInterruptLevel(
    IN  PVOID   Context
    );

VOID
PptFreePortFromInterruptLevel(
    IN  PVOID   Context
    );

BOOLEAN
PptInterruptService(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Extension
    );

BOOLEAN
PptTryAllocatePort(
    IN  PVOID   Extension
    );

BOOLEAN
PptTraversePortCheckList(
    IN  PVOID   Extension
    );

VOID
PptFreePort(
    IN  PVOID   Extension
    );

ULONG
PptQueryNumWaiters(
    IN  PVOID   Extension
    );

NTSTATUS
PptDispatchInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
PptCleanupDevice(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
PptIsNecR98Machine(
    void
    );

VOID
PowerStateCallback(
    IN  PVOID CallbackContext,
    IN  PVOID Argument1,
    IN  PVOID Argument2
    );

NTSTATUS
PptDispatchPower (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID
PptRegInitDriverSettings(
    PUNICODE_STRING   RegistryPath
    );

PWSTR
PptGetPortNameFromPhysicalDeviceObject(
  PDEVICE_OBJECT PhysicalDeviceObject
  );

PVOID
PptSetCancelRoutine(
    IN PIRP           Irp, 
    IN PDRIVER_CANCEL CancelRoutine
);

NTSTATUS
PptAcquireRemoveLockOrFailIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    PIRP              Irp
);

//
// debug.c
//

UCHAR
P5ReadPortUchar( PUCHAR Port );

VOID
P5ReadPortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count ); 

VOID
P5WritePortUchar( PUCHAR Port, UCHAR Value );

VOID
P5WritePortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count ); 

VOID
PptFdoDumpPnpIrpInfo(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

VOID
PptPdoDumpPnpIrpInfo(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    );

NTSTATUS
PptAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

VOID
PptDebugDumpResourceList(
    PIO_RESOURCE_LIST ResourceList
    );

VOID
PptDebugDumpResourceRequirementsList(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

//
//
//

VOID
PptLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

VOID
PptReportResourcesDevice(
    IN  PFDO_EXTENSION   Extension,
    IN  BOOLEAN             ClaimInterrupt,
    OUT PBOOLEAN            ConflictDetected
    );

VOID
PptUnReportResourcesDevice(
    IN OUT  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptConnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDisconnectInterrupt(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCreateClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

BOOLEAN
PptSynchronizedIncrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedDecrement(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedRead(
    IN OUT  PVOID   SyncContext
    );

BOOLEAN
PptSynchronizedQueue(
    IN  PVOID   Context
    );

BOOLEAN
PptSynchronizedDisconnect(
    IN  PVOID   Context
    );

VOID
PptCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    );

VOID
PptFreePortDpc(
    IN      PKDPC   Dpc,
    IN OUT  PVOID   Extension,
    IN      PVOID   SystemArgument1,
    IN      PVOID   SystemArgument2
    );

BOOLEAN
PptTryAllocatePortAtInterruptLevel(
    IN  PVOID   Context
    );

VOID
PptFreePortFromInterruptLevel(
    IN  PVOID   Context
    );

BOOLEAN
PptInterruptService(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Extension
    );

BOOLEAN
PptTryAllocatePort(
    IN  PVOID   Extension
    );

BOOLEAN
PptTraversePortCheckList(
    IN  PVOID   Extension
    );

VOID
PptFreePort(
    IN  PVOID   Extension
    );

ULONG
PptQueryNumWaiters(
    IN  PVOID   Extension
    );

NTSTATUS
PptDispatchDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
PptCleanupDevice(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDispatchCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
PptUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

BOOLEAN
PptIsNecR98Machine(
    void
    );

//
// parmode.c
//

NTSTATUS
PptDetectChipFilter(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDetectPortType(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptSetChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

NTSTATUS
PptClearChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

//
// par12843.c
//

ULONG
PptInitiate1284_3(
    IN  PVOID   Extension
    );

NTSTATUS
PptTrySelectDevice(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    );

NTSTATUS
PptDeselectDevice(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    );

ULONG
Ppt1284_3AssignAddress(
    IN  PFDO_EXTENSION    DeviceExtension
    );

BOOLEAN
PptSend1284_3Command(
    IN  PUCHAR  CurrentPort,
    IN  UCHAR   Command
    );

//
// Ppt RemoveLock function declarations
//
NTSTATUS
PptAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
PptReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

//
// power management function declarations
//
NTSTATUS
PptPowerDispatch (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );



//
// other function declarations
//

PWSTR
PptGetPortNameFromPhysicalDeviceObject(
  PDEVICE_OBJECT PhysicalDeviceObject
  );

NTSTATUS
PptSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
PptTrySelectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    );

NTSTATUS
PptDeselectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    );

NTSTATUS
PptRegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

NTSTATUS
PptRegSetDeviceParameterDword(
    IN PDEVICE_OBJECT  Pdo,
    IN PWSTR           ParameterName,
    IN PULONG          ParameterValue
    );

NTSTATUS
PptBuildParallelPortDeviceName(
    IN  ULONG           Number,
    OUT PUNICODE_STRING DeviceName
    );

NTSTATUS
PptInitializeDeviceExtension(
    IN PDRIVER_OBJECT  pDriverObject,
    IN PDEVICE_OBJECT  pPhysicalDeviceObject,
    IN PDEVICE_OBJECT  pDeviceObject,
    IN PUNICODE_STRING uniNameString,
    IN PWSTR           portName,
    IN ULONG           portNumber
    );

NTSTATUS
PptGetPortNumberFromLptName( 
    IN  PWSTR  PortName, 
    OUT PULONG PortNumber 
    );

PDEVICE_OBJECT
PptBuildFdo( 
    IN PDRIVER_OBJECT pDriverObject, 
    IN PDEVICE_OBJECT pPhysicalDeviceObject 
    );

VOID
PptDetectEppPort(
    IN  PFDO_EXTENSION   Extension
    );

// orig pnp.h follows

NTSTATUS
PptPnpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS
PptPnpCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpStopDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpUnhandledIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpStartDevice(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
PptPnpStartValidateResources(
    IN PDEVICE_OBJECT DeviceObject,                              
    IN BOOLEAN        FoundPort,
    IN BOOLEAN        FoundIrq,
    IN BOOLEAN        FoundDma
    );

NTSTATUS
PptPnpStartScanCmResourceList(
    IN  PFDO_EXTENSION Extension,
    IN  PIRP              Irp, 
    OUT PBOOLEAN          FoundPort,
    OUT PBOOLEAN          FoundIrq,
    OUT PBOOLEAN          FoundDma
    );

NTSTATUS
PptPnpPassThroughPnpIrpAndReleaseRemoveLock(
    IN PFDO_EXTENSION Extension,
    IN PIRP              Irp
    );

NTSTATUS
PptPnpRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
PptPnpFilterNukeIrqResourceDescriptors(
    IN OUT PIO_RESOURCE_LIST IoResourceList
    );

VOID
PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

BOOLEAN
PptPnpFilterExistsNonIrqResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

PVOID
PptPnpFilterGetEndOfResourceRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

BOOLEAN
PptPnpListContainsIrqResourceDescriptor(
    IN PIO_RESOURCE_LIST List
    );

VOID
PptPnpFilterRemoveIrqResourceLists(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    );

NTSTATUS
PptPnpBounceAndCatchPnpIrp(
    IN PFDO_EXTENSION Extension,
    IN PIRP              Irp
    );

PWSTR
P4MakePdoSymLinkName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber
    );

PWSTR
P4MakePdoDeviceName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber   // used if we had a name collision on IoCreateDevice
    );

PDEVICE_OBJECT
P4CreatePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN enum _PdoType   PdoType,
    IN UCHAR           DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN PCHAR           Ieee1284Id    // NULL if device does not report IEEE 1284 Device ID
    );

VOID
P4DestroyPdo(
    IN PDEVICE_OBJECT  Pdo
    );             

NTSTATUS
PptFindNatChip(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptBuildResourceList(
    IN  PFDO_EXTENSION   Extension,
    IN  ULONG               Partial,
    IN  PUCHAR             *Addresses,
    OUT PCM_RESOURCE_LIST   Resources
    );

// parmode.h

NTSTATUS
PptDetectChipFilter(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptDetectPortType(
    IN  PFDO_EXTENSION   Extension
    );
    
NTSTATUS
PptDetectPortCapabilities(
    IN  PFDO_EXTENSION   Extension
    );
    
VOID
PptDetectEcpPort(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDetectEppPortIfDot3DevicePresent(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDetectEppPortIfUserRequested(
    IN  PFDO_EXTENSION   Extension
    );

VOID
PptDetectBytePort(
    IN  PFDO_EXTENSION   Extension
    );

VOID 
PptDetermineFifoDepth(
    IN PFDO_EXTENSION   Extension
    );

VOID
PptDetermineFifoWidth(
    IN PFDO_EXTENSION   Extension
    );

NTSTATUS
PptSetChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

NTSTATUS
PptClearChipMode (
    IN  PFDO_EXTENSION  Extension,
    IN  UCHAR              ChipMode
    );

NTSTATUS
PptEcrSetMode(
    IN  PFDO_EXTENSION   Extension,
    IN  UCHAR               ChipMode
    );

NTSTATUS
PptCheckBidiMode(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptEcrClearMode(
    IN  PFDO_EXTENSION   Extension
    );
    
NTSTATUS
PptSetByteMode( 
    IN  PFDO_EXTENSION   Extension,
    IN  UCHAR               ChipMode
    );

NTSTATUS
PptClearByteMode( 
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
PptCheckByteMode(
    IN  PFDO_EXTENSION   Extension
    );

NTSTATUS
P4CompleteRequest(
    IN PIRP       Irp,
    IN NTSTATUS   Status,
    IN ULONG_PTR  Information 
    );

NTSTATUS
P4CompleteRequestReleaseRemLock(
    IN PIRP             Irp,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information,
    IN PIO_REMOVE_LOCK  RemLock
    );

VOID
P4SanitizeId(
    IN OUT PWSTR DeviceId
    );

VOID
P4AcquireBus( IN PDEVICE_OBJECT Fdo ); // this call will block until bus can be acquired

VOID
P4ReleaseBus( PDEVICE_OBJECT Fdo );

PCHAR
P4ReadRawIeee1284DeviceId(
    IN  PUCHAR          Controller
    );

VOID
P4WritePortNameToDevNode( PDEVICE_OBJECT Pdo, PCHAR Location );

NTSTATUS
PptPdoCreateOpen(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    );


NTSTATUS PptFdoHandleBusRelations( IN PDEVICE_OBJECT Fdo, IN PIRP Irp );
NTSTATUS PptPnpStartScanPciCardCmResourceList( PFDO_EXTENSION Extension, PIRP Irp, PBOOLEAN FoundPort, PBOOLEAN FoundIrq, PBOOLEAN FoundDma );
BOOLEAN PptIsPci( PFDO_EXTENSION Extension, PIRP Irp );
NTSTATUS PptPnpStartScanCmResourceList( PFDO_EXTENSION Extension, PIRP Irp, PBOOLEAN FoundPort, PBOOLEAN FoundIrq, PBOOLEAN FoundDma );
NTSTATUS PptPnpStartValidateResources( PDEVICE_OBJECT DeviceObject, IN BOOLEAN FoundPort, IN BOOLEAN FoundIrq, IN BOOLEAN FoundDma );
BOOLEAN PptPnpFilterExistsNonIrqResourceList( IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
VOID PptPnpFilterRemoveIrqResourceLists( PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
PVOID PptPnpFilterGetEndOfResourceRequirementsList( IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
VOID PptPnpFilterNukeIrqResourceDescriptorsFromAllLists( PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList );
VOID PptPnpFilterNukeIrqResourceDescriptors( PIO_RESOURCE_LIST IoResourceList );
BOOLEAN PptPnpListContainsIrqResourceDescriptor( IN PIO_RESOURCE_LIST List );
NTSTATUS PptPnpBounceAndCatchPnpIrp( PFDO_EXTENSION Extension, PIRP Irp );
NTSTATUS PptPnpPassThroughPnpIrpAndReleaseRemoveLock( IN PFDO_EXTENSION Extension, IN PIRP Irp );


VOID PptPdoGetPortInfoFromFdo( PDEVICE_OBJECT Pdo );


NTSTATUS
ParForwardToReverse(
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN 
ParHaveReadData(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS 
ParPing(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParReverseToForward(
    IN  PPDO_EXTENSION   Extension
    );


NTSTATUS
ParRead(
    IN PPDO_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead
    );

VOID
ParReadIrp(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParSetFwdAddress(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParTerminate(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParWrite(
    IN PPDO_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten
    );

VOID
ParWriteIrp(
    IN  PPDO_EXTENSION   Extension
    );


NTSTATUS
ParWmiPdoQueryWmiDataBlock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  ULONG           GuidIndex,
    IN  ULONG           InstanceIndex,
    IN  ULONG           InstanceCount,
    IN  OUT PULONG      InstanceLengthArray,
    IN  ULONG           OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
ParWmiPdoQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
);


NTSTATUS
ParEcpEnterReversePhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpExitReversePhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpSetupPhase(
    IN  PPDO_EXTENSION   Extension
    );


VOID
ParCleanupHwEcpPort(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwEmptyFIFO(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwHostRecoveryPhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwRecoverPort(
    IN PPDO_EXTENSION Extension,
    UCHAR  bRecoverCode
    );

NTSTATUS
ParEcpHwWaitForEmptyFIFO(
    IN PPDO_EXTENSION   Extension
    );

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pcfuncdecl.h
//
//--------------------------------------------------------------------------

//
// Function declarations for the ParClass (parallel.sys) driver
//

VOID
ParDumpDevExtTable();

NTSTATUS 
ParWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN ULONG          Action
    );

BOOLEAN
ParIsPodo(
    IN PDEVICE_OBJECT DevObj
    );

NTSTATUS
ParWmiPdoInitWmi(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ParWmiPdoSystemControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject, 
    IN  PIRP            Irp
    );

PCHAR
Par3QueryDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString, // TRUE == include the 2 size bytes in the returned string
    IN BOOLEAN              bBuildStlDeviceId
    );


PDEVICE_OBJECT
ParDetectCreatePdo(PDEVICE_OBJECT legacyPodo, UCHAR Dot3Id, BOOLEAN bStlDot3Id);

NTSTATUS
ParBuildSendInternalIoctl(
    IN  ULONG           IoControlCode,
    IN  PDEVICE_OBJECT  TargetDeviceObject,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  ULONG           InputBufferLength,
    OUT PVOID           OutputBuffer        OPTIONAL,
    IN  ULONG           OutputBufferLength,
    IN  PLARGE_INTEGER  Timeout             OPTIONAL
    );


//
// initunld.c - driver initialization and unload
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
ParPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParPdoPower(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           pIrp
   );

NTSTATUS
ParFdoPower(
    IN PPDO_EXTENSION Extension,
    IN PIRP           pIrp
   );

// parclass.c ?

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

UCHAR
ParInitializeDevice(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParNotInitError(
    IN PPDO_EXTENSION    Extension,
    IN UCHAR                DeviceStatus
    );

VOID
PptPdoStartIo(
    IN  PPDO_EXTENSION   Extension
    );

VOID
PptPdoThread(
    IN PVOID    Context
    );

NTSTATUS
ParCreateSystemThread(
    PPDO_EXTENSION   Extension
    );

VOID
ParCancelRequest(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

// exports.c

USHORT
ParExportedDetermineIeeeModes(
    IN PPDO_EXTENSION    Extension
    );

NTSTATUS
ParExportedIeeeFwdToRevMode(
    IN PPDO_EXTENSION  Extension
    );

NTSTATUS
ParExportedIeeeRevToFwdMode(
    IN PPDO_EXTENSION  Extension
    );

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PPDO_EXTENSION  Extension,
	IN USHORT             ModeMaskFwd,
	IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
	IN BOOLEAN            IsForward
    );

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PPDO_EXTENSION   Extension
    );

NTSTATUS
ParExportedParallelRead(
    IN PPDO_EXTENSION    Extension,
    IN  PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead,
    IN  UCHAR               Channel
    );

NTSTATUS
ParExportedParallelWrite(
    IN PPDO_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten,
    IN  UCHAR               Channel
    );
    
NTSTATUS
ParTerminateParclassMode(
    IN PPDO_EXTENSION   Extension
    );

VOID
ParWriteIo(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParReadIo(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParDeviceIo(
    IN  PPDO_EXTENSION   Extension
    );


// pnp?

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
ParParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParPdoParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParFdoParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

PDEVICE_OBJECT
ParPnpCreateDevice(
    IN PDRIVER_OBJECT pDriverObject
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParCheckParameters(
    IN OUT  PPDO_EXTENSION   Extension
    );

VOID
ParPnpFindDeviceIdKeys(
    OUT PCHAR   *lppMFG,
    OUT PCHAR   *lppMDL,
    OUT PCHAR   *lppCLS,
    OUT PCHAR   *lppDES,
    OUT PCHAR   *lppAID,
    OUT PCHAR   *lppCID,
    IN  PCHAR   lpDeviceID
    );

VOID
ParDot3ParseDevId(
    PCHAR   *lpp_DL,
    PCHAR   *lpp_C,
    PCHAR   *lpp_CMD,
    PCHAR   *lpp_4DL,
    PCHAR   *lpp_M,
    PCHAR   lpDeviceID
);

VOID
GetCheckSum(
    IN  PCHAR  Block,
    IN  USHORT  Len,
    OUT PUSHORT CheckSum
    );

BOOLEAN
String2Num(
    IN OUT PCHAR   *lpp_Str,
    IN CHAR         c,
    OUT ULONG       *num
    );

UCHAR
StringCountValues(
    IN PCHAR string, 
    IN CHAR  delimeter
    );

PCHAR
StringChr(
    IN  PCHAR string,
    IN  CHAR c
    );

ULONG
StringLen(
    IN  PUCHAR string
    );

VOID
StringSubst(
    IN OUT  PCHAR lpS,
    IN      CHAR chTargetChar,
    IN      CHAR chReplacementChar,
    IN      USHORT cbS
    );

BOOLEAN
ParSelectDevice(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             HavePort
    );

BOOLEAN
ParDeselectDevice(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             KeepPort
    );

NTSTATUS
ParAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
ParReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
ParReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

NTSTATUS
ParPnpInterfaceChangeNotify(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PVOID                                 pContext
    );

VOID
ParMakeClassNameFromNumber(
    IN  ULONG           Number,
    OUT PUNICODE_STRING ClassName
    );

VOID
ParMakeDotClassNameFromBaseClassName(
    IN  PUNICODE_STRING BaseClassName,
    IN  ULONG           Number,
    OUT PUNICODE_STRING DotClassName
    );

VOID
ParInitCommonDOPre(PDEVICE_OBJECT DevObj, PDEVICE_OBJECT Fdo, PUNICODE_STRING ClassName);

VOID
ParInitCommonDOPost(PDEVICE_OBJECT DevObj);

NTSTATUS
ParInitPdo(
    IN PDEVICE_OBJECT NewPdo, 
    IN PUCHAR         DeviceIdString,
    IN ULONG          DeviceIdLength,
    IN PDEVICE_OBJECT LegacyPodo,
    IN UCHAR          Dot3Id
    );

NTSTATUS
ParInitLegacyPodo(PDEVICE_OBJECT LegacyPodo, PUNICODE_STRING PortSymbolicLinkName);

VOID
ParAddDevObjToFdoList(PDEVICE_OBJECT DevObj);

PDEVICE_OBJECT
ParCreateLegacyPodo(PDEVICE_OBJECT Fdo, PUNICODE_STRING PortSymbolicLinkName);

VOID
ParAcquireListMutexAndKillDeviceObject(PDEVICE_OBJECT Fdo, PDEVICE_OBJECT DevObj);

VOID
ParKillDeviceObject(
    PDEVICE_OBJECT DeviceObject
    );

PWSTR
ParCreateWideStringFromUnicodeString(
    PUNICODE_STRING UnicodeString
    );

PDEVICE_OBJECT
ParDetectCreateEndOfChainPdo(PDEVICE_OBJECT LegacyPodo);

VOID
ParEnumerate1284_3Devices(
    IN  PDEVICE_OBJECT  pFdoDeviceObject,
    IN  PDEVICE_OBJECT  pPortDeviceObject,
    IN  PDEVICE_OBJECT  EndOfChainDeviceObject
    );

NTSTATUS
ParPnpNotifyTargetDeviceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PDEVICE_OBJECT                        pFdoDeviceObject
    );
    
NTSTATUS
ParPnpNotifyInterfaceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION NotificationStruct,
    IN  PDEVICE_OBJECT                        Fdo
    );

NTSTATUS
ParPnpGetId(
    IN  PCHAR  DeviceIdString,
    IN  ULONG   Type,
    OUT PCHAR  resultString,
    OUT PCHAR  descriptionString
    );

NTSTATUS
ParPnpFdoQueryDeviceRelationsBusRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

// VOID ParAddPodoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
// VOID ParAddEndOfChainPdoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
// VOID ParAddDot3PdoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
// VOID ParAddLegacyZipPdoToDevObjStruct(IN PPAR_DEVOBJ_STRUCT DevObjStructHead, IN PDEVICE_OBJECT CurrentDo);
// PPAR_DEVOBJ_STRUCT ParFindCreateDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PUCHAR Controller);
// VOID ParDumpDevObjStructList(PPAR_DEVOBJ_STRUCT DevObjStructHead);
// PPAR_DEVOBJ_STRUCT ParBuildDevObjStructList(PDEVICE_OBJECT Fdo);
// VOID ParDoParallelBusRescan(PPAR_DEVOBJ_STRUCT DevObjStructHead);

BOOLEAN
ParDeviceExists(
    PPDO_EXTENSION Extension,
    IN BOOLEAN        HavePortKeepPort
    );

NTSTATUS
ParAllocatePortDevice(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParAllocatePortDevice(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParAcquirePort(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
ParReleasePort(
    IN PDEVICE_OBJECT PortDeviceObject
    );

VOID
ParDetectDot3DataLink(
    IN  PPDO_EXTENSION   Extension,
    IN  PCHAR DeviceId
    );

VOID
ParMarkPdoHardwareGone(
    IN PPDO_EXTENSION Extension
    );

NTSTATUS
ParInit1284_3Bus(
    IN PDEVICE_OBJECT PortDeviceObject
    );

UCHAR
ParGet1284_3DeviceCount(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParSelect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    );

NTSTATUS
ParDeselect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    );

PCHAR
Par3QueryLegacyZipDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString // TRUE ==  include the 2 size bytes in the returned string
                                             // FALSE == discard the 2 size bytes
    );

PCHAR
ParStlQueryStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer,
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    ) ;

BOOLEAN
ParStlCheckIfStl(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

VOID
ParCheckEnableLegacyZipFlag();

BOOLEAN
P5LegacyZipDetected(
    IN  PUCHAR  Controller
    );

PWSTR
ParGetPortLptName(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParCreateDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           DeviceExtensionSize,
    IN  PUNICODE_STRING DeviceName OPTIONAL,
    IN  DEVICE_TYPE     DeviceType,
    IN  ULONG           DeviceCharacteristics,
    IN  BOOLEAN         Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

VOID
ParInitializeExtension1284Info(
    IN PPDO_EXTENSION Extension
    );

VOID
ParGetDriverParameterDword(
    IN     PUNICODE_STRING ServicePath,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

NTSTATUS
PptRegGetDword(
    IN     ULONG   RelativeTo,
    IN     PWSTR   Path,
    IN     PWSTR   ParameterName,
    IN OUT PULONG  ParameterValue
    );

NTSTATUS
PptRegSetDword(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PULONG ParameterValue
    );

NTSTATUS
PptRegGetSz(
    IN      ULONG  RelativeTo,               
    IN      PWSTR  Path,
    IN      PWSTR  ParameterName,
    IN OUT  PUNICODE_STRING ParameterValue
    );

NTSTATUS
PptRegSetSz(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PWSTR  ParameterValue
    );

VOID
ParFixupDeviceId(
    IN OUT PUCHAR DeviceId
    );

VOID
PptWriteMfgMdlToDevNode(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PCHAR           Mfg,
    IN  PCHAR           Mdl
    );

VOID
P4SanitizeMultiSzId( 
    IN OUT  PWSTR  WCharBuffer,
    IN      ULONG  BufWCharCount
    );

NTSTATUS
ParEnterByteMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateByteMode(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParByteModeRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\irpqueue.c ===
#include "pch.h"

VOID
P2InitIrpQueueContext(
    IN PIRPQUEUE_CONTEXT IrpQueueContext
    )
{
    InitializeListHead( &IrpQueueContext->irpQueue );
    KeInitializeSpinLock( &IrpQueueContext->irpQueueSpinLock );
}

VOID
P2CancelQueuedIrp(
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PIRP               Irp
    )
{
    KIRQL oldIrql;
    
    // Release the global cancel spin lock.  Do this while not holding
    //   any other spin locks so that we exit at the right IRQL.
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Dequeue and complete the IRP.  The enqueue and dequeue
    //    functions synchronize properly so that if this cancel routine
    //    is called, the dequeue is safe and only the cancel routine
    //    will complete the IRP. Hold the spin lock for the IRP queue
    //    while we do this.
    //
    KeAcquireSpinLock( &IrpQueueContext->irpQueueSpinLock, &oldIrql );
    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    KeReleaseSpinLock( &IrpQueueContext->irpQueueSpinLock, oldIrql);
    
    //  Complete the IRP.  This is a call outside the driver, so all
    //    spin locks must be released by this point.
    P4CompleteRequest( Irp, STATUS_CANCELLED, 0 );
    return;
}

NTSTATUS 
P2QueueIrp(
    IN  PIRP               Irp,
    IN  PIRPQUEUE_CONTEXT  IrpQueueContext,
    IN  PDRIVER_CANCEL     CancelRoutine
    )
{
    PDRIVER_CANCEL  oldCancelRoutine;
    KIRQL           oldIrql;
    NTSTATUS        status = STATUS_PENDING;
    
    KeAcquireSpinLock( &IrpQueueContext->irpQueueSpinLock, &oldIrql );
    
    // Queue the IRP and call IoMarkIrpPending to indicate that the
    //   IRP may complete on a different thread.
    //
    // N.B. It's okay to call these inside the spin lock because
    //   they're macros, not functions.
    IoMarkIrpPending( Irp );
    InsertTailList( &IrpQueueContext->irpQueue, &Irp->Tail.Overlay.ListEntry );
    
    // Must set a Cancel routine before checking the Cancel flag.
    #pragma warning( push ) 
    #pragma warning( disable : 4054 4055 )
    oldCancelRoutine = IoSetCancelRoutine( Irp, CancelRoutine );
    #pragma warning( pop ) 
    ASSERT( !oldCancelRoutine );

    if( Irp->Cancel ){
        // The IRP was canceled.  Check whether our cancel routine was called.
        #pragma warning( push ) 
        #pragma warning( disable : 4054 4055 )
        oldCancelRoutine = IoSetCancelRoutine( Irp, NULL );
        #pragma warning( pop ) 

        if( oldCancelRoutine ) {
            // The cancel routine was NOT called.  
            //   So dequeue the IRP now and complete it after releasing the spinlock.
            RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
            status = Irp->IoStatus.Status = STATUS_CANCELLED; 
        }
        else {
            // The cancel routine WAS called.  As soon as we drop our
            //   spin lock it will dequeue and complete the IRP.  So
            //   leave the IRP in the queue and otherwise don't touch
            //   it.  Return pending since we're not completing the IRP
            //   here.
        }
    }
    
    KeReleaseSpinLock(&IrpQueueContext->irpQueueSpinLock, oldIrql);
    
    // Normally you shouldn't call IoMarkIrpPending and return a
    //   status other than STATUS_PENDING.  But you can break this rule
    //   if you complete the IRP.
    if( status != STATUS_PENDING ) {
        P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
    }
    return status;
}

PIRP
P2DequeueIrp(
    IN  PIRPQUEUE_CONTEXT IrpQueueContext,
    IN  PDRIVER_CANCEL    CancelRoutine
    )
{
    KIRQL oldIrql;
    PIRP  nextIrp = NULL;

    KeAcquireSpinLock( &IrpQueueContext->irpQueueSpinLock, &oldIrql );

    while( !nextIrp && !IsListEmpty( &IrpQueueContext->irpQueue ) ){

        PDRIVER_CANCEL oldCancelRoutine;

        PLIST_ENTRY listEntry = RemoveHeadList( &IrpQueueContext ->irpQueue );
        
        // Get the next IRP off the queue.
        nextIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        
        //  Clear the IRP's cancel routine
        #pragma warning( push ) 
        #pragma warning( disable : 4054 4055 )
        oldCancelRoutine = IoSetCancelRoutine( nextIrp, NULL );
        #pragma warning( pop )

        //  IoCancelIrp() could have just been called on this IRP.
        //    What we're interested in is not whether IoCancelIrp() was called (nextIrp->Cancel flag set),
        //    but whether IoCancelIrp() called (or is about to call) our cancel routine.
        //    To check that, check the result of the test-and-set macro IoSetCancelRoutine.
        if( oldCancelRoutine ) {
            //  Cancel routine not called for this IRP.  Return this IRP.
            #if DBG
            ASSERT( oldCancelRoutine == CancelRoutine );
            #else
            UNREFERENCED_PARAMETER( CancelRoutine );
            #endif
        } else {
            //  This IRP was just canceled and the cancel routine was (or will be) called.
            //  The cancel routine will complete this IRP as soon as we drop the spin lock,
            //  so don't do anything with the IRP.
            //  Also, the cancel routine will try to dequeue the IRP, 
            //  so make the IRP's listEntry point to itself.
            ASSERT( nextIrp->Cancel );
            InitializeListHead( &nextIrp->Tail.Overlay.ListEntry );
            nextIrp = NULL;
        }
    }
    
    KeReleaseSpinLock( &IrpQueueContext ->irpQueueSpinLock, oldIrql );
    
    return nextIrp;
}

VOID
P2CancelRoutine(
    IN  PDEVICE_OBJECT  DevObj,
    IN  PIRP            Irp
    )
// this routine is driver specific - most other routines in this file are generic
{
    PFDO_EXTENSION     fdx             = DevObj->DeviceExtension;
    PIRPQUEUE_CONTEXT  irpQueueContext = &fdx->IrpQueueContext;
    P2CancelQueuedIrp( irpQueueContext, Irp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\natsemichipset.c ===
#include "pch.h"

// Register Definitions for National ChipSets
#define  REG_CR0                    0x00
#define  REG_CR1                    0x01
#define  REG_CR2                    0x02
#define  REG_CR3                    0x03
#define  REG_CR4                    0x04
#define  REG_CR5                    0x05
#define  REG_CR6                    0x06
#define  REG_CR7                    0x07
#define  REG_CR8                    0x08

// National Chip ID's
#define PC87303                     0x30
#define PC87306                     0x70
#define PC87307                     0xC0
#define PC87308                     0xA0
#define PC87323                     0x20
#define PC87332                     0x10
#define PC87334                     0x50
#define PC87336                     0x90
#define PC87338                     0xB0
#define PC873xx                     0x60

// Additional definitions for National PC87307 and PC87308
#define PC873_LOGICAL_DEV_REG       0x07
#define PC873_PP_LDN                0x04
#define PC873_DEVICE_ID             0x20
#define PC873_PP_MODE_REG           0xF0
#define PC873_ECP_MODE              0xF2
#define PC873_EPP_MODE              0x62
#define PC873_SPP_MODE              0x92
#define PC873_BASE_IO_ADD_MSB       0x60
#define PC873_BASE_IO_ADD_LSB       0x61


NTSTATUS
PptFindNatChip(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine finds out if there is a National Semiconductor IO chip on
    this machine.  If it finds a National chip it then determines if this 
    instance of Parport is using this chips paralle port IO address.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS       - if we were able to check for the parallel chip.
    STATUS_UNSUCCESSFUL  - if we were not able to check for the parallel chip.

Updates:
    
    Fdx->
            NationalChecked
            NationalChipFound

--*/

{
    BOOLEAN             found = FALSE;              // return code, assumed value
    BOOLEAN             OkToLook = FALSE;
    BOOLEAN             Conflict;
    PUCHAR              ChipAddr[4] = { (PUCHAR)0x398, (PUCHAR)0x26e, (PUCHAR)0x15c, (PUCHAR)0x2e };  // list of valid chip addresses
    PUCHAR              AddrList[4] = { (PUCHAR)0x378, (PUCHAR)0x3bc, (PUCHAR)0x278, (PUCHAR)0x00 };  // List of valid Parallel Port addresses
    PUCHAR              PortAddr;                   // Chip Port Address
    ULONG_PTR           Port;                       // Chip Port Read Value
    UCHAR               SaveIdx;                    // Save the index register value
    UCHAR               cr;                         // config register value
    UCHAR               ii;                         // loop index
    NTSTATUS            Status;                     // Status of success
    ULONG               ResourceDescriptorCount;
    ULONG               ResourcesSize;
    PCM_RESOURCE_LIST   Resources;
    ULONG               NationalChecked   = 0;
    ULONG               NationalChipFound = 0;

    
    //
    // Quick exit if we already know the answer
    //
    if ( Fdx->NationalChecked == TRUE ) {
        return STATUS_SUCCESS;
    }

    //
    // Mark extension so that we can quick exit the next time we are asked this question
    //
    Fdx->NationalChecked = TRUE; 

    //
    // Check the registry - we should only need to check this once per installation
    //
    PptRegGetDeviceParameterDword(Fdx->PhysicalDeviceObject, (PWSTR)L"NationalChecked", &NationalChecked);
    if( NationalChecked ) {
        //
        // We previously performed the NatSemi Check - extract result from registry
        //
        PptRegGetDeviceParameterDword(Fdx->PhysicalDeviceObject, (PWSTR)L"NationalChipFound", &NationalChipFound);
        if( NationalChipFound ) {
            Fdx->NationalChipFound = TRUE;
        } else {
            Fdx->NationalChipFound = FALSE;
        }
        return STATUS_SUCCESS;
    }

    //
    // This is our first, and hopefully last time that we need to make this check
    //   for this installation
    //

    //
    // Allocate a block of memory for constructing a resource descriptor
    //

    // number of partial descriptors 
    ResourceDescriptorCount = sizeof(ChipAddr)/sizeof(ULONG);

    // size of resource descriptor list + space for (n-1) more partial descriptors
    //   (resource descriptor list includes one partial descriptor)
    ResourcesSize =  sizeof(CM_RESOURCE_LIST) +
        (ResourceDescriptorCount - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

    Resources = (PCM_RESOURCE_LIST)ExAllocatePool(NonPagedPool, ResourcesSize);

    if (Resources == NULL) {
        // Error out
        return(STATUS_UNSUCCESSFUL);
    }

    // zero out memory block as a precaution
    RtlZeroMemory(Resources, ResourcesSize);

    //
    // Build the Resource List
    //
    Status = PptBuildResourceList( Fdx,
                                   sizeof(ChipAddr)/sizeof(ULONG),
                                   &ChipAddr[0],
                                   Resources
                                   );
    
    // Check to see if it was successful    
    if ( !NT_SUCCESS( Status ) ) {
        ExFreePool( Resources );
        return ( Status );
    }

    // 
    // check to see if we can use the io addresses where
    // national chipsets are located
    //
    Status = IoReportResourceUsage( NULL,
                                    Fdx->DriverObject,
                                    Resources,
                                    sizeof(Resources),
                                    Fdx->DeviceObject,
                                    NULL,
                                    0,
                                    FALSE,
                                    &Conflict
                                    ); 

    // done with resource list
    ExFreePool( Resources );

    // Check to see if IoReportResourceUsage was successful    
    if( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    // Check to see if it was successful    
    if ( Conflict ) {
        return STATUS_UNSUCCESSFUL;
    }


    // Was successful so now we check each of the addresses that we have
    // the resources for
    //
    // the following for loop is a state machine that checks modes and
    // port addresses.
    //
    // state 0: check for Pc873 at primary port address
    // state 1: check for Pc873 at secondary port address
    // state 2: check for Pc873 at Ter port address
    // state 3: check for Pc873 at Quad port address
    
    for ( ii = 0; !found && ii < 4; ii++ ) {

        PortAddr = (PUCHAR)ChipAddr[ii];

        // After power up the index register will read back an 0xAA one time only.
        // So we'll check for that first.
        // Then it should read back a 0 or a valid register number
            
        if(( P5ReadPortUchar( PortAddr ) == 0x88 )
           && ( P5ReadPortUchar( PortAddr ) < 0x20 )) {

            OkToLook = TRUE;

        } else {

            // Or it could read back a 0 or a valid register number
            P5ReadPortUchar( PortAddr );        // may read back 0 here
            cr = P5ReadPortUchar( PortAddr );   // valid register no.
  
            // is it really valid?
            // if( cr < 0x20 ) { - dvdr
            if( cr != 0xff ) {
                // does it read back the same?
                if( P5ReadPortUchar( PortAddr ) == cr)
                    OkToLook = TRUE;
            }

        } // end else
            
        // take a closer look by writing to the chip
        if ( OkToLook ) {

            OkToLook = FALSE;
                    
            // setup for ID reg
            P5WritePortUchar( PortAddr, REG_CR8 );
                            
            // read it back
            cr = P5ReadPortUchar( PortAddr );
                            
            // does it read back the same?
            if( cr  == REG_CR8 ) {

                // get the ID number.
                cr = (UCHAR)( P5ReadPortUchar( PortAddr + 1 ) & 0xf0 );
                                    
                // if the up. nib. is 1,3,5,6,7,9,A,B,C
                if( cr == PC87332 || cr == PC87334 || cr == PC87306 || cr == PC87303 || 
                   cr == PC87323 || cr == PC87336 || cr == PC87338 || cr == PC873xx ) {

                    // we found a national chip
                    found = TRUE;

                    // setup for Address reg
                    P5WritePortUchar( PortAddr, REG_CR1 );
                    
                    // read it back
                    Port = P5ReadPortUchar( PortAddr + 1 ) & 0x03;
                    
                    // Check the base address
                    if ( Fdx->PortInfo.Controller == (PUCHAR)AddrList[ Port ] ) {

                        //
                        // it is using the same address that Parport is using
                        // so we set the flag to not use generic ECP and EPP
                        //
                        Fdx->NationalChipFound = TRUE;

                    }
                            
                }

            } // reads back ok
                            
        } // end OkToLook

        // check to see if we found it
        if ( !found ) {

            // Check for the 307/308 chips
            SaveIdx = P5ReadPortUchar( PortAddr );

            // Setup for SID Register
            P5WritePortUchar( PortAddr, PC873_DEVICE_ID );
                    
            // Zero the ID register to start and because it is read only it will
            // let us know whether it is this chip
            P5WritePortUchar( PortAddr + 1, REG_CR0 );
                    
            // get the ID number.
            cr = (UCHAR)( P5ReadPortUchar( PortAddr + 1 ) & 0xf8 );
                    
            if ( (cr == PC87307) || (cr == PC87308) ) {

                // we found a new national chip
                found = TRUE;

                // Set the logical device
                P5WritePortUchar( PortAddr, PC873_LOGICAL_DEV_REG );
                P5WritePortUchar( PortAddr+1, PC873_PP_LDN );

                // set up for the base address MSB register
                P5WritePortUchar( PortAddr, PC873_BASE_IO_ADD_MSB );
                            
                // get the MSB of the base address
                Port = (ULONG_PTR)((P5ReadPortUchar( PortAddr + 1 ) << 8) & 0xff00);
                            
                // Set up for the base address LSB register
                P5WritePortUchar( PortAddr, PC873_BASE_IO_ADD_LSB );
                            
                // Get the LSBs of the base address
                Port |= P5ReadPortUchar( PortAddr + 1 );
                            
                // Check the base address
                if ( Fdx->PortInfo.Controller == (PUCHAR)Port ) {
                    //
                    // it is using the same address that Parport is using
                    // so we set the flag to not use generic ECP and EPP
                    //
                    Fdx->NationalChipFound = TRUE;
                }

            } else {

                P5WritePortUchar( PortAddr, SaveIdx );
            }
        }

    } // end of for ii...
    

    //
    // Check for NatSemi chip is complete - save results in registry so that we never
    //   have to make this check again for this port
    //
    {
        PDEVICE_OBJECT pdo = Fdx->PhysicalDeviceObject;
        NationalChecked    = 1;
        NationalChipFound  = Fdx->NationalChipFound ? 1 : 0;
        
        // we ignore status here because there is nothing we can do if the calls fail
        PptRegSetDeviceParameterDword(pdo, (PWSTR)L"NationalChecked",   &NationalChecked);
        PptRegSetDeviceParameterDword(pdo, (PWSTR)L"NationalChipFound", &NationalChipFound);
    }


    // 
    // release the io addresses where we checked for the national chipsets
    // we do this by calling IoReportResourceUsage with all NULL parameters
    //
    Status = IoReportResourceUsage( NULL,
                                    Fdx->DriverObject,
                                    NULL,
                                    0,
                                    Fdx->DeviceObject,
                                    NULL,
                                    0,
                                    FALSE,
                                    &Conflict
                                    ); 

    DD((PCE)Fdx,DDT,"ParMode::PptFindNatChip: return isFound [%x]\n",Fdx->NationalChipFound);
    return ( Status );
    
} // end of ParFindNat()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\legacyzip.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File: ppa3x.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
PptLegacyZipClockDiskModeByte(
    PUCHAR  Controller,
    UCHAR   ModeByte
    )
{
    P5WritePortUchar( Controller, ModeByte );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_SELECT_IN) );

} // end PptLegacyZipClockDiskModeByte()

VOID
PptLegacyZipClockPrtModeByte(
    PUCHAR  Controller,
    UCHAR   ModeByte
    )
{
    P5WritePortUchar( Controller, ModeByte );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT | DCR_AUTOFEED) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT) );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_SELECT_IN | DCR_NOT_INIT) );

} // end PptLegacyZipClockPrtModeByte()

VOID
PptLegacyZipSetDiskMode(
    PUCHAR  Controller,
    UCHAR   Mode
    )
{
    ULONG i;

    for ( i = 0; i < LEGACYZIP_MODE_LEN; i++ ) {
        PptLegacyZipClockDiskModeByte( Controller, LegacyZipModeQualifier[i] );
    }

    PptLegacyZipClockDiskModeByte( Controller, Mode );

} // end of PptLegacyZipSetDiskMode()

BOOLEAN
PptLegacyZipCheckDevice(
    PUCHAR  Controller
    )
{
    P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED) );

    if ( (P5ReadPortUchar( Controller+DSR_OFFSET ) & DSR_NOT_FAULT) == DSR_NOT_FAULT ) {

        P5WritePortUchar( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );

        if ( (P5ReadPortUchar( Controller+DSR_OFFSET ) & DSR_NOT_FAULT) != DSR_NOT_FAULT ) {
            // A device was found
            return TRUE;
        }
    }

    // No device is there
    return FALSE;

} // end PptLegacyZipCheckDevice()

NTSTATUS
PptTrySelectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    )
{
    PFDO_EXTENSION           fdx   = Context;
    PPARALLEL_1284_COMMAND      Command     = TrySelectCommand;
    NTSTATUS                    Status      = STATUS_SUCCESS; // default success
    PUCHAR                      Controller  = fdx->PortInfo.Controller;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    KIRQL                       CancelIrql;

    DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip - Enter\n");

    // test to see if we need to grab port
    if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
        // Don't have the port
        //
        // Try to acquire port and select device
        //
        DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip Try get port.\n");

        IoAcquireCancelSpinLock(&CancelIrql);
                
        SyncContext.Count = &fdx->WorkQueueCount;
                    
        if (fdx->InterruptRefCount) {
            KeSynchronizeExecution(fdx->InterruptObject,
                                   PptSynchronizedIncrement,
                                   &SyncContext);
        } else {
            PptSynchronizedIncrement(&SyncContext);
        }
                    
        if (SyncContext.NewCount) {
            // Port is busy, queue request
            Status = STATUS_PENDING;
        }  // endif - test for port busy
                    
        IoReleaseCancelSpinLock(CancelIrql);

    } // endif - test if already have port


    //
    // If we have port select legacy Zip
    //
    if ( NT_SUCCESS( Status ) && (Status != STATUS_PENDING) ) {
        if ( Command->CommandFlags & PAR_LEGACY_ZIP_DRIVE_EPP_MODE ) {
            // Select in EPP mode
            PptLegacyZipSetDiskMode( Controller, (UCHAR)0xCF );
        } else {
            // Select in Nibble or Byte mode
            PptLegacyZipSetDiskMode( Controller, (UCHAR)0x8F );
        }

        if ( PptLegacyZipCheckDevice( Controller ) ) {
            DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip - SUCCESS\n");

            //
            // Legacy Zip is selected - test for EPP if we haven't previously done the test
            //
            if( !fdx->CheckedForGenericEpp ) {
                // haven't done the test yet
                if( fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {
                    // we have an ECR - required for generic EPP

                    if( !fdx->NationalChipFound ) {
                        // we don't have a NationalSemi chipset - no generic EPP on NatSemi chips
                        PptDetectEppPort( fdx );
                    }

                }
                fdx->CheckedForGenericEpp = TRUE; // check is complete
            }

        } else {
            DD((PCE)fdx,DDT,"par12843::PptTrySelectLegacyZip - FAIL\n");
            PptDeselectLegacyZip( Context, TrySelectCommand );
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    
    return( Status );

} // end PptTrySelectLegacyZip()

NTSTATUS
PptDeselectLegacyZip(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    )
{
    ULONG i;
    PFDO_EXTENSION       fdx   = Context;
    PUCHAR                  Controller  = fdx->PortInfo.Controller;
    PPARALLEL_1284_COMMAND  Command     = DeselectCommand;

    DD((PCE)fdx,DDT,"par12843::PptDeselectLegacyZip - Enter\n");

    for ( i = 0; i < LEGACYZIP_MODE_LEN; i++ ) {
        PptLegacyZipClockPrtModeByte( Controller, LegacyZipModeQualifier[i] );
    }

    // set to printer pass thru mode
    PptLegacyZipClockPrtModeByte( Controller, (UCHAR)0x0F );

    // check if requester wants to keep port or free port
    if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
        PptFreePort( fdx );
    }

    return STATUS_SUCCESS;

} // end  PptDeselectLegacyZip()


VOID
P5SelectLegacyZip(
    IN  PUCHAR  Controller
    )
// select Legacy Zip drive in NIBBLE/BYTE mode - use this only for PnP
//   detection of drive so that drive will answer a subsequent check
//   drive command
//
// N.B. caller must own (lock for exclusive access) the port prior to
//   calling this function
{
    PptLegacyZipSetDiskMode( Controller, (UCHAR)0x8F );
}


VOID
P5DeselectLegacyZip(
    IN  PUCHAR  Controller
    )
// deselect drive - set Legacy Zip drive to printer pass thru mode
{
    ULONG i;
    for ( i = 0; i < LEGACYZIP_MODE_LEN; i++ ) {
        PptLegacyZipClockPrtModeByte( Controller, LegacyZipModeQualifier[i] );
    }
    PptLegacyZipClockPrtModeByte( Controller, (UCHAR)0x0F );
    P5WritePortUchar( Controller, 0 ); // set data wires back to zero
}


BOOLEAN
P5LegacyZipDetected(
    IN  PUCHAR  Controller
    )
// Detect Legacy Zip drive - return TRUE if Legacy Zip found on port, FALSE otherwise
{
    BOOLEAN foundZip;

    // Try to select drive so that following CheckDevice will be able
    // to determine if there is a legacy zip connected
    P5SelectLegacyZip( Controller );

    // Try to talk to drive
    if( PptLegacyZipCheckDevice( Controller ) ) {
        foundZip = TRUE;
    } else {
        // no drive detected
        foundZip = FALSE;
    }

    // send deselect sequence whether we found the drive or not
    P5DeselectLegacyZip( Controller );

    return foundZip;
}

// parclass ppa3x.c follows

PCHAR ParBuildLegacyZipDeviceId() 
{
    ULONG size = sizeof(PAR_LGZIP_PSEUDO_1284_ID_STRING) + sizeof(NULL);
    PCHAR id = ExAllocatePool(PagedPool, size);
    if( id ) {
        RtlZeroMemory( id, size );
        RtlCopyMemory( id, ParLegacyZipPseudoId, size - sizeof(NULL) );
        return id;
    } else {
        return NULL;
    }
}
PCHAR
Par3QueryLegacyZipDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString // TRUE ==  include the 2 size bytes in the returned string
                                             // FALSE == discard the 2 size bytes
    )
{
    USHORT deviceIdSize;
    PCHAR  deviceIdBuffer;

    UNREFERENCED_PARAMETER( Extension );
    UNREFERENCED_PARAMETER( bReturnRawString );
    
    // initialize returned size in case we have an error
    *DeviceIdSize = 0;

    deviceIdBuffer = ParBuildLegacyZipDeviceId();
    if( !deviceIdBuffer ) {
        // error, likely out of resources
        return NULL;
    }

    deviceIdSize = (USHORT)strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    } else {
        // caller buffer too small, return pointer to our buffer
        return deviceIdBuffer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\nibble.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    nibble.c

Abstract:

    This module contains the code to do nibble mode reads.

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

BOOLEAN
ParIsNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
NTSTATUS
ParEnterNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    );
    
NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateNibbleMode(
    IN  PPDO_EXTENSION   Pdx
    );
    
NTSTATUS
ParNibbleModeRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not nibble mode is suported
    by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (Pdx->BadProtocolModes & NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsNibbleSupported: BAD PROTOCOL Leaving\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsNibbleSupported: Already Checked YES Leaving\n");
        return TRUE;
    }

    Status = ParEnterNibbleMode (Pdx, FALSE);
    ParTerminateNibbleMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsNibbleSupported: SUCCESS Leaving\n");
        Pdx->ProtocolModesSupported |= NIBBLE;
        return TRUE;
    }
    
    DD((PCE)Pdx,DDT,"ParIsNibbleSupported: UNSUCCESSFUL Leaving\n");
    return FALSE;    
    
}

BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not channelized nibble mode is suported (1284.3)
    by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (Pdx->BadProtocolModes & CHANNEL_NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: BAD PROTOCOL Leaving\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & CHANNEL_NIBBLE) {
        DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: Already Checked YES Leaving\n");
        return TRUE;
    }

    Status = ParEnterChannelizedNibbleMode (Pdx, FALSE);
    ParTerminateNibbleMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: SUCCESS Leaving\n");
        Pdx->ProtocolModesSupported |= CHANNEL_NIBBLE;
        return TRUE;
    }
    
    DD((PCE)Pdx,DDT,"ParIsChannelizedNibbleSupported: UNSUCCESSFUL Leaving\n");
    return FALSE;    
    
}

NTSTATUS
ParEnterNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Pdx,DDT,"ParEnterNibbleMode: Start\n");

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Pdx, NIBBLE_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Pdx, NIBBLE_EXTENSIBILITY);
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterNibbleMode: In UNSAFE_MODE.\n");
        Pdx->Connected = TRUE;
    }

    // dvdr
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParEnterNibbleMode: IeeeEnter1284Mode returned success\n");
        Pdx->CurrentEvent = 6;
        P5SetPhase( Pdx, PHASE_NEGOTIATION );
        Pdx->IsIeeeTerminateOk = TRUE;
    } else {
        DD((PCE)Pdx,DDT,"ParEnterNibbleMode: IeeeEnter1284Mode returned unsuccessful\n");
        ParTerminateNibbleMode ( Pdx );
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }

    DD((PCE)Pdx,DDT,"ParEnterNibbleMode: Leaving with Status : %x \n", Status);

    return Status; 
}    

NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: Start\n");

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Pdx, CHANNELIZED_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Pdx, CHANNELIZED_EXTENSIBILITY);
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: In UNSAFE_MODE.\n");
        Pdx->Connected = TRUE;
    }
    
    // dvdr
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: IeeeEnter1284Mode returned success\n");
        Pdx->CurrentEvent = 6;
        P5SetPhase( Pdx, PHASE_NEGOTIATION );
        Pdx->IsIeeeTerminateOk = TRUE;
    } else {
        DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: IeeeEnter1284Mode returned unsuccessful\n");
        ParTerminateNibbleMode ( Pdx );
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }

    DD((PCE)Pdx,DDT,"ParEnterChannelizedNibbleMode: Leaving with Status : %x \n", Status);
    return Status; 
}    

VOID
ParTerminateNibbleMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    DD((PCE)Pdx,DDT,"ParTerminateNibbleMode: Enter.\n");
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Pdx);
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateNibbleMode: In UNSAFE_MODE.\n");
        Pdx->Connected = FALSE;
    }
    DD((PCE)Pdx,DDT,"ParTerminateNibbleMode: Exit.\n");
}

NTSTATUS
ParNibbleModeRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 nibble mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          wPortDCR;
    PUCHAR          wPortDSR;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          p = (PUCHAR)Buffer;
    UCHAR           dsr, dcr;
    UCHAR           nibble[2];
    ULONG           i, j;

    Controller = Pdx->Controller;
    wPortDCR = Controller + OFFSET_DCR;
    wPortDSR = Controller + OFFSET_DSR;
    
    // Read nibbles according to 1284 spec.
    DD((PCE)Pdx,DDT,"ParNibbleModeRead - enter\n");

    dcr = P5ReadPortUchar(wPortDCR);

    switch (Pdx->CurrentPhase) {
    
        case PHASE_NEGOTIATION: 
        
            DD((PCE)Pdx,DDT,"ParNibbleModeRead - case PHASE_NEGOTIATION\n");
            
            // Starting in state 6 - where do we go from here?
            // To Reverse Idle or Reverse Data Transfer Phase depending if
            // data is available.
            
            dsr = P5ReadPortUchar(wPortDSR);
            
            // =============== Periph State 6 ===============8
            // PeriphAck/PtrBusy        = Don't Care
            // PeriphClk/PtrClk         = Don't Care (should be high
            //                              and the nego. proc already
            //                              checked this)
            // nAckReverse/AckDataReq   = Don't Care (should be high)
            // XFlag                    = Don't Care (should be low)
            // nPeriphReq/nDataAvail    = High/Low (line status determines
            //                              which state we move to)
            Pdx->CurrentEvent = 6;
        #if (0 == DVRH_USE_NIBBLE_MACROS)
            if (dsr & DSR_NOT_DATA_AVAIL)
        #else
            if (TEST_DSR(dsr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE ))
        #endif
            {
                // Data is NOT available - go to Reverse Idle
                DD((PCE)Pdx,DDT,"ParNibbleModeRead - now in PHASE_REVERSE_IDLE\n");
                // Host enters state 7  - officially in Reverse Idle now
                
            	// Must stall for at least .5 microseconds before this state.
                KeStallExecutionProcessor(1);

                /* =============== Host State 7 Nibble Reverse Idle ===============8
                    DIR                     = Don't Care
                    IRQEN                   = Don't Care
                    1284/SelectIn           = High
                    nReverseReq/  (ECP only)= Don't Care
                    HostAck/HostBusy        = Low (signals State 7)
                    HostClk/nStrobe         = High
                  ============================================================ */
                Pdx->CurrentEvent = 7;
            #if (0 == DVRH_USE_NIBBLE_MACROS)
                dcr |= DCR_NOT_HOST_BUSY;
            #else
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
            #endif
                P5WritePortUchar(wPortDCR, dcr);

                P5SetPhase( Pdx,  PHASE_REVERSE_IDLE );
                // FALL THRU TO reverse idle
            } else {
            
                // Data is available, go to Reverse Transfer Phase
                P5SetPhase( Pdx,  PHASE_REVERSE_XFER );
                // DO NOT fall thru
                goto PhaseReverseXfer; // please save me from my sins!
            }


        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            // See if data is available (looking for state 19)
            dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                
            if (!(dsr & DSR_NOT_DATA_AVAIL)) {
                
                dcr = P5ReadPortUchar(wPortDCR);
                // =========== Host State 20 Interrupt Phase ===========8
                //  DIR                     = Don't Care
                //  IRQEN                   = Don't Care
                //  1284/SelectIn           = High
                //  nReverseReq/ (ECP only) = Don't Care
                //  HostAck/HostBusy        = High (Signals state 20)
                //  HostClk/nStrobe         = High
                //
                // Data is available, get us to Reverse Transfer Phase
                Pdx->CurrentEvent = 20;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
                P5WritePortUchar(wPortDCR, dcr);

                // =============== Periph State 21 HBDA ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = Don't Care (should be high)
                // nAckReverse/AckDataReq   = low (signals state 21)
                // XFlag                    = Don't Care (should be low)
                // nPeriphReq/nDataAvail    = Don't Care (should be low)
                Pdx->CurrentEvent = 21;
                if (CHECK_DSR(Controller,
                                DONT_CARE, DONT_CARE, INACTIVE,
                                DONT_CARE, DONT_CARE,
                                IEEE_MAXTIME_TL)) {
                                  
                // Got state 21
                    // Let's jump to Reverse Xfer and get the data
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
                    goto PhaseReverseXfer;
                        
                } else {
                    
                    // Timeout on state 21
                    Pdx->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 21: Controller %x dcr %x\n", Controller, dcr);
                    // NOTE:  Don't ASSERT Here.  An Assert here can bite you if you are in
                    //        Nibble Rev and you device is off/offline.
                    // dvrh 2/25/97
                    goto NibbleReadExit;
                }

            } else {
                
                // Data is NOT available - do nothing
                // The device doesn't report any data, it still looks like it is
                // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                // jumped out of Nibble mode, test also for AckDataReq high and XFlag low
                // and nDataAvaul high.
                Pdx->CurrentEvent = 18;
                dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                if(( dsr & DSR_NIBBLE_VALIDATION )== DSR_NIBBLE_TEST_RESULT ) {

                    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );

                } else {
                    #if DVRH_BUS_RESET_ON_ERROR
                        BusReset(wPortDCR);  // Pass in the dcr address
                    #endif
                    // Appears we failed state 19.
                    Pdx->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 19: Controller %x dcr %x\n", Controller, dcr);
                }
                goto NibbleReadExit;

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            DD((PCE)Pdx,DDT,"ParNibbleModeRead - case PHASE_REVERSE_IDLE\n");
            
            for (i = 0; i < BufferSize; i++) {
            
                for (j = 0; j < 2; j++) {
                
                    // Host enters state 7 or 12 depending if nibble 1 or 2
//                    StoreControl (Controller, HDReady);
                    dcr |= DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 9     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = low (signals state 9)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    Pdx->CurrentEvent = 9;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, INACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        
                        Pdx->IsIeeeTerminateOk = FALSE;
                        Status = STATUS_IO_DEVICE_ERROR;
                        DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 9: Controller %x dcr %x\n", Controller, dcr);
                        P5SetPhase( Pdx, PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }

                    // Read Nibble
                    nibble[j] = P5ReadPortUchar(wPortDSR);

                    /* ============== Host State 10 Nibble Read ===============8
                        DIR                     = Don't Care
                        IRQEN                   = Don't Care
                        1284/SelectIn           = High
                        HostAck/HostBusy        = High (signals State 10)
                        HostClk/nStrobe         = High
                    ============================================================ */
                    Pdx->CurrentEvent = 10;
                    dcr &= ~DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 11     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = High (signals state 11)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    Pdx->CurrentEvent = 11;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, ACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        Status = STATUS_IO_DEVICE_ERROR;
                        Pdx->IsIeeeTerminateOk = FALSE;
                        DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 11: Controller %x dcr %x\n", Controller, dcr);
                        P5SetPhase( Pdx, PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }
                }

                // Read two nibbles - make them into one byte.
                
                p[i]  = (((nibble[0]&0x38)>>3)&0x07) | ((nibble[0]&0x80) ? 0x00 : 0x08);
                p[i] |= (((nibble[1]&0x38)<<1)&0x70) | ((nibble[1]&0x80) ? 0x00 : 0x80);

                // RMT - put this back in if needed - DD((PCE)Pdx,DDT,"ParNibbleModeRead:%x:%c\n", p[i], p[i]);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = P5ReadPortUchar(wPortDSR);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
                    i++; // account for this last byte transferred
                    break;
                    
                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
                }
            } // end for i loop

            *BytesTransferred = i;
            // DON'T FALL THRU THIS ONE
            break;

        default:
            // I'm gonna mark this as false. There is not a correct answer here.
            //  The peripheral and the host are out of sync.  I'm gonna reset myself
            // and the peripheral.       
            Pdx->IsIeeeTerminateOk = FALSE;
            Status = STATUS_IO_DEVICE_ERROR;
            P5SetPhase( Pdx, PHASE_UNKNOWN );

            DD((PCE)Pdx,DDT,"ParNibbleModeRead - Failed State 9: Unknown Phase. Controller %x dcr %x\n", Controller, dcr);
            DD((PCE)Pdx,DDT, "ParNibbleModeRead: You're hosed man.\n" );
            DD((PCE)Pdx,DDT, "ParNibbleModeRead: If you are here, you've got a bug somewhere else.\n" );
            DD((PCE)Pdx,DDT, "ParNibbleModeRead: Go fix it!\n" );
            goto NibbleReadExit;
            break;
    } // end switch

NibbleReadExit:

    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        DD((PCE)Pdx,DDT,"ParNibbleModeRead - PHASE_REVERSE_IDLE\n");
        dcr |= DCR_NOT_HOST_BUSY;
        P5WritePortUchar (wPortDCR, dcr);
    }

    DD((PCE)Pdx,DDT,"ParNibbleModeRead:End [%d] bytes read = %d\n", NT_SUCCESS(Status), *BytesTransferred);
    Pdx->log.NibbleReadCount += *BytesTransferred;

#if 1 == DBG_SHOW_BYTES
    if( DbgShowBytes ) {
        if( NT_SUCCESS( Status ) && (*BytesTransferred > 0) ) {
            const ULONG maxBytes = 32;
            ULONG i;
            PUCHAR bytePtr = (PUCHAR)Buffer;
            DbgPrint("n: ");
            for( i=0 ; (i < *BytesTransferred) && (i < maxBytes ) ; ++i ) {
                DbgPrint("%02x ",*bytePtr++);
            }
            if( *BytesTransferred > maxBytes ) {
                DbgPrint("... ");
            }
            DbgPrint("zz\n");
        }
    }
#endif

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#define WANT_WDM                   1
#define DVRH_USE_CORRECT_PTRS      1

#pragma warning( disable : 4115 )   // named type definition in parentheses
#pragma warning( disable : 4127 )   // conditional expression is constant
#pragma warning( disable : 4201 )   // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )   // nonstandard extension used : bit field types other than int
#pragma warning( disable : 4514 )   // unreferenced inline function has been removed

#include <ntddk.h>
#include <wdmguid.h>
#include <wmidata.h>
#include <wmilib.h>
#include <ntddser.h>                // IOCTL_SERIAL_[ SET | GET ]_TIMEOUTS
#include <stdio.h>
#define DVRH_USE_PARPORT_ECP_ADDR 1 // use ECP base + 0x2 rather than base + 0x402 for ECR 
#include <parallel.h>               // parallel.h includes ntddpar.h
#include "queueClass.h"
#include "parport.h"
#include "parlog.h"
#include "funcdecl.h"
#include "debug.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\parport.c ===
#include "pch.h"

#include <initguid.h>
#include <wdmguid.h>
#include <ntddpar.h>

//
// globals and constants
//
LARGE_INTEGER AcquirePortTimeout;

ULONG ParEnableLegacyZip   = 0;
PCHAR ParLegacyZipPseudoId = PAR_LGZIP_PSEUDO_1284_ID_STRING;
ULONG SppNoRaiseIrql = 0;
ULONG DefaultModes   = 0;

UNICODE_STRING RegistryPath = {0,0,0};

// track CREATE/CLOSE count - likely obsolete
LONG        PortInfoReferenceCount  = -1L;
PFAST_MUTEX PortInfoMutex           = NULL;

const PHYSICAL_ADDRESS PhysicalZero = {0};

// variable to know how many times to try a select or
// deselect for 1284.3 if we do not succeed.
UCHAR PptDot3Retries = 5;

ULONG WarmPollPeriod  = 5;      // time between polls for printers (in seconds)

BOOLEAN           PowerStateIsAC                 = TRUE; // FALSE means running on battery power
PCALLBACK_OBJECT  PowerStateCallbackObject       = NULL;
PVOID             PowerStateCallbackRegistration = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdocleanup.c ===
#include "pch.h"

NTSTATUS
PptPdoCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch for a cleanup requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/
{
    PPDO_EXTENSION   pdx = DeviceObject->DeviceExtension;
    KIRQL            CancelIrql;
    PDRIVER_CANCEL   CancelRoutine;
    PIRP             CurrentLastIrp;

    DD((PCE)pdx,DDT,"ParCleanup - enter\n");

    //
    // While the list is not empty, go through and cancel each irp.
    //

    IoAcquireCancelSpinLock(&CancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(&pdx->WorkQueue)) {

        CurrentLastIrp = CONTAINING_RECORD(pdx->WorkQueue.Blink,
                                           IRP, Tail.Overlay.ListEntry);

        RemoveEntryList(pdx->WorkQueue.Blink);

        CancelRoutine = CurrentLastIrp->CancelRoutine;
        CurrentLastIrp->CancelIrql    = CancelIrql;
        CurrentLastIrp->CancelRoutine = NULL;
        CurrentLastIrp->Cancel        = TRUE;

        CancelRoutine(DeviceObject, CurrentLastIrp);

        IoAcquireCancelSpinLock(&CancelIrql);
    }

    //
    // If there is a current irp then mark it as cancelled.
    //

    if (pdx->CurrentOpIrp) {
        pdx->CurrentOpIrp->Cancel = TRUE;
    }

    IoReleaseCancelSpinLock(CancelIrql);

    P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\parport.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name :

    parport.h

Abstract:

    Type definitions and data for the parallel port driver.

Revision History:

--*/

#ifndef _PARPORT_H_
#define _PARPORT_H_

#define arraysize(p) (sizeof(p)/sizeof((p)[0])) // From Walter Oney WDM book

// Used to keep track of the state of an IEEE negotiation, transfer, or termination
typedef struct _IEEE_STATE {
    ULONG         CurrentEvent;        // IEEE 1284 event - see IEEE 1284-1994 spec
    P1284_PHASE   CurrentPhase;        // see parallel.h for enum def - PHASE_UNKNOWN, ..., PHASE_INTERRUPT_HOST
    BOOLEAN       Connected;           // are we currently negotiated into a 1284 mode?
    BOOLEAN       IsIeeeTerminateOk;   // are we in a state where an IEEE Terminate is legal?
    USHORT        ProtocolFamily;      // what protocol family are we currently using (if connected)
} IEEE_STATE, *PIEEE_STATE;

// should we use or ignore XFlag on termination event 24 when terminating NIBBLE mode for 1284 ID query?
typedef enum {
    IgnoreXFlagOnEvent24,
       UseXFlagOnEvent24
}         XFlagOnEvent24;

// DVDF - 2000-08-16
// Used with IOCTL_INTERNAL_PARPORT_EXECUTE_TASK
typedef enum {
    Select,
    Deselect,
    Write,
    Read,
    MaxTask        
} ParportTask;

// Used with IOCTL_INTERNAL_PARPORT_EXECUTE_TASK
typedef struct _PARPORT_TASK {
    ParportTask Task;          // what type of request?
    PCHAR       Buffer;        // where is the buffer to use?
    ULONG       BufferLength;  // how big is the buffer?
    ULONG       RequestLength; // how many bytes of data is requested or supplied?
    CHAR        Requestor[8];  // diagnostic use only - suggest pdx->Location, e.g., "LPT2.4"
} PARPORT_TASK, *PPARPORT_TASK;

// handled by parport FDOs - execute a specified task
#define IOCTL_INTERNAL_PARPORT_EXECUTE_TASK                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)

struct _PDO_EXTENSION;
typedef struct _PDO_EXTENSION * PPDO_EXTENSION;

typedef
NTSTATUS
(*PPROTOCOL_READ_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
NTSTATUS
(*PPROTOCOL_WRITE_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
NTSTATUS
(*PDOT3_RESET_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef struct _DOT3DL_PCTL {
    PPROTOCOL_READ_ROUTINE           fnRead;
    PPROTOCOL_WRITE_ROUTINE           fnWrite;
    PDOT3_RESET_ROUTINE           fnReset;
    P12843_DL_MODES DataLinkMode;
    USHORT          CurrentPID;
    USHORT          FwdSkipMask;
    USHORT          RevSkipMask;
    UCHAR           DataChannel;
    UCHAR           ResetChannel;
    UCHAR           ResetByteCount;
    UCHAR           ResetByte;
    PKEVENT         Event;
    BOOLEAN         bEventActive;
} DOT3DL_PCTL, *PDOT3DL_PCTL;

//
// If we can't use our preferred \Device\ParallelN number due to name collision,
//   then start with N == PAR_CLASSNAME_OFFSET and increment until we are successful
//
#define PAR_CLASSNAME_OFFSET 8

//
// For pnp id strings
//
#define MAX_ID_SIZE 256

// used to construct IEEE 1284.3 "Dot" name suffixes 
// table lookup for integer to WCHAR conversion
#define PAR_UNICODE_PERIOD L'.'
#define PAR_UNICODE_COLON  L':'


//#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY)
#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY | ECP_ANY)
#define PAR_FWD_MODE_SKIP_MASK   (EPP_ANY | BOUNDED_ECP | ECP_HW_NOIRQ | ECP_HW_IRQ)
//#define PAR_FWD_MODE_SKIP_MASK  (EPP_ANY)
#define PAR_MAX_CHANNEL 127
#define PAR_COMPATIBILITY_RESET 300



#define PptSetFlags( FlagsVariable, FlagsToSet ) { (FlagsVariable) |= (FlagsToSet); }
#define PptClearFlags( FlagsVariable, FlagsToClear ) { (FlagsVariable) &= ~(FlagsToClear); }

// convert timeout in Milliseconds to relative timeout in 100ns units
//   suitable as parameter 5 to KeWaitForSingleObject(..., TimeOut)
#define PPT_SET_RELATIVE_TIMEOUT_IN_MILLISECONDS(VARIABLE, VALUE) (VARIABLE).QuadPart = -( (LONGLONG) (VALUE)*10*1000 )

#define MAX_PNP_IRP_MN_HANDLED IRP_MN_QUERY_LEGACY_BUS_INFORMATION

extern ULONG PptDebugLevel;
extern ULONG PptBreakOn;
extern UNICODE_STRING RegistryPath;       // copy of the registry path passed to DriverEntry()

extern UCHAR PptDot3Retries;    // variable to know how many times to try a select or
                                // deselect for 1284.3 if we do not succeed.

typedef enum _DevType {
    DevTypeFdo = 1,
    DevTypePdo = 2,
} DevType, *PDevType;

typedef enum _PdoType {
    PdoTypeRawPort    = 1,
    PdoTypeEndOfChain = 2,
    PdoTypeDaisyChain = 4,
    PdoTypeLegacyZip  = 8
} PdoType, *PPdoType;

extern const PHYSICAL_ADDRESS PhysicalZero;

#define PARPORT_TAG (ULONG) 'PraP'


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,PARPORT_TAG)
#endif


//
// used for FilterResourceMethod in processing PnP IRP_MN_FILTER_RESOURCE_REQUIREMENTS
//
#define PPT_TRY_USE_NO_IRQ    0 // if alternatives exist that don't require an IRQ then
                                //   delete those alternatives that do, otherwise do nothing
#define PPT_FORCE_USE_NO_IRQ  1 // try previous method - if it fails (i.e., all alternatives 
                                //   require resources), then nuke IRQ resource descriptors 
                                //   in all alternatives
#define PPT_ACCEPT_IRQ        2 // don't do any resource filtering - accept resources that 
                                //   we are given


//
// Keep track of GET and RELEASE port info.
//
extern LONG PortInfoReferenceCount;
extern PFAST_MUTEX PortInfoMutex;

//
// DeviceStateFlags
//
#define PAR_DEVICE_PAUSED              ((ULONG)0x00000010) // stop-pending, stopped, or remove-pending states
#define PAR_DEVICE_PORT_REMOVE_PENDING ((ULONG)0x00000200) // our ParPort is in a Remove Pending State

//
// extension->PnpState - define the current PnP state of the device
//
#define PPT_DEVICE_STARTED          ((ULONG)0x00000001) // Device has succeeded START
#define PPT_DEVICE_DELETED          ((ULONG)0x00000002) // IoDeleteDevice has been called
#define PPT_DEVICE_STOP_PENDING     ((ULONG)0x00000010) // Device has succeeded QUERY_STOP, waiting for STOP or CANCEL
#define PPT_DEVICE_STOPPED          ((ULONG)0x00000020) // Device has received STOP
#define PPT_DEVICE_DELETE_PENDING   ((ULONG)0x00000040) // we have started the process of deleting device object
#define PPT_DEVICE_HARDWARE_GONE    ((ULONG)0x00000080) // our hardware is gone
#define PPT_DEVICE_REMOVE_PENDING   ((ULONG)0x00000100) // Device succeeded QUERY_REMOVE, waiting for REMOVE or CANCEL
#define PPT_DEVICE_REMOVED          ((ULONG)0x00000200) // Device has received REMOVE
#define PPT_DEVICE_SURPRISE_REMOVED ((ULONG)0x00001000) // Device has received SURPRISE_REMOVAL
#define PPT_DEVICE_PAUSED           ((ULONG)0x00010000) // stop-pending, stopped, or remove-pending - hold requests

//
// IEEE 1284 constants (Protocol Families)
//
#define FAMILY_NONE             0x0
#define FAMILY_REVERSE_NIBBLE   0x1
#define FAMILY_REVERSE_BYTE     0x2
#define FAMILY_ECP              0x3
#define FAMILY_EPP              0x4
#define FAMILY_BECP             0x5
#define FAMILY_MAX              FAMILY_BECP


typedef struct _IRPQUEUE_CONTEXT {
    LIST_ENTRY  irpQueue;
    KSPIN_LOCK  irpQueueSpinLock;
} IRPQUEUE_CONTEXT, *PIRPQUEUE_CONTEXT;

typedef struct _COMMON_EXTENSION {
    ULONG           Signature1;           // Used to increase our confidence that this is a ParPort extension
    enum _DevType   DevType;              // distinguish an FDO_EXTENSION from a PDO_EXTENSION
    PCHAR           Location;             // LPTx or LPTx.y location for PDO (symlink name less the \DosDevices prefix)
                                          // LPTxF for FDO
    PDEVICE_OBJECT  DeviceObject;         // back pointer to our DEVICE_OBJECT
    ULONG           PnpState;             // Device State - See Device State Flags: PPT_DEVICE_... above
    IO_REMOVE_LOCK  RemoveLock;           // Used to prevent PnP from removing us while requests are pending
    LONG            OpenCloseRefCount;    // keep track of the number of handles open to our device
    UNICODE_STRING  DeviceInterface;      // SymbolicLinkName returned from IoRegisterDeviceInterface
    BOOLEAN         DeviceInterfaceState; // Did we last set the DeviceInterface to True or False?
    BOOLEAN         TimeToTerminateThread;// TRUE == worker thread should kill itself via PsTerminateSystemThread()
    PVOID           ThreadObjectPointer;  // pointer to a worker thread for this Device
} COMMON_EXTENSION, *PCOMMON_EXTENSION, *PCE;


//
// Fdo Device Extension
//
typedef struct _FDO_EXTENSION {

    COMMON_EXTENSION;

    //
    // Devices that we have enumerated
    // 
    PDEVICE_OBJECT RawPortPdo;       // LPTx             - legacy "Raw Port" interface
    PDEVICE_OBJECT DaisyChainPdo[4]; // LPTx.0 -- LPTx.3 - IEEE 1284.3 daisy chain devices
    PDEVICE_OBJECT EndOfChainPdo;    // LPTx.4           - end-of-chain devices
    PDEVICE_OBJECT LegacyZipPdo;     // LPTx.5           - original (non-1284.3) Iomega Zip drive

    IEEE_STATE IeeeState;

    //
    // DisableEndOfChainBusRescan - if TRUE then do NOT rescan bus for change in End Of Chain (LPTx.4)
    //                              device in response to PnP IRP_MN_QUERY_DEVICE_RELATIONS / BusRelations,
    //                              simply report the LPTx.4 device that we found on the previous bus rescan.
    //                            - if we did not have an End Of Chain device on the previous rescan then this
    //                              flag is ignored.
    //
    BOOLEAN DisableEndOfChainBusRescan;

    //
    // Points to the driver object that contains this instance of parport.
    //
    PDRIVER_OBJECT DriverObject;

    //
    // Points to the PDO
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Points to our parent
    //
    PDEVICE_OBJECT ParentDeviceObject;

    //
    // Counter is incremented by the "polling for printers" thread on
    // each failed attempt at reading the IEEE 1284 Device ID from the
    // device. When the counter hits a defined threshold the polling
    // thread considers the error unrecoverable and stops polling
    //
    ULONG PollingFailureCounter;

    // list head for list of PDOs to delete on Driver Unload
    LIST_ENTRY DevDeletionListHead;

    //
    // Queue of ALLOCATE & SELECT irps waiting to be processed.  Access with cancel spin lock.
    //
    LIST_ENTRY WorkQueue;

    // Queue Irps while waiting to be processed
    IRPQUEUE_CONTEXT IrpQueueContext;

    //
    // The number of irps in the queue where -1 represents
    // a free port, 0 represents an allocated port with
    // zero waiters, 1 represents an allocated port with
    // 1 waiter, etc...
    //
    // This variable must be accessed with the cancel spin
    // lock or at interrupt level whenever interrupts are
    // being used.
    //
    LONG WorkQueueCount;

    //
    // These structures hold the port address and range for the parallel port.
    //
    PARALLEL_PORT_INFORMATION  PortInfo;
    PARALLEL_PNP_INFORMATION   PnpInfo;

    //
    // Information about the interrupt so that we
    // can connect to it when we have a client that
    // uses the interrupt.
    //
    ULONG AddressSpace;
    ULONG EcpAddressSpace;

    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;

    BOOLEAN FoundInterrupt;
    KIRQL InterruptLevel;
    ULONG InterruptVector;
    KAFFINITY InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;


    //
    // This list contains all of the interrupt service
    // routines registered by class drivers.  All access
    // to this list should be done at interrupt level.
    //
    // This list also contains all of the deferred port check
    // routines.  These routines are called whenever
    // the port is freed if there are no IRPs queued for
    // the port.  Access this list only at interrupt level.
    //
    LIST_ENTRY IsrList;

    //
    // The parallel port interrupt object.
    //
    PKINTERRUPT InterruptObject;

    //
    // Keep a reference count for the interrupt object.
    // This count should be referenced with the cancel
    // spin lock.
    //
    ULONG InterruptRefCount;

    //
    // DPC for freeing the port from the interrupt routine.
    //
    KDPC FreePortDpc;

    //
    // Points to workitem for freeing the port
    //
    PIO_WORKITEM FreePortWorkItem;

    //
    // Set at initialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.
    //
    BOOLEAN UnMapRegisters;

    //
    // Flags for ECP and EPP detection and changing of the modes
    //
    BOOLEAN NationalChecked;
    BOOLEAN NationalChipFound;
    BOOLEAN FilterMode;
    UCHAR EcrPortData;
    
    //
    // Structure that hold information from the Chip Filter Driver
    //
    PARALLEL_PARCHIP_INFO   ChipInfo;    

    UNICODE_STRING DeviceName;

    //
    // Current Device Power State
    //
    DEVICE_POWER_STATE DeviceState;
    SYSTEM_POWER_STATE SystemState;

    FAST_MUTEX     ExtensionFastMutex;
    FAST_MUTEX     OpenCloseMutex;

    KEVENT         FdoThreadEvent; // polling for printers thread waits w/timeout on this event

    WMILIB_CONTEXT                WmiLibContext;
    PARPORT_WMI_ALLOC_FREE_COUNTS WmiPortAllocFreeCounts;

    BOOLEAN CheckedForGenericEpp; // did we check for Generic (via the ECR) EPP capability?
    BOOLEAN FdoWaitingOnPort;
    BOOLEAN spare[2];

    // Used to increase our confidence that this is a ParPort extension
    ULONG   Signature2; 

} FDO_EXTENSION, *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION {

    COMMON_EXTENSION;

    ULONG   DeviceStateFlags;   // Device State - See Device State Flags above

    ULONG   DeviceType;         // - deprecated, use DevType in COMMON_EXTENSION - PAR_DEVTYPE_FDO=0x1, PODO=0x2, or PDO=0x4

    enum _PdoType PdoType;

    PDEVICE_OBJECT Fdo;         // Points to our FDO (bus driver/parent device)

    PCHAR  Mfg;                 // MFG field from device's IEEE 1284 ID string
    PCHAR  Mdl;                 // MDL field from device's IEEE 1284 ID string
    PCHAR  Cid;                 // CID (Compatible ID) field from device's IEEE 1284 ID string
    PWSTR  PdoName;             // name used in call to IoCreateDevice
    PWSTR  SymLinkName;         // name used in call to IoCreateUnprotectedSymbolicLink

    LIST_ENTRY DevDeletionList; // used by driver to create list of PDOs to delete on Driver Unload

    // UCHAR   DaisyChainId;       // 0..3 if PdoTypeDaisyChain, ignored otherwise

    UCHAR   Ieee1284_3DeviceId; // PDO - 0..3 is 1284.3 Daisy Chain device, 4 is End-Of-Chain Device, 5 is Legacy Zip
    BOOLEAN IsPdo;              // TRUE == this is either a PODO or a PDO - use DeviceIdString[0] to distinguish
    BOOLEAN EndOfChain;         // PODO - TRUE==NOT a .3 daisy chain dev - deprecated, use Ieee1284_3DeviceId==4 instead
    BOOLEAN PodoRegForWMI;      // has this PODO registered for WMI callbacks?

    PDEVICE_OBJECT ParClassFdo; // P[O]DO - points to the ParClass FDO

    PDEVICE_OBJECT ParClassPdo; // FDO    - points to first P[O]DO in list of ParClass created PODOs and PDOs

    PDEVICE_OBJECT Next;        // P[O]DO - points to the next DO in the list of ParClass ejected P[O]DOs

    PDEVICE_OBJECT PortDeviceObject;    // P[O]DO - points to the associated ParPort device object

    PFILE_OBJECT   PortDeviceFileObject;// P[O]DO - referenced pointer to a FILE created against PortDeviceObject

    UNICODE_STRING PortSymbolicLinkName;// P[O]DO - Sym link name of the assoc ParPort device - used to open a FILE

    PDEVICE_OBJECT PhysicalDeviceObject;// FDO - The PDO passed to ParPnPAddDevice

    PDEVICE_OBJECT ParentDeviceObject;  // FDO - parent DO returned by IoAttachDeviceToDeviceStack
    PIRP CurrentOpIrp;                  // IRP that our thread is currently processing
    PVOID NotificationHandle;           // PlugPlay Notification Handle

    ULONG Event22Delay;                 // time in microseconds to delay prior to setting event 22 in IEEE 1284 Termination

    ULONG TimerStart;           // initial value used for countdown when starting an operation

    BOOLEAN CreatedSymbolicLink; // P[O]DO - did we create a Symbolic Link for this device?

    BOOLEAN UsePIWriteLoop;     // P[O]DO - do we want to use processor independant write loop?

    BOOLEAN ParPortDeviceGone;  // Is our ParPort device object gone, possibly surprise removed?

    BOOLEAN RegForPptRemovalRelations; // Are we registered for ParPort removal relations?

    UCHAR   Ieee1284Flags;             // is device Stl older 1284.3 spec device?

    BOOLEAN DeleteOnRemoveOk;          // True means that it is OK to call IoDeleteDevice during IRP_MN_REMOVE_DEVICE processing
                                       // - FDO sets this to True during QDR/BusRelations processing if it detects that the hardware 
                                       //   is no longer present.

    USHORT        IdxForwardProtocol;  // see afpForward[] in ieee1284.c
    USHORT        IdxReverseProtocol;  // see arpReverse[] in ieee1284.c
    ULONG         CurrentEvent;        // IEEE 1284 event - see IEEE 1284-1994 spec
    P1284_PHASE   CurrentPhase;      // see parallel.h for enum def - PHASE_UNKNOWN, ..., PHASE_INTERRUPT_HOST
    P1284_HW_MODE PortHWMode;        // see parallel.h for enum def - HW_MODE_COMPATIBILITY, ..., HW_MODE_CONFIGURATION

    FAST_MUTEX OpenCloseMutex;  // protect manipulation of OpenCloseRefCount

    FAST_MUTEX DevObjListMutex; // protect manipulation of list of ParClass ejected DOs

    LIST_ENTRY WorkQueue;       // Queue of irps waiting to be processed.

    KSEMAPHORE RequestSemaphore;// dispatch routines use this to tell device worker thread that there is work to do

    //
    // PARALLEL_PORT_INFORMATION returned by IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO
    //
    PHYSICAL_ADDRESS                OriginalController;
    PUCHAR                          Controller;
    PUCHAR                          EcrController;
    ULONG                           SpanOfController;
    PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePort; // nonblocking callback to allocate ParPort device
    PPARALLEL_FREE_ROUTINE          FreePort;        // callback to free ParPort device
    PPARALLEL_QUERY_WAITERS_ROUTINE QueryNumWaiters; // callback to query number of waiters in port allocation queue
    PVOID                           PortContext;     // context for callbacks to ParPort

    //
    // subset of PARALLEL_PNP_INFORMATION returned by IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO
    //
    ULONG                           HardwareCapabilities;
    PPARALLEL_SET_CHIP_MODE         TrySetChipMode;
    PPARALLEL_CLEAR_CHIP_MODE       ClearChipMode;
    PPARALLEL_TRY_SELECT_ROUTINE    TrySelectDevice;
    PPARALLEL_DESELECT_ROUTINE      DeselectDevice;
    ULONG                           FifoDepth;
    ULONG                           FifoWidth;

    BOOLEAN                         bAllocated; // have we allocated associated ParPort device?
                                                // Note: during some PnP processing we may have the port
                                                //   for a short duration without setting this value to TRUE

    ULONG BusyDelay;            // number of microseconds to wait after strobing a byte before checking the BUSY line.

    BOOLEAN BusyDelayDetermined;// Indicates if the BusyDelay parameter has been computed yet.

    PWORK_QUEUE_ITEM DeferredWorkItem; // Holds the work item used to defer printer initialization

    // If the registry entry by the same name is set, run the parallel
    // thread at the priority we used for NT 3.5 - this solves some
    // cases where a dos app spinning for input in the foreground is
    // starving the parallel thread
    BOOLEAN UseNT35Priority;

    ULONG InitializationTimeout;// timeout in seconds to wait for device to respond to an initialization request
                                //  - default == 15 seconds
                                //  - value overridden by registry entry of same name
                                //  - we will spin for max amount if no device attached

    LARGE_INTEGER AbsoluteOneSecond;// constants that are cheaper to put here rather 
    LARGE_INTEGER OneSecond;        //   than in bss

    //
    // IEEE 1284 Mode support
    //
    PPROTOCOL_READ_ROUTINE  fnRead;    // Current pointer to a valid read funtion
    PPROTOCOL_WRITE_ROUTINE fnWrite;   // Current pointer to a valid write Funtion
    BOOLEAN       Connected;           // are we currently negotiated into a 1284 mode?
    BOOLEAN       AllocatedByLockPort; // are we currently allocated via IOCTL_INTERNAL_LOCK_PORT?
    USHORT        spare4[2];
    LARGE_INTEGER IdleTimeout;         // how long do we hold the port on the caller's behalf following an operation?
    USHORT        ProtocolData[FAMILY_MAX];
    UCHAR         ForwardInterfaceAddress;
    UCHAR         ReverseInterfaceAddress;
    BOOLEAN       SetForwardAddress;
    BOOLEAN       SetReverseAddress;
    FAST_MUTEX    LockPortMutex;

    DEVICE_POWER_STATE DeviceState;// Current Device Power State
    SYSTEM_POWER_STATE SystemState;// Current System Power State

    ULONG         spare2;
    BOOLEAN       bShadowBuffer;
    Queue         ShadowBuffer;
    ULONG         spare3;
    BOOLEAN       bSynchWrites;      // TRUE if ECP HW writes should be synchronous
    BOOLEAN       bFirstByteTimeout; // TRUE if bus just reversed, means give the
                                     //   device some time to respond with some data
    BOOLEAN       bIsHostRecoverSupported;  // Set via IOCTL_PAR_ECP_HOST_RECOVERY.
                                            // HostRecovery will not be utilized unless this bit is set
    KEVENT        PauseEvent; // PnP dispatch routine uses this to pause worker thread during
                              //   during QUERY_STOP, STOP, and QUERY_REMOVE states

    USHORT        ProtocolModesSupported;
    USHORT        BadProtocolModes;

    PARALLEL_SAFETY       ModeSafety;
    BOOLEAN               IsIeeeTerminateOk;
    DOT3DL_PCTL           P12843DL;

    // WMI
    PARALLEL_WMI_LOG_INFO log;
    WMILIB_CONTEXT        WmiLibContext;
    LONG                  WmiRegistrationCount;  // number of times this device has registered with WMI

    // PnP Query ID results
    UCHAR DeviceIdString[MAX_ID_SIZE];    // IEEE 1284 DeviceID string massaged/checksum'd to match INF form
    UCHAR DeviceDescription[MAX_ID_SIZE]; // "Manufacturer<SPACE>Model" from IEEE 1284 DeviceID string

    ULONG                 dummy; // dummy word to force RemoveLock to QuadWord alignment
    PVOID                 HwProfileChangeNotificationHandle;
    ULONG                 Signature2; // keep this the last member in extension
} PDO_EXTENSION, *PPDO_EXTENSION;

typedef struct _SYNCHRONIZED_COUNT_CONTEXT {
    PLONG   Count;
    LONG    NewCount;
} SYNCHRONIZED_COUNT_CONTEXT, *PSYNCHRONIZED_COUNT_CONTEXT;

typedef struct _SYNCHRONIZED_LIST_CONTEXT {
    PLIST_ENTRY List;
    PLIST_ENTRY NewEntry;
} SYNCHRONIZED_LIST_CONTEXT, *PSYNCHRONIZED_LIST_CONTEXT;

typedef struct _SYNCHRONIZED_DISCONNECT_CONTEXT {
    PFDO_EXTENSION                   Extension;
    PPARALLEL_INTERRUPT_SERVICE_ROUTINE IsrInfo;
} SYNCHRONIZED_DISCONNECT_CONTEXT, *PSYNCHRONIZED_DISCONNECT_CONTEXT;

typedef struct _ISR_LIST_ENTRY {
    LIST_ENTRY                  ListEntry;
    PKSERVICE_ROUTINE           ServiceRoutine;
    PVOID                       ServiceContext;
    PPARALLEL_DEFERRED_ROUTINE  DeferredPortCheckRoutine;
    PVOID                       CheckContext;
} ISR_LIST_ENTRY, *PISR_LIST_ENTRY;

typedef struct _REMOVAL_RELATIONS_LIST_ENTRY {
    LIST_ENTRY                  ListEntry;
    PDEVICE_OBJECT              DeviceObject;
    ULONG                       Flags;
    UNICODE_STRING              DeviceName;
} REMOVAL_RELATIONS_LIST_ENTRY, *PREMOVAL_RELATIONS_LIST_ENTRY;


// former ecp.h follows:

#define DEFAULT_ECP_CHANNEL 0

#define ParTestEcpWrite(X)                                               \
                (X->CurrentPhase != PHASE_FORWARD_IDLE && X->CurrentPhase != PHASE_FORWARD_XFER)  \
                 ? STATUS_IO_DEVICE_ERROR : STATUS_SUCCESS

// ==================================================================
// The following RECOVER codes are used for Hewlett-Packard devices.
// Do not remove any of the error codes.  These recover codes are
// used to quickly get the host and periph back to a known state.
// When using a recover code, add a comment where it is used at...
#define RECOVER_0           0       // Reserved - not used anywhere
#define RECOVER_1           1       // ECP_Terminate
#define RECOVER_2           2       // SLP_SetupPhase init
#define RECOVER_3           3       // SLP_FTP init DCR
#define RECOVER_4           4       // SLP_FTP init DSR
#define RECOVER_5           5       // SLP_FTP data xfer DCR
#define RECOVER_6           6       // SLP_FRP init DCR
#define RECOVER_7           7       // SLP_FRP init DSR
#define RECOVER_8           8       // SLP_FRP state 38 DCR
#define RECOVER_9           9       // SLP_FRP state 39 DCR
#define RECOVER_10          10      // SLP_FRP state 40 DSR
#define RECOVER_11          11      // SLP_RTP init DCR
#define RECOVER_12          12      // SLP_RTP init DSR
#define RECOVER_13          13      // SLP_RTP state 43 DCR
#define RECOVER_14          14      // SLP_RFP init DCR
#define RECOVER_15          15      // SLP_RFP init DSR
#define RECOVER_16          16      // SLP_RFP state 47- DCR
#define RECOVER_17          17      // SLP_RFP state 47 DCR
#define RECOVER_18          18      // SLP_RFP state 48 DSR
#define RECOVER_19          19      // SLP_RFP state 49 DSR
#define RECOVER_20          20      // ZIP_EmptyFifo DCR
#define RECOVER_21          21      // ZIP_FTP init DCR
#define RECOVER_22          22      // ZIP_FTP init DSR
#define RECOVER_23          23      // ZIP_FTP data xfer DCR
#define RECOVER_24      24      // ZIP_FRP init DSR
#define RECOVER_25      25      // ZIP_FRP init DCR
#define RECOVER_26      26      // ZIP_FRP state 38 DCR
#define RECOVER_27      27      // ZIP_FRP state 39 DCR
#define RECOVER_28      28      // ZIP_FRP state 40 DSR
#define RECOVER_29      29      // ZIP_FRP state 41 DCR
#define RECOVER_30      30      // ZIP_RTP init DSR
#define RECOVER_31      31      // ZIP_RTP init DCR
#define RECOVER_32      32      // ZIP_RFP init DSR
#define RECOVER_33      33      // ZIP_RFP init DCR
#define RECOVER_34      34      // ZIP_RFP state 47- DCR
#define RECOVER_35      35      // ZIP_RFP state 47 DCR
#define RECOVER_36      36      // ZIP_RFP state 48 DSR
#define RECOVER_37      37      // ZIP_RFP state 49 DSR
#define RECOVER_38      38      // ZIP_RFP state 49+ DCR
#define RECOVER_39      39      // Slippy_Terminate 
#define RECOVER_40      40      // ZIP_SCA init DCR
#define RECOVER_41      41      // ZIP_SCA init DSR
#define RECOVER_42      42      // SLP_SCA init DCR
#define RECOVER_43      43      // SLP_SCA init DSR
#define RECOVER_44      44      // ZIP_SP init DCR
#define RECOVER_45      45      // SIP_FRP init DSR
#define RECOVER_46      46      // SIP_FRP init DCR
#define RECOVER_47      47      // SIP_FRP state 38 DCR
#define RECOVER_48      48      // SIP_FRP state 39 DCR
#define RECOVER_49      49      // SIP_FRP state 40 DSR
#define RECOVER_50      50      // SIP_RTP init DCR
#define RECOVER_51      51      // SIP_RFP init DSR
#define RECOVER_52      52      // SIP_RFP state 43 DCR

// former ecp.h preceeds

// former hwecp.h follows

//--------------------------------------------------------------------------
// Printer status constants.   Seem to only be used by hwecp
//--------------------------------------------------------------------------
#define CHKPRNOK        0xDF        // DSR value indicating printer ok.
#define CHKPRNOFF1      0x87        // DSR value indicating printer off.
#define CHKPRNOFF2      0x4F        // DSR value indicating printer off.
#define CHKNOCABLE      0x7F        // DSR value indicating no cable.
#define CHKPRNOFLIN     0xCF        // DSR value indicating printer offline.
#define CHKNOPAPER      0xEF        // DSR value indicating out of paper.
#define CHKPAPERJAM     0xC7        // DSR value indicating paper jam.

// former hwecp.h preceeds

// former parclass.h follows

#define REQUEST_DEVICE_ID   TRUE
#define HAVE_PORT_KEEP_PORT TRUE

// enable scans for Legacy Zip?
extern ULONG ParEnableLegacyZip;

#define PAR_LGZIP_PSEUDO_1284_ID_STRING "MFG:IMG;CMD:;MDL:VP0;CLS:SCSIADAPTER;DES:IOMEGA PARALLEL PORT"
extern PCHAR ParLegacyZipPseudoId;

#define USE_PAR3QUERYDEVICEID 1

extern LARGE_INTEGER  AcquirePortTimeout; // timeout for IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE
extern ULONG          g_NumPorts;         // used to generate N in \Device\ParallelN ClassName
extern UNICODE_STRING RegistryPath;       // copy of the registry path passed to DriverEntry()

extern ULONG DumpDevExtTable;

// Driver Globals
extern ULONG SppNoRaiseIrql; // 0  == original raise IRQL behavior in SPP
                             // !0 == new behavior - disable raise IRQL 
                             //   and insert some KeDelayExecutionThread 
                             //   calls while waiting for peripheral response

extern ULONG DefaultModes;   // Upper USHORT is Reverse Default Mode, Lower is Forward Default Mode
                             // if == 0, or invalid, then use default of Nibble/Centronics

extern ULONG WarmPollPeriod; // time between polls for printers (in seconds)

extern BOOLEAN           PowerStateIsAC;    
extern PCALLBACK_OBJECT  PowerStateCallbackObject;
extern PVOID             PowerStateCallbackRegistration;


#define PAR_NO_FAST_CALLS 1
#if PAR_NO_FAST_CALLS
VOID
ParCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

NTSTATUS
ParCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
#else
#define ParCompleteRequest(a,b) IoCompleteRequest(a,b)
#define ParCallDriver(a,b) IoCallDriver(a,b)
#endif

extern const PHYSICAL_ADDRESS PhysicalZero;

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
//
#define DEFAULT_PARALLEL_NAME L"LPT"

//
// This is the parallel class name.
//
#define DEFAULT_NT_SUFFIX L"Parallel"


#define PARALLEL_DATA_OFFSET    0
#define PARALLEL_STATUS_OFFSET  1
#define PARALLEL_CONTROL_OFFSET 2
#define PARALLEL_REGISTER_SPAN  3

//
// Ieee 1284 constants (Protocol Families)
//
#define FAMILY_NONE             0x0
#define FAMILY_REVERSE_NIBBLE   0x1
#define FAMILY_REVERSE_BYTE     0x2
#define FAMILY_ECP              0x3
#define FAMILY_EPP              0x4
#define FAMILY_BECP             0x5
#define FAMILY_MAX              FAMILY_BECP

//
// For pnp id strings
//
#define MAX_ID_SIZE 256

// used to construct IEEE 1284.3 "Dot" name suffixes 
// table lookup for integer to WCHAR conversion
#define PAR_UNICODE_PERIOD L'.'
#define PAR_UNICODE_COLON  L':'


//
// DeviceStateFlags
//
#define PAR_DEVICE_DELETED             ((ULONG)0x00000002) // IoDeleteDevice has been called
#define PAR_DEVICE_PAUSED              ((ULONG)0x00000010) // stop-pending, stopped, or remove-pending states
#define PAR_DEVICE_PORT_REMOVE_PENDING ((ULONG)0x00000200) // our ParPort is in a Remove Pending State

#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY | ECP_ANY)
#define PAR_FWD_MODE_SKIP_MASK   (EPP_ANY | BOUNDED_ECP | ECP_HW_NOIRQ | ECP_HW_IRQ)
#define PAR_MAX_CHANNEL 127
#define PAR_COMPATIBILITY_RESET 300


//
// ParClass DeviceObject structure
// 
//   - Lists the ParClass created PODO and all PDOs associated with a specific ParPort device
//
typedef struct _PAR_DEVOBJ_STRUCT {
    PUCHAR                    Controller;    // host controller address for devices in this structure
    PDEVICE_OBJECT            LegacyPodo;    // legacy or "raw" port device
    PDEVICE_OBJECT            EndOfChainPdo; // End-Of-Chain PnP device
    PDEVICE_OBJECT            Dot3Id0Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 0
    PDEVICE_OBJECT            Dot3Id1Pdo;
    PDEVICE_OBJECT            Dot3Id2Pdo;
    PDEVICE_OBJECT            Dot3Id3Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 3
    PDEVICE_OBJECT            LegacyZipPdo;  // Legacy Zip Drive
    PFILE_OBJECT              pFileObject;   // Need an open handle to ParPort device to prevent it
                                             //    from being removed out from under us
    struct _PAR_DEVOBJ_STRUCT *Next;
} PAR_DEVOBJ_STRUCT, *PPAR_DEVOBJ_STRUCT;

//
// Used in device extension for DeviceType field
//
#define PAR_DEVTYPE_FDO    0x00000001
#define PAR_DEVTYPE_PODO   0x00000002
#define PAR_DEVTYPE_PDO    0x00000004



//
// Protocol structure definitions
//

typedef
BOOLEAN
(*PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_CONNECT_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

typedef
VOID
(*PPROTOCOL_DISCONNECT_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_ENTER_FORWARD_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_EXIT_FORWARD_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_ENTER_REVERSE_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_EXIT_REVERSE_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
VOID
(*PPROTOCOL_READSHADOW_ROUTINE) (
    IN Queue *pShadowBuffer,
    IN PUCHAR  lpsBufPtr,
    IN ULONG   dCount,
    OUT ULONG *fifoCount
    );

typedef
BOOLEAN
(*PPROTOCOL_HAVEREADDATA_ROUTINE) (
    IN  PPDO_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE) (
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

typedef struct _FORWARD_PTCL {
    PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE     fnIsModeSupported;
    PPROTOCOL_CONNECT_ROUTINE               fnConnect;
    PPROTOCOL_DISCONNECT_ROUTINE            fnDisconnect;
    PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE fnSetInterfaceAddress;
    PPROTOCOL_ENTER_FORWARD_ROUTINE         fnEnterForward;
    PPROTOCOL_EXIT_FORWARD_ROUTINE          fnExitForward;
    PPROTOCOL_WRITE_ROUTINE                 fnWrite;
    USHORT                                  Protocol;
    USHORT                                  ProtocolFamily;
} FORWARD_PTCL, *PFORWARD_PTCL;

typedef struct _REVERSE_PTCL {
    PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE     fnIsModeSupported;
    PPROTOCOL_CONNECT_ROUTINE               fnConnect;
    PPROTOCOL_DISCONNECT_ROUTINE            fnDisconnect;
    PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE fnSetInterfaceAddress;
    PPROTOCOL_ENTER_REVERSE_ROUTINE         fnEnterReverse;
    PPROTOCOL_EXIT_REVERSE_ROUTINE          fnExitReverse;
    PPROTOCOL_READSHADOW_ROUTINE            fnReadShadow;
    PPROTOCOL_HAVEREADDATA_ROUTINE          fnHaveReadData;
    PPROTOCOL_READ_ROUTINE                  fnRead;
    USHORT                                  Protocol;
    USHORT                                  ProtocolFamily;
} REVERSE_PTCL, *PREVERSE_PTCL;

extern FORWARD_PTCL    afpForward[];
extern REVERSE_PTCL    arpReverse[];

//
// WARNING...Make sure that enumeration matches the protocol array...
//
typedef enum _FORWARD_MODE {

    FORWARD_FASTEST     = 0,                // 0  
    BOUNDED_ECP_FORWARD = FORWARD_FASTEST,  // 0
    ECP_HW_FORWARD_NOIRQ,                   // 1
    EPP_HW_FORWARD,                         // 2
    EPP_SW_FORWARD,                         // 3
    ECP_SW_FORWARD, //......................// 4
    IEEE_COMPAT_MODE,                       // 6
    CENTRONICS_MODE,                        // 7
    FORWARD_NONE                            // 8

} FORWARD_MODE;

typedef enum _REVERSE_MODE {

    REVERSE_FASTEST     = 0,                // 0
    BOUNDED_ECP_REVERSE = REVERSE_FASTEST,  // 0
    ECP_HW_REVERSE_NOIRQ,                   // 1
    EPP_HW_REVERSE,                         // 2
    EPP_SW_REVERSE,                         // 3
    ECP_SW_REVERSE, //......................// 4
    BYTE_MODE,                              // 5
    NIBBLE_MODE,                            // 6
    CHANNELIZED_NIBBLE_MODE,                // 7
    REVERSE_NONE                            // 8 

} REVERSE_MODE;

//
// Ieee Extensibility constants
//

#define NIBBLE_EXTENSIBILITY        0x00
#define BYTE_EXTENSIBILITY          0x01
#define CHANNELIZED_EXTENSIBILITY   0x08
#define ECP_EXTENSIBILITY           0x10
#define BECP_EXTENSIBILITY          0x18
#define EPP_EXTENSIBILITY           0x40
#define DEVICE_ID_REQ               0x04

//
// Bit Definitions in the status register.
//

#define PAR_STATUS_NOT_ERROR    0x08 //not error on device
#define PAR_STATUS_SLCT         0x10 //device is selected (on-line)
#define PAR_STATUS_PE           0x20 //paper empty
#define PAR_STATUS_NOT_ACK      0x40 //not acknowledge (data transfer was not ok)
#define PAR_STATUS_NOT_BUSY     0x80 //operation in progress

//
//  Bit Definitions in the control register.
//

#define PAR_CONTROL_STROBE      0x01 //to read or write data
#define PAR_CONTROL_AUTOFD      0x02 //to autofeed continuous form paper
#define PAR_CONTROL_NOT_INIT    0x04 //begin an initialization routine
#define PAR_CONTROL_SLIN        0x08 //to select the device
#define PAR_CONTROL_IRQ_ENB     0x10 //to enable interrupts
#define PAR_CONTROL_DIR         0x20 //direction = read
#define PAR_CONTROL_WR_CONTROL  0xc0 //the 2 highest bits of the control
                                     // register must be 1
//
// More bit definitions.
//

#define DATA_OFFSET         0
#define DSR_OFFSET          1
#define DCR_OFFSET          2

#define OFFSET_DATA     DATA_OFFSET // Put in for compatibility with legacy code
#define OFFSET_DSR      DSR_OFFSET  // Put in for compatibility with legacy code
#define OFFSET_DCR      DCR_OFFSET  // Put in for compatibility with legacy code

//
// Bit definitions for the DSR.
//

#define DSR_NOT_BUSY            0x80
#define DSR_NOT_ACK             0x40
#define DSR_PERROR              0x20
#define DSR_SELECT              0x10
#define DSR_NOT_FAULT           0x08

//
// More bit definitions for the DSR.
//

#define DSR_NOT_PTR_BUSY        0x80
#define DSR_NOT_PERIPH_ACK      0x80
#define DSR_WAIT                0x80
#define DSR_PTR_CLK             0x40
#define DSR_PERIPH_CLK          0x40
#define DSR_INTR                0x40
#define DSR_ACK_DATA_REQ        0x20
#define DSR_NOT_ACK_REVERSE     0x20
#define DSR_XFLAG               0x10
#define DSR_NOT_DATA_AVAIL      0x08
#define DSR_NOT_PERIPH_REQUEST  0x08

//
// Bit definitions for the DCR.
//

#define DCR_RESERVED            0xC0
#define DCR_DIRECTION           0x20
#define DCR_ACKINT_ENABLED      0x10
#define DCR_SELECT_IN           0x08
#define DCR_NOT_INIT            0x04
#define DCR_AUTOFEED            0x02
#define DCR_STROBE              0x01

//
// More bit definitions for the DCR.
//

#define DCR_NOT_1284_ACTIVE     0x08
#define DCR_ASTRB               0x08
#define DCR_NOT_REVERSE_REQUEST 0x04
#define DCR_NOT_HOST_BUSY       0x02
#define DCR_NOT_HOST_ACK        0x02
#define DCR_DSTRB               0x02
#define DCR_NOT_HOST_CLK        0x01
#define DCR_WRITE               0x01

#define DCR_NEUTRAL (DCR_RESERVED | DCR_SELECT_IN | DCR_NOT_INIT)

//
// Give a timeout of 300 seconds.  Some postscript printers will
// buffer up a lot of commands then proceed to render what they
// have.  The printer will then refuse to accept any characters
// until it's done with the rendering.  This render process can
// take a while.  We'll give it 300 seconds.
//
// Note that an application can change this value.
//
#define PAR_WRITE_TIMEOUT_VALUE 300


#ifdef JAPAN // IBM-J printers

//
// Support for IBM-J printers.
//
// When the printer operates in Japanese (PS55) mode, it redefines
// the meaning of parallel lines so that extended error status can
// be reported.  It is roughly compatible with PC/AT, but we have to
// take care of a few cases where the status looks like PC/AT error
// condition.
//
// Status      Busy /AutoFdXT Paper Empty Select /Fault
// ------      ---- --------- ----------- ------ ------
// Not RMR      1    1         1           1      1
// Head Alarm   1    1         1           1      0
// ASF Jam      1    1         1           0      0
// Paper Empty  1    0         1           0      0
// No Error     0    0         0           1      1
// Can Req      1    0         0           0      1
// Deselect     1    0         0           0      0
//
// The printer keeps "Not RMR" during the parallel port
// initialization, then it takes "Paper Empty", "No Error"
// or "Deselect".  Other status can be thought as an
// H/W error condition.
//
// Namely, "Not RMR" conflicts with PAR_NO_CABLE and "Deselect"
// should also be regarded as another PAR_OFF_LINE.  When the
// status is PAR_PAPER_EMPTY, the initialization is finished
// (we should not send init purlse again.)
//
// See ParInitializeDevice() for more information.
//
// [takashim]

#define PAR_OFF_LINE_COMMON( Status ) ( \
            (IsNotNEC_98) ? \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            !(Status & PAR_STATUS_SLCT) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            !(Status & PAR_STATUS_SLCT) \
             )

#define PAR_OFF_LINE_IBM55( Status ) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            ((Status & PAR_STATUS_SLCT) ^ PAR_STATUS_SLCT) && \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR))

#define PAR_PAPER_EMPTY2( Status ) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_PE) && \
            ((Status & PAR_STATUS_SLCT) ^ PAR_STATUS_SLCT) && \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR))

//
// Redefine this for Japan.
//

#define PAR_OFF_LINE( Status ) ( \
            PAR_OFF_LINE_COMMON( Status ) || \
            PAR_OFF_LINE_IBM55( Status ))

#else // JAPAN
//
// Busy, not select, not error
//
// !JAPAN

#define PAR_OFF_LINE( Status ) ( \
            (IsNotNEC_98) ? \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            !(Status & PAR_STATUS_SLCT) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            !(Status & PAR_STATUS_SLCT) \
            )

#endif // JAPAN

//
// Busy, PE
//

#define PAR_PAPER_EMPTY( Status ) ( \
            (Status & PAR_STATUS_PE) )

//
// error, ack, not busy
//

#define PAR_POWERED_OFF( Status ) ( \
            (IsNotNEC_98) ? \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_ACK) ^ PAR_STATUS_NOT_ACK) && \
            (Status & PAR_STATUS_NOT_BUSY) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            (Status & PAR_STATUS_NOT_ACK) && \
            (Status & PAR_STATUS_NOT_BUSY) \
            )

//
// not error, not busy, not select
//

#define PAR_NOT_CONNECTED( Status ) ( \
            (Status & PAR_STATUS_NOT_ERROR) && \
            (Status & PAR_STATUS_NOT_BUSY) &&\
            !(Status & PAR_STATUS_SLCT) )

//
// not error, not busy
//

#define PAR_OK(Status) ( \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            (Status & PAR_STATUS_NOT_BUSY) )

//
// busy, select, not error
//

#define PAR_POWERED_ON(Status) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_SLCT) && \
            (Status & PAR_STATUS_NOT_ERROR))

//
// busy, not error
//

#define PAR_BUSY(Status) (\
             (( Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
             ( Status & PAR_STATUS_NOT_ERROR ) )

//
// selected
//

#define PAR_SELECTED(Status) ( \
            ( Status & PAR_STATUS_SLCT ) )

//
// No cable attached.
//

#define PAR_NO_CABLE(Status) ( \
            (IsNotNEC_98) ?                                           \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_NOT_ACK) &&                          \
            (Status & PAR_STATUS_PE) &&                               \
            (Status & PAR_STATUS_SLCT) &&                             \
            (Status & PAR_STATUS_NOT_ERROR) :                         \
                                                                      \
            (Status & PAR_STATUS_NOT_BUSY) &&                         \
            (Status & PAR_STATUS_NOT_ACK) &&                          \
            (Status & PAR_STATUS_PE) &&                               \
            (Status & PAR_STATUS_SLCT) &&                             \
            (Status & PAR_STATUS_NOT_ERROR)                           \
            )

//
// not error, not busy, selected.
//

#define PAR_ONLINE(Status) (                              \
            (Status & PAR_STATUS_NOT_ERROR) &&            \
            (Status & PAR_STATUS_NOT_BUSY) &&             \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            (Status & PAR_STATUS_SLCT) )


//BOOLEAN
//ParCompareGuid(
//  IN LPGUID guid1,
//  IN LPGUID guid2
//  )
//
#define ParCompareGuid(g1, g2)  (                                    \
        ( (g1) == (g2) ) ?                                           \
        TRUE :                                                       \
        RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
        )


//VOID StoreData(
//      IN PUCHAR RegisterBase,
//      IN UCHAR DataByte
//      )
// Data must be on line before Strobe = 1;
// Strobe = 1, DIR = 0
// Strobe = 0
//
// We change the port direction to output (and make sure stobe is low).
//
// Note that the data must be available at the port for at least
// .5 microseconds before and after you strobe, and that the strobe
// must be active for at least 500 nano seconds.  We are going
// to end up stalling for twice as much time as we need to, but, there
// isn't much we can do about that.
//
// We put the data into the port and wait for 1 micro.
// We strobe the line for at least 1 micro
// We lower the strobe and again delay for 1 micro
// We then revert to the original port direction.
//
// Thanks to Olivetti for advice.
//

#define StoreData(RegisterBase,DataByte)                            \
{                                                                   \
    PUCHAR _Address = RegisterBase;                                 \
    UCHAR _Control;                                                 \
    _Control = GetControl(_Address);                                \
    ASSERT(!(_Control & PAR_CONTROL_STROBE));                       \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(PAR_CONTROL_STROBE | PAR_CONTROL_DIR)) \
        );                                                          \
    P5WritePortUchar(                                               \
        _Address+PARALLEL_DATA_OFFSET,                              \
        (UCHAR)DataByte                                             \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)((_Control | PAR_CONTROL_STROBE) & ~PAR_CONTROL_DIR) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(PAR_CONTROL_STROBE | PAR_CONTROL_DIR)) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)_Control                                             \
        );                                                          \
}

//
// Function prototypes
//

//
// parpnp.c
//
#ifndef STATIC_LOAD

NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
ParParallelPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParCheckParameters(
    IN OUT  PPDO_EXTENSION   Extension
    );

#endif

//
// oldinit.c
//

#ifdef STATIC_LOAD

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParInitializeClassDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  ULONG           ParallelPortNumber
    );

VOID
ParCheckParameters(
    IN      PUNICODE_STRING     RegistryPath,
    IN OUT  PPDO_EXTENSION   Extension
    );

#endif

//
// parclass.c
//

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
PptPdoReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PPDO_EXTENSION  Extension,
	IN USHORT             ModeMaskFwd,
	IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
	IN BOOLEAN            IsForward
    );

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PPDO_EXTENSION   Extension
    );

//////////////////////////////////////////////////////////////////
//  Modes of operation
//////////////////////////////////////////////////////////////////

//
// spp.c
//

NTSTATUS
ParEnterSppMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    );

ULONG
SppCheckBusyDelay(
    IN  PPDO_EXTENSION   Extension,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    );

NTSTATUS
SppWrite(
    IN  PPDO_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

VOID
ParTerminateSppMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
SppQueryDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR              DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    );

//
// sppieee.c
//
NTSTATUS
SppIeeeWrite(
    IN  PPDO_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

//
// nibble.c
//

BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
BOOLEAN
ParIsNibbleSupported(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEnterNibbleMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateNibbleMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParNibbleModeRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// Byte.c
//

BOOLEAN
ParIsByteSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterByteMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateByteMode(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParByteModeRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// epp.c
//

NTSTATUS
ParEppSetAddress(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

//
// hwepp.c
//

BOOLEAN
ParIsEppHwSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppHwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

VOID
ParTerminateEppHwMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEppHwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppHwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// swepp.c
//

BOOLEAN
ParIsEppSwWriteSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
BOOLEAN
ParIsEppSwReadSupported(
    IN  PPDO_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppSwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateEppSwMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEppSwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppSwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// ecp.c and swecp.c
//

NTSTATUS
ParEcpEnterForwardPhase (
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN
ParEcpHaveReadData (
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PPDO_EXTENSION   Extension
    );

BOOLEAN
ParIsEcpSwReadSupported(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEnterEcpSwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

VOID 
ParCleanupSwEcpPort(
    IN  PPDO_EXTENSION   Extension
    );
    
VOID
ParTerminateEcpMode(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpSetAddress(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

NTSTATUS
ParEcpSwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpSwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpForwardToReverse(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpReverseToForward(
    IN  PPDO_EXTENSION   Extension
    );

//
// hwecp.c
//

BOOLEAN
PptEcpHwHaveReadData (
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwExitForwardPhase (
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
PptEcpHwEnterReversePhase (
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwExitReversePhase (
    IN  PPDO_EXTENSION   Extension
    );

VOID
PptEcpHwDrainShadowBuffer(IN Queue *pShadowBuffer,
                            IN PUCHAR  lpsBufPtr,
                            IN ULONG   dCount,
                            OUT ULONG *fifoCount);

NTSTATUS
ParEcpHwRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpHwWrite(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpHwSetAddress(
    IN  PPDO_EXTENSION   Extension,
    IN  UCHAR               Address
    );

NTSTATUS
ParEnterEcpHwMode(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

BOOLEAN
ParIsEcpHwSupported(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwSetupPhase(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParTerminateHwEcpMode(
    IN  PPDO_EXTENSION   Extension
    );

//
// becp.c
//

NTSTATUS
PptBecpExitReversePhase(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
PptBecpRead(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
PptEnterBecpMode(
    IN  PPDO_EXTENSION  Extension,
    IN  BOOLEAN         DeviceIdRequest
    );

BOOLEAN
PptIsBecpSupported(
    IN  PPDO_EXTENSION   Extension
    );
VOID
PptTerminateBecpMode(
    IN  PPDO_EXTENSION   Extension
    );

//
// p12843dl.c
//
NTSTATUS
ParDot3Connect(
    IN  PPDO_EXTENSION    Extension
    );

VOID
ParDot3CreateObject(
    IN  PPDO_EXTENSION   Extension,
    IN PCHAR DOT3DL,
    IN PCHAR DOT3C
    );

VOID
ParDot4CreateObject(
    IN  PPDO_EXTENSION   Extension,
    IN  PCHAR DOT4DL
    );

VOID
ParDot3ParseModes(
    IN  PPDO_EXTENSION   Extension,
    IN  PCHAR DOT3M
    );

VOID
ParMLCCreateObject(
    IN  PPDO_EXTENSION   Extension,
    IN PCHAR CMDField
    );

VOID
ParDot3DestroyObject(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParDot3Disconnect(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParDot3Read(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParDot3Write(
    IN  PPDO_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParMLCCompatReset(
    IN  PPDO_EXTENSION   Extension
    );

NTSTATUS
ParMLCECPReset(
    IN  PPDO_EXTENSION   Extension
    );

#if DBG
VOID
ParInitDebugLevel (
    IN PUNICODE_STRING RegistryPath
   );
#endif

// former parclass.h preceeds

#endif // _PARPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdocreate.c ===
#include "pch.h"

NTSTATUS
PptPdoCreateOpen(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
    )
{
    NTSTATUS        status;
    PPDO_EXTENSION  pdx      = Pdo->DeviceExtension;

    // bail out if a delete is pending for this device object
    if(pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    // bail out if device has been removed
    if(pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, 0 );
    }

    // bail out if caller is confused and thinks that we are a directory
    if( IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE ) {
        return P4CompleteRequest( Irp, STATUS_NOT_A_DIRECTORY, 0 );
    }

    // this is an exclusive access device - fail IRP if we are already open
    ExAcquireFastMutex(&pdx->OpenCloseMutex);
    if( InterlockedIncrement( &pdx->OpenCloseRefCount ) != 1 ) {
        InterlockedDecrement( &pdx->OpenCloseRefCount );
        ExReleaseFastMutex( &pdx->OpenCloseMutex );
        return P4CompleteRequest( Irp, STATUS_ACCESS_DENIED, 0 );
    }
    ExReleaseFastMutex(&pdx->OpenCloseMutex);

    PptPdoGetPortInfoFromFdo( Pdo );

    //
    // Set the default ieee1284 modes
    //
    ParInitializeExtension1284Info( pdx );

    // used to pause worker thread when we enter a "Hold Requests" state due to PnP requests
    KeInitializeEvent( &pdx->PauseEvent, NotificationEvent, TRUE );

    // set to TRUE to tell worker thread to kill itself
    pdx->TimeToTerminateThread = FALSE;

    // we are an exclusive access device - we should not already have a worker thread
    PptAssert( !pdx->ThreadObjectPointer );

    // dispatch routines signal worker thread on this semaphore when there is work for worker thread to do
    KeInitializeSemaphore(&pdx->RequestSemaphore, 0, MAXLONG);

    // create worker thread to handle serialized requests at Passive Level IRQL
    status = ParCreateSystemThread( pdx );
    if( status != STATUS_SUCCESS ) {
        DD((PCE)pdx,DDW,"PptPdoCreateOpen - FAIL worker thread creation\n");
        ExAcquireFastMutex( &pdx->OpenCloseMutex );
        InterlockedDecrement( &pdx->OpenCloseRefCount );
        if( pdx->OpenCloseRefCount < 0 ) {
            pdx->OpenCloseRefCount = 0;
        }
        ExReleaseFastMutex( &pdx->OpenCloseMutex );
    } else {
        DD((PCE)pdx,DDT,"PptPdoCreateOpen - SUCCESS\n");
    }

    return P4CompleteRequest( Irp, status, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdoioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

File Name:

    ioctl.c

Contained in Module:

    parallel.sys

Abstract:

    This file contains functions associated with ParClass IOCTL processing.

    - The three main entry points in this file are:

      - ParDeviceControl()          - Dispatch function for non-internal IOCTLs

      - ParInternalDeviceControl()  - Dispatch function for internal IOCTLs

      - ParDeviceIo()               - Worker thread entry point for handling all 
                                        IOCTLs not completed in a dispatch function

    - Helper/Utility function naming conventions:
 
      - ParpIoctlDispatch...()      - private helper function called by dispatch function

      - ParpIoctlThread...()        - private helper function called by worker thread

Authors:

    Anthony V. Ercolano  1-Aug-1992
    Norbert P. Kusters  22-Oct-1993
    Douglas G. Fritz    24-Jul-1998

Revision History :

--*/

#include "pch.h"


VOID
ParpIoctlThreadLockPort(
    IN PPDO_EXTENSION Pdx
    )
{
    NTSTATUS status;
    PIRP     irp = Pdx->CurrentOpIrp;

    DD((PCE)Pdx,DDT,"ParpIoctlThreadLockPort - enter\n");

    if( ParSelectDevice(Pdx,TRUE) ) {
        DD((PCE)Pdx,DDT,"ParpIoctlThreadLockPort - SUCCESS\n");
        Pdx->AllocatedByLockPort = TRUE;
        status = STATUS_SUCCESS;
    } else {
        DD((PCE)Pdx,DDW,"ParpIoctlThreadLockPort - FAIL\n");
        Pdx->AllocatedByLockPort = FALSE;
        status = STATUS_UNSUCCESSFUL;
    }    
    
    irp->IoStatus.Status = status;
}

VOID
ParpIoctlThreadUnlockPort(
    IN PPDO_EXTENSION Pdx
    )
{
    PIRP     irp = Pdx->CurrentOpIrp;

    Pdx->AllocatedByLockPort = FALSE;

    DD((PCE)Pdx,DDT,"ParpIoctlThreadUnlockPort - enter\n");
    
    if( ParDeselectDevice(Pdx, FALSE) ) {
        DD((PCE)Pdx,DDT,"ParpIoctlThreadUnlockPort - SUCCESS\n");
    } else {
        DD((PCE)Pdx,DDW,"ParpIoctlThreadUnlockPort - FAIL - nothing we can do\n");
    }
    
    irp->IoStatus.Status = STATUS_SUCCESS;
}

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.
    STATUS_DELETE_PENDING       - This device object is being deleted

--*/

{
    PPDO_EXTENSION        Pdx = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION    IrpSp     = IoGetCurrentIrpStackLocation( Irp );
    PPAR_SET_INFORMATION  SetInfo;
    NTSTATUS              Status;
    PSERIAL_TIMEOUTS      SerialTimeouts;
    KIRQL                 OldIrql;

    Irp->IoStatus.Information = 0;

    //
    // bail out if a delete is pending for this device object
    //
    if(Pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Pdx->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, 0 );
    }

    //
    // bail out if device has been removed
    //
    if(Pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, 0 );
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_PAR_QUERY_LOCATION:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_LOCATION\n");
        {
            ULONG  outBufLen   = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            ULONG  locationLen = strlen(Pdx->Location);

            if( outBufLen < locationLen+1 ) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                PCHAR buffer = (PCHAR)Irp->AssociatedIrp.SystemBuffer;
                RtlCopyMemory( buffer, Pdx->Location, locationLen + 1 );
                Irp->IoStatus.Information = locationLen + 1;
                Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_SET_INFORMATION:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_SET_INFORMATION\n");

        SetInfo = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PAR_SET_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else if (SetInfo->Init != PARALLEL_INIT) {
            
            Status = STATUS_INVALID_PARAMETER;
            
        } else {
            
            //
            // This is a parallel reset
            //
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_QUERY_INFORMATION :
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_INFORMATION\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PAR_QUERY_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_SERIAL_SET_TIMEOUTS:
        
        DD((PCE)Pdx,DDT,"IOCTL_SERIAL_SET_TIMEOUTS\n");
        
        SerialTimeouts = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else if (SerialTimeouts->WriteTotalTimeoutConstant < 2000) {
            
            Status = STATUS_INVALID_PARAMETER;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_SERIAL_GET_TIMEOUTS:
        
        DD((PCE)Pdx,DDT,"IOCTL_SERIAL_GET_TIMEOUTS\n");
        
        SerialTimeouts = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            //
            // We don't need to synchronize the read.
            //
            
            RtlZeroMemory(SerialTimeouts, sizeof(SERIAL_TIMEOUTS));
            SerialTimeouts->WriteTotalTimeoutConstant =
                1000 * Pdx->TimerStart;
            
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_PAR_QUERY_DEVICE_ID:
    case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_[RAW_]DEVICE_ID\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == 0) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_DEVICE_ID_SIZE\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PAR_DEVICE_ID_SIZE_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_IS_PORT_FREE:
        
        DD((PCE)Pdx,DDT,"IOCTL_PAR_IS_PORT_FREE\n");
        
        if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(BOOLEAN) ) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else {

            if( Pdx->bAllocated ) {
                // if we have the port then it is not free
                *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = FALSE;
            } else {
                // determine if the port is free by trying to allocate and free it
                //  - our alloc/free will only succeed if no one else has the port
                BOOLEAN tryAllocSuccess = Pdx->TryAllocatePort( Pdx->PortContext );
                if( tryAllocSuccess ) {
                    // we were able to allocate the port, free it and report that the port is free
                    Pdx->FreePort( Pdx->PortContext );
                    *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = TRUE;
                } else {
                    // we were unable to allocate the port, someone else must be using the port
                    *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = FALSE; 
                }
            }

            Irp->IoStatus.Information = sizeof(BOOLEAN);
            Status = STATUS_SUCCESS;

        }
        break;

    case IOCTL_PAR_GET_READ_ADDRESS:

        DD((PCE)Pdx,DDT,"IOCTL_PAR_GET_READ_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(Pdx->ReverseInterfaceAddress)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            *((PUCHAR) Irp->AssociatedIrp.SystemBuffer) = Pdx->ReverseInterfaceAddress;
            Irp->IoStatus.Information = sizeof(Pdx->ReverseInterfaceAddress);
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_GET_WRITE_ADDRESS:

        DD((PCE)Pdx,DDT,"IOCTL_PAR_GET_WRITE_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(Pdx->ForwardInterfaceAddress)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            *((PUCHAR) Irp->AssociatedIrp.SystemBuffer) = Pdx->ForwardInterfaceAddress;
            Irp->IoStatus.Information = sizeof(Pdx->ForwardInterfaceAddress);
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_SET_READ_ADDRESS:
    
        DD((PCE)Pdx,DDT,"  IOCTL_PAR_SET_READ_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Pdx->ReverseInterfaceAddress)) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_SET_WRITE_ADDRESS:

        DD((PCE)Pdx,DDT,"  IOCTL_PAR_SET_WRITE_ADDRESS\n");
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Pdx->ForwardInterfaceAddress)) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_IEEE1284_GET_MODE:
        
        DD((PCE)Pdx,DDT,"IOCTL_IEEE1284_GET_MODE\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {

            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            ppnmMask->usReadMask  = arpReverse[Pdx->IdxReverseProtocol].Protocol;
            ppnmMask->usWriteMask = afpForward[Pdx->IdxForwardProtocol].Protocol;
            
            Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_GET_DEFAULT_MODES:
        
        DD((PCE)Pdx,DDT,"IOCTL_IEEE1284_GET_MODE\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            
            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            ppnmMask->usReadMask  = NONE;            
            ppnmMask->usWriteMask = CENTRONICS;
            
            Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_ECP_HOST_RECOVERY:

        DD((PCE)Pdx,DDT,"IOCTL_PAR_ECP_HOST_RECOVERY\n");
        {
            BOOLEAN *isSupported;

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(BOOLEAN) ) {
                Status = STATUS_INVALID_PARAMETER;                
            } else {
                isSupported = (BOOLEAN *)Irp->AssociatedIrp.SystemBuffer;
                Pdx->bIsHostRecoverSupported = *isSupported;
                Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_PING:
        DD((PCE)Pdx,DDT,"IOCTL_PAR_PING\n");
        // No Parms to check!
        Status = STATUS_PENDING;        
        break;

    case IOCTL_PAR_GET_DEVICE_CAPS:
        DD((PCE)Pdx,DDT,"IOCTL_PAR_GET_DEVICE_CAPS\n");
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(Pdx->ProtocolModesSupported)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_IEEE1284_NEGOTIATE:
        
        DD((PCE)Pdx,DDT,"IOCTL_IEEE1284_NEGOTIATE\n");
        
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength  < sizeof(PARCLASS_NEGOTIATION_MASK) ||
             IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK) ) {

            DD((PCE)Pdx,DDW,"ParDeviceControl: IOCTL_IEEE1284_NEGOTIATE STATUS_INVALID_PARAMETER\n");
            Status = STATUS_INVALID_PARAMETER;

        } else {

            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            if ((ppnmMask->usReadMask  == arpReverse[Pdx->IdxReverseProtocol].Protocol) &&
                (ppnmMask->usWriteMask == afpForward[Pdx->IdxForwardProtocol].Protocol)) {
                Irp->IoStatus.Information = sizeof(PARCLASS_NEGOTIATION_MASK);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_PENDING;
            }
        }
        break;

    default :

        DD((PCE)Pdx,DDT,"IOCTL default case\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    if (Status == STATUS_PENDING) {
        
        IoAcquireCancelSpinLock(&OldIrql);
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock(OldIrql);
            Status = STATUS_CANCELLED;
            
        } else {
            
            //
            // This IRP takes more time, so it should be queued.
            //
            BOOLEAN needToSignalSemaphore = IsListEmpty( &Pdx->WorkQueue ) ? TRUE: FALSE;
            IoMarkIrpPending(Irp);

#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(Irp, ParCancelRequest);
#pragma warning( pop ) 

            InsertTailList(&Pdx->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE);
            }
        }
    }
    
    if (Status != STATUS_PENDING) {
        P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
    }

    return Status;
}

NTSTATUS
ParInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for internal device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.
    STATUS_DELETE_PENDING       - This device object is being deleted

--*/

{
    PIO_STACK_LOCATION              IrpSp;
    // PPAR_SET_INFORMATION            SetInfo;
    NTSTATUS                        Status;
    // PSERIAL_TIMEOUTS                SerialTimeouts;
    PPDO_EXTENSION               Pdx;
    KIRQL                           OldIrql;
    PPARCLASS_INFORMATION           pParclassInfo;

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Pdx = DeviceObject->DeviceExtension;

    //
    // bail out if a delete is pending for this device object
    //
    if(Pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Pdx->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if device has been removed
    //
    if(Pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );
        return STATUS_DEVICE_REMOVED;
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_INTERNAL_PARCLASS_CONNECT:
        
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARCLASS_CONNECT\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            PFDO_EXTENSION              fdx      = Pdx->Fdo->DeviceExtension;
            PPARALLEL_PORT_INFORMATION  portInfo = &fdx->PortInfo;
            PPARALLEL_PNP_INFORMATION   pnpInfo  = &fdx->PnpInfo;

            pParclassInfo = Irp->AssociatedIrp.SystemBuffer;
            
            pParclassInfo->ParclassContext       = Pdx;
            pParclassInfo->Controller            = portInfo->Controller;
            pParclassInfo->SpanOfController      = portInfo->SpanOfController;
            pParclassInfo->EcrController         = pnpInfo->EcpController;
            pParclassInfo->HardwareCapabilities  = pnpInfo->HardwareCapabilities;
            pParclassInfo->FifoDepth             = pnpInfo->FifoDepth;
            pParclassInfo->FifoWidth             = pnpInfo->FifoWidth;
            pParclassInfo->DetermineIeeeModes    = ParExportedDetermineIeeeModes;
            pParclassInfo->TerminateIeeeMode     = ParExportedTerminateIeeeMode;
            pParclassInfo->NegotiateIeeeMode     = ParExportedNegotiateIeeeMode;
            pParclassInfo->IeeeFwdToRevMode      = ParExportedIeeeFwdToRevMode;
            pParclassInfo->IeeeRevToFwdMode      = ParExportedIeeeRevToFwdMode;
            pParclassInfo->ParallelRead          = ParExportedParallelRead;
            pParclassInfo->ParallelWrite         = ParExportedParallelWrite;
            
            Irp->IoStatus.Information = sizeof(PARCLASS_INFORMATION);
            
            Status = STATUS_SUCCESS;
        }
        
        break;
        
    case IOCTL_INTERNAL_GET_PARPORT_FDO:

        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_GET_PARPORT_FDO\n");
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PDEVICE_OBJECT)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {

            PDEVICE_OBJECT *pFdo = Irp->AssociatedIrp.SystemBuffer;
            *pFdo = Pdx->Fdo;
            Irp->IoStatus.Information = sizeof(PDEVICE_OBJECT);
            
            Status = STATUS_SUCCESS;
        }
        
        break;

    case IOCTL_INTERNAL_PARCLASS_DISCONNECT:
        
        Status = STATUS_SUCCESS;
        break;
        
    case IOCTL_INTERNAL_DISCONNECT_IDLE:
    case IOCTL_INTERNAL_LOCK_PORT:
    case IOCTL_INTERNAL_UNLOCK_PORT:
    case IOCTL_INTERNAL_LOCK_PORT_NO_SELECT:
    case IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT:
    case IOCTL_INTERNAL_PARDOT3_CONNECT:
    case IOCTL_INTERNAL_PARDOT3_RESET:
    
        Status = STATUS_PENDING;
        break;

    case IOCTL_INTERNAL_PARDOT3_DISCONNECT:

        // immediately tell worker thread to stop signalling
        Pdx->P12843DL.bEventActive = FALSE;
        Status = STATUS_PENDING;
        break;

    case IOCTL_INTERNAL_PARDOT3_SIGNAL:
    
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PKEVENT) ) {
            Status = STATUS_INVALID_PARAMETER;                
        } else {
            Status = STATUS_PENDING;
        }
        break;

    default :

        DD((PCE)Pdx,DDW,"IOCTL_INTERNAL... default case - invalid parameter\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    

    if (Status == STATUS_PENDING) {
        
        //
        // This IRP takes more time, queue it for the worker thread
        //

        IoAcquireCancelSpinLock(&OldIrql);
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock(OldIrql);
            Status = STATUS_CANCELLED;
            
        } else {
            
            BOOLEAN needToSignalSemaphore = IsListEmpty( &Pdx->WorkQueue ) ? TRUE : FALSE;
            IoMarkIrpPending(Irp);
#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(Irp, ParCancelRequest);
#pragma warning( pop ) 
            InsertTailList(&Pdx->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE);
            }
        }
    }
    
    if (Status != STATUS_PENDING) {
        P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
    }

    return Status;
}

VOID
ParDeviceIo(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine implements a DEVICE_IOCTL request with the extension's current irp.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{

    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   IdLength;
    NTSTATUS                NtStatus;
    UCHAR                   Status;
    UCHAR                   Control;
    ULONG                   ioControlCode;

    Irp     = Pdx->CurrentOpIrp;
    IrpSp   = IoGetCurrentIrpStackLocation(Irp);

    ioControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch( ioControlCode ) {

    case IOCTL_PAR_SET_INFORMATION : 
        {

            Status = ParInitializeDevice(Pdx);
            
            if (!PAR_OK(Status)) {
                ParNotInitError(Pdx, Status); // Set the IoStatus.Status of the CurrentOpIrp appropriately
            } else {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_QUERY_INFORMATION :
        {
            PPAR_QUERY_INFORMATION IrpBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            Status  = GetStatus(Pdx->Controller);
            Control = GetControl(Pdx->Controller);

            // Interpretating Status & Control
            
            IrpBuffer->Status = 0x0;

            if (PAR_POWERED_OFF(Status) || PAR_NO_CABLE(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_POWER_OFF);
                
            } else if (PAR_PAPER_EMPTY(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_PAPER_EMPTY);
                
            } else if (PAR_OFF_LINE(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_OFF_LINE);
                
            } else if (PAR_NOT_CONNECTED(Status)) {

                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_NOT_CONNECTED);

            }
            
            if (PAR_BUSY(Status)) {
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_BUSY);
            }
            
            if (PAR_SELECTED(Status)) {
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_SELECTED);
            }
            
            Irp->IoStatus.Information = sizeof( PAR_QUERY_INFORMATION );
        }
        break;

    case IOCTL_PAR_QUERY_RAW_DEVICE_ID :

        // We always read the Device Id in Nibble Mode.
        NtStatus = SppQueryDeviceId(Pdx,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    &IdLength, TRUE);

        Irp->IoStatus.Status = NtStatus;

        if (NT_SUCCESS(NtStatus)) {
            Irp->IoStatus.Information = IdLength;
        } else {
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID :

        // We always read the Device Id in Nibble Mode.
        NtStatus = SppQueryDeviceId(Pdx,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    &IdLength, FALSE);

        Irp->IoStatus.Status = NtStatus;

        if( NT_SUCCESS( NtStatus ) ) {
            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_ID - SUCCESS - size = %d\n", IdLength);
            // Include terminating NULL in the string to copy back to user buffer
            Irp->IoStatus.Information = IdLength + sizeof(CHAR);
        } else if( NtStatus == STATUS_BUFFER_TOO_SMALL) {
            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_ID - FAIL - BUFFER_TOO_SMALL - supplied= %d, required=%d\n",
                                 IrpSp->Parameters.DeviceIoControl.OutputBufferLength, IdLength);
            Irp->IoStatus.Information = 0;
        } else {
            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_ID - FAIL - QUERY ID FAILED\n");
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID_SIZE :

        //
        // Read the first two bytes of the Nibble Id, add room for the terminating NULL and
        // return this to the caller.
        //
        NtStatus = SppQueryDeviceId(Pdx, NULL, 0, &IdLength, FALSE);

        if (NtStatus == STATUS_BUFFER_TOO_SMALL) {

            DD((PCE)Pdx,DDT,"IOCTL_PAR_QUERY_DEVICE_ID_SIZE - size required = %d\n", IdLength);

            Irp->IoStatus.Status = STATUS_SUCCESS;

            Irp->IoStatus.Information =
                sizeof(PAR_DEVICE_ID_SIZE_INFORMATION);

            // include space for terminating NULL
            ((PPAR_DEVICE_ID_SIZE_INFORMATION)
                Irp->AssociatedIrp.SystemBuffer)->DeviceIdSize = IdLength + sizeof(CHAR);

        } else {

            Irp->IoStatus.Status      = NtStatus;
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_PING :

        // We need to do a quick terminate and negotiate of the current modes
        NtStatus = ParPing(Pdx);
        DD((PCE)Pdx,DDT,"ParDeviceIo:IOCTL_PAR_PING\n");
        Irp->IoStatus.Status      = NtStatus;
        Irp->IoStatus.Information = 0;
        break;
        
    case IOCTL_INTERNAL_DISCONNECT_IDLE :

        if ((Pdx->Connected) &&
            (afpForward[Pdx->IdxForwardProtocol].fnDisconnect)) {
            
            DD((PCE)Pdx,DDT,"ParDeviceIo:IOCTL_INTERNAL_DISCONNECT_IDLE: Calling afpForward.fnDisconnect\n");
            afpForward[Pdx->IdxForwardProtocol].fnDisconnect (Pdx);
        }
        
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_IEEE1284_NEGOTIATE:
        {
            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;

            ParTerminate(Pdx);
            Irp->IoStatus.Status = IeeeNegotiateMode(Pdx, ppnmMask->usReadMask, ppnmMask->usWriteMask);

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(PARCLASS_NEGOTIATION_MASK)) {
                DD((PCE)Pdx,DDT, "ParDeviceIo: IOCTL_IEEE1284_NEGOTIATE Passed.\n");
                ppnmMask->usReadMask  = arpReverse[Pdx->IdxReverseProtocol].Protocol;
                ppnmMask->usWriteMask = afpForward[Pdx->IdxForwardProtocol].Protocol;
                Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            } else {
                DD((PCE)Pdx,DDT, "ParDeviceIo: IOCTL_IEEE1284_NEGOTIATE failed.\n");
                Irp->IoStatus.Information = 0;
            }
        }
        break;

    case IOCTL_PAR_GET_DEVICE_CAPS :

        Pdx->BadProtocolModes = *((USHORT *) Irp->AssociatedIrp.SystemBuffer);            
        IeeeDetermineSupportedProtocols(Pdx);
        *((USHORT *) Irp->AssociatedIrp.SystemBuffer) = Pdx->ProtocolModesSupported;
        Irp->IoStatus.Information = sizeof(Pdx->ProtocolModesSupported);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    case IOCTL_PAR_SET_READ_ADDRESS:
        {
            PUCHAR pAddress = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            
            if (Pdx->ReverseInterfaceAddress != *pAddress) {
                
                Pdx->ReverseInterfaceAddress = *pAddress;
                Pdx->SetReverseAddress = TRUE;
            }
            
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_SET_WRITE_ADDRESS :
        {
            PUCHAR pAddress = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            NtStatus = STATUS_SUCCESS;

            if (Pdx->ForwardInterfaceAddress != *pAddress) {
        
                Pdx->ForwardInterfaceAddress = *pAddress;
                
                if (Pdx->Connected) {
                    if (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress) {
                        
                        if (Pdx->CurrentPhase != PHASE_FORWARD_IDLE &&
                            Pdx->CurrentPhase != PHASE_FORWARD_XFER) {
                            NtStatus = ParReverseToForward(Pdx);
                        }
                        
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus  = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress(
                                Pdx,
                                Pdx->ForwardInterfaceAddress
                                );
                        }
                        
                        if (NT_SUCCESS(NtStatus)) {
                            Pdx->SetForwardAddress = FALSE;
                            Pdx->SetReverseAddress = FALSE;
                            Pdx->ReverseInterfaceAddress = *pAddress;
                        } else {
                            Pdx->SetForwardAddress = TRUE;
                            DD((PCE)Pdx,DDE,"ParDeviceIo: IOCTL_PAR_SET_WRITE_ADDRESS Failed\n");
                        }
                    } else {
                        DD((PCE)Pdx,DDE, "ParDeviceIo: Someone called IOCTL_PAR_SET_WRITE_ADDRESS.\n");
                        DD((PCE)Pdx,DDE, "ParDeviceIo: You don't have a fnSetInterfaceAddress.\n");
                        DD((PCE)Pdx,DDE, "ParDeviceIo: Either IEEE1284.c has wrong info or your caller is in error!\n");
                        NtStatus = STATUS_UNSUCCESSFUL;
                    }    
                } else {
                    Pdx->SetForwardAddress = TRUE;
                }
            }
            
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = NtStatus;
        }
        break;

    case IOCTL_INTERNAL_LOCK_PORT :

        ParpIoctlThreadLockPort(Pdx);
        break;

    case IOCTL_INTERNAL_UNLOCK_PORT :

        ParpIoctlThreadUnlockPort(Pdx);
        break;
        
    case IOCTL_INTERNAL_LOCK_PORT_NO_SELECT:

        DD((PCE)Pdx,DDT, "ParDeviceIo - IOCTL_INTERNAL_LOCK_PORT_NO_SELECT\n");
        Pdx->AllocatedByLockPort  = TRUE;
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT:

        DD((PCE)Pdx,DDT, "ParDeviceIo - IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT\n");
        Pdx->AllocatedByLockPort  = FALSE;
        PptAssert(!Pdx->Connected && !Pdx->AllocatedByLockPort);
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_SERIAL_SET_TIMEOUTS:
        {
            PSERIAL_TIMEOUTS ptoNew = Irp->AssociatedIrp.SystemBuffer;

            //
            // The only other thing let through is setting
            // the timer start.
            //
            
            Pdx->TimerStart = ptoNew->WriteTotalTimeoutConstant / 1000;
            Irp->IoStatus.Status  = STATUS_SUCCESS;
        }
        break;
    
    case IOCTL_INTERNAL_PARDOT3_CONNECT:
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_CONNECT - Dispatch\n");
        Irp->IoStatus.Status  = ParDot3Connect(Pdx);
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_DISCONNECT - Dispatch\n");
        Irp->IoStatus.Status  = ParDot3Disconnect(Pdx);
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_SIGNAL:
        if( Pdx->IdxReverseProtocol != NIBBLE_MODE ) {
            PKEVENT Event;// = (PKEVENT)Irp->AssociatedIrp.SystemBuffer;
            
            RtlCopyMemory(&Event, Irp->AssociatedIrp.SystemBuffer, sizeof(PKEVENT));
            
            ASSERT_EVENT(Event);
            
            DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_SIGNAL - Dispatch. Event [%x]\n", Event);
            
            Pdx->P12843DL.Event        = Event;
            Pdx->P12843DL.bEventActive = TRUE;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            // don't use signalling in NIBBLE mode - rely on dot4 polling
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_RESET:
        DD((PCE)Pdx,DDT,"IOCTL_INTERNAL_PARDOT3_RESET - Dispatch\n");
        if (Pdx->P12843DL.fnReset)
            Irp->IoStatus.Status = ((PDOT3_RESET_ROUTINE) (Pdx->P12843DL.fnReset))(Pdx);
        else
            Irp->IoStatus.Status  = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;
    default:

        //
        // unrecognized IOCTL? - we should never get here because the 
        //   dispatch routines should have filtered this out
        //

        // probably harmless, but we want to know if this happens
        //   so we can fix the problem elsewhere
        ASSERTMSG("Unrecognized IOCTL in ParDeviceIo()\n",FALSE);

        Irp->IoStatus.Status  = STATUS_UNSUCCESSFUL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdopnp.c ===
#include "pch.h"

NTSTATUS PptPdoStartDevice( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryRemove( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoRemoveDevice( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoCancelRemove( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoStopDevice( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryStop( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoCancelStop( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryDeviceRelations( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryCapabilities( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryDeviceText( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryId( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryPnpDeviceState( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoQueryBusInformation( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoSurpriseRemoval( PDEVICE_OBJECT DevObj, PIRP Irp );
NTSTATUS PptPdoDefaultPnpHandler( PDEVICE_OBJECT DevObj, PIRP Irp );

PDRIVER_DISPATCH 
PptPdoPnpDispatchTable[] =
{ 
    PptPdoStartDevice,          // IRP_MN_START_DEVICE                 0x00
    PptPdoQueryRemove,          // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    PptPdoRemoveDevice,         // IRP_MN_REMOVE_DEVICE                0x02
    PptPdoCancelRemove,         // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    PptPdoStopDevice,           // IRP_MN_STOP_DEVICE                  0x04
    PptPdoQueryStop,            // IRP_MN_QUERY_STOP_DEVICE            0x05
    PptPdoCancelStop,           // IRP_MN_CANCEL_STOP_DEVICE           0x06
    PptPdoQueryDeviceRelations, // IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    PptPdoDefaultPnpHandler,    // IRP_MN_QUERY_INTERFACE              0x08
    PptPdoQueryCapabilities,    // IRP_MN_QUERY_CAPABILITIES           0x09
    PptPdoDefaultPnpHandler,    // IRP_MN_QUERY_RESOURCES              0x0A
    PptPdoDefaultPnpHandler,    // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    PptPdoQueryDeviceText,      // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    PptPdoDefaultPnpHandler,    // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    PptPdoDefaultPnpHandler,    // no such PnP request                 0x0E
    PptPdoDefaultPnpHandler,    // IRP_MN_READ_CONFIG                  0x0F
    PptPdoDefaultPnpHandler,    // IRP_MN_WRITE_CONFIG                 0x10
    PptPdoDefaultPnpHandler,    // IRP_MN_EJECT                        0x11
    PptPdoDefaultPnpHandler,    // IRP_MN_SET_LOCK                     0x12
    PptPdoQueryId,              // IRP_MN_QUERY_ID                     0x13
    PptPdoQueryPnpDeviceState,  // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    PptPdoQueryBusInformation,  // IRP_MN_QUERY_BUS_INFORMATION        0x15
    PptPdoDefaultPnpHandler,    // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    PptPdoSurpriseRemoval,      // IRP_MN_SURPRISE_REMOVAL             0x17
    PptPdoDefaultPnpHandler     // IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
};


NTSTATUS
PptPdoStartDevice(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    ) 
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    pdx->DeviceStateFlags = PPT_DEVICE_STARTED;
    KeSetEvent(&pdx->PauseEvent, 0, FALSE); // unpause any worker thread

    PptRegGetDeviceParameterDword( Pdo, L"Event22Delay", &pdx->Event22Delay );

    //
    // Register device interface for Legacy LPTx interface PDOs and set the interface active
    //  - succeed start even if the device interface code fails
    //
    if( PdoTypeRawPort == pdx->PdoType ) {

        // This is a legacy interface "raw port" PDO, don't set interface for other types of PDOs 

        NTSTATUS  status;
        BOOLEAN   setActive = FALSE;

        if( NULL == pdx->DeviceInterface.Buffer ) {
            // Register device interface
            status = IoRegisterDeviceInterface( Pdo, &GUID_PARCLASS_DEVICE, NULL, &pdx->DeviceInterface );
            if( STATUS_SUCCESS == status ) {
                setActive = TRUE;
            }
        }

        if( (TRUE == setActive) && (FALSE == pdx->DeviceInterfaceState) ) {
            // set interface active
            status = IoSetDeviceInterfaceState( &pdx->DeviceInterface, TRUE );
            if( STATUS_SUCCESS == status ) {
                pdx->DeviceInterfaceState = TRUE;
            }
        }
    }

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryRemove(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    // DDpnp2( ("PptPdoQueryRemove\n") );

    // PnP won't remove us if there are open handles to us - so WE don't need to check for open handles

    pdx->DeviceStateFlags |= (PPT_DEVICE_REMOVE_PENDING | PAR_DEVICE_PAUSED);
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoRemoveDevice(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx     = Pdo->DeviceExtension;
    NTSTATUS        status;

    pdx->DeviceStateFlags = PAR_DEVICE_PAUSED;
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    // Set Device Interface inactive for PdoTypeRawPort - other PDO types don't have device interfaces
    if( PdoTypeRawPort == pdx->PdoType ) {
        if( (pdx->DeviceInterface.Buffer != NULL) && (TRUE == pdx->DeviceInterfaceState) ) {
            IoSetDeviceInterfaceState( &pdx->DeviceInterface, FALSE );
            pdx->DeviceInterfaceState = FALSE;
        }
    }

    // If we were not reported in the last FDO BusRelations enumeration then it is safe to delete self
    if( pdx->DeleteOnRemoveOk ) {
        DD((PCE)pdx,DDT,"PptPdoRemoveDevice - DeleteOnRemoveOk == TRUE - cleaning up self\n");
        P4DestroyPdo( Pdo );
        status = P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
        return status;
    } else {
        return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
    }
}


NTSTATUS
PptPdoCancelRemove(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    pdx->DeviceStateFlags &= ~(PPT_DEVICE_REMOVE_PENDING | PAR_DEVICE_PAUSED);
    KeSetEvent(&pdx->PauseEvent, 0, FALSE); // unpause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoStopDevice(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    // DDpnp2( ("PptPdoStopDevice\n") );

    pdx->DeviceStateFlags |=  PAR_DEVICE_PAUSED;
    pdx->DeviceStateFlags &= ~PPT_DEVICE_STARTED;
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryStop(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    // DDpnp2( ("PptPdoQueryStop\n") );

    pdx->DeviceStateFlags  |= (PPT_DEVICE_STOP_PENDING | PAR_DEVICE_PAUSED);
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoCancelStop(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    pdx->DeviceStateFlags &= ~PPT_DEVICE_STOP_PENDING;
    KeSetEvent(&pdx->PauseEvent, 0, FALSE); // unpause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryDeviceRelations(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION        pdx         = Pdo->DeviceExtension;
    PIO_STACK_LOCATION    irpSp       = IoGetCurrentIrpStackLocation( Irp );
    DEVICE_RELATION_TYPE  requestType = irpSp->Parameters.QueryDeviceRelations.Type;
    NTSTATUS              status      = Irp->IoStatus.Status;
    ULONG_PTR             info        = Irp->IoStatus.Information;

    if( TargetDeviceRelation == requestType ) {
        PDEVICE_RELATIONS devRel = ExAllocatePool( PagedPool, sizeof(DEVICE_RELATIONS) );
        if( devRel ) {
            devRel->Count = 1;
            ObReferenceObject( Pdo );
            devRel->Objects[0] = Pdo;
            status = STATUS_SUCCESS;
            info   = (ULONG_PTR)devRel;
        } else {
            status = STATUS_NO_MEMORY;
        }
    } else {
        DD((PCE)pdx,DDT,"PptPdoQueryDeviceRelations - unhandled request Type = %d\n",requestType);
    }
    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoQueryCapabilities(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION      pdx = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation( Irp );

    irpSp->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK       = TRUE;
    if( PdoTypeRawPort == pdx->PdoType ) {
        // This is the legacy LPTx interface device - no driver should
        //  ever be installed for this so don't bother the user with a popup.
        irpSp->Parameters.DeviceCapabilities.Capabilities->SilentInstall = TRUE;
    }

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoQueryDeviceText(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION      pdx        = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp      = IoGetCurrentIrpStackLocation( Irp );
    PWSTR               buffer     = NULL;
    ULONG               bufLen;
    ULONG_PTR           info;
    NTSTATUS            status;

    if( DeviceTextDescription == irpSp->Parameters.QueryDeviceText.DeviceTextType ) {

        //
        // DeviceTextDescription is: catenation of MFG+<SPACE>+MDL
        //
        if( pdx->Mfg && pdx->Mdl ) {
            //
            // Construct UNICODE string to return from the ANSI strings
            //   that we have in our extension
            //
            // need space for <SPACE> and terminating NULL
            //
            bufLen = strlen( (const PCHAR)pdx->Mfg ) + strlen( (const PCHAR)pdx->Mdl ) + 2 * sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S %S", pdx->Mfg, pdx->Mdl );
                DD((PCE)pdx,DDT,"PptPdoQueryDeviceText - DeviceTextDescription - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }
        } else {
            DD((PCE)pdx,DDE,"PptPdoQueryDeviceText - MFG and/or MDL NULL - FAIL DeviceTextDescription\n");
            status = STATUS_UNSUCCESSFUL;
        }
    } else if( DeviceTextLocationInformation == irpSp->Parameters.QueryDeviceText.DeviceTextType ) {

        //
        // DeviceTextLocationInformation is LPTx or LPTx.y (note that
        //   this is also the symlink name minus the L"\\DosDevices\\"
        //   prefix)
        //

        if( pdx->Location ) {
            bufLen = strlen( (const PCHAR)pdx->Location ) + sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S", pdx->Location );
                DD((PCE)pdx,DDT,"PptPdoQueryDeviceText - DeviceTextLocationInformation - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }
        } else {
            DD((PCE)pdx,DDE,"PptPdoQueryDeviceText - Location NULL - FAIL DeviceTextLocationInformation\n");
            status = STATUS_UNSUCCESSFUL;
        }
    } else {

        // Unknown DeviceTextType - don't change anything in IRP
        buffer = NULL;
        status = Irp->IoStatus.Status;
    }

    if( (STATUS_SUCCESS == status) && buffer ) {
        info = (ULONG_PTR)buffer;
    } else {
        if( buffer ) {
            ExFreePool( buffer );
        }
        info = Irp->IoStatus.Information;
    }

    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoQueryId( PDEVICE_OBJECT Pdo, PIRP Irp )
{
    PPDO_EXTENSION      pdx        = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp      = IoGetCurrentIrpStackLocation( Irp );
    PWSTR               buffer     = NULL;
    ULONG               bufLen;
    NTSTATUS            status;
    ULONG_PTR           info;

    switch( irpSp->Parameters.QueryId.IdType ) {
        
    case BusQueryDeviceID :
        //
        // DeviceID generation: catenate MFG and MDL fields from the
        //   IEEE 1284 device ID string (no space between fields), append
        //   MFG+MDL catenation to LPTENUM\ prefix
        //
        if( pdx->Mfg && pdx->Mdl ) {
            //
            // Construct UNICODE string to return from the ANSI strings
            //   that we have in our extension
            //
            CHAR prefix[] = "LPTENUM\\";
            // sizeof(prefix) provides space for NULL terminator
            bufLen = sizeof(prefix) + strlen( (const PCHAR)pdx->Mfg ) + strlen( (const PCHAR)pdx->Mdl );
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S%S%S", prefix, pdx->Mfg, pdx->Mdl );
                P4SanitizeId( buffer ); // replace any illegal characters with underscore
                DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryDeviceID - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }

        } else {

            DD((PCE)pdx,DDE,"PptPdoQueryId - MFG and/or MDL NULL - FAIL BusQueryDeviceID\n");
            status = STATUS_UNSUCCESSFUL;

        }
        break;
        
    case BusQueryInstanceID :
        //
        // InstanceID is LPTx or LPTx.y Location of the device (note
        //   that this is also the symlink name minus the
        //   \DosDevices\ prefix)
        //
        if( pdx->Location ) {
            //
            // Construct UNICODE string to return from the ANSI string
            //   that we have in our extension
            //
            bufLen = strlen( (const PCHAR)pdx->Location ) + sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S", pdx->Location );
                P4SanitizeId( buffer ); // replace any illegal characters with underscore
                DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryInstanceID - <%S>\n",buffer);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_MEMORY;
            }
        } else {

            DD((PCE)pdx,DDE,"PptPdoQueryId - Location NULL - FAIL BusQueryInstanceID\n");
            status = STATUS_UNSUCCESSFUL;

        }
        break;
        
    case BusQueryHardwareIDs :
        //
        // HardwareID generation:
        //
        // Generate MfgMdlCrc string as follows:
        //   1) catenate MFG and MDL fields
        //   2) generate checksum on MFG+MDL catenation
        //   3) truncate MFG+MDL catenation
        //   4) append checksum
        //
        // Return as HardwareID MULTI_SZ: LPTENUM\%MfgMdlCrc% followed by bare %MfgMdlCrc%
        //
        //   example: LPTENUM\Acme_CorpFooBarPrint3FA5\0Acme_CorpFooBarPrint3FA5\0\0
        //
        if( pdx->Mfg && pdx->Mdl ) {
            ULONG  lengthOfMfgMdlBuffer = strlen( (const PCHAR)pdx->Mfg ) + strlen( (const PCHAR)pdx->Mdl ) + sizeof(CHAR);
            PCHAR  mfgMdlBuffer         = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, lengthOfMfgMdlBuffer );

            if( mfgMdlBuffer ) {
                const CHAR  prefix[]              = "LPTENUM\\";
                const ULONG mfgMdlTruncationLimit = 20;
                const ULONG checksumLength        = 4;
                USHORT      checksum;

                // 1) catenate MFG and MDL fields and 2) generate checksum on catenation
                RtlZeroMemory( mfgMdlBuffer, lengthOfMfgMdlBuffer );
                _snprintf( mfgMdlBuffer, lengthOfMfgMdlBuffer, "%s%s", pdx->Mfg, pdx->Mdl );
                GetCheckSum( mfgMdlBuffer, (USHORT)strlen(mfgMdlBuffer), &checksum );

                //
                // alloc buffer large enough for result returned to PnP,
                // include space for 4 checksum chars (twice) + 1 NULL between strings + 2 termination chars (MULTI_SZ)
                //
                bufLen = strlen( prefix ) + 2 * mfgMdlTruncationLimit + 2 * checksumLength + 3 * sizeof(CHAR); 
                bufLen *= (sizeof(WCHAR)/sizeof(CHAR)); // convert to size needed for WCHARs
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    ULONG wcharsWritten;
                    RtlZeroMemory( buffer, bufLen );

                    // Construct the HardwareID MULTI_SZ:
                    //
                    //  Write the first Hardware ID: LPTENUM\xxx
                    wcharsWritten = _snwprintf( buffer, bufLen/2, L"%S%.20S%04X", prefix, mfgMdlBuffer, checksum );

                    //  Skip forward a UNICODE_NULL past the end of the first Hardware ID and write the second
                    //    Hardware ID: bare xxx
                    _snwprintf( buffer+wcharsWritten+1, bufLen/2-wcharsWritten-1, L"%.20S%04X", mfgMdlBuffer, checksum );

                    ExFreePool( mfgMdlBuffer );

                    DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryHardwareIDs 1st ID - <%S>\n",buffer);
                    DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryHardwareIDs 2nd ID - <%S>\n",buffer+wcslen(buffer)+1);                    
                    // replace any illegal characters with underscore, preserve UNICODE_NULLs
                    P4SanitizeMultiSzId( buffer, bufLen/2 );

                    status = STATUS_SUCCESS;

                    // printing looks for PortName in the devnode - Pdo's Location is the PortName
                    P4WritePortNameToDevNode( Pdo, pdx->Location );

                } else {
                    ExFreePool( mfgMdlBuffer );
                    DD((PCE)pdx,DDT,"PptPdoQueryId - no pool for buffer - FAIL BusQueryHardwareIDs\n");
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                DD((PCE)pdx,DDT,"PptPdoQueryId - no pool for mfgMdlBuffer - FAIL BusQueryHardwareIDs\n");
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            DD((PCE)pdx,DDT,"PptPdoQueryId - MFG and/or MDL NULL - FAIL BusQueryHardwareIDs\n");
            status = STATUS_UNSUCCESSFUL;
        }

        //
        // Save the MFG and MDL fields from the IEEE 1284 Device ID string under the 
        //   "<DevNode>\Device Parameters" key so that user mode code (e.g., printing)
        //   can retrieve the fields.
        //
        PptWriteMfgMdlToDevNode( Pdo, pdx->Mfg, pdx->Mdl );

        break;
        
    case BusQueryCompatibleIDs :

        //
        // Printing group specified that we not report compatible IDs - 2000-04-24
        //
#define PPT_REPORT_COMPATIBLE_IDS 0
#if (0 == PPT_REPORT_COMPATIBLE_IDS)

        DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryCompatibleIDs - query not supported\n");
        status = Irp->IoStatus.Status;

#else
        //
        // Return the compatible ID string reported by device, if any
        //

        if( pdx->Cid ) {
            //
            // Construct UNICODE string to return from the ANSI string
            //   that we have in our extension
            //
            bufLen = strlen( pdx->Cid ) + 2 * sizeof(CHAR);
            bufLen *= ( sizeof(WCHAR)/sizeof(CHAR) );
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
            if( buffer ) {
                RtlZeroMemory( buffer, bufLen );
                _snwprintf( buffer, bufLen/2, L"%S", pdx->Cid );
                DD((PCE)pdx,DDT,"PptPdoQueryId - BusQueryCompatibleIDs - <%S>\n",buffer);

                //
                // convert the 1284 ID representation of a Compatible ID seperator (',') into
                //   a MULTI_SZ - (i.e., scan the WSTR and replace any L',' with L'\0')
                //
                {
                    PWCHAR p = buffer;
                    while( *p ) {
                        if( L',' == *p ) {
                            *p = L'\0';
                        }
                        ++p;
                    }
                }

                // replace any illegal characters with underscore, preserve UNICODE_NULLs
                P4SanitizeMultiSzId( buffer, bufLen/2 );

                status = STATUS_SUCCESS;

            } else {
                DD((PCE)pdx,DDT,"PptPdoQueryId - no pool - FAIL BusQueryCompatibleIDs\n");
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            DD((PCE)pdx,DDT,"PptPdoQueryId - CID NULL - BusQueryCompatibleIDs\n");
            status = Irp->IoStatus.Status;
        }
#endif //  #if (0 == PPT_REPORT_COMPATIBLE_IDS)

        break;
        
    default :
        //
        // Invalid irpSp->Parameters.QueryId.IdType
        //
        DD((PCE)pdx,DDT,"PptPdoQueryId - unrecognized irpSp->Parameters.QueryId.IdType\n");
        status = Irp->IoStatus.Status;
    }


    if( (STATUS_SUCCESS == status) && buffer ) {
        info = (ULONG_PTR)buffer;
    } else {
        if( buffer ) {
            ExFreePool( buffer );
        }
        info = Irp->IoStatus.Information;
    }

    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoQueryPnpDeviceState( PDEVICE_OBJECT Pdo, PIRP Irp )
{
    PPDO_EXTENSION      pdx    = Pdo->DeviceExtension;
    NTSTATUS            status = Irp->IoStatus.Status;
    ULONG_PTR           info   = Irp->IoStatus.Information;


    if( PdoTypeRawPort == pdx->PdoType ) {
        info |= PNP_DEVICE_DONT_DISPLAY_IN_UI;
        status = STATUS_SUCCESS;
    }
    return P4CompleteRequest( Irp, status, info );
}

NTSTATUS
PptPdoQueryBusInformation( PDEVICE_OBJECT Pdo, PIRP Irp )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;
    NTSTATUS        status;
    ULONG_PTR       info;

    if( pdx->PdoType != PdoTypeRawPort ) {

        //
        // we are a "real" device enumerated by parport - report BusInformation
        //

        PPNP_BUS_INFORMATION  pBusInfo = ExAllocatePool( PagedPool, sizeof(PNP_BUS_INFORMATION) );

        if( pBusInfo ) {

            pBusInfo->BusTypeGuid   = GUID_BUS_TYPE_LPTENUM;
            pBusInfo->LegacyBusType = PNPBus;
            pBusInfo->BusNumber     = 0;

            status                  = STATUS_SUCCESS;
            info                    = (ULONG_PTR)pBusInfo;

        } else {

            // no pool
            status = STATUS_NO_MEMORY;
            info   = Irp->IoStatus.Information;

        }

    } else {

        //
        // we are a pseudo device (Legacy Interface Raw Port PDO LPTx) - don't report BusInformation
        //
        status = Irp->IoStatus.Status;
        info   = Irp->IoStatus.Information;

    }

    return P4CompleteRequest( Irp, status, info );
}


NTSTATUS
PptPdoSurpriseRemoval( 
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    PPDO_EXTENSION      pdx = Pdo->DeviceExtension;

    // Set Device Interface inactive for PdoTypeRawPort - other PDO types don't have device interfaces
    if( PdoTypeRawPort == pdx->PdoType ) {
        if( (pdx->DeviceInterface.Buffer != NULL) && (TRUE == pdx->DeviceInterfaceState) ) {
            IoSetDeviceInterfaceState( &pdx->DeviceInterface, FALSE );
            pdx->DeviceInterfaceState = FALSE;
        }
    }

    pdx->DeviceStateFlags |= PPT_DEVICE_SURPRISE_REMOVED;
    KeClearEvent(&pdx->PauseEvent); // pause any worker thread

    return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
}


NTSTATUS
PptPdoDefaultPnpHandler(
    IN PDEVICE_OBJECT  Pdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Pdo );

    return P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
}


NTSTATUS 
PptPdoPnp(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp
    ) 
{ 
    PPDO_EXTENSION               pdx   = Pdo->DeviceExtension;
    PIO_STACK_LOCATION           irpSp = IoGetCurrentIrpStackLocation( Irp );

    // diagnostic
    PptPdoDumpPnpIrpInfo( Pdo, Irp);

    if( pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING ) {
        DD((PCE)pdx,DDT,"PptPdoPnp - PPT_DEVICE_DELETE_PENDING - bailing out\n");
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }

    if( irpSp->MinorFunction < arraysize(PptPdoPnpDispatchTable) ) {
        return PptPdoPnpDispatchTable[ irpSp->MinorFunction ]( Pdo, Irp );
    } else {
        DD((PCE)pdx,DDT,"PptPdoPnp - Default Handler - IRP_MN = %x\n",irpSp->MinorFunction);
        return PptPdoDefaultPnpHandler( Pdo, Irp );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdoquerysetinfo.c ===
#include "pch.h"

NTSTATUS
PptPdoQueryInformation(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.

--*/

{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          IrpSp;
    PFILE_STANDARD_INFORMATION  StdInfo;
    PFILE_POSITION_INFORMATION  PosInfo;
    PPDO_EXTENSION           Extension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );
        return STATUS_DEVICE_REMOVED;
    }

    Irp->IoStatus.Information = 0;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {
        
    case FileStandardInformation:
        
        if (IrpSp->Parameters.QueryFile.Length < sizeof(FILE_STANDARD_INFORMATION)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            StdInfo = Irp->AssociatedIrp.SystemBuffer;
            StdInfo->AllocationSize.QuadPart = 0;
            StdInfo->EndOfFile               = StdInfo->AllocationSize;
            StdInfo->NumberOfLinks           = 0;
            StdInfo->DeletePending           = FALSE;
            StdInfo->Directory               = FALSE;
            
            Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
            Status = STATUS_SUCCESS;
            
        }
        break;
        
    case FilePositionInformation:
        
        if (IrpSp->Parameters.SetFile.Length < sizeof(FILE_POSITION_INFORMATION)) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else {
            
            PosInfo = Irp->AssociatedIrp.SystemBuffer;
            PosInfo->CurrentByteOffset.QuadPart = 0;
            
            Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
            Status = STATUS_SUCCESS;
        }
        break;
        
    default:
        Status = STATUS_INVALID_PARAMETER;
        break;
        
    }
    
    P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );

    return Status;
}

NTSTATUS
PptPdoSetInformation(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.

--*/

{
    NTSTATUS               Status;
    FILE_INFORMATION_CLASS fileInfoClass;
    PPDO_EXTENSION      Extension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {

        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );

    }


    Irp->IoStatus.Information = 0;

    fileInfoClass = IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass;

    if (fileInfoClass == FileEndOfFileInformation) {

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INVALID_PARAMETER;

    }

    return P4CompleteRequest( Irp, Status, Irp->IoStatus.Information );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdoclose.c ===
#include "pch.h"

NTSTATUS
PptPdoClose(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/
{
    PPDO_EXTENSION   pdx = Pdo->DeviceExtension;
    BOOLEAN          haveShadowBuffer;
    PVOID            threadObject;

    DD((PCE)pdx,DDT,"PptPdoClose\n");

    // immediately stop signalling any dot4 event
    pdx->P12843DL.bEventActive = FALSE;


    //
    // Protect against two threads calling us concurrently
    //
    ExAcquireFastMutex( &pdx->OpenCloseMutex );

    haveShadowBuffer         = pdx->bShadowBuffer;
    pdx->bShadowBuffer       = FALSE;

    threadObject             = pdx->ThreadObjectPointer;
    pdx->ThreadObjectPointer = NULL;

    ExReleaseFastMutex( &pdx->OpenCloseMutex );

    //
    // clean up Bounded ECP shadow buffer
    //
    if( haveShadowBuffer ) {
        Queue_Delete( &(pdx->ShadowBuffer) );
    }

    //
    // if we still have a worker thread, kill it
    //
    if( threadObject ) {

        // set the flag for the worker thread to kill itself
        pdx->TimeToTerminateThread = TRUE;
        
        // wake up the thread so it can kill itself
        KeReleaseSemaphore( &pdx->RequestSemaphore, 0, 1, FALSE );
        
        // allow thread to get past PauseEvent so it can kill self
        KeSetEvent( &pdx->PauseEvent, 0, TRUE );

        // wait for the thread to die
        KeWaitForSingleObject( threadObject, UserRequest, KernelMode, FALSE, NULL );
        
        // allow the system to release the thread object
        ObDereferenceObject( threadObject );
    }

    //
    // update open handle count
    //
    {
        ExAcquireFastMutex( &pdx->OpenCloseMutex );
        InterlockedDecrement( &pdx->OpenCloseRefCount );
        if( pdx->OpenCloseRefCount < 0) {
            // catch possible underflow
            pdx->OpenCloseRefCount = 0;
        }
        ExReleaseFastMutex(&pdx->OpenCloseMutex);
    }

    return P4CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\queueclass.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    queue.h

Abstract:

   Creates a simple Queue that works in Kernel Mode.

Author:

    Robbie Harris (Hewlett-Packard) 22-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _QUEUE_
#define _QUEUE_

typedef struct _Queue {
    int     head;
    int     max;
    int     tail;
    UCHAR   *theArray;
} Queue, *PQueue;

void Queue_Create(Queue *pQueue, int size);
BOOLEAN Queue_Delete(Queue *pQueue);
BOOLEAN Queue_Dequeue(Queue *pQueue, PUCHAR data);
BOOLEAN Queue_Enqueue(Queue *pQueue, UCHAR data);
BOOLEAN Queue_GarbageCollect(Queue *pQueue); 
BOOLEAN Queue_IsEmpty(Queue *pQueue);
BOOLEAN Queue_IsFull(Queue *pQueue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdoexports.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       exports.c
//
//--------------------------------------------------------------------------

//
// This file contains the functions exported in response to IOCTL_INTERNAL_PARCLASS_CONNECT
//
    
#include "pch.h"
    
USHORT
ParExportedDetermineIeeeModes(
    IN PPDO_EXTENSION    Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to find out what Ieee Modes there Device Supports.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    Extension->BadProtocolModes = 0;
    IeeeDetermineSupportedProtocols(Extension);
    return Extension->ProtocolModesSupported;
}

NTSTATUS
ParExportedIeeeFwdToRevMode(
    IN PPDO_EXTENSION  Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to put there device into reverse Ieee Mode.
    The Mode is determined by what was passed into the function  
    ParExportedNegotiateIeeeMode() as the Reverse Protocol with the
    ModeMaskRev.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    return ( ParForwardToReverse( Extension ) );
}

NTSTATUS
ParExportedIeeeRevToFwdMode(
    IN PPDO_EXTENSION  Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to put there device into forward Ieee Mode.
    The Mode is determined by what was passed into the function  
    ParExportedNegotiateIeeeMode() as the Forward Protocol with the
    ModeMaskFwd.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    return ( ParReverseToForward( Extension ) );
}

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PPDO_EXTENSION  Extension,
    IN USHORT             ModeMaskFwd,
    IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
    IN BOOLEAN            IsForward
    )
    
/*++
    
Routine Description:
    
    Called by filter drivers to negotiate an IEEE mode.
    
Arguments:
    
    Extension       - Device Extension
    
    Extensibility   - IEEE 1284 Extensibility
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (Extension->Connected) {
        DD((PCE)Extension,DDE,"ParExportedNegotiateIeeeMode - FAIL - already connected\n");
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (ModeSafety == UNSAFE_MODE) {    

        // Checking to see if we are doing forward compatability and reverse Nibble or Byte
        if ( (ModeMaskFwd & CENTRONICS) || (ModeMaskFwd & IEEE_COMPATIBILITY) ) {

            if ( !((ModeMaskRev & NIBBLE) || (ModeMaskRev & CHANNEL_NIBBLE) || (ModeMaskRev & BYTE_BIDIR)) ) {
                DD((PCE)Extension,DDE,"ParExportedNegotiateIeeeMode - FAIL - invalid modes\n");
                return STATUS_UNSUCCESSFUL;
            }

        } else {

            // Unsafe mode is only possible if the Fwd and Rev PCTLs the same if other than above.
            if (ModeMaskFwd != ModeMaskRev) {
                DD((PCE)Extension,DDE,"ParExportedNegotiateIeeeMode - FAIL - Fwd and Rev modes do not match\n");
                return STATUS_UNSUCCESSFUL;
            }

        }
        // RMT - Need to fill in....
        // Todo....
        // Mark in the extension
        Extension->ModeSafety = ModeSafety;
        Status = IeeeNegotiateMode(Extension, ModeMaskRev, ModeMaskFwd);

    } else {

        Extension->ModeSafety = ModeSafety;
        Status = IeeeNegotiateMode(Extension, ModeMaskRev, ModeMaskFwd);

    }
   
    if (IsForward) {

        if (afpForward[Extension->IdxForwardProtocol].fnConnect) {
            Status = afpForward[Extension->IdxForwardProtocol].fnConnect(Extension, FALSE);
        }

    } else {

        if (arpReverse[Extension->IdxReverseProtocol].fnConnect) {
            Status = arpReverse[Extension->IdxReverseProtocol].fnConnect(Extension, FALSE);
        }

    }
  
    return Status;
}

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PPDO_EXTENSION   Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to terminate from an IEEE mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
  
    STATUS_SUCCESS if successful.
 
--*/
{
    // Check the extension for UNSAFE_MODE
    // and do the right thing
    if ( Extension->ModeSafety == UNSAFE_MODE ) {    
        DD((PCE)Extension,DDT,"ParExportedTerminateIeeeMode in UNSAFE_MODE\n");
        // Need to fill in....
        // Todo....
        // Mark in the extension
    }
    
    if (Extension->CurrentPhase == PHASE_REVERSE_IDLE || Extension->CurrentPhase == PHASE_REVERSE_XFER) {
        if (arpReverse[Extension->IdxReverseProtocol].fnDisconnect) {
            arpReverse[Extension->IdxReverseProtocol].fnDisconnect( Extension );
        }
    } else {
        if (afpForward[Extension->IdxForwardProtocol].fnDisconnect) {
            afpForward[Extension->IdxForwardProtocol].fnDisconnect( Extension );
        }
    }

    Extension->ModeSafety = SAFE_MODE;

    return STATUS_SUCCESS;
}

NTSTATUS
ParExportedParallelRead(
    IN PPDO_EXTENSION    Extension,
    IN  PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead,
    IN  UCHAR               Channel
    )
    
/*++
    
Routine Description:
    
    Called by filter drivers to terminate from a currently connected mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
   
    STATUS_SUCCESS if successful.
    
--*/
    
{
    UNREFERENCED_PARAMETER( Channel );

    return ParRead( Extension, Buffer, NumBytesToRead, NumBytesRead);
}

NTSTATUS
ParExportedParallelWrite(
    IN  PPDO_EXTENSION   Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten,
    IN  UCHAR               Channel
    )
{
    UNREFERENCED_PARAMETER( Channel );
    return ParWrite( Extension, Buffer, NumBytesToWrite, NumBytesWritten);
}

NTSTATUS
ParExportedTrySelect(
    IN  PPDO_EXTENSION       Extension,
    IN  PARALLEL_1284_COMMAND   Command
    )
{
    UNREFERENCED_PARAMETER( Extension );
    UNREFERENCED_PARAMETER( Command );
    return STATUS_UNSUCCESSFUL;
}   

NTSTATUS
ParExportedDeSelect(
    IN  PPDO_EXTENSION       Extension,
    IN  PARALLEL_1284_COMMAND   Command
    )
{
    UNREFERENCED_PARAMETER( Extension );
    UNREFERENCED_PARAMETER( Command );
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pdopower.c ===
#include "pch.h"

NTSTATUS
PptPdoPower(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PIRP            Irp
   )
{
    PPDO_EXTENSION      pdx           = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp         = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS            status;
    ULONG_PTR           info          = Irp->IoStatus.Information;
    POWER_STATE         powerState    = irpSp->Parameters.Power.State;
    POWER_STATE_TYPE    powerType     = irpSp->Parameters.Power.Type;
    UCHAR               minorFunction = irpSp->MinorFunction;

    switch( minorFunction ) {

    case IRP_MN_QUERY_POWER:

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SET_POWER:

        switch( powerType ) {

        case DevicePowerState:

            PoSetPowerState( pdx->DeviceObject, powerType, powerState );
            pdx->DeviceState = powerState.DeviceState;
            status = STATUS_SUCCESS;
            break;

        case SystemPowerState:

            status = STATUS_SUCCESS;
            break;

        default:

            status = Irp->IoStatus.Status;

        }

        break;

    default:

        status = Irp->IoStatus.Status;

    }

    PoStartNextPowerIrp( Irp );

    P4CompleteRequest( Irp, status, info );

    DD((PCE)pdx,DDT,"PptPdoPower - minorFunction=%x, powerState=%x, powerType=%x, status=%x",minorFunction,powerState,powerType,status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\queueclass.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    queue.c

Abstract:

   Creates a simple Queue that works in Kernel Mode.

Author:

    Robbie Harris (Hewlett-Packard) 22-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#include "pch.h"

void Queue_Create(Queue *pQueue, int size)
{
    if( !pQueue ) {
        DD(NULL,DDE,"Queue_Create: Queue is Bad");
        return;
    }

    if (pQueue->theArray) {
        Queue_Delete(pQueue);
    }
        
    pQueue->theArray = (UCHAR *)ExAllocatePool(NonPagedPool, size);
    pQueue->max      = size;
    pQueue->head     = pQueue->tail = 0;
}

BOOLEAN Queue_Delete(Queue *pQueue)
{
    if( !pQueue ) {
        return FALSE;
    }

    if( pQueue->theArray ) {
        ExFreePool(pQueue->theArray);
        pQueue->theArray = NULL;
    }
    
    pQueue->head = 0;
    pQueue->tail = 0;
    pQueue->max  = 0;
    
    return TRUE;
}

BOOLEAN Queue_Dequeue(Queue *pQueue, PUCHAR data)
{
    // Validity of pQueue is checked in Queue_IsEmpty proc. 
    if( Queue_IsEmpty( pQueue ) ) {
        DD(NULL,DDE,"Queue_Dequeue: Queue is Empty");
        return FALSE;
    }

    *data = pQueue->theArray[pQueue->head++];
    return TRUE;
}

BOOLEAN Queue_Enqueue(Queue *pQueue, UCHAR data)
{
    // Validity of pQueue is checked in Queue_IsFull proc. 
    if( Queue_IsFull( pQueue ) ) {
        DD(NULL,DDE,"Queue_Enqueue: Queue is full. Data is lost");
        return FALSE;
    } else {
        pQueue->theArray[pQueue->tail++] = data;
    }

    return TRUE;
}

// Return TRUE if we were able to free some space in the Queue
BOOLEAN Queue_GarbageCollect(Queue *pQueue)
{
    int     iListSize;
    int     i;

    if (!pQueue)
    {
        DD(NULL,DDE,"Queue_GarbageCollect: Queue is Bad");
        return FALSE;
    }

    iListSize = pQueue->tail - pQueue->head;

    // Check to see if there is any free entries
    if (pQueue->head == 0 && pQueue->tail == pQueue->max)
        return FALSE;
         
    for (i = 0; i < iListSize; i++) {
    
        pQueue->theArray[i] = pQueue->theArray[pQueue->head+i];
    }

    pQueue->head = 0;
    pQueue->tail = iListSize;

    return TRUE;
}

//============================================================================
// NAME:    HPKQueue::IsEmpty()
//  
// PARAMETERS: None
//
// RETURNS: True is Queue is empty or doesn't exist.  Otherwise False.
//
//============================================================================
BOOLEAN Queue_IsEmpty(Queue *pQueue)
{
    if (!pQueue)
    {
        DD(NULL,DDE,"Queue_IsEmpty: Queue is Bad");
        return TRUE;
    }

    if (pQueue->theArray) {
    
        return (BOOLEAN)(pQueue->head == pQueue->tail);
    }
    DD(NULL,DDE,"Queue_IsEmpty: Queue->theArray is Bad");
    return TRUE;
}

//============================================================================
// NAME:    HPKQueue::IsFull()
//  
// PARAMETERS: None
//
// RETURNS: True is Queue is full or doesn't exist.  Otherwise False.
//
//============================================================================
BOOLEAN Queue_IsFull(Queue *pQueue)
{
    if( !pQueue ) {
        DD(NULL,DDE,"Queue_IsFull: Queue is Bad");
        return TRUE;
    }

    if( pQueue->theArray ) {
    
        if( pQueue->tail == pQueue->max ) {
            return !Queue_GarbageCollect(pQueue);
        } else {
            return FALSE;
        }
    }
    DD(NULL,DDE,"Queue_IsFull: Queue->theArray is Bad");
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\pnputils.c ===
#include "pch.h"

VOID
P5WorkItemFreePort( PDEVICE_OBJECT Fdo, PFDO_EXTENSION Fdx ) {
    PIO_WORKITEM workItem;

    UNREFERENCED_PARAMETER( Fdo );

    workItem = InterlockedExchangePointer( &Fdx->FreePortWorkItem, NULL );
    if( workItem ) {
        IoFreeWorkItem( workItem );
    }
    
    PptFreePort( Fdx );
}

BOOLEAN
P5SelectDaisyChainDevice(
    IN  PUCHAR  Controller,
    IN  UCHAR   DeviceId
    )
{
    const ULONG  maxRetries = 4;
    ULONG        retryCount = 0;
    BOOLEAN      selected   = FALSE;
    DD(NULL,DDE,"P5SelectDaisyChainDevice %x %d\n",Controller,DeviceId);
    while( !selected && retryCount < maxRetries ) {
        selected = PptSend1284_3Command( Controller, (UCHAR)(CPP_SELECT | DeviceId) );
        ++retryCount;
    }
    return selected;
}

BOOLEAN
P5DeselectAllDaisyChainDevices(
    IN  PUCHAR  Controller
    )
{
    const ULONG  maxRetries = 4;
    ULONG        retryCount = 0;
    BOOLEAN      deselected = FALSE;
    DD(NULL,DDE,"P5DeselectAllDaisyChainDevices %x\n",Controller);
    while( !deselected && retryCount < maxRetries ) {
        deselected = PptSend1284_3Command( Controller, (UCHAR)CPP_DESELECT );
        ++retryCount;
    }
    return deselected;
}

VOID
P5DeletePdoSymLink(
    IN  PDEVICE_OBJECT  Pdo
    )
//
// clean up symbolic link so we can reuse it immediately for a new PDO
//
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    if( pdx->SymLinkName ) {
        UNICODE_STRING  uniSymLinkName;
        NTSTATUS        status;

        DD((PCE)pdx,DDE,"P5DeletePdoSymLink\n");

        RtlInitUnicodeString( &uniSymLinkName, pdx->SymLinkName );
        status = IoDeleteSymbolicLink( &uniSymLinkName );
        PptAssert( STATUS_SUCCESS == status );
        ExFreePool( pdx->SymLinkName );
        pdx->SymLinkName = NULL;
    }

    return;
}

VOID
P5MarkPdoAsHardwareGone(
    IN  PDEVICE_OBJECT  Fdo,
    IN  enum _PdoType   PdoType,
    IN  ULONG           DaisyChainId  OPTIONAL // ignored if PdoType != PdoTypeDaisyChain
    )
{
    PFDO_EXTENSION  fdx = Fdo->DeviceExtension;
    PPDO_EXTENSION  pdx;
    PDEVICE_OBJECT  pdo;

    switch( PdoType ) {

    case PdoTypeRawPort:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeRawPort\n");
        pdo = fdx->RawPortPdo;
        fdx->RawPortPdo = NULL;
        break;

    case PdoTypeEndOfChain:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeEndOfChain\n");
        pdo = fdx->EndOfChainPdo;
        fdx->EndOfChainPdo = NULL;
        break;

    case PdoTypeDaisyChain:

        PptAssert( (0 == DaisyChainId) || (1 == DaisyChainId) );
        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeDaisyChain - %d\n",DaisyChainId);
        pdo = fdx->DaisyChainPdo[ DaisyChainId ];
        fdx->DaisyChainPdo[ DaisyChainId ] = NULL;
        break;

    case PdoTypeLegacyZip:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - PdoTypeLegacyZip\n");
        pdo = fdx->LegacyZipPdo;
        fdx->LegacyZipPdo = NULL;
        break;

    default:

        DD((PCE)fdx,DDE,"P5MarkPdoAsHardwareGone - Invalid PdoType parameter\n",FALSE);
        PptAssertMsg("P5MarkPdoAsHardwareGone - Invalid PdoType parameter",FALSE);
        return;

    }

    pdx = pdo->DeviceExtension;
    P5DeletePdoSymLink( pdo );
    InsertTailList( &fdx->DevDeletionListHead, &pdx->DevDeletionList );
    pdx->DeleteOnRemoveOk = TRUE;

    return;
}

BOOLEAN
P5IsDeviceStillThere( 
    IN  PDEVICE_OBJECT  Fdo,
    IN  PDEVICE_OBJECT  Pdo
    )
//
// Is the Pdo device still connected to the port represented by the Fdo?
//
// N.B. Fdo must own (have locked for exclusive access) the port before calling this function
//   or we can corrupt the data stream and hang devices connected to the port
//
{
    PFDO_EXTENSION  fdx              = Fdo->DeviceExtension;
    PPDO_EXTENSION  pdx              = Pdo->DeviceExtension;
    BOOLEAN         deviceStillThere = FALSE;
    PCHAR           devIdString      = NULL;
    PUCHAR          controller       = fdx->PortInfo.Controller;
        
    PptAssert( DevTypeFdo == fdx->DevType );
    PptAssert( DevTypePdo == pdx->DevType );

    //
    // Select device if needed, pull a fresh 1284 device ID string
    // from the device, and compare the Mfg and Mdl from the fresh
    // device ID with those stored in our extension. If the Mfg and
    // Mdl fields match then the device is still there.
    //

    switch( pdx->PdoType ) {

    case PdoTypeRawPort:
        
        // raw port is always present - it's a virtual device
        DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeRawPort - StillThere\n");
        deviceStillThere = TRUE;
        break;
        
    case PdoTypeLegacyZip:
        
        deviceStillThere = P5LegacyZipDetected( fdx->PortInfo.Controller );
        if( deviceStillThere ) {
            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeLegacyZip - StillThere\n");
        } else {
            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeLegacyZip - Gone\n");
        }
        break;
    
    case PdoTypeDaisyChain:
            
        //
        // Select device, pull a fresh 1284 device ID string
        // from the device, and compare the Mfg and Mdl from the fresh
        // device ID with those stored in our extension. If the Mfg and
        // Mdl fields match then the device is still there.
        //

        {
            UCHAR daisyChainId = pdx->Ieee1284_3DeviceId;

            // select device
            if( P5SelectDaisyChainDevice( controller, daisyChainId ) ) {

                BOOLEAN         bBuildStlDeviceId = FALSE;
                PPDO_EXTENSION  dummyPdx          = NULL;

                devIdString = NULL;

                // do a check to see if this is an SCM Micro device
                dummyPdx = ExAllocatePool( PagedPool, sizeof(PDO_EXTENSION) );
                if( dummyPdx != NULL ) {
                    RtlZeroMemory( dummyPdx, sizeof(PDO_EXTENSION) );
                    dummyPdx->Controller = fdx->PortInfo.Controller;
                    bBuildStlDeviceId = ParStlCheckIfStl( dummyPdx, daisyChainId );

                    if( bBuildStlDeviceId ) {
                        // SCM Micro device
                        ULONG DeviceIdSize;
                        devIdString = ParStlQueryStlDeviceId( dummyPdx, NULL, 0,&DeviceIdSize, TRUE );
                    } else {
                        // non-SCM Micro device
                        devIdString = P4ReadRawIeee1284DeviceId( controller );
                    }
                    ExFreePool( dummyPdx );
                }

                if( devIdString ) {
                    // got a 1284 device ID string from the device
                    PCHAR mfg, mdl, cls, des, aid, cid;
                    ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, devIdString+2 );
                    if( mfg && mdl ) {
                        // we have a device, is it the same device?
                        if( (0 == strcmp( mfg, pdx->Mfg )) && (0 == strcmp( mdl, pdx->Mdl )) ) {
                            // same device
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - StillThere\n",daisyChainId);
                            deviceStillThere = TRUE;
                        } else {
                            // different device - IDs don't match
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - diff 1284 ID\n",daisyChainId);
                            deviceStillThere = FALSE;
                        }
                    } else {
                        // either mfg or mdl field not found
                        DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - bad 1284 ID\n",daisyChainId);
                        deviceStillThere = FALSE;
                    }
                    // don't forget to free temp pool
                    ExFreePool( devIdString );
                    
                } else {
                    // unable to get a 1284 device ID string from the device
                    DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - no 1284 ID\n",daisyChainId);
                    deviceStillThere = FALSE;
                }
                // don't forget to deselect device
                P5DeselectAllDaisyChainDevices( controller );
                
            } else {
                // unable to select device
                DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeDaisyChain %d - Gone - unable to select\n",daisyChainId);
                deviceStillThere = FALSE;
            }
        } // end new scope for case PdoTypeDaisyChain
        break;
            
    case PdoTypeEndOfChain:
        
        //
        // Pull a fresh 1284 device ID string from the device, and
        // compare the Mfg and Mdl from the fresh device ID with
        // those stored in our extension. If the Mfg and Mdl
        // fields match then the device is still there.
        //
        {
            ULONG        tryNumber = 0;
            const ULONG  maxTries  = 5; // arbitrary number

            do {

                ++tryNumber;

                devIdString = P4ReadRawIeee1284DeviceId( controller );            

                if( devIdString ) {
                    PCHAR mfg, mdl, cls, des, aid, cid;
                    ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, devIdString+2 );
                    if( mfg && mdl ) {
                        // we have a device, is it the same device?
                        if( (0 == strcmp( mfg, pdx->Mfg )) && (0 == strcmp( mdl, pdx->Mdl )) ) {
                            // same device
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - StillThere\n");
                            deviceStillThere = TRUE;
                        } else {
                            // different device - IDs don't match
                            DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - Gone - diff 1284 ID\n");
                            deviceStillThere = FALSE;
                        }
                    } else {
                        // either mfg or mdl field not found
                        DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - Gone - bad 1284 ID\n");
                        deviceStillThere = FALSE;
                    }
                    // don't forget to free temp pool
                    ExFreePool( devIdString );
                } else {
                    // unable to get a 1284 device ID string from the device
                    DD((PCE)pdx,DDE,"P5IsDeviceStillThere - PdoTypeEndOfChain - Gone - no 1284 ID\n");
                    deviceStillThere = FALSE;
                }

                if( (FALSE == deviceStillThere ) && (PASSIVE_LEVEL == KeGetCurrentIrql()) ) {
                    LARGE_INTEGER delay;
                    delay.QuadPart = - 10 * 1000 * 120; // 120 ms - 3x the usual arbitrary delay 
                    KeDelayExecutionThread( KernelMode, FALSE, &delay);
                }

            } while( (FALSE == deviceStillThere) && (tryNumber < maxTries) );

        }
        break;
        
    default:
        
        PptAssertMsg("P5IsDeviceStillThere - invalid PdoType",FALSE);
        DD((PCE)Fdo,DDE,"P5IsDeviceStillThere - invalid PdoType\n");
        deviceStillThere = TRUE; // don't know what to do here - so, guess
    }
    
    return deviceStillThere;
}


NTSTATUS
PptAcquirePortViaIoctl(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++dvdf

Routine Description:

    This routine acquires the specified parallel port from the parallel 
      port arbiter ParPort via an IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE.

Arguments:

    PortDeviceObject - points to the ParPort device to be acquired

Return Value:

    STATUS_SUCCESS  - if the port was successfully acquired
    !STATUS_SUCCESS - otherwise

--*/
{
    LARGE_INTEGER    localTimeout;
    
    if( Timeout ) {
        localTimeout = *Timeout;           // caller specified
    } else {
        localTimeout = AcquirePortTimeout; // driver global variable default
    }

    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE, 
                                     PortDeviceObject, NULL, 0, NULL, 0, &localTimeout);
}


NTSTATUS
PptReleasePortViaIoctl(
    IN PDEVICE_OBJECT PortDeviceObject
    )
/*++dvdf

Routine Description:

    This routine releases the specified parallel port back to the the parallel 
      port arbiter ParPort via an IOCTL_INTERNAL_PARALLEL_PORT_FREE.

Arguments:

    PortDeviceObject - points to the ParPort device to be released

Return Value:

    STATUS_SUCCESS  - if the port was successfully released
    !STATUS_SUCCESS - otherwise

--*/
{
    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_PARALLEL_PORT_FREE, 
                                     PortDeviceObject, NULL, 0, NULL, 0, NULL);
}


VOID
PptWriteMfgMdlToDevNode(
    IN  PDEVICE_OBJECT  Pdo,
    IN  PCHAR           Mfg,
    IN  PCHAR           Mdl
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    if( Mfg && Mdl ) {
    
        NTSTATUS  status;
        HANDLE    handle;
        LONG      mfgLen = strlen( Mfg );
        LONG      mdlLen = strlen( Mdl );
        LONG      maxLen = mfgLen > mdlLen ? mfgLen : mdlLen;
        LONG      bufLen = ( maxLen + sizeof(CHAR) ) * sizeof(WCHAR);
        PWSTR     buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );

        if( buffer ) {

            status = IoOpenDeviceRegistryKey( Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &handle );
            
            if( STATUS_SUCCESS == status ) {
                UNICODE_STRING  uniValueName;
                LONG            wcharCount;
                
                //
                // Write MFG to DevNode
                //
                RtlInitUnicodeString( &uniValueName, L"IEEE_1284_Manufacturer" );
                wcharCount = _snwprintf( buffer, bufLen/sizeof(WCHAR), L"%S", Mfg );
                if( (wcharCount > 0) && (wcharCount < (LONG)(bufLen/sizeof(WCHAR))) ){
                    // no buffer overflow - continue
                    status = ZwSetValueKey( handle, &uniValueName, 0, REG_SZ, buffer, (wcharCount+1)*sizeof(WCHAR) );
                    PptAssert( STATUS_SUCCESS == status );
                } else {
                    // buffer overflow - skip writing this value to devnode
                    PptAssert(!"PptWriteMfgMdlToDevNode - buffer overflow on Mfg");
                    DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - buffer overflow on Mfg\n");
                }
                
                //
                // Write MDL to DevNode
                //
                RtlInitUnicodeString( &uniValueName, L"IEEE_1284_Model" );
                wcharCount = _snwprintf( buffer, bufLen/sizeof(WCHAR), L"%S", Mdl );
                if( (wcharCount > 0) && (wcharCount < (LONG)(bufLen/sizeof(WCHAR))) ){
                    // no buffer overflow - continue
                    status = ZwSetValueKey( handle, &uniValueName, 0, REG_SZ, buffer, (wcharCount+1)*sizeof(WCHAR) );
                    PptAssert( STATUS_SUCCESS == status );
                } else {
                    // buffer overflow - skip writing this value to devnode
                    PptAssert(!"PptWriteMfgMdlToDevNode - buffer overflow on Mdl");
                    DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - buffer overflow on Mdl\n");
                }
                
                ZwClose( handle );

            } else {
                DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - IoOpenDeviceRegistryKey FAILED - status = %x\n",status);
            }

            ExFreePool( buffer );

        } // end if( buffer )            

    } else {
        PptAssert(!"PptWriteMfgMdlToDevNode - Mfg or Mdl is NULL - calling function should catch this!");
        DD((PCE)pdx,DDW,"PptWriteMfgMdlToDevNode - Mfg or Mdl is NULL - calling function should catch this!");
    }
}


NTSTATUS
PptFdoHandleBusRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
{
    PFDO_EXTENSION     fdx         = Fdo->DeviceExtension;
    ULONG              deviceCount = 0;
    ULONG              daisyChainDevCount;
    PDEVICE_RELATIONS  devRel;
    ULONG              devRelSize;
    NTSTATUS           status;
    LARGE_INTEGER      acquirePortTimeout;
    BOOLEAN            acquiredPort;
    PUCHAR             controller  = fdx->PortInfo.Controller;
    BOOLEAN            changeDetected;

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - enter\n");

    //
    // acquire exclusive access to bus
    //

    // timeout is in 100 ns units
    acquirePortTimeout.QuadPart = -(10 * 1000 * 1000 * 2); // 2 seconds
    
    // RMT - is it valid to send this IOCTL to FDO from here?
    status = PptAcquirePortViaIoctl( Fdo, &acquirePortTimeout );

    if( STATUS_SUCCESS == status ) {
        // we have the port
        acquiredPort = TRUE;
    } else {
        // failed to aquire port
        acquiredPort = FALSE;
        // skip rescanning port - just report same thing we reported during previous scan
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - failed to acquire port for rescan\n");
        goto target_failed_to_acquire_port;
    }

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Port Acquired\n");

    //
    // Rescan the bus, note changes, create new PDOs or mark existing
    //   PDOs for removal as required
    //


    //
    // Handle Raw Port Legacy Interface LPTx device
    //
    if( !fdx->RawPortPdo ) {
        // first time through this - create our LPTx legacy interface PDO
        DD((PCE)fdx,DDT,"PptFdoHandleBusRelations - attempting to create RawPortPdo\n");
        fdx->RawPortPdo = P4CreatePdo( Fdo, PdoTypeRawPort, 0, NULL );
    }


    //
    // Handle End of Chain Device
    //

    // make sure all 1284.3 daisy chain devices are deselected
    P5DeselectAllDaisyChainDevices( controller );

    {
        // A small delay here seems to improve reliablility of 1284 device ID queries below.
        LARGE_INTEGER delay;
        delay.QuadPart = -1;
        KeDelayExecutionThread( KernelMode, FALSE, &delay );
    }

    if( fdx->EndOfChainPdo ) {

        if( fdx->DisableEndOfChainBusRescan ) {

            //
            // Pretend that the LPTx.4 device from previous rescan is still present.
            // 
            // This is needed to work around firmware state machines that can't handle a 
            // 1284 Device ID query while a print job is active.
            //

            ; // do nothing

        } else {

            //
            // we had an end of chain device - verify that it's still there
            //
            if( !P5IsDeviceStillThere( Fdo, fdx->EndOfChainPdo ) ) {
                // End of chain device is gone - do some cleanup and mark the PDO for removal/deletion
                DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - EndOfChain device gone\n");
                // note - P5MarkPdoAsHardwareGone sets fdx->EndOfChainPdo to NULL
                P5MarkPdoAsHardwareGone( Fdo, PdoTypeEndOfChain, 0 );
            }
        }
    }

    if( NULL == fdx->EndOfChainPdo ) {
        //
        // we don't have an EndOfChain device - check for EndOfChain device arrival
        //
        PCHAR devId = P4ReadRawIeee1284DeviceId( controller );
        if( devId ) {
            // RawIeee1284 string includes 2 bytes of length data at beginning, omit these 2 bytes in call to P4CreatePdo
            PDEVICE_OBJECT EndOfChainPdo = P4CreatePdo( Fdo, PdoTypeEndOfChain, 0, (devId+2) );
            DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - EndOfChain device detected <%s>\n",(devId+2));
            if( EndOfChainPdo ) {
                fdx->EndOfChainPdo = EndOfChainPdo;
                DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - created EndOfChainPdo\n");
            } else {
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - FAILED to create EndOfChainPdo\n");
            }
            ExFreePool( devId );
        }
    }


#ifdef _X86_ // Zip drives not supported on 64bit systems

    //
    // Handle Legacy Zip device
    //

    if( fdx->LegacyZipPdo ) {
        //
        // we had a Legacy Zip device - verify that it's still there
        //
        if( !P5IsDeviceStillThere( Fdo, fdx->LegacyZipPdo ) ) {
            // Legacy Zip device is gone - do some cleanup and mark the PDO for removal/deletion
            DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - LegacyZip device gone\n");
            // note - P5MarkPdoAsHardwareGone sets fdx->LegacyZipPdo to NULL
            P5MarkPdoAsHardwareGone( Fdo, PdoTypeLegacyZip, 0 );
        }
    }

    if( NULL == fdx->LegacyZipPdo ) {
        // 
        // We don't have a LegacyZip - check for arrival
        //
        if( !ParEnableLegacyZip ) {
            
            //
            // Enumeration of LegacyZip drives was disabled, check the
            //   registry to see if user has enabled LegacyZip detection
            // 
            
            // Check under \HKLM\SYSTEM\CCS\Services\Parport\Parameters
            PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );
            
            if( !ParEnableLegacyZip ) {
                // Check under \HKLM\SYSTEM\CCS\Services\Parallel\Parameters (upgrade case - under Win2k flag was here)
                PptRegGetDword( RTL_REGISTRY_SERVICES, L"Parallel\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );
                
                if( ParEnableLegacyZip ) {
                    // we found the setting in the old location, save
                    //   setting in new Parport location so that we find the
                    //   flag on the first check in the future
                    PptRegSetDword( RTL_REGISTRY_SERVICES, L"Parport\\Parameters", L"ParEnableLegacyZip", &ParEnableLegacyZip );
                }
            }
        } 
        
        if( ParEnableLegacyZip ) {
            
            //
            // Enumeration of LegacyZip drives is enabled - check for a LegacyZip arrival
            //
            
            if( P5LegacyZipDetected( controller ) ) {
                // detected drive - create LegacyZip PDO
                PDEVICE_OBJECT legacyZipPdo = P4CreatePdo( Fdo, PdoTypeLegacyZip, 0, NULL );
                DD((PCE)fdx,DDE,"legacy Zip arrival detected\n");
                if( legacyZipPdo ) {
                    fdx->LegacyZipPdo = legacyZipPdo;
                    DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - created LegacyZipPdo\n");
                } else {
                    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - FAILED to create LegacyZipPdo\n");
                }
            } else {
                // no legacy Zip detected - nothing more to do here
                DD((PCE)fdx,DDE,"no legacy Zip detected\n");
            }

        } // if( ParEnableLegacyZip ) -- Detection of LegacyZips is enabled

    } // if( fdx->LegacyZipPdo )


    //
    // Handle enumeration of IEEE 1284.3 Daisy Chain Devices
    //

    // did the 1284.3 daisy chain change since the last rescan?
    daisyChainDevCount = PptInitiate1284_3( fdx );
    DD((PCE)fdx,DDW,"daisyChainDevCount = %d\n",daisyChainDevCount);

    changeDetected = FALSE;

    {
        ULONG id;
        const ULONG maxId = 1;
        ULONG count = 0;
        for( id = 0 ; id <= maxId ; ++id ) {
            if( fdx->DaisyChainPdo[id] ) {
                ++count;
            }
        }
        if( count != daisyChainDevCount ) {
            // number of devices changed from previous scan
            DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - number of DC devices changed - count=%d, daisyChainDevCount=%d\n",
               count, daisyChainDevCount);
            changeDetected = TRUE;
        }
    }
    
    if( !changeDetected ) {
        // number of devices stayed the same - are any of the devices different?
        //
        // number of daisy chain devices didn't change
        // check if any of the devices changed
        ULONG id;
        const ULONG maxId = 1;
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - number of DC devices stayed same - check the devices\n");
        for( id = 0 ; id <= maxId ; ++id ) {
            if( fdx->DaisyChainPdo[id] && !P5IsDeviceStillThere( Fdo, fdx->DaisyChainPdo[id] ) ) {
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - a DC device changed\n");
                changeDetected = TRUE;
                break;
            }
        }
    }


    if( changeDetected ) {
        // we detected a change in the 1284.3 daisy chain devices - nuke all existing devices
        ULONG id;
        const ULONG maxId = 1;
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - changeDetected - nuking existing daisy chain PDOs\n");
        for( id = 0 ; id <= maxId ; ++id ) {
            if( fdx->DaisyChainPdo[id] ) {
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - nuking daisy chain %d\n",id);
                P5MarkPdoAsHardwareGone( Fdo, PdoTypeDaisyChain, id );
                PptAssert( NULL == fdx->DaisyChainPdo[id] );
            }
        }
        fdx->PnpInfo.Ieee1284_3DeviceCount = 0;
    } else {
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - !changeDetected in daisy chain PDOs\n");
    }

    // reinit daisy chain and assign addresses
    daisyChainDevCount = PptInitiate1284_3( fdx );
    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - daisyChainDevCount = %d\n",daisyChainDevCount);
    if( daisyChainDevCount > 2 ) {
        // we only support 2 devices per port even though the spec supports up to 4 devices per port
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - DaisyChainDevCount > 2, set to 2\n");
        daisyChainDevCount = 2;
    }

    if( changeDetected ) {
        // we detected a change in the 1284.3 daisy chain devices - we
        // previously nuked all old devices - now create a new PDO for
        // each device detected
        UCHAR id;
        PptAssert( 0 == fdx->PnpInfo.Ieee1284_3DeviceCount );
        for( id = 0 ; id < daisyChainDevCount ; ++id ) {

            BOOLEAN         bBuildStlDeviceId = FALSE;
            PPDO_EXTENSION  pdx               = NULL;


            DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - changeDetected - trying to create new daisy chain PDOs\n");

            if( P5SelectDaisyChainDevice( controller, id ) ) {

                PCHAR devId = NULL;

                // do a check to see if this is an SCM Micro device
                pdx = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(PDO_EXTENSION) );
                if( pdx != NULL ) {
                    RtlZeroMemory( pdx, sizeof(PDO_EXTENSION) );
                    pdx->Controller   = fdx->PortInfo.Controller;
                    bBuildStlDeviceId = ParStlCheckIfStl( pdx, id );
                    ExFreePool( pdx );
                }


                if( bBuildStlDeviceId ) {
                    
                    // SCM Micro device
                    pdx = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(PDO_EXTENSION) );
                    if( pdx != NULL ) {
                        ULONG DeviceIdSize;
                        RtlZeroMemory( pdx, sizeof(PDO_EXTENSION) );
                        pdx->Controller = fdx->PortInfo.Controller;
                        devId = ParStlQueryStlDeviceId(pdx, NULL, 0,&DeviceIdSize, TRUE);
                        ExFreePool (pdx);
                    }
                    
                } else {

                    // non-SCM Micro device
                    devId = P4ReadRawIeee1284DeviceId( controller );

                }

                if( devId ) {

                    // try to create a PDO for the daisy chain device
                    fdx->DaisyChainPdo[id] = P4CreatePdo( Fdo, PdoTypeDaisyChain, id, (devId+2) );

                    if( fdx->DaisyChainPdo[id] ) {
                        // have new PDO
                        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - new DaisyChainPdo[%d]\n",id);
                        ++(fdx->PnpInfo.Ieee1284_3DeviceCount);
                        
                        if( bBuildStlDeviceId ) {
                            // SCM Micro device - requires additional initialization
                            DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - new SCM Micro DaisyChainPdo[%d]\n",id);
                            pdx = fdx->DaisyChainPdo[id]->DeviceExtension;
                            pdx->Controller = fdx->PortInfo.Controller;
                            ParStlCheckIfStl( pdx, 0 ); // update IEEE 1284 flags in the new pdx
                        }

                    } else {
                        // create PDO failed
                        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - create DaisyChainPdo[%d] failed\n",id);
                    }
                    ExFreePool( devId );
                } else {
                    // devId failed
                    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - devId for DC %d failed\n",id);
                }
                P5DeselectAllDaisyChainDevices( controller );
            } else {
                // select failed
                DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - select for DC %d failed\n",id);
            }
        }
    }

    {
        ULONG i;
        ULONG count = 0;
        i = 0;
        for( i = 0 ; i < 2 ; ++i ) {
            if( fdx->DaisyChainPdo[i] ) {
                ++count;
            }
        }
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Ieee1284_3DeviceCount=%d  count1 = %d\n",
           fdx->PnpInfo.Ieee1284_3DeviceCount,count);
        PptAssert( fdx->PnpInfo.Ieee1284_3DeviceCount == count );
    }

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - daisyChainDevCount = %d, fdx->PnpInfo.Ieee1284_3DeviceCount = %d\n",
       daisyChainDevCount, fdx->PnpInfo.Ieee1284_3DeviceCount);

    // PptAssert( daisyChainDevCount == fdx->PnpInfo.Ieee1284_3DeviceCount );

#endif // _X86_

target_failed_to_acquire_port: // jump here if we couldn't get the port - result is that we report that nothing has changed

    //
    // Count the number of devices that we are going to report to PnP
    //   so that we can allocate a DEVICE_RELATIONS structure of the
    //   appropriate size.
    //

    if( fdx->RawPortPdo ) {
        ++deviceCount;
    }

    if( fdx->EndOfChainPdo ) {
        ++deviceCount;
    }

    if( fdx->LegacyZipPdo ) {
        ++deviceCount;
    }

    {
        const ULONG maxDaisyChainId = 1;
        ULONG i;
        for( i=0 ; i <= maxDaisyChainId; ++i ) {
            if( fdx->DaisyChainPdo[i] ) {
                ++deviceCount;
            } else {
                break;
            }
        }
    }

    if( deviceCount > 0 && fdx->RawPortPdo ) {

        //
        // Allocate and populate DEVICE_RELATIONS structure that we return to PnP
        //
        
        devRelSize = sizeof(DEVICE_RELATIONS) + (deviceCount-1)*sizeof(PDEVICE_OBJECT);
        devRel     = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, devRelSize );
        
        if( !devRel ) {
            // release port and fail IRP
            P4ReleaseBus( Fdo );
            return P4CompleteRequestReleaseRemLock( Irp, STATUS_INSUFFICIENT_RESOURCES, Irp->IoStatus.Information, &fdx->RemoveLock );
        }
        
        { // local block - begin
            ULONG idx = 0;
            
            RtlZeroMemory( devRel, devRelSize );
            
            ++(devRel->Count);
            ObReferenceObject( fdx->RawPortPdo );
            devRel->Objects[ idx++ ] = fdx->RawPortPdo;
            
            if( fdx->EndOfChainPdo ) {
                ++(devRel->Count);
                ObReferenceObject( fdx->EndOfChainPdo );
                devRel->Objects[ idx++ ] = fdx->EndOfChainPdo;
            }
            
            if( fdx->LegacyZipPdo ) {
                ++(devRel->Count);
                ObReferenceObject( fdx->LegacyZipPdo );
                devRel->Objects[ idx++ ] = fdx->LegacyZipPdo;
            }
            
            {
                const ULONG maxDaisyChainId = 3;
                ULONG       i;
                
                for( i=0 ; i <= maxDaisyChainId; ++i ) {
                    if( fdx->DaisyChainPdo[i] ) {
                        ++(devRel->Count);
                        ObReferenceObject( fdx->DaisyChainPdo[i] );
                        devRel->Objects[ idx++ ] = fdx->DaisyChainPdo[i];
                    } else {
                        break;
                    }
                }
            }
            
        } // local block - end
        
        PptAssert( deviceCount == devRel->Count ); // verify that our two counts match
        
        DD((PCE)fdx,DDE,"PptFdoHandleBusRelations - reporting %d devices\n",devRel->Count);
        
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = (ULONG_PTR)devRel;
    } else {
        // deviceCount <= 0 - error somewhere - likely two ports
        //   have the same LPTx name in the FDO stack's devnode

        // RMT - this assert needs to be changed to ErrorLog msg 
        PptAssert(!"no RawPort device - likely multiple ports have same LPTx name - email: DFritz");
    }


    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - passing IRP down stack\n");

    status = PptPnpPassThroughPnpIrpAndReleaseRemoveLock( fdx, Irp );

    //
    // Release our lock on the bus and pass Irp down the stack
    //
    if( acquiredPort ) {
        PIO_WORKITEM workItem = IoAllocateWorkItem( Fdo );
        if( workItem ) {

            PIO_WORKITEM oldWorkItem = InterlockedCompareExchangePointer( &fdx->FreePortWorkItem, workItem, NULL );
            if( NULL == oldWorkItem ) {

                // no workitem currently in use, queue this one
                IoQueueWorkItem( workItem, P5WorkItemFreePort, DelayedWorkQueue, fdx );

            } else {

                // there is already a workitem in use, bail out and recover as best we can

                // We really shouldn't be able to get here - how in blazes did we
                // acquire the port at the top of this function if the workitem
                // that we queued to free the port during the previous invocation
                // of this function has not yet freed the port?

                PptAssertMsg( "workitem collision - port arbitration state may be hosed", (oldWorkItem != NULL) );
                IoFreeWorkItem( workItem );
                PptFreePort( fdx );

            }

        } else {
            PptFreePort( fdx );
        }
        // DbgPrint("xxx work item to free port has been queued\n");
        //DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Releasing Port\n");
        //PptFreePort( fdx );
        //DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Port Released\n");
    } else {
        DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - Port Not acquired so no need to release\n");
    }

    DD((PCE)fdx,DDW,"PptFdoHandleBusRelations - exit\n");

    return status;
}

NTSTATUS
PptPnpStartScanPciCardCmResourceList(
    IN  PFDO_EXTENSION Fdx,
    IN  PIRP              Irp, 
    OUT PBOOLEAN          FoundPort,
    OUT PBOOLEAN          FoundIrq,
    OUT PBOOLEAN          FoundDma
    )
/*++dvdf3

Routine Description:

    This routine is used to parse the resource list for what we
      believe are PCI parallel port cards.

    This function scans the CM_RESOURCE_LIST supplied with the Pnp 
      IRP_MN_START_DEVICE IRP, extracts the resources from the list, 
      and saves them in the device extension.

Arguments:

    Fdx    - The device extension of the target of the START IRP
    Irp          - The IRP
    FoundPort    - Did we find a  Port resource?
    FoundIrq     - Did we find an IRQ  resource?
    FoundDma     - Did we find a  DMA  resource?

Return Value:

    STATUS_SUCCESS                - if we were given a resource list,
    STATUS_INSUFFICIENT_RESOURCES - otherwise

--*/
{
    NTSTATUS                        status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               ResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG                           i;
    ULONG                           length;
    
    *FoundPort = FALSE;
    *FoundIrq  = FALSE;
    *FoundDma  = FALSE;
    
    ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    
    FullResourceDescriptor = &ResourceList->List[0];
    
    if( FullResourceDescriptor ) {
        
        Fdx->InterfaceType = FullResourceDescriptor->InterfaceType;
        
        PartialResourceList = &FullResourceDescriptor->PartialResourceList;
        
        for (i = 0; i < PartialResourceList->Count; i++) {
            
            PartialResourceDescriptor = &PartialResourceList->PartialDescriptors[i];
            
            switch (PartialResourceDescriptor->Type) {
                
            case CmResourceTypePort:
                
                length = PartialResourceDescriptor->u.Port.Length;

                //
                // Use a heuristic based on length to guess which register set is
                //   SPP+EPP, which is ECP, and which is PCI Config or other.
                //
                switch( length ) {

                case 8: // SPP + EPP base address

                    Fdx->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
                    Fdx->PortInfo.SpanOfController   = PartialResourceDescriptor->u.Port.Length;
                    Fdx->PortInfo.Controller         = (PUCHAR)(ULONG_PTR)Fdx->PortInfo.OriginalController.QuadPart;
                    Fdx->AddressSpace                = PartialResourceDescriptor->Flags;
                    *FoundPort = TRUE;
                    break;

                case 4: // ECP base address
                    
                    Fdx->PnpInfo.OriginalEcpController = PartialResourceDescriptor->u.Port.Start;
                    Fdx->PnpInfo.SpanOfEcpController   = PartialResourceDescriptor->u.Port.Length;
                    Fdx->PnpInfo.EcpController         = (PUCHAR)(ULONG_PTR)Fdx->PnpInfo.OriginalEcpController.QuadPart;
                    Fdx->EcpAddressSpace               = PartialResourceDescriptor->Flags;
                    break;

                default:
                    // don't know what this is - ignore it
                    ;
                }
                break;
                
            case CmResourceTypeBusNumber:
                
                Fdx->BusNumber = PartialResourceDescriptor->u.BusNumber.Start;
                break;
                
            case CmResourceTypeInterrupt:
                
                *FoundIrq = TRUE;
                Fdx->FoundInterrupt       = TRUE;
                Fdx->InterruptLevel       = (KIRQL)PartialResourceDescriptor->u.Interrupt.Level;
                Fdx->InterruptVector      = PartialResourceDescriptor->u.Interrupt.Vector;
                Fdx->InterruptAffinity    = PartialResourceDescriptor->u.Interrupt.Affinity;
                
                if (PartialResourceDescriptor->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    
                    Fdx->InterruptMode = Latched;
                    
                } else {
                    
                    Fdx->InterruptMode = LevelSensitive;
                }
                break;
                
            case CmResourceTypeDma:
                
                // we don't do anything with DMA - fall through to default case
                
            default:

                break;

            } // end switch( PartialResourceDescriptor->Type )
        } // end for(... ; i < PartialResourceList->Count ; ...)
    } // end if( FullResourceDescriptor )
    
    return status;
}

BOOLEAN PptIsPci(
    PFDO_EXTENSION Fdx, 
    PIRP              Irp 
)
/*++

Does this look like a PCI card? Return TRUE if yes, FALSE otherwise

--*/
{
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               ResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG                           i;
    ULONG                           portResourceDescriptorCount = 0;
    BOOLEAN                         largePortRangeFound         = FALSE;
    ULONG                           rangeLength;
    
    //
    // If there are more than 2 IO resource descriptors, or if any IO resource
    //   descriptor has a range > 8 bytes, then assume that this is a PCI device
    //   and requires non-traditional handling.
    //

    ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    
    if (ResourceList == NULL) {
        // we weren't given any resources
        return FALSE;
    }

    FullResourceDescriptor = &ResourceList->List[0];
    
    if (FullResourceDescriptor) {
        
        PartialResourceList = &FullResourceDescriptor->PartialResourceList;
        
        for (i = 0; i < PartialResourceList->Count; i++) {
            
            PartialResourceDescriptor = &PartialResourceList->PartialDescriptors[i];
            
            switch (PartialResourceDescriptor->Type) {
                
            case CmResourceTypePort:
                
                rangeLength = PartialResourceDescriptor->u.Port.Length;
                DD((PCE)Fdx,DDT,"pnp::PptIsPCI - CmResourceTypePort - Start= %I64x, Length= %x , \n",
                                       PartialResourceDescriptor->u.Port.Start.QuadPart, rangeLength);

                ++portResourceDescriptorCount;

                if( rangeLength > 8 ) {
                    largePortRangeFound = TRUE;
                }
                break;
                
            default:
                ;
            } // end switch( PartialResourceDescriptor->Type )
        } // end for(... ; i < PartialResourceList->Count ; ...)
    } // end if( FullResourceDescriptor )
    
    if( (portResourceDescriptorCount > 2) || (TRUE == largePortRangeFound) ) {
        // looks like PCI
        return TRUE;
    } else {
        // does not look like PCI
        return FALSE;
    }
}

NTSTATUS
PptPnpStartScanCmResourceList(
    IN  PFDO_EXTENSION Fdx,
    IN  PIRP              Irp, 
    OUT PBOOLEAN          FoundPort,
    OUT PBOOLEAN          FoundIrq,
    OUT PBOOLEAN          FoundDma
    )
/*++dvdf3

Routine Description:

    This function is a helper function called by PptPnpStartDevice(). 

    This function scans the CM_RESOURCE_LIST supplied with the Pnp 
      IRP_MN_START_DEVICE IRP, extracts the resources from the list, 
      and saves them in the device Fdx.

Arguments:

    Fdx    - The device extension of the target of the START IRP
    Irp          - The IRP
    FoundPort    - Did we find a  Port resource?
    FoundIrq     - Did we find an IRQ  resource?
    FoundDma     - Did we find a  DMA  resource?

Return Value:

    STATUS_SUCCESS                - if we were given a resource list,
    STATUS_INSUFFICIENT_RESOURCES - otherwise

--*/
{
    NTSTATUS                        status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation( Irp );
    PCM_RESOURCE_LIST               ResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    FullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       PartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG                           i;
    PHYSICAL_ADDRESS                start;
    ULONG                           length;
    BOOLEAN                         isPci = FALSE;
    
    *FoundPort = FALSE;
    *FoundIrq  = FALSE;
    *FoundDma  = FALSE;
    
    ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    
    if (ResourceList == NULL) {
        // we weren't given any resources, bail out
        DD((PCE)Fdx,DDT,"START - FAIL - No Resources - AllocatedResourcesTranslated == NULL\n");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto targetExit;
    }

    if( TRUE == PptIsPci( Fdx, Irp ) ) {
        // This appears to be a PCI card
        status = PptPnpStartScanPciCardCmResourceList(Fdx, Irp, FoundPort, FoundIrq, FoundDma);
        isPci=TRUE;
        goto targetExit;
    }
    
    //
    // Device appears to be traditional / non-PCI card parallel port
    //

    FullResourceDescriptor = &ResourceList->List[0];
    
    if (FullResourceDescriptor) {
        
        Fdx->InterfaceType = FullResourceDescriptor->InterfaceType;
        
        PartialResourceList = &FullResourceDescriptor->PartialResourceList;
        
        for (i = 0; i < PartialResourceList->Count; i++) {
            
            PartialResourceDescriptor = &PartialResourceList->PartialDescriptors[i];
            
            switch (PartialResourceDescriptor->Type) {
                
            case CmResourceTypePort:
                
                start  = PartialResourceDescriptor->u.Port.Start;
                length = PartialResourceDescriptor->u.Port.Length;
                DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - start= %I64x , length=%x\n",start, length);

                *FoundPort = TRUE;
                if ((Fdx->PortInfo.OriginalController.LowPart == 0) &&
                    (Fdx->PortInfo.OriginalController.HighPart == 0)) {
                    
                    DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - assuming Controller\n");

                    Fdx->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
                    Fdx->PortInfo.SpanOfController   = PartialResourceDescriptor->u.Port.Length;
                    Fdx->PortInfo.Controller         = (PUCHAR)(ULONG_PTR)Fdx->PortInfo.OriginalController.QuadPart;
                    Fdx->AddressSpace                = PartialResourceDescriptor->Flags;
                    
                } else if ((Fdx->PnpInfo.OriginalEcpController.LowPart == 0) &&
                           (Fdx->PnpInfo.OriginalEcpController.HighPart == 0) &&
                           (IsNotNEC_98)) {
                    
                    if ((PartialResourceDescriptor->u.Port.Start.LowPart < Fdx->PortInfo.OriginalController.LowPart) &&
                        (PartialResourceDescriptor->u.Port.Start.HighPart < Fdx->PortInfo.OriginalController.HighPart)) {
                        
                        //
                        // Swapping address spaces
                        //
                        
                        DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - assuming Controller - Swapping Controller/EcpController\n");

                        Fdx->PnpInfo.OriginalEcpController = Fdx->PortInfo.OriginalController;
                        Fdx->PnpInfo.SpanOfEcpController   = Fdx->PortInfo.SpanOfController;
                        Fdx->PnpInfo.EcpController         = Fdx->PortInfo.Controller;
                        Fdx->EcpAddressSpace               = Fdx->AddressSpace;
                        
                        Fdx->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
                        Fdx->PortInfo.SpanOfController   = PartialResourceDescriptor->u.Port.Length;
                        Fdx->PortInfo.Controller         = (PUCHAR)(ULONG_PTR)Fdx->PortInfo.OriginalController.QuadPart;
                        Fdx->AddressSpace                = PartialResourceDescriptor->Flags;
                        
                    } else {
                        DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - assuming EcpController\n");

                        Fdx->PnpInfo.OriginalEcpController = PartialResourceDescriptor->u.Port.Start;
                        Fdx->PnpInfo.SpanOfEcpController   = PartialResourceDescriptor->u.Port.Length;
                        Fdx->PnpInfo.EcpController         = (PUCHAR)(ULONG_PTR)Fdx->PnpInfo.OriginalEcpController.QuadPart;
                        Fdx->EcpAddressSpace               = PartialResourceDescriptor->Flags;
                    }
                    
                }
                break;
                
            case CmResourceTypeBusNumber:
                
                Fdx->BusNumber = PartialResourceDescriptor->u.BusNumber.Start;
                break;
                
            case CmResourceTypeInterrupt:
                
                *FoundIrq = TRUE;
                Fdx->FoundInterrupt       = TRUE;
                Fdx->InterruptLevel       = (KIRQL)PartialResourceDescriptor->u.Interrupt.Level;
                Fdx->InterruptVector      = PartialResourceDescriptor->u.Interrupt.Vector;
                Fdx->InterruptAffinity    = PartialResourceDescriptor->u.Interrupt.Affinity;
                
                if (PartialResourceDescriptor->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    
                    Fdx->InterruptMode = Latched;
                    
                } else {
                    
                    Fdx->InterruptMode = LevelSensitive;
                }
                break;
                
            case CmResourceTypeDma:

                // we don't do anything with DMA - fall through to default case

            default:

                break;

            } // end switch( PartialResourceDescriptor->Type )
        } // end for(... ; i < PartialResourceList->Count ; ...)
    } // end if( FullResourceDescriptor )
    
targetExit:

    if( FALSE == isPci ) {
        // we scanned the resources - dump what we found
        DD((PCE)Fdx,DDT,"pnp::PptPnpStartScanCmResourceList - done, found:\n");
        DD((PCE)Fdx,DDT,"  OriginalEcpController= %I64x\n", Fdx->PnpInfo.OriginalEcpController);
        DD((PCE)Fdx,DDT,"  EcpController        = %p\n",    Fdx->PnpInfo.EcpController);
        DD((PCE)Fdx,DDT,"  SpanOfEcpController  = %x\n",    Fdx->PnpInfo.SpanOfEcpController);
    }
    return status;
}

NTSTATUS
PptPnpStartValidateResources(
    IN PDEVICE_OBJECT    DeviceObject,                              
    IN BOOLEAN           FoundPort,
    IN BOOLEAN           FoundIrq,
    IN BOOLEAN           FoundDma
    )
/*++dvdf3

Routine Description:

    This function is a helper function called by PptPnpStartDevice(). 

    This function does a sanity check of the resources saved in our
      extension by PptPnpStartScanCmResourceList() to determine 
      if those resources appear to be valid. Checks for for Irq 
      and Dma resource validity are anticipated in a future version.

Arguments:

    DeviceObject - The target of the START IRP
    FoundPort    - Did we find a  Port resource?
    FoundIrq     - Did we find an IRQ  resource?
    FoundDma     - Did we find a  DMA  resource?

Return Value:

    STATUS_SUCCESS        - on success,
    STATUS_NO_SUCH_DEVICE - if we weren't given a port resource,
    STATUS_NONE_MAPPED    - if we were given a port resource but our 
                              port address is NULL

--*/
{
    PFDO_EXTENSION fdx = DeviceObject->DeviceExtension;
    NTSTATUS          status    = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( FoundIrq ); // future use
    UNREFERENCED_PARAMETER( FoundDma ); // future use

    if( !FoundPort ) {
        status = STATUS_NO_SUCH_DEVICE;
    } else {
//         fdx->PortInfo.Controller = (PUCHAR)(ULONG_PTR)fdx->PortInfo.OriginalController.LowPart;
        fdx->PortInfo.Controller = (PUCHAR)(ULONG_PTR)fdx->PortInfo.OriginalController.QuadPart;

        if(!fdx->PortInfo.Controller) {
            // ( Controller == NULL ) is invalid
            PptLogError(DeviceObject->DriverObject, DeviceObject,
                        fdx->PortInfo.OriginalController, PhysicalZero, 0, 0, 0, 10,
                        STATUS_SUCCESS, PAR_REGISTERS_NOT_MAPPED);
            status = STATUS_NONE_MAPPED;
        }
    }
    return status;
}


BOOLEAN
PptPnpFilterExistsNonIrqResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterResourceRequirements(). 

    This function scans the IO_RESOURCE_REQUIREMENTS_LIST to determine
      whether there exists any resource alternatives that do NOT contain
      an IRQ resource descriptor. The method used to filter out IRQ
      resources may differ based on whether or not there exists a
      resource alternative that does not contain an IRQ resource
      descriptor.

Arguments:

    ResourceRequirementsList - The list to scan.

Return Value:

    TRUE  - There exists at least one resource alternative in the list that
              does not contain an IRQ resource descriptor.
    FALSE - Otherwise.           

--*/
{
    ULONG listCount = ResourceRequirementsList->AlternativeLists;
    PIO_RESOURCE_LIST curList;
    ULONG i;

    i=0;
    curList = ResourceRequirementsList->List;
    while( i < listCount ) {
        DD(NULL,DDT,"Searching List i=%d for an IRQ, curList= %x\n", i,curList);
        {
            ULONG                   remain   = curList->Count;
            PIO_RESOURCE_DESCRIPTOR curDesc  = curList->Descriptors;
            BOOLEAN                 foundIrq = FALSE;
            while( remain ) {
                DD(NULL,DDT," curDesc= %x , remain=%d\n", curDesc, remain);
                if(curDesc->Type == CmResourceTypeInterrupt) {
                    DD(NULL,DDT," Found IRQ - skip to next list\n");
                    foundIrq = TRUE;
                    break;
                }
                ++curDesc;
                --remain;
            }
            if( foundIrq == FALSE ) {
                //
                // We found a resource list that does not contain an IRQ resource. 
                //   Our search is over.
                //
                DD(NULL,DDT," Found a list with NO IRQ - return TRUE from PptPnpFilterExistsNonIrqResourceList\n");
                return TRUE;
            }
        }
        //
        // The next list starts immediately after the last descriptor of the current list.
        //
        curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
        ++i;
    }

    //
    // All resource alternatives contain at least one IRQ resource descriptor.
    //
    DD(NULL,DDT,"all lists contain IRQs - return FALSE from PptPnpFilterExistsNonIrqResourceList\n");
    return FALSE;
}

VOID
PptPnpFilterRemoveIrqResourceLists(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterResourceRequirements(). 

    This function removes all resource alternatives (IO_RESOURCE_LISTs) 
      that contain IRQ resources from the IO_RESOURCE_REQUIREMENTS_LIST 

Arguments:

    ResourceRequirementsList - The list to process.

Return Value:

    none.

--*/
{
    ULONG listCount = ResourceRequirementsList->AlternativeLists;
    PIO_RESOURCE_LIST curList;
    PIO_RESOURCE_LIST nextList;
    ULONG i;
    PCHAR currentEndOfResourceRequirementsList;
    LONG bytesToMove;

    DD(NULL,DDT,"Enter PptPnpFilterRemoveIrqResourceLists() - AlternativeLists= %d\n", listCount);

    //
    // We use the end of the list to compute the size of the memory
    //   block to move when we remove a resource alternative from the
    //   list of lists.
    //
    currentEndOfResourceRequirementsList = PptPnpFilterGetEndOfResourceRequirementsList(ResourceRequirementsList);

    i=0;
    curList = ResourceRequirementsList->List;

    //
    // Walk through the IO_RESOURCE_LISTs.
    //
    while( i < listCount ) {

        if( PptPnpListContainsIrqResourceDescriptor(curList) ) {
            //
            // The current list contains IRQ, remove it by shifting the 
            //   remaining lists into its place and decrementing the list count.
            //

            DD(NULL,DDT,"list contains an IRQ - Removing List\n");

            //
            // Get a pointer to the start of the next list.
            //
            nextList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);

            //
            // compute the number of bytes to move
            //
            bytesToMove = (LONG)(currentEndOfResourceRequirementsList - (PCHAR)nextList);

            //
            // if (currentEndOfResourceRequirementsList == next list), 
            //   then this is the last list so there is nothing to move.
            //
            if( bytesToMove > 0 ) {
                //
                // More lists remain - shift them into the hole.
                //
                RtlMoveMemory(curList, nextList, bytesToMove);

                //
                // Adjust the pointer to the end of of the 
                //   IO_RESOURCE_REQUIREMENTS_LIST (list of lists) due to the shift.
                //
                currentEndOfResourceRequirementsList -= ( (PCHAR)nextList - (PCHAR)curList );
            }

            //
            // Note that we removed an IO_RESOURCE_LIST from the IO_RESOURCE_REQUIREMENTS_LIST.
            //
            --listCount;

        } else {
            //
            // The current list does not contain an IRQ resource, advance to next list.
            //
            DD(NULL,DDT,"list does not contain an IRQ - i=%d listCount=%d curList= %#x\n", i,listCount,curList);
            curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
            ++i;
        }
    }

    //
    // Note the post filtered list count in the ResourceRequirementsList.
    //
    ResourceRequirementsList->AlternativeLists = listCount;

    DD(NULL,DDT,"Leave PptPnpFilterRemoveIrqResourceLists() - AlternativeLists= %d\n", listCount);

    return;
}

PVOID
PptPnpFilterGetEndOfResourceRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by PptPnpFilterRemoveIrqResourceLists()

    This function finds the end of an IO_RESOURCE_REQUIREMENTS_LIST 
      (list of IO_RESOURCE_LISTs).

Arguments:

    ResourceRequirementsList - The list to scan.

Return Value:

    Pointer to the next address past the end of the IO_RESOURCE_REQUIREMENTS_LIST.

--*/
{
    ULONG listCount = ResourceRequirementsList->AlternativeLists;
    PIO_RESOURCE_LIST curList;
    ULONG i;

    i=0;
    curList = ResourceRequirementsList->List;
    while( i < listCount ) {
        //
        // Pointer arithmetic based on the size of an IO_RESOURCE_DESCRIPTOR.
        //
        curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
        ++i;
    }
    return (PVOID)curList;
}

VOID
PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(
    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterResourceRequirements(). 

    This function "nukes" all IRQ resources descriptors
      in the IO_RESOURCE_REQUIREMENTS_LIST by changing the descriptor
      types from CmResourceTypeInterrupt to CmResourceTypeNull.

Arguments:

    ResourceRequirementsList - The list to process.

Return Value:

    none.

--*/
{
    ULONG             listCount = ResourceRequirementsList->AlternativeLists;
    ULONG             i         = 0;
    PIO_RESOURCE_LIST curList   = ResourceRequirementsList->List;

    DD(NULL,DDT,"Enter PptPnpFilterNukeIrqResourceDescriptorsFromAllLists() - AlternativeLists= %d\n", listCount);

    //
    // Walk through the list of IO_RESOURCE_LISTs in the IO_RESOURCE_REQUIREMENTS list.
    //
    while( i < listCount ) {
        DD(NULL,DDT,"Nuking IRQs from List i=%d, curList= %x\n", i,curList);
        //
        // Nuke all IRQ resources from the current IO_RESOURCE_LIST.
        //
        PptPnpFilterNukeIrqResourceDescriptors( curList );
        curList = (PIO_RESOURCE_LIST)(curList->Descriptors + curList->Count);
        ++i;
    }
}

VOID
PptPnpFilterNukeIrqResourceDescriptors(
    PIO_RESOURCE_LIST IoResourceList
    )
/*++dvdf8

Routine Description:

    This function is a helper function called by 
      PptPnpFilterNukeIrqResourceDescriptorsFromAllLists().

    This function "nukes" all IRQ resources descriptors
      in the IO_RESOURCE_LIST by changing the descriptor
      types from CmResourceTypeInterrupt to CmResourceTypeNull.

Arguments:

    IoResourceList - The list to process.

Return Value:

    none.

--*/
{
    PIO_RESOURCE_DESCRIPTOR  pIoResourceDescriptorIn  = IoResourceList->Descriptors;
    ULONG                    i;

    //
    // Scan the descriptor list for Interrupt descriptors.
    //
    for (i = 0; i < IoResourceList->Count; ++i) {

        if (pIoResourceDescriptorIn->Type == CmResourceTypeInterrupt) {
            //
            // Found one - change resource type from Interrupt to Null.
            //
            pIoResourceDescriptorIn->Type = CmResourceTypeNull;
            DD(NULL,DDT," - giving up IRQ resource - MinimumVector: %d MaximumVector: %d\n",
                       pIoResourceDescriptorIn->u.Interrupt.MinimumVector,
                       pIoResourceDescriptorIn->u.Interrupt.MaximumVector);
        }
        ++pIoResourceDescriptorIn;
    }
}

BOOLEAN
PptPnpListContainsIrqResourceDescriptor(
    IN PIO_RESOURCE_LIST List
)
{
    ULONG i;
    PIO_RESOURCE_DESCRIPTOR curDesc = List->Descriptors;

    for(i=0; i<List->Count; ++i) {
        if(curDesc->Type == CmResourceTypeInterrupt) {
            return TRUE;
        } else {
            ++curDesc;
        }
    }
    return FALSE;
}

NTSTATUS
PptPnpBounceAndCatchPnpIrp(
    PFDO_EXTENSION Fdx,
    PIRP              Irp
)
/*++

  Pass a PnP IRP down the stack to our parent and catch it on the way back
    up after it has been handled by the drivers below us in the driver stack.

--*/
{
    NTSTATUS       status;
    KEVENT         event;
    PDEVICE_OBJECT parentDevObj = Fdx->ParentDeviceObject;

    DD((PCE)Fdx,DDT,"PptBounceAndCatchPnpIrp()\n");

    // setup
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, PptSynchCompletionRoutine, &event, TRUE, TRUE, TRUE);

    // send
    status = IoCallDriver(parentDevObj, Irp);

    // wait for completion routine to signal that it has caught the IRP on
    //   its way back out
    KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

    if (status == STATUS_PENDING) {
        // If IoCallDriver returned STATUS_PENDING, then we must
        //   extract the "real" status from the IRP
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PptPnpPassThroughPnpIrpAndReleaseRemoveLock(
    IN PFDO_EXTENSION Fdx,
    IN PIRP              Irp
)
/*++

  Pass a PnP IRP down the stack to our parent, 
    release RemoveLock, and return status from IoCallDriver.

--*/
{
    NTSTATUS status;

    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(Fdx->ParentDeviceObject, Irp);
    PptReleaseRemoveLock(&Fdx->RemoveLock, Irp);
    return status;
}


VOID
P4DestroyPdo(
    IN PDEVICE_OBJECT  Pdo
    )
{
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;
    PDEVICE_OBJECT  fdo = pdx->Fdo;
    PFDO_EXTENSION  fdx = fdo->DeviceExtension;

    DD((PCE)pdx,DDT,"P4DestroyPdo\n");

    //
    // Remove registry entry under HKLM\HARDWARE\DEVICEMAP\PARALLEL PORTS
    //
    if( pdx->PdoName ) {
        NTSTATUS status = RtlDeleteRegistryValue( RTL_REGISTRY_DEVICEMAP, (PWSTR)L"PARALLEL PORTS", pdx->PdoName );
        if( status != STATUS_SUCCESS ) {
            DD((PCE)pdx,DDW,"P4DestroyPdo - Failed to Delete DEVICEMAP registry entry - status=%x\n",status);
        }
    }

    //
    // remove self from FDO's DevDeletionListHead list
    //
    if( !IsListEmpty( &fdx->DevDeletionListHead ) ) {

        BOOLEAN      done  = FALSE;
        PLIST_ENTRY  first = NULL;
        
        while( !done ) {
            
            // look for self on list - remove if found

            PLIST_ENTRY current = RemoveHeadList( &fdx->DevDeletionListHead );        

            if( CONTAINING_RECORD( current, PDO_EXTENSION, DevDeletionList ) != pdx ) {

                // this is not the entry that we are looking for

                if( !first ) {

                    // note the first entry so we can stop if we search the entire list and don't find self

                    first = current;
                    InsertTailList( &fdx->DevDeletionListHead, current );

                } else {

                    // have we searched the entire list?

                    if( first == current ) {

                        // we searched the entire list and didn't find self - we must not be on the list
                        // put entry back on front of list, then we're done with search
                        DD((PCE)pdx,DDT,"P4DestroyPdo - searched entire list - we're not on it - done with search\n");
                        InsertHeadList( &fdx->DevDeletionListHead, current );
                        done = TRUE;

                    } else {

                        // not the entry that we're looking for - place at end of list - continue search
                        InsertTailList( &fdx->DevDeletionListHead, current );
                    }
                }

            } else {

                // found self - self removed from list - done with search
                DD((PCE)pdx,DDT,"P4DestroyPdo - found self on FDO's DevDeletionListHead and removed self - done with search\n");
                done = TRUE;
            }

        } // end while( !done )

    } // endif( !IsListEmpty... )


    //
    // clean up any ShadowBuffer queue used by hardware ECP modes
    //
    if( pdx->bShadowBuffer ) {
        BOOLEAN queueDeleted = Queue_Delete( &(pdx->ShadowBuffer) );
        if( !queueDeleted ) {
            PptAssertMsg( "Failed to delete queue?!?", FALSE );
        }
        pdx->bShadowBuffer = FALSE;
    }
    PptAssert( NULL == pdx->ShadowBuffer.theArray );


    //
    // clean up symbolic link - unless it has been previously cleaned up elsewhere
    //
    if( pdx->SymLinkName ) {
        P5DeletePdoSymLink( Pdo );
    }

    //
    // clean up other device extension pool allocations
    //
    if( pdx->Mfg ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Mfg <%s>\n", pdx->Mfg);
        ExFreePool( pdx->Mfg );
        pdx->Mfg = NULL;
    }
    if( pdx->Mdl ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Mdl <%s>\n", pdx->Mdl);
        ExFreePool( pdx->Mdl );
        pdx->Mdl = NULL;
    }
    if( pdx->Cid ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Cid <%s>\n", pdx->Cid);
        ExFreePool( pdx->Cid );
        pdx->Cid = NULL;
    }
    if( pdx->DeviceInterface.Buffer ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up DeviceInterface <%S>\n", pdx->PdoName);
        RtlFreeUnicodeString( &pdx->DeviceInterface );
        pdx->DeviceInterfaceState = FALSE;
    }
    if( pdx->PdoName ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up PdoName <%S>\n", pdx->PdoName);
        ExFreePool( pdx->PdoName );
        pdx->PdoName = NULL;
    }
    if( pdx->Location ) {
        DD((PCE)pdx,DDT,"P4DestroyPdo - clean up Location <%s>\n", pdx->Location);
        ExFreePool( pdx->Location );
        pdx->Location = NULL;
    }

    //
    // delete device object
    //
    IoDeleteDevice( Pdo );
}


VOID
P4SanitizeId(
    IN OUT PWSTR DeviceId
    )
/*++

Routine Description:

    This routine parses the UNICODE_NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (L' ')
        c >  0x7F
        c == 0x2C (L',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               UNICODE_NULL terminated.

Return Value:

    None.

--*/

{
    PWCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= L' ') || (*p > (WCHAR)0x7F) || (*p == L',') ) {
            *p = L'_';
        }
    }
}


NTSTATUS
P4InitializePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN PDEVICE_OBJECT  Pdo,
    IN enum _PdoType   PdoType,
    IN UCHAR           DaisyChainId, // Ignored unless PdoTypeDaisyChain == PdoType
    IN PCHAR           Ieee1284Id,   // NULL if none
    IN PWSTR           PdoName,
    IN PWSTR           SymLinkName
    )
{
    PFDO_EXTENSION   fdx = Fdo->DeviceExtension;
    PPDO_EXTENSION   pdx = Pdo->DeviceExtension;
    
    // we do buffered IO rather than direct IO
    Pdo->Flags |= DO_BUFFERED_IO;

    // DO_POWER_PAGABLE should be set same as parent FDO
    Pdo->Flags |= ( Fdo->Flags & DO_POWER_PAGABLE );

    // need to be able to forward Irps to parent
    Pdo->StackSize = Fdo->StackSize + 1;

    RtlZeroMemory( pdx, sizeof(PDO_EXTENSION) );

    // used by debugger extension
    pdx->Signature1 = PARPORT_TAG;
    pdx->Signature2 = PARPORT_TAG;

    // frequently need to know what type of PDO we have in order to do special case handling 
    pdx->PdoType = PdoType;

    // Save name used in call to IoCreateDevice (for debugging use)
    pdx->PdoName     = PdoName;

    // Save name used in call to IoCreateUnprotectedSymbolicLink for later call to IoDeleteSymbolicLink
    pdx->SymLinkName = SymLinkName;

    // initialize Mfg, Mdl, and Cid
    if( Ieee1284Id ) {
        //
        // Extract Mfg, Mdl, and Cid from Ieee1284Id and save in extension
        //

        // ParPnpFindDeviceIdKeys modifies deviceID passed in so make
        // a copy of the 1284 ID and pass in a pointer to the copy
        PCHAR tmpBuffer;
        ULONG tmpBufLen = strlen(Ieee1284Id) + sizeof(CHAR);

        DD((PCE)fdx,DDT,"P4InitializePdo - have Ieee1284Id\n");

        tmpBuffer = ExAllocatePool( PagedPool, tmpBufLen );
        if( tmpBuffer ) {
            PCHAR  mfg, mdl, cls, des, aid, cid;
            RtlZeroMemory( tmpBuffer, tmpBufLen );
            strcpy( tmpBuffer, Ieee1284Id );
            DD((PCE)fdx,DDT,"P4InitializePdo - calling ParPnpFindDeviceIdKeys\n");
            ParPnpFindDeviceIdKeys( &mfg, &mdl, &cls, &des, &aid, &cid, tmpBuffer );
            if( mfg ) {
                PCHAR buffer;
                ULONG bufLen = strlen(mfg) + sizeof(CHAR);
                DD((PCE)fdx,DDT,"P4InitializePdo - found mfg - <%s>\n",mfg);
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    RtlZeroMemory( buffer, bufLen );
                    strcpy( buffer, mfg );
                    pdx->Mfg = buffer;
                }
            }
            if( mdl ) {
                PCHAR buffer;
                ULONG bufLen = strlen(mdl) + sizeof(CHAR);
                DD((PCE)fdx,DDT,"P4InitializePdo - found mdl - <%s>\n",mdl);
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    RtlZeroMemory( buffer, bufLen );
                    strcpy( buffer, mdl );
                    pdx->Mdl = buffer;
                }
            }
            if( cid ) {
                PCHAR buffer;
                ULONG bufLen = strlen(cid) + sizeof(CHAR);
                DD((PCE)fdx,DDT,"P4InitializePdo - found cid - <%s>\n",cid);
                buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, bufLen );
                if( buffer ) {
                    RtlZeroMemory( buffer, bufLen );
                    strcpy( buffer, cid );
                    pdx->Cid = buffer;
                }
            } else {
                DD((PCE)fdx,DDT,"P4InitializePdo - no cid found\n");
            }
            ExFreePool( tmpBuffer );
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool\n");
        }

    } else {
        //
        // PdoType doesn't have a Mfg, Mdl, or Cid, make up Mfg and Mdl, no Cid
        //
        const CHAR rawPortMfg[]   = "Microsoft";
        const CHAR rawPortMdl[]   = "RawPort";
        const CHAR legacyZipMfg[] = "IMG";
        const CHAR legacyZipMdl[] = "VP0";
        PCHAR      mfgStr;
        ULONG      mfgLen;
        PCHAR      mdlStr;
        ULONG      mdlLen;
        PCHAR      buffer;

        if( PdoTypeRawPort == PdoType ) {
            mfgStr = (PCHAR)rawPortMfg;
            mfgLen = sizeof(rawPortMfg);
            mdlStr = (PCHAR)rawPortMdl;
            mdlLen = sizeof(rawPortMdl);
        } else {
            // PdoTypeLegacyZip
            PptAssert( PdoTypeLegacyZip == PdoType );
            mfgStr = (PCHAR)legacyZipMfg;
            mfgLen = sizeof(legacyZipMfg);
            mdlStr = (PCHAR)legacyZipMdl;
            mdlLen = sizeof(legacyZipMdl);
        }
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, mfgLen );
        if( buffer ) {
            RtlZeroMemory( buffer, mfgLen );
            strcpy( buffer, mfgStr );
            pdx->Mfg = buffer;
        }
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, mdlLen );
        if( buffer ) {
            RtlZeroMemory( buffer, mdlLen );
            strcpy( buffer, mdlStr );
            pdx->Mdl = buffer;
        }
        pdx->Cid = NULL;
    }

    // initialize Location information - LPTx or LPTx.y
    PptAssert( fdx->PnpInfo.PortName &&
               ( (0 == wcscmp(fdx->PnpInfo.PortName, L"LPT1") ) ||
                 (0 == wcscmp(fdx->PnpInfo.PortName, L"LPT2") ) ||
                 (0 == wcscmp(fdx->PnpInfo.PortName, L"LPT3") ) ) );

    switch( PdoType ) {
        PCHAR buffer;
        ULONG bufLen;

    case PdoTypeRawPort :
        bufLen = sizeof("LPTx");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S", fdx->PnpInfo.PortName );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    case PdoTypeDaisyChain :
        bufLen = sizeof("LPTx.y");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            PptAssert( DaisyChainId >= 0 && DaisyChainId < 4 );
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S.%1d", fdx->PnpInfo.PortName, DaisyChainId );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    case PdoTypeEndOfChain :
        bufLen = sizeof("LPTx.y");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S.4", fdx->PnpInfo.PortName );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    case PdoTypeLegacyZip :
        bufLen = sizeof("LPTx.y");
        buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%S.5", fdx->PnpInfo.PortName );
            pdx->Location = buffer;
        } else {
            DD((PCE)fdx,DDT,"P4InitializePdo - out of pool");
        }
        break;

    default :
        PptAssert(!"Invalid PdoType");
    }


    // initialize synchronization and list mechanisms
    ExInitializeFastMutex( &pdx->OpenCloseMutex );
    InitializeListHead( &pdx->WorkQueue );
    KeInitializeSemaphore( &pdx->RequestSemaphore, 0, MAXLONG );
    KeInitializeEvent( &pdx->PauseEvent, NotificationEvent, TRUE );


    // general info
    pdx->DeviceObject         = Pdo;
    pdx->DevType              = DevTypePdo;

    pdx->EndOfChain           = (PdoTypeEndOfChain == PdoType) ? TRUE : FALSE; // override later if this is a
    pdx->Ieee1284_3DeviceId   = (PdoTypeDaisyChain == PdoType) ? DaisyChainId : 0; //   1284.3 Daisy Chain device

    pdx->IsPdo                = TRUE;       // really means !FDO
    pdx->Fdo                  = Fdo;
    pdx->ParClassFdo          = Fdo;        // depricated - use Fdo field on prev line
    pdx->PortDeviceObject     = Fdo;        // depricated - use Fdo field 2 lines up - modify functions to use it
    pdx->BusyDelay            = 0;
    pdx->BusyDelayDetermined  = FALSE;
    
    // timing constants
    pdx->TimerStart                  = PAR_WRITE_TIMEOUT_VALUE;
    pdx->AbsoluteOneSecond.QuadPart  = 10*1000*1000;
    pdx->IdleTimeout.QuadPart        = - 250*10*1000;       // 250 ms
    pdx->OneSecond.QuadPart          = - pdx->AbsoluteOneSecond.QuadPart;

    // init IEEE 1284 protocol settings
    ParInitializeExtension1284Info( pdx );

    pdx->DeviceType = PAR_DEVTYPE_PDO; // deprecated - use DevType in common extension

    if( Ieee1284Id ) {
        ULONG length = strlen(Ieee1284Id) + 1;
        PCHAR copyOfIeee1284Id = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, length );
        if( copyOfIeee1284Id ) {
            RtlZeroMemory( copyOfIeee1284Id, length );
            strcpy( copyOfIeee1284Id, Ieee1284Id );
            ParDetectDot3DataLink( pdx, Ieee1284Id );
            ExFreePool( copyOfIeee1284Id );
        }
    }

    // RMT - doug - need to put this back in - ParCheckParameters(DevObj->DeviceExtension);   // Check the registry for parameter overrides

    // Write symbolic link map info to the registry.
    {
        NTSTATUS status = RtlWriteRegistryValue( RTL_REGISTRY_DEVICEMAP,
                                                 (PWSTR)L"PARALLEL PORTS",
                                                 pdx->PdoName,
                                                 REG_SZ,
                                                 pdx->SymLinkName,
                                                 wcslen(pdx->SymLinkName)*sizeof(WCHAR) + sizeof(WCHAR) );
        if( NT_SUCCESS( status ) ) {
            DD((PCE)fdx,DDT,"Created DEVICEMAP registry entry - %S -> %S\n",pdx->PdoName,pdx->SymLinkName);
        } else {
            DD((PCE)fdx,DDT,"Failed to create DEVICEMAP registry entry - status = %x\n", status);
        }
    }

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;      // Tell the IO system that we are ready to receive IRPs
    return STATUS_SUCCESS;
}


PWSTR
P4MakePdoSymLinkName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber
    )
/*

    Generate \DosDevices\LPTx or \DosDevices\LPTx.y PdoSymbolicLinkName from LPTx Name

    In:  LPTx
    Out: \DosDevices\LPTx or \DosDevices\LPTx.y depending on PdoType

    examples: 
    
      LPT1 PdoTypeEndOfChain                  -> \DosDevices\LPT1.4
      LPT2 PdoTypeDaisyChain DaisyChainId==3  -> \DosDevices\LPT2.3
      LPT3 PdoTypeRawPort                     -> \DosDevices\LPT3
    
    returns - pointer to pool allocation containing PdoSymbolicLinkName on success (caller frees), or
            - NULL on error 
    
*/
{
    const UCHAR  maxDaisyChainSuffix = 3;
    const UCHAR  endOfChainSuffix    = 4;
    const UCHAR  legacyZipSuffix     = 5;
    const ULONG  maxSymLinkNameLength = sizeof(L"\\DosDevices\\LPTx.y-z");
    
    UCHAR        suffix = 0;
    PWSTR        buffer;

    if( !LptName ) {
        PptAssert( !"NULL LptName" );
        return NULL;
    }

    DD(NULL,DDT,"P4MakePdoSymLinkName - LptName = %S\n",LptName);

    switch( PdoType ) {
    case PdoTypeDaisyChain :
        if( DaisyChainId > maxDaisyChainSuffix ) {
            PptAssert( !"DaisyChainId > maxDaisyChainSuffix" );
            return NULL;
        }
        suffix = DaisyChainId;
        break;
    case PdoTypeEndOfChain :
        suffix = endOfChainSuffix;
        break;
    case PdoTypeLegacyZip :
        suffix = legacyZipSuffix;
        break;
    case PdoTypeRawPort :
        break; // no suffix
    default :
        PptAssert( !"Unrecognised PdoType" );
        return NULL;
    }

    if( 0 == RetryNumber ) {
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxSymLinkNameLength );
        if( buffer ) {
            RtlZeroMemory( buffer, maxSymLinkNameLength );
            if( PdoTypeRawPort == PdoType ) {
                swprintf( buffer, L"\\DosDevices\\%s\0", LptName );
            } else {
                swprintf( buffer, L"\\DosDevices\\%s.%d\0", LptName, suffix );
            }
        }
    } else if( RetryNumber <= 9 ) {
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxSymLinkNameLength );
        if( buffer ) {
            RtlZeroMemory( buffer, maxSymLinkNameLength );
            if( PdoTypeRawPort == PdoType ) {
                swprintf( buffer, L"\\DosDevices\\%s-%1d\0", LptName, RetryNumber );
            } else {
                swprintf( buffer, L"\\DosDevices\\%s.%d-%1d\0", LptName, suffix, RetryNumber );
            }
        }
    } else {
        buffer = NULL;
    }

    return buffer;
}


PWSTR
P4MakePdoDeviceName(
    IN PWSTR          LptName,
    IN enum _PdoType  PdoType,
    IN UCHAR          DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN UCHAR          RetryNumber   // used if we had a name collision on IoCreateDevice
    )
/*

    Generate \Device\Parallely or \Device\Parallely.z PDO DeviceName from LPTx Name

    In:  LPTx
    Out: \Device\Parallely or \Device\Parallely.z depending on PdoType

    y == (x-1), optional .z suffix is based on type of Pdo
    
    examples: 
    
      LPT1 PdoTypeEndOfChain                  -> \Device\Parallel0.4
      LPT2 PdoTypeDaisyChain DaisyChainId==3  -> \Device\Parallel1.3
      LPT3 PdoTypeRawPort                     -> \Device\Parallel2
    
    returns - pointer to pool allocation containing PdoDeviceName on success (caller frees), or
            - NULL on error 
    
*/
{
    const UCHAR  maxDaisyChainSuffix = 3;
    const UCHAR  endOfChainSuffix    = 4;
    const UCHAR  legacyZipSuffix     = 5;
    ULONG        maxDeviceNameLength;

    UCHAR  lptNumber;
    UCHAR  suffix = 0;
    PWSTR  buffer = NULL;

    DD(NULL,DDT,"P4MakePdoDeviceName - LptName=<%S>, PdoType=%d, DaisyChainId=%d\n",LptName,PdoType,DaisyChainId);  


    if( !LptName ) {
        PptAssert( !"NULL LptName" );
        return NULL;
    }

    switch( PdoType ) {
    case PdoTypeDaisyChain :
        if( DaisyChainId > maxDaisyChainSuffix ) {
            PptAssert( !"DaisyChainId > maxDaisyChainSuffix" );
            return NULL;
        }
        suffix = DaisyChainId;
        break;
    case PdoTypeEndOfChain :
        suffix = endOfChainSuffix;
        break;
    case PdoTypeLegacyZip :
        suffix = legacyZipSuffix;
        break;
    case PdoTypeRawPort :
        break; // no suffix
    default :
        PptAssert( !"Unrecognised PdoType" );
        return NULL;
    }

    if     ( 0 == wcscmp( (PCWSTR)L"LPT1", LptName ) ) { lptNumber = 1; } 
    else if( 0 == wcscmp( (PCWSTR)L"LPT2", LptName ) ) { lptNumber = 2; }
    else if( 0 == wcscmp( (PCWSTR)L"LPT3", LptName ) ) { lptNumber = 3; }
    else {
        PptAssert( !"LptName not of the form LPTx where 1 <= x <= 3" );
        return NULL;
    }

    DD(NULL,DDT,"P4MakePdoDeviceName - suffix=%d\n",suffix);

    if( 0 == RetryNumber ) {
        maxDeviceNameLength = sizeof(L"\\Device\\Parallelx.y");
        buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxDeviceNameLength );
        if( buffer ) {
            RtlZeroMemory( buffer, maxDeviceNameLength );
            if( PdoTypeRawPort == PdoType ) {
                swprintf( buffer, L"\\Device\\Parallel%d\0", lptNumber-1 );
            } else {
                swprintf( buffer, L"\\Device\\Parallel%d.%d\0", lptNumber-1, suffix );
            }
        }
    } else {
        if( RetryNumber <= 9 ) {
            maxDeviceNameLength = sizeof(L"\\Device\\Parallelx.y-z");
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, maxDeviceNameLength );
            if( buffer ) {
                RtlZeroMemory( buffer, maxDeviceNameLength );
                if( PdoTypeRawPort == PdoType ) {
                    swprintf( buffer, L"\\Device\\Parallel%d-%1d\0", lptNumber-1, RetryNumber );
                } else {
                    swprintf( buffer, L"\\Device\\Parallel%d.%d-%1d\0", lptNumber-1, suffix, RetryNumber );
                }
            }
        }
    }

    if( buffer ) {
        DD(NULL,DDT,"P4MakePdoDeviceName <%S>\n",buffer);
    }

    return buffer;
}


PDEVICE_OBJECT
P4CreatePdo(
    IN PDEVICE_OBJECT  Fdo,
    IN enum _PdoType   PdoType,
    IN UCHAR           DaisyChainId, // ignored unless PdoType == PdoTypeDaisyChain
    IN PCHAR           Ieee1284Id    // NULL if device does not report IEEE 1284 Device ID
    )
{
    PFDO_EXTENSION  fdx             = Fdo->DeviceExtension;
    PWSTR           lptName         = fdx->PnpInfo.PortName;
    NTSTATUS        status          = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT  pdo             = NULL;
    PWSTR           wstrDeviceName  = NULL;
    PWSTR           wstrSymLinkName = NULL;
    BOOLEAN         createdSymLink  = FALSE;
    UCHAR           retryNumber     = 0;

    UNICODE_STRING  deviceName;
    UNICODE_STRING  symLinkName;

    DD((PCE)fdx,DDT,"P4CreatePdo - enter - PdoType= %d, DaisyChainId=%d, Ieee1284Id=<%s>\n", PdoType, DaisyChainId, Ieee1284Id);

    __try {

        if( !lptName ) {
            DD((PCE)fdx,DDT,"P4CreatePdo - no lptName\n");
            __leave;
        }

        DD((PCE)fdx,DDT,"P4CreatePdo - lptName = %S\n",lptName);
        
targetRetryDeviceName:

        wstrDeviceName = P4MakePdoDeviceName( lptName, PdoType, DaisyChainId, retryNumber );
        if( !wstrDeviceName ) {
            DD((PCE)fdx,DDT,"P4MakePdoDeviceName FAILED\n");
            __leave;
        }

        DD((PCE)fdx,DDT,"P4CreatePdo - wstrDeviceName = %S\n",wstrDeviceName);
        RtlInitUnicodeString( &deviceName, wstrDeviceName );

        status = IoCreateDevice( fdx->DriverObject, 
                                 sizeof(PDO_EXTENSION),
                                 &deviceName,
                                 FILE_DEVICE_PARALLEL_PORT,
                                 FILE_DEVICE_SECURE_OPEN,
                                 TRUE,
                                 &pdo );
        
        if( STATUS_SUCCESS != status ) {
            DD((PCE)fdx,DDT,"P4CreatePdo - FAILED\n");
            pdo = NULL; // just to make sure that we don't try to use this later
            if( STATUS_OBJECT_NAME_COLLISION == status ) {
                // try again with another name
                DD(NULL,DDE,"P4CreatePdo - STATUS_OBJECT_NAME_COLLISION on %S\n",wstrDeviceName);
                ExFreePool( wstrDeviceName );
                ++retryNumber;
                goto targetRetryDeviceName;
            }
            __leave;
        }

        retryNumber = 0;

targetRetrySymLink:

        wstrSymLinkName = P4MakePdoSymLinkName( lptName, PdoType, DaisyChainId, retryNumber );
        if( !wstrSymLinkName ) {
            DD((PCE)fdx,DDT,"P4MakePdoSymLinkName FAILED\n");
            __leave;
        }
        RtlInitUnicodeString( &symLinkName, wstrSymLinkName );

        status = IoCreateUnprotectedSymbolicLink( &symLinkName , &deviceName );
        if( STATUS_SUCCESS != status ) {
            if( STATUS_OBJECT_NAME_COLLISION == status ) {
                DD(NULL,DDE,"P4CreatePdo - STATUS_OBJECT_NAME_COLLISION on %S\n", wstrSymLinkName);
                ExFreePool( wstrSymLinkName );
                ++retryNumber;
                goto targetRetrySymLink;
            }
            DD((PCE)fdx,DDT,"P4CreatePdo - create SymLink FAILED\n");
            __leave;
        } else {
            createdSymLink = TRUE;
        }

        if( (NULL == Ieee1284Id) && (PdoTypeDaisyChain == PdoType) ) {
            // SCM Micro device?
            PPDO_EXTENSION              pdx = pdo->DeviceExtension;
            PPARALLEL_PORT_INFORMATION  PortInfo = &fdx->PortInfo;
            BOOLEAN                     bBuildStlDeviceId;
            ULONG                       DeviceIdSize;

            pdx->Controller =  PortInfo->Controller;

            bBuildStlDeviceId = ParStlCheckIfStl( pdx, DaisyChainId ) ;

            if( TRUE == bBuildStlDeviceId ) {
                Ieee1284Id = ParStlQueryStlDeviceId( pdx, NULL, 0, &DeviceIdSize, FALSE );
            }

            pdx->OriginalController = PortInfo->OriginalController;

            P4InitializePdo( Fdo, pdo, PdoType, DaisyChainId, Ieee1284Id, wstrDeviceName, wstrSymLinkName );
            
            if (Ieee1284Id) {
                 ExFreePool (Ieee1284Id);
                 Ieee1284Id = NULL;
            }

        } else {
            P4InitializePdo( Fdo, pdo, PdoType, DaisyChainId, Ieee1284Id, wstrDeviceName, wstrSymLinkName );
        }

    } // __try

    __finally {
        if( STATUS_SUCCESS != status ) {
            // failure - do cleanup
            if( createdSymLink ) {
                IoDeleteSymbolicLink( &symLinkName );
            }
            if( pdo ) {
                IoDeleteDevice( pdo );
                pdo = NULL;
            }
            if( wstrDeviceName ) {
                ExFreePool( wstrDeviceName );
            }
            if( wstrSymLinkName ) {
                ExFreePool( wstrSymLinkName );
            }
        }
    } // __finally

    return pdo;
}


VOID
P4SanitizeMultiSzId( 
    IN OUT  PWSTR  WCharBuffer,
    IN      ULONG  BufWCharCount
    )
    // BufWCharCount == number of WCHARs (not bytes) in the string
    //
    // Sanitize the MULTI_SZ (HardwareID or CompatibleID) for PnP:
    //   1) Leave UNICODE_NULLs (L'\0') alone, otherwise
    //   2) Convert illegal characters to underscores (L'_')
    //      illegal characters are ( == L',' ) || ( <= L' ' ) || ( > (WCHAR)0x7F )
{
    PWCHAR p = WCharBuffer;
    ULONG  i;
    for( i = 0; i < BufWCharCount ; ++i, ++p ) {
        if( L'\0'== *p ) {
            continue;
        } else if( (*p <= L' ') || (*p > (WCHAR)0x7F) || (L',' == *p) ) {
            *p = L'_';
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\readwrite.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       readwrit.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with handling Read and Write requests
//

#include "pch.h"


NTSTATUS
ParForwardToReverse(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine flips the bus from Forward to Reverse direction.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Do a quick check to see if we are where we want to be.  
    // Happy punt if everything is ok.
    if( Pdx->Connected &&
        ( Pdx->CurrentPhase == PHASE_REVERSE_IDLE || Pdx->CurrentPhase == PHASE_REVERSE_XFER) ) {

        DD((PCE)Pdx,DDT,"ParForwardToReverse - already in reverse mode\n");
        return Status;
    }

    if (Pdx->Connected) {
    
        if (Pdx->CurrentPhase != PHASE_REVERSE_IDLE &&
            Pdx->CurrentPhase != PHASE_REVERSE_XFER) {
        
            if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily ==
                arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily) {

                // Protocol Families match and we are in Fwd.  Exit Fwd to cleanup the state
                // machine, fifo, etc.  We will call EnterReverse later to
                // actually bus flip.  Also only do this if in safe mode
                if ( (afpForward[Pdx->IdxForwardProtocol].fnExitForward) ) {
                    Status = afpForward[Pdx->IdxForwardProtocol].fnExitForward(Pdx);
                }
                    
            } else {

                //
                // Protocol Families don't match...need to terminate from the forward mode
                //
                if (afpForward[Pdx->IdxForwardProtocol].fnDisconnect) {
                    afpForward[Pdx->IdxForwardProtocol].fnDisconnect (Pdx);
                }
                if ((Pdx->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
                    (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress))
                    Pdx->SetForwardAddress = TRUE;
            }
            
        }                
    }

    if( (!Pdx->Connected) && (arpReverse[Pdx->IdxReverseProtocol].fnConnect) ) {

        //
        // If we are still connected the protocol families match...
        //
        Status = arpReverse[Pdx->IdxReverseProtocol].fnConnect(Pdx, FALSE);

        //
        // Makes the assumption that the connected address is always 0
        //
        if ((NT_SUCCESS(Status)) &&
            (arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress) &&
            (Pdx->ReverseInterfaceAddress != DEFAULT_ECP_CHANNEL)) {
            
            Pdx->SetReverseAddress = TRUE;
        }    
    }

    //
    // Set the channel address if we need to.
    //
    if (NT_SUCCESS(Status) && Pdx->SetReverseAddress &&    
        (arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress)) {

        Status  = arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress (
                                                                    Pdx,
                                                                    Pdx->ReverseInterfaceAddress);
        if (NT_SUCCESS(Status))
            Pdx->SetReverseAddress = FALSE;
        else
            Pdx->SetReverseAddress = TRUE;
    }

    //
    // Do we need to reverse?
    //
    if ( (NT_SUCCESS(Status)) && 
           ((Pdx->CurrentPhase != PHASE_REVERSE_IDLE) &&
            (Pdx->CurrentPhase != PHASE_REVERSE_XFER)) ) {
            
        if ((arpReverse[Pdx->IdxReverseProtocol].fnEnterReverse))
            Status = arpReverse[Pdx->IdxReverseProtocol].fnEnterReverse(Pdx);
    }

    DD((PCE)Pdx,DDT,"ParForwardToReverse - exit w/status=%x\n",Status);

    return Status;
}

BOOLEAN 
ParHaveReadData(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:
    This method determines if the dot4 peripheral has any data ready
    to send to the host.

Arguments:
    Pdx    - Supplies the device EXTENSION.   

Return Value:
    TRUE    - Either the peripheral has data
    FALSE   - No data
--*/
{
    NTSTATUS  status;
    BOOLEAN   justAcquiredPort = FALSE;

    if( Pdx->CurrentPhase != PHASE_TERMINATE    &&
        Pdx->CurrentPhase != PHASE_REVERSE_IDLE &&
        Pdx->CurrentPhase != PHASE_REVERSE_XFER &&
        Pdx->CurrentPhase != PHASE_FORWARD_IDLE &&
        Pdx->CurrentPhase != PHASE_FORWARD_XFER ) {

        // unexpected phase - no idea what to do here - pretend that
        // there is no data avail and return

        DD((PCE)Pdx,DDE,"ParHaveReadData - unexpected CurrentPhase %x\n",Pdx->CurrentPhase);
        PptAssertMsg("ParHaveReadData - unexpected CurrentPhase",FALSE);
        return FALSE;
    }
    
    if( PHASE_TERMINATE == Pdx->CurrentPhase ) {

        //
        // we're not currently talking with the peripheral and we
        // likely don't have access to the port - try to acquire the
        // port and establish communication with the peripheral so
        // that we can check if the peripheral has data for us
        //

        // CurrentPhase indicates !Connected - do a check for consistency
        PptAssert( !Pdx->Connected );
        
        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE\n");

        if( !Pdx->bAllocated ) {

            // we don't have the port - try to acquire port

            DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - don't have port\n");

            status = PptAcquirePortViaIoctl( Pdx->Fdo, NULL );

            if( STATUS_SUCCESS == status ) {

                // we now have the port

                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - port acquired\n");

                // note that we have just now acquired the port so
                // that we can release the port below if we are unable
                // to establish communication with the peripheral
                justAcquiredPort = TRUE;

                Pdx->bAllocated  = TRUE;

            } else {

                // we couldn't get the port - bail out

                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - don't have port - acquire failed\n");
                return FALSE;

            }

        } // endif !Pdx->bAllocated


        //
        // we now have the port - try to negotiate into a forward
        // mode since we believe that the check for periph data
        // avail is more robust in forward modes
        //

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_TERMINATE - we have the port - try to Connect\n");

        DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - try to Connect - calling ParReverseToForward\n");

        //
        // ParReverseToForward:
        //
        // 1) tries to negotiate the peripheral into the forward mode
        // specified by a combination of the device specific
        // Pdx->IdxForwardProtocol and the driver global afpForward
        // array.
        //
        // 2) sets up our internal state machine, Pdx->CurrentPhase
        //
        // 3) as a side effect - sets Pdx->SetForwardAddress if we
        // need to use a non-Zero ECP (or EPP) address.
        //
        status = ParReverseToForward( Pdx );

        if( STATUS_SUCCESS == status ) {

            //
            // We are in communication with the peripheral
            //

            DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - ParReverseToForward SUCCESS\n");

            // Set the channel address if we need to - use the side effect from ParReverseToForward here
            if( Pdx->SetForwardAddress ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - try to set Forward Address\n");
                if( afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress ) {
                    status = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress ( Pdx, Pdx->ForwardInterfaceAddress );
                    if( STATUS_SUCCESS == status ) {

                        // success - set flag to indicate that we don't need to set the address again
                        DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - set Forward Address - SUCCESS\n");
                        Pdx->SetForwardAddress = FALSE;

                    } else {

                        // couldn't set address - clean up and bail out - report no peripheral data avail
                        DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - set Forward Address - FAIL\n");
                        Pdx->SetForwardAddress = TRUE;

                        // Return peripheral to quiescent state
                        // (Compatibility Mode Forward Idle) and set
                        // our state machine accordingly
                        ParTerminate( Pdx );

                        // if we just acquired the port in this function then give
                        // up the port, otherwise keep it for now
                        if( justAcquiredPort ) {
                            DD((PCE)Pdx,DDE,"ParHaveReadData - set address failed - giving up port\n");
                            ParFreePort( Pdx );
                        }
                        return FALSE;

                    }
                }

            } else {
                DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - connected - no need to set Forward Address\n");
            }

        } else {

            // unable to establish communication with peripheral

            DD((PCE)Pdx,DDE,"ParHaveReadData - we have the port - try to Connect - ParReverseToForward FAILED\n");

            // if we just acquired the port in this function then give
            // up the port, otherwise keep it for now
            if( justAcquiredPort ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - connect failed - giving up port\n");
                ParFreePort( Pdx );
            }
            return FALSE;
        }

        // we're communicating with the peripheral - fall through to below to check for data avail

    } // endif PHASE_TERMINATE == CurrentPhase
    

    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE ||
        Pdx->CurrentPhase == PHASE_REVERSE_XFER ) {

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_REVERSE_*\n");

        if( arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData ) {

            if( arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData( Pdx ) ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_REVERSE_* - we have data\n");
                return TRUE;
            }

        }

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_REVERSE_* - no data - flip bus to forward\n");

        // Don't have data.  This could be a fluke. Let's flip the bus
        // and try again in Fwd mode since some peripherals reportedly
        // have broken firmware that does not properly signal that
        // they have data avail when in some reverse modes.
        ParReverseToForward( Pdx );

    }

    if( Pdx->CurrentPhase == PHASE_FORWARD_IDLE || 
        Pdx->CurrentPhase == PHASE_FORWARD_XFER ) {

        DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_*\n");

        if( afpForward[Pdx->IdxForwardProtocol].ProtocolFamily == FAMILY_BECP ||
            afpForward[Pdx->IdxForwardProtocol].Protocol & ECP_HW_NOIRQ       ||
            afpForward[Pdx->IdxForwardProtocol].Protocol & ECP_HW_IRQ) {

            if( PptEcpHwHaveReadData( Pdx ) ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_* - ECP HW - have data\n");
                return TRUE;
            }

            // Hmmm.  No data. Is the chip stuck?
            DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_* - ECP HW - no data\n");
            return FALSE;

        } else {

            if( afpForward[Pdx->IdxForwardProtocol].Protocol & ECP_SW ) {
                DD((PCE)Pdx,DDE,"ParHaveReadData - PHASE_FORWARD_* - ECP SW - checking for data\n");
                return ParEcpHaveReadData( Pdx );
            }

        }
    }

    // DVRH  RMT
    // We got here because the protocol doesn't support peeking.
    //  - pretend there is data avail
    DD((PCE)Pdx,DDE,"ParHaveReadData - exit - returning TRUE\n");
    return TRUE;
}

NTSTATUS 
ParPing(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:
    This method was intended to ping the device, but it is currently a NOOP.

Arguments:
    Pdx    - Supplies the device EXTENSION.   

Return Value:
    none
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( Pdx );

    return NtStatus;
}

NTSTATUS
PptPdoReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This is the dispatch routine for READ and WRITE requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_PENDING              - Request pending - a worker thread will carry
                                    out the request at PASSIVE_LEVEL IRQL

    STATUS_SUCCESS              - Success - asked for a read or write of
                                    length zero.

    STATUS_INVALID_PARAMETER    - Invalid parameter.

    STATUS_DELETE_PENDING       - This device object is being deleted.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PPDO_EXTENSION   Pdx;

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Pdx = DeviceObject->DeviceExtension;

    //
    // bail out if a delete is pending for this device object
    //
    if(Pdx->DeviceStateFlags & PPT_DEVICE_DELETE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }
    
    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Pdx->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        return P4CompleteRequest( Irp, STATUS_DELETE_PENDING, Irp->IoStatus.Information );
    }

    //
    // bail out if device has been removed
    //
    if(Pdx->DeviceStateFlags & (PPT_DEVICE_REMOVED|PPT_DEVICE_SURPRISE_REMOVED) ) {
        return P4CompleteRequest( Irp, STATUS_DEVICE_REMOVED, Irp->IoStatus.Information );
    }


    //
    // Note that checks of the Write IRP parameters also handles Read IRPs
    //   because the Write and Read structures are identical in the
    //   IO_STACK_LOCATION.Parameters union
    //


    //
    // bail out on nonzero offset
    //
    if( (IrpSp->Parameters.Write.ByteOffset.HighPart != 0) || (IrpSp->Parameters.Write.ByteOffset.LowPart  != 0) ) {
        return P4CompleteRequest( Irp, STATUS_INVALID_PARAMETER, Irp->IoStatus.Information );
    }


    //
    // immediately succeed read or write request of length zero
    //
    if (IrpSp->Parameters.Write.Length == 0) {
        return P4CompleteRequest( Irp, STATUS_SUCCESS, Irp->IoStatus.Information );
    }


    //
    // Request appears to be valid, queue it for our worker thread to handle at
    // PASSIVE_LEVEL IRQL and wake up the thread to do the work
    //
    {
        KIRQL               OldIrql;

        // make sure IRP isn't cancelled out from under us
        IoAcquireCancelSpinLock(&OldIrql);
        if (Irp->Cancel) {
            
            // IRP has been cancelled, bail out
            IoReleaseCancelSpinLock(OldIrql);
            return STATUS_CANCELLED;
            
        } else {
            BOOLEAN needToSignalSemaphore = IsListEmpty( &Pdx->WorkQueue ) ? TRUE : FALSE;
#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(Irp, ParCancelRequest);
#pragma warning( pop ) 
            IoMarkIrpPending(Irp);
            InsertTailList(&Pdx->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Pdx->RequestSemaphore, 0, 1, FALSE);
            }
            return STATUS_PENDING;
        }
    }
}

NTSTATUS
ParRead(
    IN PPDO_EXTENSION    Pdx,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR   lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type
    ULONG    Bytes = 0;

    *NumBytesRead = Bytes;

    // only do this if we are in safe mode
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        if (arpReverse[Pdx->IdxReverseProtocol].fnReadShadow) {
            Queue     *pQueue;
   
            pQueue = &(Pdx->ShadowBuffer);

            arpReverse[Pdx->IdxReverseProtocol].fnReadShadow( pQueue, lpsBufPtr, NumBytesToRead, &Bytes );
            NumBytesToRead -= Bytes;
            *NumBytesRead += Bytes;
            lpsBufPtr += Bytes;
            if ( 0 == NumBytesToRead ) {

                Status = STATUS_SUCCESS;
                if ((!Queue_IsEmpty(pQueue)) &&
                    (TRUE == Pdx->P12843DL.bEventActive) ) {
                    KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
                }
    	        goto ParRead_ExitLabel;
            }
        }

        if (arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData) {
            if (!arpReverse[Pdx->IdxReverseProtocol].fnHaveReadData(Pdx)) {
                DD((PCE)Pdx,DDT,"ParRead - periph doesn't have data - give cycles to someone else\n");
                Status = STATUS_SUCCESS;
                goto ParRead_ExitLabel;
            }
        }
        
    }

    // Go ahead and flip the bus if need be.  The proc will just make sure we're properly
    // connected and pointing in the right direction.
    Status = ParForwardToReverse( Pdx );


    //
    // The read mode will vary depending upon the currently negotiated mode.
    // Default: Nibble
    //

    if (NT_SUCCESS(Status)) {
        
        if (Pdx->fnRead || arpReverse[Pdx->IdxReverseProtocol].fnRead) {
            //
            // Do the read...
            //
            if(Pdx->fnRead) {
                Status = ((PPROTOCOL_READ_ROUTINE)Pdx->fnRead)( Pdx, (PVOID)lpsBufPtr, NumBytesToRead, &Bytes );
            } else {
                Status = arpReverse[Pdx->IdxReverseProtocol].fnRead( Pdx, (PVOID)lpsBufPtr, NumBytesToRead, &Bytes );
            }
            *NumBytesRead += Bytes;
            NumBytesToRead -= Bytes;
            
#if DVRH_SHOW_BYTE_LOG
            {
                ULONG i=0;
                DD((PCE)Pdx,DDT,"Parallel:Read: ");
                for (i=0; i<*NumBytesRead; ++i) {
                    DD((PCE)Pdx,DDT," %02x",((PUCHAR)lpsBufPtr)[i]);
                }
                DD((PCE)Pdx,DDT,"\n");
            }
#endif
            
        } else {
            // If you are here, you've got a bug somewhere else
            DD((PCE)Pdx,DDE,"ParRead - you're hosed man - no fnRead\n");
            PptAssertMsg("ParRead - don't have a fnRead! Can't Read!\n",FALSE);
        }
        
    } else {
        DD((PCE)Pdx,DDE,"ParRead - Bus Flip Forward->Reverse FAILED - can't read\n");
    }

ParRead_ExitLabel:

    return Status;
}


VOID
ParReadIrp(
    IN  PPDO_EXTENSION  Pdx
    )
/*++

Routine Description:

    This routine implements a READ request with the extension's current irp.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    PIRP                Irp = Pdx->CurrentOpIrp;
    PIO_STACK_LOCATION  IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG               bytesRead;
    NTSTATUS            status;

    status = ParRead( Pdx, Irp->AssociatedIrp.SystemBuffer, IrpSp->Parameters.Read.Length, &bytesRead );

    Irp->IoStatus.Status      = status;
    Irp->IoStatus.Information = bytesRead;

    DD((PCE)Pdx,DDT,"ParReadIrp - status = %x, bytesRead=%d\n", status, bytesRead);

    return;
}

NTSTATUS
ParReverseToForward(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine flips the bus from Reverse to Forward direction.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // dvdr

    if (Pdx->Connected) {
        // Do a quick check to see if we are where we want to be.  
        // Happy punt if everything is ok.
        if( Pdx->CurrentPhase == PHASE_FORWARD_IDLE || Pdx->CurrentPhase == PHASE_FORWARD_XFER ) {

            DD((PCE)Pdx,DDT,"ParReverseToForward: Already in Fwd. Exit STATUS_SUCCESS\n");
            return Status;

        } else {

            if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily !=
                arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily) {            

                //
                // Protocol Families don't match...need to terminate from the forward mode
                //
                if (arpReverse[Pdx->IdxReverseProtocol].fnDisconnect) {
                    arpReverse[Pdx->IdxReverseProtocol].fnDisconnect (Pdx);
                }

                if ((Pdx->ReverseInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
                    (arpReverse[Pdx->IdxReverseProtocol].fnSetInterfaceAddress)) {
                    Pdx->SetReverseAddress = TRUE;
                }

            } else if((Pdx->CurrentPhase == PHASE_REVERSE_IDLE) || (Pdx->CurrentPhase == PHASE_REVERSE_XFER)) {

                if ( (arpReverse[Pdx->IdxReverseProtocol].fnExitReverse) ) {
                    Status = arpReverse[Pdx->IdxReverseProtocol].fnExitReverse(Pdx);
                }

            } else {

                // We are in a screwy state.
                DD((PCE)Pdx,DDE,"ParReverseToForward: We're lost! Unknown state - Gonna start spewing!\n");
                Status = STATUS_IO_TIMEOUT;     // I picked a RetVal from thin air!
            }
        }
    }

    // Yes, we still want to check for connection since we might have
    //   terminated in the previous code block!
    if (!Pdx->Connected && afpForward[Pdx->IdxForwardProtocol].fnConnect) {

        Status = afpForward[Pdx->IdxForwardProtocol].fnConnect( Pdx, FALSE );
        //
        // Makes the assumption that the connected address is always 0
        //
        if ((NT_SUCCESS(Status)) && (Pdx->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL)) {
            Pdx->SetForwardAddress = TRUE;
        }    
    }

    //
    // Do we need to enter a forward mode?
    //
    if ( (NT_SUCCESS(Status)) && 
         (Pdx->CurrentPhase != PHASE_FORWARD_IDLE) &&
         (Pdx->CurrentPhase != PHASE_FORWARD_XFER) &&
         (afpForward[Pdx->IdxForwardProtocol].fnEnterForward) ) {
        
        Status = afpForward[Pdx->IdxForwardProtocol].fnEnterForward(Pdx);
    }

    DD((PCE)Pdx,DDT,"ParReverseToForward - exit w/status= %x\n", Status);

    return Status;
}

NTSTATUS
ParSetFwdAddress(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;

    DD((PCE)Pdx,DDT,"ParSetFwdAddress: Start: Channel [%x]\n", Pdx->ForwardInterfaceAddress);
    if (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress) {
        Status = ParReverseToForward(Pdx);
        if (!NT_SUCCESS(Status)) {
            DD((PCE)Pdx,DDE,"ParSetFwdAddress: FAIL. Couldn't flip the bus for Set ECP/EPP Channel failed.\n");
            goto ParSetFwdAddress_ExitLabel;
        }
        Status  = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress (
                                                                    Pdx,
                                                                    Pdx->ForwardInterfaceAddress);
        if (NT_SUCCESS(Status)) {
            Pdx->SetForwardAddress = FALSE;
        } else {
            DD((PCE)Pdx,DDE,"ParSetFwdAddress: FAIL. Set ECP/EPP Channel failed.\n");
            goto ParSetFwdAddress_ExitLabel;
        }
    } else {
        DD((PCE)Pdx,DDE,"ParSetFwdAddress: FAIL. Protocol doesn't support SetECP/EPP Channel\n");
        Status = STATUS_UNSUCCESSFUL;
        goto ParSetFwdAddress_ExitLabel;
    }

ParSetFwdAddress_ExitLabel:
    return Status;
}

VOID
ParTerminate(
    IN  PPDO_EXTENSION   Pdx
    )
{
    if (!Pdx->Connected) {
        return;
    }

    if (Pdx->CurrentPhase == PHASE_REVERSE_IDLE || Pdx->CurrentPhase == PHASE_REVERSE_XFER) {

        if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily !=
            arpReverse[Pdx->IdxReverseProtocol].ProtocolFamily) {

            if (arpReverse[Pdx->IdxReverseProtocol].fnDisconnect) {
                DD((PCE)Pdx,DDT,"ParTerminate: Calling arpReverse.fnDisconnect\r\n");
                arpReverse[Pdx->IdxReverseProtocol].fnDisconnect (Pdx);
            }

            return;
        }
        ParReverseToForward(Pdx);
    }

    if (afpForward[Pdx->IdxForwardProtocol].fnDisconnect) {
        DD((PCE)Pdx,DDT,"ParTerminate: Calling afpForward.fnDisconnect\r\n");
        afpForward[Pdx->IdxForwardProtocol].fnDisconnect (Pdx);
    }
}

NTSTATUS
ParWrite(
    IN PPDO_EXTENSION    Pdx,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    // The routine which performs the write varies depending upon the currently
    // negotiated mode.  Start I/O moves the IRP into the Pdx (CurrentOpIrp)
    //
    // Default mode: Centronics
    //

    // Go ahead and flip the bus if need be.  The proc will just make sure we're properly
    // connected and pointing in the right direction.
    Status = ParReverseToForward( Pdx );

    // only do this if we are in safe mode
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        //
        // Set the channel address if we need to.
        //
        if (NT_SUCCESS(Status) && Pdx->SetForwardAddress &&    
            (afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress))
        {
            Status  = afpForward[Pdx->IdxForwardProtocol].fnSetInterfaceAddress (
                                                                    Pdx,
                                                                    Pdx->ForwardInterfaceAddress);
            if (NT_SUCCESS(Status))
                Pdx->SetForwardAddress = FALSE;
            else
                Pdx->SetForwardAddress = TRUE;
        }
    }

    if (NT_SUCCESS(Status)) {

        if (Pdx->fnWrite || afpForward[Pdx->IdxForwardProtocol].fnWrite) {
            *NumBytesWritten = 0;

            #if DVRH_SHOW_BYTE_LOG
            {
                ULONG i=0;
                DD((PCE)Pdx,DDT,"Parallel:Write: ");
                for (i=0; i<NumBytesToWrite; ++i) { 
                    DD((PCE)Pdx,DDT," %02x",*((PUCHAR)Buffer+i));
                }
                DD((PCE)Pdx,DDT,"\n");
            }
            #endif
            
            if( Pdx->fnWrite) {
                Status = ((PPROTOCOL_WRITE_ROUTINE)Pdx->fnWrite)(Pdx,
                                                                       Buffer,
                                                                       NumBytesToWrite,
                                                                       NumBytesWritten);
            } else {
                Status = afpForward[Pdx->IdxForwardProtocol].fnWrite(Pdx,
                                                                           Buffer,
                                                                           NumBytesToWrite,
                                                                           NumBytesWritten);
            }
        }
    }
    return Status;
}


VOID
ParWriteIrp(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine implements a WRITE request with the extension's current irp.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    ULONG               NumBytesWritten = 0;

    Irp    = Pdx->CurrentOpIrp;
    IrpSp  = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = ParWrite(Pdx,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.Write.Length,
                                    &NumBytesWritten);

    Irp->IoStatus.Information = NumBytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\shuttle.h ===
#ifndef     _PARSTL_H_
#define     _PARSTL_H_

// Define 1284 Commands
#define CPP_QUERY_PRODID    0x10

// 1284 related SHTL prod id equates
#define SHTL_EPAT_PRODID    0xAAFF
#define SHTL_EPST_PRODID    0xA8FF

// typedefs for device type
typedef unsigned char   DEVICE_STATE ;
typedef unsigned int    STL_DEVICE_TYPE ;
typedef unsigned int    IMPACT_DEVICE_TYPE ;

// device type equates
#define DEVICE_TYPE_AUTO_DETECT     -1
#define TRUE    1
#define FALSE   0

#define DEVICE_TYPE_NONE            0x0000
#define DEVICE_TYPE_ATA             0x0001
#define DEVICE_TYPE_ATAPI           0x0002
#define DEVICE_TYPE_SCSI            0x0003
#define DEVICE_TYPE_SSFDC           0x0004
#define DEVICE_TYPE_MMC             0x0005
#define DEVICE_TYPE_FLASH           0x0006
#define DEVICE_TYPE_EPP_DEVICE      0x0007
#define DEVICE_TYPE_SOUND           0x0008
#define DEVICE_TYPE_HIFD            0x0009
#define DEVICE_TYPE_LS120           0x000A
#define DEVICE_TYPE_PCMCIA_CF       0x000B
#define DEVICE_TYPE_FLP_TAPE_DSK    0x000C
#define DEVICE_TYPE_ATA_ATAPI_8BIT  0x000D
#define DEVICE_TYPE_UMAX            0x000E
#define DEVICE_TYPE_AVISION         0x000F
#define DEVICE_TYPE_DAZZLE          0x0010
#define DEVICE_TYPE_EXT_HWDETECT    0x40000000 // to OR with expected pers.

#define DEVICE_TYPE_ATA_BIT             1 << ( DEVICE_TYPE_ATA - 1 )
#define DEVICE_TYPE_ATAPI_BIT           1 << ( DEVICE_TYPE_ATAPI - 1 )
#define DEVICE_TYPE_SCSI_BIT            1 << ( DEVICE_TYPE_SCSI - 1 )
#define DEVICE_TYPE_SSFDC_BIT           1 << ( DEVICE_TYPE_SSFDC - 1 )
#define DEVICE_TYPE_MMC_BIT             1 << ( DEVICE_TYPE_MMC - 1 )
#define DEVICE_TYPE_FLASH_BIT           1 << ( DEVICE_TYPE_FLASH - 1 )
#define DEVICE_TYPE_EPP_DEVICE_BIT      1 << ( DEVICE_TYPE_EPP_DEVICE - 1 )
#define DEVICE_TYPE_SOUND_BIT           1 << ( DEVICE_TYPE_SOUND - 1 )
#define DEVICE_TYPE_HIFD_BIT            1 << ( DEVICE_TYPE_HIFD - 1 )
#define DEVICE_TYPE_LS120_BIT           1 << ( DEVICE_TYPE_LS120 - 1 )
#define DEVICE_TYPE_PCMCIA_CF_BIT       1 << ( DEVICE_TYPE_PCMCIA_CF - 1 )
#define DEVICE_TYPE_FLP_TAPE_DSK_BIT    1 << ( DEVICE_TYPE_FLP_TAPE_DSK - 1 )
#define DEVICE_TYPE_ATA_ATAPI_8BIT_BIT  1 << ( DEVICE_TYPE_ATA_ATAPI_8BIT - 1 )
#define DEVICE_TYPE_UMAX_BIT            1 << ( DEVICE_TYPE_UMAX - 1 )
#define DEVICE_TYPE_AVISION_BIT         1 << ( DEVICE_TYPE_AVISION - 1 )
#define DEVICE_TYPE_DAZZLE_BIT          1 << ( DEVICE_TYPE_DAZZLE - 1 )

// possible Device states
#define DEVICE_STATE_INVALID    0
#define DEVICE_STATE_VALID      1
#define DEVICE_STATE_ATAPI      2

// epp dev equates
#define EPPDEV_SIGN        0x03
#define PERSONALITY_MASK    0x03

// flash related equates
#define FLASH_SIGN              0x01
#define FLASH_PERSONALITY_MASK  0x03

// dazzle related equates
#define DAZ_SELECT_BLK          0x18
#define DAZ_BLK0                0x00
#define DAZ_REG1                0x19
#define DAZ_CONFIGURED          0x5A
#define DAZ_NOT_CONFIGURED      0xBC

// umax related equates
#define    BUSY         0x20
#define    PE           0x08

#define    DATAPORT             0x18
#define    STATUSPORT           0x19
#define    CONTROLPORT          0x1A
#define    EPPADDRPORT          0x1B
#define    EPPDATA0PORT         0x1C
#define    EPPDATA1PORT         0x1D
#define    EPPDATA2PORT         0x1E
#define    EPPDATA3PORT         0x1F

// HIFD related equates
#define HIFD_CONTROLLER_READY_STATUS    0x80
#define HIFD_DIGITAL_OUTPUT_REGISTER    0x02
#define HIFD_DOR_RESET_BIT              0x04
#define HIFD_ENABLE_DMA_BIT             0x08
#define HIFD_MAIN_STATUS_REGISTER       0x04
#define HIFD_DATA_RATE_SELECT_REGISTER  0x04
#define HIFD_STATUS_REGISTER_A          0x00
#define HIFD_STATUS_REGISTER_B          0x01

#define HIFD_COMMAND_TO_CONTROLLER      0x55
#define HIFD_TERMINATE_SEQUENCE         0xAA
#define HIFD_CTL_REG_0D                 0x0D
#define HIFD_CTL_REG_03                 0x03
#define HIFD_WAIT_10_MILLISEC           10000   // 10 * 1000 
#define HIFD_WAIT_1_MILLISEC            1000   // 1 * 1000 

#define SMC_ENABLE_MODE2        0x72
#define SMC_DEVICE_ID           0x78

// LS120 related equates
#define LS120_ENGINE_VERSION            0xE2
#define LS120_ENGINE_VERSION_REGISTER   0x07

// MMC engine specific equates
#define MMC_ENGINE_INDEX    0x1E
#define MMC_ENGINE_DATA     0x1F
#define MMC_FREQ_SELECT_REG 0x00
#define MMC_BLOCK_SIZE_REG  0x06

// Though these are test patterns, they may be possible commands
// for ATA/ATAPI devices, as they are written to a possible
// ATA/ATAPI command register. These values have been fixed
// carefully, to minimize, if not eliminate, possible failure.
#define MMC_TEST_PATTERN_1  0x00    // ATA Nop commands for ATA/ATAPI type devices.
#define MMC_TEST_PATTERN_2  0xA1    // ATAPI Ident. command for ATAPI type devices.
#define MMC_TEST_PATTERN_3  0x00    // ATA Nop commands for ATA/ATAPI type devices.

// some IO register equates that are inevitable
#define CYLLOW_REG          0x0004
#define CYLHIGH_REG         0x0005

// ATAPI signature equates
#define ATAPI_SIGN_LOW      0x14
#define ATAPI_SIGN_HI       0xEB

// delay equates
#define MAX_RETRIES_FOR_5_SECS      5 * 1000    //   5 secs
#define MAX_RETRIES_FOR_10_SECS     10 * 1000   //   10 secs
#define DELAY_10MICROSECONDS        10          //  10 mu sec.
#define DELAY_1MILLISECONDS         1000        //  1 milli sec.
#define DELAY_1SECOND               1000*1000   //  1 sec.

// ATA/ATAPI command opcodes
#define ATA_NOP_COMMAND            0x00
#define ATAPI_IDENTIFY             0xA1

// ATA/ATAPI drive select values 
#define ATAPI_MASTER        0xA0
#define ATAPI_SLAVE         0xB0
#define ATAPI_MAX_DRIVES    2

//  ATA register definitions
#define ATA_DATA_REG            0x0000
#define ATA_ERROR_REG           0x0001
#define ATA_PRECOMP_REG         0x0001
#define ATA_SECCNT_REG          0x0002
#define ATA_SECNUM_REG          0x0003
#define ATA_CYLLOW_REG          0x0004
#define ATA_CYLHIGH_REG         0x0005
#define ATA_DRVHD_REG           0x0006
#define ATA_TASK_STAT_REG       0x0007
#define ATA_TASK_CMD_REG        0x0007
#define ATA_ALT_STAT_REG        0x0008

// ATA status register equates
#define ATA_ST_ERROR        0x01
#define ATA_ST_INDEX        0x02
#define ATA_ST_CORRCTD      0x04
#define ATA_ST_DRQ          0x08
#define ATA_ST_SEEK_COMPL   0x10
#define ATA_ST_WRT_FLT      0x20
#define ATA_ST_READY        0x40
#define ATA_ST_BUSY         0x80

// ATA error register equates
#define ATA_ERROR_ABORTED_COMMAND   0x04

// miscellaneous equates
#define BUS_LINES_IN_HIGH_IMPEDANCE         0xFF
#define SKIP_MEMORY_ADDRESS                 ((unsigned long)(-1L))
#define SHTL_NO_ERROR                       0x0000

#define IsShtlError(x) (x & 0x8000)
#define IsImpactPresent() ( IMPACT_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsImpactSPresent() ( IMPACTS_VERSION <= ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEp1284Present() ( EP1284_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpatPlusPresent() ( EPATP_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpezPresent() ( EPEZ_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpatPresent() ( EPAT_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpstPresent() ( EPST_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define NeedToEnableIoPads() ( EP1284_VERSION <= ParStlReadReg ( Extension, VERSION_REGISTER ) )

// Identify command processing related defines..
#define ATAPI_IDENTIFY_LENGTH               512
#define ATAPI_NAME_LENGTH                   10
#define ATAPI_NAME_OFFSET                   84

// EP1284 related equates
#define EP1284_BLK_ADDR_REGISTER    0x0A
#define EP1284_MODE_REGISTER        0x0C
#define VERSION_REGISTER            0x0B
#define EP1284_TRANSFER_CONTROL_REG 0x12
#define EP1284_PERSONALITY_REG      0x01
#define EPAT_MODE_REGISTER          0x0C
#define SOCKET_CONTROL_REGISTER     0x0C
#define ISA_CONTROL_REGISTER        0x0D
#define CONFIG_INDEX_REGISTER       0x0E
#define CONFIG_DATA_REGISTER        0x0F
#define SHTL_CARD_INSERTED_STATUS   0x02
#define XFER_IRQ_BIT                0x20
#define EP1284_POWER_CONTROL_REG    0x0F
#define ENABLE_IOPADS               0x04

// IMPACT related equates
#define IMPACT_PERSONALITY_REG  0x01

// IMPACT-S related equates
#define IMPACTS_EXT_PERSONALITY_PRESENT 0x0A // 0xA0 >> 4
#define IMPACTS_EXT_PERSONALITY_XREG    0x29

// shuttle version number related equates
#define EPST_VERSION            0xB2
#define EPAT_VERSION            0xC3
#define EPEZ_VERSION            0xC5
#define EPATP_VERSION           0xC6
#define EP1284_VERSION          0xC7
#define IMPACT_VERSION          0xC8
#define IMPACTS_VERSION         0xC9
#define EP1284_ENABLE_16BIT     0x10
#define EPAT_RESET_POLARITY     0x20
#define ISA_IO_SWAP             0x20
#define SOCKET_0                0x00
#define SOCKET_1                0x01
#define PERIPHERAL_RESET_1      0x20
#define PERIPHERAL_RESET_0      0x10

// block xfer related op-codes
#define OP_NIBBLE_BLOCK_READ    0x07

// test pattern equates
#define TEST_PATTERN_1  0x55
#define TEST_PATTERN_2  0xAA

// Memory detection related equates
#define SELECT_DRAM 0x80
#define SELECT_SRAM 0x7F
#define RESET_PTR   0x01
#define ENABLE_MEM  0x04
#define EP1284_CONTROL_REG      0x13
#define EP1284_BUFFER_DATA_REG  0x10

// IMPACT device type defines
#define IMPACT_DEVICE_TYPE_NONE                 0
#define IMPACT_DEVICE_TYPE_ATA_ATAPI            1
#define IMPACT_DEVICE_TYPE_PCMCIA_CF            2
#define IMPACT_DEVICE_TYPE_SSFDC                3
#define IMPACT_DEVICE_TYPE_MMC                  4
#define IMPACT_DEVICE_TYPE_HIFD                 5
#define IMPACT_DEVICE_TYPE_SOUND                6
#define IMPACT_DEVICE_TYPE_FLP_TAPE_DSK         7
#define IMPACT_DEVICE_TYPE_CF                   8
#define IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT       9

// parallel port signal equates
#define SLCT_IN_DISABLE     0x04
#define SLCT_IN_ENABLE      0x0C
#define STB_INIT_LOW        0x01
#define STB_INIT_AFXT_LO    0x03
#define INIT_AFXT_HIGH      0x05
#define STB_INIT_AFXT_HI    0x04
#define STB_INIT_HIGH       0x04

#define AFXT_HI_STB_HI      0x04
#define AFXT_LO_STB_HI      0x06
#define AFXT_HI_STB_LO      0x05
#define AFXT_LO_STB_LO      0x07

// structure definitions

typedef struct  _ATAPI_PARAMS{
    DEVICE_STATE    dsDeviceState[ATAPI_MAX_DRIVES];
    char            szAtapiNameString [ ATAPI_NAME_LENGTH ] ;
} ATAPIPARAMS, *PATAPIPARAMS ;

// function prototypes 
BOOLEAN
ParStlCheckIfStl(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

BOOLEAN
ParStlCheckIfNon1284_3Present(
    IN PPDO_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlCheckIfStl1284_3(
    IN PPDO_EXTENSION    Extension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    ) ;

BOOLEAN
ParStlCheckIfStlProductId(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

PCHAR
ParQueryStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    ) ;

PCHAR
ParBuildStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN          bReturnRawString                
    ) ;

STL_DEVICE_TYPE __cdecl 
ParStlGetDeviceType (
    IN PPDO_EXTENSION    Extension,
    IN int                  nPreferredDeviceType
    ) ;

VOID
ParStlSet16BitOperation (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckDrivePresent (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlWaitForBusyToClear (
    IN  PPDO_EXTENSION   Extension,
    IN  int                 nRegisterToWaitOn 
    ) ;

BOOLEAN
ParStlWaitForDrq (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlWaitForIrq (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtaAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlAtapiInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    );

BOOLEAN
ParStlAtaInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfScsiDevice (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfSSFDC (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfMMC (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfFlash (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfDazzle (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfLS120 (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfImpactLS120 (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfHiFD (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtaDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlCheckCardInsertionStatus ( 
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlSelectAdapterSocket (
    IN  PPDO_EXTENSION   Extension,
    int     nSocketNumber
    ) ;

VOID
ParStlWaitForMicroSeconds (
    int nMicroSecondsToWait
    ) ;

STL_DEVICE_TYPE
ParStlGetImpactDeviceType (
    IN  PPDO_EXTENSION       Extension,
    IN  OUT  PATAPIPARAMS       atapiParams,
    IN  int                     nPreferredDeviceType
    ) ;

STL_DEVICE_TYPE
ParStlGetImpactSDeviceType (
    IN  PPDO_EXTENSION       Extension,
    IN  OUT  PATAPIPARAMS       atapiParams,
    IN  int                     nPreferredDeviceType
    ) ;

BOOLEAN 
ParStlCheckIfEppDevice (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckPersonalityForEppDevice (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckFlashPersonality (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlHIFDCheckIfControllerReady (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlHIFDCheckSMCController (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlIsMMCEnginePresent(
    IN  PPDO_EXTENSION   Extension
    );

VOID
ParStlAssertIdleState (
    IN  PPDO_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckUMAXScannerPresence(
    IN PPDO_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlCheckAvisionScannerPresence(
    IN PPDO_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlSetEPPMode(
    IN PPDO_EXTENSION    Extension
    ) ;

USHORT
ParStlEPPWrite(
    IN PPDO_EXTENSION    Extension,
    IN UCHAR value
    ) ;

USHORT
ParStlEPPRead(
    IN PPDO_EXTENSION
    ) ;

int __cdecl
ParStlReadReg(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int    reg
    ) ;

int __cdecl
ParStlWriteReg(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int        reg,
    IN  int                 databyte
    ) ;

int __cdecl
ParStlReadIoPort(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int        reg
    ) ;

int __cdecl
ParStlWriteIoPort(
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned int        reg,
    IN  int                 databyte
    ) ;

int __cdecl
ParStlReceiveData(
    IN  PPDO_EXTENSION   Extension,
    OUT void                *hostBufferPointer,
    IN  long                shuttleMemoryAddress,
    IN  unsigned            count
    ) ;

int  __cdecl
ParStlGetMemorySize (
    IN  PPDO_EXTENSION   Extension
    ) ;

#endif  // for _PARSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\spp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    spp.c

Abstract:

    This module contains the code for standard parallel ports
    (centronics mode).

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    );
    
ULONG
SppCheckBusyDelay(
    IN  PPDO_EXTENSION   Pdx,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    );

NTSTATUS
ParEnterSppMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )
{
    UNREFERENCED_PARAMETER( DeviceIdRequest );

    DD((PCE)Pdx,DDT,"ParEnterSppMode: Enter!\n");

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    Pdx->Connected = TRUE;	
    return STATUS_SUCCESS;
}

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    )

/*++

Routine Description:

    This routine outputs the given write buffer to the parallel port
    using the standard centronics protocol.

Arguments:

    Controller  - Supplies the base address of the parallel port.

    WriteBuffer - Supplies the buffer to write to the port.

    NumBytesToWrite - Supplies the number of bytes to write out to the port.

    BusyDelay   - Supplies the number of microseconds to delay before
                    checking the busy bit.

Return Value:

    The number of bytes successfully written out to the parallel port.

--*/

{
    ULONG   i;
    UCHAR   DeviceStatus;
    BOOLEAN atPassiveIrql = FALSE;

    if( KeGetCurrentIrql() == PASSIVE_LEVEL ) {
        atPassiveIrql = TRUE;
    }

    if (!BusyDelay) {
        BusyDelay = 1;
    }

    for (i = 0; i < NumBytesToWrite; i++) {

        DeviceStatus = GetStatus(Controller);

        if (PAR_ONLINE(DeviceStatus)) {

            //
            // Anytime we write out a character we will restart
            // the count down timer.
            //

            P5WritePortUchar(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);

            KeStallExecutionProcessor(1);

            StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                      PAR_CONTROL_SLIN |
                                      PAR_CONTROL_NOT_INIT |
                                      PAR_CONTROL_STROBE));

            KeStallExecutionProcessor(1);

            StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                      PAR_CONTROL_SLIN |
                                      PAR_CONTROL_NOT_INIT));

            KeStallExecutionProcessor(BusyDelay);

        } else {
            DD(NULL,DDT,"spp::SppWriteLoopPI - DeviceStatus = %x - NOT ONLINE\n", DeviceStatus);
            break;
        }
    }

    DD(NULL,DDT,"SppWriteLoopPI - exit - bytes written = %ld\n",i);

    return i;
}

ULONG
SppCheckBusyDelay(
    IN  PPDO_EXTENSION   Pdx,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    )

/*++

Routine Description:

    This routine determines if the current busy delay setting is
    adequate for this printer.

Arguments:

    Pdx       - Supplies the device extension.

    WriteBuffer     - Supplies the write buffer.

    NumBytesToWrite - Supplies the size of the write buffer.

Return Value:

    The number of bytes strobed out to the printer.

--*/

{
    PUCHAR          Controller;
    ULONG           BusyDelay;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   PerfFreq;
    LARGE_INTEGER   End;
    LARGE_INTEGER   GetStatusTime;
    LARGE_INTEGER   CallOverhead;
    UCHAR           DeviceStatus;
    ULONG           i;
    ULONG           NumberOfCalls;
    ULONG           maxTries;
    KIRQL           OldIrql = PASSIVE_LEVEL;

    UNREFERENCED_PARAMETER( NumBytesToWrite );

    Controller = Pdx->Controller;
    BusyDelay  = Pdx->BusyDelay;
    
    // If the current busy delay value is 10 or greater then something
    // is weird and settle for 10.

    if (Pdx->BusyDelay >= 10) {
        Pdx->BusyDelayDetermined = TRUE;
        return 0;
    }

    // Take some performance measurements.

    if (0 == SppNoRaiseIrql)
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    Start = KeQueryPerformanceCounter(&PerfFreq);
    
    DeviceStatus = GetStatus(Controller);
    
    End = KeQueryPerformanceCounter(&PerfFreq);
    
    GetStatusTime.QuadPart = End.QuadPart - Start.QuadPart;

    Start = KeQueryPerformanceCounter(&PerfFreq);
    End   = KeQueryPerformanceCounter(&PerfFreq);
    
    if (0 == SppNoRaiseIrql)
        KeLowerIrql(OldIrql);

    CallOverhead.QuadPart = End.QuadPart - Start.QuadPart;
    
    GetStatusTime.QuadPart -= CallOverhead.QuadPart;
    
    if (GetStatusTime.QuadPart <= 0) {
        GetStatusTime.QuadPart = 1;
    }

    // Figure out how many calls to 'GetStatus' can be made in 20 us.

    NumberOfCalls = (ULONG) (PerfFreq.QuadPart*20/GetStatusTime.QuadPart/1000000) + 1;

    //
    // - check to make sure the device is ready to receive a byte before we start clocking
    //    data out
    // 
    // DVDF - 25Jan99 - added check
    // 

    //
    // - nothing magic about 25 - just catch the case where NumberOfCalls may be bogus
    //    and try something reasonable - empirically NumberOfCalls has ranged from 8-24
    //
    maxTries = (NumberOfCalls > 25) ? 25 : NumberOfCalls;

    for( i = 0 ; i < maxTries ; i++ ) {
        // spin for slow device to get ready to receive data - roughly 20us max
        DeviceStatus = GetStatus( Controller );
        if( PAR_ONLINE( DeviceStatus ) ) {
            // break out of loop as soon as device is ready
            break;
        }
    }
    if( !PAR_ONLINE( DeviceStatus ) ) {
        // device is still not online - bail out
        return 0;
    }

    // The printer is ready to accept a byte.  Strobe one out
    // and check out the reaction time for BUSY.

    if (BusyDelay) {

        if (0 == SppNoRaiseIrql)
            KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        P5WritePortUchar(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT |
                                  PAR_CONTROL_STROBE));
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT));
        KeStallExecutionProcessor(BusyDelay);

        for (i = 0; i < NumberOfCalls; i++) {
            DeviceStatus = GetStatus(Controller);
            if (!(DeviceStatus & PAR_STATUS_NOT_BUSY)) {
                break;
            }
        }

        if (0 == SppNoRaiseIrql)
            KeLowerIrql(OldIrql);

    } else {

        if (0 == SppNoRaiseIrql)
            KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

        P5WritePortUchar(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT |
                                  PAR_CONTROL_STROBE));
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT));

        for (i = 0; i < NumberOfCalls; i++) {
            DeviceStatus = GetStatus(Controller);
            if (!(DeviceStatus & PAR_STATUS_NOT_BUSY)) {
                break;
            }
        }

        if (0 == SppNoRaiseIrql)
            KeLowerIrql(OldIrql);
    }

    if (i == 0) {

        // In this case the BUSY was set as soon as we checked it.
        // Use this busyDelay with the PI code.

        Pdx->UsePIWriteLoop = TRUE;
        Pdx->BusyDelayDetermined = TRUE;

    } else if (i == NumberOfCalls) {

        // In this case the BUSY was never seen.  This is a very fast
        // printer so use the fastest code possible.

        Pdx->BusyDelayDetermined = TRUE;

    } else {

        // The test failed.  The lines showed not BUSY and then BUSY
        // without strobing a byte in between.

        Pdx->UsePIWriteLoop = TRUE;
        Pdx->BusyDelay++;
    }

    return 1;
}

NTSTATUS
SppWrite(
    IN  PPDO_EXTENSION Pdx,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    )

/*++

Routine Description:

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS            status;
    UCHAR               DeviceStatus;
    ULONG               TimerStart;
    LONG                CountDown;
    PUCHAR              IrpBuffer;
    LARGE_INTEGER       StartOfSpin;
    LARGE_INTEGER       NextQuery;
    LARGE_INTEGER       Difference;
    BOOLEAN             DoDelays;
    BOOLEAN             PortFree;
    ULONG               NumBytesWritten; 
    ULONG               LoopNumber;
    ULONG               NumberOfBusyChecks;
    ULONG               MaxBusyDelay;
    ULONG               MaxBytes;
    
    DD((PCE)Pdx,DDT,"SppWrite - enter, BytesToWrite = %d\n",BytesToWrite);

    *BytesTransferred = 0; // initialize to none

    IrpBuffer  = (PUCHAR)Buffer;
    MaxBytes   = BytesToWrite;
    TimerStart = Pdx->TimerStart;
    CountDown  = (LONG)TimerStart;
    
    NumberOfBusyChecks = 9;
    MaxBusyDelay = 0;
    
    // Turn off the strobe in case it was left on by some other device sharing the port.
    StoreControl(Pdx->Controller, (PAR_CONTROL_WR_CONTROL |
                                         PAR_CONTROL_SLIN |
                                         PAR_CONTROL_NOT_INIT));

PushSomeBytes:

    //
    // While we are strobing data we don't want to get context
    // switched away.  Raise up to dispatch level to prevent that.
    //
    // The reason we can't afford the context switch is that
    // the device can't have the data strobe line on for more
    // than 500 microseconds.
    //
    // We never want to be at raised irql form more than
    // 200 microseconds, so we will do no more than 100
    // bytes at a time.
    //

    LoopNumber = 512;
    if (LoopNumber > BytesToWrite) {
        LoopNumber = BytesToWrite;
    }

    //
    // Enter the write loop
    //
    
    if (!Pdx->BusyDelayDetermined) {
        DD((PCE)Pdx,DDT,"SppWrite: Calling SppCheckBusyDelay\n");
        NumBytesWritten = SppCheckBusyDelay(Pdx, IrpBuffer, LoopNumber);
        
        if (Pdx->BusyDelayDetermined) {
        
            if (Pdx->BusyDelay > MaxBusyDelay) {
                MaxBusyDelay = Pdx->BusyDelay;
                NumberOfBusyChecks = 10;
            }
            
            if (NumberOfBusyChecks) {
                NumberOfBusyChecks--;
                Pdx->BusyDelayDetermined = FALSE;
                
            } else {
            
                Pdx->BusyDelay = MaxBusyDelay + 1;
            }
        }
        
    } else if( Pdx->UsePIWriteLoop ) {
        NumBytesWritten = SppWriteLoopPI( Pdx->Controller, IrpBuffer, LoopNumber, Pdx->BusyDelay );
    } else {
        NumBytesWritten = SppWriteLoopPI( Pdx->Controller, IrpBuffer, LoopNumber, 1 );
    }


    if (NumBytesWritten) {
    
        CountDown     = TimerStart;
        IrpBuffer    += NumBytesWritten;
        BytesToWrite -= NumBytesWritten;
        
    }

    //
    // Check to see if the io is done.  If it is then call the
    // code to complete the request.
    //

    if (!BytesToWrite) {
    
        *BytesTransferred = MaxBytes;

        status = STATUS_SUCCESS;
        goto returnTarget;

    } else if ((Pdx->CurrentOpIrp)->Cancel) {

        //
        // See if the IO has been canceled.  The cancel routine
        // has been removed already (when this became the
        // current irp).  Simply check the bit.  We don't even
        // need to capture the lock.   If we miss a round
        // it won't be that bad.
        //

        *BytesTransferred = MaxBytes - BytesToWrite;

        status = STATUS_CANCELLED;
        goto returnTarget;

    } else {

        //
        // We've taken care of the reasons that the irp "itself"
        // might want to be completed.
        // printer to see if it is in a state that might
        // cause us to complete the irp.
        //
        // First let's check if the device status is
        // ok and online.  If it is then simply go back
        // to the byte pusher.
        //


        DeviceStatus = GetStatus(Pdx->Controller);

        if (PAR_ONLINE(DeviceStatus)) {
            goto PushSomeBytes;
        }

        //
        // Perhaps the operator took the device off line,
        // or forgot to put in enough paper.  If so, then
        // let's hang out here for the until the timeout
        // period has expired waiting for them to make things
        // all better.
        //

        if (PAR_PAPER_EMPTY(DeviceStatus) ||
            PAR_OFF_LINE(DeviceStatus)) {

            if (CountDown > 0) {

                //
                // We'll wait 1 second increments.
                //

                DD((PCE)Pdx,DDT,"decrementing countdown for PAPER_EMPTY/OFF_LINE - countDown: %d status: 0x%x\n", CountDown, DeviceStatus);
                    
                CountDown--;

                // If anyone is waiting for the port then let them have it,
                // since the printer is busy.

                ParFreePort(Pdx);

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &Pdx->OneSecond
                    );

                if (!ParAllocPort(Pdx)) {
                
                    *BytesTransferred = MaxBytes - BytesToWrite;

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_BUSY\n");
                    
                    status = STATUS_DEVICE_BUSY;
                    goto returnTarget;
                }

                goto PushSomeBytes;

            } else {

                //
                // Timer has expired.  Complete the request.
                //

                *BytesTransferred = MaxBytes - BytesToWrite;
                                                
                DD((PCE)Pdx,DDT,"In SppWrite(...): Timer expired - DeviceStatus = %08x\n", DeviceStatus);

                if (PAR_OFF_LINE(DeviceStatus)) {

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_OFF_LINE\n");

                    status = STATUS_DEVICE_OFF_LINE;
                    goto returnTarget;
                    
                } else if (PAR_NO_CABLE(DeviceStatus)) {

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_NOT_CONNECTED\n");

                    status = STATUS_DEVICE_NOT_CONNECTED;
                    goto returnTarget;

                } else {

                    DD((PCE)Pdx,DDT,"In SppWrite(...): returning STATUS_DEVICE_PAPER_EMPTY\n");

                    status = STATUS_DEVICE_PAPER_EMPTY;
                    goto returnTarget;

                }
            }


        } else if (PAR_POWERED_OFF(DeviceStatus) ||
                   PAR_NOT_CONNECTED(DeviceStatus) ||
                   PAR_NO_CABLE(DeviceStatus)) {

            //
            // We are in a "bad" state.  Is what
            // happened to the printer (power off, not connected, or
            // the cable being pulled) something that will require us
            // to reinitialize the printer?  If we need to
            // reinitialize the printer then we should complete
            // this IO so that the driving application can
            // choose what is the best thing to do about it's
            // io.
            //

            DD((PCE)Pdx,DDT,"In SppWrite(...): \"bad\" state - need to reinitialize printer?");

            *BytesTransferred = MaxBytes - BytesToWrite;
                        
            if (PAR_POWERED_OFF(DeviceStatus)) {

                DD((PCE)Pdx,DDT,"SppWrite: returning STATUS_DEVICE_POWERED_OFF\n");

                status = STATUS_DEVICE_POWERED_OFF;
                goto returnTarget;
                
            } else if (PAR_NOT_CONNECTED(DeviceStatus) ||
                       PAR_NO_CABLE(DeviceStatus)) {

                DD((PCE)Pdx,DDT,"SppWrite: STATUS_DEVICE_NOT_CONNECTED\n");

                status = STATUS_DEVICE_NOT_CONNECTED;
                goto returnTarget;

            }
        }

        //
        // The device could simply be busy at this point.  Simply spin
        // here waiting for the device to be in a state that we
        // care about.
        //
        // As we spin, get the system ticks.  Every time that it looks
        // like a second has passed, decrement the countdown.  If
        // it ever goes to zero, then timeout the request.
        //

        KeQueryTickCount(&StartOfSpin);
        DoDelays = FALSE;
        
        do {

            //
            // After about a second of spinning, let the rest of the
            // machine have time for a second.
            //

            if (DoDelays) {

                ParFreePort(Pdx);
                PortFree = TRUE;

                DD((PCE)Pdx,DDT,"Before delay thread of one second, dsr=%x DCR[%x]\n",
                        P5ReadPortUchar(Pdx->Controller + OFFSET_DSR),
                        P5ReadPortUchar(Pdx->Controller + OFFSET_DCR));
                KeDelayExecutionThread(KernelMode, FALSE, &Pdx->OneSecond);

                DD((PCE)Pdx,DDT,"Did delay thread of one second, CountDown=%d\n", CountDown);

                CountDown--;

            } else {

                if (Pdx->QueryNumWaiters(Pdx->PortContext)) {
                
                    ParFreePort(Pdx);
                    PortFree = TRUE;
                    
                } else {
                
                    PortFree = FALSE;
                }

                KeQueryTickCount(&NextQuery);

                Difference.QuadPart = NextQuery.QuadPart - StartOfSpin.QuadPart;

                if (Difference.QuadPart*KeQueryTimeIncrement() >=
                    Pdx->AbsoluteOneSecond.QuadPart) {

                    DD((PCE)Pdx,DDT,"Countdown: %d - device Status: %x lowpart: %x highpart: %x\n",
                            CountDown, DeviceStatus, Difference.LowPart, Difference.HighPart);
                    
                    CountDown--;
                    DoDelays = TRUE;

                }
            }

            if (CountDown <= 0) {
            
                *BytesTransferred = MaxBytes - BytesToWrite;
                status = STATUS_DEVICE_BUSY;
                goto returnTarget;

            }

            if (PortFree && !ParAllocPort(Pdx)) {
            
                *BytesTransferred = MaxBytes - BytesToWrite;
                status = STATUS_DEVICE_BUSY;
                goto returnTarget;
            }

            DeviceStatus = GetStatus(Pdx->Controller);

        } while ((!PAR_ONLINE(DeviceStatus)) &&
                 (!PAR_PAPER_EMPTY(DeviceStatus)) &&
                 (!PAR_POWERED_OFF(DeviceStatus)) &&
                 (!PAR_NOT_CONNECTED(DeviceStatus)) &&
                 (!PAR_NO_CABLE(DeviceStatus)) &&
                  !(Pdx->CurrentOpIrp)->Cancel);

        if (CountDown != (LONG)TimerStart) {

            DD((PCE)Pdx,DDT,"Leaving busy loop - countdown %d status %x\n", CountDown, DeviceStatus);

        }
        
        goto PushSomeBytes;

    }

returnTarget:
    // added single return point so we can save log of bytes transferred
    Pdx->log.SppWriteCount += *BytesTransferred;

    DD((PCE)Pdx,DDT,"SppWrite - exit, BytesTransferred = %d\n",*BytesTransferred);

    return status;

}

NTSTATUS
SppQueryDeviceId(
    IN   PPDO_EXTENSION  Pdx,
    OUT  PCHAR           DeviceIdBuffer,
    IN   ULONG           BufferSize,
    OUT  PULONG          DeviceIdSize,
    IN   BOOLEAN         bReturnRawString
    )
/*++

Routine Description:

    This routine is now a wrapper function around Par3QueryDeviceId that
      preserves the interface of the original SppQueryDeviceId function.

    Clients of this function should consider switching to Par3QueryDeviceId
      if possible because Par3QueryDeviceId will allocate and return a pointer
      to a buffer if the caller supplied buffer is too small to hold the 
      device ID.
    
Arguments:

    Pdx         - DeviceExtension/Legacy - used to get controller.
    DeviceIdBuffer    - Buffer used to return ID.
    BufferSize        - Size of supplied buffer.
    DeviceIdSize      - Size of returned ID.
    bReturnRawString  - Should the 2 byte size prefix be included? (TRUE==Yes)

Return Value:

    STATUS_SUCCESS          - ID query was successful
    STATUS_BUFFER_TOO_SMALL - We were able to read an ID from the device but the caller
                                supplied buffer was not large enough to hold the ID. The
                                size required to hold the ID is returned in DeviceIdSize.
    STATUS_UNSUCCESSFUL     - ID query failed - Possibly interface or device is hung, missed
                                timeouts during the handshake, or device may not be connected.

--*/
{
    PCHAR idBuffer;

    DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: Enter - buffersize=%d\n", BufferSize);
    if ( Pdx->Ieee1284Flags & ( 1 << Pdx->Ieee1284_3DeviceId ) ) {
        idBuffer = Par3QueryDeviceId( Pdx, DeviceIdBuffer, BufferSize, DeviceIdSize, bReturnRawString, TRUE );
    }
    else {
        idBuffer = Par3QueryDeviceId( Pdx, DeviceIdBuffer, BufferSize, DeviceIdSize, bReturnRawString, FALSE );
    }

    if( idBuffer == NULL ) {
        //
        // Error at lower level - FAIL query
        //
        DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: call to Par3QueryDeviceId hard FAIL\n");
        return STATUS_UNSUCCESSFUL;
    } else if( idBuffer != DeviceIdBuffer ) {
        //
        // We got a deviceId from the device, but caller's buffer was too small to hold it.
        //   Free the buffer and tell the caller that the supplied buffer was too small.
        //
        DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: buffer too small - have buffer size=%d, need buffer size=%d\n", BufferSize, *DeviceIdSize);
        ExFreePool( idBuffer );
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        //
        // Query succeeded using caller's buffer (idBuffer == DeviceIdBuffer)
        //
        DD((PCE)Pdx,DDT,"spp::SppQueryDeviceId: SUCCESS - deviceId=<%s>\n", idBuffer);
        return STATUS_SUCCESS;
    }
}

VOID
ParTerminateSppMode(
    IN  PPDO_EXTENSION   Pdx
    )
{
    DD((PCE)Pdx,DDT,"ParTerminateSppMode\n");
    Pdx->Connected    = FALSE;
    P5SetPhase( Pdx, PHASE_TERMINATE );
    return;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\sppieee.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    sppieee.c

Abstract:

    This module contains code for the host to utilize an ieee version of
    compatibility mode

Author:

    Robbie Harris (Hewlett-Packard) 29-July-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

NTSTATUS
SppIeeeWrite(
    IN  PPDO_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    )

/*++

Routine Description:

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      Controller = Extension->Controller;
    PUCHAR      pPortDCR = Extension->Controller + OFFSET_DCR;
    PUCHAR      pPortData = Extension->Controller + OFFSET_DATA;
    ULONG       wByteCount = BytesToWrite;
    UCHAR       bDCRstrobe;		// Holds precomputed value for state 35
    UCHAR       bDCRnormal;		// Holds precomputed value for state 37
    PUCHAR      lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type

    
    // Make precomputed DCR values for strobe and periph ack
    bDCRstrobe = SET_DCR(DIR_WRITE, IRQEN_DISABLE, ACTIVE, ACTIVE, ACTIVE, INACTIVE);
    bDCRnormal = SET_DCR(DIR_WRITE, IRQEN_DISABLE, ACTIVE, ACTIVE, ACTIVE, ACTIVE);

    // Wait a bit to give nBusy a chance to settle, because 
    // WriteComm will bail immediately if the device says busy
    if ( CHECK_DSR( Controller,
                    INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE,
                    IEEE_MAXTIME_TL ) )
    {
        while (wByteCount)
        {
                // Place a data byte on the bus
            P5WritePortUchar(pPortData, *lpsBufPtr);
            
                // Start handshake by dropping strobe
            P5WritePortUchar(pPortDCR, bDCRstrobe);
            
                // Wait for Periph Busy Response
            if ( !CHECK_DSR(Controller, ACTIVE, DONT_CARE, DONT_CARE,
                    DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) )        
            {
                status = STATUS_DEVICE_BUSY;
                break;
            }

                // Printer responded by making Busy high -- the byte has
            // been accepted.  Adjust the data pointer.
            lpsBufPtr++;
            
                // Finish handshake by raising strobe
            P5WritePortUchar(pPortDCR, bDCRnormal);

                // Adjust count while we're waiting for the peripheral
            // to respond with state 32
            wByteCount--;
            
                // Wait for PeriphAck and PeriphBusy response
            if ( !CHECK_DSR(Controller, INACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
                    DONT_CARE, IEEE_MAXTIME_TL) )
            {
                // Set appropriate error based on relaxed timeout.
                status = STATUS_DEVICE_BUSY;
                break;
            }
        }	// while...                            
    
        *BytesTransferred  = BytesToWrite - wByteCount;      // Set current count.
    }
                
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\registry.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       registry.c
//
//--------------------------------------------------------------------------

#include "pch.h"

NTSTATUS
PptRegGetDeviceParameterDword(
    IN     PDEVICE_OBJECT  Pdo,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter of type dword

Arguments:

    Pdo - ParPort PDO

    ParameterName - parameter name to look up

    ParameterValue - default parameter value

Return Value:

    Status - if RegKeyValue does not exist or other failure occurs,
               then default is returned via ParameterValue

--*/
{
    NTSTATUS                 status;
    HANDLE                   hKey;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultValue;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hKey);

    if(!NT_SUCCESS(status)) {
        return status;
    }

    defaultValue = *ParameterValue;

    RtlZeroMemory(&queryTable, sizeof(queryTable));

    queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name          = ParameterName;
    queryTable[0].EntryContext  = ParameterValue;
    queryTable[0].DefaultType   = REG_DWORD;
    queryTable[0].DefaultData   = &defaultValue;
    queryTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE, hKey, queryTable, NULL, NULL);

    if ( !NT_SUCCESS(status) ) {
        *ParameterValue = defaultValue;
    }

    ZwClose(hKey);

    return status;
}

NTSTATUS
PptRegSetDeviceParameterDword(
    IN PDEVICE_OBJECT  Pdo,
    IN PWSTR           ParameterName,
    IN PULONG          ParameterValue
    )
/*++

Routine Description:

    Create/set a devnode registry parameter of type dword

Arguments:

    Pdo - ParPort PDO

    ParameterName - parameter name

    ParameterValue - parameter value

Return Value:

    Status - status from attempt

--*/
{
    NTSTATUS        status;
    HANDLE          hKey;
    UNICODE_STRING  valueName;
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_WRITE, &hKey);

    if( !NT_SUCCESS( status ) ) {
        DD((PCE)pdx,DDE,"PptRegSetDeviceParameterDword - openKey FAILED w/status=%x",status);
        return status;
    }

    RtlInitUnicodeString( &valueName, ParameterName );

    status = ZwSetValueKey( hKey, &valueName, 0, REG_DWORD, ParameterValue, sizeof(ULONG) );
    if( !NT_SUCCESS( status ) ) {
        DD((PCE)pdx,DDE,"PptRegSetDeviceParameterDword - setValue FAILED w/status=%x",status);
    }

    ZwClose(hKey);

    return status;
}

/************************************************************************/
/* PptRegGetDword                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Read a REG_DWORD from the registry. This is a wrapper for
//       function RtlQueryRegistryValues.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to be read
//     ParameterValue - used to return the DWORD value read from the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Notes:
//
//     - On an ERROR or if the requested registry value does not exist, 
//         *ParameterValue retains its original value.
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegGetDword(
    IN     ULONG  RelativeTo,               
    IN     PWSTR  Path,
    IN     PWSTR  ParameterName,
    IN OUT PULONG ParameterValue
    )
{
    NTSTATUS                  status;
    RTL_QUERY_REGISTRY_TABLE  paramTable[2];
    ULONG                     defaultValue;

    if( ( NULL == Path ) || ( NULL == ParameterName ) || ( NULL == ParameterValue ) ) {
        return STATUS_INVALID_PARAMETER;
    }

    DD(NULL,DDT,"PptRegGetDword - RelativeTo= %x, Path=<%S>, ParameterName=<%S>\n", RelativeTo, Path, ParameterName);

    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    // leave paramTable[1] as all zeros to terminate the table
    //
    // use original value as default value
    //
    // use RtlQueryRegistryValues to do the grunge work
    //
    RtlZeroMemory( paramTable, sizeof(paramTable) );

    defaultValue = *ParameterValue;

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = ParameterName;
    paramTable[0].EntryContext  = ParameterValue;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultValue;
    paramTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues( RelativeTo | RTL_REGISTRY_OPTIONAL,
                                     Path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if( status != STATUS_SUCCESS ) {
        DD(NULL,DDW,"PptRegGetDword - RtlQueryRegistryValues FAILED w/status=%x\n",status);
    }

    DD(NULL,DDT,"PptRegGetDword - post-query <%S> *ParameterValue = %x\n", ParameterName, *ParameterValue);

    return status;
}


/************************************************************************/
/* PptRegSetDword                                                       */
/************************************************************************/
//
// Routine Description:
//
//     Write a REG_DWORD to the registry. This is a wrapper for
//       function RtlWriteRegistryValue.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to write
//     ParameterValue - points to the DWORD value to write to the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Notes:
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegSetDword(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PULONG ParameterValue
    )
{
    NTSTATUS status;

    if( (NULL == Path) || (NULL == ParameterName) || (NULL == ParameterValue) ) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = RtlWriteRegistryValue( RelativeTo,
                                        Path,
                                        ParameterName,
                                        REG_DWORD,
                                        ParameterValue,
                                        sizeof(ULONG) );
    }
    return status;
}

/************************************************************************/
/* PptRegGetSz                                                          */
/************************************************************************/
//
// Routine Description:
//
//     Read a REG_SZ from the registry. This is a wrapper for
//       function RtlQueryRegistryValues.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to be read
//     ParameterValue - points to a UNICODE_STRING structure used to return 
//                        the REG_SZ read from the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
//
// Notes:
//
//     - All fields of *ParameterValue UNICODE_STRING structure must be 
//         initialized to zero by the caller.
//     - On SUCCESS ParameterValue->Buffer points to an allocated buffer. The
//         caller is responsible for freeing this buffer when done.
//     - On SUCCESS ParameterValue->Buffer is UNICODE_NULL terminated and is
//         safe to use as a PWSTR.
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegGetSz(
    IN      ULONG  RelativeTo,               
    IN      PWSTR  Path,
    IN      PWSTR  ParameterName,
    IN OUT  PUNICODE_STRING ParameterValue
    )
{
    NTSTATUS                  status;
    RTL_QUERY_REGISTRY_TABLE  paramTable[2];

    //
    // sanity check parameters - reject NULL pointers and invalid
    //   UNICODE_STRING field initializations
    //
    if( ( NULL == Path ) || ( NULL == ParameterName ) || ( NULL == ParameterValue ) ) {
        return STATUS_INVALID_PARAMETER;
    }
    if( (ParameterValue->Length != 0) || (ParameterValue->MaximumLength !=0) || (ParameterValue->Buffer != NULL) ) {
        return STATUS_INVALID_PARAMETER;
    }

    DD(NULL,DDT,"PptRegGetSz - RelativeTo=%x, Path=<%S>, ParameterName=<%S>\n", RelativeTo, Path, ParameterName);

    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    // leave paramTable[1] as all zeros to terminate the table
    //
    // use RtlQueryRegistryValues to do the grunge work
    //
    RtlZeroMemory( paramTable, sizeof(paramTable) );

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = ParameterName;
    paramTable[0].EntryContext  = ParameterValue;
    paramTable[0].DefaultType   = REG_SZ;
    paramTable[0].DefaultData   = L"";
    paramTable[0].DefaultLength = 0;

    status = RtlQueryRegistryValues( RelativeTo | RTL_REGISTRY_OPTIONAL,
                                     Path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if( status != STATUS_SUCCESS ) {
        DD(NULL,DDW,"PptRegGetSz - RtlQueryRegistryValues FAILED w/status=%x\n",status);
    }

    //
    // Try to make ParameterValue->Buffer safe to use as a PWSTR parameter. 
    //   Clean up the allocation and fail this request if we are unable to do so.
    //
    if( (STATUS_SUCCESS == status) && (ParameterValue->Buffer != NULL) ) {

        if( ParameterValue->MaximumLength >= (ParameterValue->Length + sizeof(WCHAR)) ) {

            (ParameterValue->Buffer)[ ParameterValue->Length / sizeof(WCHAR) ] = UNICODE_NULL;
            DD(NULL,DDT,"PptRegGetSz - post-query *ParameterValue=<%S>\n", ParameterValue->Buffer);

        } else {

            ExFreePool( ParameterValue->Buffer );
            ParameterValue->Length        = 0;
            ParameterValue->MaximumLength = 0;
            ParameterValue->Buffer        = 0;
            status = STATUS_UNSUCCESSFUL;

        }
    }

    return status;
}

/************************************************************************/
/* PptRegSetSz                                                          */
/************************************************************************/
//
// Routine Description:
//
//     Write a REG_SZ to the registry. This is a wrapper for
//       function RtlWriteRegistryValue.
//
// Arguments: 
//
//     RelativeTo     - starting point for the Path
//     Path           - path to the registry key
//     ParameterName  - name of the value to write
//     ParameterValue - points to the PWSTR to write to the registry
//
// Return Value:                                          
//                                                            
//     NTSTATUS
//                                                        
// Notes:
//
// Log:
//
/************************************************************************/
NTSTATUS
PptRegSetSz(
    IN  ULONG  RelativeTo,               
    IN  PWSTR  Path,
    IN  PWSTR  ParameterName,
    IN  PWSTR  ParameterValue
    )
{
    NTSTATUS status;

    if( (NULL == Path) || (NULL == ParameterName) || (NULL == ParameterValue) ) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        status = RtlWriteRegistryValue( RelativeTo,
                                        Path,
                                        ParameterName,
                                        REG_SZ,
                                        ParameterValue,
                                        ( wcslen(ParameterValue) + sizeof(CHAR) ) * sizeof(WCHAR) );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\shuttle.c ===
/*++

Copyright (C) SCM Micro Systems.

Module Name:

    parstl.c

Abstract:

    This is the module that generates unique device id
    for shuttle adapters, that do not have the capability
    to do so, by themselves.

Author:

    Devanathan NR   21-Jun-1999
    Sudheendran TL

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"
#include "shuttle.h"

BOOLEAN
ParStlCheckIfStl(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) 
/*++

Routine Description:

    This function checks whether the indicated device
    is a shuttle device or not.

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy index on which to do the check.

Return Value:

    TRUE            - Yes, it was a Shuttle device.
    FALSE           - No, not a shuttle.

--*/
{
    BOOLEAN     bStlNon1284_3Found = FALSE ;

    DD(NULL,DDW,"ParStlCheckIfStl - enter\n");

    Extension->Ieee1284Flags &= ( ~ ( 1 << ulDaisyIndex ) ) ;
    bStlNon1284_3Found = ParStlCheckIfNon1284_3Present( Extension ) ;

    if ( TRUE == ParStlCheckIfStl1284_3 ( Extension, ulDaisyIndex, bStlNon1284_3Found ) ) {
        // this adapter is a Shuttle 1284_3 adapter
        Extension->Ieee1284Flags |= ( 1 << ulDaisyIndex ) ;
        return TRUE ;
    }
    if ( TRUE == bStlNon1284_3Found ) {
        if ( TRUE == ParStlCheckIfStlProductId ( Extension, ulDaisyIndex ) ) {
            // this adapter is Shuttle non-1284_3 adapter
            Extension->Ieee1284Flags |= ( 1 << ulDaisyIndex ) ;
            return TRUE ;
        }
    }
    return FALSE ;
}

BOOLEAN
ParStlCheckIfNon1284_3Present(
    IN PPDO_EXTENSION    Extension
    )
/*++

Routine Description:

    Indicates whether one of the devices of the earlier
    specification is present in the chain.


Arguments:

    Extension   - Device Extension structure


Return Value:

    TRUE    : Atleast one of the adapters are of earlier spec.
    FALSE   : None of the adapters of the earlier spec.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;
    UCHAR   ucAckStatus ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        ucAckStatus = status & 0x40 ;

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            if ( ucAckStatus != ( status & 0x40 ) ) {

                // save current ack status
                ucAckStatus = status & 0x40 ;

                // continue with sixth byte
                P5WritePortUchar( CurrentPort, ModeQualifier[5] );
                KeStallExecutionProcessor( Delay );

                // check for correct status
                status = P5ReadPortUchar( CurrentStatus );

                // if status is valid there is a device out there responding
                if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                    bReturnValue = TRUE ;

                } // Third status

            } // ack of earlier adapters not seen

            // last byte
            P5WritePortUchar( CurrentPort, ModeQualifier[6] );

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    DD(NULL,DDW,"ParStlCheckIfNon1284_3Present - returning %s\n",bReturnValue?"TRUE":"FALSE");

    return bReturnValue ;
} // ParStlCheckIfNon1284_3Present

BOOLEAN
ParStlCheckIfStl1284_3(
    IN PPDO_EXTENSION    Extension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle 1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

    bNoStrobe       - If set, indicates that the query
                      Ep1284 command issued by this function
                      need not assert strobe to latch the
                      command.

Return Value:

    TRUE            - Yes. Device is Shuttle 1284_3 type of device.
    FALSE           - No. This may mean that this device is either
                      non-shuttle or Shuttle non-1284_3 type of
                      device.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucExpectedPattern ;
    UCHAR   ucReadValue, ucReadPattern;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                // Device is out there
                KeStallExecutionProcessor( Delay );

                // issue shuttle specific CPP command
                P5WritePortUchar( CurrentPort, (UCHAR) ( 0x88 | ulDaisyIndex ) );
                KeStallExecutionProcessor( Delay );        // wait a bit

                if ( ulDaisyIndex && ( bNoStrobe == FALSE ) ) {

                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit

                }

                ucExpectedPattern = 0xF0 ;
                bReturnValue = TRUE ;

                while ( ucExpectedPattern ) {

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x80 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x88 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    ucReadValue = P5ReadPortUchar( CurrentStatus ) ;
                    ucReadPattern = ( ucReadValue << 1 ) & 0x70 ;
                    ucReadPattern |= ( ucReadValue & 0x80 ) ;

                    if ( ucReadPattern != ucExpectedPattern ) {
                        // not Shuttle 1284_3 behaviour
                        bReturnValue = FALSE ;
                        break ;
                    }

                    ucExpectedPattern -= 0x10 ;
                }


                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    DD(NULL,DDW,"ParStlCheckIfStl1284_3 - returning %s\n",bReturnValue?"TRUE":"FALSE");

    return bReturnValue ;
} // end  ParStlCheckIfStl1284_3()

BOOLEAN
ParStlCheckIfStlProductId(
    IN PPDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle non-1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

Return Value:

    TRUE            - Yes. Device is Shuttle non-1284_3 type of device.
    FALSE           - No. This may mean that this device is 
                      non-shuttle.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucProdIdHiByteHiNibble, ucProdIdHiByteLoNibble ;
    UCHAR   ucProdIdLoByteHiNibble, ucProdIdLoByteLoNibble ;
    UCHAR   ucProdIdHiByte, ucProdIdLoByte ;
    USHORT  usProdId ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                P5WritePortUchar ( CurrentPort, (UCHAR) (CPP_QUERY_PRODID | ulDaisyIndex )) ;
                KeStallExecutionProcessor( Delay );

                // Device is out there
                KeStallExecutionProcessor( Delay );
                ucProdIdLoByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdLoByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteLoNibble >>= 4 ;
                ucProdIdLoByte = ucProdIdLoByteHiNibble | ucProdIdLoByteLoNibble ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteLoNibble >>= 4 ;
                ucProdIdHiByte = ucProdIdHiByteHiNibble | ucProdIdHiByteLoNibble ;

                // last strobe
                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                usProdId = ( ucProdIdHiByte << 8 ) | ucProdIdLoByte ;

                if ( ( SHTL_EPAT_PRODID == usProdId ) ||\
                     ( SHTL_EPST_PRODID == usProdId ) ) {
                    // one of the devices that conform to the earlier
                    // draft is found
                    bReturnValue = TRUE ;
                }

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    DD(NULL,DDW,"ParStlCheckIfStlProductId - returning %s\n",bReturnValue?"TRUE":"FALSE");

    return bReturnValue ;
} // end  ParStlCheckIfStlProductId()

PCHAR
ParStlQueryStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer,
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    )
/*++

Routine Description:

    This routine retrieves/constructs the unique device id
    string from the selected shuttle device on the chain
    and updates the caller's buffer with the same.

Arguments:

    IN  Extension               : The device extension
    OUT CallerDeviceIdBuffer    : Caller's buffer
    IN  CallerBufferSize        : Size of caller's buffer
    OUT DeviceIdSize            : Updated device id's size
    IN  bReturnRawString        : Whether to return raw
                                  string with the first two
                                  bytes or not.

Return Value:

    Pointer to the read device ID string, if successful.

    NULL otherwise.

--*/
{
    PUCHAR              Controller = Extension->Controller;
    NTSTATUS            Status;
    UCHAR               idSizeBuffer[2];
    ULONG               bytesToRead;
    ULONG               bytesRead = 0;
    USHORT              deviceIdSize;
    USHORT              deviceIdBufferSize;
    PCHAR               deviceIdBuffer;
    PCHAR               readPtr;

    DD(NULL,DDW,"ParStlQueryStlDeviceId - enter\n");

    *DeviceIdSize = 0;

    // assert idle state, to recover from undefined state,
    // just in case it gets into
    ParStlAssertIdleState ( Extension ) ;

    //
    // If we are currently connected to the peripheral via any 1284 mode
    //   other than Compatibility/Spp mode (which does not require an IEEE
    //   negotiation), we must first terminate the current mode/connection.
    // 
    // dvdf - RMT - what if we are connected in a reverse mode?
    //
    if( (Extension->Connected) && (afpForward[Extension->IdxForwardProtocol].fnDisconnect) ) {
        afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
    }

    //
    // Negotiate the peripheral into nibble device id mode.
    //
    Status = ParEnterNibbleMode(Extension, REQUEST_DEVICE_ID);
    if( !NT_SUCCESS(Status) ) {
        ParTerminateNibbleMode(Extension);
        goto targetContinue;
    }
    
    
    //
    // Read first two bytes to get the total (including the 2 size bytes) size 
    //   of the Device Id string.
    //
    bytesToRead = 2;
    Status = ParNibbleModeRead(Extension, idSizeBuffer, bytesToRead, &bytesRead);
    if( !NT_SUCCESS( Status ) || ( bytesRead != bytesToRead ) ) {
        goto targetContinue;
    }
    
    
    //
    // Compute size of DeviceId string (including the 2 byte size prefix)
    //
    deviceIdSize = (USHORT)( idSizeBuffer[0]*0x100 + idSizeBuffer[1] );
    
    {
        const USHORT minValidDevId    =   14; // 2 size bytes + "MFG:x;" + "MDL:y;"
        const USHORT maxValidDevId    = 2048; // arbitrary, but we've never seen one > 1024
        
        if( (deviceIdSize < minValidDevId) || (deviceIdSize > maxValidDevId) ) {
            //
            // The device is reporting a 1284 ID string length that is probably bogus.
            //   Ignore the device reported ID and skip to the code below that makes
            //   up a VID/PID based 1284 ID based on the specific SCM Micro chip used
            //   by the device.
            //
            goto targetContinue; 
        }
    }
    
    //
    // Allocate a buffer to hold the DeviceId string and read the DeviceId into it.
    //
    if( bReturnRawString ) {
        //
        // Caller wants the raw string including the 2 size bytes
        //
        *DeviceIdSize      = deviceIdSize;
        deviceIdBufferSize = (USHORT)(deviceIdSize + sizeof(CHAR));     // ID size + ID + terminating NULL
    } else {
        //
        // Caller does not want the 2 byte size prefix
        //
        *DeviceIdSize      = deviceIdSize - 2*sizeof(CHAR);
        deviceIdBufferSize = (USHORT)(deviceIdSize - 2*sizeof(CHAR) + sizeof(CHAR)); //           ID + terminating NULL
    }
    
    deviceIdBuffer = (PCHAR)ExAllocatePool(PagedPool, deviceIdBufferSize);
    if( !deviceIdBuffer ) {
        goto targetContinue;
    }


    //
    // NULL out the ID buffer to be safe
    //
    RtlZeroMemory( deviceIdBuffer, deviceIdBufferSize );
    
    
    //
    // Does the caller want the 2 byte size prefix?
    //
    if( bReturnRawString ) {
        //
        // Yes, caller wants the size prefix. Copy prefix to buffer to return.
        //
        *(deviceIdBuffer+0) = idSizeBuffer[0];
        *(deviceIdBuffer+1) = idSizeBuffer[1];
        readPtr = deviceIdBuffer + 2;
    } else {
        //
        // No, discard size prefix
        //
        readPtr = deviceIdBuffer;
    }
    
    
    //
    // Read remainder of DeviceId from device
    //
    bytesToRead = deviceIdSize -  2; // already have the 2 size bytes
    Status = ParNibbleModeRead(Extension, readPtr, bytesToRead, &bytesRead);
    
    
    ParTerminateNibbleMode( Extension );
    
    if( !NT_SUCCESS(Status) || (bytesRead < 1) ) {
        ExFreePool( deviceIdBuffer );
        goto targetContinue;
    }
    
    if ( strstr ( readPtr, "MFG:" ) == 0 ) {
        ExFreePool( deviceIdBuffer ) ;
        goto targetContinue;
    }
    
    deviceIdSize = (USHORT)strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    } 
    return deviceIdBuffer;

 targetContinue:

// Builds later than 2080 fail to terminate in Compatibility mode.
//IEEETerminate1284Mode fails after  Event 23 (Extension->CurrentEvent equals 23)
// with earlier 1284 draft.
//So, we terminate the adapter ourselves, in some cases may be redundant.
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT);
    KeStallExecutionProcessor( 5 );
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT | DCR_AUTOFEED);
    KeStallExecutionProcessor( 5 );
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT);
     
    ParStlAssertIdleState ( Extension ) ;

    deviceIdBuffer = ParBuildStlDeviceId(Extension, bReturnRawString);

    if( !deviceIdBuffer ) {
        return NULL;
    }

    deviceIdSize = (USHORT)strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    }
    return deviceIdBuffer;
}

PCHAR
ParBuildStlDeviceId(
    IN  PPDO_EXTENSION   Extension,
    IN  BOOLEAN          bReturnRawString
    )
/*++

Routine Description:

    This function detects the type of shuttle adapter and
    builds an appropriate device id string and returns it
    back.

    It is assumed that the device is already in the 
    selected state.

Arguments:

    Nil. 


Return Value:

    Pointer to the read/built device ID string, if successful.

    NULL otherwise.

--*/
{
    ULONG size = 0x80 ;
    PCHAR id ;
    STL_DEVICE_TYPE dtDeviceType ;
    CHAR szDeviceIdString[0x80] ;
    CHAR szVidPidString[] = "MFG:VID_04E6;CLS:SCSIADAPTER;MDL:PID_" ;
    CHAR szVidPidStringScan[] = "MFG:VID_04E6;CLS:IMAGE;MDL:PID_" ;

    RtlZeroMemory(szDeviceIdString, sizeof(szDeviceIdString));

    // identify the shuttle adapter type by calling
    // Devtype routines here and build an unique id
    // string here.
    dtDeviceType = ParStlGetDeviceType(Extension, DEVICE_TYPE_AUTO_DETECT);

    switch ( dtDeviceType ) {

        case DEVICE_TYPE_NONE :
            return NULL;

        case DEVICE_TYPE_EPP_DEVICE :
            dtDeviceType |= 0x80000000 ;
            sprintf(szDeviceIdString, "%s%08X;", szVidPidStringScan, dtDeviceType);
            break;

        default :
            dtDeviceType |= 0x80000000 ;
            sprintf(szDeviceIdString, "%s%08X;", szVidPidString, dtDeviceType);
            break;

    }

    id = ExAllocatePool(PagedPool, size);
    if( id ) {
        RtlZeroMemory( id, size );
        if( bReturnRawString ) {
            //
            // Yes, caller wants the size prefix. Copy prefix to buffer to return.
            //
            *(id+0) = 0;
            *(id+1) = 0x80-2;
            RtlCopyMemory( id+2, szDeviceIdString, size - sizeof(NULL) - 2 );
        } else {
            RtlCopyMemory( id, szDeviceIdString, size - sizeof(NULL) );
        }
        return id;
    }
    return NULL;
}

STL_DEVICE_TYPE __cdecl 
ParStlGetDeviceType (
    IN PPDO_EXTENSION    Extension,
    IN int                  nPreferredDeviceType
    )
{
    STL_DEVICE_TYPE dtDeviceType    = DEVICE_TYPE_NONE ;
    ATAPIPARAMS atapiParams ;
    int i;

    for ( i=0 ; i<ATAPI_MAX_DRIVES ; i++){
        atapiParams.dsDeviceState[i] = DEVICE_STATE_INVALID ;
    }

    do
    {
        if ( TRUE == ParStlCheckIfScsiDevice(Extension))
        {
// SCSI Device identified.
            dtDeviceType |= DEVICE_TYPE_SCSI_BIT ;
            break ;
        }

        if ( TRUE == NeedToEnableIoPads () )
        {
// in some adapters, the IO pads need to be enabled, before
// doing the device detection
            ParStlWriteReg( Extension, CONFIG_INDEX_REGISTER, EP1284_POWER_CONTROL_REG );
            ParStlWriteReg( Extension, CONFIG_DATA_REGISTER, ENABLE_IOPADS );
        }

        if ( TRUE == IsImpactSPresent() )
        {
// as impact-s has been identified, the device type identification
// can be done through personality configuration info
            dtDeviceType |= ParStlGetImpactSDeviceType( Extension, &atapiParams, nPreferredDeviceType );
            break;
        }

        if ( TRUE == IsImpactPresent() )
        {
// as impact has been identified, the device type identification
// can be done through personality configuration info
            dtDeviceType |= ParStlGetImpactDeviceType( Extension, &atapiParams, nPreferredDeviceType );
            break;
        }

        if (TRUE == ParStlCheckIfEppDevice(Extension))
        {
// epp device identified
            if ( TRUE == ParStlCheckUMAXScannerPresence(Extension) ) {
// umax identified
                dtDeviceType |= DEVICE_TYPE_UMAX_BIT;
                break;
            }
            if ( TRUE == ParStlCheckAvisionScannerPresence(Extension) ) {
// avision identified
                dtDeviceType |= DEVICE_TYPE_AVISION_BIT;
                break;
            }
// generice scanner peripheral detected
            dtDeviceType |= DEVICE_TYPE_EPP_DEVICE_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfSSFDC(Extension))
        {
// SSFDC identified
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfMMC(Extension,&atapiParams))
        {
// MMC device identified
            dtDeviceType |= DEVICE_TYPE_MMC_BIT;
            break;
        }

// set the 16 bit mode of the adapter
        ParStlSet16BitOperation(Extension) ;

        if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension, &atapiParams))
        {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
            if (TRUE == ParStlCheckIfAtapiDevice(Extension, &atapiParams))
            {
// sub-classify between HiFD and LS-120.
                if ( TRUE == ParStlCheckIfLS120(Extension))
                {
// LS Engine is found.            
                    dtDeviceType |= DEVICE_TYPE_LS120_BIT ;
                    break ;
                }
// Check for HiFD.  
                if (TRUE == ParStlCheckIfHiFD(Extension))
                {
// HiFD device identified.
                    dtDeviceType |=   DEVICE_TYPE_HIFD_BIT ;
                    break ;
                }
// OtherWise, it is a generic ATAPI device.
                dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                break ;
            }

            if (TRUE == ParStlCheckIfAtaDevice(Extension, &atapiParams))
            {
// ata identified
                dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                break;
            }
        }

        if (TRUE == ParStlCheckIfDazzle(Extension))
        {
// dazzle identified
            dtDeviceType |= DEVICE_TYPE_DAZZLE_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfFlash(Extension))
        {
// flash identified
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break;
        }
    }
    while ( FALSE ) ;

    return dtDeviceType & nPreferredDeviceType ;
}

VOID
ParStlWaitForMicroSeconds (
    int nMicroSecondsToWait
    ) {
    KeStallExecutionProcessor ( nMicroSecondsToWait ) ;
}

BOOLEAN
ParStlCheckCardInsertionStatus ( 
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byPowerRegData ;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
            break ;
        }

        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , 0x0F ) ;
        byPowerRegData  =  (UCHAR) ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
        
        if ( byPowerRegData & SHTL_CARD_INSERTED_STATUS )
        {
// as the card not inserted status is reported, it is ATA / ATAPI
// possibly, not flash. hence, we break here.
            break ;
        }

        bReturnValue    =   TRUE ;
    }
    while ( FALSE ) ;

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlSelectAdapterSocket (
    IN  PPDO_EXTENSION   Extension,
    IN  int                 nSocketNumber
    )
{
    BOOLEAN bReturnValue    =   FALSE ;
    UCHAR   bySCRControlReg , byISAControlReg ;

    do
    {
        if ( ( nSocketNumber != SOCKET_0 ) &&
             ( nSocketNumber != SOCKET_1 ) )
        {
// as an invalid socket number is provided, we
// break here with error.
            break ;
        } 

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        bySCRControlReg = (UCHAR) ParStlReadReg (Extension, CONFIG_DATA_REGISTER ) ;

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , ISA_CONTROL_REGISTER ) ;
        byISAControlReg = (UCHAR) ParStlReadReg (Extension, CONFIG_DATA_REGISTER ) ;

        if ( SOCKET_1 == nSocketNumber )
        {
            bySCRControlReg |=  (UCHAR)SOCKET_1 ;
            bySCRControlReg |=  (UCHAR)PERIPHERAL_RESET_1 ;
            byISAControlReg &=  ~(UCHAR)ISA_IO_SWAP ;
        }
        else
        {
            bySCRControlReg &=  ~(UCHAR)SOCKET_1 ;
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_0 ;
        }

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , ISA_CONTROL_REGISTER ) ;
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , byISAControlReg ) ;

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

        if ( SOCKET_1 == nSocketNumber )
        {
// Wait for a few milliseconds to provide an optimal puse width
// for reset.
            ParStlWaitForMicroSeconds(1000);
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_1 ;
        }
        else
        {
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_0 ;
        }
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

        bReturnValue    =   TRUE ;
    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN 
ParStlCheckIfAtaAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( TRUE == ParStlCheckCardInsertionStatus(Extension) )
        {
// as the card insertion status is valid, its probably
// a flash
            break ;
        }
        if ( FALSE == ParStlCheckDrivePresent(Extension, atapiParams) ) 
        {
// as the ATA/ATAPI controller is not present, it cant be
// an ATA/ATAPI device
            break ;
        }
        bReturnValue = TRUE;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfAtapiDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
// return whatever ATAPI initialization module says
        bReturnValue = ParStlAtapiInitialize(Extension, atapiParams) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfAtaDevice (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
// return whatever ATA initialization module says
        bReturnValue = ParStlAtaInitialize(Extension, atapiParams) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckDrivePresent (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byOrgCylHigh, byOrgCylLow ;
    int     nCurrentDrive = 0 , i ;
    UCHAR   nDrvHdArray[]={ATAPI_MASTER, ATAPI_SLAVE};

    do
    {
        if ( atapiParams->dsDeviceState[nCurrentDrive] == DEVICE_STATE_VALID )
        {
// this means that the MMC module had detected the presence
// of an ATA/ATAPI device. So, we make use of that and break out
            bReturnValue = TRUE ;
            break ;
        }

        ParStlWriteIoPort(Extension, ATA_DRVHD_REG, nDrvHdArray[nCurrentDrive]);

//  The Atapi Fuji MO drive is found to de-assert BSY and still
//  does not respond to reg. r/w when configured as slave with no media.
//  However, after a delay, it works ok.
        if ( nCurrentDrive )
        {
            ParStlWaitForMicroSeconds ( DELAY_1SECOND ) ;
        }

// this dummy write of 0 is to zero out a possible 
// floating bus
        for ( i = 0 ; i < 16 ; i++ )
        {
            ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER, i) ;
            if ( !( ParStlReadIoPort (Extension, ATA_TASK_STAT_REG ) & ATA_ST_BUSY ) )
            {
                break ;
            }
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as the busy has been found permanently set, we check
// for the slave also
            continue;
        }

// as the drive head setup might have been performed in a busy state,
// we set it up again after busy clears.
        ParStlWriteIoPort(Extension, ATA_DRVHD_REG, nDrvHdArray[nCurrentDrive]);

        if ( ( ParStlReadIoPort(Extension, ATA_DRVHD_REG) & ATAPI_SLAVE ) != nDrvHdArray[nCurrentDrive] )
        {
            continue ;
        }

// read original contents of the cyl ATA high/low registers
        byOrgCylLow  = (UCHAR) ParStlReadIoPort(Extension, ATA_CYLLOW_REG);
        byOrgCylHigh = (UCHAR) ParStlReadIoPort(Extension, ATA_CYLHIGH_REG);

// write a test pattern in the cyl ATA high/low registers
        ParStlWriteIoPort(Extension, ATA_CYLLOW_REG, TEST_PATTERN_1);
        ParStlWriteIoPort(Extension, ATA_CYLHIGH_REG, TEST_PATTERN_2);

// read the test pattern in the cyl ATA high/low registers
        if ( ( TEST_PATTERN_1 != ParStlReadIoPort(Extension, ATA_CYLLOW_REG) ) ||\
             ( TEST_PATTERN_2 != ParStlReadIoPort(Extension, ATA_CYLHIGH_REG) ) )
        {
// as we were not able to read back the written values
// we break out here, indicating the absence of the device
            continue ;
        }

// write back original contents in the cyl ATA high/low registers
        ParStlWriteIoPort(Extension, ATA_CYLLOW_REG, byOrgCylLow);
        ParStlWriteIoPort(Extension, ATA_CYLHIGH_REG, byOrgCylHigh);
        bReturnValue = TRUE ;
        atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_VALID ;
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return bReturnValue ;
}

BOOLEAN
ParStlAtapiInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    int     nCurrentDrive   = 0, i ;
    UCHAR   byTempValue ;
    UCHAR   chAtapiIdentifyBuffer [ ATAPI_IDENTIFY_LENGTH ] ;
    do
    {
        if ( DEVICE_STATE_VALID != atapiParams->dsDeviceState[nCurrentDrive] )
        {
// the device is absent
            continue ;
        }

        if ( nCurrentDrive ) 
        {
// as it is the next drive, choose the slave
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_SLAVE);
        }
        else
        {
// choose the master
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set after master/slave, we fail
// the detection process
            continue ;
        }

// check if the ATAPI signature is present in the cyl hi/lo
// registers. If present, it is definitely an ATAPI device
        if ( ( ParStlReadIoPort(Extension, ATA_CYLLOW_REG) == ATAPI_SIGN_LOW ) &&\
             ( ParStlReadIoPort(Extension, ATA_CYLHIGH_REG) == ATAPI_SIGN_HI ) )
        {
// as ATAPI signature is present, it is ATAPI type
            bReturnValue = TRUE ;

// set this flag so that, ATA initialize will skip this
// target
            atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_ATAPI ;
// for Impact, since Ls120 engine is always present,
// issuing ATAPI_IDENTIFY is mandatory. 
            if ( !IsImpactPresent())
            {
                continue ;
            }
        }

// issue the ata nop command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATA_NOP_COMMAND) ;

        if ( FALSE == ParStlWaitForIrq(Extension) )
        {
// ATAPI devices are expected to give interrrupt on NOP command
// mandatorily.
            continue ;
        }
        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we proceed with the next
// drive
            continue ;
        }

// issue the atapi packet command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATAPI_IDENTIFY) ;

        if ( FALSE == ParStlWaitForIrq(Extension) )
        {
// ATAPI devices are expected to give interrrupt on 0xA1 command
// mandatorily.
            continue ;
        }
        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we proceed with the next
// drive
            continue ;
        }

        byTempValue = (UCHAR) ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) ;
        if ( ! ( byTempValue & ATA_ST_ERROR ) )
        {
// as the drive has passed the packet command, this is an atapi
// drive
// Wait for DRQ to be sit, as some drives are known
// to remove busy too early and set DRQ after some time.
            if ( FALSE == ParStlWaitForDrq(Extension) )
            {
// as there was no DRQ set, we proceed with the next
// drive
                continue ;
            }
            bReturnValue = TRUE ;
// as the DRQ is still asserted, quell it, as certain ATA/ATAPI-4
// spec. dictates it so
// There is a need to check the device identifier returned in the 
// ATAPI Identify cmd. to determine the presence of Ls-120.
            ParStlReceiveData ( Extension, chAtapiIdentifyBuffer , SKIP_MEMORY_ADDRESS , ATAPI_IDENTIFY_LENGTH ) ;
            for ( i = 0 ; i < ATAPI_NAME_LENGTH ; i++ )
            {
                atapiParams->szAtapiNameString[i] = chAtapiIdentifyBuffer[ ATAPI_NAME_OFFSET + i ] ;
            }

// set this flag so that, ATA initialize will skip this
// target
            atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_ATAPI ;
        }
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlAtaInitialize ( 
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byTempValue ;
    int     nCurrentDrive   = 0 ;
    do
    {
        if ( DEVICE_STATE_VALID != atapiParams->dsDeviceState[nCurrentDrive] )
        {
// atapi module has marked its presence or the device is absent
            continue ;
        }

// select the possibly present device
        if ( nCurrentDrive ) 
        {
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_SLAVE ) ;
        }
        else
        {
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER ) ;
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set after master/slave, we fail the
// detection process
            continue ;
        }

// issue the ata NOP command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATA_NOP_COMMAND) ;

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we fail the detection process
            continue ;
        }

        byTempValue = (UCHAR) ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) ;
        if ( ( byTempValue != BUS_LINES_IN_HIGH_IMPEDANCE ) &&\
             ( byTempValue & ATA_ST_ERROR ) )
        {
// as the bus is not reading 0xFF and the status register
// indicates an error, this is likely to be an ATA device
            if ( ATA_ERROR_ABORTED_COMMAND == ( (UCHAR) ParStlReadIoPort ( Extension, ATA_ERROR_REG ) & 0x0F ) )
            {
// as the error register, contains the ata aborted error 
// in response to our ATA NOP command, we conclude that
// it is ATA! as it is already known that it is not ATAPI
                bReturnValue = TRUE ;
                break;
            }
        }
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlWaitForBusyToClear (
    IN  PPDO_EXTENSION   Extension,
    IN  int                 nRegisterToWaitOn 
    ) 
{
// The default timeout increased to 10secs as Fujitsu MO is found to set
// BUSY for >5secs for 0xA1 command.
    int nMaxRetrials  = MAX_RETRIES_FOR_10_SECS ;
    BOOLEAN    bRetVal =   FALSE ;

    while ( nMaxRetrials-- )
    {
// the following service will be implemented by the caller
// the driver can use the STLMPORT service.
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
        if ( ! ( ParStlReadIoPort ( Extension, nRegisterToWaitOn ) & ATA_ST_BUSY ) )
        {
// as busy has cleared, we return clear here
            bRetVal = TRUE ;
            break ;
        }
    }
    return  bRetVal ;
}

BOOLEAN
ParStlWaitForDrq (
    IN  PPDO_EXTENSION   Extension
    ) 
{
    int nMaxRetrials  = MAX_RETRIES_FOR_5_SECS ;
    BOOLEAN    bRetVal =   FALSE ;
    while ( nMaxRetrials-- )
    {
        if ( ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) & ATA_ST_DRQ )
        {
// as busy has cleared, we return clear here
            bRetVal = TRUE ;
            break ;
        }
// the following service will be implemented by the caller
// the driver can use the STLMPORT service.
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
    }
    return  bRetVal ;
}

BOOLEAN
ParStlWaitForIrq (
    IN  PPDO_EXTENSION   Extension
    ) 
{
    int nMaxRetrials  = MAX_RETRIES_FOR_10_SECS ;
    BOOLEAN    bRetVal =   FALSE ;
    while ( nMaxRetrials-- )
    {
        if ( ParStlReadReg ( Extension, EP1284_TRANSFER_CONTROL_REG ) & XFER_IRQ_BIT )
        {
// as Irq has asserted, we return true here
            bRetVal = TRUE ;
            break ;
        }
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
    }
    return  bRetVal ;
}

VOID
ParStlSet16BitOperation (
    IN  PPDO_EXTENSION   Extension
    ) 
{
    int nModeReg ;

    nModeReg = ParStlReadReg ( Extension, EP1284_MODE_REGISTER ) ;

    if ( 0 == ( nModeReg & EP1284_ENABLE_16BIT ) )
    {
// as the bit is not already set, this needs to be set now
        ParStlWriteReg ( Extension, EP1284_MODE_REGISTER, nModeReg | EP1284_ENABLE_16BIT ) ; 
    }
}

BOOLEAN 
ParStlCheckIfEppDevice (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
// as EPPDEVs live only on EP1284 we break here
            break;
        }

        bReturnValue = ParStlCheckPersonalityForEppDevice(Extension) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckPersonalityForEppDevice (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, EP1284_PERSONALITY_REG ) ;
    if ( EPPDEV_SIGN == ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & PERSONALITY_MASK ) )
    {
// as the EPPDEV sign is found in the personality
// we break with success here
        bReturnValue   = TRUE ;
    }

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfFlash (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;

    do 
    {
        if ( !IsEp1284Present() && !IsImpactPresent() && !IsEpatPlusPresent() )
        {
// Check the sign-on version checks for the existence of Shuttle
// adapter. If nothing is found, we break here.
            break ;
        }

// Perform a ATA-16bit check just in case, it turns out to be something else
        bReturnValue = ParStlCheckFlashPersonality(Extension) ;
    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN
ParStlCheckFlashPersonality (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE ;

    if ( IsEp1284Present() )
    {
// as the personality configuration check only works for
// Ep1284, confim its presence before the actual check.
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, EP1284_PERSONALITY_REG ) ;
        if ( FLASH_SIGN == ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & FLASH_PERSONALITY_MASK ) )
        {
// as the flash sign ATA-16bit device is found in the personality
// we break with success here
            bReturnValue   = TRUE ;
        }
    }
    else
    {
// always return true, if a shuttle adapter other than ep1284 is
// identified and assume it might be flash!
        bReturnValue    =   TRUE ;
    }

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfDazzle (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   ucSignature ;

    do 
    {
        if ( !IsEp1284Present() )
        {
// Check for EP1284 presence, as Dazzle is ONLY on EP1284
// adapters. If the adapter is not EP1284, we break.
            break ;
        }

// Check whether any card insertion is detected, to eliminate
// possible flash adapters with the card in
        if ( TRUE == ParStlCheckCardInsertionStatus( Extension ) ) {
            break ;
        }

// code to read the pulled up pattern present on dazzle
// adapters.
        ParStlWriteReg( Extension, DAZ_SELECT_BLK, DAZ_BLK0 ) ;
        ucSignature = (UCHAR) ParStlReadReg( Extension, DAZ_REG1 ) ;

        if ( ( ucSignature == DAZ_CONFIGURED ) ||\
             ( ucSignature == DAZ_NOT_CONFIGURED ) ) {
            // the pulled up pattern generally found ONLY
            // on the DAZZLE adapter is found. So, we
            // conclude that it is a Dazzle adapter 
                bReturnValue = TRUE ;
        }

    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN 
ParStlCheckIfHiFD (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
        if ( FALSE == ParStlSelectAdapterSocket(Extension, SOCKET_1) )
        {
// as the socket 1 selection failed,
// we break out here.
            break ;
        }

// check for the ready status of the floppy controller,
// after clearing the reset bit of the floppy controller.

        if ( FALSE == ParStlHIFDCheckIfControllerReady(Extension) )
        {
// since the controller didnot wake up after the
// reset pin was asserted, we break here.

            break ;
        }

        if ( FALSE == ParStlHIFDCheckSMCController(Extension) )
        {
// as the SMC ID retrieval failed,
// we break out here.
            break ;
        }

        bReturnValue = TRUE ;

    }
    while ( FALSE ) ;
// Reset the socket to zero.
    ParStlSelectAdapterSocket(Extension, SOCKET_0);
    return bReturnValue ;
}

BOOLEAN
ParStlHIFDCheckIfControllerReady (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue    =   FALSE ;
    UCHAR   bySCRControlReg ;
    do
    {
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        bySCRControlReg = (UCHAR) ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
        bySCRControlReg |=  (UCHAR)PERIPHERAL_RESET_1 ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_10_MILLISEC ) ;

        ParStlWriteIoPort ( Extension, HIFD_DIGITAL_OUTPUT_REGISTER ,
                              0x00 ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_1_MILLISEC ) ;

        ParStlWriteIoPort ( Extension, HIFD_DIGITAL_OUTPUT_REGISTER ,
                              HIFD_DOR_RESET_BIT | HIFD_ENABLE_DMA_BIT ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_10_MILLISEC ) ;

        if ( HIFD_CONTROLLER_READY_STATUS == ParStlReadIoPort ( Extension, HIFD_MAIN_STATUS_REGISTER ) )
        {
            bReturnValue = TRUE ;
        }

        bySCRControlReg     &= ~(UCHAR)PERIPHERAL_RESET_1 ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlHIFDCheckSMCController (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;
    do
    {
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_COMMAND_TO_CONTROLLER ) ;
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_COMMAND_TO_CONTROLLER ) ;
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_CTL_REG_0D ) ;
        if ( SMC_DEVICE_ID == ParStlReadIoPort ( Extension, HIFD_STATUS_REGISTER_B ) )
        {
            bReturnValue = TRUE ;
            ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_CTL_REG_03 ) ;
            ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_B , SMC_ENABLE_MODE2 ) ;        
        }
        ParStlWriteReg ( Extension, HIFD_STATUS_REGISTER_A , HIFD_TERMINATE_SEQUENCE ) ;

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

STL_DEVICE_TYPE
ParStlGetImpactDeviceType (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams,
    IN  int                 nPreferredDeviceType
    )
{
    IMPACT_DEVICE_TYPE      idtImpactDeviceType ;
    STL_DEVICE_TYPE         dtDeviceType = DEVICE_TYPE_NONE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACT_PERSONALITY_REG ) ;
    idtImpactDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) >> 4 ;

    switch ( idtImpactDeviceType )
    {
        case IMPACT_DEVICE_TYPE_ATA_ATAPI:

            // set the 16 bit mode of the adapter
            ParStlSet16BitOperation(Extension) ;

            if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension,atapiParams))
            {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
                if (TRUE == ParStlCheckIfAtapiDevice(Extension,atapiParams))
                {
// atapi identified
// Check for Impact LS-120 device
                    if ( TRUE == ParStlCheckIfImpactLS120(Extension, atapiParams))
                    {
                        dtDeviceType |= DEVICE_TYPE_LS120_BIT ;
                        break ;
                    }
                    dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                    break ;
                }

                if (TRUE == ParStlCheckIfAtaDevice(Extension, atapiParams))
                {
// ata identified
                    dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                    break;
                }
            }
            break ;

        case IMPACT_DEVICE_TYPE_CF:
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break ;

        case IMPACT_DEVICE_TYPE_PCMCIA_CF:
            dtDeviceType |= DEVICE_TYPE_PCMCIA_CF_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SSFDC:
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_MMC:
            dtDeviceType |= DEVICE_TYPE_MMC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_HIFD:
            dtDeviceType |= DEVICE_TYPE_HIFD_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SOUND:
            dtDeviceType |= DEVICE_TYPE_SOUND_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_FLP_TAPE_DSK:
            dtDeviceType |= DEVICE_TYPE_FLP_TAPE_DSK_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT:
            dtDeviceType |= DEVICE_TYPE_ATA_ATAPI_8BIT_BIT ;
            break;

        default:
            break;
    }

    return dtDeviceType & nPreferredDeviceType ;
}

STL_DEVICE_TYPE
ParStlGetImpactSDeviceType (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams,
    IN  int                 nPreferredDeviceType
    )
{
    IMPACT_DEVICE_TYPE      idtImpactDeviceType ;
    IMPACT_DEVICE_TYPE      idtImpactSDeviceType ;
    STL_DEVICE_TYPE         dtDeviceType = DEVICE_TYPE_NONE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACT_PERSONALITY_REG ) ;
    idtImpactDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) >> 4 ;

    switch ( idtImpactDeviceType )
    {
        case IMPACT_DEVICE_TYPE_ATA_ATAPI:

            // set the 16 bit mode of the adapter
            ParStlSet16BitOperation(Extension) ;

            if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension,atapiParams))
            {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
                if (TRUE == ParStlCheckIfAtapiDevice(Extension,atapiParams))
                {
// atapi identified
                    dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                    break ;
                }

                if (TRUE == ParStlCheckIfAtaDevice(Extension,atapiParams))
                {
// ata identified
                    dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                    break;
                }
            }
            break ;

        case IMPACT_DEVICE_TYPE_CF:
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break ;

        case IMPACT_DEVICE_TYPE_PCMCIA_CF:
            dtDeviceType |= DEVICE_TYPE_PCMCIA_CF_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SSFDC:
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_MMC:
            dtDeviceType |= DEVICE_TYPE_MMC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_HIFD:
            dtDeviceType |= DEVICE_TYPE_HIFD_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SOUND:
            dtDeviceType |= DEVICE_TYPE_SOUND_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_FLP_TAPE_DSK:
            dtDeviceType |= DEVICE_TYPE_FLP_TAPE_DSK_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT:
            dtDeviceType |= DEVICE_TYPE_ATA_ATAPI_8BIT_BIT ;
            break;

        case IMPACTS_EXT_PERSONALITY_PRESENT:
            ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACTS_EXT_PERSONALITY_XREG ) ;
            idtImpactSDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
            dtDeviceType = DEVICE_TYPE_EXT_HWDETECT ;
            dtDeviceType |= idtImpactSDeviceType ;
            break ;

        default:
            break;
    }

    return dtDeviceType & nPreferredDeviceType ;
}

BOOLEAN 
ParStlCheckIfLS120 (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == ParStlSelectAdapterSocket(Extension, SOCKET_1) )
        {
// as the socket 1 selection failed,
// we break out here.
            break ;
        }

// check for engine version.                    

        if ( LS120_ENGINE_VERSION == ParStlReadIoPort( Extension, LS120_ENGINE_VERSION_REGISTER ) )
        {
// if the ls120 engine version is correct, we have
// found LS120.

            bReturnValue    =   TRUE ;
        }

// Reset the socket to zero.
        ParStlSelectAdapterSocket ( Extension, SOCKET_0 ) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfImpactLS120 (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE ;
    BOOLEAN bLs120NameFound= TRUE ;
    char chLs120Name[] = "HU DlFpoyp";
    char *pszAtapiName = atapiParams->szAtapiNameString ;
    int  i , nMemoryOnBoard ;

    do
    {
        for ( i = 0 ;i < sizeof(chLs120Name)-1 ; i++ )
        {
            if ( pszAtapiName[i] != chLs120Name[i] )
            {
                bLs120NameFound = FALSE ;
                break ;
            }
        }
        if ( TRUE != bLs120NameFound )
        {
// as LS-120 name string is not found, we conclude that it is
// not LS-120
            break ;
        }
        nMemoryOnBoard =  ParStlGetMemorySize(Extension) ;
        if ( ( !IsShtlError ( nMemoryOnBoard ) ) && \
             ( nMemoryOnBoard ) )
        {
// there is memory on-board.
// hence, we return ls120 here
            bReturnValue = TRUE ;
            break ;
        }
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfMMC (
    IN  PPDO_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
        if ( FALSE == IsEpatPlusPresent() )
        {
// as mmc device can exist only on EPAT Plus adapter only
// we break out of here
            break;
        }
        if ( TRUE == ParStlCheckIfAtaAtapiDevice (Extension,atapiParams) )
        {
// as an ATA/ATAPI device is probably present,
// we break out of here
            break;
        }
        bReturnValue = ParStlIsMMCEnginePresent(Extension) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlIsMMCEnginePresent(
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
// check if the ATAPI signature is present in the cyl hi/lo
// registers. If present, it is definitely an ATAPI device
        if ( ( ParStlReadIoPort(Extension, CYLLOW_REG) == ATAPI_SIGN_LOW ) &&\
             ( ParStlReadIoPort(Extension, CYLHIGH_REG) == ATAPI_SIGN_HI ) )
        {
// as ATAPI signature is present, it cant be MMC
            break ;
        }

// write a zero pattern ( which will be a NOP for ATA/ATAPI devices ) 
// in the block size / possible ATA/ATAPI command register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_1);
        if ( MMC_TEST_PATTERN_1 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as the written value is not available, it means device present
// has responded to the written value, in a way different from
// how an MMC would have.
            break ;
        }

// write a test pattern in the freq register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_FREQ_SELECT_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_2);

// write another in the block size register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_3);

        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_FREQ_SELECT_REG);
        if ( MMC_TEST_PATTERN_2 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as we were not able to read back the written value
// we quit here
            break;
        }

        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        if ( MMC_TEST_PATTERN_3 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as we were not able to read back the written value
// we quit here
            break;
        }
// as all tests have passed, engine presence is confirmed
// here
        bReturnValue = TRUE ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfScsiDevice (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEpstPresent() )
        {
// as SCSI devices live only on EPST we break here
            break;
        }

        bReturnValue = TRUE ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN 
ParStlCheckIfSSFDC (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
// SSFDC lives on EP1284 alone, other than impact
// which is already taken care
            break;
        }

//check to see if the loop back of the EPCS and EPDO pins
//of the INDEX 00 register read the same. If so, it is 
//SSFDC board characteristic
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , 0x00 ) ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x10 ) ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x12 ) ;
        if ( 0x1A == ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) )
        {
            ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x10 ) ;
            if ( ! ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & 0x08 ) )
            {
//as they are equal, SSFDC present
                bReturnValue    =   TRUE ;
                break ;
            }
        }

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

VOID
ParStlAssertIdleState (
    IN  PPDO_EXTENSION   Extension
    )
{
    PUCHAR  CurrentPort, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentControl = CurrentPort + 2;

// place op-code for idle state in port base
    P5WritePortUchar ( CurrentPort, (UCHAR) 0x00 ) ;
    KeStallExecutionProcessor( Delay );

// bring down DCR_INIT and DCR_STROBE
    P5WritePortUchar ( CurrentControl, (UCHAR) STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );

// lift DCR_INIT and DCR_STROBE to high
    P5WritePortUchar ( CurrentControl, (UCHAR) STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );
}

BOOLEAN
ParStlCheckAvisionScannerPresence(
        IN PPDO_EXTENSION Extension
    )
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   data;

    do {

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x08 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x08 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) != 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x02 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x02 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) != 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        bReturnValue = TRUE ;

    } while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckUMAXScannerPresence(
    IN PPDO_EXTENSION    Extension
    )
{
    UCHAR   commandPacket_[6] = {0x55,0xaa,0,0,0,0} ;
    PUCHAR  commandPacket ;
    USHORT  status;
    UCHAR   idx;
    PUCHAR  saveCommandPacket;
    ULONG   dataLength;

    ParStlWriteReg ( Extension, CONTROLPORT, 0 ) ;  // scannner reset
    KeStallExecutionProcessor ( 2000 ) ;            // 2 m.secs delay
    ParStlWriteReg ( Extension, CONTROLPORT, 0x0C ) ;

    commandPacket = commandPacket_ ;
    saveCommandPacket = commandPacket;

    if ( TRUE == ParStlSetEPPMode(Extension) ) {

        commandPacket+=2;
        dataLength = *(ULONG*)commandPacket;
        dataLength &= 0xffffff; //data bytes ordering (msb to lsb) will
                                // wrong .What we need here is whether the
                                // dataLength is 0 or not.

        commandPacket = saveCommandPacket;

        //Command phase

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700) != 0){
            return FALSE;      //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;     //TIMEOUT_ERROR);
        }

        for(idx=0; idx<= 6 ;idx++){

            if(status & 0x800){
                break;
            }

            status = ParStlEPPRead(Extension);
        }

        if(idx == 7){

            status = (status & 0xf800)  | 0x100; 
            if ( status & 0x700 )
                return FALSE;
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;          //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *commandPacket);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        //Response phase

        status    =    ParStlEPPRead(Extension);
        commandPacket = saveCommandPacket;

        if((status & 0x700) == 0){

            if((commandPacket[5] == 0xc2)&& (dataLength == 0)){

                status = ParStlEPPRead(Extension);

                if((status & 0x0700) != 0){
                    return FALSE;  //TIMEOUT_ERROR);
                }
            }
        }
    
        return  TRUE;
    }
    return FALSE;
}

BOOLEAN
ParStlSetEPPMode(
    IN PPDO_EXTENSION    Extension
    )
{
    UCHAR   idx;
    BOOLEAN timeout = TRUE ;

    ParStlWriteReg( Extension, CONTROLPORT, 0x0C ) ;
    ParStlWriteReg( Extension, DATAPORT, 0x40 ) ;
    ParStlWriteReg( Extension, CONTROLPORT, 0x06 ) ;

    for(idx=0; idx<10; idx++){

        if((ParStlReadReg(Extension, STATUSPORT) & 0x78) == 0x38){

            timeout = FALSE;
            break;

        }

    }

    if(timeout == FALSE){

        ParStlWriteReg( Extension, CONTROLPORT,0x7 );
        timeout = TRUE;

        for(idx=0; idx<10; idx++){

            if((ParStlReadReg( Extension, STATUSPORT) & 0x78) == 0x38){
                timeout = FALSE;
                break;
            }

        }

        if(timeout == FALSE){

            ParStlWriteReg( Extension, CONTROLPORT,0x4 ) ;
            timeout = TRUE;

            for(idx=0; idx<10; idx++){

                if((ParStlReadReg( Extension, STATUSPORT) & 0xf8) == 0xf8){
                    timeout = FALSE;
                    break;
                }

            }

            if(timeout == FALSE){

                timeout = TRUE;

                ParStlWriteReg( Extension, CONTROLPORT, 0x5 );

                for(idx=0; idx<10; idx++){

                    if( ParStlReadReg( Extension, CONTROLPORT ) == 0x5){

                        timeout = FALSE;
                        break;

                    }
                }

                if(timeout == FALSE){

                    ParStlWriteReg( Extension, CONTROLPORT, 0x84) ;
                    return TRUE ;

                } // final check

            } // third check

        } // second check

    } // first check

    return(FALSE);
}

USHORT
ParStlEPPWrite(
    IN PPDO_EXTENSION    Extension,
    IN UCHAR                value
    )
{
    UCHAR   idx;
    USHORT  statusData = 0;
    BOOLEAN timeout;

    timeout = TRUE;

    for(idx=0; idx<10; idx++){

        if( !( (statusData = (USHORT)ParStlReadReg( Extension, STATUSPORT)) & BUSY)){
            timeout = FALSE;
            break;
        }

    }

    if(timeout == TRUE){

        return(((statusData<<8) & 0xf800)|0x100);

    }

    ParStlWriteReg( Extension, EPPDATA0PORT,value );
    return(((statusData & 0xf8) << 8)|value);
}

USHORT
ParStlEPPRead(
    IN PPDO_EXTENSION Extension
    )
{
    UCHAR   idx;
    UCHAR   eppData;
    USHORT  statusData = 0;
    BOOLEAN timeout    = TRUE ;

    for(idx=0; idx<10; idx++){

        if(!( (statusData = (USHORT)ParStlReadReg( Extension, STATUSPORT)) & PE)){
            timeout = FALSE;
            break;
        }

    }

    if(timeout == TRUE){

        return(((statusData<<8) & 0xf800)|0x100);

    }

    eppData = (UCHAR)ParStlReadReg( Extension, EPPDATA0PORT) ;
    return(((statusData & 0x00f8)<<8) | eppData );
}

int  __cdecl
ParStlReadReg (
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg
    )
{
    UCHAR   byReadNibble ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// select the register to read
    P5WritePortUchar ( CurrentPort, (UCHAR)reg ) ;
    KeStallExecutionProcessor( Delay );

// issue nibble ctl signals to read
    P5WritePortUchar ( CurrentControl, STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_LO ) ;
    KeStallExecutionProcessor( Delay );

// read first nibble
    byReadNibble = P5ReadPortUchar (CurrentStatus);
    KeStallExecutionProcessor( Delay );
    byReadNibble >>= 4 ;

// issue nibble ctl signals to read
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );

// read next nibble
    byReadNibble |= ( P5ReadPortUchar ( CurrentStatus ) & 0xF0 ) ;

    return (int)byReadNibble ;
}

int  __cdecl
ParStlWriteReg ( 
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg, 
    IN  int                 databyte 
    )
{
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// select the register to write
    P5WritePortUchar ( CurrentPort, (UCHAR)( reg | 0x60 ) ) ;
    KeStallExecutionProcessor( Delay );

// write to printer ctl port
    P5WritePortUchar ( CurrentControl, STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );

// write the requested data
    P5WritePortUchar ( CurrentPort, (UCHAR)databyte ) ;
    KeStallExecutionProcessor( Delay );

// write to printer ctl port
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );

    return SHTL_NO_ERROR ;
}

int __cdecl
ParStlReceiveData (
    IN  PPDO_EXTENSION   Extension,
    IN  VOID                *hostBufferPointer,
    IN  long                shuttleMemoryAddress,
    IN  unsigned            count
    )
{
    PCHAR   pchDataBuffer = (PCHAR) hostBufferPointer ;
    unsigned int i = 0 ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    UNREFERENCED_PARAMETER( shuttleMemoryAddress );

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// set the block address register to ATA/ATAPI data register,
// as this function is currently used ONLY for ATA/ATAPI devices
// ATA/ATAPI data register 0x1F0 corresponds to 0x18 value
    ParStlWriteReg ( Extension, EP1284_BLK_ADDR_REGISTER, 0x18 ) ;

// do the nibble block read sequence
// write the nibble block read op-code
    P5WritePortUchar ( CurrentPort, OP_NIBBLE_BLOCK_READ ) ;
    KeStallExecutionProcessor( Delay );

// set control ports to correct signals.
    P5WritePortUchar ( CurrentControl, STB_INIT_AFXT_LO ) ;
    KeStallExecutionProcessor( Delay );

// set data port to 0xFF
    P5WritePortUchar ( CurrentPort, 0xFF ) ;
    KeStallExecutionProcessor( Delay );
    P5WritePortUchar ( CurrentControl, INIT_AFXT_HIGH ) ;
    KeStallExecutionProcessor( Delay );

    do
    {
// low nibble is available in status after
// toggling sequences as in EP1284 manual
        P5WritePortUchar ( CurrentControl, AFXT_LO_STB_HI ) ;
        KeStallExecutionProcessor( Delay );
        pchDataBuffer[i] = P5ReadPortUchar( CurrentStatus ) >> 4 ;
        KeStallExecutionProcessor( Delay );

// high nibble is available in status after
// toggling sequences as in EP1284 manual
        P5WritePortUchar ( CurrentControl, AFXT_HI_STB_HI ) ;
        KeStallExecutionProcessor( Delay );

        pchDataBuffer[i++] |= ( P5ReadPortUchar ( CurrentStatus ) & 0xF0 ) ;
        KeStallExecutionProcessor( Delay );
        if ( count - 1 == i )
        {
// to read the last byte 
            P5WritePortUchar ( CurrentPort, 0xFD ) ;
            KeStallExecutionProcessor( Delay );
        }

        P5WritePortUchar ( CurrentControl, AFXT_LO_STB_LO ) ;
        KeStallExecutionProcessor( Delay );

        pchDataBuffer[i] = P5ReadPortUchar ( CurrentStatus ) >> 4 ;
        KeStallExecutionProcessor( Delay );

        P5WritePortUchar ( CurrentControl, AFXT_HI_STB_LO ) ;
        KeStallExecutionProcessor( Delay );
        pchDataBuffer[i++] |= ( P5ReadPortUchar ( CurrentStatus ) & 0xF0 ) ;
        KeStallExecutionProcessor( Delay );
    }
    while ( i <= count ) ;

// clean up
    P5WritePortUchar ( CurrentPort, 0x00 ) ;
    KeStallExecutionProcessor( Delay );

// done
    return SHTL_NO_ERROR ;
}

int  __cdecl
ParStlReadIoPort (
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg 
    )
{
    switch ( reg )
    {
    case 0x08 :
        reg = 0x16 ;
        break ;
    case 0x09 :
        reg = 0x17 ;
        break ;
    default :
        reg |= 0x18 ;
        break;
    }
    return ParStlReadReg ( Extension, reg ) ;
}

int  __cdecl
ParStlWriteIoPort (
    IN  PPDO_EXTENSION   Extension,
    IN  unsigned            reg,
    IN  int                 databyte
    )
{
    switch ( reg )
    {
    case 0x08 :
        reg = 0x16 ;
        break ;
    case 0x09 :
        reg = 0x17 ;
        break ;
    default :
        reg |= 0x18 ;
        break;
    }
    return ParStlWriteReg ( Extension, reg, databyte ) ;
}

int  __cdecl
ParStlGetMemorySize (
    IN  PPDO_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;
    UCHAR      byTempValue ;
    do
    {
// Issue reset through control register
// first try on DRAM
        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|SELECT_DRAM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// write to the first location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_1 ) ;
// write to the next location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_2 ) ;

        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|SELECT_DRAM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// read from the first and next location in the memory
        if ( ( TEST_PATTERN_1 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) &&\
             ( TEST_PATTERN_2 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) )
        {
            bReturnValue = TRUE ;
            break ;
        }
        
        if ( !IsImpactPresent () )
        {
// as only DRAM can be present on non-impact adapters
            break ;
        }
// Issue reset through control register
// and next try on SRAM
        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|RESET_PTR ;
        byTempValue &= SELECT_SRAM ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// write to the first location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_1 ) ;
// write to the next location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_2 ) ;

        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// read from the first location in the memory
        if ( ( TEST_PATTERN_1 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) &&\
             ( TEST_PATTERN_2 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) )
        {
            bReturnValue = TRUE ;
            break ;
        }
    }
    while ( FALSE ) ;
    return bReturnValue ;
}
// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\swecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 2000

Module Name:

    swecp.c

Abstract:

    Enhanced Capabilities Port (ECP)
    
    This module contains the code to perform all ECP related tasks (including
    ECP Software and ECP Hardware modes.)

Author:

    Tim Wells (WESTTEK) - April 16, 1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    
    NTSTATUS Status;
    
    //
    // Has a client driver or user mode app told us to avoid this mode 
    //   for this device via IOCTL_PAR_GET_DEVICE_CAPS?
    //
    if( Pdx->BadProtocolModes & ECP_SW ) {
        return FALSE;
    }

    //
    // Have we previously checked for and found that this mode is
    //   supported with this device?
    //
    if( Pdx->ProtocolModesSupported & ECP_SW ) {
        return TRUE;
    }

    //
    // Determine if the mode is supported by trying to negotiate the
    //   device the device into the requested mode.
    //

    // RMT - DVDF - 000709 - the following 2 lines really handle two distinct operations
    //   each: (1) negotiating the peripheral into ECP, and (2) setting/clearing our
    //   driver state machine. Consider breaking these operations out into two
    //   distinct functions each.
    Status = ParEnterEcpSwMode( Pdx, FALSE );
    ParTerminateEcpMode( Pdx );

    if( NT_SUCCESS(Status) ) {
        Pdx->ProtocolModesSupported |= ECP_SW;
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOLEAN
ParIsEcpSwReadSupported(
    IN  PPDO_EXTENSION  Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the read direction (need to be able to float the data register
    drivers in order to do byte wide reads) by trying negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    
    NTSTATUS Status;
    
    if( !(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT) ) {

        // Only use ECP Software in the reverse direction if an
        // ECR is present or we know that we can put the data register into Byte mode.

        return FALSE;
    }
        
    if (Pdx->BadProtocolModes & ECP_SW)
        return FALSE;

    if (Pdx->ProtocolModesSupported & ECP_SW)
        return TRUE;

    // Must use SWECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEcpSwMode (Pdx, FALSE);
    ParTerminateEcpMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
    
        Pdx->ProtocolModesSupported |= ECP_SW;
        return TRUE;
    }
   
    return FALSE;    
}

NTSTATUS
ParEnterEcpSwMode(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    ECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS  status = STATUS_SUCCESS;

    if( Pdx->ModeSafety == SAFE_MODE ) {
        if( DeviceIdRequest ) {
            status = IeeeEnter1284Mode( Pdx, ECP_EXTENSIBILITY | DEVICE_ID_REQ );
        } else {
            status = IeeeEnter1284Mode( Pdx, ECP_EXTENSIBILITY );
        }
    } else {
        DD((PCE)Pdx,DDT,"ParEnterEcpSwMode: In UNSAFE_MODE\n");
        Pdx->Connected = TRUE;
    }
    
    if( NT_SUCCESS(status) ) {
        status = ParEcpSetupPhase( Pdx );
    }
      
    return status; 
}    

VOID 
ParCleanupSwEcpPort(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

   Cleans up prior to a normal termination from ECP mode.  Puts the
   port HW back into Compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    PUCHAR  Controller;
    UCHAR   dcr;           // Contents of DCR

    Controller = Pdx->Controller;

    //----------------------------------------------------------------------
    // Set data bus for output
    //----------------------------------------------------------------------
    dcr = P5ReadPortUchar(Controller + OFFSET_DCR);               // Get content of DCR
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    P5WritePortUchar( Controller + OFFSET_DCR, dcr );
    return;
}


VOID
ParTerminateEcpMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    ParCleanupSwEcpPort(Pdx);
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Pdx);
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateEcpMode: In UNSAFE_MODE\n");
        Pdx->Connected = FALSE;
    }
    return;    
}

NTSTATUS
ParEcpSetAddress(
    IN  PPDO_EXTENSION   Pdx,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets the ECP Address.
    
Arguments:

    Pdx           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    PUCHAR          DCRController;
    UCHAR           dcr;
    
    DD((PCE)Pdx,DDT,"ParEcpSetAddress: Start: Channel [%x]\n", Address);
    Controller = Pdx->Controller;
    DCRController = Controller + OFFSET_DCR;
    
    //
    // Event 34
    //
    // HostAck low indicates a command byte
    Pdx->CurrentEvent = 34;
    dcr = P5ReadPortUchar(DCRController);
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
    P5WritePortUchar(DCRController, dcr);
    // Place the channel address on the bus
    // Bit 7 of the byte sent must be 1 to indicate that this is an address
    // instead of run length count.
    //
    P5WritePortUchar(Controller + DATA_OFFSET, (UCHAR)(Address | 0x80));
    
    //
    // Event 35
    //
    // Start handshake by dropping HostClk
    Pdx->CurrentEvent = 35;
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE );
    P5WritePortUchar(DCRController, dcr);


    // =============== Periph State 36     ===============8
    // PeriphAck/PtrBusy        = High (signals state 36)
    // PeriphClk/PtrClk         = Don't Care
    // nAckReverse/AckDataReq   = Don't Care
    // XFlag                    = Don't Care
    // nPeriphReq/nDataAvail    = Don't Care
    Pdx->CurrentEvent = 35;
    if (!CHECK_DSR(Controller,
                  ACTIVE, DONT_CARE, DONT_CARE,
                  DONT_CARE, DONT_CARE,
                  DEFAULT_RECEIVE_TIMEOUT))
    {
	    DD((PCE)Pdx,DDE,"ECP::SendChannelAddress:State 36 Failed: Controller %x\n", Controller);
        // Make sure both HostAck and HostClk are high before leaving
        // HostClk should be high in forward transfer except when handshaking
        // HostAck should be high to indicate that what follows is data (not commands)
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar(DCRController, dcr);
        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 37
    //
    // Finish handshake by raising HostClk
    // HostClk is high when it's 0
    //
    Pdx->CurrentEvent = 37;
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE );
    P5WritePortUchar(DCRController, dcr);
            
    // =============== Periph State 32     ===============8
    // PeriphAck/PtrBusy        = Low (signals state 32)
    // PeriphClk/PtrClk         = Don't Care
    // nAckReverse/AckDataReq   = Don't Care
    // XFlag                    = Don't Care
    // nPeriphReq/nDataAvail    = Don't Care
    Pdx->CurrentEvent = 32;
    if (!CHECK_DSR(Controller,
                  INACTIVE, DONT_CARE, DONT_CARE,
                  DONT_CARE, DONT_CARE,
                  DEFAULT_RECEIVE_TIMEOUT))
    {
	    DD((PCE)Pdx,DDE,"ECP::SendChannelAddress:State 32 Failed: Controller %x\n", Controller);
        // Make sure both HostAck and HostClk are high before leaving
        // HostClk should be high in forward transfer except when handshaking
        // HostAck should be high to indicate that what follows is data (not commands)
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        P5WritePortUchar(DCRController, dcr);
        return STATUS_IO_DEVICE_ERROR;
    }
    
    // Make sure both HostAck and HostClk are high before leaving
    // HostClk should be high in forward transfer except when handshaking
    // HostAck should be high to indicate that what follows is data (not commands)
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
    P5WritePortUchar(DCRController, dcr);

    DD((PCE)Pdx,DDT,"ParEcpSetAddress, Exit [%d]\n", NT_SUCCESS(STATUS_SUCCESS));
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpSwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the ECP protocol under software
    control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          pBuffer;
    LARGE_INTEGER   Timeout;
    LARGE_INTEGER   StartWrite;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    ULONG           i = 0;

    Controller = Pdx->Controller;
    pBuffer    = Buffer;

    Status = ParTestEcpWrite(Pdx);

    if( !NT_SUCCESS(Status) ) {
        P5SetPhase( Pdx, PHASE_UNKNOWN );                     
        Pdx->Connected = FALSE;                                
        DD((PCE)Pdx,DDE,"ParEcpSwWrite: Invalid Entry State\n");
        goto ParEcpSwWrite_ExitLabel;
    }

    Wait.QuadPart = DEFAULT_RECEIVE_TIMEOUT * 10 * 1000 + KeQueryTimeIncrement();
    
    Timeout.QuadPart  = Pdx->AbsoluteOneSecond.QuadPart * Pdx->TimerStart;
    
    KeQueryTickCount(&StartWrite);
    
    dcr = GetControl (Controller);
    
    // clear direction bit - enable output
    dcr &= ~(DCR_DIRECTION);
    StoreControl(Controller, dcr);
    KeStallExecutionProcessor(1);

    for (i = 0; i < BufferSize; i++) {

        //
        // Event 34
        //
        Pdx->CurrentEvent = 34;
        P5WritePortUchar(Controller + DATA_OFFSET, *pBuffer++);
    
        //
        // Event 35
        //
        Pdx->CurrentEvent = 35;
        dcr &= ~DCR_AUTOFEED;
        dcr |= DCR_STROBE;
        StoreControl (Controller, dcr);
            
        //
        // Waiting for Event 36
        //
        Pdx->CurrentEvent = 36;
        while (TRUE) {

            KeQueryTickCount(&End);

            dsr = GetStatus(Controller);
            if (!(dsr & DSR_NOT_BUSY)) {
                break;
            }

            if ((End.QuadPart - StartWrite.QuadPart) * 
                    KeQueryTimeIncrement() > Timeout.QuadPart) {

                dsr = GetStatus(Controller);
                if (!(dsr & DSR_NOT_BUSY)) {
                    break;
                }
                //
                // Return the device to Idle.
                //
                dcr &= ~(DCR_STROBE);
                StoreControl (Controller, dcr);
            
                *BytesTransferred = i;
                Pdx->log.SwEcpWriteCount += *BytesTransferred;
                return STATUS_DEVICE_BUSY;
            }
        }
        
        //
        // Event 37
        //
        Pdx->CurrentEvent = 37;
        dcr &= ~DCR_STROBE;
        StoreControl (Controller, dcr);
            
        //
        // Waiting for Event 32
        //
        Pdx->CurrentEvent = 32;
        KeQueryTickCount(&Start);
        while (TRUE) {

            KeQueryTickCount(&End);

            dsr = GetStatus(Controller);
            if (dsr & DSR_NOT_BUSY) {
                break;
            }

            if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
                Wait.QuadPart) {

                dsr = GetStatus(Controller);
                if (dsr & DSR_NOT_BUSY) {
                    break;
                }
                #if DVRH_BUS_RESET_ON_ERROR
                    BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
                #endif
                *BytesTransferred = i;
                Pdx->log.SwEcpWriteCount += *BytesTransferred;
                return STATUS_IO_DEVICE_ERROR;
            }
        }
    }

ParEcpSwWrite_ExitLabel:

    *BytesTransferred = i;
    Pdx->log.SwEcpWriteCount += *BytesTransferred;

    return Status;

}

NTSTATUS
ParEcpSwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 ECP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          pBuffer;
    USHORT          usTime;
    UCHAR           dcr;
    ULONG           i;
    UCHAR           ecr = 0;
    
    Controller = Pdx->Controller;
    pBuffer    = Buffer;

    dcr = GetControl (Controller);
    
    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    //
    // Put ECR into PS/2 mode and float the drivers.
    //
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        // Save off the ECR register 
        ecr = P5ReadPortUchar(Controller + ECR_OFFSET);
    }
        
    dcr |= DCR_DIRECTION;
    StoreControl (Controller, dcr);
    KeStallExecutionProcessor(1);
    
    for (i = 0; i < BufferSize; i++) {

        // dvtw - READ TIMEOUTS
        //
        // If it is the first byte then give it more time
        //
        if (!(GetStatus (Controller) & DSR_NOT_FAULT) || i == 0) {
        
            usTime = DEFAULT_RECEIVE_TIMEOUT;
            
        } else {
        
            usTime = IEEE_MAXTIME_TL;
        }        
        
        // *************** State 43 Reverse Phase ***************8
        // PeriphAck/PtrBusy        = DONT CARE
        // PeriphClk/PtrClk         = LOW ( State 43 )
        // nAckReverse/AckDataReq   = LOW 
        // XFlag                    = HIGH
        // nPeriphReq/nDataAvail    = DONT CARE
        
        Pdx->CurrentEvent = 43;
        if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, INACTIVE, ACTIVE, DONT_CARE,
                      usTime)) {
                  
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            
            dcr &= ~DCR_DIRECTION;
            StoreControl (Controller, dcr);
                
            // restore ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }
                
            *BytesTransferred = i;
            Pdx->log.SwEcpReadCount += *BytesTransferred;                
            return STATUS_IO_DEVICE_ERROR;
    
        }

        // *************** State 44 Setup Phase ***************8
        //  DIR                     = DONT CARE
        //  IRQEN                   = DONT CARE
        //  1284/SelectIn           = DONT CARE
        //  nReverseReq/**(ECP only)= DONT CARE
        //  HostAck/HostBusy        = HIGH ( State 44 )
        //  HostClk/nStrobe         = DONT CARE
        //
        Pdx->CurrentEvent = 44;
        dcr = P5ReadPortUchar(Controller + OFFSET_DCR);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE);
        P5WritePortUchar(Controller + OFFSET_DCR, dcr);

        // *************** State 45 Reverse Phase ***************8
        // PeriphAck/PtrBusy        = DONT CARE
        // PeriphClk/PtrClk         = HIGH ( State 45 )
        // nAckReverse/AckDataReq   = LOW 
        // XFlag                    = HIGH
        // nPeriphReq/nDataAvail    = DONT CARE
        Pdx->CurrentEvent = 45;
        if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, INACTIVE, ACTIVE, DONT_CARE,
                      IEEE_MAXTIME_TL)) {
                  
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            
            dcr &= ~DCR_DIRECTION;
            StoreControl (Controller, dcr);
                
            // restore ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }
                
            *BytesTransferred = i;
            Pdx->log.SwEcpReadCount += *BytesTransferred;                
            return STATUS_IO_DEVICE_ERROR;
    
        }

        //
        // Read the data
        //
        *pBuffer = P5ReadPortUchar (Controller + DATA_OFFSET);
        pBuffer++;
        
        // *************** State 46 Setup Phase ***************8
        //  DIR                     = DONT CARE
        //  IRQEN                   = DONT CARE
        //  1284/SelectIn           = DONT CARE
        //  nReverseReq/**(ECP only)= DONT CARE
        //  HostAck/HostBusy        = LOW ( State 46 )
        //  HostClk/nStrobe         = DONT CARE
        //
        Pdx->CurrentEvent = 46;
        dcr = P5ReadPortUchar(Controller + OFFSET_DCR);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE);
        P5WritePortUchar(Controller + OFFSET_DCR, dcr);

    }
    
    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
    
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);
    
    // restore ecr register
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        P5WritePortUchar(Controller + ECR_OFFSET, ecr);
    }

    *BytesTransferred = i;
    Pdx->log.SwEcpReadCount += *BytesTransferred;                
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpForwardToReverse(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine reverses the channel (ECP).

Arguments:

    Pdx  - Supplies the device extension.

--*/

{
    PUCHAR          Controller;
    LARGE_INTEGER   Wait35ms;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    UCHAR           ecr;
    
    Controller = Pdx->Controller;

    Wait35ms.QuadPart = 10*35*1000 + KeQueryTimeIncrement();
    
    dcr = GetControl (Controller);
    
    //
    // Put ECR into PS/2 mode to flush the FIFO.
    //

    // Save off the ECR register 

    // Note: Don't worry about checking to see if it's
    // safe to touch the ecr since we've already checked 
    // that before we allowed this mode to be activated.
    ecr = P5ReadPortUchar(Controller + ECR_OFFSET);

    //
    // Event 38
    //
    Pdx->CurrentEvent = 38;
    dcr |= DCR_AUTOFEED;
    StoreControl (Controller, dcr);
    KeStallExecutionProcessor(1);
    
    //
    // Event  39
    //
    Pdx->CurrentEvent = 39;
    dcr &= ~DCR_NOT_INIT;
    StoreControl (Controller, dcr);
    
    //
    // Wait for Event 40
    //
    Pdx->CurrentEvent = 40;
    KeQueryTickCount(&Start);
    while (TRUE) {

        KeQueryTickCount(&End);

        dsr = GetStatus(Controller);
        if (!(dsr & DSR_PERROR)) {
            break;
        }

        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait35ms.QuadPart) {

            dsr = GetStatus(Controller);
            if (!(dsr & DSR_PERROR)) {
                break;
            }
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
#endif
            // restore the ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }
            
            DD((PCE)Pdx,DDE,"ParEcpForwardToReverse: Failed to get State 40\n");
            return STATUS_IO_DEVICE_ERROR;
        }
    }
        
    // restore the ecr register
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        P5WritePortUchar(Controller + ECR_OFFSET, ecr);
    }

    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpReverseToForward(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine puts the channel back into forward mode (ECP).

Arguments:

    Pdx           - Supplies the device extension.

--*/
{
    PUCHAR          Controller;
    LARGE_INTEGER   Wait35ms;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    UCHAR           ecr;
    
    Controller = Pdx->Controller;

    Wait35ms.QuadPart = 10*35*1000 + KeQueryTimeIncrement();
    
    dcr = GetControl (Controller);
    
    //
    // Put ECR into PS/2 mode to flush the FIFO.
    //

    // Save off the ECR register 
    
    // Note: Don't worry about checking to see if it's
    // safe to touch the ecr since we've already checked 
    // that before we allowed this mode to be activated.
    ecr = P5ReadPortUchar(Controller + ECR_OFFSET);

    //
    // Event 47
    //
    Pdx->CurrentEvent = 47;
    dcr |= DCR_NOT_INIT;
    StoreControl (Controller, dcr);
    
    //
    // Wait for Event 49
    //
    Pdx->CurrentEvent = 49;
    KeQueryTickCount(&Start);
    while (TRUE) {

        KeQueryTickCount(&End);

        dsr = GetStatus(Controller);
        if (dsr & DSR_PERROR) {
            break;
        }

        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
            Wait35ms.QuadPart) {

            dsr = GetStatus(Controller);
            if (dsr & DSR_PERROR) {
                break;
            }
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
#endif
            // Restore the ecr register
            if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
                P5WritePortUchar(Controller + ECR_OFFSET, ecr);
            }

            DD((PCE)Pdx,DDE,"ParEcpReverseToForward: Failed to get State 49\n");
            return STATUS_IO_DEVICE_ERROR;
        }
    }
        
    // restore the ecr register
    if (Pdx->HardwareCapabilities & PPT_ECP_PRESENT) {
        P5WritePortUchar(Controller + ECR_OFFSET, ecr);
    }

    P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\test.c ===
#include "pch.h"

NTSTATUS
P4NibbleModeRead(
    IN      PUCHAR       Controller,
    IN      PVOID        Buffer,
    IN      ULONG        BufferSize,
    OUT     PULONG       BytesTransferred,
    IN OUT  PIEEE_STATE  IeeeState
    )
/*++

Routine Description:

    This routine performs a 1284 nibble mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/
{
    PUCHAR          wPortDCR;
    PUCHAR          wPortDSR;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          p = (PUCHAR)Buffer;
    UCHAR           dsr, dcr;
    UCHAR           nibble[2];
    ULONG           i, j;

    wPortDCR = Controller + OFFSET_DCR;
    wPortDSR = Controller + OFFSET_DSR;
    
    // Read nibbles according to 1284 spec.

    dcr = P5ReadPortUchar(wPortDCR);

    switch (IeeeState->CurrentPhase) {
    
        case PHASE_NEGOTIATION: 
        
            // Starting in state 6 - where do we go from here?
            // To Reverse Idle or Reverse Data Transfer Phase depending if
            // data is available.
            
            dsr = P5ReadPortUchar(wPortDSR);
            
            // =============== Periph State 6 ===============8
            // PeriphAck/PtrBusy        = Don't Care
            // PeriphClk/PtrClk         = Don't Care (should be high
            //                              and the nego. proc already
            //                              checked this)
            // nAckReverse/AckDataReq   = Don't Care (should be high)
            // XFlag                    = Don't Care (should be low)
            // nPeriphReq/nDataAvail    = High/Low (line status determines
            //                              which state we move to)
            IeeeState->CurrentEvent = 6;
            if (TEST_DSR(dsr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE )) {
                // Data is NOT available - go to Reverse Idle
                DD(NULL,DDT,"P4NibbleModeRead - DataNotAvail - set PHASE_REVERSE_IDLE\n");
                // Host enters state 7  - officially in Reverse Idle now
                
            	// Must stall for at least .5 microseconds before this state.
                KeStallExecutionProcessor(1);

                /* =============== Host State 7 Nibble Reverse Idle ===============8
                    DIR                     = Don't Care
                    IRQEN                   = Don't Care
                    1284/SelectIn           = High
                    nReverseReq/  (ECP only)= Don't Care
                    HostAck/HostBusy        = Low (signals State 7)
                    HostClk/nStrobe         = High
                  ============================================================ */
                IeeeState->CurrentEvent = 7;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
                P5WritePortUchar(wPortDCR, dcr);

                P5BSetPhase( IeeeState, PHASE_REVERSE_IDLE );
                // FALL THRU TO reverse idle
            } else {
            
                // Data is available, go to Reverse Transfer Phase
                P5BSetPhase( IeeeState, PHASE_REVERSE_XFER );
                // DO NOT fall thru
                goto PhaseReverseXfer; // please save me from my sins!
            }


        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            // See if data is available (looking for state 19)
            dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                
            if (!(dsr & DSR_NOT_DATA_AVAIL)) {
                
                dcr = P5ReadPortUchar(wPortDCR);
                // =========== Host State 20 Interrupt Phase ===========8
                //  DIR                     = Don't Care
                //  IRQEN                   = Don't Care
                //  1284/SelectIn           = High
                //  nReverseReq/ (ECP only) = Don't Care
                //  HostAck/HostBusy        = High (Signals state 20)
                //  HostClk/nStrobe         = High
                //
                // Data is available, get us to Reverse Transfer Phase
                IeeeState->CurrentEvent = 20;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
                P5WritePortUchar(wPortDCR, dcr);

                // =============== Periph State 21 HBDA ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = Don't Care (should be high)
                // nAckReverse/AckDataReq   = low (signals state 21)
                // XFlag                    = Don't Care (should be low)
                // nPeriphReq/nDataAvail    = Don't Care (should be low)
                IeeeState->CurrentEvent = 21;
                if (CHECK_DSR(Controller,
                                DONT_CARE, DONT_CARE, INACTIVE,
                                DONT_CARE, DONT_CARE,
                                IEEE_MAXTIME_TL)) {
                                  
                // Got state 21
                    // Let's jump to Reverse Xfer and get the data
                    P5BSetPhase( IeeeState, PHASE_REVERSE_XFER);
                    goto PhaseReverseXfer;
                        
                } else {
                    
                    // Timeout on state 21
                    IeeeState->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5BSetPhase( IeeeState, PHASE_UNKNOWN );
                    DD(NULL,DDT,"P4NibbleModeRead - Failed State 21: Controller %x dcr %x\n", Controller, dcr);
                    // NOTE:  Don't ASSERT Here.  An Assert here can bite you if you are in
                    //        Nibble Rev and you device is off/offline.
                    // dvrh 2/25/97
                    goto NibbleReadExit;
                }

            } else {
                
                // Data is NOT available - do nothing
                // The device doesn't report any data, it still looks like it is
                // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                // jumped out of Nibble mode, test also for AckDataReq high and XFlag low
                // and nDataAvaul high.
                IeeeState->CurrentEvent = 18;
                dsr = P5ReadPortUchar(Controller + OFFSET_DSR);
                if(( dsr & DSR_NIBBLE_VALIDATION )== DSR_NIBBLE_TEST_RESULT ) {

                    P5BSetPhase( IeeeState, PHASE_REVERSE_IDLE );

                } else {
                    #if DVRH_BUS_RESET_ON_ERROR
                        BusReset(wPortDCR);  // Pass in the dcr address
                    #endif
                    // Appears we failed state 19.
                    IeeeState->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    P5BSetPhase( IeeeState, PHASE_UNKNOWN );
                    DD(NULL,DDT,"P4NibbleModeRead - Failed State 19: Controller %x dcr %x\n", Controller, dcr);
                }
                goto NibbleReadExit;

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            DD(NULL,DDT,"P4NibbleModeRead - case PHASE_REVERSE_XFER\n");
            
            for (i = 0; i < BufferSize; i++) {
            
                for (j = 0; j < 2; j++) {
                
                    // Host enters state 7 or 12 depending if nibble 1 or 2
                    dcr |= DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 9     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = low (signals state 9)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    IeeeState->CurrentEvent = 9;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, INACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        
                        IeeeState->IsIeeeTerminateOk = FALSE;
                        Status = STATUS_IO_DEVICE_ERROR;
                        DD(NULL,DDT,"P4NibbleModeRead - Failed State 9: Controller %x dcr %x\n", Controller, dcr);
                        P5BSetPhase( IeeeState,PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }

                    // Read Nibble
                    nibble[j] = P5ReadPortUchar(wPortDSR);

                    /* ============== Host State 10 Nibble Read ===============8
                        DIR                     = Don't Care
                        IRQEN                   = Don't Care
                        1284/SelectIn           = High
                        HostAck/HostBusy        = High (signals State 10)
                        HostClk/nStrobe         = High
                    ============================================================ */
                    IeeeState->CurrentEvent = 10;
                    dcr &= ~DCR_NOT_HOST_BUSY;
                    P5WritePortUchar(wPortDCR, dcr);

                    // =============== Periph State 11     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = High (signals state 11)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    IeeeState->CurrentEvent = 11;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, ACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        Status = STATUS_IO_DEVICE_ERROR;
                        IeeeState->IsIeeeTerminateOk = FALSE;
                        DD(NULL,DDT,"P4NibbleModeRead - Failed State 11: Controller %x dcr %x\n", Controller, dcr);
                        P5BSetPhase( IeeeState,PHASE_UNKNOWN );
                        goto NibbleReadExit;
                    }
                }

                // Read two nibbles - make them into one byte.
                
                p[i]  = (((nibble[0]&0x38)>>3)&0x07) | ((nibble[0]&0x80) ? 0x00 : 0x08);
                p[i] |= (((nibble[1]&0x38)<<1)&0x70) | ((nibble[1]&0x80) ? 0x00 : 0x80);

                // DD(NULL,DDT,"P4NibbleModeRead:%x:%c\n", p[i], p[i]);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = P5ReadPortUchar(wPortDSR);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    P5BSetPhase( IeeeState, PHASE_REVERSE_IDLE );
                    i++; // account for this last byte transferred
                    break;
                    
                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    P5BSetPhase( IeeeState, PHASE_REVERSE_XFER );
                }
            } // end for i loop

            *BytesTransferred = i;
            // DON'T FALL THRU THIS ONE
            break;

        default:
            // I'm gonna mark this as false. There is not a correct answer here.
            //  The peripheral and the host are out of sync.  I'm gonna reset myself
            // and the peripheral.       
            IeeeState->IsIeeeTerminateOk = FALSE;
            Status = STATUS_IO_DEVICE_ERROR;
            P5BSetPhase( IeeeState, PHASE_UNKNOWN );

            DD(NULL,DDT,"P4NibbleModeRead:Failed State 9: Unknown Phase. Controller %x dcr %x\n",
                                Controller, dcr);
            DD(NULL,DDT,"P4NibbleModeRead: You're hosed man.\n" );
            DD(NULL,DDT,"P4NibbleModeRead: If you are here, you've got a bug somewhere else.\n" );
            DD(NULL,DDT,"P4NibbleModeRead: Go fix it!\n" );
            goto NibbleReadExit;
            break;
    } // end switch

NibbleReadExit:

    if( IeeeState->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        dcr |= DCR_NOT_HOST_BUSY;

        P5WritePortUchar (wPortDCR, dcr);
    }

    DD(NULL,DDT,"P4NibbleModeRead - returning status = %x\n",Status);
    if(NT_SUCCESS(Status)) {
        DD(NULL,DDT,"P4NibbleModeRead - bytes read = %d\n",*BytesTransferred);
    }
    return Status;
}


VOID
P4IeeeTerminate1284Mode(
    IN PUCHAR           Controller,
    IN OUT PIEEE_STATE  IeeeState,
    IN enum XFlagOnEvent24 XFlagOnEvent24
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    PUCHAR wPortDCR;
    UCHAR  dcr, dsrMask, dsrValue;
    BOOLEAN bXFlag;
    BOOLEAN bUseXFlag = FALSE;

    DD(NULL,DDT,"P4IeeeTerminate1284Mode - enter - Controller=%x, IeeeState=%x\n",Controller,IeeeState);

    wPortDCR = Controller + OFFSET_DCR;
    dcr = P5ReadPortUchar(wPortDCR);

    if( PHASE_TERMINATE == IeeeState->CurrentPhase ) {
        // We are already terminated.  This will fail if we don't just bypass this mess.
        goto Terminate_ExitLabel;
    }

    // Keep Negotiated XFLAG to use for termination.
    //    xFlag,  // Technically we should have
            // cached this value from state
            // 6 of nego. This peripheral's XFlag
            // at pre state 22 should be the
            // same as state 6.
    bXFlag = P5ReadPortUchar(Controller + OFFSET_DSR) & 0x10;

    // REVISIT: Do we need to ensure the preceeding state is a valid
    //          state to terminate from.  In other words, is there there
    //          a black bar on the 1284 line for that state?

    // =============== Host State 22 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low (Signals state 22)
    //  nReverseReq/**(ECP only)    = Don't Care (High for ECP, otherwise unused)
    //  HostAck/HostBusy/nAutoFeed  = High
    //  HostClk/nStrobe             = High
	//
    IeeeState->CurrentEvent = 22;
    dcr = P5ReadPortUchar(wPortDCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // Clear data lines so we don't have any random spew.
    P5WritePortUchar(Controller + OFFSET_DATA, 0);

    // *************** Periph State 23/24 Termination ***************8
    // PeriphAck/PtrBusy        = High  (Signals state 23 for ECP
    //                                   otherwise already high)
    // PeriphClk/PtrClk         = Low   (Signals state 24 for ecp
    //                                   Signals state 23 for Nibble)
    // nAckRev/AckDataReq/PE    = Don't Care
    // XFlag                    = Low  (ECP and Byte)   (State 24)
    //                          = High (Nibble)         (State 24)
    //                          = Low (All DeviceID Requests including Nibble) (State 24)
    //                          = Undefined (EPP)
    // nPeriphReq/nDataAvail    = High
    //                            Don't check nPeriphReq/nDataAvail
    //                            Since it was in a "Don't Care"
    //                            state (ie. Double bar in the spec)
    //                            until state 23 for ECP mode.
    if (IeeeState->CurrentPhase == PHASE_REVERSE_IDLE ||
        IeeeState->CurrentPhase == PHASE_REVERSE_XFER) {

        // We must be in Nibble Reverse.  Let's double check!!!
        if( FAMILY_REVERSE_NIBBLE == IeeeState->ProtocolFamily ||
            FAMILY_REVERSE_BYTE   == IeeeState->ProtocolFamily ) {
            bUseXFlag = TRUE;   // We're in Nibble or Byte
        
            if( XFlagOnEvent24 == IgnoreXFlagOnEvent24 ) {
                // normally we would honor XFlag but we need to work around Brother MFC-8700 firmware
                bUseXFlag = FALSE;
            }
        
        } else
            bUseXFlag = FALSE;   // Don't know what mode we are in?

    } else {

        if( FAMILY_BECP == IeeeState->ProtocolFamily ||
            FAMILY_ECP  == IeeeState->ProtocolFamily )
            bUseXFlag = TRUE;   // We're in an ECP Flavor
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?
        
    }

    if( bUseXFlag ) {
        dsrMask  = DSR_TEST_MASK(  DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, bXFlag ? INACTIVE : ACTIVE, DONT_CARE );
    }
    else {
        dsrMask  = DSR_TEST_MASK(  DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE );
    }
    IeeeState->CurrentEvent = 23;
    if( !CheckPort( Controller + OFFSET_DSR, dsrMask, dsrValue, IEEE_MAXTIME_TL ) ) {
        // We couldn't negotiate back to compatibility mode - just terminate.
        DD(NULL,DDT,"IeeeTerminate1284Mode:State 23/24 Failed: Controller %x dsr %x dcr %x\n", 
               Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
        goto Terminate_ExitLabel;
    }

    // =============== Host State 25 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = Low (Signals State 25)
    //  HostClk/nStrobe             = High
    //
    IeeeState->CurrentEvent = 25;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // =============== State 26 Termination ===============8
    // Do nothing for state 26

    // =============== Periph State 27 Termination ===============8
    // PeriphAck/PtrBusy        = High
    // PeriphClk/PtrClk         = High   (Signals State 27)
    // nAckRev/AckDataReq/PE    = Don't Care  (Invalid from State 23)
    // XFlag                    = Don't Care (All Modes)   (Invlaid at State 27)
    // nPeriphReq/nDataAvial    = Don't Care (Invalid from State 26)
    // dvrh 6/16/97
    IeeeState->CurrentEvent = 27;
    if( !CHECK_DSR(Controller, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) ) {
        DD(NULL,DDE,"P4IeeeTerminate1284Mode - State 27 Failed -  Controller %x dsr %x dcr %x\n",
           Controller, P5ReadPortUchar(Controller + OFFSET_DSR), dcr);
    }

Terminate_ExitLabel:

    // =============== Host State 28 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = High (Signals State 28)
    //  HostClk/nStrobe             = High
    //
    IeeeState->CurrentEvent = 28;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // We are now back in compatibility mode.

    IeeeState->CurrentPhase      = PHASE_TERMINATE;
    IeeeState->Connected         = FALSE;
    IeeeState->IsIeeeTerminateOk = FALSE;

    return;
}

NTSTATUS
P4IeeeEnter1284Mode(
    IN  PUCHAR          Controller,                    
    IN  UCHAR           Extensibility,
    IN OUT PIEEE_STATE  IeeeState
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - supplies the port base address

    Extensibility   - supplies the IEEE 1284 mode desired

    IeeeState           - tracks the state of the negotiation with the peripheral

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    PUCHAR          wPortDCR;
    UCHAR           dcr;
    const USHORT    sPeriphResponseTime = 35;

    wPortDCR = Controller + OFFSET_DCR;

    /* =============== Host Prep for Pre State 0 ===============8
       Set the following just in case someone didn't
       put the port in compatibility mode before we got it.
      
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High for ECP / Don't Care for Nibble
                                    I will do ahead and set it to high
                                    since Nibble doesn't care.
        HostAck/HostBusy        = High
        HostClk/nStrobe         = Don't Care
    ============================================================ */
    dcr = P5ReadPortUchar(wPortDCR);               // Get content of DCR.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, DONT_CARE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);

    /* =============== Host Pre State 0 Negotiation ===============8
        DIR                     = Low ( Don't Care by spec )
        IRQEN                   = Low ( Don't Care by spec )
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High ( Don't Care by spec )
        HostAck/HostBusy        = High
        HostClk/nStrobe         = High
    ============================================================ */
    
    dcr = UPDATE_DCR(dcr, INACTIVE, INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);
    KeStallExecutionProcessor(2);
    /* =============== Host State 0 Negotiation ===============8
       Place the extensibility request value on the data bus - state 0.
      
    ============================================================ */
    IeeeState->CurrentEvent = 0;
    P5WritePortUchar(Controller + DATA_OFFSET, Extensibility);
    KeStallExecutionProcessor(2);

    /* =========== Host State 1 Negotiation Phase ===========8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High  (Signals State 1)
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low   (Signals state 1)
        HostClk/nStrobe         = High
      
    ============================================================ */
    IeeeState->CurrentEvent = 1;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* =============== Periph State 2 Negotiation ===============8
       PeriphAck/PtrBusy        = Don't Care
       PeriphClk/PtrClk         = low   Signals State 2
       nAckReverse/AckDataReq   = high  Signals State 2
       XFlag                    = high  Signals State 2
                                    **Note: It is high at state 2
                                            for both ecp and nibble
       nPeriphReq/nDataAvail    = high  Signals State 2
    ============================================================ */
    IeeeState->CurrentEvent = 2;
    if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE,
                  sPeriphResponseTime)) {
        KeStallExecutionProcessor(2);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);
        
        DD(NULL,DDT,"IeeeEnter1284Mode: %x - Extensibility=%x, FAIL - TIMEOUT on Event 2\n", Controller, Extensibility);
        P5BSetPhase( IeeeState, PHASE_UNKNOWN );
        IeeeState->Connected = FALSE;
        IeeeState->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    /* =============== Host State 3 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low
        HostClk/nStrobe         = Low (signals State 3)
      
        NOTE: Strobe the Extensibility byte
    ============================================================ */
    IeeeState->CurrentEvent = 3;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, INACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    // HostClk must be help low for at least .5 microseconds.
    //
    KeStallExecutionProcessor(2);

    /* =============== Host State 4 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = High (signals State 4)
        HostClk/nStrobe         = High (signals State 4)
      
        NOTE: nReverseReq should be high in ECP, but this line is only
                valid for ECP.  Since it isn't used for signaling
                anything in negotiation, let's just ignore it for now.
    ============================================================ */
    IeeeState->CurrentEvent = 4;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    P5WritePortUchar(wPortDCR, dcr);

    /* ============== Periph State 5/6 Negotiation ===============
       PeriphAck/PtrBusy        = Don't Care. low (ECP) / Don't Care (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       PeriphClk/PtrClk         = high (Signals State 6)
       nAckReverse/AckDataReq   = Don't Care. low (ECP) / high (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       XFlag                    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       nPeriphReq/nDataAvail    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       ============== Periph State 5/6 Negotiation ==============8
      
        NOTES:
                - It's ok to lump states 5 and 6 together.  In state 5 Nibble,
                    the periph will set XFlag low and nPeriphReq/nDataAvail low.
                    The periph will then hold for .5ms then set PeriphClk/PtrClk
                    high.  In ECP, state 5 is nAckReverse/AckDataReq going low and
                    PeriphAck/PtrBusy going low.  Followed by a .5ms pause.
                    Followed by PeriphClk/PtrClk going high.
    ============================================================ */
    IeeeState->CurrentEvent = 5;
    if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE,
                  sPeriphResponseTime)) {
                  
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE);
        P5WritePortUchar(wPortDCR, dcr);

        DD(NULL,DDE,"P4IeeeEnter1284Mode - controller=%x - Extensibility=%x, FAIL - TIMEOUT on Events 5/6\n"
           , Controller, Extensibility);
        P5BSetPhase( IeeeState, PHASE_UNKNOWN );
        IeeeState->Connected = FALSE;
        IeeeState->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    KeStallExecutionProcessor(2);

    P5BSetPhase( IeeeState, PHASE_NEGOTIATION );
    IeeeState->Connected    = TRUE;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\swepp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epp.c

Abstract:

    This module contains the code to perform all EPP related tasks (including
    EPP Software and EPP Hardware modes.)

Author:

    Timothy T. Wells (WestTek, L.L.C.) - April 16, 1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


BOOLEAN
ParIsEppSwWriteSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
BOOLEAN
ParIsEppSwReadSupported(
    IN  PPDO_EXTENSION   Pdx
    );
    
NTSTATUS
ParEnterEppSwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateEppSwMode(
    IN  PPDO_EXTENSION   Pdx
    );

NTSTATUS
ParEppSwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppSwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsEppSwWriteSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not EPP mode is suported
    in the write direction by trying negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Entering\n");

    if (!(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Hardware Not Supported Leaving\n");
        // Only use EPP Software in the reverse direction if an ECR is 
        // present or we know that we can put the data register into Byte mode.
        return FALSE;
    }
        

    if (Pdx->BadProtocolModes & EPP_SW) {
        // dvdr
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Not Supported Leaving\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & EPP_SW) {
        // dvdr
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Supported Leaving\n");
        return TRUE;
    }

    // Must use SWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppSwMode (Pdx, FALSE);
    ParTerminateEppSwMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Negotiated Supported Leaving\n");
        Pdx->ProtocolModesSupported |= EPP_SW;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsEppSwWriteSupported: Not Negotiated Not Supported Leaving\n");
    return FALSE;    
}

BOOLEAN
ParIsEppSwReadSupported(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine determines whether or not EPP mode is suported
    in the read direction (need to be able to float the data register
    drivers in order to do byte wide reads) by trying negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (!(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwReadSupported: Hardware Not Supported Leaving\n");
        // Only use EPP Software in the reverse direction if an ECR is 
        // present or we know that we can put the data register into Byte mode.
        return FALSE;
    }
        
    if (Pdx->BadProtocolModes & EPP_SW)
        return FALSE;

    if (Pdx->ProtocolModesSupported & EPP_SW)
        return TRUE;

    // Must use SWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppSwMode (Pdx, FALSE);
    ParTerminateEppSwMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsEppSwReadSupported: Negotiated Supported Leaving\n");
        Pdx->ProtocolModesSupported |= EPP_SW;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsEppSwReadSupported: Not Negotiated Not Supported Leaving\n");
    return FALSE;    
}

NTSTATUS
ParEnterEppSwMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    EPP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Entering\n");

    // Parport Set Chip mode will put the Chip into Byte Mode if Capable
    // We need it for Epp Sw Mode
    Status = Pdx->TrySetChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );

    if ( NT_SUCCESS(Status) ) {
        if ( Pdx->ModeSafety == SAFE_MODE ) {
            if (DeviceIdRequest) {
                // dvdr
                DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Calling IeeeEnter1284Mode with DEVICE_ID_REQUEST\n");
                Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY | DEVICE_ID_REQ);
            } else {
                // dvdr
                DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Calling IeeeEnter1284Mode\n");
                Status = IeeeEnter1284Mode (Pdx, EPP_EXTENSIBILITY);
            }
        } else {
            DD((PCE)Pdx,DDT,"ParEnterEppSwMode: In UNSAFE_MODE.\n");
            Pdx->Connected = TRUE;
        }
    }
        
    if ( NT_SUCCESS(Status) ) {
        // dvdr
        DD((PCE)Pdx,DDT,"ParEnterEppSwMode: IeeeEnter1284Mode returned success\n");
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
        Pdx->IsIeeeTerminateOk = TRUE;

    } else {
        // dvdr
        DD((PCE)Pdx,DDT,"ParEnterEppSwMode: IeeeEnter1284Mode returned unsuccessful\n");
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }
    
    DD((PCE)Pdx,DDT,"ParEnterEppSwMode: Leaving with Status : %x \n", Status);

    return Status; 
}    

VOID
ParTerminateEppSwMode(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Pdx  - The Device Extension which has the parallel port's controller address.

Return Value:

    None.

--*/

{
    // dvdr
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Entering\n");
    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Pdx);
    } else {
        DD((PCE)Pdx,DDT,"ParTerminateEppMode: In UNSAFE_MODE.\n");
        Pdx->Connected = FALSE;
    }
    Pdx->ClearChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );
    DD((PCE)Pdx,DDT,"ParTerminateEppMode: Leaving\n");
    return;    
}

NTSTATUS
ParEppSwWrite(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the EPP protocol under software
    control.
    
Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    PUCHAR          pBuffer = (PUCHAR)Buffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           i, j;
    UCHAR           HDReady, HDAck, HDFinished;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwWrite: Entering\n");

    Controller = Pdx->Controller;

    P5SetPhase( Pdx, PHASE_FORWARD_XFER );
    
    // BIT5 of DCR needs to be low to be in BYTE forward mode
    HDReady = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, INACTIVE, INACTIVE );
    HDAck = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, INACTIVE );
    HDFinished = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, ACTIVE );

    for (i = 0; i < BufferSize; i++) {

        // dvdr
        DD((PCE)Pdx,DDT,"ParEppSwWrite: Writing Byte to port\n");

        P5WritePortBufferUchar( Controller, pBuffer++, (ULONG)0x01 );

        //
        // Event 62
        //
        StoreControl (Controller, HDReady);

        // =============== Periph State 58     ===============
        // Should wait up to 10 micro Seconds but waiting up
        // to 15 micro just in case
        for ( j = 16; j > 0; j-- ) {
            if( !(GetStatus(Controller) & DSR_NOT_BUSY) )
                break;
            KeStallExecutionProcessor(1);
        }

        // see if we timed out on state 58
        if ( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwModeWrite:Failed State 58: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }

        //
        // Event 63
        //
        StoreControl (Controller, HDAck);

        // =============== Periph State 60     ===============
        // Should wait up to 125 nano Seconds but waiting up
        // to 5 micro seconds just in case
        for ( j = 6; j > 0; j-- ) {
            if( GetStatus(Controller) & DSR_NOT_BUSY )
                break;
            KeStallExecutionProcessor(1);
        }

        if( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwModeWrite:Failed State 60: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }
            
        //
        // Event 61
        //
        StoreControl (Controller, HDFinished);
            
        // Stall a little bit between data bytes
        KeStallExecutionProcessor(1);

    }
        
    *BytesTransferred = i;

    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwWrite: Leaving with %i Bytes Transferred\n", i);

    if ( Status == STATUS_SUCCESS )
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );
    
    return Status;

}

NTSTATUS
ParEppSwRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 EPP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          pBuffer = (PUCHAR)Buffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           i, j;
    UCHAR           dcr;
    UCHAR           HDReady, HDAck;
    
    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwRead: Entering\n");

    Controller = Pdx->Controller;

    P5SetPhase( Pdx, PHASE_REVERSE_XFER );
    
    // Save off Control
    dcr = GetControl (Controller);
    
    // BIT5 of DCR needs to be high to be in BYTE reverse mode
    HDReady = SET_DCR( ACTIVE, INACTIVE, ACTIVE, ACTIVE, INACTIVE, ACTIVE );
    HDAck = SET_DCR( ACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, ACTIVE );

    // First time to get into reverse mode quickly
    StoreControl (Controller, HDReady);

    for (i = 0; i < BufferSize; i++) {

        //
        // Event 67
        //
        StoreControl (Controller, HDReady);
            
        // =============== Periph State 58     ===============
        // Should wait up to 10 micro Seconds but waiting up
        // to 15 micro just in case
        for ( j = 16; j > 0; j-- ) {
            if( !(GetStatus(Controller) & DSR_NOT_BUSY) )
                break;
            KeStallExecutionProcessor(1);
        }

        // see if we timed out on state 58
        if ( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwRead:Failed State 58: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }

        // Read the Byte                
        P5ReadPortBufferUchar( Controller, 
                                pBuffer++, 
                                (ULONG)0x01 );

        //
        // Event 63
        //
        StoreControl (Controller, HDAck);
            
        // =============== Periph State 60     ===============
        // Should wait up to 125 nano Seconds but waiting up
        // to 5 micro seconds just in case
        for ( j = 6; j > 0; j-- ) {
            if( GetStatus(Controller) & DSR_NOT_BUSY )
                break;
            KeStallExecutionProcessor(1);
        }

        if( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            DD((PCE)Pdx,DDE,"ParEppSwRead:Failed State 60: Controller %x\n", Controller);
            P5SetPhase( Pdx, PHASE_UNKNOWN );
            break;
        }
        
        // Stall a little bit between data bytes
        KeStallExecutionProcessor(1);
    }
    
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);
    
    *BytesTransferred = i;

    // dvdr
    DD((PCE)Pdx,DDT,"ParEppSwRead: Leaving with %x Bytes Transferred\n", i);

    if ( Status == STATUS_SUCCESS )
        P5SetPhase( Pdx, PHASE_FORWARD_IDLE );

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\unload.c ===
#include "pch.h"

VOID
PptUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++
      
Routine Description:
      
    This routine cleans up all of the memory associated with
      any of the devices belonging to the driver.  It  will
      loop through the device list.
      
Arguments:
      
    DriverObject    - Supplies the driver object controlling all of the
                        devices.
      
Return Value:
      
    None.
      
--*/
    
{
    PDEVICE_OBJECT                  CurrentDevice;
    PFDO_EXTENSION               Extension;
    PLIST_ENTRY                     Head;
    PISR_LIST_ENTRY                 Entry;
    
    CurrentDevice = DriverObject->DeviceObject;

    while( CurrentDevice ) {
        
        Extension = CurrentDevice->DeviceExtension;
        
        if (Extension->InterruptRefCount) {
            PptDisconnectInterrupt(Extension);
        }
        
        while (!IsListEmpty(&Extension->IsrList)) {
            Head = RemoveHeadList(&Extension->IsrList);
            Entry = CONTAINING_RECORD(Head, ISR_LIST_ENTRY, ListEntry);
            ExFreePool(Entry);
        }
        
        ExFreePool(Extension->DeviceName.Buffer);

        IoDeleteDevice(CurrentDevice);
        
        IoGetConfigurationInformation()->ParallelCount--;

        CurrentDevice = DriverObject->DeviceObject;
    }
    
    if( PortInfoMutex ) {
        ExFreePool( PortInfoMutex );
        PortInfoMutex = NULL;
    }

    if( PowerStateCallbackRegistration ) {
        ExUnregisterCallback( PowerStateCallbackRegistration );
        PowerStateCallbackRegistration = NULL; // probably not needed, but shouldn't hurt
    }
    if( PowerStateCallbackObject ) {
        ObDereferenceObject( PowerStateCallbackObject );
        PowerStateCallbackObject = NULL;
    }

    RtlFreeUnicodeString( &RegistryPath );

    DD(NULL,DDE,"PptUnload\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\thread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       thread.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with ParClass worker threads
//

#include "pch.h"

VOID
PptPdoThread(
    IN PVOID Context
    )

/*++

Routine Description:

    This is the parallel thread routine.  Loops performing I/O operations.

Arguments:

    Context -- Really the extension

Return Value:

    None

--*/

{
    
    PPDO_EXTENSION  pdx = Context;
    KIRQL           OldIrql;
    NTSTATUS        Status;
    LARGE_INTEGER   Timeout;
    PIRP            CurrentIrp;

    DD((PCE)pdx,DDT,"PptPdoThread - %s - enter\n",pdx->Location);

    do {

        Timeout = pdx->IdleTimeout;

        Status  = KeWaitForSingleObject( &pdx->RequestSemaphore, UserRequest, KernelMode, FALSE, &Timeout );
        
        if( Status == STATUS_TIMEOUT ) {

            if( pdx->P12843DL.bEventActive ) {

                // Dot4.sys has a worker thread blocked on this event
                // waiting for us to signal if the peripheral has data
                // available for dot4 to read. When we signal this
                // event dot4.sys generates a read request to retrieve
                // the data from the peripheral.

                if( ParHaveReadData( pdx ) ) {
                    // the peripheral has data - signal dot4.sys
                    DD((PCE)pdx,DDT,"PptPdoThread: Signaling Event [%x]\n", pdx->P12843DL.Event);
                    KeSetEvent(pdx->P12843DL.Event, 0, FALSE);
                }
            }

            if( pdx->QueryNumWaiters( pdx->PortContext ) != 0 ) {

                // someone else is waiting on the port - give up the
                // port - we'll attempt to reaquire the port later
                // when we have a request to process

                ParTerminate(pdx);
                ParFreePort(pdx);
                continue;
            }

        } // endif STATUS_TIMEOUT


        // wait here if PnP has paused us (e.g., QUERY_STOP, STOP, QUERY_REMOVE)
        KeWaitForSingleObject(&pdx->PauseEvent, Executive, KernelMode, FALSE, 0);

        if ( pdx->TimeToTerminateThread ) {

            // A dispatch thread has signalled us that we should clean
            // up any communication with our peripheral and then
            // terminate self. The dispatch thread is blocked waiting
            // for us to terminate self.

            if( pdx->Connected ) {

                // We currently have the port acquired and have the
                // peripheral negotiated into an IEEE mode. Terminate
                // the peripheral back to Compatibility mode forward
                // idle and release the port.

                ParTerminate( pdx );
                ParFreePort( pdx );
            }

            // terminate self

            PsTerminateSystemThread( STATUS_SUCCESS );
        }


        //
        // process the next request from the work queue - use the
        // Cancel SpinLock to protect the queue
        //

        IoAcquireCancelSpinLock(&OldIrql);

        ASSERT(!pdx->CurrentOpIrp);

        while (!IsListEmpty(&pdx->WorkQueue)) {

            // get next IRP from our list of work items
            PLIST_ENTRY HeadOfList;
            HeadOfList = RemoveHeadList(&pdx->WorkQueue);
            CurrentIrp = CONTAINING_RECORD(HeadOfList, IRP, Tail.Overlay.ListEntry);

            // we have started processing, this IRP can no longer be cancelled
#pragma warning( push ) 
#pragma warning( disable : 4054 4055 )
            IoSetCancelRoutine(CurrentIrp, NULL);
#pragma warning( pop ) 
            ASSERT(NULL == CurrentIrp->CancelRoutine);
            ASSERT(!CurrentIrp->Cancel);

            pdx->CurrentOpIrp = CurrentIrp;

            IoReleaseCancelSpinLock(OldIrql);

            //
            // Do the Io - PptPdoStartIo will exectute and complete the IRP: pdx->CurrentIrp
            //
            PptPdoStartIo(pdx);

            if( pdx->P12843DL.bEventActive ) {

                // Dot4.sys has a worker thread blocked on this event
                // waiting for us to signal if the peripheral has data
                // available for dot4 to read. When we signal this
                // event dot4.sys generates a read request to retrieve
                // the data from the peripheral.

                if( ParHaveReadData( pdx ) ) {
                    // the peripheral has data - signal dot4.sys
                    DD((PCE)pdx,DDT,"PptPdoThread: Signaling Eventb [%x]\n", pdx->P12843DL.Event);
                    KeSetEvent(pdx->P12843DL.Event, 0, FALSE);
                }
            }

            // wait here if PnP has paused us (e.g., QUERY_STOP, STOP, QUERY_REMOVE)
            KeWaitForSingleObject(&pdx->PauseEvent, Executive, KernelMode, FALSE, 0);

            IoAcquireCancelSpinLock(&OldIrql);
        }
        IoReleaseCancelSpinLock(OldIrql);

    } while (TRUE);
}

NTSTATUS
ParCreateSystemThread(
    PPDO_EXTENSION Pdx
    )

{
    NTSTATUS        Status;
    HANDLE          ThreadHandle;
    OBJECT_ATTRIBUTES objAttrib;

    DD((PCE)Pdx,DDT,"ParCreateSystemThread - %s - enter\n",Pdx->Location);

    // Start the thread - save referenced pointer to thread in our extension
    InitializeObjectAttributes( &objAttrib, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );
    Status = PsCreateSystemThread( &ThreadHandle, THREAD_ALL_ACCESS, &objAttrib, NULL, NULL, PptPdoThread, Pdx );
    if (!NT_ERROR(Status)) {
        // We've got the thread.  Now get a pointer to it.
        Status = ObReferenceObjectByHandle( ThreadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, &Pdx->ThreadObjectPointer, NULL );
        if (NT_ERROR(Status)) {
            Pdx->TimeToTerminateThread = TRUE;
            KeReleaseSemaphore( &Pdx->RequestSemaphore, 0, 1, FALSE );
        } else {
            // Now that we have a reference to the thread we can simply close the handle.
            ZwClose(ThreadHandle);
        }
        DD((PCE)Pdx,DDT,"ParCreateSystemThread - %s - SUCCESS\n",Pdx->Location);
    } else {
        DD((PCE)Pdx,DDT,"ParCreateSystemThread - %s FAIL - status = %x\n",Pdx->Location, Status);
    }
    return Status;
}

VOID
PptPdoStartIo(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine starts an I/O operation for the driver and
    then returns

Arguments:

    Pdx - The parallel device extension

Return Value:

    None

--*/

{
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    KIRQL                   CancelIrql;

    Irp = Pdx->CurrentOpIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Information = 0;

    if (!Pdx->Connected && !ParAllocPort(Pdx)) {
        // #pragma message( "dvrh Left bad stuff in thread.c") 
        DD((PCE)Pdx,DDE,"PptPdoStartIo - %s - threads are hosed\n",Pdx->Location);
        //        __asm int 3   
        //
        // If the allocation didn't succeed then fail this IRP.
        //
        goto CompleteIrp;
    }

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_WRITE:
            ParWriteIrp(Pdx);
            break;

        case IRP_MJ_READ:
            ParReadIrp(Pdx);
            break;

        default:
            ParDeviceIo(Pdx);
            break;
    }

    if (!Pdx->Connected && !Pdx->AllocatedByLockPort) {
    
        // if we're not connected in a 1284 mode, then release host port
        // otherwise let the watchdog timer do it.

        ParFreePort(Pdx);
    }

CompleteIrp:

    IoAcquireCancelSpinLock(&CancelIrql);
    Pdx->CurrentOpIrp = NULL;
    IoReleaseCancelSpinLock(CancelIrql);

    P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\utils.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------


#ifndef _UTIL_
#define _UTIL_

#define GetStatus(RegisterBase) \
    (P5ReadPortUchar((RegisterBase)+DSR_OFFSET))

#define GetControl(RegisterBase) \
    (P5ReadPortUchar((RegisterBase)+DCR_OFFSET))


#define StoreControl(RegisterBase,ControlByte)  \
{                                               \
    P5WritePortUchar((RegisterBase)+DCR_OFFSET, \
                     (UCHAR)ControlByte );      \
}

// The following macros may be used to test the contents of the Device
// Status Regisger (DSR).  These macros account for the hardware
// inversion of the nBusy (aka PtrBusy, PeriphAck) signal.
//////////////////////////////////////////////////////////////////////////////

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)(b7==DONT_CARE? 0:  BIT_7_SET) | \
            (b6==DONT_CARE? 0:  BIT_6_SET) | \
            (b5==DONT_CARE? 0:  BIT_5_SET) | \
            (b4==DONT_CARE? 0:  BIT_4_SET) | \
            (b3==DONT_CARE? 0:  BIT_3_SET) )
#else
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)((b7==DONT_CARE?0:1)<<BIT_7) | \
            ((b6==DONT_CARE?0:1)<<BIT_6) | \
            ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) )
#endif

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) ((b7==DONT_CARE?0:(b7==ACTIVE?0        : BIT_7_SET)) | \
            (b6==DONT_CARE?0:(b6==ACTIVE?  BIT_6_SET: 0)) | \
            (b5==DONT_CARE?0:(b5==ACTIVE?  BIT_5_SET: 0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET: 0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  BIT_3_SET: 0)) ) )
#else
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) (((b7==DONT_CARE?0:(b7==ACTIVE?0:1))<<BIT_7) | \
            ((b6==DONT_CARE?0:(b6==ACTIVE?1:0))<<BIT_6) | \
            ((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?1:0))<<BIT_3) ) )
#endif

#define TEST_DSR(registerValue,b7,b6,b5,b4,b3)  \
(((registerValue) & DSR_TEST_MASK(b7,b6,b5,b4,b3)) == DSR_TEST_VALUE(b7,b6,b5,b4,b3))


#define CHECK_DSR( addr, b7, b6, b5, b4, b3, usTime )                    \
    (TEST_DSR(P5ReadPortUchar(addr + DSR_OFFSET), b7, b6, b5, b4, b3 ) ? TRUE :   \
    CheckPort( addr + DSR_OFFSET,                                               \
             DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                                   \
             DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),                                  \
             usTime ) )

////////////////////////////////////////////////////////////////////////////////
// The CHECK_DSR_AND_FIFO macro may be used to invoke the CheckPort2 function, 
// without having to specify the mask and value components twice.
// CHECK_DSR_AND_FIFO does quick tests of the DSR and ECR ports first.
// If the peripheral has already responded with either of the
//  desired values, CheckPort2 need not be called.
////////////////////////////////////////////////////////////////////////////////

#define CHECK_DSR_WITH_FIFO( addr, b7, b6, b5, b4, b3, ecr_mask, ecr_value, msTime ) \
( TEST_DSR( P5ReadPortUchar( addr + OFFSET_DSR ), b7, b6, b5, b4, b3 ) ? TRUE :       \
  CheckTwoPorts( addr + OFFSET_DSR,                                  \
                 DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                \
                 DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),               \
                 addr + ECR_OFFSET,                                  \
                 ecr_mask,                                           \
                 ecr_value,                                          \
                 msTime) )

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////

// The DCR_AND_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   BIT_5_SET:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    BIT_4_SET:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    BIT_3_SET:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    BIT_2_SET:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    BIT_1_SET:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    BIT_0_SET:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?1:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?1:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?1:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?1:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?1:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?1:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif  

// The DCR_OR_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   0:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The UPDATE_DCR macro generates provides a selective update of specific bits
// in the DCR.  Any bit positions specified as DONT_CARE will be left
// unchanged.  The macro accounts for the hardware inversion of
// certain signals.

#define UPDATE_DCR(registerValue,b5,b4,b3,b2,b1,b0) \
((UCHAR)(((registerValue) & DCR_AND_MASK(b5,b4,b3,b2,b1,b0)) | DCR_OR_MASK(b5,b4,b3,b2,b1,b0)))

// The DCR_TEST_MASK macro generates a byte constant which may be used
// to mask of DCR bits that we don't care about

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:BIT_5_SET) | \
            (b4==DONT_CARE?0:BIT_4_SET) | \
            (b3==DONT_CARE?0:BIT_3_SET) | \
            (b2==DONT_CARE?0:BIT_2_SET) | \
            (b1==DONT_CARE?0:BIT_1_SET) | \
            (b0==DONT_CARE?0:BIT_0_SET) ) )
#else
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)( ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) | \
            ((b2==DONT_CARE?0:1)<<BIT_2) | \
            ((b1==DONT_CARE?0:1)<<BIT_1) | \
            ((b0==DONT_CARE?0:1)<<BIT_0) ) )
#endif
// The DCR_TEST_VALUE macro generates a byte constant that may be used
// to compare against a masked DCR value.  This macro takes into
// account which signals are inverted by hardware before driving the
// signal line.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:(b5==ACTIVE? BIT_5_SET:  0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The TEST_DCR macro may be used to generate a boolean result that is
// TRUE if the DCR value matches the specified signal levels and FALSE
// otherwise.

#define TEST_DCR(registerValue,b5,b4,b3,b2,b1,b0)  \
(((registerValue) & DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)) == DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0))

BOOLEAN CheckPort(IN PUCHAR offset_Controller,
                  IN UCHAR dsrMask,
                  IN UCHAR dsrValue,
                  IN USHORT msTimeDelay);


// *** original parclass util.h follows ***

// Standard Maximum Timing values
#define IEEE_MAXTIME_TL    35       // Max time Tl from the IEEE spec
#define DEFAULT_RECEIVE_TIMEOUT     330

#define ParEnterCriticalSection(Xtension)  xTension->bCriticalSection = TRUE
#define ParExitCriticalSection(Xtension)   xTension->bCriticalSection = FALSE

// The following macros may be used to test the contents of the Device
// Status Regisger (DSR).  These macros account for the hardware
// inversion of the nBusy (aka PtrBusy, PeriphAck) signal.
//////////////////////////////////////////////////////////////////////////////

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)(b7==DONT_CARE? 0:  BIT_7_SET) | \
            (b6==DONT_CARE? 0:  BIT_6_SET) | \
            (b5==DONT_CARE? 0:  BIT_5_SET) | \
            (b4==DONT_CARE? 0:  BIT_4_SET) | \
            (b3==DONT_CARE? 0:  BIT_3_SET) )
#else
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)((b7==DONT_CARE?0:1)<<BIT_7) | \
            ((b6==DONT_CARE?0:1)<<BIT_6) | \
            ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) )
#endif

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) ((b7==DONT_CARE?0:(b7==ACTIVE?0        : BIT_7_SET)) | \
            (b6==DONT_CARE?0:(b6==ACTIVE?  BIT_6_SET: 0)) | \
            (b5==DONT_CARE?0:(b5==ACTIVE?  BIT_5_SET: 0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET: 0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  BIT_3_SET: 0)) ) )
#else
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) (((b7==DONT_CARE?0:(b7==ACTIVE?0:1))<<BIT_7) | \
            ((b6==DONT_CARE?0:(b6==ACTIVE?1:0))<<BIT_6) | \
            ((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?1:0))<<BIT_3) ) )
#endif

#define TEST_DSR(registerValue,b7,b6,b5,b4,b3)  \
(((registerValue) & DSR_TEST_MASK(b7,b6,b5,b4,b3)) == DSR_TEST_VALUE(b7,b6,b5,b4,b3))


#if 0 // use parport's util.h versions
#define CHECK_DSR( addr, b7, b6, b5, b4, b3, msTime )                    \
    (TEST_DSR(P5ReadPortUchar(addr + OFFSET_DSR), b7, b6, b5, b4, b3 ) ? TRUE :   \
    CheckPort( addr + OFFSET_DSR,                                               \
             DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                                   \
             DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),                                  \
             msTime ) )

////////////////////////////////////////////////////////////////////////////////
// The CHECK_DSR_AND_FIFO macro may be used to invoke the CheckPort2 function, 
// without having to specify the mask and value components twice.
// CHECK_DSR_AND_FIFO does quick tests of the DSR and ECR ports first.
// If the peripheral has already responded with either of the
//  desired values, CheckPort2 need not be called.
////////////////////////////////////////////////////////////////////////////////
#endif // 0

#if 0 // use parport's util.h versions
#define CHECK_DSR_WITH_FIFO( addr, b7, b6, b5, b4, b3, ecr_mask, ecr_value, msTime ) \
( TEST_DSR( P5ReadPortUchar( addr + OFFSET_DSR ), b7, b6, b5, b4, b3 ) ? TRUE :       \
  CheckTwoPorts( addr + OFFSET_DSR,                                  \
                 DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                \
                 DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),               \
                 addr + ECR_OFFSET,                                  \
                 ecr_mask,                                           \
                 ecr_value,                                          \
                 msTime) )
#endif // 0

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////

// The DCR_AND_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   BIT_5_SET:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    BIT_4_SET:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    BIT_3_SET:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    BIT_2_SET:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    BIT_1_SET:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    BIT_0_SET:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?1:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?1:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?1:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?1:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?1:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?1:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif  

// The DCR_OR_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   0:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The UPDATE_DCR macro generates provides a selective update of specific bits
// in the DCR.  Any bit positions specified as DONT_CARE will be left
// unchanged.  The macro accounts for the hardware inversion of
// certain signals.

#define UPDATE_DCR(registerValue,b5,b4,b3,b2,b1,b0) \
((UCHAR)(((registerValue) & DCR_AND_MASK(b5,b4,b3,b2,b1,b0)) | DCR_OR_MASK(b5,b4,b3,b2,b1,b0)))

// The DCR_TEST_MASK macro generates a byte constant which may be used
// to mask of DCR bits that we don't care about

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:BIT_5_SET) | \
            (b4==DONT_CARE?0:BIT_4_SET) | \
            (b3==DONT_CARE?0:BIT_3_SET) | \
            (b2==DONT_CARE?0:BIT_2_SET) | \
            (b1==DONT_CARE?0:BIT_1_SET) | \
            (b0==DONT_CARE?0:BIT_0_SET) ) )
#else
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)( ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) | \
            ((b2==DONT_CARE?0:1)<<BIT_2) | \
            ((b1==DONT_CARE?0:1)<<BIT_1) | \
            ((b0==DONT_CARE?0:1)<<BIT_0) ) )
#endif
// The DCR_TEST_VALUE macro generates a byte constant that may be used
// to compare against a masked DCR value.  This macro takes into
// account which signals are inverted by hardware before driving the
// signal line.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:(b5==ACTIVE? BIT_5_SET:  0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The TEST_DCR macro may be used to generate a boolean result that is
// TRUE if the DCR value matches the specified signal levels and FALSE
// otherwise.

#define TEST_DCR(registerValue,b5,b4,b3,b2,b1,b0)  \
(((registerValue) & DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)) == DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0))

//  mask all but AckDataReq, XFlag, and nDataAvail to validate if it is still NIBBLE mode
//  00111000b
//#define DSR_NIBBLE_VALIDATION       (0x38)
#define DSR_NIBBLE_VALIDATION       (0x30)
//  AckDataReq high, XFlag low, nDataAvail high
//  00101000b
//#define DSR_NIBBLE_TEST_RESULT      (0x28)
#define DSR_NIBBLE_TEST_RESULT      (0x20)

//  mask all but AckDataReq, XFlag, and nDataAvail to validate if it is still BYTE mode
//  00111000b
#define DSR_BYTE_VALIDATION         (0x38)
//  AckDataReq high, XFlag high, nDataAvail high
//  00111000b
#define DSR_BYTE_TEST_RESULT        (0x38)

#define DVRH_LOGIC_ANALYZER_START(CNT)      \
            int DVRH_temp;                  \
            int DVRH_max = CNT;             \
            int DVRH_cnt = 0;               \
            UCHAR DVRH_dsr;                 \
            UCHAR DVRH_Statedsr[CNT];       \
            LARGE_INTEGER DVRH_Statetime[CNT];
#define DVRH_LOGIC_ANALYZER_READ_TIMER(DSR)          \
            DVRH_dsr = P5ReadPortUchar(DSR);                \
            KeQuerySystemTime(&DVRH_Statetime[DVRH_cnt]);   \
            DVRH_Statedsr[DVRH_cnt++] = DVRH_dsr;
#define DVRH_LOGIC_ANALYZER_READ_STATE(DSR)          \
            DVRH_dsr = P5ReadPortUchar(DSR);                \
            KeQuerySystemTime(&DVRH_Statetime[DVRH_cnt]);   \
            DVRH_Statedsr[DVRH_cnt ? ((DVRH_dsr != DVRH_Statedsr[DVRH_cnt-1]) ? DVRH_cnt++ : DVRH_cnt) : 0] = DVRH_dsr;

#define DVRH_LOGIC_ANALYZER_END                                 \
        KdPrint("0. %10u-%10u dsr [%x]\n",                      \
            DVRH_Statetime[0].HighPart,                         \
            DVRH_Statetime[0].LowPart/10,                       \
            DVRH_Statedsr[0]);                                  \
        for (DVRH_temp=1; DVRH_temp<DVRH_cnt; DVRH_temp++)      \
        {                                                       \
            KdPrint("%d. %10u-%10u diff [%10u]us dsr [%x]\n",   \
                DVRH_temp,                                      \
                DVRH_Statetime[DVRH_temp].HighPart,             \
                DVRH_Statetime[DVRH_temp].LowPart/10,           \
                ((DVRH_Statetime[DVRH_temp].LowPart/10) - (DVRH_Statetime[DVRH_temp-1].LowPart/10)),    \
                DVRH_Statedsr[DVRH_temp]);                      \
        }

void BusReset(
    IN  PUCHAR DCRController
    );

BOOLEAN CheckPort(IN PUCHAR offset_Controller,
                  IN UCHAR dsrMask,
                  IN UCHAR dsrValue,
                  IN USHORT msTimeDelay);

BOOLEAN
CheckTwoPorts(
    PUCHAR  pPortAddr1,
    UCHAR   bMask1,
    UCHAR   bValue1,
    PUCHAR  pPortAddr2,
    UCHAR   bMask2,
    UCHAR   bValue2,
    USHORT  msTimeDelay
    );

#endif // _PC_UTIL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parvdm\parvdm.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parvdm.c

Abstract:

    This module contains the code for a simple parallel class driver.

    Unload and Cleanup are supported.  The model for grabing and
    releasing the parallel port is embodied in the code for IRP_MJ_READ.
    Other IRP requests could be implemented similarly.

    Basically, every READ requests that comes in gets
    passed down to the port driver as a parallel port allocate
    request.  This IRP will return to this driver when the driver

Environment:

    Kernel mode

Revision History :

--*/

#include "ntosp.h"
#include "parallel.h"
#include "ntddvdm.h"
#include "parvdm.h"
#include "parlog.h"

static const PHYSICAL_ADDRESS PhysicalZero = {0};

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParInitializeDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           ParallelPortNumber
    );

NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    );

VOID
ParReleasePortInfoToPortDevice(
    IN OUT PDEVICE_EXTENSION    Extension
    );

NTSTATUS
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP Irp
    );

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,ParInitializeDeviceObject)
#pragma alloc_text(INIT,ParMakeNames)
#endif
//
// Keep track of OPEN and CLOSE.
//
ULONG OpenCloseReferenceCount = 1;
PFAST_MUTEX OpenCloseMutex = NULL;

#define ParClaimDriver()                        \
    ExAcquireFastMutex(OpenCloseMutex);         \
    if(++OpenCloseReferenceCount == 1) {        \
    MmResetDriverPaging(DriverEntry);       \
    }                                           \
    ExReleaseFastMutex(OpenCloseMutex);         \

#define ParReleaseDriver()                      \
    ExAcquireFastMutex(OpenCloseMutex);         \
    if(--OpenCloseReferenceCount == 0) {        \
    MmPageEntireDriver(DriverEntry);        \
    }                                           \
    ExReleaseFastMutex(OpenCloseMutex);         \


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/

{
    ULONG       i;

    PAGED_CODE();

    //
    // allocate the mutex to protect driver reference count
    //

    OpenCloseMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX));
    if (!OpenCloseMutex) {

    //
    // NOTE - we could probably do without bailing here and just
    // leave a note for ourselves to never page out, but since we
    // don't have enough memory to allocate a mutex we should probably
    // avoid leaving the driver paged in at all times
    //

    return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeFastMutex(OpenCloseMutex);


    for (i = 0; i < IoGetConfigurationInformation()->ParallelCount; i++) {
    ParInitializeDeviceObject(DriverObject, i);
    }

    if (!DriverObject->DeviceObject) {
        if( OpenCloseMutex ) {
            ExFreePool( OpenCloseMutex );
            OpenCloseMutex = NULL;
        }
    return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize the Driver Object with driver's entry points
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = ParCreateOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ParClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ParDeviceControl;
    DriverObject->DriverUnload = ParUnload;

    //
    // page out the driver if we can
    //

    ParReleaseDriver();


    return STATUS_SUCCESS;
}

NTSTATUS
ParOpenFileAgainstParport(PDEVICE_EXTENSION extension)
{
    NTSTATUS status;

    status = IoGetDeviceObjectPointer(&extension->ParPortName, FILE_READ_ATTRIBUTES,
                                      &extension->ParPortFileObject,
                      &extension->PortDeviceObject);
    return status;
}

VOID
ParCloseFileAgainstParport(PDEVICE_EXTENSION extension)
{
    if( extension->ParPortFileObject ) {
        ObDereferenceObject( extension->ParPortFileObject );
        extension->ParPortFileObject = NULL;
    }
}

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                device.

    DeviceObject        - Supplies a pointer to the device object associated
                with the device that had the error, early in
                initialization, one may not yet exist.

    P1,P2               - Supplies the physical addresses for the controller
                ports involved with the error if they are available
                and puts them through as dump data.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                the life of the irp in this driver - 0 generally
                means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                associated with this error.  If this log entry is
                being made during one of the retries this value
                will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    PVOID                   objectToUse;
    SHORT                   dumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {
    objectToUse = DeviceObject;
    } else {
    objectToUse = DriverObject;
    }

    dumpToAllocate = 0;

    if (P1.LowPart != 0 || P1.HighPart != 0) {
    dumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    if (P2.LowPart != 0 || P2.HighPart != 0) {
    dumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    errorLogEntry = IoAllocateErrorLogEntry(objectToUse,
        (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate));

    if (!errorLogEntry) {
    return;
    }

    errorLogEntry->ErrorCode = SpecificIOStatus;
    errorLogEntry->SequenceNumber = SequenceNumber;
    errorLogEntry->MajorFunctionCode = MajorFunctionCode;
    errorLogEntry->RetryCount = RetryCount;
    errorLogEntry->UniqueErrorValue = UniqueErrorValue;
    errorLogEntry->FinalStatus = FinalStatus;
    errorLogEntry->DumpDataSize = dumpToAllocate;

    if (dumpToAllocate) {

    RtlCopyMemory(errorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

    if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

        RtlCopyMemory(((PUCHAR) errorLogEntry->DumpData) +
              sizeof(PHYSICAL_ADDRESS), &P2,
              sizeof(PHYSICAL_ADDRESS));
    }
    }

    IoWriteErrorLogEntry(errorLogEntry);
}

VOID
ParInitializeDeviceObject(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           ParallelPortNumber
    )

/*++

Routine Description:

    This routine is called for every parallel port in the system.  It
    will create a class device upon connecting to the port device
    corresponding to it.

Arguments:

    DriverObject        - Supplies the driver object.

    ParallelPortNumber  - Supplies the number for this port.

Return Value:

    None.

--*/

{
    UNICODE_STRING      portName, className, linkName;
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   extension;
    PFILE_OBJECT        fileObject;

    PAGED_CODE();

    // Cobble together the port and class device names.

    if (!ParMakeNames(ParallelPortNumber, &portName, &className, &linkName)) {

    ParLogError(DriverObject, NULL, PhysicalZero, PhysicalZero, 0, 0, 0, 1,
            STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);

    return;
    }


    // Create the device object.

    status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION),
                &className, FILE_DEVICE_PARALLEL_PORT, 0, FALSE,
                &deviceObject);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, NULL, PhysicalZero, PhysicalZero, 0, 0, 0, 2,
            STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);

    ExFreePool(linkName.Buffer);
    ExFreePool(portName.Buffer);
    ExFreePool(className.Buffer);
    return;
    }


    // Now that the device has been created,
    // set up the device extension.

    extension = deviceObject->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));

    extension->DeviceObject = deviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

    status = IoGetDeviceObjectPointer(&portName, FILE_READ_ATTRIBUTES,
                      &fileObject,
                      &extension->PortDeviceObject);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, deviceObject, PhysicalZero, PhysicalZero,
            0, 0, 0, 3, STATUS_SUCCESS, PAR_CANT_FIND_PORT_DRIVER);

    IoDeleteDevice(deviceObject);
    ExFreePool(linkName.Buffer);
    ExFreePool(portName.Buffer);
    ExFreePool(className.Buffer);
    return;
    }

    ObDereferenceObject(fileObject);

    extension->DeviceObject->StackSize =
        extension->PortDeviceObject->StackSize + 1;


    // We don't own parallel ports initially

    extension->PortOwned = FALSE;

    // Get the port information from the port device object.

    status = ParGetPortInfoFromPortDevice(extension);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, deviceObject, PhysicalZero, PhysicalZero,
            0, 0, 0, 4, STATUS_SUCCESS, PAR_CANT_FIND_PORT_DRIVER);

    IoDeleteDevice(deviceObject);
    ExFreePool(linkName.Buffer);
        ExFreePool(portName.Buffer);
        ExFreePool(className.Buffer);
    return;
    }


    // Set up the symbolic link for windows apps.

    status = IoCreateUnprotectedSymbolicLink(&linkName, &className);
    if (!NT_SUCCESS(status)) {

    ParLogError(DriverObject, deviceObject, extension->OriginalController,
            PhysicalZero, 0, 0, 0, 5, STATUS_SUCCESS,
            PAR_NO_SYMLINK_CREATED);

    extension->CreatedSymbolicLink = FALSE;
    ExFreePool(linkName.Buffer);
    goto Cleanup;
    }


    // We were able to create the symbolic link, so record this
    // value in the extension for cleanup at unload time.

    extension->CreatedSymbolicLink = TRUE;
    extension->SymbolicLinkName = linkName;

Cleanup:
    // release the port info so the port driver can be paged out
    ParReleasePortInfoToPortDevice(extension);
    // ExFreePool(portName.Buffer); - save this in extension for
    // future CreateFiles against parport
    if( portName.Buffer ) {
        RtlInitUnicodeString( &extension->ParPortName, portName.Buffer );
    }
    ExFreePool(className.Buffer);
}

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    )

/*++

Routine Description:

    This routine generates the names \Device\ParallelPortN and
    \Device\ParallelVdmN, \DosDevices\PARVDMN.

Arguments:

    ParallelPortNumber  - Supplies the port number.

    PortName            - Returns the port name.

    ClassName           - Returns the class name.

    LinkName            - Returns the symbolic link name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING  prefix, digits, linkPrefix, linkDigits;
    WCHAR           digitsBuffer[10], linkDigitsBuffer[10];
    UNICODE_STRING  portSuffix, classSuffix, linkSuffix;
    NTSTATUS        status;

    // Put together local variables for constructing names.

    RtlInitUnicodeString(&prefix, L"\\Device\\");
    RtlInitUnicodeString(&linkPrefix, L"\\DosDevices\\");
    RtlInitUnicodeString(&portSuffix, DD_PARALLEL_PORT_BASE_NAME_U);
    RtlInitUnicodeString(&classSuffix, L"ParallelVdm");
    RtlInitUnicodeString(&linkSuffix, L"$VDMLPT");
    digits.Length = 0;
    digits.MaximumLength = 20;
    digits.Buffer = digitsBuffer;
    linkDigits.Length = 0;
    linkDigits.MaximumLength = 20;
    linkDigits.Buffer = linkDigitsBuffer;
    status = RtlIntegerToUnicodeString(ParallelPortNumber, 10, &digits);
    if (!NT_SUCCESS(status)) {
    return FALSE;
    }
    status = RtlIntegerToUnicodeString(ParallelPortNumber + 1, 10, &linkDigits);
    if (!NT_SUCCESS(status)) {
    return FALSE;
    }

    // Make the port name.

    PortName->Length = 0;
    PortName->MaximumLength = prefix.Length + portSuffix.Length +
                  digits.Length + sizeof(WCHAR);
    PortName->Buffer = ExAllocatePool(PagedPool, PortName->MaximumLength);
    if (!PortName->Buffer) {
    return FALSE;
    }
    RtlZeroMemory(PortName->Buffer, PortName->MaximumLength);
    RtlAppendUnicodeStringToString(PortName, &prefix);
    RtlAppendUnicodeStringToString(PortName, &portSuffix);
    RtlAppendUnicodeStringToString(PortName, &digits);


    // Make the class name.

    ClassName->Length = 0;
    ClassName->MaximumLength = prefix.Length + classSuffix.Length +
                   digits.Length + sizeof(WCHAR);
    ClassName->Buffer = ExAllocatePool(PagedPool, ClassName->MaximumLength);
    if (!ClassName->Buffer) {
    ExFreePool(PortName->Buffer);
    return FALSE;
    }
    RtlZeroMemory(ClassName->Buffer, ClassName->MaximumLength);
    RtlAppendUnicodeStringToString(ClassName, &prefix);
    RtlAppendUnicodeStringToString(ClassName, &classSuffix);
    RtlAppendUnicodeStringToString(ClassName, &digits);


    // Make the link name.

    LinkName->Length = 0;
    LinkName->MaximumLength = linkPrefix.Length + linkSuffix.Length +
                 linkDigits.Length + sizeof(WCHAR);
    LinkName->Buffer = ExAllocatePool(PagedPool, LinkName->MaximumLength);
    if (!LinkName->Buffer) {
    ExFreePool(PortName->Buffer);
    ExFreePool(ClassName->Buffer);
    return FALSE;
    }
    RtlZeroMemory(LinkName->Buffer, LinkName->MaximumLength);
    RtlAppendUnicodeStringToString(LinkName, &linkPrefix);
    RtlAppendUnicodeStringToString(LinkName, &linkSuffix);
    RtlAppendUnicodeStringToString(LinkName, &linkDigits);

    return TRUE;
}

VOID
ParReleasePortInfoToPortDevice(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine will release the port information back to the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO,
                    Extension->PortDeviceObject,
                    NULL, 0, NULL, 0,
                    TRUE, &event, &ioStatus);

    if (!irp) {
    return;
    }

    status = IoCallDriver(Extension->PortDeviceObject, irp);

    if (!NT_SUCCESS(status)) {
    return;
    }

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
}

NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine will request the port information from the port driver
    and fill it in the device extension.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - Success.
    !STATUS_SUCCESS - Failure.

--*/

{
    KEVENT                      event;
    PIRP                        irp;
    PARALLEL_PORT_INFORMATION   portInfo;
    IO_STATUS_BLOCK             ioStatus;
    NTSTATUS                    status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO,
                    Extension->PortDeviceObject,
                    NULL, 0, &portInfo,
                    sizeof(PARALLEL_PORT_INFORMATION),
                    TRUE, &event, &ioStatus);

    if (!irp) {
    return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Extension->PortDeviceObject, irp);

    if (!NT_SUCCESS(status)) {
    return status;
    }

    status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(status)) {
    return status;
    }

    Extension->OriginalController = portInfo.OriginalController;
    Extension->Controller = portInfo.Controller;
    Extension->SpanOfController = portInfo.SpanOfController;
    Extension->FreePort = portInfo.FreePort;
    Extension->FreePortContext = portInfo.Context;

    if (Extension->SpanOfController < PARALLEL_REGISTER_SPAN) {
    return STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

VOID
ParCompleteRequest(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP  Irp
    )

/*++

Routine Description:

    This routine completes the 'CurrentIrp' after it was returned
    from the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    // DbgPrint("ParVDMCompleteRequest: Enter with irp = %#08x\n", Irp);
    //
    // If the allocate failed, then fail this request
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        // failed to allocate port, release port info back to port driver
        // and paged ourselves out.
        ParReleasePortInfoToPortDevice(Extension);
        ParReleaseDriver();
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        Extension->CreateOpenLock = 0;
        return;
    }

    //
    // This is where the driver specific stuff should go.  The driver
    // has exclusive access to the parallel port in this space.
    //

    // DbgPrint("ParVDMCompleteRequest: We own the port\n");
    Extension->PortOwned = TRUE;

    //
    // Complete the IRP, free the port, and start up the next IRP in
    // the queue.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_PARALLEL_INCREMENT);

    return;
}


VOID
ParCancel(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This is the cancel routine for this driver.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for create requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS          - Success.
    STATUS_NOT_A_DIRECTORY  - This device is not a directory.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    //
    // Enforce exclusive access to this device
    //
    if( InterlockedExchange( &extension->CreateOpenLock, 1 ) ) {
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_ACCESS_DENIED;
    }

    if(extension->PortOwned) {
        //
        // Do an early exit if we can detect that another client has
        //   already acquired the port for exclusive use.
        //
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        extension->CreateOpenLock = 0;
        return STATUS_ACCESS_DENIED;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MajorFunction == IRP_MJ_CREATE &&
    irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE) {
        //
        // Bail out if client thinks that we are a directory.
        //
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        extension->CreateOpenLock = 0;
        return STATUS_NOT_A_DIRECTORY;
    }

    // DVDF - open FILE against parport device
    status = ParOpenFileAgainstParport( extension );
    if( !NT_SUCCESS( status ) ) {
        //
        // We couldn't open a handle to the parport device - bail out
        //
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        extension->CreateOpenLock = 0;
        return STATUS_ACCESS_DENIED;
    }

    //Lock in driver code
    ParClaimDriver();

    // lock in ParPort driver
    ParGetPortInfoFromPortDevice(extension);

    // try to allocate the port for our exclusive use
    status = ParAllocPort(extension, Irp);

    // DbgPrint("ParVDMDeviceControl: ParAllocPort returned %#08lx\n");

    if( !NT_SUCCESS( status ) ) {
        extension->CreateOpenLock = 0;
    }
    return status;
}


NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PDEVICE_EXTENSION   extension;
    NTSTATUS            statusOfWait;


    extension = DeviceObject->DeviceExtension;

    if (!extension->PortOwned)
        return STATUS_ACCESS_DENIED;


    // free the port for other uses
    extension->FreePort(extension->FreePortContext);
    extension->PortOwned = FALSE;

    // Allow the port driver to be paged.
    ParReleasePortInfoToPortDevice(extension);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    // DVDF - close our FILE
    ParCloseFileAgainstParport(extension);

    // Unlock the code that was locked during the open.

    ParReleaseDriver();

    // DbgPrint("ParVDMClose: Close device, we no longer own the port\n");

    extension->CreateOpenLock = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
ParAllocateCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    )

/*++

Routine Description:

    This is the completion routine for the device control request.
    This driver has exclusive access to the parallel port in this
    routine.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

    Extension       - Supplies the device extension.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    KIRQL               oldIrql;
    LONG                irpRef;

    if( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    ParCompleteRequest(Extension, Irp);

    // If the IRP was completed.  It was completed with 'IoCompleteRequest'.

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PIRP Irp
    )

/*++

Routine Description:

    This routine takes the 'CurrentIrp' and sends it down to the
    port driver as an allocate parallel port request.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  nextSp;
    // DbgPrint("ParVDMAllocPort: Entry\n");

    nextSp = IoGetNextIrpStackLocation(Irp);
    nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextSp->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE;

    IoSetCompletionRoutine(Irp,
               ParAllocateCompletionRoutine,
               Extension, TRUE, TRUE, TRUE);

    // DbgPrint("ParVDMAllocPort: Sending Request and exiting\n");
    return IoCallDriver(Extension->PortDeviceObject, Irp);
}

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_PENDING  - Request pending.

--*/

{
    PDEVICE_EXTENSION   extension;
    PIO_STACK_LOCATION  currentStack;
    NTSTATUS            status = STATUS_INVALID_PARAMETER;

    extension = DeviceObject->DeviceExtension;
    currentStack = IoGetCurrentIrpStackLocation(Irp);

    switch(currentStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_VDM_PAR_WRITE_DATA_PORT: {

        // DbgPrint("ParVDMDeviceControl: IOCTL_VDM_PAR_WRITE_DATA_PORT\n");
        if(extension->PortOwned) {
        UCHAR *data = (PUCHAR) Irp->AssociatedIrp.SystemBuffer;
        ULONG length = currentStack->Parameters.DeviceIoControl.InputBufferLength;

        Irp->IoStatus.Information = 0;

        if (length == 1) {
            WRITE_PORT_UCHAR(extension->Controller +
                     PARALLEL_DATA_OFFSET,
                     *data);
        } else {

            for(; length != 0; length--, data++) {
            WRITE_PORT_UCHAR(extension->Controller +
                     PARALLEL_DATA_OFFSET,
                     *data);
            // KeStallExecutionProcessor(1);
            }
        }

        status = STATUS_SUCCESS;

        } else {

        status = STATUS_ACCESS_DENIED;

        }

        break;
    }

    case IOCTL_VDM_PAR_READ_STATUS_PORT: {

        // DbgPrint("ParVDMDeviceControl: IOCTL_VDM_PAR_READ_STATUS_PORT\n");
        if (extension->PortOwned) {

        if(currentStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(UCHAR)) {

            *(PUCHAR)(Irp->AssociatedIrp.SystemBuffer) =
            READ_PORT_UCHAR(extension->Controller +
                    PARALLEL_STATUS_OFFSET);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(UCHAR);

        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        } else {
        status = STATUS_ACCESS_DENIED;
        }
        break;
    }

    case IOCTL_VDM_PAR_WRITE_CONTROL_PORT: {

        // DbgPrint("ParVDMDeviceControl: IOCTL_VDM_PAR_WRITE_CONTROL_PORT\n");
        if(extension->PortOwned) {

        if(currentStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(UCHAR)) {

            WRITE_PORT_UCHAR(
            extension->Controller + PARALLEL_CONTROL_OFFSET,
            *(PUCHAR)(Irp->AssociatedIrp.SystemBuffer)
            );

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(UCHAR);
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        } else {
        status = STATUS_ACCESS_DENIED;
        }
        break;
    }

    default: {
        // DbgPrint("ParVDMDeviceControl: Unknown IOCTL\n");
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    }

    // DbgPrint("ParVDMDeviceControl: Exit with status %#08lx\n", status);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_PARALLEL_INCREMENT);
    return status;
}

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine loops through the device list and cleans up after
    each of the devices.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT                      currentDevice;
    PDEVICE_EXTENSION                   extension;
    KEVENT                              event;
    PARALLEL_INTERRUPT_SERVICE_ROUTINE  interruptService;
    PIRP                                irp;
    IO_STATUS_BLOCK                     ioStatus;

    while (currentDevice = DriverObject->DeviceObject) {

    extension = currentDevice->DeviceExtension;

    if (extension->CreatedSymbolicLink) {
        IoDeleteSymbolicLink(&extension->SymbolicLinkName);
        ExFreePool(extension->SymbolicLinkName.Buffer);
    }

        if( extension->ParPortName.Buffer ) {
            RtlFreeUnicodeString( &extension->ParPortName );
        }

    IoDeleteDevice(currentDevice);
    }

    if( OpenCloseMutex ) {
        ExFreePool( OpenCloseMutex );
        OpenCloseMutex = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parvdm\test\test.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    chngcnt.c

Abstract:

        User mode program to retrive media change counts from a scsi driver

Author:

    13-May-1995 Peter Wieland (peterwie)

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include <winioctl.h>
#include <ntddpar.h>
#include "..\..\..\..\inc\ntddvdm.h"

int __cdecl main(int argc, char *argv[])       {

    HANDLE h;
    ULONG in;
    ULONG out;
    ULONG bytesBack;
    UCHAR cmd;
    ULONG num;
    UCHAR buf[128];

    ULONG ioctlCode;

    h = CreateFile(argv[1], 
                   GENERIC_READ | GENERIC_WRITE, 
                   FILE_SHARE_READ | FILE_SHARE_WRITE, 
                   NULL, 
                   OPEN_EXISTING, 
                   FILE_ATTRIBUTE_NORMAL, 
                   NULL);

    if(h == INVALID_HANDLE_VALUE) {
        printf("Error [%d] opening device %s\n", GetLastError(), argv[1]);
        return -1;
    }

    do {

        printf("Command>");
        fflush(stdout);

        if((gets(buf) == NULL) && (feof(stdin))) {
            printf("EOF - exiting\n");
            break;
        }

        cmd = 'x';
        num = 75;
        bytesBack = 0;
        in = out = 0xff;

        sscanf(buf, "%c %d", &cmd, &num);

        switch(cmd) {

            case 'c': {

		printf("IOCTL_VDM_PAR_WRITE_CONTROL_PORT %d\n", num);
		ioctlCode = IOCTL_VDM_PAR_WRITE_CONTROL_PORT;
                in = num;
                break;
            }

            case 's': {

		printf("IOCTL_VDM_PAR_READ_STATUS_PORT\n");
		ioctlCode = IOCTL_VDM_PAR_READ_STATUS_PORT;
                out = 0;
                break;
            }

            case 'w': {

		printf("IOCTL_VDM_PAR_WRITE_DATA_PORT %d\n", num);
		ioctlCode = IOCTL_VDM_PAR_WRITE_DATA_PORT;
                in = num;
                break;
            }

            case 'q': {
                printf("Quitting\n");
                goto Done;
                break;
            }

            default: {

                printf("Unknown command %c\n", cmd);
                ioctlCode = 0;
                break;
            }
        }
                
        if(ioctlCode == 0) {
            continue;
        }

        if(!DeviceIoControl(h, 
                            ioctlCode, 
                            &in, 
                            sizeof(in), 
                            &out,
                            sizeof(out),
                            &bytesBack,
                            NULL )) {
            printf("Error [%d] sending ioctl\n", GetLastError());
            continue;
        } else {
            printf("Ioctl sent - %d bytes back - %d back\n", bytesBack,  out);
        }
    } while(TRUE);

Done:

    CloseHandle(h);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\utils.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       util.c
//
//--------------------------------------------------------------------------

#include "pch.h"

#define		IDMFG				0
#define		IDMDL				1
#define		NUMOFBROTHERPRODUCT	14


CHAR *XflagOnEvent24Devices[NUMOFBROTHERPRODUCT][2] =
{

	//	Brother
      {"Brother",		"MFC"	},				//	0
      {"Brother",		"FAX"	},				//	1
      {"Brother",		"HL-P"	},				//	2
      {"Brother",		"DCP"	},				//	3
	//	PB
      {"PitneyBowes",	"1630"	},				//	4
      {"PitneyBowes",	"1640"	},				//	5
	//	LEGEND
      {"LEGEND",		"LJ6112MFC"	},			//	6
      {"LEGEND",		"LJ6212MFC"	},			//	7
	//
      {"HBP",			"MFC 6550"	},			//	8
      {"HBP",			"OMNI L621"	},			//	9
      {"HBP",			"LJ 6106MFC"	},		//	10
      {"HBP",			"LJ 6206MFC"	},		//	11

	// P2500
      {"Legend",		"LJ6012MFP"	},			//	12

	//Terminater
      {NULL,		NULL	}					//	13
	
};
    

NTSTATUS
PptAcquireRemoveLockOrFailIrp(PDEVICE_OBJECT DevObj, PIRP Irp)
{
    PFDO_EXTENSION   fdx    = DevObj->DeviceExtension;
    NTSTATUS         status = PptAcquireRemoveLock( &fdx->RemoveLock, Irp );

    if( status != STATUS_SUCCESS ) {
        P4CompleteRequest( Irp, status, Irp->IoStatus.Information );
    }
    return status;
}

NTSTATUS
PptDispatchPreProcessIrp(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
/*++

    - Acquire removelock
    - If(!Special Handling IRP) {
          check if we are running, stalled
         

--*/
{
    PFDO_EXTENSION Fdx = DevObj->DeviceExtension;
    NTSTATUS status = PptAcquireRemoveLock(&Fdx->RemoveLock, Irp);
    UNREFERENCED_PARAMETER(DevObj);
    UNREFERENCED_PARAMETER(Irp);


        if ( !NT_SUCCESS( status ) ) {
            //
            // Someone gave us a pnp irp after a remove.  Unthinkable!
            //
            PptAssertMsg("Someone gave us a PnP IRP after a Remove",FALSE);
            P4CompleteRequest( Irp, status, 0 );
        }

    return status;
}

NTSTATUS
PptSynchCompletionRoutine(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++
      
Routine Description:
      
    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.
      
Arguments:
      
    DriverObject - Pointer to driver object created by system.
      
    Irp          - Irp that just completed
      
    Event        - Event we'll signal to say Irp is done
      
Return Value:
      
    None.
      
--*/
{
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( DevObj );

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    return (STATUS_MORE_PROCESSING_REQUIRED);
}

PWSTR
PptGetPortNameFromPhysicalDeviceObject(
  PDEVICE_OBJECT PhysicalDeviceObject
)

/*++

Routine Description:

    Retrieve the PortName for the ParPort from the registry. This PortName
      will be used as the symbolic link name for the end of chain device 
      object created by ParClass for this ParPort.

    *** This function allocates pool. ExFreePool must be called when
          result is no longer needed.

Arguments:

    PortDeviceObject - The ParPort Device Object

Return Value:

    PortName - if successful
    NULL     - otherwise

--*/

{
    NTSTATUS                    status;
    HANDLE                      hKey;
    PKEY_VALUE_FULL_INFORMATION buffer;
    ULONG                       bufferLength;
    ULONG                       resultLength;
    PWSTR                       valueNameWstr;
    UNICODE_STRING              valueName;
    PWSTR                       portName = NULL;

    PAGED_CODE ();

    //
    // try to open the registry key
    //

    status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &hKey);

    if( !NT_SUCCESS(status) ) {
        // unable to open key, bail out
        DD(NULL,DDT,"PptGetPortNameFromPhysicalDeviceObject(): FAIL w/status = %x\n", status);
        return NULL;    
    }

    //
    // we have a handle to the registry key
    //
    // loop trying to read registry value until either we succeed or
    //   we get a hard failure, grow the result buffer as needed
    //

    bufferLength  = 0;          // we will ask how large a buffer we need
    buffer        = NULL;
    valueNameWstr = (PWSTR)L"PortName";
    RtlInitUnicodeString(&valueName, valueNameWstr);
    status        = STATUS_BUFFER_TOO_SMALL;

    while(status == STATUS_BUFFER_TOO_SMALL) {

      status = ZwQueryValueKey(hKey,
                               &valueName,
                               KeyValueFullInformation,
                               buffer,
                               bufferLength,
                               &resultLength);

      if(status == STATUS_BUFFER_TOO_SMALL) {
          // 
          // buffer too small, free it and allocate a larger buffer
          //
          if(buffer) ExFreePool(buffer);
          buffer       = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, resultLength);
          bufferLength = resultLength;
          if(!buffer) {
              // unable to allocate pool, clean up and exit
              ZwClose(hKey);
              return NULL;
          }
      }
      
    } // end while BUFFER_TOO_SMALL

    
    //
    // query is complete
    //

    // no longer need the handle so close it
    ZwClose(hKey);

    // check the status of our query
    if( !NT_SUCCESS(status) ) {
        if(buffer) ExFreePool(buffer);
        return NULL;
    }

    // make sure we have a buffer
    if( buffer ) {

        // sanity check our result
        if( (buffer->Type != REG_SZ) || (!buffer->DataLength) ) {
            ExFreePool(buffer);       // query succeeded, so we know we have a buffer
            return NULL;
        }
    

        // 
        // result looks ok, copy PortName to its own allocation of the proper size
        //   and return a pointer to it
        //

        portName = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, buffer->DataLength);

        if(!portName) {
            // unable to allocate pool, clean up and exit
            ExFreePool(buffer);
            return NULL;
        }

        RtlCopyMemory(portName, (PUCHAR)buffer + buffer->DataOffset, buffer->DataLength);

        ExFreePool( buffer );
    }

    return portName;
}

NTSTATUS
PptConnectInterrupt(
    IN  PFDO_EXTENSION   Fdx
    )

/*++
      
Routine Description:
      
    This routine connects the port interrupt service routine
      to the interrupt.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    NTSTATUS code.
      
--*/
    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (!Fdx->FoundInterrupt) {
        
        return STATUS_NOT_SUPPORTED;
        
    }
    
    //
    // Connect the interrupt.
    //
    
    Status = IoConnectInterrupt(&Fdx->InterruptObject,
                                PptInterruptService,
                                Fdx,
                                NULL,
                                Fdx->InterruptVector,
                                Fdx->InterruptLevel,
                                Fdx->InterruptLevel,
                                Fdx->InterruptMode,
                                TRUE,
                                Fdx->InterruptAffinity,
                                FALSE);
    
    if (!NT_SUCCESS(Status)) {
        
        PptLogError(Fdx->DeviceObject->DriverObject,
                    Fdx->DeviceObject,
                    Fdx->PortInfo.OriginalController,
                    PhysicalZero, 0, 0, 0, 14,
                    Status, PAR_INTERRUPT_CONFLICT);
        
    }
    
    return Status;
}

VOID
PptDisconnectInterrupt(
    IN  PFDO_EXTENSION   Fdx
    )

/*++
      
Routine Description:
      
    This routine disconnects the port interrupt service routine
      from the interrupt.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    None.
      
--*/
    
{
    IoDisconnectInterrupt(Fdx->InterruptObject);
}

BOOLEAN
PptSynchronizedIncrement(
    IN OUT  PVOID   SyncContext
    )

/*++
      
Routine Description:
      
    This routine increments the 'Count' variable in the context and returns
      its new value in the 'NewCount' variable.
      
Arguments:
      
    SyncContext - Supplies the synchronize count context.
      
Return Value:
      
    TRUE
      
--*/
    
{
    ((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->NewCount =
        ++(*(((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->Count));
    return(TRUE);
}

BOOLEAN
PptSynchronizedDecrement(
    IN OUT  PVOID   SyncContext
    )

/*++
      
Routine Description:
      
    This routine decrements the 'Count' variable in the context and returns
      its new value in the 'NewCount' variable.
      
Arguments:
      
    SyncContext - Supplies the synchronize count context.
      
Return Value:
      
    TRUE
      
--*/
    
{
    ((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->NewCount =
        --(*(((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->Count));
    return(TRUE);
}

BOOLEAN
PptSynchronizedRead(
    IN OUT  PVOID   SyncContext
    )

/*++
      
Routine Description:
      
    This routine reads the 'Count' variable in the context and returns
      its value in the 'NewCount' variable.
      
Arguments:
      
    SyncContext - Supplies the synchronize count context.
      
Return Value:
      
    None.
      
--*/
    
{
    ((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->NewCount =
        *(((PSYNCHRONIZED_COUNT_CONTEXT) SyncContext)->Count);
    return(TRUE);
}

BOOLEAN
PptSynchronizedQueue(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
      
    This routine adds the given list entry to the given list.
      
Arguments:
      
    Context - Supplies the synchronized list context.
      
Return Value:
      
    TRUE
      
--*/
    
{
    PSYNCHRONIZED_LIST_CONTEXT  ListContext;
    
    ListContext = Context;
    InsertTailList(ListContext->List, ListContext->NewEntry);
    return(TRUE);
}

BOOLEAN
PptSynchronizedDisconnect(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
    
    This routine removes the given list entry from the ISR
      list.
      
Arguments:
      
    Context - Supplies the synchronized disconnect context.
      
Return Value:
      
    FALSE   - The given list entry was not removed from the list.
    TRUE    - The given list entry was removed from the list.
      
--*/
    
{
    PSYNCHRONIZED_DISCONNECT_CONTEXT    DisconnectContext;
    PKSERVICE_ROUTINE                   ServiceRoutine;
    PVOID                               ServiceContext;
    PLIST_ENTRY                         Current;
    PISR_LIST_ENTRY                     ListEntry;
    
    DisconnectContext = Context;
    ServiceRoutine = DisconnectContext->IsrInfo->InterruptServiceRoutine;
    ServiceContext = DisconnectContext->IsrInfo->InterruptServiceContext;
    
    for (Current = DisconnectContext->Extension->IsrList.Flink;
         Current != &(DisconnectContext->Extension->IsrList);
         Current = Current->Flink) {
        
        ListEntry = CONTAINING_RECORD(Current, ISR_LIST_ENTRY, ListEntry);
        if (ListEntry->ServiceRoutine == ServiceRoutine &&
            ListEntry->ServiceContext == ServiceContext) {
            
            RemoveEntryList(Current);
            return TRUE;
        }
    }
    
    return FALSE;
}

VOID
PptCancelRoutine(
    IN OUT  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp
    )

/*++
      
Routine Description:
      
    This routine is called on when the given IRP is cancelled.  It
      will dequeue this IRP off the work queue and complete the
      request as CANCELLED.  If it can't get if off the queue then
      this routine will ignore the CANCEL request since the IRP
      is about to complete anyway.
      
Arguments:
      
    DeviceObject    - Supplies the device object.
      
    Irp             - Supplies the IRP.
      
Return Value:
      
    None.
      
--*/
    
{
    PFDO_EXTENSION           Fdx = DeviceObject->DeviceExtension;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    
    DD((PCE)Fdx,DDT,"CANCEL IRP %x\n", Irp);
    
    SyncContext.Count = &Fdx->WorkQueueCount;
    
    if (Fdx->InterruptRefCount) {
        
        KeSynchronizeExecution( Fdx->InterruptObject, PptSynchronizedDecrement, &SyncContext );
    } else {
        PptSynchronizedDecrement( &SyncContext );
    }
    
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    IoReleaseCancelSpinLock(Irp->CancelIrql);
    
    PptReleaseRemoveLock(&Fdx->RemoveLock, Irp);

    P4CompleteRequest( Irp, STATUS_CANCELLED, 0 );
}

VOID
PptFreePortDpc(
    IN      PKDPC   Dpc,
    IN OUT  PVOID   Fdx,
    IN      PVOID   SystemArgument1,
    IN      PVOID   SystemArgument2
    )

/*++
      
Routine Description:
      
    This routine is a DPC that will free the port and if necessary
      complete an alloc request that is waiting.
      
Arguments:
      
    Dpc             - Not used.
      
    Fdx       - Supplies the device extension.
      
    SystemArgument1 - Not used.
      
    SystemArgument2 - Not used.
      
Return Value:
      
    None.
      
--*/
    
{
    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    PptFreePort(Fdx);
}

BOOLEAN
PptTryAllocatePortAtInterruptLevel(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
      
    This routine is called at interrupt level to quickly allocate
      the parallel port if it is available.  This call will fail
      if the port is not available.
      
Arguments:
      
    Context - Supplies the device extension.
      
Return Value:
      
    FALSE   - The port was not allocated.
    TRUE    - The port was successfully allocated.
     
--*/
    
{
    if (((PFDO_EXTENSION) Context)->WorkQueueCount == -1) {
        
        ((PFDO_EXTENSION) Context)->WorkQueueCount = 0;
        
        ( (PFDO_EXTENSION)Context )->WmiPortAllocFreeCounts.PortAllocates++;

        return(TRUE);
        
    } else {
        
        return(FALSE);
    }
}

VOID
PptFreePortFromInterruptLevel(
    IN  PVOID   Context
    )

/*++
      
Routine Description:
      
    This routine frees the port that was allocated at interrupt level.
      
Arguments:
      
    Context - Supplies the device extension.
      
Return Value:
      
    None.
      
--*/
    
{
    // If no one is waiting for the port then this is simple operation,
    // otherwise queue a DPC to free the port later on.
    
    if (((PFDO_EXTENSION) Context)->WorkQueueCount == 0) {
        
        ((PFDO_EXTENSION) Context)->WorkQueueCount = -1;
        
    } else {
        
        KeInsertQueueDpc(&((PFDO_EXTENSION) Context)->FreePortDpc, NULL, NULL);
    }
}

BOOLEAN
PptInterruptService(
    IN  PKINTERRUPT Interrupt,
    IN  PVOID       Fdx
    )
/*++
      
Routine Description:
      
    This routine services the interrupt for the parallel port.
      This routine will call out to all of the interrupt routines
      that connected with this device via
      IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT in order until
      one of them returns TRUE.
      
Arguments:
      
    Interrupt   - Supplies the interrupt object.
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    FALSE   - The interrupt was not handled.
    TRUE    - The interrupt was handled.
      
--*/
{
    PLIST_ENTRY      Current;
    PISR_LIST_ENTRY  IsrListEntry;
    PFDO_EXTENSION   fdx = Fdx;
    
    for( Current = fdx->IsrList.Flink; Current != &fdx->IsrList; Current = Current->Flink ) {
        
        IsrListEntry = CONTAINING_RECORD(Current, ISR_LIST_ENTRY, ListEntry);

        if (IsrListEntry->ServiceRoutine(Interrupt, IsrListEntry->ServiceContext)) {
            return TRUE;
        }
    }
    
    return FALSE;
}

BOOLEAN
PptTryAllocatePort(
    IN  PVOID   Fdx
    )

/*++
      
Routine Description:
      
    This routine attempts to allocate the port.  If the port is
      available then the call will succeed with the port allocated.
      If the port is not available the then call will fail
      immediately.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    FALSE   - The port was not allocated.
    TRUE    - The port was allocated.
      
--*/
    
{
    PFDO_EXTENSION   fdx = Fdx;
    KIRQL            CancelIrql;
    BOOLEAN          b;
    
    if (fdx->InterruptRefCount) {
        
        b = KeSynchronizeExecution( fdx->InterruptObject, PptTryAllocatePortAtInterruptLevel, fdx );
        
    } else {
        
        IoAcquireCancelSpinLock(&CancelIrql);
        b = PptTryAllocatePortAtInterruptLevel(fdx);
        IoReleaseCancelSpinLock(CancelIrql);
    }
    
    DD((PCE)fdx,DDT,"PptTryAllocatePort on %x returned %x\n", fdx->PortInfo.Controller, b);

    return b;
}

BOOLEAN
PptTraversePortCheckList(
    IN  PVOID   Fdx
    )

/*++
      
Routine Description:
      
    This routine traverses the deferred port check routines.  This
      call must be synchronized at interrupt level so that real
      interrupts are blocked until these routines are completed.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    FALSE   - The port is in use so no action taken by this routine.
    TRUE    - All of the deferred interrupt routines were called.
      
--*/
    
{
    PFDO_EXTENSION   fdx = Fdx;
    PLIST_ENTRY         Current;
    PISR_LIST_ENTRY     CheckEntry;
    
    //
    // First check to make sure that the port is still free.
    //
    if (fdx->WorkQueueCount >= 0) {
        return FALSE;
    }
    
    for (Current = fdx->IsrList.Flink;
         Current != &fdx->IsrList;
         Current = Current->Flink) {
        
        CheckEntry = CONTAINING_RECORD(Current,
                                       ISR_LIST_ENTRY,
                                       ListEntry);
        
        if (CheckEntry->DeferredPortCheckRoutine) {
            CheckEntry->DeferredPortCheckRoutine(CheckEntry->CheckContext);
        }
    }
    
    return TRUE;
}

VOID
PptFreePort(
    IN  PVOID   Fdx
    )
/*++
      
Routine Description:
      
    This routine frees the port.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    None.
      
--*/
{
    PFDO_EXTENSION              fdx = Fdx;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    KIRQL                       CancelIrql;
    PLIST_ENTRY                 Head;
    PIRP                        Irp;
    PIO_STACK_LOCATION          IrpSp;
    ULONG                       InterruptRefCount;
    PPARALLEL_1284_COMMAND      Command;
    BOOLEAN                     Allocated;

    DD((PCE)fdx,DDT,"PptFreePort\n");

    SyncContext.Count = &fdx->WorkQueueCount;
    
    IoAcquireCancelSpinLock( &CancelIrql );
    if (fdx->InterruptRefCount) {
        KeSynchronizeExecution( fdx->InterruptObject, PptSynchronizedDecrement, &SyncContext );
    } else {
        PptSynchronizedDecrement( &SyncContext );
    }
    IoReleaseCancelSpinLock( CancelIrql );

    //
    // Log the free for WMI
    //
    fdx->WmiPortAllocFreeCounts.PortFrees++;

    //
    // Port is free, check for queued ALLOCATE and/or SELECT requests
    //

    Allocated = FALSE;

    while( !Allocated && SyncContext.NewCount >= 0 ) {

        //
        // We have ALLOCATE and/or SELECT requests queued, satisfy the first request
        //
        IoAcquireCancelSpinLock(&CancelIrql);
        Head = RemoveHeadList(&fdx->WorkQueue);
        if( Head == &fdx->WorkQueue ) {
            // queue is empty - we're done - exit while loop
            IoReleaseCancelSpinLock(CancelIrql);
            break;
        }
        Irp = CONTAINING_RECORD(Head, IRP, Tail.Overlay.ListEntry);
        PptSetCancelRoutine(Irp, NULL);

        if ( Irp->Cancel ) {

            Irp->IoStatus.Status = STATUS_CANCELLED;

            // Irp was cancelled so have to get next in line
            SyncContext.Count = &fdx->WorkQueueCount;
    
            if (fdx->InterruptRefCount) {
                KeSynchronizeExecution(fdx->InterruptObject, PptSynchronizedDecrement, &SyncContext);
            } else {
                PptSynchronizedDecrement(&SyncContext);
            }

            IoReleaseCancelSpinLock(CancelIrql);

        } else {

            Allocated = TRUE;
            IoReleaseCancelSpinLock(CancelIrql);
        
            // Finding out what kind of IOCTL it was
            IrpSp = IoGetCurrentIrpStackLocation(Irp);
        
            // Check to see if we need to select a 
            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_INTERNAL_SELECT_DEVICE ) {

                // request at head of queue was a SELECT
                // so call the select function with the device command saying we already have port

                Command  = (PPARALLEL_1284_COMMAND)Irp->AssociatedIrp.SystemBuffer;
                Command->CommandFlags |= PAR_HAVE_PORT_KEEP_PORT;

                // Call Function to try to select device
                Irp->IoStatus.Status = PptTrySelectDevice( Fdx, Command );
            
            } else {
                // request at head of queue was an ALLOCATE
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            // Note that another Allocate request has been granted (WMI counts allocs)
            fdx->WmiPortAllocFreeCounts.PortAllocates++;
        }

        // Remove remove lock on Irp and Complete request whether the Irp
        // was cancelled or we acquired the port
        PptReleaseRemoveLock(&fdx->RemoveLock, Irp);
        P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
    }

    if( !Allocated ) {

        //
        // ALLOCATE/SELECT request queue was empty
        //
        IoAcquireCancelSpinLock(&CancelIrql);
        InterruptRefCount = fdx->InterruptRefCount;
        IoReleaseCancelSpinLock(CancelIrql);
        if ( InterruptRefCount ) {
            KeSynchronizeExecution( fdx->InterruptObject, PptTraversePortCheckList, fdx );
        }
    }

    return;
}

ULONG
PptQueryNumWaiters(
    IN  PVOID   Fdx
    )

/*++
      
Routine Description:
      
    This routine returns the number of irps queued waiting for
      the parallel port.
      
Arguments:
      
    Fdx   - Supplies the device extension.
      
Return Value:
      
    The number of irps queued waiting for the port.
      
--*/
    
{
    PFDO_EXTENSION           fdx = Fdx;
    KIRQL                       CancelIrql;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    LONG                        count;
    
    SyncContext.Count = &fdx->WorkQueueCount;
    if (fdx->InterruptRefCount) {
        KeSynchronizeExecution(fdx->InterruptObject,
                               PptSynchronizedRead,
                               &SyncContext);
    } else {
        IoAcquireCancelSpinLock(&CancelIrql);
        PptSynchronizedRead(&SyncContext);
        IoReleaseCancelSpinLock(CancelIrql);
    }
    
    count = (SyncContext.NewCount >= 0) ? ((ULONG)SyncContext.NewCount) : 0;

    if( fdx->FdoWaitingOnPort ) {
        ++count;
    }

    return count;
}

PVOID
PptSetCancelRoutine(PIRP Irp, PDRIVER_CANCEL CancelRoutine)
{
// #pragma warning( push )
// 4054: 'type cast' : from function pointer to data pointer
// 4055: 'type cast' : from data pointer to function pointer
// 4152:  nonstandard extension, function/data pointer conversion in expression
#pragma warning( disable : 4054 4055 4152 )
    return IoSetCancelRoutine(Irp, CancelRoutine);
    // #pragma warning( pop )
}

// this is the version from Win2k parclass
BOOLEAN
CheckPort(
    IN  PUCHAR  wPortAddr,
    IN  UCHAR   bMask,
    IN  UCHAR   bValue,
    IN  USHORT  msTimeDelay
    )
/*++

Routine Description:
    This routine will loop for a given time period (actual time is
    passed in as an arguement) and wait for the dsr to match
    predetermined value (dsr value is passed in).

Arguments:
    wPortAddr   - Supplies the base address of the parallel port + some offset.
                  This will have us point directly to the dsr (controller + 1).
    bMask       - Mask used to determine which bits we are looking at
    bValue      - Value we are looking for.
    msTimeDelay - Max time to wait for peripheral response (in ms)

Return Value:
    TRUE if a dsr match was found.
    FALSE if the time period expired before a match was found.
--*/

{
    UCHAR  dsr;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;

    // Do a quick check in case we have one stinkingly fast peripheral!
    dsr = P5ReadPortUchar(wPortAddr);
    if ((dsr & bMask) == bValue)
        return TRUE;

    Wait.QuadPart = (msTimeDelay * 10 * 1000) + KeQueryTimeIncrement();
    KeQueryTickCount(&Start);

CheckPort_Start:
    KeQueryTickCount(&End);
    dsr = P5ReadPortUchar(wPortAddr);
    if ((dsr & bMask) == bValue)
        return TRUE;

    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart)
    {
        // We timed out!!!

        // do one last check
        dsr = P5ReadPortUchar(wPortAddr);
        if ((dsr & bMask) == bValue)
            return TRUE;

#if DVRH_BUS_RESET_ON_ERROR
            BusReset(wPortAddr+1);  // Pass in the dcr address
#endif

#if DBG
            DD(NULL,DDW,"CheckPort: Timeout\n");
            {
                int i;
                for (i = 3; i < 8; i++) {
                    if ((bMask >> i) & 1) {
                        if (((bValue >> i) & 1) !=  ((dsr >> i) & 1)) {
                            DD(NULL,DDW,"Bit %d is %d and should be %d!!!\n", i, (dsr >> i) & 1, (bValue >> i) & 1);
                        }
                    }
                }
            }
#endif
        goto CheckPort_TimeOut;
    }
    goto CheckPort_Start;

CheckPort_TimeOut:

    return FALSE;    
}

NTSTATUS
PptBuildParallelPortDeviceName(
    IN  ULONG           Number,
    OUT PUNICODE_STRING DeviceName
    )
/*++
      
Routine Description:
      
    Build a Device Name of the form: \Device\ParallelPortN
      
    *** On success this function returns allocated memory that must be freed by the caller

Arguments:
      
    DriverObject          - ParPort driver object
    PhysicalDeviceObject  - PDO whose stack the ParPort FDO will attach to
    DeviceObject          - ParPort FDO
    UniNameString         - the DeviceName (e.g., \Device\ParallelPortN)
    PortName              - the "LPTx" PortName from the devnode
    PortNumber            - the "N" in \Device\ParallelPortN
      
Return Value:
      
    STATUS_SUCCESS on success

    error status otherwise
      
--*/
{
    UNICODE_STRING      uniDeviceString;
    UNICODE_STRING      uniBaseNameString;
    UNICODE_STRING      uniPortNumberString;
    WCHAR               wcPortNum[10];
    NTSTATUS            status;

    //
    // Init strings
    //
    RtlInitUnicodeString( DeviceName, NULL );
    RtlInitUnicodeString( &uniDeviceString, (PWSTR)L"\\Device\\" );
    RtlInitUnicodeString( &uniBaseNameString, (PWSTR)DD_PARALLEL_PORT_BASE_NAME_U );


    //
    // Convert Port Number to UNICODE_STRING
    //
    uniPortNumberString.Length        = 0;
    uniPortNumberString.MaximumLength = sizeof( wcPortNum );
    uniPortNumberString.Buffer        = wcPortNum;

    status = RtlIntegerToUnicodeString( Number, 10, &uniPortNumberString);
    if( !NT_SUCCESS( status ) ) {
        return status;
    }


    //
    // Compute size required and alloc a buffer
    //
    DeviceName->MaximumLength = (USHORT)( uniDeviceString.Length +
                                          uniBaseNameString.Length +
                                          uniPortNumberString.Length +
                                          sizeof(UNICODE_NULL) );

    DeviceName->Buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, DeviceName->MaximumLength );
    if( NULL == DeviceName->Buffer ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory( DeviceName->Buffer, DeviceName->MaximumLength );


    //
    // Catenate the parts to construct the DeviceName
    //
    RtlAppendUnicodeStringToString(DeviceName, &uniDeviceString);
    RtlAppendUnicodeStringToString(DeviceName, &uniBaseNameString);
    RtlAppendUnicodeStringToString(DeviceName, &uniPortNumberString);

    return STATUS_SUCCESS;
}

NTSTATUS
PptInitializeDeviceExtension(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN PUNICODE_STRING UniNameString,
    IN PWSTR           PortName,
    IN ULONG           PortNumber
    )
/*++
      
Routine Description:
      
    Initialize a ParPort FDO DeviceExtension
      
Arguments:
      
    DriverObject          - ParPort driver object
    PhysicalDeviceObject  - PDO whose stack the ParPort FDO will attach to
    DeviceObject          - ParPort FDO
    UniNameString         - the DeviceName (e.g., \Device\ParallelPortN)
    PortName              - the "LPTx" PortName from the devnode
    PortNumber            - the "N" in \Device\ParallelPortN
      
Return Value:
      
    STATUS_SUCCESS on success

    error status otherwise
      
--*/
{
    PFDO_EXTENSION Fdx = DeviceObject->DeviceExtension;

    RtlZeroMemory( Fdx, sizeof(FDO_EXTENSION) );

    //
    // Signature1 helps confirm that we are looking at a Parport DeviceExtension
    //
    Fdx->Signature1 = PARPORT_TAG;
    Fdx->Signature2 = PARPORT_TAG;

    //
    // Standard Info
    //
    Fdx->DriverObject         = DriverObject;
    Fdx->PhysicalDeviceObject = PhysicalDeviceObject;
    Fdx->DeviceObject         = DeviceObject;
    Fdx->PnpInfo.PortNumber   = PortNumber; // this is the "N" in \Device\ParallelPortN

    //
    // We are an FDO
    //
    Fdx->DevType = DevTypeFdo;

    //
    // Mutual Exclusion initialization
    //
    IoInitializeRemoveLock(&Fdx->RemoveLock, PARPORT_TAG, 1, 10);
    ExInitializeFastMutex(&Fdx->OpenCloseMutex);
    ExInitializeFastMutex(&Fdx->ExtensionFastMutex);

    //
    // chipset detection initialization - redundant, but safer
    //
    Fdx->NationalChipFound = FALSE;
    Fdx->NationalChecked   = FALSE;

    //
    // List Head for List of PDOs to delete during driver unload, if not before
    //
    InitializeListHead(&Fdx->DevDeletionListHead);

    //
    // Initialize 'WorkQueue' - a Queue for Allocate and Select requests
    //
    InitializeListHead(&Fdx->WorkQueue);
    Fdx->WorkQueueCount = -1;

    //
    // Initialize Exports - Exported via Internal IOCTLs
    //
    Fdx->PortInfo.FreePort            = PptFreePort;
    Fdx->PortInfo.TryAllocatePort     = PptTryAllocatePort;
    Fdx->PortInfo.QueryNumWaiters     = PptQueryNumWaiters;
    Fdx->PortInfo.Context             = Fdx;

    Fdx->PnpInfo.HardwareCapabilities = PPT_NO_HARDWARE_PRESENT;
    Fdx->PnpInfo.TrySetChipMode       = PptSetChipMode;
    Fdx->PnpInfo.ClearChipMode        = PptClearChipMode;
    Fdx->PnpInfo.TrySelectDevice      = PptTrySelectDevice;
    Fdx->PnpInfo.DeselectDevice       = PptDeselectDevice;
    Fdx->PnpInfo.Context              = Fdx;
    Fdx->PnpInfo.PortName             = PortName;

    //
    // Save location info in common extension
    //
    {
        ULONG bufLen = sizeof("LPTxF");
        PCHAR buffer = ExAllocatePool( NonPagedPool, bufLen );
        if( buffer ) {
            RtlZeroMemory( buffer, bufLen );
            _snprintf( buffer, bufLen, "%.4SF", PortName );
            Fdx->Location = buffer;
        }
    }

    //
    // Empty list of interrupt service routines, interrupt NOT connected
    //
    InitializeListHead( &Fdx->IsrList );
    Fdx->InterruptObject   = NULL;
    Fdx->InterruptRefCount = 0;

    //
    // Initialize the free port DPC.
    //
    KeInitializeDpc( &Fdx->FreePortDpc, PptFreePortDpc, Fdx );

    //
    // Save Device Name in our extension
    //
    {
        ULONG bufferLength = UniNameString->MaximumLength + sizeof(UNICODE_NULL);
        Fdx->DeviceName.Buffer = ExAllocatePool(NonPagedPool, bufferLength);
        if( !Fdx->DeviceName.Buffer ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlZeroMemory( Fdx->DeviceName.Buffer, bufferLength );
        Fdx->DeviceName.Length        = 0;
        Fdx->DeviceName.MaximumLength = UniNameString->MaximumLength;
        RtlCopyUnicodeString( &Fdx->DeviceName, UniNameString );
    }

    //
    // Port is in default mode and mode has not been set 
    //   by a lower filter driver
    //
    Fdx->PnpInfo.CurrentMode  = INITIAL_MODE;
    Fdx->FilterMode           = FALSE;

    return STATUS_SUCCESS;
}

NTSTATUS
PptGetPortNumberFromLptName( 
    IN  PWSTR  PortName, 
    OUT PULONG PortNumber 
    )
/*++
      
Routine Description:
      
    Verify that the LptName is of the form LPTn, if so then return
    the integer value of n
      
Arguments:
      
    PortName   - the PortName extracted from the devnode - expected to be 
                   of the form: "LPTn"

    PortNumber - points to the UNLONG that will hold the result on success
      
Return Value:
      
    STATUS_SUCCESS on success - *PortNumber will contain the integer value of n

    error status otherwise
      
--*/
{
    NTSTATUS       status;
    UNICODE_STRING str;

    //
    // Verify that the PortName looks like LPTx where x is a number
    //

    if( PortName[0] != L'L' || PortName[1] != L'P' || PortName[2] != L'T' ) {
        DD(NULL,DDE,"PptGetPortNumberFromLptName - name prefix doesn't look like LPT\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // prefix is LPT, check for integer suffix with value > 0
    //
    RtlInitUnicodeString( &str, (PWSTR)&PortName[3] );

    status = RtlUnicodeStringToInteger( &str, 10, PortNumber );

    if( !NT_SUCCESS( status ) ) {
        DD(NULL,DDT,"util::PptGetPortNumberFromLptName - name suffix doesn't look like an integer\n");
        return STATUS_UNSUCCESSFUL;
    }

    if( *PortNumber == 0 ) {
        DD(NULL,DDT,"util::PptGetPortNumberFromLptName - name suffix == 0 - FAIL - Invalid value\n");
        return STATUS_UNSUCCESSFUL;
    }

    DD(NULL,DDT,"util::PptGetPortNumberFromLptName - LPT name suffix= %d\n", *PortNumber);

    return STATUS_SUCCESS;
}

PDEVICE_OBJECT
PptBuildFdo( 
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject 
    )
/*++
      
Routine Description:
      
    This routine constructs and initializes a parport FDO
      
Arguments:
      
    DriverObject         - Pointer to the parport driver object
    PhysicalDeviceObject - Pointer to the PDO whose stack we will attach to
      
Return Value:
      
    Pointer to the new ParPort Device Object on Success

    NULL otherwise
      
--*/
{
    UNICODE_STRING      uniNameString = {0,0,0};
    ULONG               portNumber    = 0;
    PWSTR               portName      = NULL;
    NTSTATUS            status        = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject = NULL;

    //
    // Get the LPTx name for this port from the registry.
    //
    // The initial LPTx name for a port is determined by the ports class installer 
    //   msports.dll, but the name can subsequently be changed by the user via
    //   a device manager property page.
    //
    portName = PptGetPortNameFromPhysicalDeviceObject( PhysicalDeviceObject );
    if( NULL == portName ) {
        DD(NULL,DDE,"PptBuildFdo - get LPTx Name from registry - FAILED\n");
        goto targetExit;
    }

    //
    // Extract the preferred port number N to use for the \Device\ParallelPortN 
    //   DeviceName from the LPTx name
    //
    // Preferred DeviceName for LPT(n) is ParallelPort(n-1) - e.g., LPT3 -> ParallelPort2
    //
    status = PptGetPortNumberFromLptName( portName, &portNumber );
    if( !NT_SUCCESS( status ) ) {
        DD(NULL,DDE,"PptBuildFdo - extract portNumber from LPTx Name - FAILED\n");
        ExFreePool( portName );
        goto targetExit;
    }
    --portNumber;               // convert 1 (LPT) based number to 0 (ParallelPort) based number

    //
    // Build a DeviceName of the form: \Device\ParallelPortN
    //
    status = PptBuildParallelPortDeviceName(portNumber, &uniNameString);
    if( !NT_SUCCESS( status ) ) {
        // we couldn't make up a name - bail out
        DD(NULL,DDE,"PptBuildFdo - Build ParallelPort DeviceName - FAILED\n");
        ExFreePool( portName );
        goto targetExit;
    }

    //
    // Create the device object for this device.
    //
    status = IoCreateDevice(DriverObject, sizeof(FDO_EXTENSION), &uniNameString, 
                            FILE_DEVICE_PARALLEL_PORT, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

    
    if( STATUS_OBJECT_NAME_COLLISION == status ) {
        //
        // Preferred DeviceName already exists - try made up names
        // 

        DD(NULL,DDW,"PptBuildFdo - Initial Device Creation FAILED - Name Collision\n");

        //
        // use an offset so that our made up names won't collide with 
        //   the preferred names of ports that have not yet started
        //   (start with ParallelPort8)
        //
        #define PPT_CLASSNAME_OFFSET 7
        portNumber = PPT_CLASSNAME_OFFSET;

        do {
            RtlFreeUnicodeString( &uniNameString );
            ++portNumber;
            status = PptBuildParallelPortDeviceName(portNumber, &uniNameString);
            if( !NT_SUCCESS( status ) ) {
                // we couldn't make up a name - bail out
                DD(NULL,DDE,"PptBuildFdo - Build ParallelPort DeviceName - FAILED\n");
                ExFreePool( portName );
                goto targetExit;
            }
            DD(NULL,DDT,"PptBuildFdo - Trying Device Creation <%wZ>\n", &uniNameString);
            status = IoCreateDevice(DriverObject, sizeof(FDO_EXTENSION), &uniNameString, 
                                    FILE_DEVICE_PARALLEL_PORT, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

        } while( STATUS_OBJECT_NAME_COLLISION == status );
    }

    if( !NT_SUCCESS( status ) ) {
        // we got a failure other than a name collision - bail out
        DD(NULL,DDE,"PptBuildFdo - Device Creation FAILED - status=%x\n",status);
        deviceObject = NULL;
        ExFreePool( portName );
        goto targetExit;
    }

    //
    // We have a deviceObject - Initialize DeviceExtension
    //
    status = PptInitializeDeviceExtension( DriverObject, PhysicalDeviceObject, deviceObject, 
                                           &uniNameString, portName, portNumber );
    if( !NT_SUCCESS( status ) ) {
        // failure initializing the device extension - clean up and bail out
        DD(NULL,DDE,"PptBuildFdo - Device Initialization FAILED - status=%x\n",status);
        IoDeleteDevice( deviceObject );
        deviceObject = NULL;
        ExFreePool( portName );
        goto targetExit;
    }

    //
    // Propagate the power pagable flag of the PDO to our new FDO
    //
    if( PhysicalDeviceObject->Flags & DO_POWER_PAGABLE ) {
        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    DD(NULL,DDT,"PptBuildFdo - SUCCESS\n");

targetExit:

    RtlFreeUnicodeString( &uniNameString );

    return deviceObject;
}


VOID
PptPdoGetPortInfoFromFdo( PDEVICE_OBJECT Pdo )
{
    PPDO_EXTENSION              pdx = Pdo->DeviceExtension;
    PDEVICE_OBJECT              fdo = pdx->Fdo;
    PFDO_EXTENSION              fdx = fdo->DeviceExtension;

    pdx->OriginalController   = fdx->PortInfo.OriginalController;
    pdx->Controller           = fdx->PortInfo.Controller;
    pdx->SpanOfController     = fdx->PortInfo.SpanOfController;
    pdx->TryAllocatePort      = fdx->PortInfo.TryAllocatePort;
    pdx->FreePort             = fdx->PortInfo.FreePort;
    pdx->QueryNumWaiters      = fdx->PortInfo.QueryNumWaiters;
    pdx->PortContext          = fdx->PortInfo.Context;
    
    pdx->EcrController        = fdx->PnpInfo.EcpController;
    pdx->HardwareCapabilities = fdx->PnpInfo.HardwareCapabilities;
    pdx->TrySetChipMode       = fdx->PnpInfo.TrySetChipMode;
    pdx->ClearChipMode        = fdx->PnpInfo.ClearChipMode;
    pdx->TrySelectDevice      = fdx->PnpInfo.TrySelectDevice;
    pdx->DeselectDevice       = fdx->PnpInfo.DeselectDevice;
    pdx->FifoDepth            = fdx->PnpInfo.FifoDepth;
    pdx->FifoWidth            = fdx->PnpInfo.FifoWidth;
}


VOID
P4WritePortNameToDevNode( PDEVICE_OBJECT Pdo, PCHAR Location )
{
    HANDLE          handle;
    NTSTATUS        status;
    WCHAR           portName[8]; // expect: L"LPTx:" (L"LPTx.y:" for DaisyChain PDOs)
    PPDO_EXTENSION  pdx = Pdo->DeviceExtension;
                
    RtlZeroMemory( portName, sizeof(portName) );
    
    PptAssert( NULL != Location );

    switch( pdx->PdoType ) {

    case PdoTypeLegacyZip:
    case PdoTypeDaisyChain:
        // At least one vendor uses the y from LPTx.y to determine the
        // location of their device in the 1284.3 daisy chain.  We
        // have chastised this vendor for using this undocumented
        // interface and they have apologized profusely and promised
        // to try to avoid using undocumented interfaces in the future
        // (at least without telling us that they are doing so).
        _snwprintf( portName, sizeof(portName)/sizeof(WCHAR), L"%.6S:\0", Location );
        PptAssert( 7 == wcslen(portName) );
        break;

    case PdoTypeRawPort:
    case PdoTypeEndOfChain:
        // don't confuse printing with the .4 suffix for an EndOfChain device
        _snwprintf( portName, sizeof(portName)/sizeof(WCHAR), L"%.4S:\0", Location );
        PptAssert( 5 == wcslen(portName) );
        break;

    default:
        DD((PCE)pdx,DDE,"P4WritePortNameToDevNode - invalid pdx->PdoType\n");
    }
    
    PptAssert( wcsncmp( portName, L"LPT", sizeof(L"LPT")/sizeof(WCHAR)) ) ;

    status = IoOpenDeviceRegistryKey( Pdo, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &handle );

    if( STATUS_SUCCESS == status ) {
        UNICODE_STRING name;
        RtlInitUnicodeString( &name, L"PortName" );
        ZwSetValueKey( handle, &name, 0, REG_SZ, portName, (wcslen(portName)+1)*sizeof(WCHAR) );
        ZwClose(handle);
    }
}                


PCHAR
P4ReadRawIeee1284DeviceId(
    IN  PUCHAR          Controller
    )
{
    IEEE_STATE ieeeState = { 0,                  // CurrentEvent
                             PHASE_FORWARD_IDLE, // CurrentPhase
                             FALSE,              // Connected in IEEE mode?
                             FALSE,              // IsIeeeTerminateOk
                             FAMILY_NONE };      // ProtocolFamily - Centronics => FAMILY_NONE
    NTSTATUS    status;
    PCHAR       devIdBuffer      = NULL;
    ULONG       bytesTransferred = 0;
    ULONG       tryCount         = 1;
    const ULONG maxTries         = 3;
    const ULONG minValidDevId    = 14; // 2 size bytes + "MFG:x;" + "MDL:y;"
    BOOLEAN     ignoreXflag        = FALSE;
    ULONG       deviceIndex;


 targetRetry:

    status = P4IeeeEnter1284Mode( Controller, ( NIBBLE_EXTENSIBILITY | DEVICE_ID_REQ ), &ieeeState );

    if( STATUS_SUCCESS == status ) {

        // Negotiation for 1284 device ID succeeded

        const ULONG  tmpBufLen        = 1024; // reasonable max length for IEEE 1284 Device ID string
        PCHAR        tmpBuf           = ExAllocatePool( PagedPool, tmpBufLen );

        if( tmpBuf ) {

            RtlZeroMemory( tmpBuf, tmpBufLen );
            
            // try to read the 1284 device ID from the peripheral

            ieeeState.CurrentPhase = PHASE_NEGOTIATION;
            status = P4NibbleModeRead( Controller, tmpBuf, tmpBufLen-1, &bytesTransferred, &ieeeState );
            
            if( NT_SUCCESS( status ) ) {

                UCHAR highLengthByte = 0xff & tmpBuf[0];
                UCHAR lowLengthByte  = 0xff & tmpBuf[1];
                PCHAR idString       = &tmpBuf[2];
                
                DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - len:%02x %02x - string:<%s>\n",highLengthByte,lowLengthByte,idString);
                
                if( highLengthByte > 2 ) {
                    
                    DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - len:%02x %02x - looks bogus - ignore this ID\n",highLengthByte,lowLengthByte);
                    devIdBuffer = NULL;
                    
                } else {
                    
                    if( bytesTransferred >= minValidDevId ) {
                        // looks like this might be a valid 1284 id
                        devIdBuffer = ExAllocatePool( PagedPool, bytesTransferred + 1 );
                        if( devIdBuffer ) {
                            ULONG length          = (highLengthByte * 256) + lowLengthByte;
                            ULONG truncationIndex = ( (length >= minValidDevId) && (length < bytesTransferred) ) ? length : bytesTransferred;
                            RtlCopyMemory( devIdBuffer, tmpBuf, bytesTransferred );
                            devIdBuffer[ truncationIndex ] = '\0';
                        } else {
                            DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4IeeeEnter1284Mode FAILED - no pool for devIdBuffer\n");
                        }
                    }
                }

            } else {
                DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4NibbleModeRead FAILED - looks like no device there\n");
            }

            ExFreePool( tmpBuf );

        } else {
            DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4IeeeEnter1284Mode FAILED - no pool for tmpBuf\n");
        }

        ieeeState.ProtocolFamily = FAMILY_REVERSE_NIBBLE;

	    //check brother product
        if(devIdBuffer && 
        	(	strstr(devIdBuffer+2,"Brother")	||
        		strstr(devIdBuffer+2,"PitneyBowes")	||
        		strstr(devIdBuffer+2,"LEGEND")	||
        		strstr(devIdBuffer+2,"Legend")	||
        		strstr(devIdBuffer+2,"HBP")		))
        {
        		
            // look for device that needs to ignore XFlag on event 24
            for(deviceIndex = 0; deviceIndex < NUMOFBROTHERPRODUCT;
            			deviceIndex++)
            {
            	if(XflagOnEvent24Devices[deviceIndex][0] == NULL)
            	{
            		break;
            	}

	            if(strstr(devIdBuffer+2,
	                		XflagOnEvent24Devices[deviceIndex][IDMFG] ) ) 
	            {
	                if(strstr(devIdBuffer+2,
	                		XflagOnEvent24Devices[deviceIndex][IDMDL] ) ) 
	                {
    	                // found a match, so set our flag and get out
	                    ignoreXflag = TRUE;
        	            break;
        	        }
                }
            }
        }

        if(ignoreXflag)
        {
            // work around Brother's firmware handling of XFlag on Event 24
            P4IeeeTerminate1284Mode( Controller, &ieeeState, IgnoreXFlagOnEvent24 );
        } else {
            // normal handling
            P4IeeeTerminate1284Mode( Controller, &ieeeState, UseXFlagOnEvent24 );
        }

    } else {
        DD(NULL,DDT,"P4ReadRawIeee1284DeviceId - P4IeeeEnter1284Mode FAILED - looks like no device there\n");
    }


    //
    // add retry if we got some bytes, but not enough for a valid ID
    //
    if( (NULL == devIdBuffer) &&                  // we didn't get an ID
        (bytesTransferred > 0 ) &&                // peripheral reported some bytes
        (bytesTransferred < minValidDevId ) &&    //   but not enough
        (tryCount < maxTries ) ) {                // we haven't exhausted our retries
            
        ++tryCount;
        bytesTransferred = 0;
        goto targetRetry;
    }

    return devIdBuffer;
}

VOID
P4ReleaseBus( PDEVICE_OBJECT Fdo )
{
    PFDO_EXTENSION fdx = Fdo->DeviceExtension;
    DD((PCE)fdx,DDT,"P4ReleaseBus\n");
    fdx->FdoWaitingOnPort = FALSE;
    if( 0 == d3 ) {
        PptFreePort( fdx );
    }
}

NTSTATUS
P4CompleteRequest(
    IN PIRP       Irp,
    IN NTSTATUS   Status,
    IN ULONG_PTR  Information 
    )
{
    P5TraceIrpCompletion( Irp );
    Irp->IoStatus.Status      = Status;
    Irp->IoStatus.Information = Information;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}


NTSTATUS
P4CompleteRequestReleaseRemLock(
    IN PIRP             Irp,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information,
    IN PIO_REMOVE_LOCK  RemLock
    )
{
    P4CompleteRequest( Irp, Status, Information );
    PptReleaseRemoveLock( RemLock, Irp );
    return Status;
}


// pcutil.c follows:


//============================================================================
// NAME:    BusReset()
//
//    Performs a bus reset as defined in Chapter 7.2 of the
//    1284-1994 spec.
//
// PARAMETERS:
//      DCRController   - Supplies the base address of of the DCR.
//
// RETURNS:
//      nothing
//============================================================================
void BusReset(
    IN  PUCHAR DCRController
    )
{
    UCHAR dcr;

    dcr = P5ReadPortUchar(DCRController);
    // Set 1284 and nInit low.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, INACTIVE, DONT_CARE, DONT_CARE);
    P5WritePortUchar(DCRController, dcr);
    KeStallExecutionProcessor(100); // Legacy Zip will hold what looks to be
                                    // a bus reset for 9us.  Since this proc is used
                                    // to trigger a logic analyzer... let's hold
                                    // for 100us
}    

BOOLEAN
CheckTwoPorts(
    PUCHAR  pPortAddr1,
    UCHAR   bMask1,
    UCHAR   bValue1,
    PUCHAR  pPortAddr2,
    UCHAR   bMask2,
    UCHAR   bValue2,
    USHORT  msTimeDelay
    )
{
    UCHAR           bPort1;
    UCHAR           bPort2;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;

    // Do a quick check in case we have one stinkingly fast peripheral!
    bPort1 = P5ReadPortUchar( pPortAddr1 );
    if ( ( bPort1 & bMask1 ) == bValue1 ) {
        return TRUE;
    }
    bPort2 = P5ReadPortUchar( pPortAddr2 );
    if ( ( bPort2 & bMask2 ) == bValue2 ) {
        return FALSE;
    }

    Wait.QuadPart = (msTimeDelay * 10 * 1000) + KeQueryTimeIncrement();
    KeQueryTickCount(&Start);

    for(;;) {
        KeQueryTickCount(&End);
        
        bPort1 = P5ReadPortUchar( pPortAddr1 );
        if ( ( bPort1 & bMask1 ) == bValue1 ) {
            return TRUE;
        }
        bPort2 = P5ReadPortUchar( pPortAddr2 );
        if ( ( bPort2 & bMask2 ) == bValue2 ) {
            return FALSE;
        }
        
        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
            // We timed out!!! -  Recheck the values
            bPort1 = P5ReadPortUchar( pPortAddr1 );
            if ( ( bPort1 & bMask1 ) == bValue1 ) {
                return TRUE;
            }
            bPort2 = P5ReadPortUchar( pPortAddr2 );
            if ( ( bPort2 & bMask2 ) == bValue2 ) {
                return FALSE;
            }
            
#if DVRH_BUS_RESET_ON_ERROR
            BusReset(pPortAddr1+1);  // Pass in the dcr address
#endif
            // Device never responded, return timeout status.
            return FALSE;
        }

    } // forever;

} // CheckPort2...


PWSTR
ParCreateWideStringFromUnicodeString(PUNICODE_STRING UnicodeString)
/*++

Routine Description:

    Create a UNICODE_NULL terminated WSTR given a UNICODE_STRING.

    This function allocates PagedPool, copies the UNICODE_STRING buffer
      to the allocation, and appends a UNICODE_NULL to terminate the WSTR
    
    *** This function allocates pool. ExFreePool must be called to free
          the allocation when the buffer is no longer needed.

Arguments:

    UnicodeString - The source

Return Value:

    PWSTR  - if successful

    NULL   - otherwise

--*/
{
    PWSTR buffer;
    ULONG length = UnicodeString->Length;

    buffer = ExAllocatePool( PagedPool, length + sizeof(UNICODE_NULL) );
    if(!buffer) {
        return NULL;      // unable to allocate pool, bail out
    } else {
        RtlCopyMemory(buffer, UnicodeString->Buffer, length);
        buffer[length/2] = UNICODE_NULL;
        return buffer;
    }
}

VOID
ParInitializeExtension1284Info(
    IN PPDO_EXTENSION Pdx
    )
// make this a function since it is now called from two places:
//  - 1) when initializing a new devobj
//  - 2) from CreateOpen
{
    USHORT i;

    Pdx->Connected               = FALSE;
    if (DefaultModes)
    {
        USHORT rev = (USHORT) (DefaultModes & 0xffff);
        USHORT fwd = (USHORT)((DefaultModes & 0xffff0000)>>16);
        
        switch (fwd)
        {
            case BOUNDED_ECP:
                Pdx->IdxForwardProtocol      = BOUNDED_ECP_FORWARD;       
                break;
            case ECP_HW_NOIRQ:
            case ECP_HW_IRQ:
                Pdx->IdxForwardProtocol      = ECP_HW_FORWARD_NOIRQ;       
                break;
            case ECP_SW:
                Pdx->IdxForwardProtocol      = ECP_SW_FORWARD;       
                break;
            case EPP_HW:
                Pdx->IdxForwardProtocol      = EPP_HW_FORWARD;       
                break;
            case EPP_SW:
                Pdx->IdxForwardProtocol      = EPP_SW_FORWARD;       
                break;
            case IEEE_COMPATIBILITY:
                Pdx->IdxForwardProtocol      = IEEE_COMPAT_MODE;
                break;
            case CENTRONICS:
            default:
                Pdx->IdxForwardProtocol      = CENTRONICS_MODE;       
                break;
        }
        
        switch (rev)
        {
            case BOUNDED_ECP:
                Pdx->IdxReverseProtocol      = BOUNDED_ECP_REVERSE;       
                break;
            case ECP_HW_NOIRQ:
            case ECP_HW_IRQ:
                Pdx->IdxReverseProtocol      = ECP_HW_REVERSE_NOIRQ;       
                break;
            case ECP_SW:
                Pdx->IdxReverseProtocol      = ECP_SW_REVERSE;       
                break;
            case EPP_HW:
                Pdx->IdxReverseProtocol      = EPP_HW_REVERSE;       
                break;
            case EPP_SW:
                Pdx->IdxReverseProtocol      = EPP_SW_REVERSE;       
                break;
            case BYTE_BIDIR:
                Pdx->IdxReverseProtocol      = BYTE_MODE;       
                break;
            case CHANNEL_NIBBLE:
            case NIBBLE:
            default:
                Pdx->IdxReverseProtocol      = NIBBLE_MODE;
                break;
        }
    }
    else
    {
        Pdx->IdxReverseProtocol      = NIBBLE_MODE;
        Pdx->IdxForwardProtocol      = CENTRONICS_MODE;
    }
    Pdx->bShadowBuffer           = FALSE;
    Pdx->ProtocolModesSupported  = 0;
    Pdx->BadProtocolModes        = 0;
    Pdx->fnRead  = NULL;
    Pdx->fnWrite = NULL;

    Pdx->ForwardInterfaceAddress = DEFAULT_ECP_CHANNEL;
    Pdx->ReverseInterfaceAddress = DEFAULT_ECP_CHANNEL;
    Pdx->SetForwardAddress       = FALSE;
    Pdx->SetReverseAddress       = FALSE;
    Pdx->bIsHostRecoverSupported = FALSE;
    Pdx->IsIeeeTerminateOk       = FALSE;

    for (i = FAMILY_NONE; i < FAMILY_MAX; i++) {
        Pdx->ProtocolData[i] = 0;
    }
}


NTSTATUS
ParBuildSendInternalIoctl(
    IN  ULONG           IoControlCode,
    IN  PDEVICE_OBJECT  TargetDeviceObject,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  ULONG           InputBufferLength,
    OUT PVOID           OutputBuffer        OPTIONAL,
    IN  ULONG           OutputBufferLength,
    IN  PLARGE_INTEGER  RequestedTimeout    OPTIONAL
    )
/*++dvdf

Routine Description:

    This routine builds and sends an Internal IOCTL to the TargetDeviceObject, waits
    for the IOCTL to complete, and returns status to the caller.

    *** WORKWORK - dvdf 12Dec98: This function does not support Input and Output in the same IOCTL

Arguments:

    IoControlCode       - the IOCTL to send
    TargetDeviceObject  - who to send the IOCTL to
    InputBuffer         - pointer to input buffer, if any
    InputBufferLength,  - length of input buffer
    OutputBuffer        - pointer to output buffer, if any
    OutputBufferLength, - length of output buffer
    Timeout             - how long to wait for request to complete, NULL==use driver global AcquirePortTimeout

Return Value:

    Status

--*/
{
    NTSTATUS           status;
    PIRP               irp;
    LARGE_INTEGER      timeout;
    KEVENT             event;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Current limitation is that this function does not handle a request with
    //   both InputBufferLength and OutputBufferLength > 0
    //
    if( InputBufferLength != 0 && OutputBufferLength != 0 ) {
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Allocate and initialize IRP
    //
    irp = IoAllocateIrp( (CCHAR)(TargetDeviceObject->StackSize + 1), FALSE );
    if( !irp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength  = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode      = IoControlCode;


    if( InputBufferLength != 0 ) {
        irp->AssociatedIrp.SystemBuffer = InputBuffer;
    } else if( OutputBufferLength != 0 ) {
        irp->AssociatedIrp.SystemBuffer = OutputBuffer;
    }


    //
    // Set completion routine and send IRP
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( irp, ParSynchCompletionRoutine, &event, TRUE, TRUE, TRUE );

    status = ParCallDriver(TargetDeviceObject, irp);

    if( !NT_SUCCESS(status) ) {
        DD(NULL,DDE,"ParBuildSendInternalIoctl - ParCallDriver FAILED w/status=%x\n",status);
        IoFreeIrp( irp );
        return status;
    }

    //
    // Set timeout and wait
    //
    //                                      user specified   : default
    timeout = (NULL != RequestedTimeout) ? *RequestedTimeout : AcquirePortTimeout;
    status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);

    //
    // Did we timeout or did the IRP complete?
    //
    if( status == STATUS_TIMEOUT ) {
        // we timed out - cancel the IRP
        IoCancelIrp( irp );
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    //
    // Irp is complete, grab the status and free the irp
    //
    status = irp->IoStatus.Status;
    IoFreeIrp( irp );

    return status;
}


UCHAR
ParInitializeDevice(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine is invoked to initialize the parallel port drive.
    It performs the following actions:

        o   Send INIT to the driver and if the device is online.

Arguments:

    Context - Really the device extension.

Return Value:

    The last value that we got from the status register.

--*/

{

    KIRQL               OldIrql;
    UCHAR               DeviceStatus = 0;
    LARGE_INTEGER       StartOfSpin = {0,0};
    LARGE_INTEGER       NextQuery   = {0,0};
    LARGE_INTEGER       Difference  = {0,0};

    //
    // Tim Wells (WestTek, L.L.C.)
    //
    // -  Removed the deferred initialization code from DriverEntry, device creation
    // code.  This code will be better utilized in the Create/Open logic or from
    // the calling application.
    //
    // -  Changed this code to always reset when asked, and to return after a fixed
    // interval reqardless of the response.  Additional responses can be provided by
    // read and write code.
    //

    //
    // Clear the register.
    //

    if (GetControl(Pdx->Controller) & PAR_CONTROL_NOT_INIT) {

        //
        // We should stall for at least 60 microseconds after the init.
        //

        KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );

        StoreControl( Pdx->Controller, (UCHAR)(PAR_CONTROL_WR_CONTROL | PAR_CONTROL_SLIN) );

        KeStallExecutionProcessor(60);
        KeLowerIrql(OldIrql);

    }

    StoreControl( Pdx->Controller, 
                  (UCHAR)(PAR_CONTROL_WR_CONTROL | PAR_CONTROL_NOT_INIT | PAR_CONTROL_SLIN) );

    //
    // Spin waiting for the device to initialize.
    //

    KeQueryTickCount(&StartOfSpin);

    do {

        KeQueryTickCount(&NextQuery);

        Difference.QuadPart = NextQuery.QuadPart - StartOfSpin.QuadPart;

        ASSERT(KeQueryTimeIncrement() <= MAXLONG);

        if (Difference.QuadPart*KeQueryTimeIncrement() >= Pdx->AbsoluteOneSecond.QuadPart) {

            //
            // Give up on getting PAR_OK.
            //

            DD((PCE)Pdx,DDT,"Did spin of one second - StartOfSpin: %x NextQuery: %x\n", StartOfSpin.LowPart,NextQuery.LowPart);

            break;
        }

        DeviceStatus = GetStatus(Pdx->Controller);

    } while (!PAR_OK(DeviceStatus));

    return (DeviceStatus);
}

VOID
ParNotInitError(
    IN PPDO_EXTENSION Pdx,
    IN UCHAR             DeviceStatus
    )

/*++

Routine Description:

Arguments:

    Pdx       - Supplies the device extension.

    deviceStatus    - Last read status.

Return Value:

    None.

--*/

{

    PIRP Irp = Pdx->CurrentOpIrp;

    if (PAR_OFF_LINE(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        DD((PCE)Pdx,DDE,"Init Error - off line - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else if (PAR_NO_CABLE(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        DD((PCE)Pdx,DDE,"Init Error - no cable - not connected - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else if (PAR_PAPER_EMPTY(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_PAPER_EMPTY;
        DD((PCE)Pdx,DDE,"Init Error - paper empty - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else if (PAR_POWERED_OFF(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_POWERED_OFF;
        DD((PCE)Pdx,DDE,"Init Error - power off - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);

    } else {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        DD((PCE)Pdx,DDE,"Init Error - not conn - STATUS/INFORMATON: %x/%x\n", Irp->IoStatus.Status, Irp->IoStatus.Information);
    }

}

VOID
ParCancelRequest(
    PDEVICE_OBJECT DevObj,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel any request in the parallel driver.

Arguments:

    DevObj - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER( DevObj );

    //
    // The only reason that this irp can be on the queue is
    // if it's not the current irp.  Pull it off the queue
    // and complete it as canceled.
    //

    ASSERT(!IsListEmpty(&Irp->Tail.Overlay.ListEntry));

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    P4CompleteRequest( Irp, STATUS_CANCELLED, 0 );

}



#if PAR_NO_FAST_CALLS
// temp debug functions so params show up on stack trace

NTSTATUS
ParCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    return IoCallDriver(DeviceObject, Irp);
}
#endif // PAR_NO_FAST_CALLS


NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ParCheckParameters(
    IN OUT  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine reads the parameters section of the registry and modifies
    the device extension as specified by the parameters.

Arguments:

    RegistryPath    - Supplies the registry path.

    Pdx       - Supplies the device extension.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE ParamTable[4];
    ULONG                    UsePIWriteLoop;
    ULONG                    UseNT35Priority;
    ULONG                    Zero = 0;
    NTSTATUS                 Status;
    HANDLE                   hRegistry;

    if (Pdx->PhysicalDeviceObject) {

        Status = IoOpenDeviceRegistryKey (Pdx->PhysicalDeviceObject,
                                          PLUGPLAY_REGKEY_DRIVER,
                                          STANDARD_RIGHTS_ALL,
                                          &hRegistry);

        if (NT_SUCCESS(Status)) {

            RtlZeroMemory(ParamTable, sizeof(ParamTable));

            ParamTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[0].Name          = (PWSTR)L"UsePIWriteLoop";
            ParamTable[0].EntryContext  = &UsePIWriteLoop;
            ParamTable[0].DefaultType   = REG_DWORD;
            ParamTable[0].DefaultData   = &Zero;
            ParamTable[0].DefaultLength = sizeof(ULONG);

            ParamTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[1].Name          = (PWSTR)L"UseNT35Priority";
            ParamTable[1].EntryContext  = &UseNT35Priority;
            ParamTable[1].DefaultType   = REG_DWORD;
            ParamTable[1].DefaultData   = &Zero;
            ParamTable[1].DefaultLength = sizeof(ULONG);

            ParamTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[2].Name          = (PWSTR)L"InitializationTimeout";
            ParamTable[2].EntryContext  = &(Pdx->InitializationTimeout);
            ParamTable[2].DefaultType   = REG_DWORD;
            ParamTable[2].DefaultData   = &Zero;
            ParamTable[2].DefaultLength = sizeof(ULONG);

            Status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                            hRegistry, ParamTable, NULL, NULL);

            if (NT_SUCCESS(Status)) {

                if(UsePIWriteLoop) {
                    Pdx->UsePIWriteLoop = TRUE;
                }

                if(UseNT35Priority) {
                    Pdx->UseNT35Priority = TRUE;
                }

                if(Pdx->InitializationTimeout == 0) {
                    Pdx->InitializationTimeout = 15;
                }
            }

        } else {
            Pdx->InitializationTimeout = 15;
        }

        ZwClose (hRegistry);

    } else {
        Pdx->InitializationTimeout = 15;
    }
}

BOOLEAN
String2Num(
    IN OUT PCHAR   *lpp_Str,
    IN     CHAR     c,
    OUT    ULONG   *num
    )
{
    int cc;
    int cnt = 0;

    DD(NULL,DDT,"String2Num. string [%s]\n", lpp_Str);
    *num = 0;
    if (!*lpp_Str) {
        *num = 0;
        return FALSE;
    }
    // At this point, we should have a string that is a
    // positive hex value.  I will not be checking for
    // validity of the string.  If peripheral handed me a
    // bogus value then I'm gonna make their life
    // miserable.
String2Num_Start:
    cc = (int)(unsigned char)**lpp_Str;
    if (cc >= '0' && cc <= '9') {    
        *num = 16 * *num + (cc - '0');    /* accumulate digit */
    } else if (cc >= 'A' && cc <= 'F') {
        *num = 16 * *num + (cc - 55);     /* accumulate digit */
    } else if (cc >= 'a' && cc <= 'f') {
        *num = 16 * *num + (cc - 87);     /* accumulate digit */
    } else if (cc == c || cc == 0) {
        *lpp_Str = 0;
        return TRUE;
    } else if (cc == 'y' || cc == 'Y') {
        *lpp_Str = 0;
        *num = (ULONG)~0;     /* Special case */
        return FALSE;
    } else {
        *lpp_Str = 0;
        *num = 0;     /* It's all messed up */
        return FALSE;
    }
    DD(NULL,DDT,"String2Num. num [%x]\n", *num);
    (*lpp_Str)++;
    if (cnt++ > 100) {
        // If our string is this large, then I'm gonna assume somethings wrong
        DD(NULL,DDE,"String2Num. String too long\n");
        goto String2Num_End;
    }
    goto String2Num_Start;

String2Num_End:
    DD(NULL,DDE,"String2Num. Something's wrong with String\n");
    *num = 0;
    return FALSE;
}

UCHAR
StringCountValues(
    IN PCHAR string, 
    IN CHAR  delimeter
    )
{
    PUCHAR  lpKey = (PUCHAR)string;
    UCHAR   cnt = 1;

    if(!string) {
        return 0;
    }

    while(*lpKey) {
        if( *lpKey==delimeter ) {
            ++cnt;
        }
        lpKey++;
    }

    return cnt;
}

PCHAR
StringChr(
    IN PCHAR string, 
    IN CHAR  c
    )
{
    if(!string) {
        return(NULL);
    }

    while(*string) {
        if( *string==c ) {
            return string;
        }
        string++;
    }

    return NULL;
}

VOID
StringSubst(
    IN PCHAR lpS,
    IN CHAR  chTargetChar,
    IN CHAR  chReplacementChar,
    IN USHORT cbS
    )
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}

VOID
ParFixupDeviceId(
    IN OUT PUCHAR DeviceId
    )
/*++

Routine Description:

    This routine parses the NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PUCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= ' ') || (*p > (UCHAR)0x7F) || (*p == ',') ) {
            *p = '_';
        }
    }
}

VOID
ParDetectDot3DataLink(
    IN  PPDO_EXTENSION   Pdx,
    IN  PCHAR DeviceId
    )
{
    PCHAR       DOT3DL   = NULL;     // 1284.3 Data Link Channels
    PCHAR       DOT3C    = NULL;     // 1284.3 Data Link Services
    PCHAR       DOT4DL   = NULL;     // 1284.4 Data Link for peripherals that were implemented prior to 1284.3
    PCHAR       CMDField = NULL;     // The command field for parsing legacy MLC
    PCHAR       DOT3M    = NULL;     // 1284 physical layer modes that will break this device

    DD((PCE)Pdx,DDT,"ParDetectDot3DataLink: DeviceId [%s]\n", DeviceId);
    ParDot3ParseDevId(&DOT3DL, &DOT3C, &CMDField, &DOT4DL, &DOT3M, DeviceId);
    ParDot3ParseModes(Pdx,DOT3M);
    if (DOT4DL) {
        DD((PCE)Pdx,DDT,"ParDot3ParseModes - 1284.4 with MLC Data Link Detected. DOT4DL [%s]\n", DOT4DL);
        ParDot4CreateObject(Pdx, DOT4DL);
    } else if (DOT3DL) {
        DD((PCE)Pdx,DDT,"ParDot4CreateObject - 1284.3 Data Link Detected DL:[%s] C:[%s]\n", DOT3DL, DOT3C);
        ParDot3CreateObject(Pdx, DOT3DL, DOT3C);
    } else if (CMDField) {
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - MLC Data Link Detected. MLC [%s]\n", CMDField);
        ParMLCCreateObject(Pdx, CMDField);
    } else {
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - No Data Link Detected\n");
    }
}

VOID
ParDot3ParseDevId(
    PCHAR   *lpp_DL,
    PCHAR   *lpp_C,
    PCHAR   *lpp_CMD,
    PCHAR   *lpp_4DL,
    PCHAR   *lpp_M,
    PCHAR   lpDeviceID
)
{
    PCHAR    lpKey = lpDeviceID;     // Pointer to the Key to look at
    PCHAR    lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.
    while (lpKey != NULL) {

        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?
        lpValue = StringChr((PCHAR)lpKey, ':');
        if( NULL == lpValue ) {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        switch (*lpKey) {
        case '1':
            // Look for DOT3 Datalink
            if((RtlCompareMemory(lpKey, "1284.4DL:", wKeyLength)==9))
            {
                *lpp_4DL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3DL:", wKeyLength)==9))
            {
                *lpp_DL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3C:", wKeyLength)==8))
            {
                *lpp_C = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3M:", wKeyLength)==8))
            {
                *lpp_M = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case '.':
            // Look for for .3 extras
            if ((RtlCompareMemory(lpKey, ".3C:", wKeyLength)==4) ) {

                *lpp_C = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if ((RtlCompareMemory(lpKey, ".3M:", wKeyLength)==4) ) {

                *lpp_M = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case 'C':
            // Look for MLC Datalink
            if( (RtlCompareMemory(lpKey, "CMD:",         wKeyLength)==4 ) ||
                (RtlCompareMemory(lpKey, "COMMAND SET:", wKeyLength)==12) ) {

                *lpp_CMD = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }

            break;

        default:
            // The key is uninteresting.  Go to the next Key
            if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;
        }
    }
}

NTSTATUS
ParPnpGetId(
    IN PCHAR DeviceIdString,
    IN ULONG Type,
    OUT PCHAR resultString,
    OUT PCHAR descriptionString OPTIONAL
    )
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS        status       = STATUS_SUCCESS;
    USHORT          checkSum     = 0;             // A 16 bit check sum
    CHAR            nodeName[16] = "LPTENUM\\";
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PCHAR           MFG = NULL;                   // Manufacturer name
    PCHAR           MDL = NULL;                   // Model name
    PCHAR           CLS = NULL;                   // Class name
    PCHAR           AID = NULL;                   // Hardare ID
    PCHAR           CID = NULL;                   // Compatible IDs
    PCHAR           DES = NULL;                   // Device Description

    switch(Type) {

    case BusQueryDeviceID:

        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        ParPnpFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
            goto ParPnpGetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf(resultString, "%s%s\0",MFG,MDL);
        
        if (descriptionString) {
            sprintf((PCHAR)descriptionString, "%s %s\0",MFG,MDL);
        }
            
        break;

    case BusQueryHardwareIDs:

        GetCheckSum(DeviceIdString, (USHORT)strlen((const PCHAR)DeviceIdString), &checkSum);
        sprintf(resultString,"%s%.20s%04X",nodeName,DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen((const PCHAR)DeviceIdString), &checkSum);
        sprintf(resultString,"%.20s%04X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {

        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst (resultString, ' ', '_', (USHORT)strlen((const PCHAR)resultString));
    }

ParPnpGetId_Cleanup:

    return(status);
}

VOID
ParPnpFindDeviceIdKeys(
    PCHAR   *lppMFG,
    PCHAR   *lppMDL,
    PCHAR   *lppCLS,
    PCHAR   *lppDES,
    PCHAR   *lppAID,
    PCHAR   *lppCID,
    PCHAR   lpDeviceID
    )
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/
{
    PCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    DD(NULL,DDT,"ParPnpFindDeviceIdKeys - enter\n");

    if( lppMFG ) { *lppMFG = NULL; }
    if( lppMDL ) { *lppMDL = NULL; }
    if( lppCLS ) { *lppCLS = NULL; }
    if( lppDES ) { *lppDES = NULL; }
    if( lppAID ) { *lppAID = NULL; }
    if( lppCID ) { *lppCID = NULL; }

    if( !lpDeviceID ) { 
        PptAssert(!"ParPnpFindDeviceIdKeys - NULL lpDeviceID");
        return; 
    }

    while (lpKey != NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?
        lpValue = StringChr(lpKey, ':');
        if( NULL == lpValue ) {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        switch (*lpKey) {
        case 'M':
            // Look for MANUFACTURE (MFG) or MODEL (MDL)
            if((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
               (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) ) {

                *lppMFG = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=NULL) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                      (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) ) {

                *lppMDL = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if((lpKey = StringChr(lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case 'C':
            // Look for CLASS (CLS) or COMPATIBLEID (CID)
            if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) ) {

                *lppCLS = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                       (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) ) {

                *lppCID = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr(lpValue,';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
        
            break;

        case 'D':
            // Look for DESCRIPTION (DES)
            if(RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                RtlCompareMemory(lpKey, "DES", wKeyLength) ) {

                *lppDES = lpValue;
                if((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr(lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            
            break;

        case 'A':
            // Look for AUTOMATIC ID (AID)
            if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                RtlCompareMemory(lpKey, "AID", wKeyLength) ) {

                *lppAID = lpValue;
                if ((lpKey = StringChr(lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr(lpValue, ';'))!=0) {

                *lpKey = '\0';
                ++lpKey;

            }
            break;

        default:
            // The key is uninteresting.  Go to the next Key
            if ((lpKey = StringChr(lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;
        }
    }
}


VOID
GetCheckSum(
    PCHAR  Block,
    USHORT  Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    //    UCHAR  lrc;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = (UCHAR)(Block[i] ^ (UCHAR)crc);
         crc = (USHORT)((crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4]);
    }

    *CheckSum = crc;
}


PCHAR
Par3QueryDeviceId(
    IN  PPDO_EXTENSION   Pdx,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString, // TRUE ==  include the 2 size bytes in the returned string
                                              // FALSE == discard the 2 size bytes
    IN BOOLEAN              bBuildStlDeviceId
    )
/*++

  This is the replacement function for SppQueryDeviceId.

  This function uses the caller supplied buffer if the supplied buffer
    is large enough to hold the device id. Otherwise, a buffer is
    allocated from paged pool to hold the device ID and a pointer to
    the allocated buffer is returned to the caller. The caller determines
    whether a buffer was allocated by comparing the returned PCHAR with
    the DeviceIdBuffer parameter passed to this function. A NULL return
    value indicates that an error occurred.

    *** this function assumes that the caller has already acquired
          the port (and selected the device if needed in the case
          of a 1284.3 daisy chain device).

    *** If this function returns a pointer to a paged pool allocation then
          the caller is responsible for freeing the buffer when it is no
          longer needed.

--*/
{
    PUCHAR              Controller = Pdx->Controller;
    NTSTATUS            Status;
    UCHAR               idSizeBuffer[2];
    ULONG               bytesToRead;
    ULONG               bytesRead = 0;
    USHORT              deviceIdSize;
    USHORT              deviceIdBufferSize;
    PCHAR               deviceIdBuffer;
    PCHAR               readPtr;
    BOOLEAN             allocatedBuffer = FALSE;

    DD((PCE)Pdx,DDT,"Enter pnp::Par3QueryDeviceId: Controller=%x\n", Controller);
                    
    if( TRUE == bBuildStlDeviceId ) {
        // if this is a legacy stl, forward call to special handler
        return ParStlQueryStlDeviceId(Pdx, 
                                          CallerDeviceIdBuffer, CallerBufferSize,
                                          DeviceIdSize, bReturnRawString);
    }

    if( Pdx->Ieee1284_3DeviceId == DOT3_LEGACY_ZIP_ID ) {
        // if this is a legacy Zip, forward call to special handler
        return Par3QueryLegacyZipDeviceId(Pdx, 
                                          CallerDeviceIdBuffer, CallerBufferSize,
                                          DeviceIdSize, bReturnRawString);
    }

    //
    // Take a 40ms nap - there is at least one printer that can't handle
    //   back to back 1284 device ID queries without a minimum 20-30ms delay
    //   between the queries which breaks PnP'ing the printer
    //
    if( KeGetCurrentIrql() == PASSIVE_LEVEL ) {
        LARGE_INTEGER delay;
        delay.QuadPart = - 10 * 1000 * 40; // 40 ms
        KeDelayExecutionThread( KernelMode, FALSE, &delay );
    }

    *DeviceIdSize = 0;

    //
    // If we are currently connected to the peripheral via any 1284 mode
    //   other than Compatibility/Spp mode (which does not require an IEEE
    //   negotiation), we must first terminate the current mode/connection.
    // 
    ParTerminate( Pdx );

    //
    // Negotiate the peripheral into nibble device id mode.
    //
    Status = ParEnterNibbleMode(Pdx, REQUEST_DEVICE_ID);
    if( !NT_SUCCESS(Status) ) {
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: call to ParEnterNibbleMode FAILED\n");
        ParTerminateNibbleMode(Pdx);
        return NULL;
    }


    //
    // Read first two bytes to get the total (including the 2 size bytes) size 
    //   of the Device Id string.
    //
    bytesToRead = 2;
    Status = ParNibbleModeRead(Pdx, idSizeBuffer, bytesToRead, &bytesRead);
    if( !NT_SUCCESS( Status ) || ( bytesRead != bytesToRead ) ) {
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: read of DeviceID size FAILED\n");
        return NULL;
    }


    //
    // Compute size of DeviceId string (including the 2 byte size prefix)
    //
    deviceIdSize = (USHORT)( idSizeBuffer[0]*0x100 + idSizeBuffer[1] );
    DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: DeviceIdSize (including 2 size bytes) reported as %d\n", deviceIdSize);


    //
    // Allocate a buffer to hold the DeviceId string and read the DeviceId into it.
    //
    if( bReturnRawString ) {
        //
        // Caller wants the raw string including the 2 size bytes
        //
        *DeviceIdSize      = deviceIdSize;
        deviceIdBufferSize = (USHORT)(deviceIdSize + sizeof(CHAR));     // ID size + ID + terminating NULL
    } else {
        //
        // Caller does not want the 2 byte size prefix
        //
        *DeviceIdSize      = deviceIdSize - 2*sizeof(CHAR);
        deviceIdBufferSize = (USHORT)(deviceIdSize - 2*sizeof(CHAR) + sizeof(CHAR)); //           ID + terminating NULL
    }


    //
    // If caller's buffer is large enough use it, otherwise allocate a buffer
    //   to hold the device ID
    //
    if( CallerDeviceIdBuffer && (CallerBufferSize >= deviceIdBufferSize) ) {
        //
        // Use caller's buffer - *** NOTE: we are creating an alias for the caller buffer
        //
        deviceIdBuffer = CallerDeviceIdBuffer;
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: using Caller supplied buffer\n");
    } else {
        //
        // Either caller did not supply a buffer or supplied a buffer that is not
        //   large enough to hold the device ID, so allocate a buffer.
        //
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: Caller's Buffer TOO_SMALL - CallerBufferSize= %d, deviceIdBufferSize= %d\n",
                   CallerBufferSize, deviceIdBufferSize);
        DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: will allocate and return ptr to buffer\n");
        deviceIdBuffer = (PCHAR)ExAllocatePool(PagedPool, deviceIdBufferSize);
        if( !deviceIdBuffer ) {
            DD((PCE)Pdx,DDT,"pnp::Par3QueryDeviceId: ExAllocatePool FAILED\n");
            return NULL;
        }
        allocatedBuffer = TRUE; // note that we allocated our own buffer rather than using caller's buffer
    }


    //
    // NULL out the ID buffer to be safe
    //
    RtlZeroMemory( deviceIdBuffer, deviceIdBufferSize );


    //
    // Does the caller want the 2 byte size prefix?
    //
    if( bReturnRawString ) {
        //
        // Yes, caller wants the size prefix. Copy prefix to buffer to return.
        //
        *(deviceIdBuffer+0) = idSizeBuffer[0];
        *(deviceIdBuffer+1) = idSizeBuffer[1];
        readPtr = deviceIdBuffer + 2;
    } else {
        //
        // No, discard size prefix
        //
        readPtr = deviceIdBuffer;
    }


    //
    // Read remainder of DeviceId from device
    //
    bytesToRead = deviceIdSize -  2; // already have the 2 size bytes
    Status = ParNibbleModeRead(Pdx, readPtr, bytesToRead, &bytesRead);
            

    ParTerminateNibbleMode( Pdx );
    P5WritePortUchar(Controller + DCR_OFFSET, DCR_NEUTRAL);

    if( !NT_SUCCESS(Status) || (bytesRead < 1) ) {
        if( allocatedBuffer ) {
            // we're using our own allocated buffer rather than a caller supplied buffer - free it
            DD((PCE)Pdx,DDE,"Par3QueryDeviceId:: read of DeviceId FAILED - discarding buffer\n");
            ExFreePool( deviceIdBuffer );
        }
        return NULL;
    }

    if ( bytesRead < bytesToRead ) {
        //
        // Device likely reported incorrect value for IEEE 1284 Device ID length
        //
        // This spew is on by default in checked builds to try to get
        //   a feel for how many types of devices are broken in this way
        //
        DD((PCE)Pdx,DDE,"pnp::Par3QueryDeviceId - ID shorter than expected\n");
    }

    return deviceIdBuffer;
}


VOID
ParReleasePortInfoToPortDevice(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine will release the port information back to the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    //
    // ParPort treats this as a NO-OP in Win2K, so don't bother sending the IOCTL.
    //
    // In follow-on to Win2K parport may use this to page the entire driver as
    //   it was originally intended, so we'll turn this back on then.
    //

    UNREFERENCED_PARAMETER( Pdx );

    return;
}

VOID
ParFreePort(
    IN  PPDO_EXTENSION Pdx
    )
/*++

Routine Description:

    This routine calls the internal free port ioctl.  This routine
    should be called before completing an IRP that has allocated
    the port.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    // Don't allow multiple releases
    if( Pdx->bAllocated ) {
        DD((PCE)Pdx,DDT,"ParFreePort - calling ParPort's FreePort function\n");
        Pdx->FreePort( Pdx->PortContext );
    } else {
        DD((PCE)Pdx,DDT,"ParFreePort - we don't have the Port! (!Ext->bAllocated)\n");
    }
        
    Pdx->bAllocated = FALSE;
}


NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

/*++

Routine Description:

    This routine is the completion routine for a port allocate request.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.
    Context         - Supplies the notification event.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - The Irp still requires processing.

--*/

{
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( DeviceObject );

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
ParAllocPort(
    IN  PPDO_EXTENSION   Pdx
    )

/*++

Routine Description:

    This routine takes the given Irp and sends it down as a port allocate
    request.  When this request completes, the Irp will be queued for
    processing.

Arguments:

    Pdx   - Supplies the device extension.

Return Value:

    FALSE   - The port was not successfully allocated.
    TRUE    - The port was successfully allocated.

--*/

{
    PIO_STACK_LOCATION  NextSp;
    KEVENT              Event;
    PIRP                Irp;
    BOOLEAN             bAllocated;
    NTSTATUS            Status;
    LARGE_INTEGER       Timeout;

    // Don't allow multiple allocations
    if (Pdx->bAllocated) {
        DD((PCE)Pdx,DDT,"ParAllocPort - controller=%x - port already allocated\n", Pdx->Controller);
        return TRUE;
    }

    Irp = Pdx->CurrentOpIrp;
    
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    NextSp = IoGetNextIrpStackLocation(Irp);
    NextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE;

    IoSetCompletionRoutine( Irp, ParAllocPortCompletionRoutine, &Event, TRUE, TRUE, TRUE );

    ParCallDriver(Pdx->PortDeviceObject, Irp);

    Timeout.QuadPart = -((LONGLONG) Pdx->TimerStart*10*1000*1000);

    Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, &Timeout);

    if (Status == STATUS_TIMEOUT) {
    
        IoCancelIrp(Irp);
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    }

    bAllocated = (BOOLEAN)NT_SUCCESS(Irp->IoStatus.Status);
    
    Pdx->bAllocated = bAllocated;
    
    if (!bAllocated) {
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        DD((PCE)Pdx,DDE,"ParAllocPort - controller=%x - FAILED - DEVICE_BUSY timeout\n",Pdx->Controller);
    }

    return bAllocated;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parvdm\parvdm.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name :

    parsimp.h

Abstract:

    Type definitions and data for a simple parallel class driver.

Author:

    Norbert P. Kusters 4-Feb-1994

Revision History:

--*/

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ParV')
#endif

#define PARALLEL_DATA_OFFSET 0
#define PARALLEL_STATUS_OFFSET 1
#define PARALLEL_CONTROL_OFFSET 2
#define PARALLEL_REGISTER_SPAN 3

typedef struct _DEVICE_EXTENSION {

    //
    // Points to the device object that contains
    // this device extension.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // Points to the port device object that this class device is
    // connected to.
    //
    PDEVICE_OBJECT PortDeviceObject;

    //
    // Keeps track of whether or not we actually own the
    // parallel hardware
    //
    BOOLEAN PortOwned;

    BOOLEAN spare[3]; // force to DWORD alignment

    //
    // Enforce exclusive Create/Open - 1 == either handle open or Create/Open in process
    //                                 0 == no handle open to device
    //
    ULONG CreateOpenLock;

    //
    // This holds the result of the get parallel port info
    // request to the port driver.
    //
    PHYSICAL_ADDRESS OriginalController;
    PUCHAR Controller;
    ULONG SpanOfController;
    PPARALLEL_FREE_ROUTINE FreePort;
    PVOID FreePortContext;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time and the symbolic link itself.  If we didn't
    // create it, we won't try to destroy it when we unload.
    //
    BOOLEAN CreatedSymbolicLink;
    UNICODE_STRING SymbolicLinkName;

#ifdef INTERRUPT_NEEDED

    //
    // Set 'IgnoreInterrupts' to TRUE unless the port is owned by
    // this device.
    //

    BOOLEAN IgnoreInterrupts;
    PKINTERRUPT InterruptObject;

    //
    // Keep the interrupt level alloc and free routines.
    //

    PPARALLEL_TRY_ALLOCATE_ROUTINE TryAllocatePortAtInterruptLevel;
    PVOID TryAllocateContext;

#endif

#ifdef TIMEOUT_ALLOCS

    //
    // This timer is used to timeout allocate requests that are sent
    // to the port device.
    //
    KTIMER AllocTimer;
    KDPC AllocTimerDpc;
    LARGE_INTEGER AllocTimeout;

    //
    // This variable is used to indicate outstanding references
    // to the current irp.  This solves the contention problem between
    // the timer DPC and the completion routine.  Access using
    // 'ControlLock'.
    //

#define IRP_REF_TIMER               1
#define IRP_REF_COMPLETION_ROUTINE  2

    LONG CurrentIrpRefCount;
    KSPIN_LOCK ControlLock;

    //
    // Indicates that the current request timed out.
    //
    BOOLEAN TimedOut;

#endif

    //
    // Name of the parport device that we use when opening a FILE
    //
    UNICODE_STRING ParPortName;
    PFILE_OBJECT   ParPortFileObject;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#ifdef INTERRUPT_NEEDED

BOOLEAN
ParInterruptService(
    IN      PKINTERRUPT Interrupt,
    IN OUT  PVOID       Extension
    );

VOID
ParDpcForIsr(
    IN  PKDPC           Dpc,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    );

VOID
ParDeferredPortCheck(
    IN  PVOID   Extension
    );

#endif

#ifdef TIMEOUT_ALLOCS

VOID
ParAllocTimerDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   Extension,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

#endif

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN PDEVICE_OBJECT	DeviceObject,
    IN PIRP		Irp
    );

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\published\sdk\inc\makefile.inc ===
#
# 1394wmi.h, 1394wmi.bmf
#
$(O)\1394wmi.bmf: $(O)\1394wmi.mof
$(O)\1394wmi.w : $(O)\1394wmi.bmf
    wmimofck -m -h$@ $?

$(O)\ntddredb.bmf: $(O)\ntddredb.mof
$(O)\ntddredb.w : $(O)\ntddredb.bmf
    wmimofck -h$@ $?

WINIOCTL_DEPENDS = $(SDK_INC_PATH)\devioctl.h \
                   ntddstor.w \
                   ntdddisk.w \
                   ntddchgr.w \
                   ntddser.w \
                   $(SDK_INC_PATH)\ntioapi.h \
                   ntddvol.w


########################################################################
# winioctl.h
#

$(O)\winioctl.w: $(WINIOCTL_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winioctl.h

Abstract:

    This module defines the 32-Bit Windows Device I/O control codes.

Revision History:

--*/


//
// Device interface class GUIDs.
//
// need these GUIDs outside conditional includes so that user can
//   #include <winioctl.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <winioctl.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

<<
    hextract -f -o $@ -lt wioctlguids -bt begin_wioctlguids end_wioctlguids $(WINIOCTL_DEPENDS)
    type << >> $@

//
// Obsolete device interface class GUID names.
// (use of above GUID_DEVINTERFACE_* names is recommended).
//
<<
    hextract -f -o $@ -lt wioctlobsoleteguids -bt begin_wioctlobsoleteguids end_wioctlobsoleteguids $(WINIOCTL_DEPENDS)
    type << >> $@

#endif // DEFINE_GUID

#ifndef _WINIOCTL_
#define _WINIOCTL_

<<
    hextract -f -o $@ -lt winioctl -bt begin_winioctl end_winioctl $(WINIOCTL_DEPENDS)
    type << >> $@

#endif // _WINIOCTL_

<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\published\ddk\inc\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

all: $(DDK_INC_PATH)\dderror.h  $(O)\hbapiwmi.h

clean: cleansrc all

cleansrc:
    -erase dderror.w $(O)\hbapiwmi.h

$(O)\hbapiwmi.h: hbaapi.mof
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) hbaapi.mof > $(O)\hbaapi.mof
    mofcomp /b:$O\hbaapi.bmf $(O)\hbaapi.mof
    wmimofck -h$O\hbapiwmi.h -m -u $O\hbaapi.bmf
    $(PUBLISH_CMD) {$(O)\hbapiwmi.h=$(DDK_INC_PATH)\hbapiwmi.h}

$(DDK_INC_PATH)\dderror.h: dderror.w
    $(PUBLISH_CMD) {$**=$@}

dderror.w: $(SDK_INC_PATH)\winerror.h makefile.inc
    type << > $@

/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

<<
    hextract -o $@ -lt dderror -bt begin_dderror end_dderror $(SDK_INC_PATH)\winerror.h
    type << >> $@

#endif /* _DDERROR_ */

<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\published\internal\inc\rt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    rt.h

Abstract:

    This is the public include file for realtime executive (rt.sys) clients.

Author:

    Joseph Ballantyne

Environment:

    Kernel Mode

Revision History:

--*/




#ifdef __cplusplus
extern "C" {
#endif


// The following values can be ORed together and the result passed as the Flags argument
// to the RtCreateThread and RtAdjustCpuLoad routines.

#define CPUCYCLES		0x10000
#define INSTRUCTIONS	0x20000

#define USESFLOAT		0x00001
#define USESMMX			0x00002


// These should be used when calculating the desired period and duration to be
// passed to RtCreateThread and RtAdjustCpuLoad.

#define WEEK 604800000000000000I64
#define DAY   86400000000000000I64
#define HOUR   3600000000000000I64
#define MIN      60000000000000I64
#define SEC       1000000000000I64
#define MSEC         1000000000I64
#define USEC            1000000I64
#define NSEC               1000I64
#define PSEC                  1I64


#define X86 1


#define INTEL 1
#define AMD 2



typedef struct {
	ULONG ProcessorCount;	// Number of CPUs in the system.
	ULONG CpuArchitecture;	// Architecture of CPU, currently always X86==1
	ULONG CpuManufacturer;	// Manufacturer ID, Intel==1, AMD==2
	ULONG CpuFamily;		// CPU Family as reported by cpuid instruction.  0x0-0xf
	ULONG CpuModel;			// CPU Model as reported by cpuid instruction.  0x0-0xf
	ULONG CpuStepping;		// CPU Stepping as reported by cpuid instruction.  0x0-0xf
	ULONGLONG CpuFeatures;	// CPU features as reported by cpuid instruction.
	ULONGLONG CpuExtendedFeatures;	// AMD extended features.  (Not implemented.)  Always 0.
	ULONGLONG ProcessorID[2];		// Processor Unique ID.  If enabled.
	ULONG CpuCyclesPerMsec;			// Number of cpu cycles per MSEC.
	ULONG SystemBusCyclesPerMsec;	// Number of system bus cycles per MSEC.
	ULONG ReservedCpuPerMsec;		// Total cpu time reserved per ms by existing rt threads. (in picoseconds)
	ULONG UsedCpuPerMsec;			// Estimate of cpu time used per ms by existing rt threads. (in picoseconds)
	ULONG AvailableCpuPerMsec;		// Cpu time available per ms for allocation to new rt threads. (in picoseconds)
	} SystemInfo;



// The following realtime thread statistics are updated just before control is
// passed by the realtime executive to the realtime thread.  Everytime a realtime
// thread is being switched in, these statistics are updated before control is transfered.
// This means the statistics will change over time, but not while a realtime
// thread is running between thread switches.

#pragma pack(push,2)

typedef struct threadstats {
	ULONGLONG Period;		// Period as passed to RtCreateThread or latest RtAdjustCpuLoad call.
	ULONGLONG Duration;		// Duration from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG Flags;			// Flags from RtCreateThread or latest RtAdjustCpuLoad call.
	ULONG StackSize;		// StackSize from RtCreateThread call.
	ULONGLONG PeriodIndex;					// Number of periods since start of thread.
	ULONGLONG TimesliceIndex;				// Number of times thread has been switched to.
	ULONGLONG TimesliceIndexThisPeriod;		// Number of times thread switch to this period.
	ULONGLONG ThisPeriodStartTime;			// Starting time for current period.
	ULONGLONG ThisTimesliceStartTime;		// Starting time for current timeslice.
	ULONGLONG DurationRunThisPeriod;		// Total time run so far this period.
	ULONGLONG DurationRunLastPeriod;		// Total time run in the last period.
	} ThreadStats;

#pragma pack(pop)


typedef VOID (*RTTHREADPROC)(PVOID Context, ThreadStats *Statistics);



NTSTATUS
RtVersion (
	OUT PULONG Version
	);

// RtVersion will return the version number of the currently running
// realtime executive.

// If the realtime executive is running, this function returns
// STATUS_SUCCESS.  If for some reason the realtime executive
// cannot run on the current machine then STATUS_NOT_SUPPORTED
// is returned.

// Currently the realtime executive will only run on PII class or newer
// machines.

// If the pointer to the version number is non NULL, then the
// version information for the currently loaded realtime executive
// is returned.  The version information will be returned regardless
// of the NTSTATUS code returned by the function.

// The version number returned is in the format xx.xx.xx.xx where each
// xx is 1 byte of the ULONG and the ordering left to right is high
// order byte - > low order byte.  ie: 0x01020304 is version 1.2.3.4

// It IS acceptable to pass in a NULL version pointer.  In that case
// no version information is returned.

// If this function is called from a real time thread, then the version
// pointer MUST either be NULL, or it MUST point to a local variable on 
// that real time thread's stack.  Otherwise this function will return 
// STATUS_INVALID_PARAMETER.

// If this function is called from Windows, then the pointer must be
// valid for writing.  Otherwise it will return STATUS_INVALID_PARAMETER.

// This function may be called from any thread.  Windows or realtime.



BOOLEAN
RtThread (
    VOID
    );

// RtThread returns TRUE if called from within a realtime thread.  Otherwise
// it returns FALSE.



NTSTATUS
RtSystemInfo (
	ULONG Processor,
	SystemInfo *pSystemInfo
	);

// RtSystemInfo copies the pertinant processor and system information into the memory 
// pointed to by pSystemInfo.  If pSystemInfo is null or invalid, then RtSystemInfo 
// returns STATUS_INVALID_PARAMETER_2.  Otherwise RtSystemInfo will return STATUS_SUCCESS.

// For uniprocessor systems, the Processor number should be zero.  For N processor
// systems, the processor numbers range from 0 to N-1.  An invalid processor number
// will cause a STATUS_INVALID_PARAMETER_1 to be returned.



NTSTATUS
RtCreateThread (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONG Flags,
	ULONG StackSize,
	RTTHREADPROC RtThread,
	IN PVOID pRtThreadContext,
	OUT PHANDLE pRtThreadHandle
	);

// RtCreateThread is used to create a realtime thread.

// Period is the used to determine the frequency at which the realtime thread must be
// run.  The current minimum period that can be specified is 1ms.

// Duration is the amount of time within the period that the realtime thread will
// need to run.  Percentage CPU load can be calculated as 100*(Duration/Period) as long
// as Duration and Period are both specified in units of time.

// Flags
// This parameter is used to indicate specific requirements of the realtime thread
// being created.  Currently supported values for Flags are USESFLOAT and USESMMX.
// A realtime thread that can use floating point instructions must specify the
// USESFLOAT flag.  A realtime thread that can use MMX instructions must specify the
// USESMMX flag.

// StackSize is the size of the stack required by the realtime thread in 4k blocks.
// Currently StackSize must be between 1 and 8 inclusive.  RtCreateThread will fail
// with STATUS_UNSUCCESSFUL for any other values of StackSize.

// pRtThreadContext is a pointer to the context that should be passed to the thread.
// It may be NULL.  It is passed to the realtime thread as the Context parameter.

// pRtThreadHandle is a pointer to an RtThreadHandle that can be output from
// RtCreateThread.  pRtThreadHandle can be NULL, in which case no RtThreadHandle is
// returned.  Storage for the HANDLE RtThreadHandle must be allocated by the code
// that calls RtCreateThread.

// RtCreateThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtDestroyThread (
	HANDLE RtThreadHandle
	);

// RtDestroyThread removes the realtime thread identified by RtThreadHandle from the
// list of running realtime threads, and releases all resources that were allocated when
// the thread was created.  RtThreadHandle must be a handle returned from RtCreateThread.

// RtDestroyThread may only be called from within a standard windows thread.  It MUST NOT
// be called from within a realtime thread.



NTSTATUS
RtAdjustCpuLoad (
	ULONGLONG Period,
	ULONGLONG Duration,
	ULONGLONG Phase,
	ULONG Flags
	);

// This function allows a realtime thread to adjust the amount of CPU that is allocated
// to it.  The Flags parameter must currently match that passed in at thread creation
// time, however, the Period and Duration may be different from the Period and Duration
// passed at thread create time.  If there is sufficient CPU to meet the new request,
// the function will return STATUS_SUCCESS and the Period and Duration in the thread's
// statistics will be updated to match the values passed in to this function.  If
// there is not enough CPU available to meet the request, this function will leave
// the Period and Duration recorded in Statistics unchanged and will return
// STATUS_INSUFFICIENT_RESOURCES.

// This function MUST be called from within a realtime thread.  A realtime thread can
// only change its OWN allocation.  It cannot change the allocation of any other
// realtime thread.



VOID
RtYield (
	ULONGLONG Mark,
	ULONGLONG Delta
	);

// RtYield will yield execution to other realtime threads in the system.

// It should be called whenever a realtime thread does not require further CPU resources.

// Parameters:
//  Mark
//		This is the reference time which will be subtracted from the current
//		realtime executive scheduler time.  Note that this time is ALWAYS
//		considered by the scheduler to be in the past.  Do NOT pass a time
//		which occurs in the future to this parameter.
//	Delta
//		This is the time that will be compared to the difference between the current
//		scheduler time and the mark.  The thread will yield execution until
//		the difference between the current scheduler time and the mark is greater 
//		than delta.

//		After a thread has called RtYield it will only be run when the following
//		code evaluates TRUE.  ( (RtTime() - Mark) >= Delta )  Until that occurs
//		the thread will NOT run.  Unless it is holding a spinlock required by
//		some other realtime thread - in which case it will run until it releases
//		the spinlock at which point it will again yield.



PVOID
RtAddLogEntry (
    ULONG Size
    );

// RtAddLogEntry reserves space for a new entry in the realtime logging buffer.
// It returns a pointer to the reserved space.  Note that if an unsupported Size
// is specified, or if there is no realtime logging buffer available on the
// system, this routine will return NULL.

// Parameters:
//  Size
//      This is the size in bytes of the chunk to reserve in the log.  It MUST be
//      an integral multiple of 16.



// The following standard WDM functions are also safe to call from within a real time 
// thread:  KeAcquireSpinLock and KeReleaseSpinLock.

// They have been modified to support realtime threads in the following ways:



// KeAcquireSpinLock

// KeAcquireSpinLock will now always attempt to take the spinlock regardless of whether it
// is running on a multiproc or uniproc machine.  If the spinlock is already acquired,
// then KeAcquireSpinLock will spin in a loop that calls RtYield(THISTIMESLICE) until
// the spinlock is released.

// It will then claim the spinlock.  This means that realtime threads that attempt to 
// acquire a held spinlock will BLOCK until the spinlock is free.  If you don't HAVE to use 
// spinlocks in your realtime threads, DON'T.

// Note that other realtime threads will continue to run as scheduled, but the thread
// waiting for the spinlock will continue yielding all its timeslices until the spinlock
// is released.

// If KeAcquireSpinLock is called from a realtime thread, then it will NOT attempt to
// change any irql levels.  This is important, since the current Windows IRQL level may
// be at higher than DISPATCH_LEVEL when this function is called.  Furthermore, the OldIrql
// returned by this function when it is called from a realtime thread is always 0xff - 
// which is an INVALID irql level.

// If you call KeAcquireSpinLock from a realtime thread you MUST call KeReleaseSpinLock
// for that spinlock from a realtime thread.

// Evenutally, KeAcquireSpinLock will be modified to do an RtDirectedYield to the realtime
// thread that is holding the spinlock.

// KeAcquireSpinLock may be called from within any thread.  Realtime or windows.



// KeReleaseSpinLock

// KeReleaseSpinLock now always attempts to release a held spinlock regardless of whether
// it is running on a multiproc or uniproc machine.

// If KeReleaseSpinLock is called from a realtime thread, then it will NOT change any irql
// levels.  It will also validate that it has been called with a new irql level of 0xff
// as would have been returned by the KeAcquireSpinLock call in the realtime thread to
// acquire the spinlock.

// At some point KeReleaseSpinLock may do an RtDirectedYield back to the realtime thread
// that yielded when it attempted to acquire the spinlock.

// KeReleaseSpinLock may be called from within any thread.  Realtime or windows.


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\cmd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cmd.c

Abstract:

    This module contains the routines for handling each command.

Author:

    Sean Selitrennikoff (v-seans) - Dec 2, 1999

Revision History:

--*/

#include "sac.h"
#include <ntddip.h>
#include <ntddtcp.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <stdlib.h>

BOOLEAN GlobalPagingNeeded = TRUE;
BOOLEAN GlobalDoThreads = FALSE;
// For the APC routines, a global value is better :-)
IO_STATUS_BLOCK GlobalIoStatusBlock;

ULONG GlobalBufferSize = 0;
char *GlobalBuffer = NULL;

typedef struct _SAC_RSP_TLIST {
            
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

    ULONG PagefileInfoOffset;
    ULONG ProcessInfoOffset;

} SAC_RSP_TLIST, *PSAC_RSP_TLIST;


WCHAR *StateTable[] = {
    L"Initialized",
    L"Ready",
    L"Running",
    L"Standby",
    L"Terminated",
    L"Wait:",
    L"Transition",
    L"Unknown",
    L"Unknown",
    L"Unknown",
    L"Unknown",
    L"Unknown"
};

WCHAR *WaitTable[] = {
    L"Executive",
    L"FreePage",
    L"PageIn",
    L"PoolAllocation",
    L"DelayExecution",
    L"Suspended",
    L"UserRequest",
    L"Executive",
    L"FreePage",
    L"PageIn",
    L"PoolAllocation",
    L"DelayExecution",
    L"Suspended",
    L"UserRequest",
    L"EventPairHigh",
    L"EventPairLow",
    L"LpcReceive",
    L"LpcReply",
    L"VirtualMemory",
    L"PageOut",
    L"Spare1",
    L"Spare2",
    L"Spare3",
    L"Spare4",
    L"Spare5",
    L"Spare6",
    L"Spare7",
    L"Unknown",
    L"Unknown",
    L"Unknown"
};

WCHAR *Empty = L" ";

#define IP_LOOPBACK(x)  (((x) & 0x000000ff) == 0x7f)

#define IS_WHITESPACE(_ch) ((_ch == ' ') || (_ch == '\t'))
#define IS_NUMBER(_ch) ((_ch >= '0') && (_ch <= '9'))

#define SKIP_WHITESPACE(_pch) \
     while (IS_WHITESPACE(*_pch) && (*_pch != '\0')) { \
        _pch++; \
     }

#define SKIP_NUMBERS(_pch) \
     while (IS_NUMBER(*_pch) && (*_pch != '\0')) { \
        _pch++; \
     }


//
// Forward declarations.
//
NTSTATUS
GetTListInfo(
    OUT PSAC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    );

VOID
PrintTListInfo(
    IN PSAC_RSP_TLIST Buffer
    );

VOID
PutMore(
    OUT PBOOLEAN Stop
    );

VOID
DoGetNetInfo(
    IN BOOLEAN PrintToTerminal
    );
    
VOID
NetAPCRoutine(IN PVOID ApcContext,
              IN PIO_STATUS_BLOCK IoStatusBlock,
              IN ULONG Reserved
              );


VOID
DoHelpCommand(
    VOID
    )

/*++

Routine Description:

    This routine displays the help text on the terminal.

Arguments:

    None.

Return Value:

        None.

--*/
{
    SacPutSimpleMessage( SAC_HELP_D_CMD );
    SacPutSimpleMessage( SAC_HELP_F_CMD );
    SacPutSimpleMessage( SAC_HELP_HELP_CMD );
    SacPutSimpleMessage( SAC_HELP_I1_CMD );
    SacPutSimpleMessage( SAC_HELP_I2_CMD );
    SacPutSimpleMessage( SAC_HELP_I3_CMD );
    SacPutSimpleMessage( SAC_HELP_IDENTIFICATION_CMD );
    SacPutSimpleMessage( SAC_HELP_K_CMD );
    SacPutSimpleMessage( SAC_HELP_L_CMD );
    SacPutSimpleMessage( SAC_HELP_M_CMD );
    SacPutSimpleMessage( SAC_HELP_P_CMD );
    SacPutSimpleMessage( SAC_HELP_R_CMD );
    SacPutSimpleMessage( SAC_HELP_S1_CMD );
    SacPutSimpleMessage( SAC_HELP_S2_CMD );
    SacPutSimpleMessage( SAC_HELP_T_CMD );
    SacPutSimpleMessage( SAC_HELP_Q_CMD );
    SacPutSimpleMessage( SAC_HELP_RESTART_CMD );
    SacPutSimpleMessage( SAC_HELP_SHUTDOWN_CMD );
    SacPutSimpleMessage( SAC_HELP_CRASHDUMP1_CMD );
    SacPutSimpleMessage( SAC_HELP_CRASHDUMP2_CMD );
}


VOID
DoFullInfoCommand(
    VOID
    )

/*++

Routine Description:

    This routine toggles on and off full thread information on tlist.

Arguments:

    None.

Return Value:

        None.

--*/
{
    GlobalDoThreads = (BOOLEAN)!GlobalDoThreads;

    if (GlobalDoThreads) {
        SacPutSimpleMessage(SAC_THREAD_ON);
    } else {
        SacPutSimpleMessage(SAC_THREAD_OFF);
    }
}

VOID
DoPagingCommand(
    VOID
    )

/*++

Routine Description:

    This routine toggles on and off paging information on tlist.

Arguments:

    None.

Return Value:

        None.

--*/
{
    GlobalPagingNeeded = (BOOLEAN)!GlobalPagingNeeded;
    
    if (GlobalPagingNeeded) {
        SacPutSimpleMessage(SAC_PAGING_ON);
    } else {
        SacPutSimpleMessage(SAC_PAGING_OFF);
    }
}

VOID
DoSetTimeCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine sets the current system time.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }

    RtlZeroMemory(&TimeFields, sizeof(TIME_FIELDS));

    //
    // Skip the command.
    //
    pch += (sizeof(TIME_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {

        //
        // This is a display time request.
        //
        Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                          &TimeOfDay,
                                          sizeof(TimeOfDay),
                                          NULL
                                         );

        if (!NT_SUCCESS(Status)) {
            swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR ) , Status);
            SacPutUnicodeString((PWSTR)GlobalBuffer);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (2).\n")));
            return;
        }

        RtlTimeToTimeFields(&(TimeOfDay.CurrentTime), &TimeFields);

        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_DATETIME_FORMAT ),
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds
               );

        SacPutUnicodeString((PWSTR)GlobalBuffer);
        return;
    }

    pchTmp = pch;
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (3).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);


    //
    // If there is something other than the divider, it is a mal-formed line.
    //
    if (*pchTmp != '/') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (4).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Month = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (4b).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    //
    // If there is something other than the divider, it is a mal-formed line.
    //
    if (*pchTmp != '/') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (5).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Day = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (5b).\n")));
        return;
    }

    //
    // Skip all the numbers.
    //
    SKIP_NUMBERS(pchTmp);

    //
    // If there is something other than whitespace, it is a mal-formed line.
    //
    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (6).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Year = (USHORT)(atoi((LPCSTR)pch));

    if ((TimeFields.Year < 1980) || (TimeFields.Year > 2099)) {
        SacPutSimpleMessage(SAC_DATETIME_LIMITS);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (6b).\n")));
        return;
    }

    pch = pchTmp;

    //
    // Skip to the hours
    //
    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (7).\n")));
        return;
    }

    pch = pchTmp;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != ':') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    TimeFields.Hour = (USHORT)(atoi((LPCSTR)pch));

    pch = pchTmp;

    //
    // Verify nothing else on the line but numbers
    //
    SKIP_WHITESPACE(pchTmp);

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8a).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (8b).\n")));
        return;
    }

    //
    // Get the minutes.
    //
    TimeFields.Minute = (USHORT)(atoi((LPCSTR)pch));

    if (!RtlTimeFieldsToTime(&TimeFields, &Time)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (9).\n")));
        return;
    }

    Status = ZwSetSystemTime(&Time, NULL);

    if (!NT_SUCCESS(Status)) {
        sprintf((LPSTR)GlobalBuffer, "Failed with status 0x%X.\r\n", Status);
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetTimeCommand: Exiting (10).\n")));
        return;
    }

    swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_DATETIME_FORMAT2 ),    
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute
           );
    SacPutUnicodeString((PWSTR)GlobalBuffer);
    return;
}

VOID
DoSetIpAddressCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine sets the IP address and subnet mask.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    HANDLE Handle;
    HANDLE EventHandle;
    PKEVENT Event;
    ULONG IpAddress;
    ULONG SubIpAddress;
    ULONG SubnetMask;
    ULONG NetworkNumber;
    LARGE_INTEGER TimeOut;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PIP_SET_ADDRESS_REQUEST IpRequest;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }

    //
    // Skip the command.
    //
    pch += (sizeof(SETIP_COMMAND_STRING) - sizeof(UCHAR));
    
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {       
        //
        // No other parameters, get the network numbers and their IP addresses.
        //
        DoGetNetInfo( TRUE );
        return;
    }

    pchTmp = pch;

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    
    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (1c).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    NetworkNumber = atoi((LPCSTR)pch);

    pch = pchTmp;

    //
    // Parse out the IP address.
    //

    //
    // Skip ahead to the divider and make it a \0.
    //
    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (2).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4a).\n")));
        return;
    }
    IpAddress = SubIpAddress;

    //
    // Get 2nd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (4b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    
    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5a).\n")));
        return;
    }
    IpAddress |= (SubIpAddress << 8);

    //
    // Get 3rd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (5b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    
    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6a).\n")));
        return;
    }
    IpAddress |= (SubIpAddress << 16);

    //
    // Get 4th part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (6b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);

    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (7).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    
    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (7a).\n")));
        return;
    }
    IpAddress |= (SubIpAddress << 24);

    //
    //
    // Now onto the subnet mask.
    //
    //
    //
    // Skip ahead to the divider and make it a \0.
    //

    SKIP_WHITESPACE(pchTmp);

    pch = pchTmp;
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (8).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (9).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (9a).\n")));
        return;
    }
    SubnetMask = SubIpAddress;
    
    //
    // Get 2nd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (9b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10a).\n")));
        return;
    }
    SubnetMask |= (SubIpAddress << 8);

    //
    // Get 3rd part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (10b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '.') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (11).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (11a).\n")));
        return;
    }
    SubnetMask |= (SubIpAddress << 16);

    //
    // Get 4th part
    //
    pch = pchTmp;

    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (12).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (13).\n")));
        return;
    }

    SubIpAddress = atoi((LPCSTR)pch);
    if( SubIpAddress > 255 ) {
    
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (13a).\n")));
        return;
    }    
    SubnetMask |= (SubIpAddress << 24);

    //
    //
    // Now that that is done, we move onto actually doing the command.
    //
    //


    //
    // Start by opening the driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_IPADDRESS_SET_FAILURE);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: failed to open TCP device, ec = 0x%X\n",
                     Status)));
        return;
    }

    //
    // Setup notification event
    //
    RtlInitUnicodeString(&UnicodeString, L"\\BaseNamedObjects\\SACEvent");

    Event = IoCreateSynchronizationEvent(&UnicodeString, &EventHandle);

    if (Event == NULL) {
        SacPutSimpleMessage(SAC_IPADDRESS_RETRIEVE_FAILURE);
        ZwClose(Handle);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Event is NULL.\n")));
        return;
    }

    //
    // Setup the IOCTL buffer to delete the old address.
    //
    IpRequest = (PIP_SET_ADDRESS_REQUEST)GlobalBuffer;
    IpRequest->Address = 0;
    IpRequest->SubnetMask = 0;
    IpRequest->Context = (USHORT)NetworkNumber;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(Handle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_IP_SET_ADDRESS,
                                   IpRequest,
                                   sizeof(IP_SET_ADDRESS_REQUEST),
                                   NULL,
                                   0
                                  );
                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (Status == STATUS_SUCCESS) {
            Status = IoStatusBlock.Status;
        }

    }

    if (Status != STATUS_SUCCESS) {
        SacPutSimpleMessage( SAC_IPADDRESS_CLEAR_FAILURE );
        ZwClose(EventHandle);
        ZwClose(Handle);
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't clear existing IP Address (0x%X).\n",
                     Status)));
        return;
    }

    //
    // Now add our address.
    //
    IpRequest = (PIP_SET_ADDRESS_REQUEST)GlobalBuffer;
    IpRequest->Address = IpAddress;
    IpRequest->SubnetMask = SubnetMask;
    IpRequest->Context = (USHORT)NetworkNumber;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(Handle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_IP_SET_ADDRESS,
                                   IpRequest,
                                   sizeof(IP_SET_ADDRESS_REQUEST),
                                   NULL,
                                   0
                                  );
                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
        }

    }

    ZwClose(EventHandle);
    ZwClose(Handle);
    
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage( SAC_IPADDRESS_SET_FAILURE );                
        IF_SAC_DEBUG(
            SAC_DEBUG_FUNC_TRACE, 
            KdPrint(("SAC DoSetIpAddressCommand: Exiting because it couldn't set existing IP Address (0x%X).\n",
                     Status)));
        return;
    }
    
    SacPutSimpleMessage( SAC_IPADDRESS_SET_SUCCESS );
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting.\n")));
    return;
}

VOID
DoKillCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine kill a process.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    NTSTATUS StatusOfJobObject;
    HANDLE Handle = NULL;
    HANDLE JobHandle = NULL;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    CLIENT_ID ClientId;
    BOOLEAN TerminateJobObject;
    BOOLEAN TerminateProcessObject;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(KILL_COMMAND_STRING) - sizeof(UCHAR));
    
    SKIP_WHITESPACE(pch);

    if (*pch == '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (2).\n")));
        return;
    }

    pchTmp = pch;

    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (2b).\n")));
        return;
    }

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);

    //
    // Try and open an existing job object
    //
    swprintf((PWCHAR)GlobalBuffer, L"\\BaseNamedObjects\\SAC%d", ProcessId);
    RtlInitUnicodeString(&UnicodeString, (PWCHAR)GlobalBuffer);
    InitializeObjectAttributes(&ObjectAttributes,                
                               &UnicodeString,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    StatusOfJobObject = ZwOpenJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

    //
    // Also open a handle to the process itself.
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&Handle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status) && !NT_SUCCESS(StatusOfJobObject)) {
        SacPutSimpleMessage(SAC_KILL_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (4).\n")));
        return;
    }

    //
    // To make the logic here more understandable, I use two booleans.  We have to use
    // ZwIsProcessInJob because there may be a previous JobObject for a process that we 
    // have killed, but has not yet been fully cleaned up by the system to determine if
    // the process we are trying to kill is, in fact, in the JobObject we have opened.
    //
    TerminateJobObject = (BOOLEAN)(NT_SUCCESS(StatusOfJobObject) &&
                          (BOOLEAN)NT_SUCCESS(Status) &&
                          (BOOLEAN)(ZwIsProcessInJob(Handle, JobHandle) == STATUS_PROCESS_IN_JOB)
                         );

    TerminateProcessObject = !TerminateJobObject && (BOOLEAN)NT_SUCCESS(Status);
         
    if (TerminateJobObject) {

        Status = ZwTerminateJobObject(JobHandle, 1); 

        //
        // Make the job object temporary so that when we do our close it
        // will remove it.
        //
        ZwMakeTemporaryObject(JobHandle);

    } else if (TerminateProcessObject) {

        Status = ZwTerminateProcess(Handle, 1);

    }

    if (JobHandle != NULL) {
        ZwClose(JobHandle);
    }

    if (Handle != NULL) {
        ZwClose(Handle);
    }

    if (!TerminateProcessObject && !TerminateJobObject) {

        SacPutSimpleMessage(SAC_PROCESS_STALE);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (5).\n")));
        return;

    } else if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_KILL_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting (6).\n")));
        return;

    }

    //
    // All done
    //
    
    SacPutSimpleMessage(SAC_KILL_SUCCESS);
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoKillCommand: Exiting.\n")));
    
    return;
}

VOID
DoLowerPriorityCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine slams the priority of a process down to the lowest possible, IDLE.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    PROCESS_BASIC_INFORMATION BasicInfo;
    ULONG LoopCounter;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (1).\n")));
            goto Exit;            
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(LOWER_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (2).\n")));
        
        goto Exit;

    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);



    //
    // Try to open the process
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (4).\n")));
        goto Exit;

    }



    //
    // Query information on the process.
    //
    Status = ZwQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (5).\n")));
        goto Exit;

    }


    //
    // Lower the priority and set.  Keep lowering it until we fail.  Remember
    // that we're supposed to lower it as far as it will go.
    //
    Status = STATUS_SUCCESS;
    LoopCounter = 0;
    while( (Status == STATUS_SUCCESS) &&
           (BasicInfo.BasePriority > 0) ) {

        BasicInfo.BasePriority--;
        Status = ZwSetInformationProcess( ProcessHandle,
                                          ProcessBasePriority,
                                          &BasicInfo.BasePriority,
                                          sizeof(BasicInfo.BasePriority) );

        //
        // Only treat a failure on the first time through.
        //
        if( (!NT_SUCCESS(Status)) && (LoopCounter == 0) ) {

            SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
            swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
            SacPutUnicodeString((PWSTR)GlobalBuffer);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting (6).\n")));
            goto Exit;

        }

        LoopCounter++;
    }


    //
    // All done.
    //
    SacPutSimpleMessage(SAC_LOWERPRI_SUCCESS);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLowerPriorityCommand: Exiting.\n")));

Exit:

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);    
    }

    return;
}

VOID
DoRaisePriorityCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine raises the priority of a process up one increment.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    PROCESS_BASIC_INFORMATION BasicInfo;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (1).\n")));
            goto Exit;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Skip to next argument (process id)
    //
    pch += (sizeof(RAISE_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (2).\n")));
        
        goto Exit;

    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (3).\n")));
        return;
    }

    ProcessId = atoi((LPCSTR)pch);


    //
    // See if the process even exists.
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_RAISEPRI_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (4).\n")));
        goto Exit;

    }




    //
    // Query information on the process.
    //
    Status = ZwQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &BasicInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (5).\n")));
        goto Exit;

    }


    //
    // Lower the priority and set.  Keep lowering it until we fail.  Remember
    // that we're supposed to lower it as far as it will go.
    //
    BasicInfo.BasePriority++;
    Status = ZwSetInformationProcess( ProcessHandle,
                                      ProcessBasePriority,
                                      &BasicInfo.BasePriority,
                                      sizeof(BasicInfo.BasePriority) );

    //
    // Only treat a failure on the first time through.
    //
    if( !NT_SUCCESS(Status) ) {

        SacPutSimpleMessage(SAC_LOWERPRI_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting (6).\n")));
        goto Exit;

    }


    //
    // All done.
    //
    SacPutSimpleMessage(SAC_RAISEPRI_SUCCESS);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRaisePriorityCommand: Exiting.\n")));

Exit:

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);    
    }

    return;
}

VOID
DoLimitMemoryCommand(
    PUCHAR InputLine
    )

/*++

Routine Description:

    This routine reduces the memory working set of a process to the values in
    the input line given.

Arguments:

    InputLine - The users input line to parse.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    NTSTATUS StatusOfJobObject;
    PUCHAR pch = InputLine;
    PUCHAR pchTmp;
    ULONG ProcessId;
    ULONG MemoryLimit;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE JobHandle = NULL;
    HANDLE ProcessHandle = NULL;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ProposedLimits;
    ULONG ReturnedLength;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Entering.\n")));

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (1).\n")));
            goto Exit;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    //
    // Get process id
    //
    pch += (sizeof(LIMIT_COMMAND_STRING) - sizeof(UCHAR));
    SKIP_WHITESPACE(pch);

    if (!IS_NUMBER(*pch)) {
        
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (2).\n")));
        
        goto Exit;

    }

    pchTmp = pch;

    SKIP_NUMBERS(pchTmp);

    if (!IS_WHITESPACE(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (3).\n")));
        return;
    }

    *pchTmp = '\0';
    pchTmp++;

    ProcessId = atoi((LPCSTR)pch);

    //
    // Now get memory limit
    //
    SKIP_WHITESPACE(pchTmp);
    
    if (!IS_NUMBER(*pchTmp)) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (4).\n")));
        return;
    }


    pch = pchTmp;

    SKIP_NUMBERS(pchTmp);
    SKIP_WHITESPACE(pchTmp);

    if (*pchTmp != '\0') {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (5).\n")));
        return;
    }

    MemoryLimit = atoi((LPCSTR)pch);

    if (MemoryLimit == 0) {
        SacPutSimpleMessage(SAC_INVALID_PARAMETER);
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (6).\n")));
        goto Exit;
    }

    //
    // Create the name for the job object
    //
    swprintf((PWCHAR)GlobalBuffer, L"\\BaseNamedObjects\\SAC%d", ProcessId);

    //
    // Try and open the existing job object
    //
    RtlInitUnicodeString(&UnicodeString, (PWCHAR)GlobalBuffer);
    InitializeObjectAttributes(&ObjectAttributes,                
                               &UnicodeString,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    StatusOfJobObject = ZwOpenJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);


    //
    // Try to open the process
    //
    InitializeObjectAttributes(&ObjectAttributes,                
                               NULL,       
                               OBJ_CASE_INSENSITIVE,  
                               NULL,                  
                               NULL                   
                              );

    ClientId.UniqueProcess = (HANDLE)UlongToPtr(ProcessId);
    ClientId.UniqueThread = NULL;

    Status = ZwOpenProcess(&ProcessHandle,
                           MAXIMUM_ALLOWED, 
                           &ObjectAttributes, 
                           &ClientId
                          );


    if (!NT_SUCCESS(Status) && !NT_SUCCESS(StatusOfJobObject)) {

        SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (7).\n")));
        goto Exit;

    }

    if (NT_SUCCESS(Status) && 
        NT_SUCCESS(StatusOfJobObject) &&
        (ZwIsProcessInJob(ProcessHandle, JobHandle) != STATUS_PROCESS_IN_JOB)) {

        SacPutSimpleMessage(SAC_DUPLICATE_PROCESS);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (8).\n")));
        goto Exit;

    }

    if (!NT_SUCCESS(StatusOfJobObject)) {
        
        //
        // Now try and create a job object to wrap around this process.
        //
        InitializeObjectAttributes(&ObjectAttributes,                
                                   &UnicodeString,       
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,  
                                   NULL,                  
                                   NULL                   
                                  );

        Status = ZwCreateJobObject(&JobHandle, MAXIMUM_ALLOWED, &ObjectAttributes);


        if (!NT_SUCCESS(Status)) {
            SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
            swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
            SacPutUnicodeString((PWSTR)GlobalBuffer);            
            
            ZwClose(ProcessHandle);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (8b).\n")));
            
            goto Exit;
        }

        //
        // Assign the process to this new job object.
        //
        Status = ZwAssignProcessToJobObject(JobHandle, ProcessHandle);

        ZwClose(ProcessHandle);

        if (!NT_SUCCESS(Status)) {
            SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
            swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
            SacPutUnicodeString((PWSTR)GlobalBuffer);
        
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (9).\n")));
            goto Exit;        
        }

    }

    //
    // Get the current set of limits
    //
    Status = ZwQueryInformationJobObject(JobHandle, 
                                         JobObjectExtendedLimitInformation, 
                                         &ProposedLimits, 
                                         sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
                                         &ReturnedLength
                                        );
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (10).\n")));
        goto Exit;
    }

    //
    // Change the memory limits
    //
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
    ProposedLimits.ProcessMemoryLimit = MemoryLimit * 1024 * 1024;
    ProposedLimits.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
    ProposedLimits.JobMemoryLimit = MemoryLimit * 1024 * 1024;

    Status = ZwSetInformationJobObject(JobHandle, 
                                       JobObjectExtendedLimitInformation, 
                                       &ProposedLimits, 
                                       sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
                                      );
    if (!NT_SUCCESS(Status)) {
        SacPutSimpleMessage(SAC_LOWERMEM_FAILURE);
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting (11).\n")));\
        goto Exit;
    }

    //
    // All done.
    //

    SacPutSimpleMessage(SAC_LOWERMEM_SUCCESS);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoLimitMemoryCommand: Exiting.\n")));

Exit:
    if (JobHandle != NULL) {
        ZwClose(JobHandle);
    }

    if (ProcessHandle != NULL) {
        ZwClose(ProcessHandle);
    }

    return;
}

VOID
DoRebootCommand(
    BOOLEAN Reboot
    )

/*++

Routine Description:

    This routine does a shutdown and an optional reboot.

Arguments:

    Reboot - To Reboot or not to reboot, that is the question answered here.

Return Value:

        None.

--*/
{
    #define         RESTART_DELAY_TIME (60)
    NTSTATUS        Status;
    LARGE_INTEGER   TickCount;
    LARGE_INTEGER   ElapsedTime;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Entering.\n")));


    //
    // If we attempt to shutdown the system before smss.exe has initialized
    // properly, and if there's no debugger, the machine may bugcheck.  Figuring
    // out exactly what's going on is difficult because if we put a debugger on
    // the machine, he won't repro the problem.  To work around this, we're going
    // to make sure the machine has had time to initialize before we tell it to
    // restart/shutdown.
    //

    // Elapsed TickCount
    KeQueryTickCount( &TickCount );

    // ElapsedTime in seconds.
    ElapsedTime.QuadPart = (TickCount.QuadPart)/(10000000/KeQueryTimeIncrement());

    if( ElapsedTime.QuadPart < RESTART_DELAY_TIME ) {

        KEVENT Event;

        SacPutSimpleMessage(Reboot ? SAC_PREPARE_RESTART : SAC_PREPARE_SHUTDOWN);

        // wait until the machine has been up for at least RESTART_DELAY_TIME seconds.
        KeInitializeEvent( &Event,
                           SynchronizationEvent,
                           FALSE );

        ElapsedTime.QuadPart = Int32x32To64((LONG)((RESTART_DELAY_TIME-ElapsedTime.LowPart)*10000), // milliseconds until we reach RESTART_DELAY_TIME
                                            -1000);
        KeWaitForSingleObject((PVOID)&Event, Executive, KernelMode,  FALSE, &ElapsedTime);

    }

    Status = NtShutdownSystem(Reboot ? ShutdownReboot : ShutdownPowerOff);

    //
    // Get the global buffer started so that we have room for error messages.
    //
    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Exiting (1).\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


    SacPutSimpleMessage(Reboot ? SAC_RESTART_FAILURE : SAC_SHUTDOWN_FAILURE);
    swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
    SacPutUnicodeString((PWSTR)GlobalBuffer);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoRebootCommand: Exiting.\n")));
}

VOID
DoCrashCommand(
    VOID
    )

/*++

Routine Description:

    This routine does a shutdown and bugcheck.

Arguments:

    None.

Return Value:

        None.

--*/
{
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCrashCommand: Entering.\n")));

    //
    // this call does not return
    //
    KeBugCheckEx(MANUALLY_INITIATED_CRASH, 0, 0, 0, 0);

    // SacPutSimpleMessage( SAC_CRASHDUMP_FAILURE );
    // IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoCrashCommand: Exiting.\n")));
}

VOID
DoTlistCommand(
    VOID
    )

/*++

Routine Description:

    This routine gets a Tlist and displays it.

Arguments:

    None.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    ULONG DataLength;
    PVOID NewBuffer;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Entering.\n")));

    if (GlobalBuffer == NULL) {
        GlobalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);

        if (GlobalBuffer == NULL) {
            SacPutSimpleMessage(SAC_NO_MEMORY);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
            return;
        }

        GlobalBufferSize = MEMORY_INCREMENT;
    }


RetryTList:

    Status = GetTListInfo((PSAC_RSP_TLIST)GlobalBuffer, 
                          (LONG)GlobalBufferSize, 
                          &DataLength
                         );

    if ((Status == STATUS_NO_MEMORY) ||
        (Status == STATUS_INFO_LENGTH_MISMATCH)) {
        //
        // Try to get more memory, if not available, then just fail without out of memory error.
        //
        NewBuffer = ALLOCATE_POOL(GlobalBufferSize + MEMORY_INCREMENT, GENERAL_POOL_TAG);
                                         
        if (NewBuffer != NULL) {

            FREE_POOL(&GlobalBuffer);
            GlobalBuffer = NewBuffer;
            GlobalBufferSize += MEMORY_INCREMENT;
            goto RetryTList;                            
        }
                    
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
        return;

    }

    if (NT_SUCCESS(Status)) {
        PrintTListInfo((PSAC_RSP_TLIST)GlobalBuffer);
    } else {
        SacPutSimpleMessage( SAC_TLIST_FAILURE );
        swprintf((PWSTR)GlobalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
        SacPutUnicodeString((PWSTR)GlobalBuffer);        
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoTlistCommand: Exiting.\n")));
}


NTSTATUS
GetTListInfo(
    OUT PSAC_RSP_TLIST ResponseBuffer,
    IN  LONG ResponseBufferSize,
    OUT PULONG ResponseDataSize
    )

/*++

Routine Description:

    This routine gets all the information necessary for the TList command.

Arguments:

    ResponseBuffer - The buffer to put the results into.
    
    ResponseBufferSize - The length of the above buffer.
    
    ResponseDataSize - The length of the resulting buffer.

Return Value:

        None.

--*/

{
    NTSTATUS Status;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    PUCHAR DataBuffer;
    PUCHAR StartProcessInfo;
    LONG CurrentBufferSize;
    ULONG ReturnLength;
    ULONG TotalOffset;
    ULONG OffsetIncrement = 0;
        
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Entering.\n")));
    
    *ResponseDataSize = 0;

    if (ResponseBufferSize < sizeof(ResponseBuffer)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory.\n")));
        return(STATUS_NO_MEMORY);
    }
    
    DataBuffer = (PUCHAR)(ResponseBuffer + 1);
    CurrentBufferSize = ResponseBufferSize - sizeof(SAC_RSP_TLIST);
    
    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (2).\n")));
        return STATUS_NO_MEMORY;
    }

    //
    // Get system-wide information
    //
    Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                      &(ResponseBuffer->TimeOfDayInfo),
                                      sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error.\n")));
        return(Status);
    }

    Status = ZwQuerySystemInformation(SystemBasicInformation,
                                      &(ResponseBuffer->BasicInfo),
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(2).\n")));
        return(Status);
    }

    //
    // Get pagefile information
    //
    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)DataBuffer;
    Status = ZwQuerySystemInformation(SystemPageFileInformation,
                                      PageFileInfo,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (NT_SUCCESS(Status) && (ReturnLength != 0)) {

        ResponseBuffer->PagefileInfoOffset = ResponseBufferSize - CurrentBufferSize;
        CurrentBufferSize -= ReturnLength;
        DataBuffer += ReturnLength;
    
        if (CurrentBufferSize < 0) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(3).\n")));
            return STATUS_NO_MEMORY;
        }

        //
        // Go thru each pagefile and fixup the names...
        //
        for (; ; ) {

            if (PageFileInfo->PageFileName.Length > CurrentBufferSize) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(3).\n")));
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, 
                          (PUCHAR)(PageFileInfo->PageFileName.Buffer), 
                          PageFileInfo->PageFileName.Length
                         );

            PageFileInfo->PageFileName.Buffer = (PWSTR)DataBuffer;
            DataBuffer += PageFileInfo->PageFileName.Length;
            CurrentBufferSize -= PageFileInfo->PageFileName.Length;

            if (CurrentBufferSize < 0) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (4).\n")));
                return STATUS_NO_MEMORY;
            }

            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
        }

    } else if (((ULONG)CurrentBufferSize) < ReturnLength) {
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(5).\n")));
        return(STATUS_NO_MEMORY);
     
    } else {

        //
        // Either failure or no paging file present.
        //
        ResponseBuffer->PagefileInfoOffset = 0;

    }

    //
    // Get process information
    //
    Status = ZwQuerySystemInformation(SystemFileCacheInformation,
                                      &(ResponseBuffer->FileCache),
                                      sizeof(ResponseBuffer->FileCache),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(4).\n")));
        return(Status);
    }


    Status = ZwQuerySystemInformation(SystemPerformanceInformation,
                                      &(ResponseBuffer->PerfInfo),
                                      sizeof(ResponseBuffer->PerfInfo),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {     
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(5).\n")));
        return(Status);
    }

    //
    // Realign DataBuffer for the next query
    //
    DataBuffer = ALIGN_UP_POINTER(DataBuffer, SYSTEM_PROCESS_INFORMATION);
    CurrentBufferSize = (ULONG)(ResponseBufferSize - (((ULONG_PTR)DataBuffer) - ((ULONG_PTR)ResponseBuffer)));
        
    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory (6).\n")));
        return STATUS_NO_MEMORY;
    }


    Status = ZwQuerySystemInformation(SystemProcessInformation,
                                      DataBuffer,
                                      CurrentBufferSize,
                                      &ReturnLength
                                     );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(6).\n")));
        return(Status);
    }


    StartProcessInfo = DataBuffer;

    ResponseBuffer->ProcessInfoOffset = ResponseBufferSize - CurrentBufferSize;
    DataBuffer += ReturnLength;
    CurrentBufferSize -= ReturnLength;

    if (CurrentBufferSize < 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(7).\n")));
        return STATUS_NO_MEMORY;
    }

    OffsetIncrement = 0;
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)StartProcessInfo;

    do {

        //
        // We have to take the name of each process and pack the UNICODE_STRING
        // buffer in our buffer so it doesn't collide with the subsequent data
        //
        if (ProcessInfo->ImageName.Buffer) {
                
            if (CurrentBufferSize < ProcessInfo->ImageName.Length ) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, error(7).\n")));
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            RtlCopyMemory(DataBuffer, (PUCHAR)(ProcessInfo->ImageName.Buffer), ProcessInfo->ImageName.Length);                        

            ProcessInfo->ImageName.Buffer = (PWSTR)DataBuffer;

            DataBuffer += ProcessInfo->ImageName.Length;
            CurrentBufferSize -= ProcessInfo->ImageName.Length;
            
            if (CurrentBufferSize < 0) {
                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting, no memory(8).\n")));
                return STATUS_NO_MEMORY;
            }

        }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&(StartProcessInfo[TotalOffset]);

    } while( OffsetIncrement != 0 );

    *ResponseDataSize = (ULONG)(ResponseBufferSize - CurrentBufferSize);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC GetTlistInfo: Exiting.\n")));
    return STATUS_SUCCESS;
}

VOID
PrintTListInfo(
    IN PSAC_RSP_TLIST Buffer
    )

/*++

Routine Description:

    This routine prints TList info to the headless terminal.

Arguments:

    Buffer - The buffer with the results.

Return Value:

        None.

--*/

{
    LARGE_INTEGER Time;
    
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    
    ULONG TotalOffset;
    ULONG OffsetIncrement = 0;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;

    ULONG i;

    PUCHAR ProcessInfoStart;
    PUCHAR BufferStart = (PUCHAR)Buffer;

    ULONG LineNumber = 0;

    WCHAR OutputBuffer[200];  // should never be more than 80, but just to be safe....
    
    UNICODE_STRING Process;
    
    BOOLEAN Stop;
    
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Entering.\n")));

    Time.QuadPart = Buffer->TimeOfDayInfo.CurrentTime.QuadPart - Buffer->TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields(&Time, &UpTime);

    swprintf( OutputBuffer, 
              GetMessage( SAC_TLIST_HEADER1_FORMAT ),
              Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize / 1024),
              UpTime.Day,
              UpTime.Hour,
              UpTime.Minute,
              UpTime.Second,
              UpTime.Milliseconds
           );

    SacPutUnicodeString(OutputBuffer);

    LineNumber += 2;

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(BufferStart + Buffer->PagefileInfoOffset);
        
    //
    // Print out the page file information.
    //

    if (Buffer->PagefileInfoOffset == 0) {
    
        SacPutSimpleMessage(SAC_TLIST_NOPAGEFILE);
        LineNumber++;
        
    } else {
    
        for (; ; ) {

            //
            // ensure that the OutputBuffer is big enough to hold the string
            //
            if (((wcslen(GetMessage(SAC_TLIST_PAGEFILE_NAME)) + 
                 wcslen((PWSTR)&(PageFileInfo->PageFileName))) * sizeof(WCHAR)) > (sizeof(OutputBuffer)-2)) {
                
                //
                // Since we don't expect the pagefilename to be > 80 chars, we should stop and 
                // take a look at the name if this does happen
                //
                ASSERT(0);
                
                //
                // give up trying to print page file info
                //
                break;

            }

            swprintf( OutputBuffer, 
                      GetMessage(SAC_TLIST_PAGEFILE_NAME),
                      &PageFileInfo->PageFileName);

            SacPutUnicodeString(OutputBuffer);
            LineNumber++;

            swprintf( OutputBuffer,
                      GetMessage(SAC_TLIST_PAGEFILE_DATA),            
                      PageFileInfo->TotalSize * (Buffer->BasicInfo.PageSize/1024),
                      PageFileInfo->TotalInUse * (Buffer->BasicInfo.PageSize/1024),
                      PageFileInfo->PeakUsage * (Buffer->BasicInfo.PageSize/1024)
                   );
            
            SacPutUnicodeString(OutputBuffer);
            LineNumber++;
            
            if (PageFileInfo->NextEntryOffset == 0) {
                break;
            }

            PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)((PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);

        }

    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //
    if (Buffer->ProcessInfoOffset == 0) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting (1).\n")));
        return;
    }

    OffsetIncrement = 0;
    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);
    ProcessInfoStart = (PUCHAR)ProcessInfo;
    
    do {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart +TotalOffset);
    } while( OffsetIncrement != 0 );

    SumWorkingSet += Buffer->FileCache.CurrentSize/1024;

    if (LineNumber > 17) {
        PutMore(&Stop);

        if (Stop) {
            return;
        }

        LineNumber = 0;
    }

    swprintf(OutputBuffer, 
            GetMessage(SAC_TLIST_MEMORY1_DATA),
            Buffer->BasicInfo.NumberOfPhysicalPages * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.AvailablePages * (Buffer->BasicInfo.PageSize/1024),
            SumWorkingSet,
            (Buffer->PerfInfo.ResidentSystemCodePage + Buffer->PerfInfo.ResidentSystemDriverPage) * 
              (Buffer->BasicInfo.PageSize/1024),
            (Buffer->PerfInfo.ResidentPagedPoolPage) * (Buffer->BasicInfo.PageSize/1024)
           );
    
    SacPutUnicodeString(OutputBuffer);
    LineNumber += 2;
    if (LineNumber > 18) {
        PutMore(&Stop);

        if (Stop) {
            return;
        }

        LineNumber = 0;
    }

    swprintf(OutputBuffer,
            GetMessage(SAC_TLIST_MEMORY2_DATA),
            Buffer->PerfInfo.CommittedPages * (Buffer->BasicInfo.PageSize/1024),
            SumCommit,
            Buffer->PerfInfo.CommitLimit * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.PeakCommitment * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.NonPagedPoolPages * (Buffer->BasicInfo.PageSize/1024),
            Buffer->PerfInfo.PagedPoolPages * (Buffer->BasicInfo.PageSize/1024)
           );

    SacPutUnicodeString(OutputBuffer);

    LineNumber++;
    if (LineNumber > 18) {
        PutMore(&Stop);

        if (Stop) {
            return;
        }

        LineNumber = 0;
    }


    SacPutSimpleMessage(SAC_ENTER);
    PutMore(&Stop);

    if (Stop) {
        return;
    }

    LineNumber = 0;

    SacPutSimpleMessage( SAC_TLIST_PROCESS1_HEADER );
    LineNumber++;

    swprintf(OutputBuffer,
            GetMessage( SAC_TLIST_PROCESS2_HEADER ),
            Buffer->FileCache.CurrentSize/1024,
            Buffer->FileCache.PageFaultCount );

    SacPutUnicodeString(OutputBuffer);
    LineNumber++;
    
    OffsetIncrement = 0;
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    do {
        
        RtlTimeToElapsedTimeFields(&ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields(&ProcessInfo->KernelTime, &KernelTime);

        Process.Buffer = NULL;
        if (ProcessInfo->UniqueProcessId == 0) {
            RtlInitUnicodeString( &Process, L"Idle Process" );
        } else if (!ProcessInfo->ImageName.Buffer) {
            RtlInitUnicodeString( &Process, L"System" );
        }

        swprintf(OutputBuffer, 
                 GetMessage( SAC_TLIST_PROCESS1_DATA ),
                 UserTime.Hour,
                 UserTime.Minute,
                 UserTime.Second,
                 UserTime.Milliseconds,
                 KernelTime.Hour,
                 KernelTime.Minute,
                 KernelTime.Second,
                 KernelTime.Milliseconds,
                 ProcessInfo->WorkingSetSize / 1024,
                 ProcessInfo->PageFaultCount,
                 ProcessInfo->PrivatePageCount / 1024,
                 ProcessInfo->BasePriority,
                 ProcessInfo->HandleCount,
                 ProcessInfo->NumberOfThreads,
                 HandleToUlong(ProcessInfo->UniqueProcessId),
                 Process.Buffer ? &Process : &ProcessInfo->ImageName 
                );

        SacPutUnicodeString(OutputBuffer);

        LineNumber++;

        if( wcslen( OutputBuffer ) >= 80 ) {
            //
            // We line-wrapped, so include the additional line in our running-count.
            //
            LineNumber++;
        }
        
        //
        // update the position in the process list before we check to see if we need
        // to prompt for more.  This way, if we are done, we don't prompt.
        //
        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);
        
        //
        // if there are more records and we have displayed a screen's worth of data
        // Prompt for more and reset the line counter
        //
        if (( OffsetIncrement != 0 ) && (LineNumber > 18)) {
            PutMore(&Stop);

            if (Stop) {
                return;
            }

            LineNumber = 0;

            if (GlobalPagingNeeded) {
                SacPutSimpleMessage( SAC_TLIST_PROCESS1_HEADER );                
            }

            LineNumber++;
        }

    } while( OffsetIncrement != 0 );


    if (!GlobalDoThreads) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting (2).\n")));
        return;
    }

    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    OffsetIncrement = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(BufferStart + Buffer->ProcessInfoOffset);

    PutMore(&Stop);

    if (Stop) {
        return;
    }

    LineNumber = 0;

    SacPutSimpleMessage(SAC_ENTER);
    LineNumber++;

    do {

        Process.Buffer = NULL;
        if (ProcessInfo->UniqueProcessId == 0) {
            RtlInitUnicodeString( &Process, L"Idle Process" );
        } else if (!ProcessInfo->ImageName.Buffer) {
            RtlInitUnicodeString( &Process, L"System" );
        }

        swprintf(OutputBuffer, 
                GetMessage(SAC_TLIST_PSTAT_HEADER),
                HandleToUlong(ProcessInfo->UniqueProcessId),
                ProcessInfo->BasePriority,
                ProcessInfo->HandleCount,
                ProcessInfo->PageFaultCount,
                ProcessInfo->WorkingSetSize / 1024,
                Process.Buffer ? &Process : &ProcessInfo->ImageName
               );

        SacPutUnicodeString(OutputBuffer);
        LineNumber++;
        
        if( wcslen( OutputBuffer ) >= 80 ) {
            //
            // We line-wrapped, so include the additional line in our running-count.
            //
            LineNumber++;
        }
        
        if (LineNumber > 18) {
            PutMore(&Stop);

            if (Stop) {
                return;
            }

            LineNumber = 0;
        }

        i = 0;
        
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        if (ProcessInfo->NumberOfThreads) {

            if ((LineNumber < 18) || !GlobalPagingNeeded) {
                SacPutSimpleMessage( SAC_TLIST_PSTAT_THREAD_HEADER );                
                LineNumber++;
            } else {
                PutMore(&Stop);

                if (Stop) {
                    return;
                }

                LineNumber = 0;
            }

        }

        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            
            swprintf(OutputBuffer, 
                     GetMessage( SAC_TLIST_PSTAT_THREAD_DATA ),
                     ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                     ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                     ThreadInfo->ContextSwitches,
                     ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress,
                     UserTime.Hour,
                     UserTime.Minute,
                     UserTime.Second,
                     UserTime.Milliseconds,
                     KernelTime.Hour,
                     KernelTime.Minute,
                     KernelTime.Second,
                     KernelTime.Milliseconds,
                     StateTable[ThreadInfo->ThreadState],
                     (ThreadInfo->ThreadState == 5) ? WaitTable[ThreadInfo->WaitReason] : Empty
                    );
            SacPutUnicodeString(OutputBuffer);

            LineNumber++;
            
            
            if( wcslen( OutputBuffer ) >= 80 ) {
                //
                // We line-wrapped, so include the additional line in our running-count.
                //
                LineNumber++;
            }

            if (LineNumber > 18) {
                PutMore(&Stop);

                if (Stop) {
                    return;
                }

                LineNumber = 0;

                if (GlobalPagingNeeded) {
                    SacPutSimpleMessage( SAC_TLIST_PSTAT_THREAD_HEADER );
                }

                LineNumber++;
            }


            ThreadInfo += 1;
            i += 1;

        }

        OffsetIncrement = ProcessInfo->NextEntryOffset;
        TotalOffset += OffsetIncrement;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessInfoStart + TotalOffset);

        SacPutSimpleMessage(SAC_ENTER);
        LineNumber++;

        if (LineNumber > 18) {
            PutMore(&Stop);

            if (Stop) {
                return;
            }

            LineNumber = 0;
        }

    } while( OffsetIncrement != 0 );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PrintTlistInfo: Exiting.\n")));
}


VOID
PutMore(
    OUT PBOOLEAN Stop
    )
{
    PHEADLESS_RSP_GET_LINE Response;
    UCHAR Buffer[20];
    SIZE_T Length;
    LARGE_INTEGER WaitTime;
    NTSTATUS Status;

    ASSERT(sizeof(HEADLESS_RSP_GET_LINE) <= (sizeof(UCHAR) * 20));

    if (GlobalPagingNeeded) {
        
        WaitTime.QuadPart = Int32x32To64((LONG)100, -1000); // 100ms from now.
        
        SacPutSimpleMessage( SAC_MORE_MESSAGE );
        
        Response = (PHEADLESS_RSP_GET_LINE)&(Buffer[0]);
        Length = sizeof(UCHAR) * 20;

        Status = HeadlessDispatch(HeadlessCmdGetLine,
                                  NULL,
                                  0,
                                  Response,
                                  &Length
                                 );

        while (NT_SUCCESS(Status) && !Response->LineComplete) {

            KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);
            
            Length = sizeof(UCHAR) * 20;
            Status = HeadlessDispatch(HeadlessCmdGetLine,
                                      NULL,
                                      0,
                                      Response,
                                      &Length
                                     );

        }

        if (Response->Buffer[0] == 0x3) { // Control-C
            *Stop = TRUE;
        } else {
            *Stop = FALSE;
        }

        // 
        // Drain any remaining buffered input
        //
        Length = sizeof(UCHAR) * 20;
        Status = HeadlessDispatch(HeadlessCmdGetLine,
                                  NULL,
                                  0,
                                  Response,
                                  &Length
                                 );

        while (NT_SUCCESS(Status) && Response->LineComplete) {

            Length = sizeof(UCHAR) * 20;
            Status = HeadlessDispatch(HeadlessCmdGetLine,
                                      NULL,
                                      0,
                                      Response,
                                      &Length
                                     );

        }

    } else {
        *Stop = FALSE;
    }

}


NTSTATUS 
CallQueryIPIOCTL(
    HANDLE IpDeviceHandle,
    PKEVENT Event,
    HANDLE EventHandle,
    IO_STATUS_BLOCK *IoStatusBlock,
    PVOID  InputBuffer,
    ULONG  InputBufferSize,
    PVOID  OutputBuffer,
    ULONG  OutputBufferSize,
    BOOLEAN PrintToTerminal,
    BOOLEAN *putPrompt
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;

    //
    // Submit the IOCTL
    //
    Status = NtDeviceIoControlFile(IpDeviceHandle,
                                   EventHandle,
                                   NULL,
                                   NULL,
                                   IoStatusBlock,
                                   IOCTL_TCP_QUERY_INFORMATION_EX,
                                   InputBuffer,
                                   InputBufferSize,
                                   OutputBuffer,
                                   OutputBufferSize);

                                  
    if (Status == STATUS_PENDING) {

        //
        // Wait up to 30 seconds for it to finish
        //
        if (PrintToTerminal != FALSE) {
            SacPutSimpleMessage( SAC_ENTER );
            SacPutSimpleMessage( SAC_RETRIEVING_IPADDR );
            if (putPrompt) {
                *putPrompt= TRUE;
            }
        }
        
        TimeOut.QuadPart = Int32x32To64((LONG)30000, -1000);
        
        Status = KeWaitForSingleObject((PVOID)Event, Executive, KernelMode,  FALSE, &TimeOut);
        
        if (NT_SUCCESS(Status)) {
            Status = IoStatusBlock->Status;
        }

    }

    return(Status);


}


VOID
DoGetNetInfo(
    BOOLEAN PrintToTerminal
    )

/*++

Routine Description:

    This routine attempts to get and print every IP net number and its IP
    address.

Arguments:

    PrintToTerminal - Determines if the IP information is printed ( == TRUE )
           Or sent to the kernel ( == FALSE ) 

Return Value:

        None.

--*/

{
    NTSTATUS Status;
    HANDLE Handle;
    ULONG i;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    
    PTCP_REQUEST_QUERY_INFORMATION_EX TcpRequestQueryInformationEx;
    IPAddrEntry *AddressEntry,*AddressArray;
    IPSNMPInfo *IpsiInfo;
        
    PHEADLESS_CMD_SET_BLUE_SCREEN_DATA LocalPropBuffer = NULL;
    PVOID LocalBuffer;

    PUCHAR pch = NULL;
    ULONG len;
    BOOLEAN putPrompt=FALSE;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Entering.\n")));

    //
    // Alloc space for calling the IP driver
    //
    TcpRequestQueryInformationEx = ALLOCATE_POOL( 
                                        sizeof(TCP_REQUEST_QUERY_INFORMATION_EX), 
                                        GENERAL_POOL_TAG );
    if (TcpRequestQueryInformationEx == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (1).\n")));
        return;
    }

    IpsiInfo = ALLOCATE_POOL( sizeof(IPSNMPInfo), 
                              GENERAL_POOL_TAG );
    if (IpsiInfo == NULL) {
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (1).\n")));
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want the count of interfaces)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_STATS_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    LocalBuffer = ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);
    if (LocalBuffer == NULL) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (6).\n")));            
        FREE_POOL(&TcpRequestQueryInformationEx);
        FREE_POOL(&IpsiInfo);
        return;        
    }

    
    //
    // Start by opening the TCP driver
    //
    RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                       );

    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal ) {   
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
            SacPutSimpleMessage(SAC_ENTER);
        }
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (2).\n")));
        return;
    }
    
    if (SACEvent == NULL) {
        if (PrintToTerminal) {
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
        }
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (14).\n")));
        return;
    }

    //
    // now call the ioctl
    //
    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   IpsiInfo,
                   sizeof(IPSNMPInfo),
                   FALSE,
                   &putPrompt);
    

    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal){
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
        }

        ZwClose(Handle);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    }

    if (IpsiInfo->ipsi_numaddr == 0) {
        if (PrintToTerminal) {
            SacPutSimpleMessage( SAC_IPADDR_NONE );
        }
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;

    }

    //
    // if it succeeded, then allocate space for the array of IP addresses
    //
    AddressArray = ALLOCATE_POOL(IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry), 
                                 GENERAL_POOL_TAG);
    if (AddressArray == NULL) {    
        SacPutSimpleMessage(SAC_NO_MEMORY);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (16).\n")));
        ZwClose(Handle);
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&IpsiInfo);
        FREE_POOL(&TcpRequestQueryInformationEx);
        return;
    
    }

    //
    // zero out the context information and preload with the info we're gonna
    // request (we want the count of interfaces)
    //
    RtlZeroMemory(TcpRequestQueryInformationEx, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    TcpRequestQueryInformationEx->ID.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    TcpRequestQueryInformationEx->ID.toi_type = INFO_TYPE_PROVIDER;
    TcpRequestQueryInformationEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    TcpRequestQueryInformationEx->ID.toi_entity.tei_instance = 0;

    Status = CallQueryIPIOCTL(
                   Handle,
                   SACEvent,
                   SACEventHandle,
                   &IoStatusBlock,
                   TcpRequestQueryInformationEx,
                   sizeof(TCP_REQUEST_QUERY_INFORMATION_EX),
                   AddressArray,
                   IpsiInfo->ipsi_numaddr*sizeof(IPAddrEntry),
                   PrintToTerminal,
                   &putPrompt);

    //
    // don't need this anymore
    //
    FREE_POOL(&TcpRequestQueryInformationEx);
    ZwClose(Handle);

    
    if (!NT_SUCCESS(Status)) {
        if (PrintToTerminal){
            SacPutSimpleMessage(SAC_IPADDR_FAILED);
            swprintf((PWSTR)LocalBuffer, GetMessage( SAC_FAILURE_WITH_ERROR), Status);
            SacPutUnicodeString((PWSTR)LocalBuffer);
            
        }
        FREE_POOL(&LocalBuffer);
        FREE_POOL(&AddressArray);
        FREE_POOL(&IpsiInfo);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoSetIpAddressCommand: Exiting (15).\n")));        
        return;
    }
    

    //
    // Need to allocate a buffer for the XML data.
    //
    if(PrintToTerminal==FALSE) {
        LocalPropBuffer = (PHEADLESS_CMD_SET_BLUE_SCREEN_DATA) ALLOCATE_POOL(2*MEMORY_INCREMENT, GENERAL_POOL_TAG);
        if (LocalPropBuffer == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (6).\n")));            
            FREE_POOL(&AddressArray);
            FREE_POOL(&IpsiInfo);
            return;
        }
        pch = &(LocalPropBuffer->Data[0]);
        len = sprintf((LPSTR)pch,"IPADDRESS");
        LocalPropBuffer->ValueIndex = len+1;
        pch = pch+len+1;
        len = sprintf((LPSTR)pch,"\r\n<PROPERTY.ARRAY NAME=\"IPADDRESS\" TYPE=\"string\">\r\n");
        pch = pch + len;
        len = sprintf((LPSTR)pch,"<VALUE.ARRAY>\r\n");
        pch = pch + len;
    }
    
    //
    // walk the list of IP addresses and spit out the data
    //
    for (i = 0; i < IpsiInfo->ipsi_numaddr; i++) {

        AddressEntry = &AddressArray[i];

        if (IP_LOOPBACK(AddressEntry->iae_addr)) {
            continue;
        }        
        
        if(PrintToTerminal){
           swprintf(LocalBuffer, 
                    GetMessage( SAC_IPADDR_DATA ),
                    AddressEntry->iae_context,
                    AddressEntry->iae_addr & 0xFF,
                    (AddressEntry->iae_addr >> 8) & 0xFF,
                    (AddressEntry->iae_addr >> 16) & 0xFF,
                    (AddressEntry->iae_addr >> 24) & 0xFF,
                    AddressEntry->iae_mask  & 0xFF,
                    (AddressEntry->iae_mask >> 8) & 0xFF,
                    (AddressEntry->iae_mask >> 16) & 0xFF,
                    (AddressEntry->iae_mask >> 24) & 0xFF
                   );
           SacPutUnicodeString(LocalBuffer);

        } else {
           
            len=sprintf((LPSTR)LocalBuffer,"<VALUE>\"%d.%d.%d.%d\"</VALUE>\r\n",
                       AddressEntry->iae_addr & 0xFF,
                       (AddressEntry->iae_addr >> 8) & 0xFF,
                       (AddressEntry->iae_addr >> 16) & 0xFF,
                       (AddressEntry->iae_addr >> 24) & 0xFF
                       );
            if (pch + len < ((PUCHAR) LocalPropBuffer) + 2*MEMORY_INCREMENT - 80){
               // the 80 characters ensures that we can end this XML data
               // properly
               strcat((LPSTR)pch,LocalBuffer);
               pch = pch + len;
            }
        }
    }

  
    if(PrintToTerminal==FALSE) { 
        sprintf((LPSTR)pch, "</VALUE.ARRAY>\r\n</PROPERTY.ARRAY>");
    }

    FREE_POOL(&AddressArray);
    FREE_POOL(&IpsiInfo);

    if(!PrintToTerminal){
        
        
        HeadlessDispatch(HeadlessCmdSetBlueScreenData,
                         LocalPropBuffer,
                         2*MEMORY_INCREMENT,
                         NULL,
                         NULL
                         );
        FREE_POOL(&LocalPropBuffer);

        //
        // open up the IP driver so we know if the addresses change
        //
        RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        Status = ZwOpenFile(&Handle,
                            (ACCESS_MASK)FILE_GENERIC_READ,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0
                           );

        if (!NT_SUCCESS(Status)) {
            
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DoGetNetInfo: Exiting (2).\n")));
            return;
        }

        
        Status = ZwDeviceIoControlFile(Handle,
                                       NULL,
                                       NetAPCRoutine,
                                       NULL,
                                       &GlobalIoStatusBlock,
                                       IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST,
                                       NULL,
                                       0,
                                       NULL,
                                       0
                                      );
                                  
        if (Status == STATUS_PENDING) {
            IoctlSubmitted = TRUE;
        }
        if (putPrompt) {
            SacPutSimpleMessage(SAC_ENTER);
            SacPutSimpleMessage(SAC_PROMPT);            
        }
    }

    ZwClose(Handle);
    return;

}

VOID
NetAPCRoutine(IN PVOID ApcContext,
              IN PIO_STATUS_BLOCK IoStatusBlock,
              IN ULONG Reserved
              )
/*++

Routine Description:
    This is the APC routine called after IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST
    was completed
    
Arguments:
    
    APCContext    - UNUSED
    IoStatusBlock - Status about the Fate of the IRP
    Reserved      - UNUSED
    

Return Value:

        None.

--*/
{
    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(ApcContext);

    if (IoStatusBlock->Status == STATUS_CANCELLED) {
        // The SAC driver might be unloading
        // BUGBUG - If the IP driver is stopped and restarted 
        // then we are out of the loop. What to do ??
                
        return;

    }
    
    // Refresh the kernel information and resend the IRP

    DoGetNetInfo( FALSE );
    
    return;
}


VOID
SubmitIPIoRequest(
    )
/*++

Routine Description:
    Called the first time by the Processing Thread to actually
    submit the ADDR_CHANGE IOCTL to the IP Driver. Only the
    processing thread can call this and calls it only once successfully. 
    Then on the APC is reentered only through the NetAPCRoutine
    
Arguments:
    
    None.

Return Value:

        None.

--*/
{
    

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Submit IP Ioctl: Entering.\n")));

    DoGetNetInfo( FALSE );
    return;
    
}

VOID
CancelIPIoRequest(
    )
/*++

Routine Description:
    Called by the processing thread during unload of the driver
    to cancel the IOCTL sent to the IP driver
    
Arguments:
    
    None.

Return Value:

        None.

--*/
{

    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes; 
    NTSTATUS Status;
    HANDLE Handle;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Cancel IP Ioctl: Entering.\n")));

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenFile(&Handle,
                        (ACCESS_MASK)FILE_GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0
                        );
    
    if (!NT_SUCCESS(Status)) {
        // Well, well IP Driver was probably never loaded.
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC Cancel IP IOCTL: Exiting (2).\n")));
        return;
    }
    ZwCancelIoFile(Handle,
                   &IoStatusBlock
                   );
    ZwClose(Handle);


}

VOID
DoMachineInformationCommand(
    VOID
    )
/*++

Routine Description:

    This function displays the contents of a buffer, which in turn contains
    a bunch of machine-specific information that can be used to help identify
    the machine.
    
Arguments:
    
    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER   TickCount;
    LARGE_INTEGER   ElapsedTime;
    ULONG           ElapsedHours = 0;
    ULONG           ElapsedMinutes = 0;
    ULONG           ElapsedSeconds = 0;
    PWSTR           TmpBuffer;


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Display Machine Information: Entering.\n")));



    //
    // If the information buffer hasn't been filled in yet, there's not much we can do.
    //
    if( MachineInformationBuffer == NULL ) {

        //
        // He's empty.  This shouldn't have happened though because
        // he gets filled as soon as we're initialized.
        //

        IF_SAC_DEBUG( SAC_DEBUG_FUNC_TRACE_LOUD, 
                      KdPrint(("SAC Display Machine Information: MachineInformationBuffer hasn't been initialized yet.\n")));

        SacPutSimpleMessage(SAC_IDENTIFICATION_UNAVAILABLE);

        return;
    }


    //
    // Static information about ourselves.
    //
    SacPutUnicodeString((PWSTR)MachineInformationBuffer);


    //
    // Elapsed machine uptime.
    //

    // Elapsed TickCount
    KeQueryTickCount( &TickCount );

    // ElapsedTime in seconds.
    ElapsedTime.QuadPart = (TickCount.QuadPart)/(10000000/KeQueryTimeIncrement());

    ElapsedHours = (ULONG)(ElapsedTime.QuadPart / 3600);
    ElapsedMinutes = (ULONG)(ElapsedTime.QuadPart % 3600) / 60;
    ElapsedSeconds = (ULONG)(ElapsedTime.QuadPart % 3600) % 60;

    TmpBuffer = (PWSTR)ALLOCATE_POOL( 0x100, GENERAL_POOL_TAG );

    if( TmpBuffer ) {
        swprintf( (PWSTR)TmpBuffer,
                  GetMessage( SAC_HEARTBEAT_FORMAT ),
                  ElapsedHours,
                  ElapsedMinutes,
                  ElapsedSeconds );

        SacPutUnicodeString( (PWSTR)TmpBuffer );

        FREE_POOL( &TmpBuffer );
    }



    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Display Machine Information: Exiting.\n")));


    return;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\data.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for SAC.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#include "sac.h"

NTSTATUS
CreateAdminSecurityDescriptor(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

NTSTATUS
BuildDeviceAcl(
    OUT PACL *DeviceAcl
    );

VOID
WorkerThreadStartUp(
    IN PVOID StartContext
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, InitializeGlobalData)
#pragma alloc_text( INIT, CreateAdminSecurityDescriptor )
#pragma alloc_text( INIT, BuildDeviceAcl )
#endif

//
// Globally defined variables are here.
//
BOOLEAN GlobalDataInitialized = FALSE;
UCHAR TmpBuffer[sizeof(PROCESS_PRIORITY_CLASS)];
BOOLEAN IoctlSubmitted;
LONG ProcessingType;
HANDLE SACEventHandle;
PKEVENT SACEvent=NULL;
LONG Attempts;

#if DBG
ULONG SACDebug = 0x0;
#endif


BOOLEAN
InitializeGlobalData(
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine initializes all the driver components that are shared across devices.

Arguments:

    RegistryPath - A pointer to the location in the registry to read values from.
    DriverObject - pointer to DriverObject

Return Value:

    TRUE if successful, else FALSE

--*/

{
    NTSTATUS Status;
    UNICODE_STRING DosName;
    UNICODE_STRING NtName;
    UNICODE_STRING UnicodeString;

    UNREFERENCED_PARAMETER(RegistryPath);

    PAGED_CODE();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeGlobalData: Entering.\n")));

    if (!GlobalDataInitialized) {
        
        //
        // Create a symbolic link from a DosDevice to this device so that a user-mode app can open us.
        //
        RtlInitUnicodeString(&DosName, SAC_DOSDEVICE_NAME);
        RtlInitUnicodeString(&NtName, SAC_DEVICE_NAME);
        Status = IoCreateSymbolicLink(&DosName, &NtName);

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        //
        // Initialize internal memory system
        //
        if (!InitializeMemoryManagement()) {

            IoDeleteSymbolicLink(&DosName);

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeGlobalData: Exiting with status FALSE\n")));

            return FALSE;
        }

        Status = PreloadGlobalMessageTable(DriverObject->DriverStart);
        if (!NT_SUCCESS(Status)) {

            IoDeleteSymbolicLink(&DosName);

            IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                      KdPrint(( "SAC DriverEntry: unable to pre-load message table: %X\n", Status )));
            return FALSE;
        
        }

        Utf8ConversionBuffer = (PUCHAR)ALLOCATE_POOL(MEMORY_INCREMENT, GENERAL_POOL_TAG);
        if (!Utf8ConversionBuffer) {

            TearDownGlobalMessageTable();

            IoDeleteSymbolicLink(&DosName);

            IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                      KdPrint(( "SAC DriverEntry: unable to allocate memory for UTF8 translation." )));

            return FALSE;
        }

        GlobalDataInitialized = TRUE;
        ProcessingType = SAC_NO_OP;
        IoctlSubmitted = FALSE;
        Attempts = 0;

        //
        // Setup notification event
        //
        RtlInitUnicodeString(&UnicodeString, L"\\SACEvent");
        SACEvent = IoCreateSynchronizationEvent(&UnicodeString, &SACEventHandle);
        
        if (SACEvent == NULL) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeGlobalData: Exiting with Event NULL\n")));

            return FALSE;
        }

        //
        // Retrieve all the machine-specific identification information.
        //
        InitializeMachineInformation();

    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeGlobalData: Exiting with status TRUE\n")));

    return TRUE;
} // InitializeGlobalData


VOID
FreeGlobalData(
    VOID
    )

/*++

Routine Description:

    This routine frees all shared components.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UNICODE_STRING DosName;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeGlobalData: Entering.\n")));

    if (GlobalDataInitialized) {
        if(SACEvent != NULL){
            ZwClose(SACEventHandle);
            SACEvent = NULL;
        }

        TearDownGlobalMessageTable();

        RtlInitUnicodeString(&DosName, SAC_DOSDEVICE_NAME);
        IoDeleteSymbolicLink(&DosName);

        FreeMemoryManagement();
        GlobalDataInitialized = FALSE;
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeGlobalData: Exiting.\n")));

} // FreeGlobalData


BOOLEAN
InitializeDeviceData(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine initializes all the parts specific for each device.

Arguments:

    DeviceObject - pointer to device object to be initialized.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    NTSTATUS Status;
        LARGE_INTEGER Time;
    LONG Priority;
    HEADLESS_CMD_ENABLE_TERMINAL Command;
    PSAC_DEVICE_CONTEXT DeviceContext;

    PAGED_CODE();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeDeviceData: Entering.\n")));

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;

    if (!DeviceContext->InitializedAndReady) {
        
        DeviceObject->StackSize = DEFAULT_IRP_STACK_SIZE;
        DeviceObject->Flags |= DO_DIRECT_IO;

        DeviceContext->DeviceObject = DeviceObject;
        DeviceContext->PriorityBoost = DEFAULT_PRIORITY_BOOST;
        DeviceContext->AdminSecurityDescriptor = NULL;        
        DeviceContext->UnloadDeferred = FALSE;
        DeviceContext->Processing = FALSE;
                
        KeInitializeTimer(&(DeviceContext->Timer));

        KeInitializeDpc(&(DeviceContext->Dpc), &TimerDpcRoutine, DeviceContext);

        KeInitializeSpinLock(&(DeviceContext->SpinLock));
        
        KeInitializeEvent(&(DeviceContext->ProcessEvent), SynchronizationEvent, FALSE);

        //
        // Enable the terminal
        //
        Command.Enable = TRUE;
        Status = HeadlessDispatch(HeadlessCmdEnableTerminal, 
                                  &Command, 
                                  sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                                  NULL,
                                  NULL
                                 );
        if (!NT_SUCCESS(Status)) {

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (1) with status FALSE\n")));
            return FALSE;
        }
        
        //
        // Remember a pointer to the system process.  We'll use this pointer
        // for KeAttachProcess() calls so that we can open handles in the
        // context of the system process.
        //
        DeviceContext->SystemProcess = (PKPROCESS)IoGetCurrentProcess();

        //
        // Create the security descriptor used for raw access checks.
        //
        Status = CreateAdminSecurityDescriptor(DeviceContext);

        if (!NT_SUCCESS(Status)) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (2) with status FALSE\n")));
            Command.Enable = FALSE;
            HeadlessDispatch(HeadlessCmdEnableTerminal, 
                             &Command, 
                             sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                             NULL,
                             NULL
                            );
            return FALSE;
        }

        //
        // Start a thread to handle requests
        //
        Status = PsCreateSystemThread(&(DeviceContext->ThreadHandle),
                                      PROCESS_ALL_ACCESS,
                                      NULL,
                                      NULL,
                                      NULL,
                                      WorkerThreadStartUp,
                                      DeviceContext
                                     );
                                      
        if (!NT_SUCCESS(Status)) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (3) with status FALSE\n")));
            Command.Enable = FALSE;
            HeadlessDispatch(HeadlessCmdEnableTerminal, 
                             &Command, 
                             sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                             NULL,
                             NULL
                            );
            return FALSE;
        }

        //
        // Set this thread to the real-time highest priority so that it will be
        // responsive.
        //
        Priority = HIGH_PRIORITY;
        Status = NtSetInformationThread(DeviceContext->ThreadHandle,
                                        ThreadPriority,
                                        &Priority,
                                        sizeof(Priority)
                                       );

        if (!NT_SUCCESS(Status)) {
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC InitializeDeviceData: Exiting (6) with status FALSE\n")));
                              
            //
            // Tell thread to exit.
            //
            DeviceContext->UnloadDeferred = TRUE;
            KeInitializeEvent(&(DeviceContext->UnloadEvent), SynchronizationEvent, FALSE);
            KeSetEvent(&(DeviceContext->ProcessEvent), DeviceContext->PriorityBoost, FALSE);    
            Status = KeWaitForSingleObject((PVOID)&(DeviceContext->UnloadEvent), Executive, KernelMode,  FALSE, NULL);
            ASSERT(Status == STATUS_SUCCESS);

            Command.Enable = FALSE;
            HeadlessDispatch(HeadlessCmdEnableTerminal, 
                             &Command, 
                             sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                             NULL,
                             NULL
                            );
            return FALSE;
        }

        //
        // Start our timer
        //
        Time.QuadPart = Int32x32To64((LONG)100, -1000); // 100ms from now.
        KeSetTimerEx(&(DeviceContext->Timer), Time, (LONG)100, &(DeviceContext->Dpc)); // every 100ms

        //
        // Display the prompt
        //
        SacPutSimpleMessage( SAC_ENTER );
        SacPutSimpleMessage( SAC_INITIALIZED );
        SacPutSimpleMessage( SAC_ENTER );
        SacPutSimpleMessage( SAC_PROMPT );

        DeviceContext->InitializedAndReady = TRUE;


    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InitializeDeviceData: Exiting with status TRUE\n")));

    return TRUE;
} // InitializeDeviceData


VOID
FreeDeviceData(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine frees all components specific to a device..

Arguments:

    DeviceContext - The device to work on.

Return Value:

    It will stop and wait, if necessary, for any processing to complete.

--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;
    PVOID MemToFree;
    PSAC_DEVICE_CONTEXT DeviceContext;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Entering.\n")));

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;

    if (!GlobalDataInitialized || !DeviceContext->InitializedAndReady) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Exiting.\n")));
        return;
    }

    //
    // Wait for all processing to complete
    //
    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);
    
    DeviceContext->UnloadDeferred = TRUE;

    while (DeviceContext->Processing) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Waiting....\n")));

        KeInitializeEvent(&(DeviceContext->UnloadEvent), SynchronizationEvent, FALSE);

        KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
        
        Status = KeWaitForSingleObject((PVOID)&(DeviceContext->UnloadEvent), Executive, KernelMode,  FALSE, NULL);

        ASSERT(Status == STATUS_SUCCESS);

        KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);

    }

    DeviceContext->Processing = TRUE;

    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
    
    KeCancelTimer(&(DeviceContext->Timer));
    
    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);
    
    DeviceContext->Processing = FALSE;

    MemToFree = (PVOID)DeviceContext->AdminSecurityDescriptor;
    DeviceContext->AdminSecurityDescriptor = NULL;
    

    //
    // Signal the thread to exit
    //
    KeInitializeEvent(&(DeviceContext->UnloadEvent), SynchronizationEvent, FALSE);
    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
    KeSetEvent(&(DeviceContext->ProcessEvent), DeviceContext->PriorityBoost, FALSE);    
    
    Status = KeWaitForSingleObject((PVOID)&(DeviceContext->UnloadEvent), Executive, KernelMode,  FALSE, NULL);
    ASSERT(Status == STATUS_SUCCESS);

    //
    // Finish up cleaning up.
    //
    IoUnregisterShutdownNotification(DeviceObject);

    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);
    
    DeviceContext->InitializedAndReady = FALSE;
    DeviceContext->UnloadDeferred = FALSE;

    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);

    if (MemToFree != NULL) {
        ExFreePool(MemToFree);
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeDeviceData: Exiting.\n")));
} // FreeDeviceData


NTSTATUS
BuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators and LocalSystem
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid;
    PSID SystemSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC BuildDeviceAcl: Entering.\n")));
    
    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    //SeEnableAccessToExports();

    AdminsSid = SeExports->SeAliasAdminsSid;
    SystemSid = SeExports->SeLocalSystemSid;

    AclLength = sizeof(ACL) + (2 * sizeof(ACCESS_ALLOWED_ACE)) +
                RtlLengthSid(AdminsSid) + RtlLengthSid(SystemSid) -
                (2 * sizeof(ULONG));

    NewAcl = ALLOCATE_POOL(AclLength, SECURITY_POOL_TAG);

    if (NewAcl == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);

    if (!NT_SUCCESS(Status)) {
        FREE_POOL(&NewAcl);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC BuildDeviceAcl: Exiting with status 0x%x\n", Status)));
        return(Status);
    }

    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    AdminsSid
                                   );

    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    SystemSid
                                   );

    ASSERT(NT_SUCCESS(Status));

    *DeviceAcl = NewAcl;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC BuildDeviceAcl: Exiting with status 0x%x\n", STATUS_SUCCESS)));
    return(STATUS_SUCCESS);

} // BuildDeviceAcl


NTSTATUS
CreateAdminSecurityDescriptor(
    PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to Administrtors and LocalSystem. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    DeviceContext - A pointer to the device to work on.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  RawAcl = NULL;
    NTSTATUS              Status;
    BOOLEAN               MemoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  SecurityDescriptor;
    ULONG                 SecurityDescriptorLength;
    CHAR                  Buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  LocalSecurityDescriptor = (PSECURITY_DESCRIPTOR) &Buffer;
    PSECURITY_DESCRIPTOR  LocalAdminSecurityDescriptor;
    SECURITY_INFORMATION  SecurityInformation = DACL_SECURITY_INFORMATION;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC CreateAdminSecDesc: Entering.\n")));

    //
    // Get a pointer to the security descriptor from the device object.
    //
    Status = ObGetObjectSecurity(DeviceContext->DeviceObject,
                                 &SecurityDescriptor,
                                 &MemoryAllocated
                                );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(("SAC: Unable to get security descriptor, error: %x\n", Status)));
        ASSERT(MemoryAllocated == FALSE);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC CreateAdminSecDesc: Exiting with status 0x%x\n", Status)));
        return(Status);
    }

    //
    // Build a local security descriptor with an ACL giving only
    // administrators and system access.
    //
    Status = BuildDeviceAcl(&RawAcl);

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(("SAC CreateAdminSecDesc: Unable to create Raw ACL, error: %x\n", Status)));
        goto ErrorExit;
    }

    (VOID)RtlCreateSecurityDescriptor(LocalSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION
                                     );

    (VOID)RtlSetDaclSecurityDescriptor(LocalSecurityDescriptor,
                                       TRUE,
                                       RawAcl,
                                       FALSE
                                      );

    //
    // Make a copy of the security descriptor. This copy will be the raw descriptor.
    //
    SecurityDescriptorLength = RtlLengthSecurityDescriptor(SecurityDescriptor);

    LocalAdminSecurityDescriptor = ExAllocatePoolWithTag(PagedPool,
                                                         SecurityDescriptorLength,
                                                         SECURITY_POOL_TAG
                                                        );

    if (LocalAdminSecurityDescriptor == NULL) {
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(("SAC CreateAdminSecDesc: couldn't allocate security descriptor\n")));
        goto ErrorExit;
    }

    RtlMoveMemory(LocalAdminSecurityDescriptor,
                  SecurityDescriptor,
                  SecurityDescriptorLength
                 );

    DeviceContext->AdminSecurityDescriptor = LocalAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    Status = SeSetSecurityDescriptorInfo(NULL,
                                         &SecurityInformation,
                                         LocalSecurityDescriptor,
                                         &(DeviceContext->AdminSecurityDescriptor),
                                         NonPagedPool,
                                         IoGetFileObjectGenericMapping()
                                        );

    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(("SAC CreateAdminSecDesc: SeSetSecurity failed, %lx\n", Status)));
        ASSERT(DeviceContext->AdminSecurityDescriptor == LocalAdminSecurityDescriptor);
        ExFreePool(DeviceContext->AdminSecurityDescriptor);
        DeviceContext->AdminSecurityDescriptor = NULL;
        goto ErrorExit;
    }

    if (DeviceContext->AdminSecurityDescriptor != LocalAdminSecurityDescriptor) {
        ExFreePool(LocalAdminSecurityDescriptor);
    }

    Status = STATUS_SUCCESS;

ErrorExit:

    ObReleaseObjectSecurity(SecurityDescriptor, MemoryAllocated);

    if (RawAcl != NULL) {
        FREE_POOL(&RawAcl);
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC CreateAdminSecDesc: Exiting with status 0x%x\n", Status)));

    return(Status);
}

VOID
WorkerThreadStartUp(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine is the start up routine for the worker thread.  It justn
    sends the worker thread to the processing routine.

Arguments:

    StartContext - A pointer to the device to work on.

Return Value:

    None.

--*/

{
    WorkerProcessEvents((PSAC_DEVICE_CONTEXT)StartContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\event.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains the event handling routines for SAC.

Author:

    Sean Selitrennikoff (v-seans) - Jan 22, 1999

Revision History:

--*/

#include "sac.h"

//
// Definitions for this file.
//

#define RESPONSE_BUFFER_SIZE (80 + sizeof(HEADLESS_RSP_GET_LINE) - sizeof(UCHAR))
UCHAR ResponseBuffer[RESPONSE_BUFFER_SIZE];

//
// Forward declarations for this file.
//
VOID
ProcessInputLine(
    VOID
    );

VOID
WorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )

/*++

Routine Description:

        This is the routine for the worker thread.  It blocks on an event, when
    the event is signalled, then that indicates a request is ready to be processed.    

Arguments:

    DeviceContext - A pointer to this device.

Return Value:

        None.

--*/
{
    NTSTATUS Status;
    KIRQL OldIrql;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC WorkerProcessEvents: Entering.\n")));

    //
    // Loop forever.
    //
    while (1) {

        //
        // Block until there is work to do.
        //
        Status = KeWaitForSingleObject((PVOID)&(DeviceContext->ProcessEvent), Executive, KernelMode,  FALSE, NULL);

        if (DeviceContext->UnloadDeferred) {
            CancelIPIoRequest();
            SacPutSimpleMessage(SAC_ENTER);
            SacPutSimpleMessage(SAC_UNLOADED);
            SacPutSimpleMessage(SAC_ENTER);
            KeSetEvent(&(DeviceContext->UnloadEvent), DeviceContext->PriorityBoost, FALSE);
            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC WorkerProcessEvents: Terminating.\n")));
            PsTerminateSystemThread(STATUS_SUCCESS);
        }
        switch ( ProcessingType ){
        
        case SAC_PROCESS_INPUT:
            //
            // Process the input line.
            //
            ProcessInputLine();

            //
            // Put the next command prompt
            //
            SacPutSimpleMessage(SAC_PROMPT);
            break;

        case SAC_SUBMIT_IOCTL:
            if ( !IoctlSubmitted ) {
                // submit the notify request with the 
                // IP driver. This procedure will also 
                // ensure that it is done only once in 
                // the lifetime of the driver.
                SubmitIPIoRequest();
            }
            break;
        default:
            break;
        }
        

        //
        // Unset the processing flag
        //
        KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);

        DeviceContext->Processing = FALSE;

        KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);

        //
        // If there is any stuff that got delayed, process it.
        //
        DoDeferred(DeviceContext);
    }

    ASSERT(0);
}




VOID
DoDeferred(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    )
{
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC DoDeferred: Entering.\n")));

    if (DeviceContext->UnloadDeferred) {

        KeSetEvent(&(DeviceContext->UnloadEvent), DeviceContext->PriorityBoost, FALSE);

    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC DoDeferred: Exiting.\n")));

}

VOID
TimerDpcRoutine(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

        This is a DPC routine that is queue'd by DriverEntry.  It is used to check for any
    user input and then processes them.

Arguments:

    DeferredContext - A pointer to the device context.
    
    All other parameters are unused.

Return Value:

        None.

--*/
{
    PSAC_DEVICE_CONTEXT DeviceContext = (PSAC_DEVICE_CONTEXT)DeferredContext;
    KIRQL OldIrql;
    SIZE_T i;
    PHEADLESS_RSP_GET_LINE Response;
    NTSTATUS Status;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Entering.\n")));

        UNREFERENCED_PARAMETER(Dpc);
        UNREFERENCED_PARAMETER(SystemArgument1);
        UNREFERENCED_PARAMETER(SystemArgument2);

    KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);

    //
    // If we are processing, then move on.
    //
    if (DeviceContext->Processing) {
        KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Exiting.\n")));
        return;
    }

    DeviceContext->Processing = TRUE;

    KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);

    //
    // Check for user input
    //
    i = RESPONSE_BUFFER_SIZE;
    Response = (PHEADLESS_RSP_GET_LINE)ResponseBuffer;
    Status = HeadlessDispatch(HeadlessCmdGetLine,
                              NULL,
                              0,
                              Response,
                              &i
                             );

    if (NT_SUCCESS(Status) && Response->LineComplete) {

        //
        // Lower case all the characters.  We do not use strlwr() or the like, so that
        // the SAC (expecting ASCII always) doesn't accidently get DBCS or the like 
        // translation of the UCHAR stream.
        //
        Response->Buffer[(RESPONSE_BUFFER_SIZE - sizeof(HEADLESS_RSP_GET_LINE)) / sizeof(UCHAR)] = '\0';
        
        for (i = 0; Response->Buffer[i] != '\0'; i++) {
            if ((Response->Buffer[i] >= 'A') && (Response->Buffer[i] <= 'Z')) {
                Response->Buffer[i] = Response->Buffer[i] - 'A' + 'a';
            }
        }

        //
        // Fire off the worker thread to do the line.  It will unset the processing
        // flag when it is done.
        //
        ProcessingType = SAC_PROCESS_INPUT;

        KeSetEvent(&(DeviceContext->ProcessEvent), DeviceContext->PriorityBoost, FALSE);
        
    } else {
        
        if ( !IoctlSubmitted ) {
            
            // We Still need to try and submit the notify IOCTL
            
            if(Attempts == 0){

                ProcessingType = SAC_SUBMIT_IOCTL;

                Attempts = SAC_RETRY_GAP;

                KeSetEvent(&(DeviceContext->ProcessEvent), DeviceContext->PriorityBoost, FALSE);


                IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Exiting.\n")));

                return;

            } else {

                Attempts --;
            }
        }
        KeAcquireSpinLock(&(DeviceContext->SpinLock), &OldIrql);

        DeviceContext->Processing = FALSE;

        KeReleaseSpinLock(&(DeviceContext->SpinLock), OldIrql);

        //
        // If there is any, process it.
        //
        DoDeferred(DeviceContext);

    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE_LOUD, KdPrint(("SAC TimerDpcRoutine: Exiting.\n")));
}

VOID
ProcessInputLine(
    VOID
    )

/*++

Routine Description:

        This routine is called to process an input line.

Arguments:

    None.

Return Value:

        None.

--*/

{
    HEADLESS_CMD_DISPLAY_LOG Command;
    PUCHAR          InputLine;
    BOOLEAN         CommandFound = FALSE;

    InputLine = &(((PHEADLESS_RSP_GET_LINE)ResponseBuffer)->Buffer[0]);

    if (!strcmp((LPSTR)InputLine, TLIST_COMMAND_STRING)) {
        DoTlistCommand();
        CommandFound = TRUE;
    } else if ((!strcmp((LPSTR)InputLine, HELP1_COMMAND_STRING)) ||
               (!strcmp((LPSTR)InputLine, HELP2_COMMAND_STRING))) {
        DoHelpCommand();
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, DUMP_COMMAND_STRING)) {

        Command.Paging = GlobalPagingNeeded;
        HeadlessDispatch(HeadlessCmdDisplayLog,
                         &Command,
                         sizeof(HEADLESS_CMD_DISPLAY_LOG),
                         NULL,
                         NULL
                        );
        CommandFound = TRUE;
                         
    } else if (!strcmp((LPSTR)InputLine, FULLINFO_COMMAND_STRING)) {
        DoFullInfoCommand();
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, PAGING_COMMAND_STRING)) {
        DoPagingCommand();
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, REBOOT_COMMAND_STRING)) {
        DoRebootCommand(TRUE);
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, SHUTDOWN_COMMAND_STRING)) {
        DoRebootCommand(FALSE);
        CommandFound = TRUE;
    } else if (!strcmp((LPSTR)InputLine, CRASH_COMMAND_STRING)) {
        CommandFound = TRUE;
        DoCrashCommand(); // this call does not return
    } else if (!strncmp((LPSTR)InputLine, 
                        KILL_COMMAND_STRING, 
                        sizeof(KILL_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            DoKillCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        LOWER_COMMAND_STRING, 
                        sizeof(LOWER_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            DoLowerPriorityCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        RAISE_COMMAND_STRING, 
                        sizeof(RAISE_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            DoRaisePriorityCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        LIMIT_COMMAND_STRING, 
                        sizeof(LIMIT_COMMAND_STRING) - sizeof(UCHAR))) {
        if ((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) {
            DoLimitMemoryCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strncmp((LPSTR)InputLine, 
                        TIME_COMMAND_STRING, 
                        sizeof(TIME_COMMAND_STRING) - sizeof(UCHAR))) {
        if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
            (strlen((LPSTR)InputLine) == 1)) {
            DoSetTimeCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if (!strcmp((LPSTR)InputLine, INFORMATION_COMMAND_STRING)) {
        DoMachineInformationCommand();
        CommandFound = TRUE;
    } else if (!strncmp((LPSTR)InputLine, 
                        SETIP_COMMAND_STRING, 
                        sizeof(SETIP_COMMAND_STRING) - sizeof(UCHAR))) {
        if (((strlen((LPSTR)InputLine) > 1) && (InputLine[1] == ' ')) ||
            (strlen((LPSTR)InputLine) == 1)) {
            DoSetIpAddressCommand(InputLine);
            CommandFound = TRUE;
        }
    } else if ((InputLine[0] == '\n') || (InputLine[0] == '\0')) {
        CommandFound = TRUE;
    }


    if( !CommandFound ) {
        //
        // We don't know what this is.
        //
        SacPutSimpleMessage(SAC_UNKNOWN_COMMAND);
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the SAC device driver.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#include "sac.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SAC device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    CLONG i;
    BOOLEAN Success;
    PDEVICE_OBJECT DeviceObject;
    PSAC_DEVICE_CONTEXT DeviceContext;
    HEADLESS_RSP_QUERY_INFO Response;
    SIZE_T Length;

    PAGED_CODE( );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DriverEntry: Entering.\n")));


    //
    // If the system is not setup to use a terminal, then just exit now.
    //
    Length = sizeof(HEADLESS_RSP_QUERY_INFO);
    HeadlessDispatch(HeadlessCmdQueryInformation, 
                     NULL,
                     0,
                     &Response,
                     &Length
                    );

    if ((Response.PortType == HeadlessUndefinedPortType) ||
        ((Response.PortType == HeadlessSerialPort) && !Response.Serial.TerminalAttached)) {
        return STATUS_PORT_DISCONNECTED;
    }

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // An ACL to the device object in InitializeDeviceData().
    //

    RtlInitUnicodeString(&DeviceName,  SAC_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject,            // DriverObject
                            sizeof(SAC_DEVICE_CONTEXT), // DeviceExtension
                            &DeviceName,             // DeviceName
                            FILE_DEVICE_NAMED_PIPE,  // DeviceType
                            0,                       // DeviceCharacteristics
                            FALSE,                   // Exclusive
                            &DeviceObject            // DeviceObject
                           );


    if (!NT_SUCCESS(Status)) {
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(( "SAC DriverEntry: unable to create device object: %X\n", Status )));
        goto ErrorExit;
    }

    DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;
    DeviceContext->InitializedAndReady = FALSE;

    //
    // Initialize the driver object for this file system driver.
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = Dispatch;
    }
    //
    // Special case for IRP_MJ_DEVICE_CONTROL since it is
    // the most often used function in SAC.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = DispatchShutdownControl;
    DriverObject->FastIoDispatch = NULL;
    DriverObject->DriverUnload = UnloadHandler;    

    //
    // Initialize global data.
    //
    Success = InitializeGlobalData(RegistryPath, DriverObject);
    if (!Success) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // Initialize our device object.
    //
    Success = InitializeDeviceData(DeviceObject);
    if (!Success) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // Register that we want shutdown notification.  If this fails, no big deal, as
    // we only lose telling the user of this development.
    //
    IoRegisterShutdownNotification(DeviceObject);

    return (Status);

ErrorExit:
    
    FreeGlobalData();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DriverEntry: Exiting with status 0x%x\n", Status)));    

    return Status;

} // DriverEntry


VOID
UnloadHandler(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the routine for handling unloading of the driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT DeviceContext;
    PDEVICE_OBJECT NextDeviceContext;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC UnloadHandler: Entering.\n")));

    //
    // Walk down each device, disconnecting it and freeing it.
    //
    DeviceContext = DriverObject->DeviceObject;

    while (DeviceContext != NULL) {

        NextDeviceContext = (PDEVICE_OBJECT)DeviceContext->NextDevice;

        FreeDeviceData(DeviceContext);

        IoDeleteDevice(DeviceContext);

        DeviceContext = NextDeviceContext;

    }

    //
    // Free global data
    //
    FreeGlobalData();

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC UnloadHandler: Exiting.\n")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\dispatch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch routines for SAC.

Author:

    Sean Selitrennikoff (v-seans) - Jan 13, 1999

Revision History:

--*/

#include "sac.h"

NTSTATUS
DispatchClose(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    );

NTSTATUS
DispatchCreate(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    );

VOID
CancelReceiveIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
CompleteSendIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
CancelSendIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    

NTSTATUS
Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PSAC_DEVICE_CONTEXT DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC Dispatch: Entering.\n")));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {
    
    case IRP_MJ_CREATE:
        
        Status = DispatchCreate(DeviceContext, Irp);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC Dispatch: Exiting with status 0x%x\n", Status)));

        return Status;

    case IRP_MJ_CLEANUP:

        Status = STATUS_SUCCESS;

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC Dispatch: Exiting cleanup status 0x%x\n", Status)));

        return Status;

    case IRP_MJ_CLOSE:

        Status = DispatchClose(DeviceContext, Irp);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                              KdPrint(("SAC Dispatch: Exiting close status 0x%x\n", Status)));

        return Status;

    case IRP_MJ_DEVICE_CONTROL:

        Status = DispatchDeviceControl(DeviceObject, Irp);

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC Dispatch: Exiting with status 0x%x\n", Status)));

        return Status;

    default:
        IF_SAC_DEBUG(SAC_DEBUG_FAILS, 
                          KdPrint(( "SAC Dispatch: Invalid major function %lx\n", IrpSp->MajorFunction )));
        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

        Status = STATUS_NOT_IMPLEMENTED;
        
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC Dispatch: Exiting with status 0x%x\n", Status)));

        return Status;
    }

} // Dispatch


NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC IOCTLs.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS Status;
    
    PSAC_DEVICE_CONTEXT DeviceContext = (PSAC_DEVICE_CONTEXT)DeviceObject;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchDeviceControl: Entering.\n")));

    //
    // If we made it this far, then the ioctl is invalid.
    //
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, DeviceContext->PriorityBoost);

    Status = STATUS_INVALID_DEVICE_REQUEST;
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC DispatchDeviceControl: Exiting with status 0x%x\n", Status)));

    return Status;

} // DispatchDeviceControl


NTSTATUS
DispatchShutdownControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine which receives the shutdown IRP.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchShutdownControl: Entering.\n")));

    //
    // Notify any user.
    //
    SacPutSimpleMessage(SAC_ENTER);
    SacPutSimpleMessage(SAC_SHUTDOWN);
    SacPutSimpleMessage(SAC_ENTER);
    
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchShutdownControl: Exiting.\n")));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

} // DispatchShutdownControl


NTSTATUS
DispatchCreate(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC IOCTL Create

Arguments:

    DeviceContext - Pointer to device context for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchCreate: Entering.\n")));

    //
    // Check to see if we are done initializing.
    //
    if (!GlobalDataInitialized || !DeviceContext->InitializedAndReady) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, DeviceContext->PriorityBoost);

        Status = STATUS_INVALID_DEVICE_STATE;

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC DispatchCreate: Exiting with status 0x%x\n", Status)));

        return Status;
    }

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //
    switch (IrpSp->MajorFunction) {
    
    //
    // The Create function opens a connection to this device.
    //
    case IRP_MJ_CREATE:

        Status = STATUS_UNSUCCESSFUL;
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, DeviceContext->PriorityBoost);

    //
    // Return the immediate status code to the caller.
    //

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC DispatchCreate: Exiting with status 0x%x\n", Status)));

    return Status;

}


NTSTATUS
DispatchClose(
    IN PSAC_DEVICE_CONTEXT DeviceContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for SAC IOCTL Close

Arguments:

    DeviceContext - Pointer to device context for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS Status;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC DispatchClose: Entering.\n")));

    //
    // Check to see if we are done initializing.
    //
    if (!GlobalDataInitialized || !DeviceContext->InitializedAndReady) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (Irp, DeviceContext->PriorityBoost);

        Status = STATUS_INVALID_DEVICE_STATE;

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC DispatchClose: Exiting with status 0x%x\n", Status)));

        return Status;
    }



    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest (Irp, DeviceContext->PriorityBoost);

    Status = STATUS_UNSUCCESSFUL;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\sac.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sac.h

Abstract:

    This is the local header file for SAC.   It includes all other
    necessary header files for this driver.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#ifndef _SACP_
#define _SACP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4206)   // translation unit empty
#pragma warning(disable:4706)   // assignment within conditional
#pragma warning(disable:4324)   // structure was padded
#pragma warning(disable:4328)   // greater alignment than needed


#include <stdio.h>
#include <ntosp.h>
#include <zwapi.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

#include "sacmsg.h"

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

//
// Debug spew control
//
#if DBG
extern ULONG SACDebug;
#define SAC_DEBUG_FUNC_TRACE           0x0001
#define SAC_DEBUG_FAILS                0x0004
#define SAC_DEBUG_RECEIVE              0x0008
#define SAC_DEBUG_FUNC_TRACE_LOUD      0x2000  // Warning! This could get loud!
#define SAC_DEBUG_MEM                  0x1000  // Warning! This could get loud!

#define IF_SAC_DEBUG(x, y) if ((x) & SACDebug) { y; }
#else
#define IF_SAC_DEBUG(x, y)
#endif

//
// Device name
//
#define SAC_DEVICE_NAME L"\\Device\\SAC"
#define SAC_DOSDEVICE_NAME L"\\DosDevices\\SAC"


//
// Commands
//
#define HELP1_COMMAND_STRING    "?"
#define HELP2_COMMAND_STRING    "help"
#define CRASH_COMMAND_STRING    "crashdump"
#define DUMP_COMMAND_STRING     "d"
#define FULLINFO_COMMAND_STRING "f"
#define SETIP_COMMAND_STRING    "i"
#define INFORMATION_COMMAND_STRING "id"
#define KILL_COMMAND_STRING     "k"
#define LOWER_COMMAND_STRING    "l"
#define LIMIT_COMMAND_STRING    "m"
#define PAGING_COMMAND_STRING   "p"
#define RAISE_COMMAND_STRING    "r"
#define REBOOT_COMMAND_STRING   "restart"
#define TIME_COMMAND_STRING     "s"
#define SHUTDOWN_COMMAND_STRING "shutdown"
#define TLIST_COMMAND_STRING    "t"



//
// Device port - a random number :-)
//
#define SAC_PORT_NUMBER 385

//
// Memory tags
//
#define ALLOC_POOL_TAG             ((ULONG)'ApcR')
#define FREE_POOL_TAG              ((ULONG)'FpcR')
#define INITIAL_POOL_TAG           ((ULONG)'IpcR')
#define IRP_POOL_TAG               ((ULONG)'JpcR')
#define SECURITY_POOL_TAG          ((ULONG)'SpcR')
#define GENERAL_POOL_TAG           ((ULONG)'GpcR')



//
// Global data 
//
extern BOOLEAN GlobalDataInitialized;
extern BOOLEAN GlobalPagingNeeded;
extern BOOLEAN IoctlSubmitted;
extern LONG ProcessingType;
extern HANDLE SACEventHandle;
extern PKEVENT SACEvent;
extern LONG Attempts;
extern PWSTR MachineInformationBuffer;
extern char* GlobalBuffer;
extern ULONG GlobalBufferSize;
extern PUCHAR Utf8ConversionBuffer;

#define MEMORY_INCREMENT 0x1000

#define DEFAULT_IRP_STACK_SIZE 16
#define DEFAULT_PRIORITY_BOOST 2
#define SAC_SUBMIT_IOCTL 1
#define SAC_PROCESS_INPUT 2
#define SAC_NO_OP 0
#define SAC_RETRY_GAP 10
//
// Context for each device created
//
typedef struct _SAC_DEVICE_CONTEXT {

    PDEVICE_OBJECT DeviceObject;        // back pointer to the device object.

    BOOLEAN InitializedAndReady;        // Is this device ready to go?
    BOOLEAN Processing;                 // Is something being processed on this device?
    BOOLEAN UnloadDeferred;             // Should whoever is processing deal with an unload when done?

    CCHAR PriorityBoost;                // boost to priority for completions.
    PKPROCESS SystemProcess;            // context for grabbing handles
    PSECURITY_DESCRIPTOR AdminSecurityDescriptor; 
    KSPIN_LOCK SpinLock;                // Used to lock this data structure for access.
    KEVENT UnloadEvent;                 // Used to signal the thread trying to unload to continue processing.
    KEVENT ProcessEvent;                // Used to signal worker thread to process the next request.

    HANDLE ThreadHandle;                // Handle for the worker thread.
    
    KTIMER Timer;                       // Used to poll for user input.
    KDPC Dpc;                           // Used with the above timer.

} SAC_DEVICE_CONTEXT, * PSAC_DEVICE_CONTEXT;


//
// Memory management routines
//
#define ALLOCATE_POOL(b,t) MyAllocatePool( b, t, __FILE__, __LINE__ )
#define FREE_POOL(b) MyFreePool( b )

BOOLEAN
InitializeMemoryManagement(
    VOID
    );

VOID
FreeMemoryManagement(
    VOID
    );

PVOID
MyAllocatePool(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

VOID
MyFreePool(
    IN PVOID Pointer
    );

//
// Initialization routines.
//
BOOLEAN
InitializeGlobalData(
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_OBJECT DriverObject
    );

VOID
FreeGlobalData(
    VOID
    );

BOOLEAN
InitializeDeviceData(
    PDEVICE_OBJECT DeviceObject
    );

VOID
FreeDeviceData(
    PDEVICE_OBJECT DeviceContext
    );


//
// Dispatch routines
//
NTSTATUS
Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DispatchShutdownControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UnloadHandler(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DispatchSend(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

VOID
DoDeferred(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );

VOID
TimerDpcRoutine(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Worker thread routines.
//
VOID
WorkerProcessEvents(
    IN PSAC_DEVICE_CONTEXT DeviceContext
    );


//
// Routines in cmd.c
//
VOID
DoHelpCommand(
    VOID
    );

VOID
DoKillCommand(
    PUCHAR InputLine
    );

VOID
DoLowerPriorityCommand(
    PUCHAR InputLine
    );

VOID
DoRaisePriorityCommand(
    PUCHAR InputLine
    );

VOID
DoLimitMemoryCommand(
    PUCHAR InputLine
    );

VOID
DoSetTimeCommand(
    PUCHAR InputLine
    );

VOID
DoSetIpAddressCommand(
    PUCHAR InputLine
    );

VOID
DoRebootCommand(
    BOOLEAN Reboot
    );

VOID
DoCrashCommand(
    VOID
    );

VOID
DoFullInfoCommand(
    VOID
    );

VOID
DoPagingCommand(
    VOID
    );

VOID
DoTlistCommand(
    VOID
    );

VOID
SubmitIPIoRequest(
    );

VOID
CancelIPIoRequest(
    );

VOID
DoMachineInformationCommand(
    VOID
    );

//
// routines in util.c
//
NTSTATUS
PreloadGlobalMessageTable(
    PVOID ImageHandle
    );

NTSTATUS
TearDownGlobalMessageTable(
    VOID
    );

PCWSTR
GetMessage(
    ULONG MessageId
    );

BOOLEAN
SacPutSimpleMessage(
    ULONG MessageId
    );

BOOLEAN
SacPutUnicodeString(
    PCWSTR String
    );

VOID
SacPutString(
    PUCHAR String
    );

VOID
InitializeMachineInformation(
    VOID
    );

#endif // ndef _SACP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=drivers
MINORCOMP=sac

TARGETNAME=sacdrv
TARGETPATH=obj
TARGETTYPE=DRIVER

TARGETLIBS=

INCLUDES=$(BASE_INC_PATH);$(NET_INC_PATH)

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_ -D_PNP_POWER_ -DBUFFER_OWNERSHIP=1

SOURCES=                \
        ..\cmd.c        \
        ..\data.c       \
        ..\dispatch.c   \
        ..\event.c      \
        ..\init.c       \
        ..\memory.c     \
        ..\sacmsg.mc    \
        ..\util.c       \
        ..\version.rc   \


UMRES=obj\*\sac.res

MSC_WARNING_LEVEL=/W4 /WX

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\memory.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module contains routines for handling memory management within the SAC.
    
    Currently the SAC allocates a chunk of memory up front and then does all local allocations
    from this, growing it as necessary.

Author:

    Sean Selitrennikoff (v-seans) - Jan 11, 1999

Revision History:

--*/

#include "sac.h"

      
//
// These are useful for finding memory leaks.
//
LONG TotalAllocations = 0;
LONG TotalFrees = 0;
LARGE_INTEGER TotalBytesAllocated;
LARGE_INTEGER TotalBytesFreed;


#define GLOBAL_MEMORY_SIGNATURE   0x44414548
#define LOCAL_MEMORY_SIGNATURE    0x5353454C
//
// Structure for holding all allocations from the system
//
typedef struct _GLOBAL_MEMORY_DESCRIPTOR {
#if DBG
    ULONG Signature;
#endif
    PVOID Memory;
    ULONG Size;
    struct _GLOBAL_MEMORY_DESCRIPTOR *NextDescriptor;
} GLOBAL_MEMORY_DESCRIPTOR, *PGLOBAL_MEMORY_DESCRIPTOR;

typedef struct _LOCAL_MEMORY_DESCRIPTOR {
#if DBG
#if defined (_IA64_)
    //
    // We must make sure that allocated memory falls on mod-8 boundaries.
    // To do this, we must make sure that this structure is of size mod-8.
    //
    ULONG Filler;
#endif
    ULONG Signature;
#endif
    ULONG Tag;
    ULONG Size;
} LOCAL_MEMORY_DESCRIPTOR, *PLOCAL_MEMORY_DESCRIPTOR;


//
// Variable for holding our memory together.
//
PGLOBAL_MEMORY_DESCRIPTOR GlobalMemoryList;
KSPIN_LOCK MemoryLock;


//
// Constants used to manipulate  size growth
//
#define MEMORY_ALLOCATION_SIZE    PAGE_SIZE
#define INITIAL_MEMORY_BLOCK_SIZE 0x100000


//
// Functions
//
BOOLEAN
InitializeMemoryManagement(
    VOID
    )

/*++

Routine Description:

    This routine initializes the internal memory management system.

Arguments:

    None.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMem: Entering\n")));

    GlobalMemoryList = (PGLOBAL_MEMORY_DESCRIPTOR)ExAllocatePoolWithTagPriority(NonPagedPool,
                                                                                INITIAL_MEMORY_BLOCK_SIZE,
                                                                                INITIAL_POOL_TAG,
                                                                                HighPoolPriority
                                                                               );

    if (GlobalMemoryList == NULL) {
        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                          KdPrint(("SAC InitializeMem: Exiting with FALSE. No pool.\n")));
        return FALSE;
    }

    KeInitializeSpinLock(&MemoryLock);

#if DBG
    GlobalMemoryList->Signature = GLOBAL_MEMORY_SIGNATURE;
#endif
    GlobalMemoryList->Memory = (PVOID)(GlobalMemoryList + 1);
    GlobalMemoryList->Size = INITIAL_MEMORY_BLOCK_SIZE - sizeof(GLOBAL_MEMORY_DESCRIPTOR);
    GlobalMemoryList->NextDescriptor = NULL;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalMemoryList->Memory);
#if DBG
    LocalDescriptor->Signature = LOCAL_MEMORY_SIGNATURE;
#endif    
    LocalDescriptor->Tag = FREE_POOL_TAG;
    LocalDescriptor->Size = GlobalMemoryList->Size - sizeof(LOCAL_MEMORY_DESCRIPTOR);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMem: Exiting with TRUE.\n")));
    return TRUE;

} // InitializeMemoryManagement


VOID
FreeMemoryManagement(
    VOID
    )

/*++

Routine Description:

    This routine frees the internal memory management system.

Arguments:

    None.

Return Value:

    TRUE if successful, else FALSE

--*/

{
    KIRQL OldIrql;
    PGLOBAL_MEMORY_DESCRIPTOR NextDescriptor;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeMem: Entering\n")));

    KeAcquireSpinLock(&MemoryLock, &OldIrql);

    //
    // Check if the memory allocation fits in a current block anywhere
    //
    while (GlobalMemoryList != NULL) {
#if DBG
        ASSERT( GlobalMemoryList->Signature == GLOBAL_MEMORY_SIGNATURE );
#endif
        NextDescriptor = GlobalMemoryList->NextDescriptor;

        KeReleaseSpinLock(&MemoryLock, OldIrql);

        ExFreePool(GlobalMemoryList);

        KeAcquireSpinLock(&MemoryLock, &OldIrql);

        GlobalMemoryList = NextDescriptor;

    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC FreeMem: Exiting\n")));

}


PVOID
MyAllocatePool(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )

/*++

Routine Description:

    This routine allocates memory from our internal structures, and if needed, gets more pool.

Arguments:

    NumberOfBytes - Number of bytes the client wants.
    
    Tag - A tag to place on the memory.
    
    FileName - The file name this request is coming from.
    
    LineNumber - Line number within the file that is making this request.

Return Value:

    A pointer to the allocated block if successful, else NULL

--*/

{
    KIRQL OldIrql;
    PGLOBAL_MEMORY_DESCRIPTOR GlobalDescriptor;
    PGLOBAL_MEMORY_DESCRIPTOR NewDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR NextDescriptor;
    ULONG ThisBlockSize;
    ULONG BytesToAllocate;

    

    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(LineNumber);

    ASSERT(Tag != FREE_POOL_TAG);

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: Entering.\n")));

    KeAcquireSpinLock(&MemoryLock, &OldIrql);

    //
    // Always allocate on mod-8 boundaries
    //
    if( NumberOfBytes & 0x7 ) {
        NumberOfBytes += 8 - (NumberOfBytes & 0x7);
    }

    //
    // Check if the memory allocation fits in a current block anywhere
    //
    GlobalDescriptor = GlobalMemoryList;

    while (GlobalDescriptor != NULL) {
#if DBG
        ASSERT( GlobalDescriptor->Signature == GLOBAL_MEMORY_SIGNATURE );
#endif        
        LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalDescriptor->Memory);
        ThisBlockSize = GlobalDescriptor->Size;

        while (ThisBlockSize != 0) {
#if DBG
            ASSERT( LocalDescriptor->Signature == LOCAL_MEMORY_SIGNATURE );
#endif
            if ((LocalDescriptor->Tag == FREE_POOL_TAG) && 
                (LocalDescriptor->Size >= NumberOfBytes)) {
                
                IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: Found a good sized block.\n")));

                goto FoundBlock;
            }

            ThisBlockSize -= (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
            LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                         LocalDescriptor->Size +
                                                         sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                        );
        }

        GlobalDescriptor = GlobalDescriptor->NextDescriptor;

    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);

    //
    // There is no memory block big enough to hold the request.
    //
    
    //
    // Now check if the request is larger than the normal allocation unit we use.
    //
    if (NumberOfBytes > 
        (MEMORY_ALLOCATION_SIZE - sizeof(GLOBAL_MEMORY_DESCRIPTOR) - sizeof(LOCAL_MEMORY_DESCRIPTOR))) {

        BytesToAllocate = (ULONG)(NumberOfBytes + sizeof(GLOBAL_MEMORY_DESCRIPTOR) + sizeof(LOCAL_MEMORY_DESCRIPTOR));

    } else {

        BytesToAllocate = MEMORY_ALLOCATION_SIZE;

    }

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: Allocating new space.\n")));

    NewDescriptor = (PGLOBAL_MEMORY_DESCRIPTOR)ExAllocatePoolWithTagPriority(NonPagedPool,
                                                                             BytesToAllocate,
                                                                             ALLOC_POOL_TAG,
                                                                             HighPoolPriority
                                                                            );
    if (NewDescriptor == NULL) {
        
        IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyAllocPool: No more memory, returning NULL.\n")));

        return NULL;
    }

    KeAcquireSpinLock(&MemoryLock, &OldIrql);
#if DBG
    NewDescriptor->Signature = GLOBAL_MEMORY_SIGNATURE;
#endif
    NewDescriptor->Memory = (PVOID)(NewDescriptor + 1);
    NewDescriptor->Size = BytesToAllocate - sizeof(GLOBAL_MEMORY_DESCRIPTOR);
    NewDescriptor->NextDescriptor = GlobalMemoryList;

    GlobalMemoryList = NewDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalMemoryList->Memory);
#if DBG
    LocalDescriptor->Signature = LOCAL_MEMORY_SIGNATURE;
#endif
    LocalDescriptor->Tag = FREE_POOL_TAG;
    LocalDescriptor->Size = GlobalMemoryList->Size - sizeof(LOCAL_MEMORY_DESCRIPTOR);


FoundBlock:

    //
    // Jump to here when a memory descriptor of the right size has been found.  It is expected that
    // LocalDescriptor points to the correct block.
    //
    ASSERT(LocalDescriptor != NULL);
    ASSERT(LocalDescriptor->Tag == FREE_POOL_TAG);
#if DBG
    ASSERT(LocalDescriptor->Signature == LOCAL_MEMORY_SIGNATURE );
#endif

    if (LocalDescriptor->Size > NumberOfBytes + sizeof(LOCAL_MEMORY_DESCRIPTOR)) {

        //
        // Make a descriptor of the left over parts of this block.
        //
        NextDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR) +
                                                    NumberOfBytes
                                                   );

#if DBG
        NextDescriptor->Signature = LOCAL_MEMORY_SIGNATURE;
#endif
        NextDescriptor->Tag = FREE_POOL_TAG;
        NextDescriptor->Size = (ULONG)(LocalDescriptor->Size - NumberOfBytes - sizeof(LOCAL_MEMORY_DESCRIPTOR));
        LocalDescriptor->Size = (ULONG)NumberOfBytes;

    }

    LocalDescriptor->Tag = Tag;
    
    KeReleaseSpinLock(&MemoryLock, OldIrql);

    InterlockedIncrement(
        &TotalAllocations
        );

    ExInterlockedAddLargeStatistic(
        &TotalBytesAllocated,
        (CLONG)LocalDescriptor->Size     // Sundown - FIX
        );

    IF_SAC_DEBUG(SAC_DEBUG_MEM, 
                      KdPrint(("SAC MyAllocPool: Returning block 0x%X.\n", LocalDescriptor)));

    RtlZeroMemory( (LocalDescriptor+1), NumberOfBytes );

    return (PVOID)(LocalDescriptor + 1);

} // MyAllocatePool


VOID
MyFreePool(
    IN PVOID *Pointer
    )

/*++

Routine Description:

    This routine frees a block previously allocated from the internal memory management system.

Arguments:

    Pointer - A pointer to the pointer to free.

Return Value:

    Pointer is set to NULL if successful, else it is left alone.

--*/

{
    KIRQL OldIrql;
    ULONG ThisBlockSize;
    PGLOBAL_MEMORY_DESCRIPTOR GlobalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR LocalDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR PrevDescriptor;
    PLOCAL_MEMORY_DESCRIPTOR ThisDescriptor;

    LocalDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)(*Pointer)) - sizeof(LOCAL_MEMORY_DESCRIPTOR));

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: Entering with block 0x%X.\n", LocalDescriptor)));

    ASSERT (LocalDescriptor->Size > 0);
#if DBG
    ASSERT (LocalDescriptor->Signature == LOCAL_MEMORY_SIGNATURE);
#endif

    InterlockedIncrement(
        &TotalFrees
        );

    ExInterlockedAddLargeStatistic(
        &TotalBytesFreed,
        (CLONG)LocalDescriptor->Size
        );


    //
    // Find the memory block in the global list
    //
    KeAcquireSpinLock(&MemoryLock, &OldIrql);

    GlobalDescriptor = GlobalMemoryList;

    while (GlobalDescriptor != NULL) {
#if DBG
        ASSERT(GlobalDescriptor->Signature == GLOBAL_MEMORY_SIGNATURE);
#endif
        PrevDescriptor = NULL;
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(GlobalDescriptor->Memory);
        ThisBlockSize = GlobalDescriptor->Size;

        while (ThisBlockSize != 0) {
#if DBG
            ASSERT (ThisDescriptor->Signature == LOCAL_MEMORY_SIGNATURE);
#endif
            
            if (ThisDescriptor == LocalDescriptor) {
                goto FoundBlock;
            }

            ThisBlockSize -= (ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR));
            
            PrevDescriptor = ThisDescriptor;
            ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)ThisDescriptor) + 
                                                        ThisDescriptor->Size +
                                                        sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                       );
        }

        GlobalDescriptor = GlobalDescriptor->NextDescriptor;

    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);

    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: Could not find block.\n")));

    ASSERT(FALSE);

    return;

FoundBlock:

    //
    // Jump to here when the proper memory descriptor has been found.
    //
#if DBG
    ASSERT (ThisDescriptor->Signature == LOCAL_MEMORY_SIGNATURE);
#endif

    
    if (LocalDescriptor->Tag == FREE_POOL_TAG) {
        //
        // Ouch! We tried to free something twice, skip it before bad things happen.
        //
        KeReleaseSpinLock(&MemoryLock, OldIrql);
        IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: Attempted to free something twice.\n")));
        ASSERT(FALSE);
        return;
    }

    LocalDescriptor->Tag = FREE_POOL_TAG;

    //
    // If possible, merge this memory block with the next one.
    //
    if (ThisBlockSize > (LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR))) {
        ThisDescriptor = (PLOCAL_MEMORY_DESCRIPTOR)(((PUCHAR)LocalDescriptor) + 
                                                    LocalDescriptor->Size +
                                                    sizeof(LOCAL_MEMORY_DESCRIPTOR)
                                                   );
        if (ThisDescriptor->Tag == FREE_POOL_TAG) {
            ThisDescriptor->Tag = 0;
#if DBG
            ThisDescriptor->Signature = 0;
#endif
            LocalDescriptor->Size += ThisDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
        }

    }

    //
    // Now see if we can merge this block with a previous block.
    //
    if ((PrevDescriptor != NULL) && (PrevDescriptor->Tag == FREE_POOL_TAG)) {
#if DBG
        LocalDescriptor->Signature = 0;
#endif
        LocalDescriptor->Tag = 0;
        PrevDescriptor->Size += LocalDescriptor->Size + sizeof(LOCAL_MEMORY_DESCRIPTOR);
    }

    KeReleaseSpinLock(&MemoryLock, OldIrql);
    
    *Pointer = NULL;
    
    IF_SAC_DEBUG(SAC_DEBUG_MEM, KdPrint(("SAC MyFreePool: exiting.\n")));

} // MyFreePool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\driver\util.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Utility routines for sac driver

Author:

    Andrew Ritz (andrewr) - 15 June, 2000

Revision History:

--*/

#include "sac.h"

VOID
AppendMessage(
    PWSTR       OutPutBuffer,
    ULONG       MessageId,
    PWSTR       ValueBuffer OPTIONAL
    );

NTSTATUS
InsertRegistrySzIntoMachineInfoBuffer(
    PWSTR       KeyName,
    PWSTR       ValueName,
    ULONG       MessageId
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, PreloadGlobalMessageTable )
#pragma alloc_text( INIT, AppendMessage )
#pragma alloc_text( INIT, InsertRegistrySzIntoMachineInfoBuffer )
#pragma alloc_text( INIT, InitializeMachineInformation )
#endif


//
// Message Table routines.  We load all of our message table entries into a 
// global non-paged structure so that we can send text to HeadlessDispatch at
// any time.
//

typedef struct _MESSAGE_TABLE_ENTRY {
    ULONG             MessageId;
    PCWSTR             MessageText;
} MESSAGE_TABLE_ENTRY, *PMESSAGE_TABLE_ENTRY;

PMESSAGE_TABLE_ENTRY GlobalMessageTable;
ULONG          GlobalMessageTableCount;
PUCHAR         Utf8ConversionBuffer;
ULONG          Utf8ConversionBufferSize = MEMORY_INCREMENT;

#define MESSAGE_INITIAL 1
#define MESSAGE_FINAL 200


//
// Machine Information table and routines.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

extern char *GlobalBuffer;

PWSTR MachineInformationBuffer = NULL;


extern
BOOLEAN
ExVerifySuite(
    SUITE_TYPE SuiteType
    );

VOID
SacFormatMessage(
    PWSTR       OutputString,
    PWSTR       InputString,
    ULONG       InputStringLength
    )
/*++

Routine Description:

    This routine parses the InputString for any control characters in the
    message, then converts those control characters.
    
Arguments:

    OutputString      - holds formatted string.

    InputString       - original unformatted string.

    InputStringLength - length of unformatted string.


Return Value:

    NONE

--*/
{

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC SacFormatMessage: Entering.\n")));


    if( (InputString == NULL) ||
        (OutputString == NULL) ||
        (InputStringLength == 0) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC SacFormatMessage: Exiting with invalid parameters.\n")));

        return;
    }



    while( (*InputString != L'\0') &&
           (InputStringLength) ) {
        if( *InputString == L'%' ) {
            
            //
            // Possibly a control sequence.
            //
            if( *(InputString+1) == L'0' ) {

                *OutputString = L'\0';
                OutputString++;
                goto SacFormatMessage_Done;

            } else if( *(InputString+1) == L'%' ) {

                *OutputString = L'%';
                OutputString++;
                InputString += 2;

            } else if( *(InputString+1) == L'\\' ) {

                *OutputString = L'\r';
                OutputString++;
                *OutputString = L'\n';
                OutputString++;
                InputString += 2;

            } else if( *(InputString+1) == L'r' ) {

                *OutputString = L'\r';
                InputString += 2;
                OutputString++;

            } else if( *(InputString+1) == L'b' ) {

                *OutputString = L' ';
                InputString += 2;
                OutputString++;

            } else if( *(InputString+1) == L'.' ) {

                *OutputString = L'.';
                InputString += 2;
                OutputString++;

            } else if( *(InputString+1) == L'!' ) {

                *OutputString = L'!';
                InputString += 2;
                OutputString++;

            } else {

                //
                // Don't know what this is.  eat the '%' character.
                //
                InputString += 1;
            }
    
        } else {

            *OutputString++ = *InputString++;
        }

        InputStringLength--;

    }


    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC SacFormatMessage: Exiting.\n")));

SacFormatMessage_Done:

    return;
}


NTSTATUS
PreloadGlobalMessageTable(
    PVOID ImageBase
    )
/*++

Routine Description:

    This routine loads all of our message table entries into a global
    structure and 
    
Arguments:

    ImageBase - pointer to image base for locating resources

Return Value:

    NTSTATUS code indicating outcome.

--*/
{
    ULONG Count,EntryCount;
    SIZE_T TotalSizeInBytes = 0;
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY messageEntry;
    PWSTR pStringBuffer;
    
    PAGED_CODE( );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PreloadGlobalMessageTable: Entering.\n")));


    // 
    // if it already exists, then just return success
    //
    if (GlobalMessageTable != NULL) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    ASSERT( MESSAGE_FINAL > MESSAGE_INITIAL );

    //
    // get the total required size for the table.
    //
    for (Count = MESSAGE_INITIAL; Count != MESSAGE_FINAL ; Count++) {
        
        Status = RtlFindMessage(ImageBase,
                                11, // RT_MESSAGETABLE
                                LANG_NEUTRAL,
                                Count,
                                &messageEntry
                               );

        if (NT_SUCCESS(Status)) {
            //
            // add it on to our total size.
            //
            // the messageEntry size contains the structure size + the size of the text.
            //
            ASSERT(messageEntry->Flags & MESSAGE_RESOURCE_UNICODE);
            TotalSizeInBytes += sizeof(MESSAGE_TABLE_ENTRY) + 
                                (messageEntry->Length - FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text));
            GlobalMessageTableCount +=1;        
        }
            
    }


    if (TotalSizeInBytes == 0) {
        IF_SAC_DEBUG(
            SAC_DEBUG_FAILS,
            KdPrint(("SAC PreloadGlobalMessageTable: No Messages.\n")));
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Allocate space for the table.
    //
    GlobalMessageTable = (PMESSAGE_TABLE_ENTRY) ALLOCATE_POOL( TotalSizeInBytes, GENERAL_POOL_TAG);
    if (!GlobalMessageTable) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    //
    // go through again, this time filling out the table with actual data
    //
    pStringBuffer = (PWSTR)((ULONG_PTR)GlobalMessageTable + 
                        (ULONG_PTR)(sizeof(MESSAGE_TABLE_ENTRY)*GlobalMessageTableCount));
    EntryCount = 0;
    for (Count = MESSAGE_INITIAL ; Count != MESSAGE_FINAL ; Count++) {
        Status = RtlFindMessage(ImageBase,
                                11, // RT_MESSAGETABLE
                                LANG_NEUTRAL,
                                Count,
                                &messageEntry
                               );

        if (NT_SUCCESS(Status)) {
            ULONG TextSize = messageEntry->Length - FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text);
            GlobalMessageTable[EntryCount].MessageId = Count;
            GlobalMessageTable[EntryCount].MessageText = pStringBuffer;

            //
            // Send the message through our Formatting filter as it passes
            // into our global message structure.
            //
            SacFormatMessage( pStringBuffer, (PWSTR)messageEntry->Text, TextSize );

            ASSERT( (wcslen(pStringBuffer)*sizeof(WCHAR)) <= TextSize );

            pStringBuffer = (PWSTR)((ULONG_PTR)pStringBuffer + (ULONG_PTR)(TextSize));
            EntryCount += 1;
        }
    }

    Status = STATUS_SUCCESS;
                    
exit:
    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC PreloadGlobalMessageTable: Exiting with status 0x%0x.\n",
                Status)));

    return(Status);

}

NTSTATUS
TearDownGlobalMessageTable(
    VOID
    ) 
{
    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC PreloadGlobalMessageTable: Entering.\n")));
    
    if (GlobalMessageTable) {
        FREE_POOL( &GlobalMessageTable );
    }

    IF_SAC_DEBUG(
        SAC_DEBUG_FUNC_TRACE, 
        KdPrint(("SAC TearDownGlobalMessageTable: Exiting\n")));

    return(STATUS_SUCCESS);
}

PCWSTR
GetMessage(
    ULONG MessageId
    )
{
    PMESSAGE_TABLE_ENTRY pMessageTable;
    ULONG Count;
    
    if (!GlobalMessageTable) {
        return(NULL);
    }

    for (Count = 0; Count < GlobalMessageTableCount; Count++) {
        pMessageTable = &GlobalMessageTable[Count];
        if (pMessageTable->MessageId == MessageId) {

            
            return(pMessageTable->MessageText);
        }
    }


    ASSERT( FALSE );
    return(NULL);

}

BOOLEAN
SacTranslateUnicodeToUtf8(
    PCWSTR SourceBuffer,
    UCHAR  *DestinationBuffer
    )
{
    ULONG Count = 0;

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    DestinationBuffer[Count] = (UCHAR)'\0';
    while (*SourceBuffer) {

        if( (*SourceBuffer & 0xFF80) == 0 ) {
            //
            // if the top 9 bits are zero, then just
            // encode as 1 byte.  (ASCII passes through unchanged).
            //
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0x7F);
        } else if( (*SourceBuffer & 0xF700) == 0 ) {
            //
            // if the top 5 bits are zero, then encode as 2 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 6) & 0x1F) | 0xC0;
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        } else {
            //
            // encode as 3 bytes
            //
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 12) & 0xF) | 0xE0;
            DestinationBuffer[Count++] = (UCHAR)((*SourceBuffer >> 6) & 0x3F) | 0x80;
            DestinationBuffer[Count++] = (UCHAR)(*SourceBuffer & 0xBF) | 0x80;
        }
        SourceBuffer += 1;
    }

    DestinationBuffer[Count] = (UCHAR)'\0';

    return(TRUE);

}

BOOLEAN
SacPutUnicodeString(
    PCWSTR String
    )
{
    if (!Utf8ConversionBuffer) {
        return(FALSE);
    }

    ASSERT( (wcslen(String)+1)*sizeof(WCHAR) < Utf8ConversionBufferSize );

    SacTranslateUnicodeToUtf8(String,Utf8ConversionBuffer);
    SacPutString(Utf8ConversionBuffer);

    return(TRUE);
}

BOOLEAN
SacPutSimpleMessage(
    ULONG MessageId
    )
{
    PCWSTR p;

    p = GetMessage(MessageId);

    if (p) {
        SacPutUnicodeString(p);        
        return(TRUE);
    }
    
    return(FALSE);

}

VOID
SacPutString(
    PUCHAR String
    )

/*++

Routine Description:

    This routine takes a string and packages it into a command structure for the
    HeadlessDispatch routine.

Arguments:

    String - The string to display.

Return Value:

        None.

--*/
{
    SIZE_T Length;

    ASSERT(FIELD_OFFSET(HEADLESS_CMD_PUT_STRING, String) == 0);  // ASSERT if anyone changes this structure.
    
    Length = strlen((LPSTR)String) + sizeof('\0');

    HeadlessDispatch(HeadlessCmdPutString,
                     (PHEADLESS_CMD_PUT_STRING)String,
                     Length,
                     NULL,
                     NULL
                    );
}




VOID
AppendMessage(
    PWSTR       OutPutBuffer,
    ULONG       MessageId,
    PWSTR       ValueBuffer OPTIONAL
    )
/*++

Routine Description:

    This function will insert the valuestring into the specified message, then
    concatenate the resulting string onto the OutPutBuffer.

Arguments:
    
    OutPutBuffer    The resulting String.

    MessageId       ID of the formatting message to use.

    ValueBUffer     Value string to be inserted into the message.

Return Value:

    NONE

--*/
{
PWSTR       MyTemporaryBuffer = NULL;
PCWSTR      p;

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC AppendMessage: Entering.\n")));

    p = GetMessage(MessageId);

    if( p == NULL ) {
        return;
    }

    if( ValueBuffer == NULL ) {

        wcscat( OutPutBuffer, p );

    } else {

        MyTemporaryBuffer = (PWSTR)(wcschr(OutPutBuffer, L'\0'));
        if( MyTemporaryBuffer == NULL ) {
            MyTemporaryBuffer = OutPutBuffer;
        }

        swprintf( MyTemporaryBuffer, p, ValueBuffer );
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC AppendMessage: Entering.\n")));

    return;
}


NTSTATUS
InsertRegistrySzIntoMachineInfoBuffer(
    PWSTR       KeyName,
    PWSTR       ValueName,
    ULONG       MessageId
    )
/*++

Routine Description:

    This function will go query the registry and pull the specified Value.
    We will then insert this value into the specified message, then concatenate
    the resulting string into our MachineInformationBuffer.

Arguments:
    
    KeyName         Name of the registry key we'll be querying.

    ValueName       Name of the registry value we'll be querying.

    MessageId       ID of the formatting message to use.

Return Value:

    NTSTATUS.

--*/
{
NTSTATUS        Status = STATUS_SUCCESS;
ULONG           KeyValueLength = 0;
PKEY_VALUE_PARTIAL_INFORMATION ValueBuffer = NULL;
OBJECT_ATTRIBUTES Obja;
UNICODE_STRING  UnicodeString;
HANDLE          KeyHandle;



    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InsertRegistrySzIntoMachineInfoBuffer: Entering.\n")));

    INIT_OBJA( &Obja, &UnicodeString, KeyName );
    Status = ZwOpenKey( &KeyHandle,
                        KEY_READ | KEY_WRITE,
                        &Obja );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InsertRegistrySzIntoMachineInfoBuffer: Exiting (1).\n")));
        return Status;
    }

    RtlInitUnicodeString( &UnicodeString, ValueName );
    KeyValueLength = 0;
    Status = ZwQueryValueKey( KeyHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              (PVOID)NULL,
                              0,
                              &KeyValueLength );

    if( KeyValueLength == 0 ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InsertRegistrySzIntoMachineInfoBuffer: Exiting (2).\n")));
        return Status;
    }


    KeyValueLength += 4;
    ValueBuffer = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCATE_POOL( KeyValueLength, GENERAL_POOL_TAG );

    if( ValueBuffer == NULL ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InsertRegistrySzIntoMachineInfoBuffer: Exiting (3).\n")));
        return Status;
    }

    Status = ZwQueryValueKey( KeyHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              ValueBuffer,
                              KeyValueLength,
                              &KeyValueLength );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InsertRegistrySzIntoMachineInfoBuffer: Exiting (4).\n")));
        FREE_POOL( &ValueBuffer );
        return Status;
    }

    AppendMessage( MachineInformationBuffer,
                   MessageId,
                   (PWSTR)ValueBuffer->Data );

    FREE_POOL( &ValueBuffer );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC InsertRegistrySzIntoMachineInfoBuffer: Exiting.\n")));

    return Status;

}

VOID
InitializeMachineInformation(
    VOID
    )
/*++

Routine Description:

    This function initializes the global variable MachineInformationBuffer.

    We'll gather a whole bunch of information about the machine and fill
    in the buffer.

Arguments:
    
    None.

Return Value:

    None.

--*/
{
#define         MACHINEINFORMATIONBUFFER_SIZE (512 * sizeof(WCHAR))
PWSTR           COMPUTERNAME_KEY_NAME  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName";
PWSTR           COMPUTERNAME_VALUE_NAME  = L"ComputerName";
PWSTR           PROCESSOR_ARCHITECTURE_KEY_NAME  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Environment";
PWSTR           PROCESSOR_ARCHITECTURE_VALUE_NAME  = L"PROCESSOR_ARCHITECTURE";

PSTR            XML_TAG = "MACHINEINFO";
PSTR            XML_HEADER0 = "\r\n<PROPERTY.ARRAY NAME=\"MACHINEINFO\" TYPE=\"string\">\r\n";
PSTR            XML_HEADER1 = "<VALUE.ARRAY>\r\n";
PSTR            XML_HEADER2 = "<VALUE>\"%ws\"</VALUE>\r\n";
PSTR            XML_FOOTER0 = "</VALUE.ARRAY>\r\n</PROPERTY.ARRAY>";

NTSTATUS        Status = STATUS_SUCCESS;
SIZE_T          i;
RTL_OSVERSIONINFOEXW VersionInfo;
PWSTR           MyTemporaryBufferW = NULL;
PHEADLESS_CMD_SET_BLUE_SCREEN_DATA BSBuffer;
PUCHAR          pch;
ULONG           len;
GUID            MyGUID;
PCWSTR          pwStr = NULL;




    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Initialize Machine Information: Entering.\n")));


    if( MachineInformationBuffer != NULL ) {

        //
        // someone called us again!
        //
        IF_SAC_DEBUG( SAC_DEBUG_FUNC_TRACE_LOUD, 
                      KdPrint(("SAC Initialize Machine Information:: MachineInformationBuffer already initialzied.\n")));

        return;
    } else {

        MachineInformationBuffer = (PWCHAR)ALLOCATE_POOL( MACHINEINFORMATIONBUFFER_SIZE, GENERAL_POOL_TAG );

        if( MachineInformationBuffer == NULL ) {

            goto InitializeMachineInformation_Failure;
        }
    }

    RtlZeroMemory( MachineInformationBuffer, MACHINEINFORMATIONBUFFER_SIZE );



    //
    // We're real early in the boot process, so we're going to take for granted that the machine hasn't
    // bugchecked.  This means that we can safely call some kernel functions to go figure out what
    // platform we're running on.
    //
    RtlZeroMemory( &VersionInfo, sizeof(VersionInfo));
    Status = RtlGetVersion( (POSVERSIONINFOW)&VersionInfo );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (2).\n")));
        goto InitializeMachineInformation_Failure;
    }


    //
    // ========
    // Machine name.
    // ========
    //
    Status = InsertRegistrySzIntoMachineInfoBuffer( COMPUTERNAME_KEY_NAME,
                                                    COMPUTERNAME_VALUE_NAME,
                                                    SAC_MACHINEINFO_COMPUTERNAME );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (20).\n")));
        goto InitializeMachineInformation_Failure;
    }



    //
    // ========
    // Machine GUID.
    // ========
    //

    // make sure.
    RtlZeroMemory( &MyGUID, sizeof(GUID) );
    i = sizeof(GUID);
    Status = HeadlessDispatch( HeadlessCmdQueryGUID,
                               NULL,
                               0,
                               &MyGUID,
                               &i );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (30).\n")));
        goto InitializeMachineInformation_Failure;
    }

    //
    // Allocate enough memory for the formatting message, plus the size of a
    // GUID-turned-text, which is 2x the number of bytes required to hold the binary,
    // plus 8 bytes of slop.
    //
    pwStr = GetMessage(SAC_MACHINEINFO_GUID);

    if( pwStr ) {

        MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( (sizeof(GUID)*2) + (wcslen(pwStr) + 8) * sizeof(WCHAR) , GENERAL_POOL_TAG );
        if( MyTemporaryBufferW == NULL ) {

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (31).\n")));
            goto InitializeMachineInformation_Failure;
        }

        swprintf( MyTemporaryBufferW,
                  GetMessage(SAC_MACHINEINFO_GUID),
                  MyGUID.Data1,
                  MyGUID.Data2,
                  MyGUID.Data3,
                  MyGUID.Data4[0],
                  MyGUID.Data4[1],
                  MyGUID.Data4[2],
                  MyGUID.Data4[3],
                  MyGUID.Data4[4],
                  MyGUID.Data4[5],
                  MyGUID.Data4[6],
                  MyGUID.Data4[7] );

        wcscat( MachineInformationBuffer, MyTemporaryBufferW );

        FREE_POOL( &MyTemporaryBufferW );
    }


    //
    // ========
    // Processor Architecture.
    // ========
    //
    Status = InsertRegistrySzIntoMachineInfoBuffer( PROCESSOR_ARCHITECTURE_KEY_NAME,
                                                    PROCESSOR_ARCHITECTURE_VALUE_NAME,
                                                    SAC_MACHINEINFO_PROCESSOR_ARCHITECTURE );

    if( !NT_SUCCESS(Status) ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (40).\n")));
        goto InitializeMachineInformation_Failure;
    }



    //
    // ========
    // OS Name.
    // ========
    //

    //
    // Allocate enough memory for the formatting message, plus the size of 2 digits.
    // Currently, our versioning info is of the type "5.1", so we don't need much space
    // here, but let's be conservative and assume both major and minor version numbers
    // are 4 digits in size.  That's 9 characters.
    //
    MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( (wcslen(GetMessage(SAC_MACHINEINFO_OS_VERSION)) + 9) * sizeof(WCHAR), GENERAL_POOL_TAG );
    if( MyTemporaryBufferW == NULL ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (50).\n")));
        goto InitializeMachineInformation_Failure;
    }

    swprintf( MyTemporaryBufferW,
              GetMessage(SAC_MACHINEINFO_OS_VERSION),
              VersionInfo.dwMajorVersion,
              VersionInfo.dwMinorVersion );

    wcscat( MachineInformationBuffer, MyTemporaryBufferW );

    FREE_POOL( &MyTemporaryBufferW );



    //
    // ========
    // Build Number.
    // ========
    //

    //
    // Allocate enough memory for the formatting message, plus the size of our build number.
    // Currently that's well below the 5-digit mark, but let's build some headroom here for
    // build numbers up to 99000 (5-digits).
    //
    MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( (wcslen(GetMessage(SAC_MACHINEINFO_OS_BUILD)) + 5) * sizeof(WCHAR), GENERAL_POOL_TAG );
    if( MyTemporaryBufferW == NULL ) {

        IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (60).\n")));
        goto InitializeMachineInformation_Failure;
    }

    swprintf( MyTemporaryBufferW,
              GetMessage(SAC_MACHINEINFO_OS_BUILD),
              VersionInfo.dwBuildNumber );

    wcscat( MachineInformationBuffer, MyTemporaryBufferW );

    FREE_POOL( &MyTemporaryBufferW );



    //
    // ========
    // Product Type (and Suite).
    // ========
    //
    if( ExVerifySuite(DataCenter) ) {

        AppendMessage( MachineInformationBuffer,
                       SAC_MACHINEINFO_OS_PRODUCTTYPE,
                       (PWSTR)GetMessage(SAC_MACHINEINFO_DATACENTER) );

    } else if( ExVerifySuite(EmbeddedNT) ) {

        AppendMessage( MachineInformationBuffer,
                       SAC_MACHINEINFO_OS_PRODUCTTYPE,
                       (PWSTR)GetMessage(SAC_MACHINEINFO_EMBEDDED) );

    } else if( ExVerifySuite(Enterprise) ) {

        AppendMessage( MachineInformationBuffer,
                       SAC_MACHINEINFO_OS_PRODUCTTYPE,
                       (PWSTR)GetMessage(SAC_MACHINEINFO_ADVSERVER) );

    } else {

        //
        // We found no product suite that we recognized or cared about.
        // Assume we're running on a generic server.
        //
        AppendMessage( MachineInformationBuffer,
                       SAC_MACHINEINFO_OS_PRODUCTTYPE,
                       (PWSTR)GetMessage(SAC_MACHINEINFO_SERVER) );
    }



    //
    // ========
    // Service Pack Information.
    // ========
    //
    if( VersionInfo.wServicePackMajor != 0 ) {

        //
        // There's been a service pack applied.  Better tell the user.
        //


        //
        // Allocate enough memory for the formatting message, plus the size of our servicepack number.
        // Currently that's well below the 5-digit mark, but let's build some headroom here for
        // service pack numbers up to 99000 (5-digits).
        //
        MyTemporaryBufferW = (PWSTR)ALLOCATE_POOL( (wcslen(GetMessage(SAC_MACHINEINFO_SERVICE_PACK)) + 5) * sizeof(WCHAR), GENERAL_POOL_TAG );
        if( MyTemporaryBufferW == NULL ) {

            IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, KdPrint(("SAC InitializeMachineInformation: Exiting (80).\n")));
            goto InitializeMachineInformation_Failure;
        }

        swprintf( MyTemporaryBufferW,
                  GetMessage(SAC_MACHINEINFO_SERVICE_PACK),
                  VersionInfo.wServicePackMajor,
                  VersionInfo.wServicePackMinor );

        wcscat( MachineInformationBuffer, MyTemporaryBufferW );

        FREE_POOL( &MyTemporaryBufferW );
    } else {

        AppendMessage( MachineInformationBuffer, SAC_MACHINEINFO_NO_SERVICE_PACK, NULL );
    }




    //
    // ========
    // Insert it all into the BLUESCREEN data.
    // ========
    //


    //
    // How big is this going to be?
    //
    i = wcslen(MachineInformationBuffer);
    i += strlen(XML_TAG);
    i += strlen(XML_HEADER0);
    i += strlen(XML_HEADER1);
    i += strlen(XML_HEADER2);
    i += strlen(XML_FOOTER0);
    i += 8;

    BSBuffer = (PHEADLESS_CMD_SET_BLUE_SCREEN_DATA)ALLOCATE_POOL( i,
                                                                  GENERAL_POOL_TAG );

    if( BSBuffer == NULL ) {

        goto InitializeMachineInformation_Failure;
    }

    pch = &(BSBuffer->Data[0]);
    len = sprintf( (LPSTR)pch, XML_TAG );
    BSBuffer->ValueIndex = len+1;
    pch = pch+len+1;
    len = sprintf( (LPSTR)pch, "%s%s", XML_HEADER0, XML_HEADER1 );
    pch = pch + len;
    len = sprintf( (LPSTR)pch, XML_HEADER2, MachineInformationBuffer );
    strcat( (LPSTR)pch, XML_FOOTER0 );

    HeadlessDispatch( HeadlessCmdSetBlueScreenData,
                      BSBuffer,
                      wcslen(MachineInformationBuffer)+256,
                      NULL,
                      0 );

    FREE_POOL( &BSBuffer );

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                      KdPrint(("SAC Initialize Machine Information: Exiting.\n")));

    return;




InitializeMachineInformation_Failure:
    if( MachineInformationBuffer != NULL ) {
        FREE_POOL(&MachineInformationBuffer);
        MachineInformationBuffer = NULL;
    }

    IF_SAC_DEBUG(SAC_DEBUG_FUNC_TRACE, 
                    KdPrint(("SAC Initialize Machine Information: Exiting with error.\n")));
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\inc\lhc.h ===
#pragma once

typedef PVOID LHCHANDLE;

BOOL lhcInitialize();
void lhcFinalize();
LHCHANDLE lhcOpen(PCWSTR pcszPortSpec);
BOOL lhcRead(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead);
BOOL lhcWrite(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize);
BOOL lhcClose(
    LHCHANDLE hObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\sources.inc ===
# We do this so that everything builds with the same
# options, and we don't get mismatches

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
USE_CRTDLL=1
USE_NATIVE_EH=ASYNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\inc\term.h ===
#pragma once

#define MAX_ESCAPE_PARAMS 32

typedef BOOL (*TERMTXPROC)(PCWSTR, DWORD);

typedef struct __TERMINAL
{
    HANDLE      hSavedBuffer;
    HANDLE      hNewBuffer;
    HANDLE      hInput;
    HANDLE      hOutput;
    WORD        wAttributes;
    BOOL        fInverse;
    BOOL        fBold;
    BOOL        fEscapeValid;
    BOOL        fEscapeInvalid;
    WORD        wEscapeParamCount;
    WORD        wEscapeParams[MAX_ESCAPE_PARAMS];
    WCHAR       chEscapeCommand;
    WCHAR       chEscapeFirstChar;
    TERMTXPROC  pTxProc;
} TERMINAL, *PTERMINAL;

PTERMINAL termInitialize(TERMTXPROC pTxProc);
void termFinalize(PTERMINAL pTerminal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\lhc\library.c ===
#include "std.h"



PLIBRARY_DESCRIPTOR lhclLoadLibrary(PCWSTR pcszPathName)
{
    PLIBRARY_DESCRIPTOR pResult = malloc(
        sizeof(LIBRARY_DESCRIPTOR));

    if (NULL==pResult)
    {
        goto NoStructure;
    }

    pResult->m_hModule = LoadLibraryW(
        pcszPathName);

    if (NULL==pResult->m_hModule)
    {
        goto NoLibrary;
    }

    pResult->m_fpOpen = (PLHC_OPENPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcOpen");

    if (NULL==pResult->m_fpOpen)
    {
        goto Error;
    }

    pResult->m_fpClose = (PLHC_CLOSEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcClose");

    if (NULL==pResult->m_fpClose)
    {
        goto Error;
    }

    pResult->m_fpRead = (PLHC_READPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcRead");

    if (NULL==pResult->m_fpRead)
    {
        goto Error;
    }

    pResult->m_fpWrite = (PLHC_WRITEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcWrite");

    if (NULL==pResult->m_fpWrite)
    {
        goto Error;
    }

    pResult->m_fpGetLibraryName = (PLHC_GETLIBRARYNAMEPROC)GetProcAddress(
        pResult->m_hModule,
        "lhcGetLibraryName");

    if (NULL==pResult->m_fpGetLibraryName)
    {
        goto Error;
    }

    return pResult;

Error:
    FreeLibrary(
        pResult->m_hModule);
NoLibrary:
    free(
        pResult);
NoStructure:
    return FALSE;
}



void lhclFreeLibrary(PLIBRARY_DESCRIPTOR pLibrary)
{
    if (pLibrary!=NULL)
    {
        if (pLibrary->m_hModule!=NULL)
        {
            FreeLibrary(
                pLibrary->m_hModule);
        }
        free(
            pLibrary);
    }
}


PLHCOBJECT_DESCRIPTOR lhclOpen(
    PLIBRARY_DESCRIPTOR pLibrary,
    PCWSTR pcszPortSpec)
{
    return pLibrary->m_fpOpen(
        pcszPortSpec);
}


BOOL lhclRead(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead)
{
    return pLibrary->m_fpRead(
        pObject,
        pBuffer,
        dwBufferSize,
        pdwBytesRead);
}


BOOL lhclWrite(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize)
{
    return pLibrary->m_fpWrite(
        pObject,
        pBuffer,
        dwBufferSize);
}


BOOL lhclClose(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject)
{
    return pLibrary->m_fpClose(
        pObject);
}


DWORD lhclGetLibraryName(
    PLIBRARY_DESCRIPTOR pLibrary,
    PWSTR pszBuffer,
    DWORD dwBufferSize)
{
    return pLibrary->m_fpGetLibraryName(
        pszBuffer,
        dwBufferSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\lhc\library.h ===
#pragma once

typedef PVOID PLHCOBJECT_DESCRIPTOR;

typedef PLHCOBJECT_DESCRIPTOR (APIENTRY *PLHC_OPENPROC)(PCWSTR);
typedef BOOL  (APIENTRY *PLHC_READPROC)(PLHCOBJECT_DESCRIPTOR,PVOID,DWORD,PDWORD);
typedef BOOL  (APIENTRY *PLHC_WRITEPROC)(PLHCOBJECT_DESCRIPTOR,PVOID,DWORD);
typedef BOOL  (APIENTRY *PLHC_CLOSEPROC)(PLHCOBJECT_DESCRIPTOR);
typedef DWORD (APIENTRY *PLHC_GETLIBRARYNAMEPROC)(PWSTR, DWORD);

typedef struct __LIBRARY_DESCRIPTOR
{
    HMODULE       m_hModule;                    // Handle to the loaded DLL
    // Now come the pointers to functions in the DLL
    PLHC_OPENPROC m_fpOpen;                     // lchOpen function
    PLHC_READPROC m_fpRead;                     // lhcRead function
    PLHC_WRITEPROC m_fpWrite;                   // lhcWrite function
    PLHC_CLOSEPROC m_fpClose;                   // lhcClose function
    PLHC_GETLIBRARYNAMEPROC m_fpGetLibraryName; // lhcGetLibraryName function
} LIBRARY_DESCRIPTOR, *PLIBRARY_DESCRIPTOR;

PLIBRARY_DESCRIPTOR lhclLoadLibrary(
    PCWSTR pcszPathName);

void lhclFreeLibrary(
    PLIBRARY_DESCRIPTOR pLibrary);

PLHCOBJECT_DESCRIPTOR lhclOpen(
    PLIBRARY_DESCRIPTOR pLibrary,
    PCWSTR pcszPortSpec);

BOOL lhclRead(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead);

BOOL lhclWrite(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject,
    PVOID pBuffer,
    DWORD dwBufferSize);

BOOL lhclClose(
    PLIBRARY_DESCRIPTOR pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject);

DWORD lhclGetLibraryName(
    PLIBRARY_DESCRIPTOR pLibrary,
    PWSTR pszBuffer,
    DWORD dwBufferSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\lhc\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shlwapi.h>

#include <lhc.h>

#include "library.h"
#include "suite.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\lhc\suite.h ===
#pragma once

#define LHC_MAX_OPEN_OBJECTS 64

typedef struct __LIBRARY_NODE
{
    GUID                   m_Secret;
    PLIBRARY_DESCRIPTOR    m_pLibrary;
    struct __LIBRARY_NODE* m_pNext;
} LIBRARY_NODE, *PLIBRARY_NODE;


typedef struct __LHCSTRUCT
{
    GUID                    m_Secret;
    PLHCOBJECT_DESCRIPTOR   m_pObject;
    PLIBRARY_DESCRIPTOR     m_pLibrary;
    struct __LHCSTRUCT*     m_pNext;
    struct __LHCSTRUCT**    m_ppThis;
} LHCSTRUCT, *PLHCSTRUCT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\tcpip\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\serial\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <stdlib.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\lhc\suite.c ===
#include "std.h"



// {6249D949-5263-4d6a-883C-78EFAF85D5E3}
static const GUID g_lhcHandleGUID =
{
    // This guid will be used to identify LCHHANDLE structures to
    // help prevent accessing invalid items
    0x6249d949, 0x5263, 0x4d6a,
    {
        0x88, 0x3c, 0x78, 0xef, 0xaf, 0x85, 0xd5, 0xe3
    }
};

// {40A71300-B2C7-4d4f-808F-52643110B329}
static const GUID g_lhcLibraryGUID =
{
    // This guid will be used to identify LIBRARY_NODE structures to
    // help prevent accessing invalid items
    0x40a71300, 0xb2c7, 0x4d4f,
    {
        0x80, 0x8f, 0x52, 0x64, 0x31, 0x10, 0xb3, 0x29
    }
};

PLIBRARY_NODE     g_pLibraryList = NULL;
PLHCSTRUCT        g_pObjectList = NULL;
CRITICAL_SECTION  g_csTableControl;


BOOL lhcpIsValidHandle(PLHCSTRUCT pObject);
PLIBRARY_NODE lhcpNewLibraryNode();
void lhcpFreeLibraryNode(PLIBRARY_NODE pNode);
PLHCSTRUCT lhcpNewObjectHandle();
void lhcpFreeObjectHandle(PLHCSTRUCT pNode);
BOOL lhcpIsValidHandle(PLHCSTRUCT pObject);
PWSTR lhcpGetExeDirectory();
PLHCSTRUCT lhcpCreateHandle(
    PLIBRARY_DESCRIPTOR   pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject);
void lhcpDestroyHandle(PLHCSTRUCT pNode);


BOOL lhcpIsValidHandle(PLHCSTRUCT pObject)
{
    BOOL bResult;

    __try
    {
        bResult = IsEqualGUID(
            &g_lhcHandleGUID,
            &pObject->m_Secret);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        bResult = FALSE;
        goto Done;
    }

Done:
    return bResult;
}


PLIBRARY_NODE lhcpNewLibraryNode()
{
    //
    // Create the new node, zero out the memory and copy in the secret
    //
    PLIBRARY_NODE pNode = malloc(
        sizeof(LIBRARY_NODE));

    if (pNode!=NULL)
    {
        ZeroMemory(
            pNode,
            sizeof(LIBRARY_NODE));
        CopyMemory(
            &pNode->m_Secret,
            &g_lhcLibraryGUID,
            sizeof(GUID));
    }

    return pNode;
}


void lhcpFreeLibraryNode(PLIBRARY_NODE pNode)
{
    ZeroMemory(
        pNode,
        sizeof(LIBRARY_NODE));
    free(
        pNode);
}


PLHCSTRUCT lhcpNewObjectHandle()
{
    //
    // Create the new node, zero out the memory and copy in the secret
    //

    PLHCSTRUCT pNode = malloc(
        sizeof(LHCSTRUCT));

    if (pNode!=NULL)
    {
        ZeroMemory(
            pNode,
            sizeof(LHCSTRUCT));
        CopyMemory(
            &pNode->m_Secret,
            &g_lhcHandleGUID,
            sizeof(GUID));
    }

    return pNode;
}


void lhcpFreeObjectHandle(PLHCSTRUCT pNode)
{
    ZeroMemory(
        pNode,
        sizeof(LHCSTRUCT));
    free(
        pNode);
}


PWSTR lhcpGetExeDirectory()
{
    DWORD dwSize = 64;
    PWSTR pszBuffer = NULL;
    PWSTR pszReturn;
    DWORD dwResult;
    BOOL bResult;
    PWSTR pszLastBackslash;

    do
    {
        pszBuffer = malloc(
            dwSize * sizeof(WCHAR));

        if (NULL==pszBuffer)
        {
            SetLastError(
                ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }

        dwResult = GetModuleFileNameW(
            NULL,
            pszBuffer,
            dwSize);

        if (0==dwResult)
        {
            goto Error;
        }

        if (dwSize==dwResult)  // INSUFFICIENT_BUFFER
        {
            dwSize *= 2;            // Double the buffer length
            free(
                pszBuffer);
            pszBuffer = NULL;
            dwResult = 0;
        }
    } while (0==dwResult && dwSize<=65536);

    if (dwSize>65536)
    {
        SetLastError(
            ERROR_INSUFFICIENT_BUFFER);
        goto Error;
    }

    pszLastBackslash = wcsrchr(
        pszBuffer,
        L'\\');

    if (NULL==pszLastBackslash)
    {
        SetLastError(
            ERROR_GEN_FAILURE);
        goto Error;
    }

    pszLastBackslash++;
    *pszLastBackslash = L'\0';

    pszReturn = malloc(
        (wcslen(pszBuffer)+MAX_PATH+1)*sizeof(WCHAR));

    if (NULL==pszReturn)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    wcscpy(
        pszReturn,
        pszBuffer);

    free(
        pszBuffer);

    return pszReturn;

Error:
    if (pszBuffer!=NULL)
    {
        free(
            pszBuffer);
    }
    return NULL;
}


PLHCSTRUCT lhcpCreateHandle(
    PLIBRARY_DESCRIPTOR   pLibrary,
    PLHCOBJECT_DESCRIPTOR pObject)
{
    PLHCSTRUCT pNode = lhcpNewObjectHandle();

    if (pNode!=NULL)
    {
        EnterCriticalSection(
            &g_csTableControl);

        pNode->m_pObject = pObject;
        pNode->m_pLibrary = pLibrary;
        pNode->m_pNext = g_pObjectList;
        pNode->m_ppThis = &g_pObjectList;

        if (pNode->m_pNext!=NULL)
        {
            pNode->m_pNext->m_ppThis = &pNode->m_pNext;
        }

        g_pObjectList = pNode;

        LeaveCriticalSection(
            &g_csTableControl);
    }
    else
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
    }

    return pNode;
}


void lhcpDestroyHandle(PLHCSTRUCT pNode)
{
    EnterCriticalSection(
        &g_csTableControl);

    // Remove this node from the list of handles.

    *(pNode->m_ppThis) = pNode->m_pNext;
    if (pNode->m_pNext!=NULL)
    {
        pNode->m_pNext->m_ppThis = pNode->m_ppThis;
    }

    lhcpFreeObjectHandle(
        pNode);            // Invalidates the structure and frees the memory

    LeaveCriticalSection(
        &g_csTableControl);

}


BOOL lhcInitialize()
{
    PWSTR pszPath = NULL;
    PWSTR pszFileName;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    BOOL bResult;
    PLIBRARY_DESCRIPTOR pLibrary = NULL;
    PLIBRARY_NODE pNode = NULL;
    WCHAR pszLibraryName[64];

    InitializeCriticalSection(
        &g_csTableControl);

    pszPath = lhcpGetExeDirectory();

    if (NULL==pszPath)
    {
        goto Error;
    }

    pszFileName = pszPath + wcslen(pszPath);

    wcscat(
        pszFileName,
        L"*.lhc");

    hFind = FindFirstFileW(
        pszPath,
        &FindData);

    bResult = (hFind!=INVALID_HANDLE_VALUE);

    if (!bResult)
    {
        goto Error;
    }

    while (bResult)
    {
        wcscpy(
            pszFileName,
            FindData.cFileName);

        pLibrary = lhclLoadLibrary(
            pszPath);

        if (pLibrary==NULL)
        {
            wprintf(
                L"Unable to load (%u).\n",
                pszFileName,
                GetLastError());
        }
        else
        {
            lhclGetLibraryName(
                pLibrary,
                pszLibraryName,
                64);

            wprintf(
                L"Loaded %s library.\n",
                pszLibraryName);

            pNode = lhcpNewLibraryNode();

            if (NULL==pNode)
            {
                SetLastError(
                    ERROR_NOT_ENOUGH_MEMORY);
                goto Error;
                // Out of memory is fatal
            }

            pNode->m_pLibrary = pLibrary;
            pNode->m_pNext = g_pLibraryList;
            g_pLibraryList = pNode;
            pNode = NULL;
            pLibrary = NULL;
        }

        bResult = FindNextFileW(
            hFind,
            &FindData);
    }

    FindClose(hFind);

    free(pszPath);

    return g_pLibraryList!=NULL;

Error:
    if (pLibrary!=NULL)
    {
        lhclFreeLibrary(pLibrary);
    }
    if (pszPath!=NULL)
    {
        free(pszPath);
    }
    if (pNode!=NULL)
    {
        free(pszPath);
    }
    if (hFind!=INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
    }
    // We need to unload the libraries that successfully loaded.
    lhcFinalize();

    return FALSE;
}



void lhcFinalize()
{
    PLIBRARY_NODE pNode;
    WCHAR pszLibraryName[64];

    while (g_pObjectList!=NULL)
    {
        lhcClose(
            g_pObjectList);
    }

    while (g_pLibraryList!=NULL)
    {
        pNode = g_pLibraryList;
        g_pLibraryList = g_pLibraryList->m_pNext;

        lhclGetLibraryName(
            pNode->m_pLibrary,
            pszLibraryName,
            64);

        lhclFreeLibrary(
            pNode->m_pLibrary);

        wprintf(
            L"Unloaded %s library.\n",
            pszLibraryName);

        lhcpFreeLibraryNode(
            pNode);
    }
}


LHCHANDLE lhcOpen(PCWSTR pcszPortSpec)
{
    PLIBRARY_NODE pLibraryNode = g_pLibraryList;
    PLHCOBJECT_DESCRIPTOR pObject = NULL;
    PLHCSTRUCT hObject;

    while (pLibraryNode!=NULL && pObject==NULL)
    {
        // Try libraries one at a time until one opens successfully
        pObject = lhclOpen(
            pLibraryNode->m_pLibrary,
            pcszPortSpec);

        if (!pObject)
        {
            pLibraryNode = pLibraryNode->m_pNext;
        }
    }

    if (!pObject)
    {
        goto Error;
    }

    hObject = lhcpCreateHandle(
        pLibraryNode->m_pLibrary,
        pObject);

    if (hObject==NULL)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    return hObject;

Error:
    if (pObject!=NULL)
    {
        lhclClose(
            pLibraryNode->m_pLibrary,
            pObject);
    }

    return NULL;
}


BOOL lhcRead(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize,
    PDWORD pdwBytesRead)
{
    PLIBRARY_DESCRIPTOR   pLibrary;
    PLHCOBJECT_DESCRIPTOR pObject;

    if (!lhcpIsValidHandle(hObject))
    {
        goto Error;
    }

    EnterCriticalSection(
        &g_csTableControl);

    // Ensure consistent information
    pLibrary = ((PLHCSTRUCT)hObject)->m_pLibrary;
    pObject = ((PLHCSTRUCT)hObject)->m_pObject;

    LeaveCriticalSection(
        &g_csTableControl);

    return lhclRead(
        pLibrary,
        pObject,
        pBuffer,
        dwBufferSize,
        pdwBytesRead);

Error:
    return FALSE;
}


BOOL lhcWrite(
    LHCHANDLE hObject,
    PVOID pBuffer,
    DWORD dwBufferSize)
{
    PLIBRARY_DESCRIPTOR   pLibrary;
    PLHCOBJECT_DESCRIPTOR pObject;

    if (!lhcpIsValidHandle(hObject))
    {
        goto Error;
    }

    // Ensure consistent information by using the critical section
    EnterCriticalSection(
        &g_csTableControl);

    // Ensure consistent information
    pLibrary = ((PLHCSTRUCT)hObject)->m_pLibrary;
    pObject = ((PLHCSTRUCT)hObject)->m_pObject;

    LeaveCriticalSection(
        &g_csTableControl);

    return lhclWrite(
        pLibrary,
        pObject,
        pBuffer,
        dwBufferSize);

Error:
    return FALSE;
}


BOOL lhcClose(
    LHCHANDLE hObject)
{
    PLIBRARY_DESCRIPTOR   pLibrary;
    PLHCOBJECT_DESCRIPTOR pObject;

    if (!lhcpIsValidHandle(hObject))
    {
        goto Error;
    }

    // Ensure consistent information by using the critical section

    EnterCriticalSection(
        &g_csTableControl);

    // Ensure consistent information
    pLibrary = ((PLHCSTRUCT)hObject)->m_pLibrary;
    pObject = ((PLHCSTRUCT)hObject)->m_pObject;

    lhcpDestroyHandle(
        hObject);

    LeaveCriticalSection(
        &g_csTableControl);

    return lhclClose(
        pLibrary,
        pObject);

Error:
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\term\std.h ===
/*****************************************************************************
*
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      all.hxx
*
*  Abstract:
*
*      This is the pre-compiled header file containing all of the common
*      SDK and DDK headers.
*
*  Author:
*
*      Steven West [swest]                   1-January-1999
*
*  Revision History:
*
*****************************************************************************/

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <windows.h>
#include <shlwapi.h>

#include <term.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\serial\serial.c ===
#include "std.h"

// This is the communications mask used by our serial port.  More may be
// necessary, but for right now, this seems to work.
#define EV_SERIAL EV_RXCHAR | EV_ERR | EV_BREAK
#define SERIALPORT_NAME     L"Serial Port"

// This GUID is used to identify objects opened by this library.  It is
// placed in the m_Secret member of the SERIALPORT structure. Any external
// interface accepting a SERIALPORT object as a parameter should check this
// out before using the structure.
static const GUID uuidSerialPortObjectGuid =
{ 0x86ae9c9b, 0x9444, 0x4d00, { 0x84, 0xbb, 0xc1, 0xd9, 0xc2, 0xd9, 0xfb, 0xf3 } };


// Structure defining an open serial port object.  All external users of this
// library will only have a void pointer to one of these, and the structure is
// not published anywhere.  This abstration makes it more difficult for the
// user to mess things up.
typedef struct __SERIALPORT
{
    GUID   m_Secret;                // Identifies this as a serial port
    HANDLE m_hPort;                 // Handle to the opened serial port
    HANDLE m_hAbort;                // Event signalled when port is closing
    HANDLE m_hReadMutex;            // Only one thread allowed to read a port
    HANDLE m_hWriteMutex;           // Only one thread allowed to read a port
    HANDLE m_hCloseMutex;           // Only one thread allowed to close a port
    HANDLE m_hReadComplete;         // Event to signal read completion
    HANDLE m_hWriteComplete;        // Event to signal write completion
} SERIALPORT, *PSERIALPORT;


extern PVOID APIENTRY lhcOpen(
    PCWSTR pcszPortSpec);

extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize);

extern BOOL APIENTRY lhcClose(
    PVOID pObject);

extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize);

BOOL lhcpAcquireWithAbort(
    HANDLE hMutex,
    HANDLE hAbort);

BOOL lhcpAcquireReadWithAbort(
    PSERIALPORT pObject);

BOOL lhcpAcquireWriteWithAbort(
    PSERIALPORT pObject);

BOOL lhcpAcquireCloseWithAbort(
    PSERIALPORT pObject);

BOOL lhcpAcquireReadAndWrite(
    PSERIALPORT pObject);

BOOL lhcpReleaseRead(
    PSERIALPORT pObject);

BOOL lhcpReleaseWrite(
    PSERIALPORT pObject);

BOOL lhcpReleaseClose(
    PSERIALPORT pObject);

BOOL lhcpIsValidObject(
    PSERIALPORT pObject);

PSERIALPORT lhcpCreateNewObject();

void lhcpDeleteObject(
    PSERIALPORT pObject);

BOOL lhcpParseParameters(
    PCWSTR pcszPortSpec,
    PWSTR* pszPort,
    PDWORD pdwBaudRate);

void lhcpParseParametersFree(
    PWSTR* pszPort,
    PDWORD pdwBaudRate);

BOOL lhcpSetCommState(
    HANDLE hPort,
    DWORD dwBaudRate);

BOOL lhcpWaitForCommEvent(
    PSERIALPORT pObject,
    PDWORD pdwEventMask);

BOOL lhcpReadCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

BOOL lhcpWriteCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize);






BOOL lhcpAcquireWithAbort(HANDLE hMutex, HANDLE hAbort)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = hAbort;
    hWaiters[1] = hMutex;

    // We should honour the m_hAbort event, since this is signalled when the
    // port is closed by another thread
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }


    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpAcquireReadWithAbort(PSERIALPORT pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hReadMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireWriteWithAbort(PSERIALPORT pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hWriteMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireCloseWithAbort(PSERIALPORT pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hCloseMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireReadAndWrite(PSERIALPORT pObject)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = pObject->m_hReadMutex;
    hWaiters[1] = pObject->m_hWriteMutex;

    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        TRUE,
        1000);      // Timeout after 1 second

    if (WAIT_OBJECT_0!=dwWaitResult)
    {
        goto Error;
    }

    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpReleaseRead(PSERIALPORT pObject)
{
    return ReleaseMutex(
        pObject->m_hReadMutex);
}


BOOL lhcpReleaseWrite(PSERIALPORT pObject)
{
    return ReleaseMutex(
        pObject->m_hWriteMutex);
}


BOOL lhcpReleaseClose(PSERIALPORT pObject)
{
    return ReleaseMutex(
        pObject->m_hCloseMutex);
}


BOOL lhcpIsValidObject(PSERIALPORT pObject)
{
    BOOL bResult;

    __try
    {
        bResult = IsEqualGUID(
            &uuidSerialPortObjectGuid,
            &pObject->m_Secret);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        bResult = FALSE;
        goto Done;
    }

Done:
    return bResult;
}


PSERIALPORT lhcpCreateNewObject()
{
    PSERIALPORT pObject = (PSERIALPORT)malloc(
        sizeof(SERIALPORT));
    pObject->m_Secret = uuidSerialPortObjectGuid;
    pObject->m_hPort = INVALID_HANDLE_VALUE;
    pObject->m_hAbort = NULL;
    pObject->m_hReadMutex = NULL;     // Only one thread allowed to read a port
    pObject->m_hWriteMutex = NULL;    // Only one thread allowed to read a port
    pObject->m_hCloseMutex = NULL;    // Only one thread allowed to read a port
    pObject->m_hReadComplete = NULL;  // Event to signal read completion
    pObject->m_hWriteComplete = NULL; // Event to signal write completion
    return pObject;
}


void lhcpDeleteObject(PSERIALPORT pObject)
{
    if (pObject==NULL)
    {
        return;
    }
    ZeroMemory(
        &(pObject->m_Secret),
        sizeof(pObject->m_Secret));
    if (pObject->m_hPort!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(
            pObject->m_hPort);
    }
    if (pObject->m_hAbort!=NULL)
    {
        CloseHandle(
            pObject->m_hAbort);
    }
    if (pObject->m_hReadMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hReadMutex);
    }
    if (pObject->m_hWriteMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteMutex);
    }
    if (pObject->m_hCloseMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hCloseMutex);
    }
    if (pObject->m_hReadComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hReadComplete);
    }
    if (pObject->m_hWriteComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteComplete);
    }
    FillMemory(
        pObject,
        sizeof(SERIALPORT),
        0x00);

    free(
        pObject);
}


BOOL lhcpParseParameters(PCWSTR pcszPortSpec, PWSTR* pszPort, PDWORD pdwBaudRate)
{
    PWSTR pszSettings;

    *pszPort = malloc(
        (wcslen(pcszPortSpec) + 5) * sizeof(WCHAR));

    if (NULL==*pszPort)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    wcscpy(
        *pszPort,
        L"\\\\.\\");         // Append the device prefix to the port name

    wcscat(
        *pszPort,
        pcszPortSpec);

    pszSettings = wcschr(       // Find where the settings start
        *pszPort,
        L'@');

    if (NULL==pszSettings)
    {
        SetLastError(
            ERROR_INVALID_PARAMETER);
        goto Error;
    }

    *pszSettings++ = L'\0';  // Separate the strings

    *pdwBaudRate = 0;

    while (*pszSettings!=L'\0' && *pdwBaudRate<115200)
    {
        if (L'0'<=*pszSettings && *pszSettings<=L'9')
        {
            *pdwBaudRate *= 10;
            *pdwBaudRate += *pszSettings - L'0';
            pszSettings++;
        }
        else
        {
            break;
        }
    }

    if (*pszSettings!=L'0' && *pdwBaudRate!=9600 && *pdwBaudRate!=19200 &&
        *pdwBaudRate!=38400 && *pdwBaudRate!=57600 && *pdwBaudRate!=115200)
    {
        SetLastError(
            ERROR_INVALID_PARAMETER);
        goto Error;
    }

    return TRUE;

Error:
    lhcpParseParametersFree(
        pszPort, pdwBaudRate);

    return FALSE;
}



void lhcpParseParametersFree(PWSTR* pszPort, PDWORD pdwBaudRate)
{
    if (*pszPort != NULL)
    {
        free(*pszPort);
        *pszPort = NULL;
    }

    *pdwBaudRate = 0;
}



BOOL lhcpSetCommState(HANDLE hPort, DWORD dwBaudRate)
{
    DCB MyDCB;
    COMMTIMEOUTS CommTimeouts;
    BOOL bResult;

    ZeroMemory(
        &MyDCB,
        sizeof(DCB));

    MyDCB.DCBlength         = sizeof(DCB);
    MyDCB.BaudRate          = dwBaudRate;
    MyDCB.fBinary           = 1;
    MyDCB.fParity           = 1;
    MyDCB.fOutxCtsFlow      = 0;
    MyDCB.fOutxDsrFlow      = 0;
    MyDCB.fDtrControl       = 1;
    MyDCB.fDsrSensitivity   = 0;
    MyDCB.fTXContinueOnXoff = 1;
    MyDCB.fOutX             = 1;
    MyDCB.fInX              = 1;
    MyDCB.fErrorChar        = 0;
    MyDCB.fNull             = 0;
    MyDCB.fRtsControl       = 1;
    MyDCB.fAbortOnError     = 0;
    MyDCB.XonLim            = 0x50;
    MyDCB.XoffLim           = 0xc8;
    MyDCB.ByteSize          = 0x8;
    MyDCB.Parity            = 0;
    MyDCB.StopBits          = 0;
    MyDCB.XonChar           = 17;
    MyDCB.XoffChar          = 19;
    MyDCB.ErrorChar         = 0;
    MyDCB.EofChar           = 0;
    MyDCB.EvtChar           = 0;

    bResult = SetCommState(
        hPort,
        &MyDCB);

    if (!bResult)
    {
        goto Error;
    }

    CommTimeouts.ReadIntervalTimeout = 0xffffffff;  //MAXDWORD
    CommTimeouts.ReadTotalTimeoutMultiplier = 0x0;  //MAXDWORD
    CommTimeouts.ReadTotalTimeoutConstant = 0x0;

    CommTimeouts.WriteTotalTimeoutMultiplier = 0;
    CommTimeouts.WriteTotalTimeoutConstant = 0;

    bResult = SetCommTimeouts(
        hPort,
        &CommTimeouts);

    if (!bResult)
    {
        goto Error;
    }

    bResult = SetCommMask(
        hPort,
        EV_SERIAL);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



BOOL lhcpWaitForCommEvent(PSERIALPORT pObject, PDWORD pdwEventMask)
{
    OVERLAPPED Overlapped;
    BOOL bResult;
    HANDLE hWaiters[2];
    DWORD dwWaitResult;
    DWORD dwBytesTransferred;

    // I have no idea whether this is necessary, so I will do it just to be
    // on the safe side.
    ZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    Overlapped.hEvent = pObject->m_hReadComplete;

    // Start waiting for a comm event
    bResult = WaitCommEvent(
        pObject->m_hPort,
        pdwEventMask,
        &Overlapped);

    if (!bResult && GetLastError()!=ERROR_IO_PENDING)
    {
        goto Error;
    }

    hWaiters[0] = pObject->m_hAbort;
    hWaiters[1] = pObject->m_hReadComplete;

    // Let's wait for the operation to complete. This will quit waiting if
    // the m_hAbort event is signalled.
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        // The m_hAbort event was signalled.  This means that Close was called
        // on this serial port object.  So let's cancel the pending IO.
        CancelIo(
            pObject->m_hPort);
        // The serial port object is being closed, so let's call it invalid.
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }

    // Check the success or failure of the operation
    bResult = GetOverlappedResult(
        pObject->m_hPort,
        &Overlapped,
        &dwBytesTransferred,
        TRUE);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



BOOL lhcpReadCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    OVERLAPPED Overlapped;
    BOOL bResult;
    DWORD dwWaitResult;
    HANDLE hWaiters[2];

    // I have no idea whether this is necessary, so I will do it just to be
    // on the safe side.
    ZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    Overlapped.hEvent = pObject->m_hReadComplete;

    // We can now read the comm port
    bResult = ReadFile(
        pObject->m_hPort,
        pBuffer,
        dwSize,
        pdwBytesRead,
        &Overlapped);

    if (!bResult && GetLastError()!=ERROR_IO_PENDING)
    {
        goto Error;
    }

    hWaiters[0] = pObject->m_hAbort;
    hWaiters[1] = pObject->m_hReadComplete;

    // Let's wait for the operation to complete. This will quit waiting if
    // the m_hAbort event is signalled.
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        // The m_hAbort event was signalled.  This means that Close was called
        // on this serial port object.  So let's cancel the pending IO.
        CancelIo(
            pObject->m_hPort);
        // The serial port object is being closed, so let's call it invalid.
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }

    // Check the success or failure of the read operation
    bResult = GetOverlappedResult(
        pObject->m_hPort,
        &Overlapped,
        pdwBytesRead,
        TRUE);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



BOOL lhcpWriteCommPort(
    PSERIALPORT pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    OVERLAPPED Overlapped;
    BOOL bResult;
    DWORD dwBytesWritten;
    DWORD dwWaitResult;
    HANDLE hWaiters[2];

    // I have no idea whether this is necessary, so I will do it just to be
    // on the safe side.
    ZeroMemory(
        &Overlapped,
        sizeof(OVERLAPPED));

    Overlapped.hEvent = pObject->m_hWriteComplete;

    // We can now read the comm port
    bResult = WriteFile(
        pObject->m_hPort,
        pBuffer,
        dwSize,
        &dwBytesWritten,
        &Overlapped);

    if (!bResult && GetLastError()!=ERROR_IO_PENDING)
    {
        goto Error;
    }

    hWaiters[0] = pObject->m_hAbort;
    hWaiters[1] = pObject->m_hWriteComplete;

    // Let's wait for the operation to complete. This will quit waiting if
    // the m_hAbort event is signalled.  If the read operation completed
    // immediately, then this wait will succeed immediately.
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        // The m_hAbort event was signalled.  This means that Close was called
        // on this serial port object.  So let's cancel the pending IO.
        CancelIo(
            pObject->m_hPort);
        // The serial port object is being closed, so let's call it invalid.
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }

    // Check the success or failure of the write operation
    bResult = GetOverlappedResult(
        pObject->m_hPort,
        &Overlapped,
        &dwBytesWritten,
        TRUE);

    if (!bResult)
    {
        goto Error;
    }

    return TRUE;

Error:
    return FALSE;
}



extern PVOID APIENTRY lhcOpen(PCWSTR pcszPortSpec)
{
    BOOL bResult;
    PWSTR pszPort;
    DWORD dwBaudRate;
    PSERIALPORT pObject = NULL;
    DCB MyDCB;

    bResult = lhcpParseParameters(
        pcszPortSpec,
        &pszPort,
        &dwBaudRate);

    if (!bResult)
    {
        goto Error;
    }

    // Allocate space and initialize the serial port object
    pObject = lhcpCreateNewObject();

    if (NULL==pObject)
    {
        goto Error;
    }

    // Open the serial port
    pObject->m_hPort = CreateFileW(
        pszPort,
        GENERIC_ALL,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL);

    if (INVALID_HANDLE_VALUE==pObject->m_hPort)
    {
        goto Error;
    }

    // Set the properties of the serial port
    bResult = lhcpSetCommState(
        pObject->m_hPort,
        dwBaudRate);

    if (!bResult)
    {
        goto Error;
    }

    // This event will be set when we want to close the port
    pObject->m_hAbort = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hAbort)
    {
        goto Error;
    }

    // This event will be used for overlapped reading from the port
    pObject->m_hReadComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadComplete)
    {
        goto Error;
    }

    // This event will be used for overlapped writing to the port
    pObject->m_hWriteComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteComplete)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can read at a time
    pObject->m_hReadMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can write at a time
    pObject->m_hWriteMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can close the port
    pObject->m_hCloseMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hCloseMutex)
    {
        goto Error;
    }

    // Free up the temporary memory used to parse the parameters
    lhcpParseParametersFree(
        &pszPort, &dwBaudRate);

    // Return a pointer to the new object
    return pObject;

Error:
    lhcpParseParametersFree(
        &pszPort, &dwBaudRate);
    lhcpDeleteObject(
        pObject);

    return NULL;
}


extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    OVERLAPPED Overlapped;
    DWORD dwEventMask;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid SERIALPORT object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    bResult = lhcpAcquireReadWithAbort(
        (PSERIALPORT)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Wait for something to happen to the serial port
    bResult = lhcpWaitForCommEvent(
        (PSERIALPORT)pObject, &dwEventMask);

    if (!bResult)
    {
        goto Error;
    }

    // We should now have a valid serial port event, so let's read the port.
    bResult = lhcpReadCommPort(
        (PSERIALPORT)pObject,
        pBuffer,
        dwSize,
        pdwBytesRead);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseRead(
        (PSERIALPORT)pObject);
    return TRUE;

Error:
    lhcpReleaseRead(
        (PSERIALPORT)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    OVERLAPPED Overlapped;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid SERIALPORT object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    // Block until it is your turn
    bResult = lhcpAcquireWriteWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Wait for something to happen to the serial port
    bResult = lhcpWriteCommPort(
        (PSERIALPORT)pObject,
        pBuffer,
        dwSize);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseWrite(
        (PSERIALPORT)pObject);
    return TRUE;

Error:
    lhcpReleaseWrite(
        (PSERIALPORT)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcClose(PVOID pObject)
{
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid SERIALPORT object
    if (!lhcpIsValidObject(pObject))
    {
        goto Error;
    }

    // We need to ensure that we are the only thread closing this object
    bResult = lhcpAcquireCloseWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Signal everyone to quit doing what they're doing.  Any new threads
    // calling lhcRead and lhcWrite will be immediately sent packing, since
    // the m_hAbort event is waited on along with the relevant mutex.
    bResult = SetEvent(
        ((PSERIALPORT)pObject)->m_hAbort);

    if (!bResult)
    {
        goto Error;
    }

    // Now acquire the read and write mutexes so that no-one else will try to
    // access this object to read or write.  Abort does not apply, since we
    // have already signalled it.  We know that we are closing, and we need
    // the read and write mutexes.
    bResult = lhcpAcquireReadAndWrite(
        (PSERIALPORT)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }

    // Closes all of the open handles, erases the secret and frees up the
    // memory associated with the object.  We can close the mutex objects,
    // even though we are the owners, since we can guarantee that no-one
    // else is waiting on them.  The m_hAbort event being signalled will
    // ensure this.
    lhcpDeleteObject(
        (PSERIALPORT)pObject);

    return TRUE;

Error:
    lhcpReleaseClose(
        (PSERIALPORT)pObject);
NoMutex:
    return FALSE;
}



extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize)
{
    DWORD dwNameSize = wcslen(SERIALPORT_NAME)+1;

    // If zero is passed in as the buffer length, we will return the
    // required buffer size in characters, as calulated above.  If the
    // incoming buffer size is not zero, and smaller than the required
    // buffer size, we return 0 (failure) with a valid error code.  Notice
    // that in the case where the incoming size is zero, we don't touch
    // the buffer pointer at all.

    if (dwSize!=0 && dwSize < dwNameSize)
    {
        SetLastError(
            ERROR_INSUFFICIENT_BUFFER);
        dwNameSize = 0;
    }
    else
    {
        wcscpy(
            pszBuffer,
            SERIALPORT_NAME);
    }

    return dwNameSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\tcpip\tcpip.c ===
#include "std.h"

// This is the communications mask used by our serial port.  More may be
// necessary, but for right now, this seems to work.
#define EV_SERIAL EV_RXCHAR | EV_ERR | EV_BREAK
#define TCPIP_NAME     L"TCP/IP"

// This GUID is used to identify objects opened by this library.  It is
// placed in the m_Secret member of the SOCKET structure. Any external
// interface accepting a SOCKET object as a parameter should check this
// out before using the structure.
// {29566A75-BCDE-4bba-BC6A-EA652C0651D9}
static const GUID uuidTCPIPObjectGuid =
{ 0x29566a75, 0xbcde, 0x4bba, { 0xbc, 0x6a, 0xea, 0x65, 0x2c, 0x6, 0x51, 0xd9 } };


// Structure defining an open serial port object.  All external users of this
// library will only have a void pointer to one of these, and the structure is
// not published anywhere.  This abstration makes it more difficult for the
// user to mess things up.
typedef struct __TCPIP
{
    GUID   m_Secret;                // Identifies this as a tcpip socket
    SOCKET m_Socket;                // SOCKET handle
    HANDLE m_hAbort;                // Event signalled when port is closing
    HANDLE m_hReadMutex;            // Only one thread allowed to read a port
    HANDLE m_hWriteMutex;           // Only one thread allowed to read a port
    HANDLE m_hCloseMutex;           // Only one thread allowed to close a port
    HANDLE m_hReadComplete;         // Event to signal read completion
    HANDLE m_hWriteComplete;        // Event to signal write completion
} TCPIP, *PTCPIP;


extern PVOID APIENTRY lhcOpen(
    PCWSTR pcszPortSpec);

extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize);

extern BOOL APIENTRY lhcClose(
    PVOID pObject);

extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize);

BOOL lhcpAcquireWithAbort(
    HANDLE hMutex,
    HANDLE hAbort);

BOOL lhcpAcquireReadWithAbort(
    PTCPIP pObject);

BOOL lhcpAcquireWriteWithAbort(
    PTCPIP pObject);

BOOL lhcpAcquireCloseWithAbort(
    PTCPIP pObject);

BOOL lhcpAcquireReadAndWrite(
    PTCPIP pObject);

BOOL lhcpReleaseRead(
    PTCPIP pObject);

BOOL lhcpReleaseWrite(
    PTCPIP pObject);

BOOL lhcpReleaseClose(
    PTCPIP pObject);

BOOL lhcpIsValidObject(
    PTCPIP pObject);

PTCPIP lhcpCreateNewObject();

void lhcpDeleteObject(
    PTCPIP pObject);

BOOL lhcpParseParameters(
    PCWSTR        pcszPortSpec,
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address);

void lhcpParseParametersFree(
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address);

BOOL lhcpSetCommState(
    HANDLE hPort,
    DWORD dwBaudRate);

BOOL lhcpReadTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead);

BOOL lhcpWriteTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize);



BOOL WINAPI DllEntryPoint(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved)  // reserved
{
    WSADATA WsaData;
    int dResult;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        dResult = WSAStartup(
            MAKEWORD(2,0),
            &WsaData);
        if (dResult!=ERROR_SUCCESS)
        {
            SetLastError(
                dResult);
            return FALSE;
        }
        break;
    case DLL_PROCESS_DETACH:
        dResult = WSACleanup();
        if (dResult!=ERROR_SUCCESS)
        {
            SetLastError(
                dResult);
            return FALSE;
        }
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}



BOOL lhcpAcquireWithAbort(HANDLE hMutex, HANDLE hAbort)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = hAbort;
    hWaiters[1] = hMutex;

    // We should honour the m_hAbort event, since this is signalled when the
    // port is closed by another thread
    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        FALSE,
        INFINITE);

    if (WAIT_OBJECT_0==dwWaitResult)
    {
        goto Error;
    }
    else if ((WAIT_OBJECT_0+1)!=dwWaitResult)
    {
        // This should never, ever happen - so I will put a debug breapoint
        // in here (checked only).
        #ifdef DBG
        DebugBreak();
        #endif
        goto Error;
    }


    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpAcquireReadWithAbort(PTCPIP pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hReadMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireWriteWithAbort(PTCPIP pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hWriteMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireCloseWithAbort(PTCPIP pObject)
{
    return lhcpAcquireWithAbort(
        pObject->m_hCloseMutex,
        pObject->m_hAbort);
}


BOOL lhcpAcquireReadAndWrite(PTCPIP pObject)
{
    HANDLE hWaiters[2];
    DWORD dwWaitResult;

    hWaiters[0] = pObject->m_hReadMutex;
    hWaiters[1] = pObject->m_hWriteMutex;

    dwWaitResult = WaitForMultipleObjects(
        2,
        hWaiters,
        TRUE,
        1000);      // Timeout after 1 second

    if (WAIT_OBJECT_0!=dwWaitResult)
    {
        goto Error;
    }

    return TRUE;    // We have acquired the write mutex

Error:
    return FALSE;   // We have aborted
}


BOOL lhcpReleaseRead(PTCPIP pObject)
{
    return ReleaseMutex(
        pObject->m_hReadMutex);
}


BOOL lhcpReleaseWrite(PTCPIP pObject)
{
    return ReleaseMutex(
        pObject->m_hWriteMutex);
}


BOOL lhcpReleaseClose(PTCPIP pObject)
{
    return ReleaseMutex(
        pObject->m_hCloseMutex);
}


BOOL lhcpIsValidObject(PTCPIP pObject)
{
    BOOL bResult;

    __try
    {
        bResult = IsEqualGUID(
            &uuidTCPIPObjectGuid,
            &pObject->m_Secret);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        bResult = FALSE;
        goto Done;
    }

Done:
    return bResult;
}


PTCPIP lhcpCreateNewObject()
{
    PTCPIP pObject = (PTCPIP)malloc(
        sizeof(TCPIP));
    pObject->m_Secret = uuidTCPIPObjectGuid;
    pObject->m_Socket = INVALID_SOCKET;
    pObject->m_hAbort = NULL;
    pObject->m_hReadMutex = NULL;     // Only one thread allowed to read a port
    pObject->m_hWriteMutex = NULL;    // Only one thread allowed to read a port
    pObject->m_hCloseMutex = NULL;    // Only one thread allowed to read a port
    pObject->m_hReadComplete = NULL;  // Event to signal read completion
    pObject->m_hWriteComplete = NULL; // Event to signal write completion
    return pObject;
}


void lhcpDeleteObject(PTCPIP pObject)
{
    if (pObject==NULL)
    {
        return;
    }
    ZeroMemory(
        &(pObject->m_Secret),
        sizeof(pObject->m_Secret));
    if (pObject->m_Socket!=INVALID_SOCKET)
    {
        closesocket(
            pObject->m_Socket);
    }
    if (pObject->m_hAbort!=NULL)
    {
        CloseHandle(
            pObject->m_hAbort);
    }
    if (pObject->m_hReadMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hReadMutex);
    }
    if (pObject->m_hWriteMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteMutex);
    }
    if (pObject->m_hCloseMutex!=NULL)
    {
        CloseHandle(
            pObject->m_hCloseMutex);
    }
    if (pObject->m_hReadComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hReadComplete);
    }
    if (pObject->m_hWriteComplete!=NULL)
    {
        CloseHandle(
            pObject->m_hWriteComplete);
    }
    FillMemory(
        pObject,
        sizeof(TCPIP),
        0x00);

    free(
        pObject);
}


BOOL lhcpParseParameters(
    PCWSTR        pcszPortSpec,
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address)
{
    DWORD dwPort;
    DWORD dwAddress;
    PSTR pszAddress = NULL;
    PSTR pszPort = NULL;
    struct hostent* pHost = NULL;
    int dStringLength = 0;
    PWSTR pszCount = (PWSTR)pcszPortSpec;

    *pszHostName = NULL;
    *pszInetAddress = NULL;
    *Address = NULL;


    // First off, we need to do a quick check for a valid looking target. If
    // we are definitely looking at something invalid, why make the user wait?
    while (*pszCount!='\0')
    {
        if (!(iswalpha(*pszCount) || iswdigit(*pszCount) || (*pszCount==L'_') ||
            (*pszCount==L'.') || (*pszCount==L':') || (*pszCount==L'-')))
        {
            SetLastError(
                ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }
        pszCount++;
    }

    dStringLength = WideCharToMultiByte(
        CP_ACP,
        0,
        pcszPortSpec,
        -1,
        NULL,
        0,
        NULL,
        NULL);

    if (0==dStringLength)
    {
        goto Error;
    }

    pszAddress = (PSTR)malloc(
        dStringLength);

    if (NULL==pszAddress)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    dStringLength = WideCharToMultiByte(
        CP_ACP,
        0,
        pcszPortSpec,
        -1,
        pszAddress,
        dStringLength,
        NULL,
        NULL);

    if (0==dStringLength)
    {
        goto Error;
    }

    // Let's see if there is a port specified

    pszPort = strchr(
        pszAddress,
        ':');

    if (NULL==pszPort)
    {
        // No port was specified, so what we have here is an attempt to
        // connect to the default telnet port (23). I will point the port
        // pointer at a null character.
        pszPort = pszAddress + strlen(pszAddress);
        dwPort = 23;
    }
    else
    {
        *pszPort++ = '\0';
        dwPort = 0;
    }

    while ((*pszPort)!='\0')
    {
        if ('0'<=(*pszPort) && (*pszPort)<='9')
        {
            dwPort *= 10;
            dwPort += ((*pszPort) - '0');
            if (dwPort>0xffff) // Check for maximum port number
            {
                dwPort=0;      // The port number is not valid
                break;
            }
            pszPort++;         // Look at the next character
        }
        else
        {
            dwPort = 0;         // The port number is not valid
            break;
        }
    }

    if (dwPort==0)
    {
        SetLastError(
            ERROR_INVALID_PARAMETER);
        goto Error;
    }

    // We have decoded the port, now we need to get the hostentry for
    // the target server.

    // Firstly check whether this is a dotted internet address.
    dwAddress = (DWORD)inet_addr(
        pszAddress);

    dwAddress = (dwAddress==0) ? INADDR_NONE : dwAddress;

    if (dwAddress==INADDR_NONE)
    {
        // This is not a dotted address, or is invalid.
        // Check for a machine name
        pHost = gethostbyname(
            pszAddress);

        if (pHost==NULL)
        {
            // This is not a valid address, so we need to return an error
            SetLastError(WSAGetLastError());
            goto Error;
        }
        else
        {
            dwAddress = *((DWORD*)(pHost->h_addr));
        }
    }
    else
    {
        pHost = NULL;
    }

    // This takes too long.  If the user has used a dotted address, then
    // that is all that he will see.
    /*
    else
    {
        // Attempt to get the host name (for prettyness)
        pHost = gethostbyaddr(
            (char*)&dwAddress,
            sizeof(IN_ADDR),
            AF_INET);
    }
    */

    *Address = malloc(
        sizeof(SOCKADDR_IN));

    if (NULL==*Address)
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    ZeroMemory(
        *Address,
        sizeof(SOCKADDR_IN));

    if (pHost==NULL)
    {
        // This address does not resolve to a name, so we must just go
        // the IP number passed to us.
        *pszHostName = NULL;
    }
    else
    {
        // We have a hostent entry to populate this with

        dStringLength = MultiByteToWideChar(
            CP_ACP,
            0,
            pHost->h_name,
            -1,
            NULL,
            0);

        if (dStringLength==0)
        {
            goto Error;
        }

        *pszHostName = malloc(
            (dStringLength + 7) * sizeof(WCHAR));

        if (NULL==*pszHostName)
        {
            SetLastError(
                ERROR_NOT_ENOUGH_MEMORY);
            goto Error;
        }

        dStringLength = MultiByteToWideChar(
            CP_ACP,
            0,
            pHost->h_name,
            -1,
            *pszHostName,
            dStringLength);

        if (dStringLength==0)
        {
            goto Error;
        }

        if (dwPort==23)
        {
            wcscat(
                *pszHostName,
                L":telnet");
        }
        else
        {
            PWSTR pszPort = *pszHostName + wcslen(*pszHostName);

            swprintf(
                pszPort,
                L":%u",
                dwPort & 0xFFFF);
        }

    }

    (**Address).sin_family = AF_INET;
    (**Address).sin_port = htons((USHORT)dwPort);
    (**Address).sin_addr.S_un.S_addr = (ULONG)dwAddress;

    *pszInetAddress = malloc(
        22 * sizeof(WCHAR));

    if (*pszInetAddress==NULL)
    {
        goto Error;
    }

    swprintf(
        *pszInetAddress,
        L"%u.%u.%u.%u:%u",
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b1),
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b2),
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b3),
        (DWORD)((**Address).sin_addr.S_un.S_un_b.s_b4),
        (DWORD)ntohs((**Address).sin_port));

    free(pszAddress);

    return TRUE;

Error:
    lhcpParseParametersFree(
        pszHostName,
        pszInetAddress,
        Address);

    if (pszAddress!=NULL)
    {
        free(pszAddress);
    }

    return FALSE;
}



void lhcpParseParametersFree(
    PWSTR*        pszHostName,
    PWSTR*        pszInetAddress,
    SOCKADDR_IN** Address)
{
    if (*pszHostName!=NULL)
    {
        free(*pszHostName);
        *pszHostName = NULL;
    }
    if (*pszInetAddress!=NULL)
    {
        free(*pszInetAddress);
        *pszInetAddress = NULL;
    }
    if (*Address!=NULL)
    {
        free(*Address);
        *Address = NULL;
    }
}



BOOL lhcpReadTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    int dBytesRead;

    dBytesRead = recv(
        pObject->m_Socket,
        (char*)pBuffer,
        (int)dwSize,
        0);

    if (dBytesRead==SOCKET_ERROR)
    {
        SetLastError(WSAGetLastError());
        return FALSE;
    }
    else if (dBytesRead==0)   // graceful closure has occurred
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        return FALSE;
    }
    else
    {
        *pdwBytesRead = (DWORD)dBytesRead;
        return TRUE;
    }
}



BOOL lhcpWriteTCPIP(
    PTCPIP pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    int dBytesSent;

    dBytesSent = send(
        pObject->m_Socket,
        (char FAR*)pBuffer,
        (int)dwSize,
        0);

    if (dBytesSent==SOCKET_ERROR)
    {
        SetLastError(WSAGetLastError());
        wprintf(L"SEND error: %u\n", GetLastError());
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}



extern PVOID APIENTRY lhcOpen(PCWSTR pcszPortSpec)
{
    BOOL         bResult;
    int          dResult;
    PWSTR        pszHostName;
    PWSTR        pszInetAddr;
    SOCKADDR_IN* SockAddr;
    SOCKADDR_IN  saLocal;
    PTCPIP       pObject = NULL;
    int          On = 1;

    bResult = lhcpParseParameters(
        pcszPortSpec,
        &pszHostName,
        &pszInetAddr,
        &SockAddr);

    if (!bResult)
    {
        goto Error;
    }

    // Allocate space and initialize the serial port object
    pObject = lhcpCreateNewObject();

    if (NULL==pObject)
    {
        goto Error;
    }

    // Open the serial port
    pObject->m_Socket = socket(
        SockAddr->sin_family,
        SOCK_STREAM,
        0);

    if (INVALID_SOCKET==pObject->m_Socket)
    {
        goto Error;
    }

    ZeroMemory(
        &saLocal,
        sizeof(saLocal));

    if (pszHostName==NULL)
    {
//        wprintf(
//            L"Connecting to %s\n",
//            pszInetAddr);
    }
    else
    {
//        wprintf(
//            L"Connecting to %s (%s)\n",
//            pszHostName,
//            pszInetAddr);
    }

    ZeroMemory(
        &saLocal,
        sizeof(saLocal));

    saLocal.sin_family = AF_INET;
    saLocal.sin_port = 0;
    saLocal.sin_addr.S_un.S_addr = INADDR_ANY;

    dResult = bind(
        pObject->m_Socket,
        (SOCKADDR*)&saLocal,
        sizeof(SOCKADDR_IN));

    if (dResult==SOCKET_ERROR)
    {
        SetLastError(
            WSAGetLastError());
        wprintf(L"BIND error: %u\n", GetLastError());
        Sleep(1000);
        goto Error;
    }

    dResult = setsockopt(
        pObject->m_Socket,
        IPPROTO_TCP,
        TCP_NODELAY,
        (char *)&On,
        sizeof(On));

    if (dResult==SOCKET_ERROR)
    {
        SetLastError(
            WSAGetLastError());
        wprintf(L"SETSOCKOPT error: %u\n", GetLastError());
        Sleep(1000);
        goto Error;
    }

    dResult = connect(
        pObject->m_Socket,
        (SOCKADDR*)SockAddr,
        sizeof(SOCKADDR_IN));

    if (dResult==SOCKET_ERROR)
    {
        SetLastError(
            WSAGetLastError());
        if (dResult==SOCKET_ERROR)
        {
            SetLastError(
                WSAGetLastError());
            wprintf(L"CONNECT error: %u\n", GetLastError());
            Sleep(1000);
            goto Error;
        }
        goto Error;
    }

    // This event will be set when we want to close the port
    pObject->m_hAbort = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hAbort)
    {
        goto Error;
    }

    // This event will be used for overlapped reading from the port
    pObject->m_hReadComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadComplete)
    {
        goto Error;
    }

    // This event will be used for overlapped writing to the port
    pObject->m_hWriteComplete = CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteComplete)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can read at a time
    pObject->m_hReadMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hReadMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can write at a time
    pObject->m_hWriteMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hWriteMutex)
    {
        goto Error;
    }

    // This mutex will ensure that only one thread can close the port
    pObject->m_hCloseMutex = CreateMutex(
        NULL,
        FALSE,
        NULL);

    if (NULL==pObject->m_hCloseMutex)
    {
        goto Error;
    }

    // Free up the temporary memory used to parse the parameters
    lhcpParseParametersFree(
        &pszHostName,
        &pszInetAddr,
        &SockAddr);

    // Return a pointer to the new object
    return pObject;

Error:
    lhcpParseParametersFree(
        &pszHostName,
        &pszInetAddr,
        &SockAddr);
    lhcpDeleteObject(
        pObject);

    return NULL;
}


extern BOOL APIENTRY lhcRead(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize,
    PDWORD pdwBytesRead)
{
    OVERLAPPED Overlapped;
    DWORD dwEventMask;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid TCPIP object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    bResult = lhcpAcquireReadWithAbort(
        (PTCPIP)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // We should now have a valid serial port event, so let's read the port.
    bResult = lhcpReadTCPIP(
        (PTCPIP)pObject,
        pBuffer,
        dwSize,
        pdwBytesRead);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseRead(
        (PTCPIP)pObject);
    return TRUE;

Error:
    lhcpReleaseRead(
        (PTCPIP)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcWrite(
    PVOID pObject,
    PVOID pBuffer,
    DWORD dwSize)
{
    OVERLAPPED Overlapped;
    BOOL bResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid TCPIP object
    if (!lhcpIsValidObject(pObject))
    {
        goto NoMutex;
    }

    // Block until it is your turn
    bResult = lhcpAcquireWriteWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Wait for something to happen to the serial port
    bResult = lhcpWriteTCPIP(
        (PTCPIP)pObject,
        pBuffer,
        dwSize);

    if (!bResult)
    {
        goto Error;
    }

    lhcpReleaseWrite(
        (PTCPIP)pObject);
    return TRUE;

Error:
    lhcpReleaseWrite(
        (PTCPIP)pObject);
NoMutex:
    return FALSE;
}



extern BOOL APIENTRY lhcClose(PVOID pObject)
{
    BOOL bResult;
    int dSockResult;

    // Firstly, we need to check whether the pointer that got passed in
    // points to a valid TCPIP object
    if (!lhcpIsValidObject(pObject))
    {
        goto Error;
    }

    // We need to ensure that we are the only thread closing this object
    bResult = lhcpAcquireCloseWithAbort(
        pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto NoMutex;
    }

    // Signal everyone to quit doing what they're doing.  Any new threads
    // calling lhcRead and lhcWrite will be immediately sent packing, since
    // the m_hAbort event is waited on along with the relevant mutex.
    bResult = SetEvent(
        ((PTCPIP)pObject)->m_hAbort);

    // This abort flag will not cause blocking socket reads and writes to quit
    // immediately.  The only way to make this happen is to close the socket
    // gracefully.  So here we go...
    dSockResult = closesocket(
        ((PTCPIP)pObject)->m_Socket);

    if (dSockResult==SOCKET_ERROR)
    {
        SetLastError(WSAGetLastError());
        goto Error;
    }
    else
    {
        // This will cause all subsequent attempts to use the socket to fail
        ((PTCPIP)pObject)->m_Socket = INVALID_SOCKET;
    }

    // Now acquire the read and write mutexes so that no-one else will try to
    // access this object to read or write.  Abort does not apply, since we
    // have already signalled it.  We know that we are closing, and we need
    // the read and write mutexes.
    bResult = lhcpAcquireReadAndWrite(
        (PTCPIP)pObject);

    if (!bResult)
    {
        SetLastError(
            ERROR_INVALID_HANDLE);
        goto Error;
    }

    // Closes all of the open handles, erases the secret and frees up the
    // memory associated with the object.  We can close the mutex objects,
    // even though we are the owners, since we can guarantee that no-one
    // else is waiting on them.  The m_hAbort event being signalled will
    // ensure this.
    lhcpDeleteObject(
        (PTCPIP)pObject);

    return TRUE;

Error:
    lhcpReleaseClose(
        (PTCPIP)pObject);
NoMutex:
    return FALSE;
}



extern DWORD APIENTRY lhcGetLibraryName(
    PWSTR pszBuffer,
    DWORD dwSize)
{
    DWORD dwNameSize = wcslen(TCPIP_NAME)+1;

    // If zero is passed in as the buffer length, we will return the
    // required buffer size in characters, as calulated above.  If the
    // incoming buffer size is not zero, and smaller than the required
    // buffer size, we return 0 (failure) with a valid error code.  Notice
    // that in the case where the incoming size is zero, we don't touch
    // the buffer pointer at all.

    if (dwSize!=0 && dwSize < dwNameSize)
    {
        SetLastError(
            ERROR_INSUFFICIENT_BUFFER);
        dwNameSize = 0;
    }
    else
    {
        wcscpy(
            pszBuffer,
            TCPIP_NAME);
    }

    return dwNameSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\win32\except.cxx ===
#include "std.hxx"

void __cdecl StructuredExceptionHandler(unsigned int u, EXCEPTION_POINTERS* pExp)
{
    throw CStructuredExcept(
        u, pExp);
}


int __cdecl MemoryExceptionHandler(size_t size)
{
    throw CMemoryExcept(
        (DWORD)size);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\uterm\terminal.cxx ===
#include "std.hxx"

#define SHIFT_KEY_PRESSED(KeyEvent) \
    (((KeyEvent).dwControlKeyState & (SHIFT_PRESSED))!=0)

#define CTRL_KEY_PRESSED(KeyEvent) \
    (((KeyEvent).dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))!=0)

#define ALT_KEY_PRESSED(KeyEvent) \
    (((KeyEvent).dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))!=0)

#define SHIFT_ACTIVE(KeyEvent)              \
    (SHIFT_KEY_PRESSED(KeyEvent) &&         \
    (!CTRL_KEY_PRESSED(KeyEvent)) &&        \
    (!ALT_KEY_PRESSED(KeyEvent)))

#define CTRL_ACTIVE(KeyEvent)               \
    ((!SHIFT_KEY_PRESSED(KeyEvent)) &&      \
    CTRL_KEY_PRESSED(KeyEvent) &&           \
    (!ALT_KEY_PRESSED(KeyEvent)))

#define ALT_ACTIVE(KeyEvent)                \
    ((!SHIFT_KEY_PRESSED(KeyEvent)) &&      \
    (!CTRL_KEY_PRESSED(KeyEvent)) &&        \
    ALT_KEY_PRESSED(KeyEvent))

#define NONE_ACTIVE(KeyEvent)               \
    ((!SHIFT_KEY_PRESSED(KeyEvent)) &&      \
    (!CTRL_KEY_PRESSED(KeyEvent)) &&        \
    (!ALT_KEY_PRESSED(KeyEvent)))
/*
#define IS_A_SHIFTKEY( KeyEvent ) \
    (((KeyEvent).wVirtualKeyCode == VK_SCROLL) ||
     ((KeyEvent).wVirtualKeyCode == VK_NUMLOCK) ||
     ((KeyEvent).wVirtualKeyCode == VK_CAPITAL) ||
     ((KeyEvent).wVirtualKeyCode == VK_LSHIFT) ||
     ((KeyEvent).wVirtualKeyCode == VK_RSHIFT) ||
     ((KeyEvent).wVirtualKeyCode == VK_SHIFT) ||
     ((KeyEvent).wVirtualKeyCode == VK_RCTRL) ||
     ((KeyEvent).wVirtualKeyCode == VK_LCTRL) ||
     ((KeyEvent).wVirtualKeyCode == VK_CTRL) ||
     ((KeyEvent).wVirtualKeyCode == VK_LALTNUMLOCK) ||
     ((KeyEvent).wVirtualKeyCode == VK_NUMLOCK) ||
     ((KeyEvent).wVirtualKeyCode == VK_NUMLOCK) ||



      ((KeyEvent.wVirtualKeyCode == VK_INSERT   ) || \
      ( KeyEvent.wVirtualKeyCode == VK_END      ) || \
      ( KeyEvent.wVirtualKeyCode == VK_DOWN     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_NEXT     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_LEFT     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_CLEAR    ) || \
      ( KeyEvent.wVirtualKeyCode == VK_RIGHT    ) || \
      ( KeyEvent.wVirtualKeyCode == VK_HOME     ) || \
      ( KeyEvent.wVirtualKeyCode == VK_UP       ) || \
      ( KeyEvent.wVirtualKeyCode == VK_PRIOR    ) ) )
*/


BOOL CTelnetCommand::Feed(UCHAR ch)
{
    if (m_wSequenceCount>=3)
    {
        m_wSequenceCount = 0;
    }

    if (ch==0xff || m_wSequenceCount!=0)
    {
        m_Sequence[m_wSequenceCount++] = ch;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


void CAnsiSequence::Start()
{
    m_fValid = FALSE;
    m_fInvalid = FALSE;
    m_fInNumber = FALSE;
    m_bFirstChar = 0;
    m_bCommand = 0;
    m_dwParamCount = 0;
    ZeroMemory(
        m_dwParams,
        sizeof(m_dwParams));
}



void CAnsiSequence::Feed(WCHAR ch)
{
    if (ch>0x7F)
    {
        m_fInvalid = TRUE;
        return;
    }
    if (0==m_bFirstChar && '['==ch)
    {
        m_bFirstChar = ch;
        return;
    }
    else if ('0'<=ch && ch<='9')
    {
        if (m_dwParams[m_dwParamCount] < 1000)
        {
            m_dwParams[m_dwParamCount] *= 10;
            m_dwParams[m_dwParamCount] += (ch-'0');
            m_fInNumber = TRUE;
        }
        else
        {
            m_fInvalid = TRUE;
        }
    }
    else if (';'==ch)
    {
        if (m_dwParamCount<32)
        {
            m_dwParamCount++;
            m_fInNumber = TRUE;
        }
        else
        {
            m_fInvalid = TRUE;
        }
    }
    else if (('A'<=ch && ch<='Z') || ('a'<=ch && ch<='z'))
    {
        if (m_fInNumber)
        {
            m_fInNumber = FALSE;
            m_dwParamCount++;
        }
        m_bCommand = ch;
        m_fValid = TRUE;
    }
    else
    {
        m_fInvalid = TRUE;
    }
}


void CUtf8Decoder::Start()
{
    m_dwCharacter = 0;
    m_dwByteCount = 0;
    m_fValid = FALSE;
    m_fInvalid = TRUE;
}


void CUtf8Decoder::Feed(UCHAR ch)
{
    if ((ch & 0x80)==0)   // This is a single byte character
    {
        m_dwCharacter = (WCHAR)ch;
        m_dwByteCount = 0;
        m_fValid = TRUE;
        m_fInvalid = FALSE;
    }
    else if ((ch & 0xe0)==0xc0)    // First of two bytes
    {
        m_dwCharacter = ch & 0x1f; // Get data bits
        m_dwByteCount = 1;         // 1 bytes still to come
        m_fValid = FALSE;
        m_fInvalid = FALSE;
    }
    else if ((ch & 0xf0)==0xe0)    // First of three bytes
    {
        m_dwCharacter = ch & 0xf;  // Get data bits
        m_dwByteCount = 2;         // 2 bytes still to come
        m_fValid = FALSE;
        m_fInvalid = FALSE;
    }
    else if (((ch & 0xc0)==0x80) && m_dwByteCount>0 && m_dwByteCount<=3)
    {
        m_dwCharacter = ((m_dwCharacter << 6) | (((WORD)ch) & 0x3f));
        m_dwByteCount--;
        if (0==m_dwByteCount)
        {
            m_dwByteCount = 0;
            m_fValid = TRUE;
            m_fInvalid = FALSE;
        }
    }
    else
    {
        m_dwCharacter = 0;
        m_dwByteCount = 0;
        m_fValid = FALSE;
        m_fInvalid = TRUE;
    }
}



CUTerminal::CUTerminal() :
    m_wAttributes(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE),
    m_fBold(FALSE),
    m_fReverse(FALSE),
    m_fUtf8(TRUE),
    m_fAnsiKeys(FALSE),
    m_hLogFile(INVALID_HANDLE_VALUE)
{
    lhcInitialize();
    m_hConsoleOut = xGetStdHandle(STD_OUTPUT_HANDLE);    // Default = Output
    m_hConsoleIn = xGetStdHandle(STD_INPUT_HANDLE);
    SaveWindow();
    SizeWindow();
    ClearScreen();
}



CUTerminal::~CUTerminal()
{
    if (m_hLogFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLogFile);
        m_hLogFile = INVALID_HANDLE_VALUE;
    }
    RestoreWindow();
    ClearScreen();
    lhcFinalize();
}


void CUTerminal::UTF_8(BOOL utf_8)
{
    m_fUtf8 = utf_8;
    if (utf_8)
    {
        m_Utf8.Start();
    }
    SetConsoleTitle(NULL);
}



void CUTerminal::SaveWindow()
{
    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &m_BufferInfo);

    DWORD Result = GetConsoleTitle(
        pszOldTitle,
        1024);

    BOOL bResult = GetConsoleMode(
        m_hConsoleOut,
        &dwOldConsoleOutMode);

    if (!bResult)
    {
        dwOldConsoleOutMode = 0;
    }

    bResult = GetConsoleMode(
        m_hConsoleIn,
        &dwOldConsoleInMode);

    if (!bResult)
    {
        dwOldConsoleInMode = 0;
    }

    if (0==Result)
    {
        *pszOldTitle = _T('\0');
    }
}


void CUTerminal::RestoreWindow()
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &csbi);

    csbi.srWindow.Left = m_BufferInfo.srWindow.Left;
    csbi.srWindow.Right = m_BufferInfo.srWindow.Right;
    csbi.dwSize.X = m_BufferInfo.dwSize.X;

    BOOL bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    bResult = SetConsoleMode(
        m_hConsoleIn,
        dwOldConsoleInMode);
    bResult = SetConsoleMode(
        m_hConsoleOut,
        dwOldConsoleOutMode);

    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    csbi.srWindow.Top = m_BufferInfo.srWindow.Top;
    csbi.srWindow.Bottom = m_BufferInfo.srWindow.Bottom;
    csbi.dwSize.Y = m_BufferInfo.dwSize.Y;

    bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    SetConsoleTextAttribute(
        m_hConsoleOut,
        m_BufferInfo.wAttributes);

    if (_tcslen(pszOldTitle)!=0)
    {
        SetConsoleTitle(
            pszOldTitle);
    }
}


void CUTerminal::SizeWindow()
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    SetConsoleMode(
        m_hConsoleOut,
        ENABLE_PROCESSED_OUTPUT);
    SetConsoleMode(
        m_hConsoleIn,
        0);

    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &csbi);

    csbi.srWindow.Left = 0;
    csbi.srWindow.Right = TERM_COLUMN_COUNT-1;
    csbi.dwSize.X = TERM_COLUMN_COUNT;

    BOOL bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    csbi.srWindow.Top = 0;
    csbi.srWindow.Bottom = TERM_ROW_COUNT-1;
    csbi.dwSize.Y = TERM_ROW_COUNT;

    bResult = SetConsoleScreenBufferSize(
        m_hConsoleOut,
        csbi.dwSize);

    xSetConsoleWindowInfo(
        m_hConsoleOut,
        TRUE,
        &csbi.srWindow);

    if (!bResult)       // If the last one succeeded, no need to do it again
    {
        xSetConsoleScreenBufferSize(
            m_hConsoleOut,
            csbi.dwSize);
    }

    xSetConsoleTextAttribute(
        m_hConsoleOut,
        m_wAttributes);
}


void CUTerminal::SetConsoleTitle(PCTSTR pcszTitle)
{
    if (pcszTitle!=NULL)
    {
        _tcscpy(
            pszNewTitle,
            pcszTitle);
    }
    TCHAR pszTitle[1024];
    _tcscpy(
        pszTitle,
        pszNewTitle);
    _tcscat(
        pszTitle,
        m_fUtf8 ? _T(" (VT-UTF8)") : _T(" (VT100+)"));
    ::SetConsoleTitle(
        pszTitle);

}


void CUTerminal::StartLog(PCTSTR pcszLogFile)
{
    if (pcszLogFile==NULL)
    {
        return;
    }
    if (m_hLogFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hLogFile);
        m_hLogFile = INVALID_HANDLE_VALUE;
    }
    m_hLogFile = CreateFile(
        pcszLogFile,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
}



void CUTerminal::ClearScreen()
{
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD dwResult;

    xGetConsoleScreenBufferInfo(
        m_hConsoleOut,
        &csbi);

    csbi.dwCursorPosition.X = csbi.dwCursorPosition.Y = 0;

    SetConsoleCursorPosition(
        m_hConsoleOut,
        csbi.dwCursorPosition);

    xFillConsoleOutputCharacter(
        m_hConsoleOut,
        _T(' '),
        csbi.dwSize.X * csbi.dwSize.Y,
        csbi.dwCursorPosition,
        &dwResult);

    xFillConsoleOutputAttribute(
        m_hConsoleOut,
        csbi.wAttributes,
        csbi.dwSize.X * csbi.dwSize.Y,
        csbi.dwCursorPosition,
        &dwResult);
}


BOOL CUTerminal::RunTerminal(PCTSTR pcszPort)
{
    m_hClosing = xCreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL);

    m_hPortHandle = lhcOpen(
        pcszPort);
    if (0!=m_hPortHandle)
    {
        DWORD dwTemp;
        m_hOutputThread = xCreateThread(
            NULL,
            0,
            StOutputThread,
            this,
            0,
            &dwTemp);

        InputThread();

        lhcClose(
            m_hPortHandle);
        m_hPortHandle = NULL;

        // Wait for 5 seconds for the read thread to terminate.  If it doesn't,
        // then that is just tough.  The closing of the port should cause the
        // read to return ERROR_INVALID_HANDLE, and thus terminate the thread.

        dwTemp = WaitForSingleObject(
            m_hOutputThread,
            5000);

        CloseHandle(
            m_hOutputThread);
        CloseHandle(
            m_hClosing);

        return TRUE;
    }
    else
    {
        _tprintf(_T("Unable to open %s.\n"), pcszPort);
        return FALSE;
    }
}



DWORD CUTerminal::StOutputThread(PVOID pParam)
{
    ((CUTerminal*)pParam)->OutputThread();
    return 0;
}



void CUTerminal::InputThread()
{

    int ch = 0;
    int sc = 0;
    WCHAR pszKey[16];
    DWORD dwKeySize = 1;
    BOOL bResult = TRUE;

    PCSTR pszKeySequence = NULL;

    while (bResult)
    {
        bResult = Read();
        dwKeySize = 0;

        if (bResult && m_Input.uChar.UnicodeChar==0)
        {
            pszKeySequence=NULL;
            if (NONE_ACTIVE(m_Input))
            {
                switch (m_Input.wVirtualKeyCode)
                {
                case VK_F1:                   // F1 = <ESC>1
                    pszKeySequence = "\x1b""1";
                    break;
                case VK_F2:                    // F2 = <ESC>2
                    pszKeySequence = "\x1b""2";
                    break;
                case VK_F3:                    // F3 = <ESC>3
                    pszKeySequence = "\x1b""3";
                    break;
                case VK_F4:                    // F4 = <ESC>4
                    pszKeySequence = "\x1b""4";
                    break;
                case VK_F5:                    // F5 = <ESC>5
                    pszKeySequence = "\x1b""";
                    break;
                case VK_F6:                    // F6 = <ESC>6
                    pszKeySequence = "\x1b""6";
                    break;
                case VK_F7:                    // F7 = <ESC>7
                    pszKeySequence = "\x1b""7";
                    break;
                case VK_F8:                    // F8 = <ESC>8
                    pszKeySequence = "\x1b""8";
                    break;
                case VK_F9:                    // F9 = <ESC>9
                    pszKeySequence = "\x1b""9";
                    break;
                case VK_F10:                    // F10 = <ESC>0
                    pszKeySequence = "\x1b""0";
                    break;
                case VK_F11:                    // F11 = <ESC>0
                    pszKeySequence = "\x1b""!";
                    break;
                case VK_F12:                    // F12 = <ESC>0
                    pszKeySequence = "\x1b""@";
                    break;
                case VK_HOME:                  // <ESC>h
                    pszKeySequence = "\x1b""h";
                    break;
                case VK_UP:                    // UP = <ESC>A
                    pszKeySequence = "\x1b""[A";
                    break;
                case VK_PRIOR:                    // PgUp = <ESC>?
                    pszKeySequence = "\x1b""?";
                    break;
                case VK_LEFT:                    // Left = <ESC>C
                    pszKeySequence = "\x1b""[C";
                    break;
                case VK_RIGHT:                    // Right = <ESC>D
                    pszKeySequence = "\x1b""[D";
                    break;
                case VK_END:                    // END = <ESC>k
                    pszKeySequence = "\x1b""k";
                    break;
                case VK_DOWN:                    // Down = <ESC>[B
                    pszKeySequence = "\x1b""[B";
                    break;
                case VK_NEXT:                    // PgDn = <ESC>/
                    pszKeySequence = "\x1b""/";
                    break;
                case VK_INSERT:                    // Ins = <ESC>+
                    pszKeySequence = "\x1b""+";
                    break;
                case VK_DELETE:                    // Del = <ESC>-
                    pszKeySequence = "\x1b""-";
                    break;
                default:
                    continue;
                }
            }
            else if (ALT_ACTIVE(m_Input))
            {
                switch (m_Input.wVirtualKeyCode)
                {
                case VK_F1:
                    pszKeySequence = "\x1b""OP";
                    break;
                case VK_F2:
                    pszKeySequence = "\x1b""OQ";
                    break;
                case VK_F3:
                    pszKeySequence = "\x1b""OR";
                    break;
                case VK_F4:
                    pszKeySequence = "\x1b""OS";
                    break;
                case VK_F5:
                    pszKeySequence = "\x1b""[15~";
                    break;
                case VK_F6:
                    pszKeySequence = "\x1b""[17~";
                    break;
                case VK_F7:
                    pszKeySequence = "\x1b""[18~";
                    break;
                case VK_F8:
                    pszKeySequence = "\x1b""[19~";
                    break;
                case VK_F9:
                    pszKeySequence = "\x1b""[20~";
                    break;
                case VK_F10:
                    pszKeySequence = "\x1b""[21~";
                    break;
                case VK_F11:
                    pszKeySequence = "\x1b""[23~";
                    break;
                case VK_F12:
                    pszKeySequence = "\x1b""[24~";
                    break;
                default:
                    continue;
                }
            }

            if (pszKeySequence!=NULL)
            {
                DWORD dwSize = strlen(
                    pszKeySequence);

                bResult = lhcWrite(
                    m_hPortHandle,
                    (PVOID)pszKeySequence,
                    dwSize);
            }

        }
        else
        {
            if (ALT_ACTIVE(m_Input))
            {
                if (m_Input.wVirtualKeyCode=='U')
                {
                    UTF_8(!m_fUtf8);
//                    if (m_fUtf8)
//                    {
//                        printf("\a");    // Beep for on
//                    }

                }
            }
            else
            {
                if (m_Input.uChar.UnicodeChar!=29)
                {
                    bResult = Write(&(m_Input.uChar.UnicodeChar),1);
                }
                else
                {
                    bResult = FALSE;  // User selected quit
                }
            }
        }
    }
}


BOOL CUTerminal::Write(PCWSTR ch, DWORD dwSize)
{
    // We need to UTF8 encode this bad boy

    BOOL bResult = TRUE;
    UCHAR pszOutputBuffer[1024];

    if (m_fUtf8)
    {
        UCHAR*  out = pszOutputBuffer;
        PCWSTR in = ch;
        int dOutputLength = 0;

        for (DWORD dwCount=0; dwCount<dwSize; dwCount++)
        {
            if (*in<=0x80)
            {
                *out++ = *in;
                dOutputLength++;
            }
            else if (*in<=800)
            {
                *out++ = ((((*in) >>  6) & 0x1f) | 0xc0);
                *out++ = ((((*in)      ) & 0x3f) | 0x80);
                dOutputLength+=2;
            }
            else
            {
                *out++ = ((((*in) >> 12) & 0x0f) | 0xe0);
                *out++ = ((((*in) >>  6) & 0x3f) | 0x80);
                *out++ = ((((*in)      ) & 0x3f) | 0x80);
                dOutputLength+=3;
            }
            in++;
        }

        bResult = lhcWrite(
            m_hPortHandle,
            pszOutputBuffer,
            dOutputLength);
    }
    else
    {
        UCHAR*  out = pszOutputBuffer;
        PCWSTR in = ch;
        int dOutputLength = 0;

        for (DWORD dwCount=0; dwCount<dwSize; dwCount++)
        {
            *out++ = UnicodeToAnsi(*in++);
            dOutputLength++;
        }

        bResult = lhcWrite(
            m_hPortHandle,
            pszOutputBuffer,
            dOutputLength);
    }

    return bResult;
}


BOOL CUTerminal::Read()
{
    HANDLE hWaiters[2];
    static WORD wLastKey = 0;
    INPUT_RECORD pEvent;
    BOOL fGotKey = FALSE;

    while (!fGotKey)
    {
        hWaiters[0] = m_hClosing;
        hWaiters[1] = m_hConsoleIn;

        // This will wait on input being ready, whilst honoring the m_hClosing
        // event
        DWORD dwWaitResult = WaitForMultipleObjects(
            2,
            hWaiters,    // Wait on the console and on closing event
            FALSE,       // Wait for only one
            INFINITE);   // Never timeout

        if (dwWaitResult==WAIT_OBJECT_0)   // We are closing now
        {
            return FALSE;
        }

        DWORD dwEventsRead;
        BOOL bResult = ReadConsoleInputW(
            m_hConsoleIn,
            &pEvent,
            1,                                 // Just read one
            &dwEventsRead);

        if (!bResult || dwEventsRead!=1)
        {
            return FALSE;
        }

        if (pEvent.EventType!=KEY_EVENT)
        {
            // This is not a key event.  Wait again.
            continue;
        }

        memcpy(
            &m_Input,
            &pEvent.Event.KeyEvent,
            sizeof(KEY_EVENT_RECORD));

        if (m_Input.bKeyDown)
        {
            if (m_Input.uChar.UnicodeChar>=0x20)
            {
                wLastKey = 0;
                fGotKey = TRUE;
            }
            else
            {
                if (wLastKey==m_Input.wVirtualKeyCode)
                {
                    // We are auto-repeating when we shouldn't be
                    continue;
                }
                else
                {
                    wLastKey = m_Input.wVirtualKeyCode;
                    fGotKey = TRUE;
                }
            }
        }
        else
        {
            wLastKey = 0;
        }
    }

    return TRUE;
}



void CUTerminal::OutputThread()
{
    BOOL bResult;

    do
    {
        UCHAR pBuffer[1024];
        DWORD dwBytesRead;

        bResult = lhcRead(
            m_hPortHandle,
            pBuffer,
            sizeof(pBuffer),
            &dwBytesRead);

        if (bResult)
        {
            if (m_hLogFile!=INVALID_HANDLE_VALUE)
            {
                DWORD dwBytesWritten;
                // If this doesn't work, close the file and don't log any more
                bResult = WriteFile(
                    m_hLogFile,
                    pBuffer,
                    dwBytesRead,
                    &dwBytesWritten,
                    NULL);

                if (!bResult)
                {
                    CloseHandle(m_hLogFile);
                    m_hLogFile = INVALID_HANDLE_VALUE;
                }
            }

            ProcessChars(
                (PCSTR)pBuffer,
                dwBytesRead);
        }
    }
    while (bResult);
    lhcClose(
        m_hPortHandle);
    m_hPortHandle = NULL;

    SetEvent(m_hClosing);
}


void CUTerminal::ProcessChars(PCSTR ch, DWORD dwCount)
{
    PUCHAR ptr = (PUCHAR)ch;
    for (DWORD dwIndex=0; dwIndex<dwCount; dwIndex++, ptr++)
    {
        DecodeChar(*ptr);
    }
}



void CUTerminal::DecodeChar(const UCHAR ch)
{
    BOOL bProcess = m_TelnetCommand.Feed(ch);

    if (m_TelnetCommand.GotCommand())
    {
        ProcessTelnetCommand();
    }

    if (!bProcess || ch==0)  // Must we process the character?
    {
        return;
    }

    if (m_fUtf8)
    {
        m_Utf8.Feed(ch);
        if (ch==0x0e)
        {
        }
        else if (ch==0x0f)
        {
        }
        else
        {
            if (m_Utf8.IsValid())
            {
                WCHAR tc = m_Utf8.Character();
                ProcessChar(tc);
            }
        }
    }
    else
    {
        if (ch==0x0e)  // SO = do UTF8
        {
        }
        else if (ch==0x0f)
        {
        }
        else
        {
            WCHAR tc;
            tc = AnsiToUnicode(ch);
            ProcessChar(tc);
        }
    }
}


void CUTerminal::ProcessChar(WCHAR ch)
{
    if (!(m_Ansi.IsValid() || m_Ansi.IsInvalid())) // Busy with escape
    {
        m_Ansi.Feed(ch);
        if (m_Ansi.IsValid())
        {
            ProcessEscape();
        }
    }
    else
    {
        if (033==ch)    // Is this an escape char (octal value = 033)
        {
            m_Ansi.Start();
        }
        else if (3==ch)   // Write pretty version of ^C to screen
        {
            DWORD dwResult;
            WriteConsoleW(
                m_hConsoleOut,
                L"^C",
                2,
                &dwResult,
                NULL);
        }
        else
        {
            DWORD dwResult;
            WriteConsoleW(
                m_hConsoleOut,
                &ch,
                1,
                &dwResult,
                NULL);
        }
    }

}


void CUTerminal::ProcessEscape()
{
    // We need to implement the following escape sequences for the
    // headless setup stuff

    // I am going to include a hardcoded breakpoint for any extra escape
    // sequences that may occur later on in the development process

    if (m_Ansi.FirstChar()==L'[')
    {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        DWORD dwResult;
        COORD TempCoord;
        DWORD dwScratch = 0xFFFFFFFF;;

        switch (m_Ansi.Command())
        {
        case 'f':  // Same as 'H'
        case 'H':
            if (m_Ansi.ParamCount()<=2)
            {
                DWORD dwRow = m_Ansi.Param(1);
                DWORD dwColumn = m_Ansi.Param(2);
                if (dwRow==0) dwRow=1;
                if (dwColumn==0) dwColumn=1;
                COORD cp = {dwColumn-1, dwRow-1};
                SetConsoleCursorPosition(
                    m_hConsoleOut,
                    cp);
            }
            break;
        case 'J':
            if (m_Ansi.ParamCount()<=1)
            {
                xGetConsoleScreenBufferInfo(
                    m_hConsoleOut,
                    &csbi);

                if (m_Ansi.Param(1)==0)
                {
                    dwScratch = csbi.dwSize.X - csbi.dwCursorPosition.X +
                        csbi.dwSize.X * (csbi.dwSize.Y -
                                         csbi.dwCursorPosition.Y - 1);
                    TempCoord = csbi.dwCursorPosition;
                }
                else if (m_Ansi.Param(1)==1)
                {
                    dwScratch = csbi.dwCursorPosition.X + 1 +
                        (csbi.dwSize.X * csbi.dwCursorPosition.Y);
                    TempCoord.X = 0;
                    TempCoord.Y = 0;
                }
                else if (m_Ansi.Param(1)==2)
                {
                    dwScratch = csbi.dwSize.X * csbi.dwSize.Y;
                    TempCoord.X = 0;
                    TempCoord.Y = 0;
                }
                xFillConsoleOutputCharacter(
                    m_hConsoleOut,
                    _T(' '),
                    dwScratch,
                    TempCoord,
                    &dwResult);
                xFillConsoleOutputAttribute(
                    m_hConsoleOut,
                    csbi.wAttributes,
                    dwScratch,
                    TempCoord,
                    &dwResult);
            }
            break;
        case 'K':
            if (m_Ansi.ParamCount()<=1)
            {
                xGetConsoleScreenBufferInfo(
                    m_hConsoleOut,
                    &csbi);

                if (m_Ansi.Param(1)==0)
                {
                    TempCoord = csbi.dwCursorPosition;
                    dwScratch = csbi.dwSize.X - csbi.dwCursorPosition.X;
                }
                else if (m_Ansi.Param(1)==1)
                {
                    TempCoord.Y = csbi.dwCursorPosition.Y;
                    TempCoord.X = 0;
                    dwScratch = csbi.dwCursorPosition.X + 1;
                }
                else if (m_Ansi.Param(1)==2)
                {
                    TempCoord.Y = csbi.dwCursorPosition.Y;
                    TempCoord.X = 0;
                    dwScratch = csbi.dwSize.X;
                }
                xFillConsoleOutputCharacter(
                    m_hConsoleOut,
                    _T(' '),
                    dwScratch,
                    TempCoord,
                    &dwResult);
                xFillConsoleOutputAttribute(
                    m_hConsoleOut,
                    csbi.wAttributes,
                    dwScratch,
                    TempCoord,
                    &dwResult);
            }
            break;
        case 'm':
            // We need to map these attributes to comething that our screens
            // can do.  Flashing, Underscore and Concealed are something that
            // I cannot be bothered with
            if (m_Ansi.ParamCount()==0)
            {
                SetBold(FALSE);
                SetReverse(FALSE);
                ResetColors();
            }
            for (WORD count=1; count<=m_Ansi.ParamCount(); count++)
            {
                switch (m_Ansi.Param(count))
                {
                case 0:
                    SetBold(FALSE);
                    SetReverse(FALSE);
                    ResetColors();
                    break;
                case 1:
                    SetBold(TRUE);
                    break;
                case 7:
                    SetReverse(TRUE);
                    break;
                case 21:
                    SetBold(FALSE);
                    break;
                case 27:
                    SetReverse(FALSE);
                    break;
                case 30:
                    SetForeground(0);
                    break;
                case 31:  // Red
                    SetForeground(FOREGROUND_RED);
                    break;
                case 32:  // Green
                    SetForeground(FOREGROUND_GREEN);
                    break;
                case 33:  // Yellow
                    SetForeground(FOREGROUND_RED | FOREGROUND_GREEN);
                    break;
                case 34:  // Blue
                    SetForeground(FOREGROUND_BLUE);
                    break;
                case 35:  // Magenta
                    SetForeground(FOREGROUND_RED | FOREGROUND_BLUE);
                    break;
                case 36:  // Cyan
                    SetForeground(FOREGROUND_GREEN | FOREGROUND_BLUE);
                    break;
                case 37:  // White
                    SetForeground(FOREGROUND_RED | FOREGROUND_GREEN
                        | FOREGROUND_BLUE);
                    break;
                case 40:
                    SetBackground(0);
                    break;
                case 41:  // Red
                    SetBackground(BACKGROUND_RED);
                    break;
                case 42:  // Green
                    SetBackground(BACKGROUND_GREEN);
                    break;
                case 43:  // Yellow
                    SetBackground(BACKGROUND_RED | BACKGROUND_GREEN);
                    break;
                case 44:  // Blue
                    SetBackground(BACKGROUND_BLUE);
                    break;
                case 45:  // Magenta
                    SetBackground(BACKGROUND_RED | BACKGROUND_BLUE);
                    break;
                case 46:  // Cyan
                    SetBackground(BACKGROUND_GREEN | BACKGROUND_BLUE);
                    break;
                case 47:  // White
                    SetBackground(BACKGROUND_RED | BACKGROUND_GREEN
                        | BACKGROUND_BLUE);
                    break;
                }
            }

            xSetConsoleTextAttribute(
                m_hConsoleOut,
                m_wAttributes);
            break;
        default:
            printf("Unknown Escape Sequence: %c\n", m_Ansi.Command());
            break;
        }
    }
}


void CUTerminal::ProcessTelnetCommand()
{
    // Check that we have a command, and that the command descriptor is
    // correct.
    if (!m_TelnetCommand.GotCommand() || m_TelnetCommand.GetByte(1)!=0xff)
    {
        // This is not a proper command.  It should be by this point, but
        // I will do this sanity check anyhow.
        return;
    }

    UCHAR pszCommand[3];
    DWORD dwCommandSize = 3;

    switch (m_TelnetCommand.GetByte(2))  // Get the command byte
    {
    case 254:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)252;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    case 253:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)251;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    case 252:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)254;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    case 251:
        pszCommand[0] = (UCHAR)255;
        pszCommand[1] = (UCHAR)253;
        pszCommand[2] = m_TelnetCommand.GetByte(3);
        break;
    default:
        dwCommandSize = 0;
    }

    if (dwCommandSize!=0)
    {
        lhcWrite(
            m_hPortHandle,
            pszCommand,
            dwCommandSize);
    }
}



void CUTerminal::SetForeground(WORD wColor)
{
    m_wAttributes = (WORD)( ( m_wAttributes & ~((UCHAR)(FOREGROUND_RED |
        FOREGROUND_GREEN | FOREGROUND_BLUE))) | wColor );
}


void CUTerminal::SetBackground(WORD wColor)
{
    m_wAttributes = (WORD)(( m_wAttributes & ~((UCHAR)(BACKGROUND_RED |
        BACKGROUND_GREEN | BACKGROUND_BLUE))) | wColor);
}


void CUTerminal::SetBold(BOOL fOn)
{
    if (fOn)
    {
        m_wAttributes |= (UCHAR) FOREGROUND_INTENSITY;
        m_fBold = TRUE;
    }
    else
    {
        m_wAttributes &= (UCHAR) ~(FOREGROUND_INTENSITY);
        m_fBold = FALSE;
    }
}


void CUTerminal::ResetColors()
{
    m_wAttributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
}


void CUTerminal::SetReverse(BOOL fOn)
{
    if (fOn)
    {
        if (!m_fReverse)
        {
            m_wAttributes = (WORD) (((m_wAttributes &
                (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE)) >> 4) |
                ((m_wAttributes & (FOREGROUND_RED | FOREGROUND_GREEN |
                FOREGROUND_BLUE)) << 4) | (m_wAttributes &
                FOREGROUND_INTENSITY) | (m_wAttributes &
                BACKGROUND_INTENSITY));
            m_fReverse = TRUE;
        }
    }
    else
    {
        if (m_fReverse)
        {
            m_wAttributes = (WORD) (((m_wAttributes &
                (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE)) >> 4) |
                ((m_wAttributes & (FOREGROUND_RED | FOREGROUND_GREEN |
                FOREGROUND_BLUE)) << 4) | (m_wAttributes &
                FOREGROUND_INTENSITY) | (m_wAttributes &
                BACKGROUND_INTENSITY));
            m_fReverse = FALSE;
        }
    }
}



WCHAR CUTerminal::AnsiToUnicode(const UCHAR ch)
{
    WCHAR pszOutput[2];

    int i = MultiByteToWideChar(
      GetConsoleOutputCP(),         // code page
      0,                            // character-type options
      (char*)&ch,                   // string to map
      1,                            // number of bytes in string
      pszOutput,                    // wide-character buffer
      2);                           // size of buffer

    if (1==i)
    {
        return (WCHAR)*pszOutput;
    }
    else
    {
        return 0;
    }
}



UCHAR CUTerminal::UnicodeToAnsi(const WCHAR ch)
{
    UCHAR pszOutput[2];

    int i = WideCharToMultiByte(
      GetConsoleCP(),               // code page
      0,                            // character-type options
      (PCWSTR)&ch,                  // string to map
      1,                            // number of bytes in string
      (PSTR)pszOutput,              // wide-character buffer
      2,                            // size of buffer
      NULL,
      NULL);

    if (i!=0)
    {
        return *pszOutput;
    }
    else
    {
        return 0x20;                // If this didn't work, space
    }
}



void CUTerminal::StatusBar()
{
    PCTSTR pcszStatus[] = {
        _T("                                     VT1")
        _T("00+                                     "),
        _T("                                      AN")
        _T("SI                                      ")
    };

    WORD wAttribute = BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;

    COORD co;
    co.X = 0;
    co.Y = TERM_ROW_COUNT;
    DWORD dwResult;

    xWriteConsoleOutputCharacter(
        m_hConsoleOut,
        pcszStatus[m_fAnsiKeys ? 1 : 0],
        TERM_COLUMN_COUNT,
        co,
        &dwResult);

    xFillConsoleOutputAttribute(
        m_hConsoleOut,
        wAttribute,
        TERM_COLUMN_COUNT,
        co,
        &dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\term\term.c ===
#include "std.h"

#define FOREGROUND_BLACK        0
#define FOREGROUND_CYAN         FOREGROUND_BLUE | FOREGROUND_GREEN
#define FOREGROUND_MAGENTA      FOREGROUND_BLUE | FOREGROUND_RED
#define FOREGROUND_YELLOW       FOREGROUND_GREEN | FOREGROUND_RED
#define FOREGROUND_WHITE        FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED

#define BACKGROUND_BLACK        0
#define BACKGROUND_CYAN         BACKGROUND_BLUE | BACKGROUND_GREEN
#define BACKGROUND_MAGENTA      BACKGROUND_BLUE | BACKGROUND_RED
#define BACKGROUND_YELLOW       BACKGROUND_GREEN | BACKGROUND_RED
#define BACKGROUND_WHITE        BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED

#define TERMINAL_ROWS           25
#define TERMINAL_COLUMNS        80

HANDLE termpCreateTerminalBuffer();
PTERMINAL termpCreateTerminal();
void termpDestroyTerminal(PTERMINAL pTerminal);


PTERMINAL termpCreateTerminal()
{
    PTERMINAL pResult;

    pResult = malloc(
        sizeof(TERMINAL));

    if (pResult!=NULL)
    {
        ZeroMemory(
            pResult,
            sizeof(TERMINAL));
        pResult->hInput = INVALID_HANDLE_VALUE;
        pResult->hOutput = INVALID_HANDLE_VALUE;
        pResult->hSavedBuffer = INVALID_HANDLE_VALUE;
        pResult->hNewBuffer = INVALID_HANDLE_VALUE;
        pResult->wAttributes = FOREGROUND_WHITE;
        pResult->fInverse = FALSE;
        pResult->fBold = FALSE;
        pResult->fEscapeValid = FALSE;
        pResult->fEscapeInvalid = TRUE;
        pResult->wEscapeParamCount = 0;
        pResult->chEscapeCommand = 0;
        pResult->chEscapeFirstChar = 0;
        pResult->pTxProc = NULL;
    }
    else
    {
        SetLastError(
            ERROR_NOT_ENOUGH_MEMORY);
    }

    return pResult;
}


void termpDestroyTerminal(PTERMINAL pTerminal)
{
    if (pTerminal!=NULL)
    {
        free(pTerminal);
    }
}


PTERMINAL termInitialize(TERMTXPROC pTxProc)
{
    PTERMINAL pResult;
    BOOL      fResult;

    pResult = termpCreateTerminal();

    if (pResult==NULL)
    {
        goto Error;
    }

    pResult->hSavedBuffer = GetStdHandle(
        STD_OUTPUT_HANDLE);

    if (pResult->hSavedBuffer==INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    pResult->hNewBuffer = termpCreateTerminalBuffer();

    if (pResult->hNewBuffer==INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    fResult = SetConsoleActiveScreenBuffer(
        pResult->hNewBuffer);

    if (!fResult)
    {
        goto Error;
    }

    return pResult;

Error:
    termFinalize(pResult);
    return NULL;
}



void termFinalize(PTERMINAL pTerminal)
{
    if (pTerminal!=NULL)
    {
        if (pTerminal->hSavedBuffer!=INVALID_HANDLE_VALUE)
        {
            SetConsoleActiveScreenBuffer(
                pTerminal->hSavedBuffer);
        }

        if (pTerminal->hNewBuffer!=INVALID_HANDLE_VALUE)
        {
            CloseHandle(
                pTerminal->hNewBuffer);
        }

        free(pTerminal);
    }
}


HANDLE termpCreateTerminalBuffer()
{
    HANDLE hNewBuffer;
    BOOL bResult;
    COORD Coord;

    hNewBuffer = CreateConsoleScreenBuffer(
        GENERIC_READ | GENERIC_WRITE,
        0,                              // No sharing allowed
        NULL,                           // No inheritance allowed
        CONSOLE_TEXTMODE_BUFFER,        // The only supported value
        NULL);                          // Reserved, must be null

    if (hNewBuffer==INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    Coord.Y = TERMINAL_ROWS;
    Coord.X = TERMINAL_COLUMNS;

    bResult = SetConsoleScreenBufferSize(
        hNewBuffer,
        Coord);

    if (!bResult)
    {
        goto Error;
    }

    bResult = SetConsoleTextAttribute(
        hNewBuffer,
        FOREGROUND_WHITE);

    if (!bResult)
    {
        goto Error;
    }

    Coord.X = 0;
    Coord.Y = 0;

    bResult = SetConsoleCursorPosition(
        hNewBuffer,
        Coord);

    if (!bResult)
    {
        goto Error;
    }

    return hNewBuffer;

Error:
    if (hNewBuffer!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(hNewBuffer);
    }

    return INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\common\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\netctmrk.inf: $(_INX)\netctmrk.inx $(_LNG)\netctmrk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\uterm\uterm.cxx ===
#include "std.hxx"


extern "C"
{
#include <locale.h>
}

PTSTR pszConnectTo = NULL;
PTSTR pszLogFile = NULL;


BOOL DecodeParameters(int argc, PTSTR argv[])
{
    BOOL fLookForFilename = FALSE;
    for (int i=1; i<argc; i++)
    {
        if (_tcsicmp(argv[i], _T("-f"))==0)
        {
            fLookForFilename = TRUE;
            continue;
        }
        else
        {
            if (fLookForFilename)
            {
                if (pszLogFile!=NULL)
                {
                    return FALSE;
                }
                pszLogFile = argv[i];
                fLookForFilename = FALSE;
            }
            else
            {
                if (!pszConnectTo)
                {
                    pszConnectTo = argv[i];
                }
                else
                {
                    return FALSE;
                }
            }
        }
    }

    return (!fLookForFilename && pszConnectTo!=NULL);
}



extern "C"
int __cdecl _tmain(int argc, PTSTR argv[], PTSTR envv[])
{
    CUTerminal* MyTerminal;

    BOOL bResult = DecodeParameters(
        argc,
        argv);

    if (!bResult)
    {
        _tprintf(
            _T("Usage:\n\n")
            _T("  hdlstest <portspec>\n\n")
            _T("where <portspec> is the initialization string.\n"));
        return 0;
    }
    try
    {
        MyTerminal = new CUTerminal;
        MyTerminal->SetConsoleTitle(
            argv[1]);
        MyTerminal->StartLog(
            pszLogFile);
        if (!MyTerminal->RunTerminal(pszConnectTo))
        {
            delete MyTerminal;
            _tprintf(_T("Unable to open %s."), argv[1]);
        }
        else
        {
            delete MyTerminal;
        }
    }
    catch(CApiExcept& e)
    {
        _tprintf(_T("Unhandled exception in %s (%u).\n"),
            e.GetDescription(),
            e.GetError());
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\admin.h ===
// admin.h
// 6-17-97 - start using index field assigned to box to id rx-messages.

int ioctl_device(int cmd,
                 BYTE *buf,
                 BYTE *pkt,
                 ULONG offset,  // or ioctl-subfunction if cmd=ioctl
                 int size);
int eth_device_data(int message_type,
                unsigned long offset,
                int num_bytes,
                unsigned char *data,
                unsigned char *pkt,
                int *pkt_size);
int eth_device_reply(int message_type,
                unsigned long offset,
                int *num_bytes,
                unsigned char *data,
                unsigned char *pkt);

#define IOCTL_COMMAND    0x5 
#define GET_COMMAND      0x7
#define UPLOAD_COMMAND   0x8
#define DOWNLOAD_COMMAND 0x9

int admin_send_reset(Nic *nic, BYTE *dest_addr);
int admin_send_query_id(Nic *nic, BYTE *dest_addr, int set_us_as_master,
                        BYTE assigned_index);
int admin_send(Nic *nic, BYTE *buf, int len, int admin_type, BYTE *mac_dest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\sac\uterm\common\win32\xwindows.cxx ===
#include "std.hxx"


void xGetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait)
{
    BOOL bResult = ::GetOverlappedResult(
        hFile,
        lpOverlapped,
        lpNumberOfBytesTransferred,
        bWait);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetOverlappedResult"));
    }
}



HANDLE xCreateFile(
    PCTSTR pcszFileName,                         // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    PSECURITY_ATTRIBUTES pSecurityAttributes,   // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile)                       // handle to template file
{
    HANDLE hTemp = ::CreateFile(
        pcszFileName,
        dwDesiredAccess,
        dwShareMode,
        pSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);

    if (INVALID_HANDLE_VALUE==hTemp)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateFile"));
    }

    return hTemp;
}



void xCloseHandle(
    HANDLE hObject)                     // handle to object
{
    BOOL bResult = ::CloseHandle(
        hObject);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CloseHandle"));
    }
}



BOOL xReadFile(
    HANDLE hFile,                       // handle to file
    PVOID pBuffer,                      // data buffer
    DWORD dwNumberOfBytesToRead,        // number of bytes to read
    PDWORD pdwNumberOfBytesRead,        // number of bytes read
    LPOVERLAPPED pOverlapped)           // overlapped buffer
{
    BOOL bResult = ::ReadFile(
        hFile,
        pBuffer,
        dwNumberOfBytesToRead,
        pdwNumberOfBytesRead,
        pOverlapped);

    if (!bResult && (GetLastError()!=ERROR_IO_PENDING))
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReadFile"));
    }

    return bResult;
}



void xReadFileWithAbort(
    HANDLE hFile,                       // handle to file
    PVOID pBuffer,                      // data buffer
    DWORD dwNumberOfBytesToRead,        // number of bytes to read
    PDWORD pdwNumberOfBytesRead,        // number of bytes read
    LPOVERLAPPED pOverlapped,           // overlapped buffer
    HANDLE hAbort)                      // Handle to manual reset abort event
{
    HANDLE hWait[2];
    hWait[0] = hAbort;
    hWait[1] = pOverlapped->hEvent;

    BOOL bResult = xReadFile(
        hFile,                          // handle to file
        pBuffer,                        // data buffer
        dwNumberOfBytesToRead,          // number of bytes to read
        pdwNumberOfBytesRead,           // number of bytes read
        pOverlapped);                   // overlapped buffer

    if (!bResult)
    {
        DWORD dwResult = xWaitForMultipleObjects(
            2,                              // There are two to wait on
            hWait,                          // Our two event handles
            FALSE,                          // Only one event need to be pinged
            INFINITE);                      // Wait for ever

        switch (dwResult)
        {
        case (WAIT_OBJECT_0):
            CancelIo(
                hFile);
            throw CAbortExcept();
            break;
        case (WAIT_OBJECT_0 + 1):
            xGetOverlappedResult(
                hFile,
                pOverlapped,
                pdwNumberOfBytesRead,
                TRUE);
            break;
        }
    }
}



BOOL xWriteFile(
    HANDLE hFile,                       // handle to file
    LPCVOID pBuffer,                    // data buffer
    DWORD dwNumberOfBytesToWrite,       // number of bytes to write
    PDWORD pdwNumberOfBytesWritten,     // number of bytes written
    LPOVERLAPPED pOverlapped)           // overlapped buffer
{
    BOOL bResult = ::WriteFile(
        hFile,
        pBuffer,
        dwNumberOfBytesToWrite,
        pdwNumberOfBytesWritten,
        pOverlapped);

    if (!bResult && (GetLastError()!=ERROR_IO_PENDING))
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteFile"));
    }

    return bResult;
}



void xWriteFileWithAbort(
    HANDLE hFile,                       // handle to file
    LPCVOID pBuffer,                    // data buffer
    DWORD dwNumberOfBytesToWrite,       // number of bytes to write
    PDWORD pdwNumberOfBytesWritten,     // number of bytes written
    LPOVERLAPPED pOverlapped,           // overlapped buffer
    HANDLE hAbort)                      // Handle to manual reset abort event
{
    HANDLE hWait[2];
    hWait[0] = hAbort;
    hWait[1] = pOverlapped->hEvent;

    BOOL bResult = xWriteFile(
        hFile,                          // handle to file
        pBuffer,                        // data buffer
        dwNumberOfBytesToWrite,         // number of bytes to read
        pdwNumberOfBytesWritten,        // number of bytes read
        pOverlapped);                   // overlapped buffer

    if (!bResult)
    {
        DWORD dwResult = xWaitForMultipleObjects(
            2,                              // There are two to wait on
            hWait,                          // Our two event handles
            FALSE,                          // Only one event need to be pinged
            INFINITE);                      // Wait for ever

        switch (dwResult)
        {
        case (WAIT_OBJECT_0):
            CancelIo(
                hFile);
            throw CAbortExcept();
            break;
        case (WAIT_OBJECT_0 + 1):
            xGetOverlappedResult(
                hFile,
                pOverlapped,
                pdwNumberOfBytesWritten,
                TRUE);
            break;
        }
    }
}



void xGetCommState(
    HANDLE hFile,                       // handle to communications device
    LPDCB pDCB)                         // device-control block
{
    BOOL bResult = ::GetCommState(
        hFile,
        pDCB);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetCommState"));
    }
}



void xSetCommState(
    HANDLE hFile,                       // handle to communications device
    LPDCB pDCB)                         // device-control block
{
    BOOL bResult = ::SetCommState(
        hFile,
        pDCB);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetCommState"));
    }
}



void xGetCommTimeouts(
    HANDLE hFile,                       // handle to comm device
    LPCOMMTIMEOUTS pCommTimeouts)       // time-out values
{
    BOOL bResult = ::GetCommTimeouts(
        hFile,
        pCommTimeouts);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetCommTimeouts"));
    }
}



void xSetCommTimeouts(
    HANDLE hFile,                       // handle to comm device
    LPCOMMTIMEOUTS pCommTimeouts)       // time-out values
{
    BOOL bResult = ::SetCommTimeouts(
        hFile,
        pCommTimeouts);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetCommTimeouts"));
    }
}


void xSetCommMask(
    HANDLE hFile,                       // handle to communications device
    DWORD dwEvtMask)                    // mask that identifies enabled events
{
    BOOL bResult = ::SetCommMask(
        hFile,
        dwEvtMask);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetCommMask"));
    }
}



void xGetCommMask(
    HANDLE hFile,                       // handle to communications device
    PDWORD pdwEvtMask)                  // mask that identifies enabled events
{
    BOOL bResult = ::GetCommMask(
        hFile,
        pdwEvtMask);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetCommMask"));
    }
}



BOOL xWaitCommEvent(
    HANDLE hFile,                       // handle to comm device
    PDWORD pdwEvtMask,                  // event type
    LPOVERLAPPED pOverlapped)           // overlapped structure
{
    BOOL bResult = ::WaitCommEvent(
        hFile,
        pdwEvtMask,
        pOverlapped);

    if (!bResult && (GetLastError()!=ERROR_IO_PENDING))
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WaitCommEvent"));
    }

    return bResult;
}



void xWaitCommEventWithAbort(
    HANDLE hFile,                       // handle to comm device
    PDWORD pdwEvtMask,                  // event type
    LPOVERLAPPED pOverlapped,           // overlapped structure
    HANDLE hAbort)                      // Manual reset abort event
{
    HANDLE hWait[2];
    hWait[0] = hAbort;
    hWait[1] = pOverlapped->hEvent;
    DWORD dwBytesRead;

    BOOL bResult = xWaitCommEvent(
        hFile,
        pdwEvtMask,
        pOverlapped);

    if (!bResult)
    {
        DWORD dwResult = xWaitForMultipleObjects(
            2,                              // There are two to wait on
            hWait,                          // Our two event handles
            FALSE,                          // Only one event need to be pinged
            INFINITE);                      // Wait for ever

        switch (dwResult)
        {
        case (WAIT_OBJECT_0):
            CancelIo(
                hFile);
            throw CAbortExcept();
            break;
        case (WAIT_OBJECT_0 + 1):
            xGetOverlappedResult(
                hFile,
                pOverlapped,
                &dwBytesRead,
                TRUE);
            break;
        }
    }
}



void xEscapeCommFunction(
    HANDLE hFile,                       // handle to communications device
    DWORD dwFunc)                       // extended function to perform
{
    BOOL bResult = ::EscapeCommFunction(
        hFile,
        dwFunc);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("EscapeCommFunction"));
    }
}



void xClearCommBreak(
    HANDLE hFile)                       // handle to communications device
{
    BOOL bResult = ::ClearCommBreak(
        hFile);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ClearCommBreak"));
    }
}



void xClearCommError(
    HANDLE hFile,                       // handle to communications device
    PDWORD pdwErrors,                   // error codes
    LPCOMSTAT pStat)                    // communications status
{
    BOOL bResult = ::ClearCommError(
        hFile,
        pdwErrors,
        pStat);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ClearCommError"));
    }
}



void xBuildCommDCB(
    PCTSTR pcszDef,                      // device-control string
    LPDCB  lpDCB)                       // device-control block
{
    BOOL bResult = ::BuildCommDCB(
        pcszDef,
        lpDCB);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("BuildCommDCB"));
    }
}


void xTransmitCommChar(
  HANDLE hFile,
  char cChar)
{
    BOOL bResult = ::TransmitCommChar(
        hFile,
        cChar);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("TransmitCommChar"));
    }
}


HANDLE xCreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD
    DWORD dwStackSize,                        // initial stack size
    LPTHREAD_START_ROUTINE lpStartAddress,    // thread function
    LPVOID lpParameter,                       // thread argument
    DWORD dwCreationFlags,                    // creation option
    LPDWORD lpThreadId)                       // thread identifier
{
    HANDLE hResult = ::CreateThread(
        lpThreadAttributes,             // SD
        dwStackSize,                    // initial stack size
        lpStartAddress,                 // thread function
        lpParameter,                    // thread argument
        dwCreationFlags,                // creation option
        lpThreadId);                    // thread identifier

    if (NULL==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateThread"));
    }

    return hResult;
}


void xTerminateThread(
    HANDLE hThread,                     // handle to thread
    DWORD dwExitCode)                   // exit code
{
    BOOL bResult = ::TerminateThread(
        hThread,
        dwExitCode);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("TerminateThread"));
    }
}


UINT_PTR xSetTimer(
  HWND hWnd,                            // handle to window
  UINT_PTR nIDEvent,                    // timer identifier
  UINT uElapse,                         // time-out value
  TIMERPROC lpTimerFunc)                // timer procedure
{
    UINT_PTR pResult = ::SetTimer(
        hWnd,
        nIDEvent,
        uElapse,
        lpTimerFunc);

    if (0 == pResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetTimer"));
    }

    return pResult;
}



void xKillTimer(
  HWND hWnd,                            // handle to window
  UINT_PTR uIDEvent)                    // timer identifier
{
    BOOL bResult = ::KillTimer(
        hWnd,
        uIDEvent);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("KillTimer"));
    }
}


void xFillConsoleOutputAttribute(
  HANDLE hConsoleOutput,
  WORD wAttribute,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfAttrsWritten)
{
    BOOL bResult = ::FillConsoleOutputAttribute(
        hConsoleOutput,
        wAttribute,
        nLength,
        dwWriteCoord,
        lpNumberOfAttrsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FillConsoleOutputAttribute"));
    }
}


void xFillConsoleOutputCharacter(
  HANDLE hConsoleOutput,
  TCHAR cCharacter,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfCharsWritten)
{
    BOOL bResult = ::FillConsoleOutputCharacter(
        hConsoleOutput,
        cCharacter,
        nLength,
        dwWriteCoord,
        lpNumberOfCharsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FillConsoleOutputCharacter"));
    }
}


void xGetConsoleScreenBufferInfo(
  HANDLE hConsoleOutput,
  PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
{
    BOOL bResult = ::GetConsoleScreenBufferInfo(
        hConsoleOutput,
        lpConsoleScreenBufferInfo);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetConsoleScreenBufferInfo"));
    }
}


DWORD xGetConsoleTitle(
  LPTSTR lpConsoleTitle,
  DWORD nSize)
{
    DWORD dwResult = ::GetConsoleTitle(
        lpConsoleTitle,
        nSize);

    if (!dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetConsoleTitle"));
    }

    return dwResult;
}


COORD xGetLargestConsoleWindowSize(
  HANDLE hConsoleOutput)
{
    COORD Result = ::GetLargestConsoleWindowSize(
        hConsoleOutput);

    if (0==Result.X && 0==Result.Y)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetLargestConsoleWindowSize"));
    }

    return Result;
}


HANDLE xGetStdHandle(
  DWORD nStdHandle)
{
    HANDLE hResult = ::GetStdHandle(
            nStdHandle);

    if (INVALID_HANDLE_VALUE==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetStdHandle"));
    }

    return hResult;
}


void xReadConsoleOutputAttribute(
  HANDLE hConsoleOutput,
  LPWORD lpAttribute,
  DWORD nLength,
  COORD dwReadCoord,
  LPDWORD lpNumberOfAttrsRead)
{
    BOOL bResult = ::ReadConsoleOutputAttribute(
        hConsoleOutput,
        lpAttribute,
        nLength,
        dwReadCoord,
        lpNumberOfAttrsRead);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReadConsoleOutputAttribute"));
    }
}


void xReadConsoleOutputCharacter(
  HANDLE hConsoleOutput,
  LPTSTR lpCharacter,
  DWORD nLength,
  COORD dwReadCoord,
  LPDWORD lpNumberOfCharsRead)
{
    BOOL bResult = ::ReadConsoleOutputCharacter(
        hConsoleOutput,
        lpCharacter,
        nLength,
        dwReadCoord,
        lpNumberOfCharsRead);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReadConsoleOutputCharacter"));
    }
}

void xSetConsoleScreenBufferSize(
  HANDLE hConsoleOutput,
  COORD dwSize)
{
    BOOL bResult = ::SetConsoleScreenBufferSize(
        hConsoleOutput,
        dwSize);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleScreenBufferSize"));
    }
}


void xSetConsoleTextAttribute(
  HANDLE hConsoleOutput,
  WORD wAttributes)
{
    BOOL bResult = ::SetConsoleTextAttribute(
        hConsoleOutput,
        wAttributes);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleTextAttribute"));
    }
}


void xSetConsoleTitle(
  LPCTSTR lpConsoleTitle)
{
    BOOL bResult = ::SetConsoleTitle(
        lpConsoleTitle);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleTitle"));
    }
}


void xSetConsoleWindowInfo(
  HANDLE hConsoleOutput,
  BOOL bAbsolute,
  CONST SMALL_RECT *lpConsoleWindow)
{
    BOOL bResult = ::SetConsoleWindowInfo(
        hConsoleOutput,
        bAbsolute,
        lpConsoleWindow);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetConsoleWindowInfo"));
    }
}


void xWriteConsole(
  HANDLE hConsoleOutput,
  CONST VOID *lpBuffer,
  DWORD nNumberOfCharsToWrite,
  LPDWORD lpNumberOfCharsWritten,
  LPVOID lpReserved)
{
    BOOL bResult = ::WriteConsole(
        hConsoleOutput,
        lpBuffer,
        nNumberOfCharsToWrite,
        lpNumberOfCharsWritten,
        lpReserved);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteConsole"));
    }
}


void xWriteConsoleOutputAttribute(
  HANDLE hConsoleOutput,
  CONST WORD *lpAttribute,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfAttrsWritten)
{
    BOOL bResult = ::WriteConsoleOutputAttribute(
        hConsoleOutput,
        lpAttribute,
        nLength,
        dwWriteCoord,
        lpNumberOfAttrsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteConsoleOutputAttribute"));
    }
}

void xWriteConsoleOutputCharacter(
  HANDLE hConsoleOutput,
  LPCTSTR lpCharacter,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfCharsWritten)
{
    BOOL bResult = ::WriteConsoleOutputCharacter(
        hConsoleOutput,
        lpCharacter,
        nLength,
        dwWriteCoord,
        lpNumberOfCharsWritten);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WriteConsoleOutputCharacter"));
    }
}


HANDLE xCreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCTSTR lpName)                          // object name
{
    HANDLE hResult = ::CreateEvent(
        lpEventAttributes,
        bManualReset,
        bInitialState,
        lpName);

    if (INVALID_HANDLE_VALUE==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateEvent"));
    }

    return hResult;
}


void xSetEvent(
    HANDLE hEvent)
{
    BOOL bResult = ::SetEvent(
        hEvent);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("SetEvent"));
    }
}



void xResetEvent(
    HANDLE hEvent)
{
    BOOL bResult = ::ResetEvent(
        hEvent);

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ResetEvent"));
    }
}



DWORD xWaitForMultipleObjects(
    DWORD nCount,             // number of handles in array
    CONST HANDLE *lpHandles,  // object-handle array
    BOOL fWaitAll,            // wait option
    DWORD dwMilliseconds)     // time-out interval
{
    DWORD dwResult = ::WaitForMultipleObjects(
        nCount,
        lpHandles,
        fWaitAll,
        dwMilliseconds);

    if (WAIT_FAILED==dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WaitForMultipleObjects"));
    }

    return dwResult;
}



DWORD xWaitForSingleObject(
  HANDLE hHandle,           // handle to object
  DWORD dwMilliseconds)     // time-out interval
{
    DWORD dwResult = ::WaitForSingleObject(
        hHandle,            // handle to object
        dwMilliseconds);    // time-out interval

    if (WAIT_FAILED==dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WaitForSingleObject"));
    }

    return dwResult;
}



PWSTR xMultiByteToWideChar(
    UINT CodePage,            // code page
    DWORD dwFlags,            // performance and mapping flags
    LPCSTR lpMultiByteStr)    // wide-character string
{
    int dResult = ::MultiByteToWideChar(
        CodePage,
        dwFlags,
        lpMultiByteStr,
        -1,
        NULL,
        0);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("MultiByteToWideChar"));
    }

    auto_ptr<WCHAR> pszOutput(
        new WCHAR[dResult]);

    dResult = ::MultiByteToWideChar(
        CodePage,
        dwFlags,
        lpMultiByteStr,
        -1,
        pszOutput.get(),
        dResult);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("MultiByteToWideChar"));
    }

    return pszOutput.release();
}


PSTR xWideCharToMultiByte(
    UINT CodePage,            // code page
    DWORD dwFlags,            // performance and mapping flags
    LPCWSTR lpWideCharStr)    // wide-character string
{
    int dResult = ::WideCharToMultiByte(
        CodePage,
        dwFlags,
        lpWideCharStr,
        -1,
        NULL,
        0,
        NULL,
        NULL);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WideCharToMultiByte"));
    }

    auto_ptr<CHAR> pszOutput(
        new CHAR[dResult]);

    dResult = ::WideCharToMultiByte(
        CodePage,
        dwFlags,
        lpWideCharStr,
        -1,
        pszOutput.get(),
        dResult,
        NULL,
        NULL);

    if (dResult==0)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("WideCharToMultiByte"));
    }

    return pszOutput.release();
}


PWSTR xMakeWideChar(
    PTSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<WCHAR> pszOutput(
        new WCHAR[wcslen(pcszInput)+1]);
    wcscpy(
        pszOutput.get(),
        pcszInput);
    #else
    auto_ptr<WCHAR> pszOutput(
        xMultiByteToWideChar(
            CP_ACP,
            0,
            pcszInput));
    #endif
    return pszOutput.release();
}


PSTR xMakeMultiByte(
    PTSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<CHAR> pszOutput(
        xWideCharToMultiByte(
            CP_ACP,
            0,
            pcszInput));
    #else
    auto_ptr<CHAR> pszOuptut(
        new CHAR[strlen(pcszInput)+1]);
    strcpy(
        pszOutput.get(),
        pcszInput);
    #endif
    return pszOutput.release();
}


PTSTR xMakeDefaultChar(
    PWSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<WCHAR> pszOutput(
        new WCHAR[wcslen(pcszInput)+1]);
    wcscpy(
        pszOutput.get(),
        pcszInput);
    #else
    auto_ptr<WCHAR> pszOuptut(
        xWideCharToMultiByte(
            CP_ACP,
            0,
            pcszInput));
    #endif
    return pszOutput.release();
}


PTSTR xMakeDefaultChar(
    PSTR pcszInput)
{
    #ifdef _UNICODE
    auto_ptr<WCHAR> pszOutput(
        xMultiByteToWideChar(
            CP_ACP,
            0,
            pcszInput));
    #else
    auto_ptr<CHAR> pszOuptut(
        new CHAR[strlen(pcszInput)+1]);
    strcpy(
        pszOutput.get(),
        pcszInput);
    #endif
    return pszOutput.release();
}


DWORD xGetModuleFileName(
    HMODULE hModule,    // handle to module
    LPTSTR lpFilename,  // file name of module
    DWORD nSize)        // size of buffer
{
    DWORD dwResult = ::GetModuleFileName(
        hModule,
        lpFilename,
        nSize);

    if (0==dwResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetModuleFileName"));
    }

    if (dwResult == nSize)  // This will happen if
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }
    else
    {
        return dwResult;
    }
}


HANDLE xFindFirstFile(
    LPCTSTR lpFileName,               // file name
    LPWIN32_FIND_DATA lpFindFileData) // data buffer
{
    HANDLE hResult = ::FindFirstFile(
        lpFileName,
        lpFindFileData);

    if (INVALID_HANDLE_VALUE==hResult && GetLastError()!=ERROR_NO_MORE_FILES)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FindFirstFile"));
    }

    return hResult;
}

BOOL xFindNextFile(
    HANDLE hFindFile,                 // search handle
    LPWIN32_FIND_DATA lpFindFileData) // data buffer
{
    BOOL fResult = ::FindNextFile(
        hFindFile,
        lpFindFileData);

    if (!fResult && GetLastError()!=ERROR_NO_MORE_FILES)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("FindNextFile"));
    }

    return fResult;
}


HMODULE xLoadLibrary(
    LPCTSTR lpFileName)   // file name of module
{
    HMODULE hResult = ::LoadLibrary(
        lpFileName);

    if (NULL==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("LoadLibrary"));
    }

    return hResult;
}


FARPROC xGetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName)
{
    FARPROC pResult = ::GetProcAddress(
        hModule,
        lpProcName);

    if (NULL==pResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("GetProcAddress"));
    }

    return pResult;
}







CFindFile::~CFindFile()
{
    if (m_hFind!=INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
    }
}


BOOL CFindFile::First(PCTSTR pcszFileName)
{
    if (m_hFind!=INVALID_HANDLE_VALUE)
    {
        FindClose(m_hFind);
    }

    m_hFind = xFindFirstFile(
        pcszFileName,
        &m_FindData);

    return (m_hFind!=INVALID_HANDLE_VALUE);
}



BOOL CFindFile::Next()
{
    return xFindNextFile(
        m_hFind,
        &m_FindData);
}


PWIN32_FIND_DATA CFindFile::Found()
{
    return &m_FindData;
}



HANDLE xCreateMutex(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD
  BOOL bInitialOwner,                       // initial owner
  LPCTSTR lpName)                           // object name
{
    HANDLE hResult = ::CreateMutex(
        lpMutexAttributes,                  // SD
        bInitialOwner,                      // initial owner
        lpName);                            // object name

    if (NULL==hResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("CreateMutex"));
    }

    return hResult;
}


void xReleaseMutex(
    HANDLE hMutex)
{
    BOOL bResult = ::ReleaseMutex(
        hMutex);                            // mutex object handle

    if (!bResult)
    {
        throw CWin32ApiExcept(
            GetLastError(),
            _T("ReleaseMutex"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\admin.c ===
/*--------------------------------------------------------------------------
| admin.c - Ethernet common admin-packet handling.  Includes common
  admin. packet handling code.

6-17-97 - start using index field assigned to box to id rx-messages.

 Copyright 1996,97 Comtrol Corporation.  All rights reserved.  Proprietary
 information not permitted for development or use with non-Comtrol products.
|--------------------------------------------------------------------------*/
#include "precomp.h"

static int eth_command_reset(BYTE *rx, BYTE *pkt_in, int size);
static int eth_loop_back(BYTE *pkt_in, int size);
static int eth_id_reply(BYTE *rx, BYTE *pkt_in);
static int eth_id_req(BYTE *mac_addr);

#define TraceStr(s) GTrace(D_Nic, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
static char *sz_modid = {"Admin"};
static char *sz_modid_err = {"Error,Admin"};

#define MAX_SEND_DATA_SIZE 220
#define DEV_OK              0
#define DEV_PORT_TIMEOUT    1
#define DEV_NO_REPLY        2
#define DEV_SHORT_REPLY     3
#define DEV_BAD_RHEADSHORT  4
#define DEV_BAD_RHEAD       5
#define DEV_BAD_CHKSUM      6
#define DEV_OVERRUN         7
#define DEV_RESPOND_ERROR   100

/*----------------------------------------------------------------------------
| admin_send_query_id -
|----------------------------------------------------------------------------*/
int admin_send_query_id(Nic *nic, BYTE *dest_addr, int set_us_as_master,
                        BYTE assigned_index)
{
  BYTE pkt[60];
  int stat;
  TraceStr("SndQuery");

  memset(pkt, 0, 60);

  if (set_us_as_master)
       pkt[26] = 2;  // take over device(makes it save our mac-addr)
                     // 2H = Observe Owner LockOut
  else pkt[26] = 1;  // set 1 bit so device does not save off mac-addr
                     // 1H = Passive Query

  pkt[15] = assigned_index;  // assign the box a index value which we
    // use to "id" the box messages.

  // server query for box-id
  if (dest_addr == NULL)
       stat = admin_send(nic, pkt, 26, ADMIN_ID_QUERY, broadcast_addr);
  else stat = admin_send(nic, pkt, 26, ADMIN_ID_QUERY, dest_addr);
  if (stat != 0)
    TraceErr("txer5A!");

  return stat;
}

/*----------------------------------------------------------------------------
| admin_send_reset -
|----------------------------------------------------------------------------*/
int admin_send_reset(Nic *nic, BYTE *dest_addr)
{
  BYTE pkt[60];
  int stat;
  TraceStr("SndReset");
  memset(pkt, 0, 60);

  *((WORD *)&pkt[20]) = 0x5555;
  if (dest_addr == NULL)
       stat = admin_send(nic, pkt, 26, ADMIN_ID_RESET, broadcast_addr);
  else stat = admin_send(nic, pkt, 26, ADMIN_ID_RESET, dest_addr);
  if (stat != 0)
    TraceErr("txer4A!");

  return stat;
}

/*----------------------------------------------------------------------------
| admin_send - Used to send common admin packets, takes care of
   filling in the header.
|----------------------------------------------------------------------------*/
int admin_send(Nic *nic, BYTE *buf, int len, int admin_type, BYTE *mac_dest)
{
 int stat;

  TraceStr("SndPkt");
  memcpy(&buf[0], mac_dest, 6);
  memcpy(&buf[6], nic->address, 6);  // our addr

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&buf[12]) = 0xfe11;

  buf[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  buf[15] = 0;     // conc. index field
  buf[16] = 1;     // admin
  *((WORD *)&buf[17]) = len;
  buf[19] = admin_type;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  if (admin_type == ADMIN_ID_QUERY)
    memcpy(&buf[20], nic->address, 6);  // our addr

  if (len < 60)
    len = 60;
  stat = nic_send_pkt(nic, buf, len);
  if (stat)
  {
    TraceErr("txer3!");
  }
  return stat;
}

/*---------------------------------------------------------------------------
| ioctl_device - send admin, boot loader packets to the box to
   upload code, do misc ioctl commands, etc.
|---------------------------------------------------------------------------*/
int ioctl_device(int cmd,
                 BYTE *buf,
                 BYTE *pkt,
                 ULONG offset,  // or ioctl-subfunction if cmd=ioctl
                 int size)
{
 int stat;
 int pkt_size;
  TraceStr("Ioctl");

 stat = 1;  // err
 switch(cmd)
 {
   case IOCTL_COMMAND:
     stat = eth_device_data(cmd, offset, size, buf, pkt, &pkt_size);
   break;
   case DOWNLOAD_COMMAND:
     stat = eth_device_data(cmd, offset, size, buf, pkt, &pkt_size);
   break;
   case UPLOAD_COMMAND:
     stat = eth_device_data(cmd, offset, size, buf, pkt, &pkt_size);
   break;
 }
   return stat;
}

/*---------------------------------------------------------------------------
| eth_device_data - talks with the device, either sets device data or gets
|  device data.  Returns 0 if communications ok.
|---------------------------------------------------------------------------*/
int eth_device_data(int message_type,
                unsigned long offset,
                int num_bytes,
                unsigned char *data,
                unsigned char *pkt,
                int *pkt_size)
{
  int i;
  unsigned char chksum, command, dat_in;
  WORD packet_length;
  int pkt_i;
  unsigned char *bf;


  int in_size = num_bytes;




  command = message_type;
  switch (message_type)
  {
    case IOCTL_COMMAND :
      packet_length = in_size + 6; // num bytes after len, no chksum included
    break;

    case UPLOAD_COMMAND :
      //  send: 0=header, 1=addr, 2=len, 3,4=cmd, 5,6,7,8=offset, data, chksum
      // reply: 0=header, 1=addr, 2=len, 3,4=cmd, 5=chksum
      packet_length = in_size + 6;
    break;

    case DOWNLOAD_COMMAND :
      // 0=header, 1=addr, 2=len, 3,4=cmd, 5,6,7,8=offset, 9=len_ret
      // reply: 0=header, 1=addr, 2=len, 3,4=cmd, data, chksum
      packet_length = 8;
    break;
  }

  //-------- flush any ethernet packets in rx buffer
  //eth_flush();

  pkt_i=0;  // start data area in eth. packet
  pkt[pkt_i++] = '~';

  pkt[pkt_i] = (unsigned char) packet_length;
  chksum = pkt[pkt_i++];

  pkt[pkt_i] = (unsigned char) (packet_length >> 8);
  chksum += pkt[pkt_i++];

  chksum += command;
  pkt[pkt_i++] = command;
  pkt[pkt_i++] = 0;   /* hi-byte, command */

  switch (message_type)
  {
    case IOCTL_COMMAND :
      bf = (BYTE *) &offset;
      chksum += bf[0]; pkt[pkt_i++] = bf[0];
      chksum += bf[1]; pkt[pkt_i++] = bf[1];
      chksum += bf[2]; pkt[pkt_i++] = bf[2];
      chksum += bf[3]; pkt[pkt_i++] = bf[3];

      //printf("ioctl-id:%d, size\n", bf[3], in_size);
      for (i=0; i<in_size; i++)
      {
        dat_in = data[i];
        chksum += dat_in;
        pkt[pkt_i++] = dat_in;
      }
    break;

    case UPLOAD_COMMAND :
      bf = (BYTE *) &offset;
      chksum += bf[0]; pkt[pkt_i++] = bf[0];
      chksum += bf[1]; pkt[pkt_i++] = bf[1];
      chksum += bf[2]; pkt[pkt_i++] = bf[2];
      chksum += bf[3]; pkt[pkt_i++] = bf[3];

      for (i=0; i<in_size; i++)
      {
        dat_in = data[i];
        chksum += dat_in;
        pkt[pkt_i++] = dat_in;
      }
    break;

    case DOWNLOAD_COMMAND :
      bf = (BYTE *) &offset;
      chksum += bf[0]; pkt[pkt_i++] = bf[0];
      chksum += bf[1]; pkt[pkt_i++] = bf[1];
      chksum += bf[2]; pkt[pkt_i++] = bf[2];
      chksum += bf[3]; pkt[pkt_i++] = bf[3];

      chksum += (unsigned char) in_size;
      pkt[pkt_i++] = (unsigned char) in_size;

      chksum += (unsigned char) (in_size >> 8);
      pkt[pkt_i++] = (unsigned char) (in_size >> 8);
    break;

    default:
    break;
  }

  pkt[pkt_i++] = ~chksum;

  *pkt_size = pkt_i;

  return 0;
}

/*---------------------------------------------------------------------------
| eth_device_reply - Validate the ACK reply pkt due to a sent
   boot packet.  Ack reply may include data if an IOCTL or
   DOWNLOAD type.  We use UPLOAD command for code uploads.
|    Returns 0 if communications ok.
|---------------------------------------------------------------------------*/
int eth_device_reply(int message_type,
                unsigned long offset,
                int *num_bytes,
                unsigned char *data,
                unsigned char *pkt)
{
  int i;
  unsigned char chksum;
  unsigned char *bf;
  unsigned char uc;
  WORD ret_size;
  BYTE *bptr;

  bptr = pkt;

  if (bptr[0] != '|')  // good reply header
  {
    TraceErr("Err3");
    return DEV_BAD_RHEAD;
  }

  chksum = bptr[1];
  ret_size = bptr[1];  // get len

  chksum += bptr[2];
  ret_size += ((WORD)(bptr[2]) << 8);  // get len
  if (ret_size > 1600)  // limit
    ret_size = 0;

  uc = bptr[3];  // get command return word
  chksum += uc;
  uc = bptr[4];
  chksum += uc;

  i = 0;
  if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
  {
    // o_printf("ret size:%d\n", ret_size-2);
    if (data == NULL)
      return 20;  // err out

    bf = data;
    for (i=0; i<ret_size-2; i++)
    {
      bf[i] = bptr[5+i];
      chksum += bf[i];
    }
    i = ret_size-2;
  }

  chksum += bptr[5+i];
  if (chksum != 0xff)
  {
    return DEV_BAD_CHKSUM;  /* bad chksum */
  }

  if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
    *num_bytes = ret_size-2;
  else
    *num_bytes = 0;

  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\asic.h ===
/*-------------------------------------------------------------------
  asic.h - Whole slew of literals for talking to RocketPort hardware.
Copyright 1993-96 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/

#define MCODE_SIZE 256          /* maximum microcode array size */
#define MCODE_ADDR 0x900        /* microcode base address within char */

/* Offsets within MCode1Reg[].  Defines ending in _OUT give the MCode1Reg[]
   index used to obtain the DWORD value written to the AIOP Index Register.
   This DWORD contains the SRAM address in the low word, and the SRAM data
   in the high word.  Defines ending in _DATA given the MCode1Reg[]
   index for one of the two bytes of SRAM data withing a DWORD. These
   defines are used to locate various character values that are used by
   the Rx processor. */
#define RXMASK_DATA    0x13     /* Rx Mask FF 913 */
#define RXMASK_OUT     0x10
#define RXCMPVAL0_DATA 0x17     /* Rx Cmp #0 00 915 */
#define RXCMPVAL0_OUT  0x14
#define RXCMPVAL1_DATA 0x1b     /* Rx Cmp #1 7B 917 */
#define RXCMPVAL1_OUT  0x18  
#define RXCMPVAL2_DATA 0x1f     /* Rx Cmp #2 7D 919 */
#define RXCMPVAL2_OUT  0x1c  
#define RXREPL1_DATA   0x27     /* Rx Repl #1 7A 91d */
#define RXREPL1_OUT    0x24
#define RXREPL2_DATA   0x2f     /* Rx Repl #2 7c 921 */
#define RXREPL2_OUT    0x2c  
#define TXXOFFVAL_DATA 0x07     /* Tx XOFF 13 909 */ 
#define TXXOFFVAL_OUT  0x04  
#define TXXONVAL_DATA  0x0b     /* Tx XON 11 90b  */
#define TXXONVAL_OUT   0x08  


/* More offsets with MCode1Reg[].  These are used to enable/disable Rx
   processor features.  Defines ending in _DATA and _OUT are used as
   described above.  The actual values to be saved at the _DATA
   indices end in _EN (to enable the feature) or _DIS (to disable the
   feature). */

/* Ignore # 0 */
#define IGNORE0_DATA  0x16  /* ce/82 914 */
#define IGNORE0_OUT   0x14  
#define IGNORE0_EN    0xce
#define IGNORE0_DIS   0x82

/* Ignore / Replace Byte #1 */
#define IGREP1_DATA  0x26  /* 0a/40/86 91c */
#define IGREP1_OUT   0x24
#define IGNORE1_EN   0x0a
#define REPLACE1_EN  0x40
#define IG_REP1_DIS  0x86

/* Ignore / Replace Byte #2 */
#define IGREP2_DATA  0x2e  /* 0a/40/82 920 */
#define IGREP2_OUT   0x2c
#define IGNORE2_EN   0x0a
#define REPLACE2_EN  0x40
#define IG_REP2_DIS  0x82

/* Interrupt Compare #1 */
#define INTCMP1_DATA 0x23   /* 11/81 91b */
#define INTCMP1_OUT  0x20
#define INTCMP1_EN   0x11
#define INTCMP1_DIS  0x81

/* Interrupt Compare #2 */
#define INTCMP2_DATA 0x2b  /* 10/81 91f */
#define INTCMP2_OUT  0x28
#define INTCMP2_EN   0x10
#define INTCMP2_DIS  0x81

/* Receive Compare #1 */
#define RXCMP1_DATA  0x1a  /* C4/82 916 */
#define RXCMP1_OUT   0x18
#define RXCMP1_EN    0xc4
#define RXCMP1_DIS   0x82

/* Receive Compare #2 */
#define RXCMP2_DATA  0x1e  /* C6/8a 918 */
#define RXCMP2_OUT   0x1c
#define RXCMP2_EN    0xc6
#define RXCMP2_DIS   0x8a

/* Receive FIFO */
#define RXFIFO_DATA  0x32  /* 08/0a 922 */
#define RXFIFO_OUT   0x30
#define RXFIFO_EN    0x08 
#define RXFIFO_DIS   0x0a

/* Transmit S/W Flow Cont */
#define TXSWFC_DATA  0x06  /* C5/8A 908 */
#define TXSWFC_OUT   0x04
#define TXSWFC_EN    0xc5
#define TXSWFC_DIS   0x8a

/* XANY Flow Control */
#define IXANY_DATA   0x0e  /* 21/86 921 */
#define IXANY_OUT    0x0c
#define IXANY_EN     0x21
#define IXANY_DIS    0x86


/************************************************************************
 End of Microcode definitions.
************************************************************************/

/************************************************************************
 Global Register Offsets - Direct Access - Fixed values
************************************************************************/

#define _CMD_REG   0x38   /* Command Register            8    Write */
#define _INT_CHAN  0x39   /* Interrupt Channel Register  8    Read */
#define _INT_MASK  0x3A   /* Interrupt Mask Register     8    Read / Write */
#define _UNUSED    0x3B   /* Unused                      8 */
#define _INDX_ADDR 0x3C   /* Index Register Address      16   Write */
#define _INDX_DATA 0x3E   /* Index Register Data         8/16 Read / Write */

/************************************************************************
 Channel Register Offsets for 1st channel in AIOP - Direct Access
************************************************************************/
#define _TD0       0x00  /* Transmit Data               16   Write */
#define _RD0       0x00  /* Receive Data                16   Read */
#define _CHN_STAT0 0x20  /* Channel Status              8/16 Read / Write */
#define _FIFO_CNT0 0x10  /* Transmit/Receive FIFO Count 16   Read */
#define _INT_ID0   0x30  /* Interrupt Identification    8    Read */

/************************************************************************
 Tx Control Register Offsets - Indexed - External - Fixed
************************************************************************/
#define _TX_ENBLS  0x980    /* Tx Processor Enables Register 8 Read / Write */
#define _TXCMP1    0x988    /* Transmit Compare Value #1     8 Read / Write */
#define _TXCMP2    0x989    /* Transmit Compare Value #2     8 Read / Write */
#define _TXREP1B1  0x98A    /* Tx Replace Value #1 - Byte 1  8 Read / Write */
#define _TXREP1B2  0x98B    /* Tx Replace Value #1 - Byte 2  8 Read / Write */
#define _TXREP2    0x98C    /* Transmit Replace Value #2     8 Read / Write */

/************************************************************************
Memory Controller Register Offsets - Indexed - External - Fixed
************************************************************************/
#define _RX_FIFO    0x000    /* Rx FIFO */
#define _TX_FIFO    0x800    /* Tx FIFO */
#define _RXF_OUTP   0x990    /* Rx FIFO OUT pointer        16 Read / Write */
#define _RXF_INP    0x992    /* Rx FIFO IN pointer         16 Read / Write */
#define _TXF_OUTP   0x994    /* Tx FIFO OUT pointer        8  Read / Write */
#define _TXF_INP    0x995    /* Tx FIFO IN pointer         8  Read / Write */
#define _TXP_CNT    0x996    /* Tx Priority Count          8  Read / Write */
#define _TXP_PNTR   0x997    /* Tx Priority Pointer        8  Read / Write */

#define PRI_PEND    0x80     /* Priority data pending (bit7, Tx pri cnt) */
#define TXFIFO_SIZE 255      /* size of Tx FIFO */
#define RXFIFO_SIZE 1023     /* size of Rx FIFO */

/************************************************************************
Tx Priority Buffer - Indexed - External - Fixed
************************************************************************/
#define _TXP_BUF    0x9C0    /* Tx Priority Buffer  32  Bytes   Read / Write */
#define TXP_SIZE    0x20     /* 32 bytes */

/************************************************************************
Channel Register Offsets - Indexed - Internal - Fixed
************************************************************************/

#define _TX_CTRL    0xFF0    /* Transmit Control               16  Write */
#define _RX_CTRL    0xFF2    /* Receive Control                 8  Write */
#define _BAUD       0xFF4    /* Baud Rate                      16  Write */
#define _CLK_PRE    0xFF6    /* Clock Prescaler                 8  Write */

/************************************************************************
  Baud rate divisors using mod 9 clock prescaler and 36.864 clock
  clock prescaler, MUDBAC prescale is in upper nibble (=0x10)
  AIOP prescale is in lower nibble (=0x9)
************************************************************************/
#define DEF_ROCKETPORT_PRESCALER 0x14 /* div 5 prescale, max 460800 baud(NO 50baud!) */
#define DEF_ROCKETPORT_CLOCKRATE 36864000

#define DEF_RPLUS_PRESCALER  0x12 /* div by 3 baud prescale, 921600, crystal:44.2368Mhz */
#define DEF_RPLUS_CLOCKRATE 44236800

//#define BRD9600           47
//#define RCKT_CLK_RATE   (2304000L / ((CLOCK_PRESC & 0xf)+1))
//#define BRD9600           (((RCKT_CLK_RATE + (9600 / 2)) / 9600) - 1)
//#define BRD57600          (((RCKT_CLK_RATE + (57600 / 2)) / 57600) - 1)
//#define BRD115200         (((RCKT_CLK_RATE + (115200 / 2)) / 115200) - 1)


/************************************************************************
        Channel register defines
************************************************************************/
/* channel data register stat mode status byte (high byte of word read) */
#define STMBREAK   0x08        /* BREAK */
#define STMFRAME   0x04        /* framing error */
#define STMRCVROVR 0x02        /* receiver over run error */
#define STMPARITY  0x01        /* parity error */
#define STMERROR   (STMBREAK | STMFRAME | STMPARITY)
#define STMBREAKH   0x800      /* BREAK */
#define STMFRAMEH   0x400      /* framing error */
#define STMRCVROVRH 0x200      /* receiver over run error */
#define STMPARITYH  0x100      /* parity error */
#define STMERRORH   (STMBREAKH | STMFRAMEH | STMPARITYH)
/* channel status register low byte */
#define CTS_ACT   0x20        /* CTS input asserted */
#define DSR_ACT   0x10        /* DSR input asserted */
#define CD_ACT    0x08        /* CD input asserted */
#define TXFIFOMT  0x04        /* Tx FIFO is empty */
#define TXSHRMT   0x02        /* Tx shift register is empty */
#define RDA       0x01        /* Rx data available */
#define DRAINED (TXFIFOMT | TXSHRMT)  /* indicates Tx is drained */

/* channel status register high byte */
#define STATMODE  0x8000      /* status mode enable bit */
#define RXFOVERFL 0x2000      /* receive FIFO overflow */
#define RX2MATCH  0x1000      /* receive compare byte 2 match */
#define RX1MATCH  0x0800      /* receive compare byte 1 match */
#define RXBREAK   0x0400      /* received BREAK */
#define RXFRAME   0x0200      /* received framing error */
#define RXPARITY  0x0100      /* received parity error */
#define STATERROR (RXBREAK | RXFRAME | RXPARITY)
/* transmit control register low byte */
#define CTSFC_EN  0x80        /* CTS flow control enable bit */

/////////////////NEW////////////////////////////
#define DSRFC_EN  0x01        /* DSR flow control enable bit */
////////////////////////////////////////////////////////

#define RTSTOG_EN 0x40        /* RTS toggle enable bit */
#define TXINT_EN  0x10        /* transmit interrupt enable */
#define STOP2     0x08        /* enable 2 stop bits (0 = 1 stop) */
#define PARITY_EN 0x04        /* enable parity (0 = no parity) */
#define EVEN_PAR  0x02        /* even parity (0 = odd parity) */
#define DATA8BIT  0x01        /* 8 bit data (0 = 7 bit data) */
/* transmit control register high byte */
#define SETBREAK  0x10        /* send break condition (must clear) */
#define LOCALLOOP 0x08        /* local loopback set for test */
#define SET_DTR   0x04        /* assert DTR */
#define SET_RTS   0x02        /* assert RTS */
#define TX_ENABLE 0x01        /* enable transmitter */

/* receive control register */
#define RTSFC_EN  0x40        /* RTS flow control enable */
#define RXPROC_EN 0x20        /* receive processor enable */
#define TRIG_NO   0x00        /* Rx FIFO trigger level 0 (no trigger) */
#define TRIG_1    0x08        /* trigger level 1 char */
#define TRIG_1_2  0x10        /* trigger level 1/2 */
#define TRIG_7_8  0x18        /* trigger level 7/8 */
#define TRIG_MASK 0x18        /* trigger level mask */
#define SRCINT_EN 0x04        /* special Rx condition interrupt enable */
#define RXINT_EN  0x02        /* Rx interrupt enable */
#define MCINT_EN  0x01        /* modem change interrupt enable */

/* interrupt ID register */
#define RXF_TRIG  0x20        /* Rx FIFO trigger level interrupt */
#define TXFIFO_MT 0x10        /* Tx FIFO empty interrupt */
#define SRC_INT   0x08        /* special receive condition interrupt */
#define DELTA_CD  0x04        /* CD change interrupt */
#define DELTA_CTS 0x02        /* CTS change interrupt */
#define DELTA_DSR 0x01        /* DSR change interrupt */

/* Tx processor enables register */
#define REP1W2_EN 0x10        /* replace byte 1 with 2 bytes enable */
#define IGN2_EN   0x08        /* ignore byte 2 enable */
#define IGN1_EN   0x04        /* ignore byte 1 enable */
#define COMP2_EN  0x02        /* compare byte 2 enable */
#define COMP1_EN  0x01        /* compare byte 1 enable */

/* AIOP command register */
#define RESET_ALL 0x80        /* reset AIOP (all channels) */
#define TXOVERIDE 0x40        /* Transmit software off override */
#define RESETUART 0x20        /* reset channel's UART */
#define RESTXFCNT 0x10        /* reset channel's Tx FIFO count register */
#define RESRXFCNT 0x08        /* reset channel's Rx FIFO count register */
/* bits 2-0 indicate channel to operate upon */

/************************************************************************
   MUDBAC register defines
************************************************************************/
/* base + 1 */
#define INTSTAT0  0x01        /* AIOP 0 interrupt status */
#define INTSTAT1  0x02        /* AIOP 1 interrupt status */
#define INTSTAT2  0x04        /* AIOP 2 interrupt status */
#define INTSTAT3  0x08        /* AIOP 3 interrupt status */
/* base + 2 */
/* irq selections here tps */
#define INTR_EN   0x08        /* allow interrupts to host */
#define INT_STROB 0x04        /* strobe and clear interrupt line (EOI) */
/* base + 3 */
#define CHAN3_EN  0x08        /* enable AIOP 3 */
#define CHAN2_EN  0x04        /* enable AIOP 2 */
#define CHAN1_EN  0x02        /* enable AIOP 1 */
#define CHAN0_EN  0x01        /* enable AIOP 0 */
#define FREQ_DIS  0x00
#define FREQ_560HZ 0x70
#define FREQ_274HZ 0x60
#define FREQ_137HZ 0x50
#define FREQ_69HZ  0x40
#define FREQ_34HZ  0x30
#define FREQ_17HZ  0x20
#define FREQ_9HZ   0x10
#define PERIODIC_ONLY 0x80    /* only PERIODIC interrupt */

/************************************************************************
   MUDBAC registers re-maped for PCI
************************************************************************/
//#define _CFG_INT_PCI 0x40         /*offset for interupt config register */
#define _PCI_INT_FUNC 0x3A        /*offset for interupt stat register on aiop 0*/
#define INTR_EN_PCI 0x0010          /*Bit 4 of int config reg */
#define PCI_PERIODIC_FREQ     0x0007    // setup periodic
#define PER_ONLY_PCI 0x0008         /*bit 3 of int config reg */
#define PCI_AIOPIC_INT_STATUS 0x0f    // 1bit=Aiop1, 2bit=Aiop2,etc
#define PCI_PER_INT_STATUS    0x10    // interrupt status from board
#define PCI_STROBE 0x2000           /*bit 13 of int aiop reg */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\debuger.c ===
/*----------------------------------------------------------------------------
| debuger.c -
|----------------------------------------------------------------------------*/
#include "precomp.h"

void read_in_queue(char *str);
void reset_box(void);
void reset_port(void);
void reset_modem(void);
void dump_driver(void);
void dump_mem(UCHAR *ptr, ULONG len);
void dump_net(void);
void send_str(char *str);
void dump_ext1(void);
void no_port_message(void);
#ifdef S_VS
void eth_test_pkt(void);
void dump_box(int index);
void dump_nic(int index);
int read_trace_queue(PortMan *pm);
int write_remote_cmd(PortMan *pm, char *cmd);
#endif

#define TraceStr(s) GTrace(D_L10, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
#define TraceC(c)   GMark(c,10)

static char *sz_modid = {"deb"};
static char *sz_modid_err = {"Error,deb"};

// following used to restrict to one pending debug packet to box
static int pending_debug_packet = 0;

/*----------------------------------------------------------------------------
| do_cmd_line - complete line entered, handle command line interpreter.
|----------------------------------------------------------------------------*/
void do_cmd_line(char *line)
{
 char *s = line;
 int i, j, k;
 char cmd[20];  // buffer for command only, not for params
 //char str2[20];
 ULONG dnums[5];
 PSERIAL_DEVICE_EXTENSION ext;

  i = strlen(s);
  if (i==0)
    return;

  if (s[i-1] == 0xd)
  {
    s[i-1] = 0;
    if (i == 0)
      deb_printf("\x0d\x0a:");
  }

  while ((*s == ' ') || (*s == 0xa))
    ++s;
  if (*s == 0)
  {
    deb_printf("\x0d\x0a:");
    return;
  }

  deb_printf(":%s\x0d\x0a", s);  // echo cmd line
  i = 0;
  while ((*s != ' ') && (*s != 0)  && (*s != ',') && (i < 8))
  {
    cmd[i++] = (char)my_toupper(*s);
    ++s;
  }
  cmd[i] = 0;

  while (*s == ' ')
    ++s;

  dnums[0] = 0;
  dnums[1] = 0;
  dnums[2] = 0;
  i = getnumbers(s, (long *)dnums, 4, 1);  // get max of 4 hex dword numbers

  Driver.DebugTimeOut = 1000;  // about 600 second seconds timeout
  switch (cmd[0])
  {
   case 'B':  // b - box selection to debug
#ifdef S_VS
#if 0
     if (*s != 0)
     {
       write_remote_cmd(&Driver.pm[0], s);
     }
     else
     {
       read_trace_queue(&Driver.pm[0]);
     }
#endif
#endif
   break;

   case 'D':  // d - dump memory
      getstr(cmd, s, &j, 16);
      if (my_lstricmp(cmd, "ext") == 0)
        dump_mem((UCHAR *)Driver.DebugExt,
                  sizeof(*Driver.DebugExt));  // dump memory
      else if (my_lstricmp(cmd, "RxBuf") == 0)
      {
        k = Driver.DebugExt->RxQ.QPut;
        dump_mem((UCHAR *)&Driver.DebugExt->RxQ.QBase[0], 0x200);  // dump memory
      }
      else if (my_lstricmp(cmd, "port") == 0)
      {
#ifdef S_VS
        dump_mem((UCHAR *)Driver.DebugExt->Port, 
                  sizeof(*Driver.DebugExt->Port));  // dump memory
#else
        dump_mem((UCHAR *)Driver.DebugExt->ChP, 
                  sizeof(*Driver.DebugExt->ChP));  // dump memory
#endif
      }
      else if (my_lstricmp(cmd, "driver") == 0)
      {
        dump_driver();
      }
      else if (i == 1)  // 1 number
        dump_mem((UCHAR *)dnums[0], 0x100);  // dump memory
    break;

    case 'E': // EXIT
      if (my_lstricmp(cmd, "EXIT") == 0)
        debug_all_off();
    break;

    case 'I': // iw
      if (cmd[1] == 'W')
      {
        dnums[1] = READ_PORT_USHORT((PUSHORT) dnums[0]);
        deb_printf("iw[%x] = %x\n", dnums[0], dnums[1]);
      }
      else if (cmd[1] == ' ')
      {
        dnums[1] = READ_PORT_UCHAR((PUCHAR) dnums[0]);
        deb_printf("i[%x] = %x\n", dnums[0], dnums[1]);
      }

    case 'L': //  L
        Driver.load_testing = dnums[0];
        deb_printf("test load = %d\n", Driver.load_testing);
    break;

    case 'M': //  M
      if (my_lstricmp(cmd, "M") == 0)  //  MON  {RX | TX | EV}
      {
        Driver.GTraceFlags = D_Error;
        debug_all_off();
        break;
      }

      if (my_lstricmp(cmd, "MONG") == 0)  //  MONG {0,1,2,3,4...}
      {
        if (dnums[0] == 0)
             Driver.GTraceFlags = D_Error | D_Init;
        else Driver.GTraceFlags |= (1 << dnums[0]);
        break;
      }

      if (Driver.DebugExt == NULL)
      {
        no_port_message();
        break;
      }

      if (my_lstricmp(cmd, "MON") == 0)  //  MON  {RX | TX | EV}
      {

        getstr(cmd, s, &j, 16);
        if (my_lstricmp(cmd, "rx") == 0)
        {
          Driver.DebugExt->TraceOptions |= 2;
          Driver.TraceOptions |= 2;
        }
        else if (my_lstricmp(cmd, "off") == 0)
        {
          Driver.DebugExt->TraceOptions = 0;
          Driver.TraceOptions = 0;
        }
        else if (my_lstricmp(cmd, "tx") == 0)
        {
          Driver.DebugExt->TraceOptions |= 4;
          Driver.TraceOptions |= 4;
        }
        else if (my_lstricmp(cmd, "ev") == 0)
        {
          Driver.DebugExt->TraceOptions |= 1;
          Driver.TraceOptions |= 1;
        }
        else if (my_lstricmp(cmd, "irq") == 0)
        {
          Driver.DebugExt->TraceOptions |= 8;
          Driver.TraceOptions |= 8;
        }
      }
    break;

#ifdef S_VS    
    case 'N': //  Net
      dump_net();
    break;
#endif

    case 'O':
      if (cmd[1] == 'D')
      {
        WRITE_PORT_ULONG((PULONG) dnums[0], (ULONG) dnums[1]);
        deb_printf("od[%x] = %x\n", dnums[0], dnums[1]);
      }
      else if (cmd[1] == 'W')
      {
        WRITE_PORT_USHORT((PUSHORT) dnums[0], (USHORT) dnums[1]);
        deb_printf("ow[%x] = %x\n", dnums[0], dnums[1]);
      }
      else if (cmd[1] == ' ')
      {
        WRITE_PORT_UCHAR((PUCHAR) dnums[0], (UCHAR) dnums[1]);
        deb_printf("o[%x] = %x\n", dnums[0], dnums[1]);
      }
    break;

     case 'P': //  PORT name
      debug_all_off();

      getstr(cmd, s, &j, 10);
      deb_printf("Port - %s\n", cmd);

      ext = find_ext_by_name(cmd, NULL);
      Driver.DebugExt = ext;
      if (ext != NULL)
           deb_printf("Found port.\n");
      else deb_printf("Not Found!!!\n");
    break;

    case 'R': //  RESET PORT
      if (Driver.DebugExt == NULL)
      {
        no_port_message();
        break;
      }

      if (my_lstricmp(cmd, "RESET") == 0)
      {
        getstr(cmd, s, &j, 16);
        if (my_lstricmp(cmd, "port") == 0)
          reset_port();

        if (my_lstricmp(cmd, "modem") == 0)
          reset_modem();

#ifdef S_VS
        if (my_lstricmp(cmd, "box") == 0)
          reset_box();
#endif
      }
    break;

    case 'S': //  STAT
#ifdef S_VS
      if (my_lstricmp(cmd, "SENDE") == 0)
      {
        eth_test_pkt();
        break;
      }
#endif
      if (Driver.DebugExt == NULL)
      {
        no_port_message();
        break;
      }

      if (my_lstricmp(cmd, "STAT") == 0)
      {
        deb_printf("--stats--\n");
          dump_ext1();
      }
      else if (my_lstricmp(cmd, "SEND") == 0)
      {
        send_str(s);
      }
    break;

#ifdef COMMENT_OUT
    case 'T': //  timer
      if (my_lstricmp(cmd, "timer") == 0)
      {
        LARGE_INTEGER t1,t2;
        our_assert(123, 0);
        t1 = KeQueryPerformanceCounter(NULL);
        deb_printf("Low:%x High:%x\n", Driver.PollIntervalTime.LowPart,
                   Driver.PollIntervalTime.HighPart);
        t2 = KeQueryPerformanceCounter(NULL);
        deb_printf("L2:%x L1:%x H2:%x H1:%x\n", t2.LowPart, t1.LowPart,
                   t2.HighPart, t1.HighPart);
      }
    break;
#endif

    default:
      deb_printf("Driver Version:%s\n", VER_PRODUCTVERSION_STR);
      deb_printf("? - This help.\n");
      deb_printf("PORT COM# - set the port to work on.\n");
      deb_printf("D {ext | chp | rxbuf | driver}  - Dump structure.\n");
      deb_printf("STAT - Dump key info.\n");
      deb_printf("SEND string - Send string out port.\n");
#ifdef S_VS
      //deb_printf("SENDE - Send a test ethernet pkt.\n");
      //deb_printf("RESET {PORT | BOX} - Reset Port or device.\n");
#endif
      deb_printf("M - Turn event/data monitor off.\n");
#ifdef S_VS    
      deb_printf("NET - Dump network statistics.\n");
#endif
      deb_printf("MON {EV | TX | RX} - monitor events, rx-data or tx-data\n");
#ifdef S_VS
      deb_printf("MONG {0,1,...10} - monitor stack 1=nic 3=hdlc 5=port\n");
      deb_printf("RESET modem - Reset VS2000 modem(on selected port).\n");
#endif
    break;
  }

  deb_printf("\x0d\x0a:");
}

#ifdef S_VS
/*----------------------------------------------------------------------------
| eth_test_pkt -
|----------------------------------------------------------------------------*/
void eth_test_pkt(void)
{
 BYTE buf[80];
 int stat, len;
 static BYTE cnt;
 Nic *nic;

  nic = Driver.board_ext->pm->nic;
  if (nic == NULL)
  {
    Tprintf("Null Nic!");
    return;
  }
  len = 64;
  //memset(&buf[0], 0xff, 6);
  memcpy(&buf[0], Driver.board_ext->hd->dest_addr, 6);
  memcpy(&buf[6], nic->address, 6);  // our addr

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&buf[12]) = 0xfe11;

  buf[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  buf[15] = 0;     // conc. index field
  buf[16] = 1;     // admin
  *((WORD *)&buf[17]) = len;
  buf[19] = 0x70;     // ADMIN packet type, 1=boot-loader, 3=id-reply
  buf[20] = cnt++;

  stat = nic_send_pkt(nic, buf, len);
  if (stat)
  {
    deb_printf("Error sending.\x0d\x0a:");
  }
  else deb_printf("Sent.\x0d\x0a:");
}
#endif

/*----------------------------------------------------------------------------
| bad_cmd_message -
|----------------------------------------------------------------------------*/
void bad_cmd_message(void)
{
  deb_printf("Unknown command!");
}

/*----------------------------------------------------------------------------
| no_port_message -
|----------------------------------------------------------------------------*/
void no_port_message(void)
{
  deb_printf("Use PORT com# to setup a port to monitor!");
}

/*----------------------------------------------------------------------------
| read_in_queue -
|----------------------------------------------------------------------------*/
void read_in_queue(char *str)
{
 int j,k;
 PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.DebugExt;

  k = getint(str, &j);
  if (j==0)  // got a number
  {
//    dump_mem(UCHAR *ptr, ULONG len);
      deb_printf("read %d!\n", k);
  }
}

/*----------------------------------------------------------------------------
| debug_poll - used to timeout inactive debug session and turn off any
|   tracing which might be active.  Called roughly every 6 seconds.
|----------------------------------------------------------------------------*/
void debug_poll(void)
{
  if (Driver.DebugTimeOut == 0)  // used to timeout inactive debug sessions.
    return;
  --Driver.DebugTimeOut;

  if (Driver.DebugTimeOut == 0)  // used to timeout inactive debug sessions.
  {
    debug_all_off();
  }
}

/*----------------------------------------------------------------------------
| debug_all_off - 
|----------------------------------------------------------------------------*/
void debug_all_off(void)
{
#ifdef S_VS
 int Dev;
#endif

  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION board_ext;

  // Driver.DebugExt = NULL;
  Driver.TraceOptions = 0;

  board_ext = Driver.board_ext;
  while (board_ext)
  {
    ext = board_ext->port_ext;
    while (ext)
    {
      ext->TraceOptions = 0;
      ext = ext->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;
  }  // while board extension
}

#ifdef S_VS
/*----------------------------------------------------------------------------
| reset_box -
|----------------------------------------------------------------------------*/
void reset_box(void)
{
  PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  while (ext)
  {
    ext->pm->state = ST_INIT;
    ext = ext->board_ext;
  }
}
#endif

/*----------------------------------------------------------------------------
| reset_modem - Reset Port Modem Hardware
|----------------------------------------------------------------------------*/
void reset_modem(void)
{
  PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;

  if (ext == NULL)
    return;

#ifdef S_VS
  pModemReset(ext->Port);
#endif
}

/*----------------------------------------------------------------------------
| reset_port - Reset Port Hardware(assume modem on with RTS/CTS flow ctrl)
|----------------------------------------------------------------------------*/
void reset_port(void)
{
  PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;

  if (ext == NULL)
    return;

#ifndef S_VS
   sFlushTxFIFO(ext->ChP);
   sFlushRxFIFO(ext->ChP);

   // Disable all Tx and Rx functions
   sDisTransmit(ext->ChP);
   sDisRxFIFO(ext->ChP);
   sDisRTSFlowCtl(ext->ChP);
   sDisCTSFlowCtl(ext->ChP);
   sDisRTSToggle(ext->ChP);
   sClrBreak(ext->ChP);

   // Drop the modem outputs
   // Takes care of DTR flow control as well
   sClrRTS(ext->ChP);
   sClrDTR(ext->ChP);

   //---- wait, give time for user to see this reset
   time_stall(10);  // wait 1 second

   ProgramBaudRate(ext, ext->BaudRate);

   // Enable Rx, Tx and interrupts for the channel
   sEnRxFIFO(ext->ChP);    // Enable Rx
   sEnTransmit(ext->ChP);    // Enable Tx
   sSetRxTrigger(ext->ChP,TRIG_1);  // always trigger
   sEnInterrupts(ext->ChP, ext->IntEnables); // allow interrupts

   sEnRTSFlowCtl(ext->ChP);
   sEnCTSFlowCtl(ext->ChP);
   sSetDTR(ext->ChP);
#endif
}

/*----------------------------------------------------------------------------
| send_str - Dump extension data
|----------------------------------------------------------------------------*/
void send_str(char *str)
{
  PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;
  ULONG i;

  if (ext == NULL)
    return;

  strcat(str, "\x0d\x0a");  // modems like CR,LF
#ifdef S_VS
  i = q_put(&ext->Port->QOut, str, strlen(str));
#else
  i = sWriteTxBlk(ext->ChP, str, strlen(str));
#endif
  deb_printf("%d bytes sent\n", i);
}

/*----------------------------------------------------------------------------
| dump_driver - Dump driver status
|----------------------------------------------------------------------------*/
void dump_driver(void)
{
  deb_printf("DRIVER, PollCnt:%d, PollStop:%d\n",
             Driver.PollCnt, Driver.Stop_Poll);

  deb_printf(" MemAlloced:%d\n", Driver.mem_alloced);

#ifdef S_VS
  deb_printf(" Tick100usBase:%d\n", Driver.Tick100usBase);
#endif
}

#ifdef S_VS
/*----------------------------------------------------------------------------
| dump_box - Dump box status
|----------------------------------------------------------------------------*/
void dump_box(int index)
{
 PortMan *pm;
 Hdlc *hd;
 int i;
 PSERIAL_DEVICE_EXTENSION ext;

  i = 0;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if ((index == i) || (index == 10000))
    {
      pm = ext->pm;
      hd = ext->hd;
      deb_printf("BOX, Index:%d, Nic:%d Ports:%d\n",
                 i, pm->nic_index, pm->num_ports);

    if(pm->backup_server)
      deb_printf(" Backup Server: Timeout:%d min Current Time:%d min/%d tic\n", 
        pm->backup_timer, (pm->load_timer/6000), pm->load_timer);
    else
      deb_printf(" Designated as Primary Server\n");

      deb_printf(" State:%s Reload Errors:%d Timer:%d\n",
                 port_state_str[pm->state],
                 pm->reload_errors, pm->state_timer);

      deb_printf(" MAC:%x %x %x %x %x %x\n",
                  hd->dest_addr[0], hd->dest_addr[1], hd->dest_addr[2],
                  hd->dest_addr[3], hd->dest_addr[4], hd->dest_addr[5]);

      deb_printf("Hdlc Status:\n");
      //----- circular que of outgoing data packets
#if DBG
      deb_printf(" qout.QBase:%x", hd->qout.QBase);  // our packet buffer circular queue
      deb_printf(" Pkt Cnt:%d Put:%d Get:%d\n",
                  q_count(&hd->qout), hd->qout.QPut, hd->qout.QGet);
#endif
      deb_printf(" Pkt Sends:%d ReSends:%d", hd->iframes_sent, hd->iframes_resent);
      deb_printf(" Timeouts, RAck:%d SAck:%d", hd->rec_ack_timeouts,
                   hd->send_ack_timeouts);

      deb_printf(" status:%x\n", hd->status);
#if DBG
      deb_printf(" HDLC: V(s):%x V(r):%x NextIn:%x\n",
                   hd->out_snd_index, hd->in_ack_index, hd->next_in_index);
      deb_printf("  UnAcked:%x TxAckTimer:%x RxAckTimer:%x\n",
                    hd->unacked_pkts, hd->sender_ack_timer, hd->rec_ack_timer);
#endif
      deb_printf("  Window pkt size:%d\n", hd->pkt_window_size);
      deb_printf("  Errors OurOfSeq:%d\n",
                    hd->iframes_outofseq);
      deb_printf("\n");
    }
    ext = ext->board_ext; // next one
    ++i;
  }
}

/*----------------------------------------------------------------------------
| dump_nic - Dump nic status
|----------------------------------------------------------------------------*/
void dump_nic(int index)
{
 Nic *nic;
 int i;

  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if ((index == i) || (index == 10000))
    {
      if (Driver.nics[i].Open)
      {
        nic = &Driver.nics[i];
        deb_printf("NIC, Name[%d]=%s\n",i, nic->NicName);

        deb_printf(" MAC:%x %x %x %x %x %x\n",
           nic->address[0],nic->address[1],nic->address[2],
           nic->address[3],nic->address[4],nic->address[5]);

        deb_printf(" Packets Rcvd: Ours:%d NotOurs:%d Pend:%d NonPend:%d",
                   nic->pkt_rcvd_ours,
                   nic->pkt_rcvd_not_ours,
                   nic->RxPendingMoves,
                   nic->RxNonPendingMoves);

        deb_printf(" OvrFlows:%d  Rcvd Bytes:%d\n",
                   nic->pkt_overflows, nic->rec_bytes);

        deb_printf(" Packets Sent: Pkts:%d Bytes:%d\n", nic->pkt_sent,
                   nic->send_bytes);
      }  // open
      deb_printf("\n");
    }
  }
}

/*----------------------------------------------------------------------------
| dump_net - Dump network status
|----------------------------------------------------------------------------*/
void dump_net(void)
{
 PSERIAL_DEVICE_EXTENSION ext = Driver.board_ext;
 int num_devs = 0;

 while (ext != NULL)
 {
#if DBG
   //write_device_options(ext);
#endif
   ext = ext->board_ext;
   ++num_devs;
 }
 deb_printf("ScanRate:%d, Base:%d\n", Driver.ScanRate, Driver.Tick100usBase);

 deb_printf("----Num Devices:%d\n", num_devs);

 deb_printf("    threadHandle: %x, threadCount:%d\n",
             Driver.threadHandle, Driver.threadCount);
 dump_nic(10000);  // dump all nic card data;
 dump_box(10000);  // dump all box data;
}
#endif

/*----------------------------------------------------------------------------
| dump_ext1 - Dump extension data
|----------------------------------------------------------------------------*/
void dump_ext1(void)
{
// int i;
 PSERIAL_DEVICE_EXTENSION ext = Driver.DebugExt;

  if (ext == NULL)
    return;

  deb_printf("%s, BaudRate:%d Open:%d\n", ext->SymbolicLinkName,
              ext->BaudRate, ext->DeviceIsOpen);
  if (ext->port_config->LockBaud != 0)
    deb_printf(" LockBaud:%d\n", ext->port_config->LockBaud);

  deb_printf("ModemStatus:%xH DTRRTS:%xH\n", ext->ModemStatus, ext->DTRRTSStatus);

#ifdef NEW_Q
  {
#ifdef S_VS
  LONG tx_remote;
#endif
  LONG rx_buf = 0;
  if (ext->DeviceIsOpen)
    rx_buf = q_count(&ext->RxQ);
#ifdef S_VS
  tx_remote = PortGetTxCntRemote(ext->Port);
  deb_printf("IRP TxCnt:%d TxBufCnt:%d TxRemoteCnt:%d  BufRxCnt:%d\n",
     ext->TotalCharsQueued,
     PortGetTxCnt(ext->Port),
     tx_remote, rx_buf);
  deb_printf(" (nPutRemote:%d, nGetRemote:%d, nGetLocal:%d)\n",
         ext->Port->nPutRemote,
         ext->Port->nGetRemote,
         ext->Port->nGetLocal);
#else
  deb_printf("TxIRP_Cnt:%d TxBoardCnt:%d  RxBufCnt:%d RxBoardCnt:%d\n",
     ext->TotalCharsQueued,
     sGetTxCnt(ext->ChP),
     rx_buf,
     sGetRxCnt(ext->ChP));
#endif
  }

#else
  // old-q-tracking code.....
  deb_printf("RxPut:%d RxGet:%d RxSize:%d RxBufAddr:%xH\n",
     ext->RxQ.QPut, ext->RxQ.QGet, ext->RxQ.QSize, ext->RxQ.QBase);

#ifndef S_VS
  deb_printf("BoardTxCnt:%d BoardRxCnt:%d\n",
     sGetTxCnt(ext->ChP), sGetRxCnt(ext->ChP));
#endif

#endif

  deb_printf("Stats - RxTot:%u TxTot:%u\n",
    ext->OurStats.ReceivedCount,
    ext->OurStats.TransmittedCount);

  deb_printf("Errors - Parity:%d Frame:%d Buf Overflow:%d Hardware Overflow:%d\n",
    ext->OurStats.ParityErrorCount,
    ext->OurStats.FrameErrorCount,
    ext->OurStats.BufferOverrunErrorCount,
    ext->OurStats.SerialOverrunErrorCount);

  deb_printf("Stats - Writes:%u Reads:%u\n", ext->sent_packets, ext->rec_packets);

  deb_printf("IRPs -");
  //------
  if ( (!IsListEmpty(&ext->WriteQueue))  // no queued up output data
     || (ext->CurrentWriteIrp) )
    deb_printf("WrIRP:");
  if (!IsListEmpty(&ext->WriteQueue))  // no queued up output data
    deb_printf("Q");
  if (ext->CurrentWriteIrp)
    deb_printf("C");


  //------
  if ( (!IsListEmpty(&ext->ReadQueue))  // no queued up output data
     || (ext->CurrentReadIrp) )
    deb_printf(" RdIRP:");

  if (!IsListEmpty(&ext->ReadQueue))  // no queued up output data
    deb_printf("Q");
  if (ext->CurrentReadIrp)
    deb_printf("C");
  
  //------
  //if ( (!IsListEmpty(&ext->MaskQueue))  // no queued up output data
  //   || (ext->CurrentMaskIrp) )
  //  deb_printf(" MaskIRP:");

  //if (!IsListEmpty(&ext->MaskQueue))  // no queued up output data
  //  deb_printf("Q");
  //if (ext->CurrentMaskIrp)
  // deb_printf("C");

  //------
  if (ext->CurrentWaitIrp)
    deb_printf(" WaitIRP:C");

  //------
  if ( (!IsListEmpty(&ext->PurgeQueue))  // no queued up output data
    || (ext->CurrentPurgeIrp))
    deb_printf(" PurgeIRP:");

  if (!IsListEmpty(&ext->PurgeQueue))  // no queued up output data
    deb_printf("Q");
  if (ext->CurrentPurgeIrp)
    deb_printf("C");

  deb_printf("\n");
  //------

  if ((ext->WriteLength) ||
       (ext->NumberNeededForRead))
  {
    deb_printf("WrLen:%x, ReadLeft:%x\n",
      ext->WriteLength,
      ext->NumberNeededForRead);
  }

  if (ext->IsrWaitMask ||  ext->HistoryMask || ext->WaitIsISRs)
  {
    deb_printf("WaitMask:%x HistMask:%x MaskLoc:%x\n",
      ext->IsrWaitMask,
      ext->HistoryMask,
      ext->IrpMaskLocation);

    if (ext->IsrWaitMask & 2)  // RXFLAG(event-char)
      deb_printf("Event Char:%xH\n",
         ext->SpecialChars.EventChar);
  }

  if (ext->TXHolding || ext->RXHolding || ext->ErrorWord)
    deb_printf("TXHolding:%x RXHolding:%x ErrorW:%x\n",
      ext->TXHolding,
      ext->RXHolding,
      ext->ErrorWord);

  if (ext->TotalCharsQueued)
    deb_printf("TotalTX:%x\n",
      ext->TotalCharsQueued);
#ifdef S_VS
  deb_printf("%s ExtAddr:%xH(size:%xH)\n",
             ext->SymbolicLinkName,
             ext, sizeof(*ext));
#else
  deb_printf("%s ExtAddr:%xH(size:%xH)  ChnAddr:%xH(size:%xH)\n",
             ext->SymbolicLinkName, ext, sizeof(*ext),
             ext->ChP, sizeof(*ext->ChP));
#endif
}

/*----------------------------------------------------------------------------
| dump_mem - Dump memory to debug channel.
|----------------------------------------------------------------------------*/
void dump_mem(UCHAR *ptr, ULONG len)
{
 unsigned char binbuf[17];
 char tmpstr[60];
 int j,i;
 ULONG off = 0;

  if (ptr == NULL)
  {
    deb_printf("Null\n");
    return;
  }

  if (MmIsAddressValid(ptr) == FALSE)
  {
    deb_printf("Not valid\n");
    return;
  }

  if (len > 0x500) len = 0x500;

  while (len > 0)
  {
    j = 16;
    if (len < 16)
      j = len;

    deb_printf("%08x> ", (ULONG)ptr + off);
    for (i=0; i<j; i++)
    {
      binbuf[i] = ptr[i+off];
      Sprintf(tmpstr, "%02x ", binbuf[i]);
      if ((i % 16) == 7)
        strcat(tmpstr,"- ");
      deb_printf(tmpstr);

      if ((binbuf[i] < 0x20) || (binbuf[i] >= 0x80))
        binbuf[i] = '.';
      else if (binbuf[i] == '\\')
        binbuf[i] = '.';
      else if (binbuf[i] == '%')
        binbuf[i] = '.';
    }
    off += 16;
    binbuf[i] = 0;
    Sprintf(tmpstr, "%s\x0d\x0a", binbuf);
    deb_printf(tmpstr);
    len -= j;
  }
}

/*---------------------------------------------------------------------------
| deb_printf - uart printf.
|---------------------------------------------------------------------------*/
void __cdecl deb_printf(char *format, ...)
{
  va_list next;
  int len;
 static char buf[120];

  va_start(next, format);
  our_vsnprintf(buf, 118, format, next);

  len = strlen(buf);
  if (len > 0)  //--- convert "\n" to a CR,LF
  {
    if (buf[len-1] == 0xa)
    {
      buf[len-1] = 0xd;
      buf[len] = 0xa;
      buf[len+1] = 0;
      ++len;
    }
  }

  //----- log it into our debug Q
  q_put(&Driver.DebugQ, (BYTE *) buf, len);
}

#ifdef S_VS
#if 0
/*---------------------------------------------------------------------------
| write_remote_cmd - Write remote trace debug command. 
   This is experimental code to read box traces, not in working order.
|---------------------------------------------------------------------------*/
int write_remote_cmd(PortMan *pm, char *cmd)
{
 int stat;
 BYTE *buf;
 BYTE cmd_buf[60];
 BYTE *tx_base;

  TraceStr("writeTrace");

  strcpy(cmd_buf, cmd);
  cmd_buf[0x3f] = 1;  // new-command flag

  hdlc_get_ctl_outpkt(pm->hd, &buf);
  if (buf == NULL)
    return 1;
  tx_base = buf - 20;  // backup to start of pkt

  stat = ioctl_device(UPLOAD_COMMAND,
                      (BYTE *) cmd_buf,
                      buf,
                      0x400L,  // offset into memory
                      0x40);   // num bytes of data
  // setup header
  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;     // conc. index field
  tx_base[16] = 1;     // admin
  *((WORD *)&tx_base[17]) = 0x80;
  tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  if (pending_debug_packet)
    time_stall(1);  // wait 1/10th second
  pending_debug_packet = 1;  // flag to tell when response comes in

  // send it.
  stat = hdlc_send_raw(pm->hd, 60, NULL);

  if (stat)
       {TraceErr("Bad send");}

  return 0;
}

/*---------------------------------------------------------------------------
| read_trace_queue - Read remote trace buffer, so we can display any new
   trace data to the screen.  This routine just sends out the query.
   admin.c will get a reply and stuff the incoming data into the
   local trace queue.
   This is experimental code to read box traces, not in working order.
|---------------------------------------------------------------------------*/
int read_trace_queue(PortMan *pm)
{
 int stat;
 BYTE *buf;
 WORD io_buf[60];
 BYTE *tx_base;

  TraceStr("readTrace");

  hdlc_get_ctl_outpkt(pm->hd, &buf);
  if (buf == NULL)
    return 1;
  tx_base = buf - 20;  // backup to start of pkt

  stat = ioctl_device(IOCTL_COMMAND,
                      (BYTE *) io_buf,
                      buf,
                      22,  // 22 = get trace q
                      0);  // num bytes of data
  // setup header
  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;     // conc. index field
  tx_base[16] = 1;     // admin
  *((WORD *)&tx_base[17]) = 40;
  tx_base[19] = 1;     // ADMIN packet type, 1=boot-loader, 3=id-reply

  if (pending_debug_packet)
    time_stall(1);  // wait 1/10th second
  pending_debug_packet = 22;  // flag to tell when response comes in

  // send it.
  stat = hdlc_send_raw(pm->hd, 60, NULL);

  if (stat)
       {TraceErr("Bad send");}

  return 0;
}

/*---------------------------------------------------------------------------
| debug_device_reply - Handle received debug-boot loader ADMIN packets
    from device.
   This is experimental code to read box traces, not in working order.
|---------------------------------------------------------------------------*/
int debug_device_reply(PVOID *void_pm,   // PortMan *pm,
                 unsigned char *data,
                 unsigned char *pkt);
{
  int i;
  unsigned char chksum;
//  unsigned char *bf;
  unsigned char uc;
  WORD ret_size;
  BYTE *bptr;
  BYTE message_type;
  PortMan *pm = (PortMan *)void_pm;

  bptr = data;


  if (bptr[0] != '|')  // good reply header
  {
    deb_printf("dbg:bad hdr\n");
    return 1;
  }

  chksum = bptr[1];
  ret_size = bptr[1];  // get len

  chksum += bptr[2];
  ret_size += ((WORD)(bptr[2]) << 8);  // get len
  if (ret_size > 1600)  // limit
    ret_size = 0;

  uc = bptr[3];  // get command return word
  message_type = uc & 0x7f;  // strip off 80H bit.

  chksum += uc;
  uc = bptr[4];
  chksum += uc;

  i = 0;
  if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
  {
    // o_printf("ret size:%d\n", ret_size-2);
    if (data == NULL)
    {
      pending_debug_packet = 0;
      //deb_printf("dbg:no data\n");
      return 20;  // err out
    }

    //bf = data;
    for (i=0; i<ret_size-2; i++)
    {
      //bf[i] = bptr[5+i];
      chksum += bptr[5+i];
    }
    i = ret_size-2;
  }

  chksum += bptr[5+i];
  if (chksum != 0xff)
  {
    deb_printf("dbg:bad chksum\n");
    return 2;  /* bad chksum */
  }

  //if ((message_type == IOCTL_COMMAND) || (message_type == DOWNLOAD_COMMAND))
  //  *num_bytes = ret_size-2;
  //else
  //  *num_bytes = 0;

  if (message_type == IOCTL_COMMAND)
  {
    if (pending_debug_packet == 22)  // flag to tell when response comes in
    {
      if (ret_size > 2)
        TracePut(&bptr[5], ret_size -2);
      deb_printf("dbg:read q\n");
    }
  }
  else
   deb_printf("dbg:set q\n");
  pending_debug_packet = 0;

  return 0;  // ok
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\debuger.h ===
// debuger.h

void debug_all_off(void);
void debug_poll(void);
void do_cmd_line(char *line);
void __cdecl deb_printf(char *format, ...);

int debug_device_reply(PVOID *void_pm,   // PortMan *pm,
                 unsigned char *data,
                 unsigned char *pkt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\hdlc.c ===
/*-------------------------------------------------------------------
  hdlc.c - handle LAN communications.  Provide error free transport
 of packets: take care of packet drop detection, retransmition.
 HDLC like services.  Layer 2.

4-27-98 - adjust for scanrate addition.
6-17-97 - change link-integrity check code.
6-17-97 - rewrite sequencing logic, in hdlc_clear_outpkts().

 Copyright 1996,97 Comtrol Corporation.  All rights reserved.  Proprietary
 information not permitted for development or use with non-Comtrol products.
|---------------------------------------------------------------------*/
#include "precomp.h"

//void hdlc_send_ialive(Hdlc *hd);
int hdlc_send_ack_only(Hdlc *hd);
static void hdlc_clear_outpkts(Hdlc *hd);
int hdlc_SendPkt(Hdlc *hd, int pkt_num, int length);
int hdlc_ctl_SendPkt(Hdlc *hd, int pkt_num, int length);

#define Trace1(s,p1) GTrace1(D_Hdlc, sz_modid, s, p1)
#define TraceStr(s) GTrace(D_Hdlc, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
static char *sz_modid = {"Hdlc"};
static char *sz_modid_err = {"Error,Hdlc"};

#define DISABLE()
#define ENABLE()

/*--------------------------------------------------------------------------
| hdlc_open -  setup and initialize a LanPort thing.
|--------------------------------------------------------------------------*/
int hdlc_open(Hdlc *hd, BYTE *box_mac_addr)
{
 int i;
 NTSTATUS Status;
 PNDIS_BUFFER    NdisBuffer;

  TraceStr("open");
  if (hd->qout.QBase != NULL)
  {
    MyKdPrint(D_Error, ("HDLC already open!\n"))
    return 0;
  }

  hd->out_snd_index= 0;
  hd->in_ack_index = 0;
  hd->next_in_index = 0;
  hd->rec_ack_timer = 0;
  hd->sender_ack_timer = 0;
  hd->tx_alive_timer = 0;
  hd->rx_alive_timer = 0;
  hd->qout_ctl.QPut = 0;
  hd->qout_ctl.QGet = 0;
  hd->qout_ctl.QSize = 2;  // 2 pkts
  hd->qout.QPut = 0;
  hd->qout.QGet = 0;
  hd->qout.QSize = HDLC_TX_PKT_QUEUE_SIZE;  // number of iframe pkts
  hd->pkt_window_size = HDLC_TX_PKT_QUEUE_SIZE-2;
  memcpy(hd->dest_addr, box_mac_addr, 6);

  // default to the first nic card slot, port state handling and nic
  // packet reception handling dynamically figures this out.
  // we should probably set it to null, but I'm afraid of this right now
#ifdef BREAK_NIC_STUFF
  hd->nic = NULL;
#else
  hd->nic = &Driver.nics[0];
#endif

  // NDIS packets consist of one or more buffer descriptors which point
  // to the actual data.  We send or receive single packets made up of
  // 1 or more buffers.  A MDL is used as a buffer descriptor under NT.

  //---------  Allocate a packet pool for our tx packets
  NdisAllocatePacketPool(&Status, &hd->TxPacketPool, HDLC_TX_PKT_QUEUE_SIZE,
                         sizeof(PVOID));
                         // sizeof(PACKET_RESERVED));
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 4;
  }

  //---------  Allocate a buffer pool for our tx packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &hd->TxBufferPool, HDLC_TX_PKT_QUEUE_SIZE);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 5;
  }

  //-------- create tx data buffer area
  hd->qout.QBase = our_locked_alloc( MAX_PKT_SIZE * HDLC_TX_PKT_QUEUE_SIZE,"hdTX");

  //-------- form our tx queue packets so they link to our tx buffer area
  for (i=0; i<HDLC_TX_PKT_QUEUE_SIZE; i++)
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &hd->TxPackets[i], hd->TxPacketPool);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 8;
    }
    hd->TxPackets[i]->ProtocolReserved[0] = i;  // mark with our index
    hd->TxPackets[i]->ProtocolReserved[1] = 0;  // free for use

    // get a buffer for the header
    NdisAllocateBuffer(&Status, &NdisBuffer, hd->TxBufferPool,
      &hd->qout.QBase[MAX_PKT_SIZE * i], 1500);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 9;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(hd->TxPackets[i], NdisBuffer);
  }

  
  
  //---------  Allocate a packet pool for our tx control packets(2)
  NdisAllocatePacketPool(&Status, &hd->TxCtlPacketPool, 2, sizeof(PVOID));
                         // sizeof(PACKET_RESERVED));
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 4;
  }

  //---------  Allocate a buffer pool for our tx ctl packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &hd->TxCtlBufferPool, 2);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    hdlc_close(hd);
    return 5;
  }

  //-------- create tx control data buffer area
  hd->qout_ctl.QBase = our_locked_alloc( MAX_PKT_SIZE * 2,"hdct");

  //-------- form our tx queue packets so they link to our tx buffer area
  for (i=0; i<2; i++)
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &hd->TxCtlPackets[i], hd->TxCtlPacketPool);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 8;
    }
    hd->TxCtlPackets[i]->ProtocolReserved[0] = i;  // mark with our index
    hd->TxCtlPackets[i]->ProtocolReserved[1] = 0;  // free for use

    // get a buffer for the header
    NdisAllocateBuffer(&Status, &NdisBuffer, hd->TxCtlBufferPool,
      &hd->qout_ctl.QBase[MAX_PKT_SIZE * i], 1500);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      hdlc_close(hd);
      return 9;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(hd->TxCtlPackets[i], NdisBuffer);
  }

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_close - 
|--------------------------------------------------------------------------*/
int hdlc_close(Hdlc *hd)
{
  TraceStr("close");

  if (hd->TxPacketPool != NULL)
    NdisFreePacketPool(hd->TxPacketPool);
  hd->TxPacketPool = NULL;

  if (hd->TxBufferPool != NULL)
    NdisFreeBufferPool(hd->TxBufferPool);
  hd->TxBufferPool = NULL;

  if (hd->qout.QBase != NULL)
    our_free(hd->qout.QBase, "hdTX");
  hd->qout.QBase = NULL;


  //------- close up the control packet buffers
  if (hd->TxCtlPacketPool != NULL)
    NdisFreePacketPool(hd->TxCtlPacketPool);
  hd->TxCtlPacketPool = NULL;

  if (hd->TxCtlBufferPool != NULL)
    NdisFreeBufferPool(hd->TxCtlBufferPool);
  hd->TxCtlBufferPool = NULL;

  if (hd->qout_ctl.QBase != NULL)
    our_free(hd->qout_ctl.QBase, "hdct");
  hd->qout_ctl.QBase = NULL;

  return 0;
}

/*----------------------------------------------------------------
 hdlc_validate_rx_pkt - Handle "hdlc" like validation of the
  rx packets from our nic driver.
  Handle checking sequence index byte and return an error if packet
  is out of sequence.
|-----------------------------------------------------------------*/
int hdlc_validate_rx_pkt(Hdlc *hd, BYTE *buf)
{
#define CONTROL_HEADER  buf[0]
#define SND_INDEX       buf[1]
#define ACK_INDEX       buf[2]
#define PRODUCT_HEADER  buf[3]

  TraceStr("validate");
  switch (CONTROL_HEADER)
  {
    case 1:  // 1H=unindex
      TraceStr("val,unindexed");
    break;

    case 3:  // 1H=unindex, 2H=sync_init
      //----- use to re-sync up our index count
      // the vs-1000 device will never do this now, only us(the server) will
      TraceStr("RESYNC");
      hdlc_resync(hd);
    return ERR_CONTROL_PACKET;  // control packet, no network data

    case 0:  // normal information frame
    break;
  }

  if ((CONTROL_HEADER & 1) == 0)  // indexed, so validate
  {
    if (hd->rec_ack_timer == 0)
      hd->rec_ack_timer = MIN_ACK_REC_TIME;

        // now check that packet is syncronized in-order
        // make sure we didn't miss a packet
    if (SND_INDEX != ((BYTE)(hd->next_in_index)) )
    {
      ++hd->iframes_outofseq;

      hd->status |= LST_SEND_ACK;  // force an acknowledgement packet

      TraceErr("bad index");
      return ERR_GET_BAD_INDEX;  // error, packet out of sequence
    }
    ++hd->unacked_pkts;  // when to trip acknowledge at 80% full
    if (hd->unacked_pkts > (hd->pkt_window_size - 1))
    {
      hd->status |= LST_SEND_ACK;
      TraceStr("i_ack");
    }

    hd->rx_alive_timer = 0;  // reset this since we have a good rx-active link

    ++hd->next_in_index;  // bump our index count
    TraceStr("iframe OK");

  }  // indexed

   //---- now grab the packet acknowledged index.
  if (hd->in_ack_index != ACK_INDEX)  // only act when changed.
  {
    //--- we can assume this ack-index is a reasonable value
    // since it has gone threw the ethernet checksum.
    hd->in_ack_index = ACK_INDEX;  // update our copy
    hd->status |= LST_RECLAIM;  // perform reclaim operation
  }

  return 0;  // ok
}

/*--------------------------------------------------------------------------
| hdlc_poll - Call at regular interval to handle packet sequencing,
   and packet resending.   Called 20 times per second for DOS,embedded,
   for NT called 100 times per sec.
|--------------------------------------------------------------------------*/
void hdlc_poll(Hdlc *hd)
{
 WORD timer;

  hd->tick_timer += ((WORD) Driver.Tick100usBase);
  if (hd->tick_timer >= 1000)  // 1/10th second
  {
    hd->tick_timer = 0;

                           // every 1/10th second
    ++hd->tx_alive_timer;
    ++hd->rx_alive_timer;
    if ((hd->tx_alive_timer >= KEEP_ALIVE_TIMEOUT) ||  // about 1 min.
        (hd->rx_alive_timer >= KEEP_ALIVE_TIMEOUT))
    {
      // Rx or Tx or both activity has not happened, or com-link
      // failure has occurred, so send out a iframe to see if
      // we are in failure or just a state of non-activity.

      // take the biggest timeout value, so we don't have to do
      // the logic twice for each.
      if (hd->tx_alive_timer > hd->rx_alive_timer)
           timer = hd->tx_alive_timer;
      else timer = hd->rx_alive_timer;

      if (timer == KEEP_ALIVE_TIMEOUT)
      {
        //hdlc_send_ialive(hd); // send out a iframe to get ack back.
        //TraceStr("Snd ialive");
        //----- notify owner to check link
        if (hd->upper_layer_proc != NULL)
          (*hd->upper_layer_proc) (hd->context, EV_L2_CHECK_LINK, 0);
      }
      else if (timer == (KEEP_ALIVE_TIMEOUT * 2))
      {
        // declare a bad connection, bring connection down.
        //----- notify owner that it needs to resync
        if (hd->upper_layer_proc != NULL)
          (*hd->upper_layer_proc) (hd->context, EV_L2_RELOAD, 0);

        TraceErr("ialive fail");

        // make sure everything is cleared out, or reset at our level
        hdlc_resync(hd);
        hd->tx_alive_timer = 0;
        hd->rx_alive_timer = 0;
      }
    }

    if (hd->sender_ack_timer > 0)
    {
      --hd->sender_ack_timer;
      if (hd->sender_ack_timer == 0)
      {
        if (!q_empty(&hd->qout)) // have outpkts waiting for ack.
        {
          TraceStr("Snd timeout");
          ++hd->send_ack_timeouts; // statistics: # of send-ack-timeouts
          hdlc_resend_outpkt(hd); // send it out again!
        }
      }
    }

    if (hd->rec_ack_timer > 0)
    {
      --hd->rec_ack_timer;
      if (hd->rec_ack_timer == 0)  // timeout on rec. packet ack.
      {
        ++hd->rec_ack_timeouts; // statistics: # of rec-ack-timeouts
  
        TraceStr("RecAck timeout");
        if (!q_empty(&hd->qout)) // have outpkts waiting for ack.
          hdlc_resend_outpkt(hd); // send it out again!
        else
        {
          // no iframe packets sent out(piggy back acks on them normally)
          // for REC_ACK_TIME amount, so we have to send out just an
          // acknowledgement packet.
          // arrange for a ack-packet to be sent by setting this bit
          hd->status |= LST_SEND_ACK;
        }
      }
    }
  }  // end of 100ms tick period

  // check if received packets more than 80% of senders capacity, if so
  // send immediate ack.
  if (hd->status & LST_SEND_ACK)
  {
    if (hdlc_send_ack_only(hd) == 0) // ok
    {
      hd->status &= ~LST_SEND_ACK;
      TraceStr("Ack Sent");
    }
    else
    {
      TraceStr("Ack Pkt Busy!");
    }
  }

  if (hd->status & LST_RECLAIM)  // check if we should perform reclaim operation
    hdlc_clear_outpkts(hd);

  return;
}

/*--------------------------------------------------------------------------
| hdlc_get_ctl_outpkt - Used to allocate a outgoing control data
   packet, fill in the
   common header elements and return a pointer to the packet, so the
   application can fill in the data in the packet.  The caller is then
   expected to send the packet via hdlc_send_ctl_outpkt().
|--------------------------------------------------------------------------*/
int hdlc_get_ctl_outpkt(Hdlc *hd, BYTE **buf)
{
  BYTE *bptr;

  TraceStr("get_ctl_outpkt");

  bptr = &hd->qout_ctl.QBase[(MAX_PKT_SIZE * hd->qout_ctl.QPut)];

  *buf = &bptr[20];  // return ptr to the sub-packet area

  if (hd->TxCtlPackets[hd->qout_ctl.QPut]->ProtocolReserved[1] != 0)  // free for use
  {
    TraceErr("CPktNotOurs!");
    *buf = NULL;
    return 2;  // error, packet is owned, busy
  }

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_get_outpkt - Used to allocate a outgoing data packet, fill in the
   common header elements and return a pointer to the packet, so the
   application can fill in the data in the packet.  The caller is then
   expected to send the packet via hdlc_send_outpkt().
|--------------------------------------------------------------------------*/
int hdlc_get_outpkt(Hdlc *hd, BYTE **buf)
{
  BYTE *bptr;

  TraceStr("get_outpkt");
  if (hd->status & LST_RECLAIM)  // check if we should perform reclaim operation
    hdlc_clear_outpkts(hd);

  // if indexed, then reduce by one so we always leave one for an
  // unindexed packet.
  if (q_count(&hd->qout) >= hd->pkt_window_size)
  {
    return 1;  // no room
  }
  if (hd->TxPackets[hd->qout.QPut]->ProtocolReserved[1] != 0)  // free for use
  {
    TraceErr("PktNotOurs!");
    *buf = NULL;
    return 2;
  }
  bptr = &hd->qout.QBase[(MAX_PKT_SIZE * hd->qout.QPut)];

  *buf = &bptr[20];  // return ptr to the sub-packet area

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_clear_outpkts - go through output queue and re-claim any packet
   buffers which have been acknowledged.
|--------------------------------------------------------------------------*/
static void hdlc_clear_outpkts(Hdlc *hd)
{
#define NEW_WAY

#ifndef NEW_WAY
  int count, get, i, ack_count, ack_get;
  BYTE *tx_base;

#define OUT_SNDINDEX tx_base[18]
#else

#define OUT_SNDINDEX_BYTE_OFFSET 18
#endif
  int put;
  int ack_index;

  TraceStr("clear_outpkt");
  hd->status &= ~LST_RECLAIM;  // clear this flag

  // in_ack_index is the last packet V(r) acknowledgement, so it
  // is equal to what the other party expects the next rec. pkt
  // index to be.
  if (hd->in_ack_index > 0)
       ack_index = hd->in_ack_index-1;
  else ack_index = 0xff;

#ifdef NEW_WAY
  put = hd->qout.QPut;
  // figure out a queue index of the last(most recent) pkt we sent
  // (back up the QPut index)

  while (put != hd->qout.QGet)  // while not end of ack-pending out-packets
  {
    // (back up the QPut index)
    if (put == 0)
     put = HDLC_TX_PKT_QUEUE_SIZE-1;
    else --put;

    // if ack matches the out_snd_index for this packet
    if (hd->qout.QBase[(MAX_PKT_SIZE * put)+OUT_SNDINDEX_BYTE_OFFSET]
         == ack_index)
    {
      // clear all pending up to this packet by updating the QGet index.
      if (put == (HDLC_TX_PKT_QUEUE_SIZE-1))
           hd->qout.QGet = 0;
      else hd->qout.QGet = (put+1);

      hd->tx_alive_timer = 0;  // reset this since we have a good active link

      if (q_empty(&hd->qout))  // all packets cleared
           hd->sender_ack_timer = 0;  // stop the timeout counter
      break;  // bail out of while loop, all done
    }
  }
#else
  count = q_count(&hd->qout);
  get   = hd->qout.QGet;
  ack_count = 0;
  ack_get = get;  // acknowledge all up to this point

  for (i=0; i<count; i++)
  {
    //-- setup a ptr to our first outgoing packet in our resend buffer
    tx_base= &hd->qout.QBase[(MAX_PKT_SIZE * get)];
    ++get;  // setup for next one
    if (get >= HDLC_TX_PKT_QUEUE_SIZE)
      get = 0;

       // if the packet is definitely older than our ACK index
    if (OUT_SNDINDEX <= ack_index)
    {
     
      ++ack_count;    // acknowledge all up to this point
      ack_get = get;  // acknowledge all up to this point
    }
       // else if roll over cases might exist
    else if (ack_index < HDLC_TX_PKT_QUEUE_SIZE)
    {
      if (OUT_SNDINDEX > HDLC_TX_PKT_QUEUE_SIZE)  // roll over case
      {
        ++ack_count;    // acknowledge all up to this point
        ack_get = get;  // acknowledge all up to this point
      }
      else break;  // bail from for loop
    }
    else  // we are all done, because pkts must be in order
    {
      break;  // bail from for loop
    }
  }

  if (ack_count)  // if we did acknowledge(free) some output packets
  {
    hd->tx_alive_timer = 0;  // reset this since we have a good active link

    hd->qout.QGet    = ack_get;   // update the circular get queue index.

    if (q_empty(&hd->qout))  // all packets cleared
         hd->sender_ack_timer = 0;  // stop the timeout counter
  }
#endif
}

/*--------------------------------------------------------------------------
| hdlc_resend_outpkt - resend packet(s) due to sequence error.  Only indexed
   iframe packets get resent.
|--------------------------------------------------------------------------*/
int hdlc_resend_outpkt(Hdlc *hd)
{
  BYTE *tx_base;
  int phy_len, count;
//  BYTE *buf;
//  WORD *wptr;
  int get;

  TraceStr("resend_outpkt");
  if (hd->status & LST_RECLAIM)  // check if we should perform reclaim operation
    hdlc_clear_outpkts(hd);

  count = q_count(&hd->qout);
  get   = hd->qout.QGet;

  if (count == 0)
    return 0;  // none to send

  while (count > 0)
  {
    if (hd->TxPackets[get]->ProtocolReserved[1] == 0) {
      /* Make sure packet has come back from NDIS */

      /* free to resend */
      // assume indexing used
      tx_base= &hd->qout.QBase[(MAX_PKT_SIZE * get)];

      ++hd->iframes_sent;  // statistics
      // get calculated length of packet for resending at out pkt prefix.
      phy_len = hd->phys_outpkt_len[get];

      // always make the ack as current as possible
      tx_base[19] = hd->next_in_index;  // V(r)

      hdlc_SendPkt(hd, get, phy_len);

      ++hd->iframes_resent; // statistics: # of packets re-sent
    }

    ++get;
    if (get >= HDLC_TX_PKT_QUEUE_SIZE)
      get = 0;

    --count;
  }
  hd->unacked_pkts = 0;

  // reset timeout
  hd->sender_ack_timer = (MIN_ACK_REC_TIME * 2);

  // reset this timer, since we are sending out new ack.
  hd->rec_ack_timer = 0;

  return 0;
}

/*--------------------------------------------------------------------------
| hdlc_send_ctl_outpkt - App. calls hdlc_get_ctl_outpkt() to get a buffer.
   App then fills buffer and sends it out by calling us.
|--------------------------------------------------------------------------*/
int hdlc_send_ctl_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr)
{
  BYTE *tx_base;
  int phy_len;
  int get, stat;

  TraceStr("send_ctl_outpkt");
  get = hd->qout_ctl.QPut;

  tx_base = &hd->qout_ctl.QBase[(MAX_PKT_SIZE * get)];
  ++hd->qout_ctl.QPut;
  if (hd->qout_ctl.QPut >= hd->qout_ctl.QSize)
    hd->qout_ctl.QPut = 0;

  ++hd->ctlframes_sent;  // statistics

  if (dest_addr == NULL)
       memcpy(tx_base, hd->dest_addr, 6);   // set dest addr
  else memcpy(tx_base, dest_addr, 6);       // set dest addr

  memcpy(&tx_base[6], hd->nic->address, 6); // set src addr

             // + 1 for trailing 0(sub-pkt terminating header)
  phy_len = 20 + data_len + 1; 

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&tx_base[12]) = 0xfe11;

  if (phy_len < 60)
    phy_len = 60;

  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;                  // conc. index field
  tx_base[16] = ASYNC_FRAME;        // ASYNC FRAME(0x55)
  tx_base[17] = 1;                  // hdlc control field(ctrl-packet)
  tx_base[18] = 0; // V(s), unindexed so mark as 0 to avoid confusion
  tx_base[19] = hd->next_in_index;  // V(r), acknowl. field
  tx_base[20+data_len] = 0;         // terminating sub-packet type


  hd->unacked_pkts = 0;  // reset this

  // reset this timer, since we are sending out new ack.
  hd->rec_ack_timer = 0;

  stat = hdlc_ctl_SendPkt(hd, get, phy_len);


 return stat;
}

/*--------------------------------------------------------------------------
| hdlc_send_outpkt - App. calls hdlc_get_outpkt() to get a buffer.  App then
    fills buffer and sends it out by calling us.  This packet sits in
   transmit queue for possible re-send until a packet comes in which
   acknowledges reception of it.
|--------------------------------------------------------------------------*/
int hdlc_send_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr)
{
  BYTE *tx_base;
  int phy_len;
  int get, stat;

  TraceStr("send_outpkt");
  get = hd->qout.QPut;

  tx_base = &hd->qout.QBase[(MAX_PKT_SIZE * get)];

  ++hd->qout.QPut;
  if (hd->qout.QPut >= HDLC_TX_PKT_QUEUE_SIZE)
    hd->qout.QPut = 0;
  // setup this timeout for ack. back.
  hd->sender_ack_timer = (MIN_ACK_REC_TIME * 2);

  ++hd->iframes_sent;  // statistics

  if (dest_addr == NULL)
       memcpy(tx_base, hd->dest_addr, 6);   // set dest addr
  else memcpy(tx_base, dest_addr, 6);       // set dest addr

  memcpy(&tx_base[6], hd->nic->address, 6); // set src addr

             // + 1 for trailing 0(sub-pkt terminating header)
  phy_len = 20 + data_len + 1; 

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&tx_base[12]) = 0xfe11;

  if (phy_len < 60)
    phy_len = 60;

  tx_base[14] = ASYNC_PRODUCT_HEADER_ID;  // comtrol packet type = driver management, any product.
  tx_base[15] = 0;                  // conc. index field
  tx_base[16] = ASYNC_FRAME;        // ASYNC FRAME(0x55)
  tx_base[17] = 0;                  // hdlc control field(iframe-packet)
  tx_base[19] = hd->next_in_index;  // V(r), acknowl. field
  tx_base[20+data_len] = 0;         // terminating sub-packet type

  // save calculated length of packet for resending at out pkt prefix.
  hd->phys_outpkt_len[get] = phy_len;

  tx_base[18] = hd->out_snd_index;  // V(s)
  hd->out_snd_index++;

  hd->unacked_pkts = 0;  // reset this

  // reset this timer, since we are sending out new ack.
  hd->rec_ack_timer = 0;

  stat = hdlc_SendPkt(hd, get, phy_len);


 return stat;
}

/*----------------------------------------------------------------------
 hdlc_ctl_SendPkt - Our send routine.
|----------------------------------------------------------------------*/
int hdlc_ctl_SendPkt(Hdlc *hd, int pkt_num, int length)
{
  NTSTATUS Status;


#if DBG
  if (hd == NULL)
  {
    MyKdPrint(D_Error, ("H1\n"))
    TraceErr("Hsnd1a1");
    return 1;
  }
  if (hd->nic == NULL)
  {
    MyKdPrint(D_Error, ("H2\n"))
    TraceErr("Hsnd1a");
    return 1;
  }
  if (hd->nic->TxBufTemp == NULL)
  {
    MyKdPrint(D_Error, ("H3\n"))
    TraceErr("Hsnd1b");
    return 1;
  }
  if (hd->nic->TxPacketsTemp == NULL)
  {
    MyKdPrint(D_Error, ("H4\n"))
    TraceErr("Hsnd1c");
    return 1;
  }
  if (hd->nic->Open == 0)
  {
    MyKdPrint(D_Error, ("H5\n"))
    TraceErr("Hsnd1d");
    return 1;
  }
#endif
  Trace1("Hsendpkt Nic%d", hd->nic->RefIndex);

  hd->TxCtlPackets[pkt_num]->Private.TotalLength = length;
  NdisAdjustBufferLength(hd->TxCtlPackets[pkt_num]->Private.Head, length);

  hd->TxCtlPackets[pkt_num]->ProtocolReserved[1] = 1;  // mark as pending
  NdisSend(&Status, hd->nic->NICHandle,  hd->TxCtlPackets[pkt_num]);
  if (Status == NDIS_STATUS_SUCCESS)
  {
    TraceStr(" ok");
    hd->TxCtlPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
  }
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceStr(" pend");
      // Status = NicWaitForCompletion(nic);  // wait for completion
  }
  else
  {
    hd->TxCtlPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
    TraceErr(" send1A");
    return 1;
  }

  ++hd->nic->pkt_sent;          // statistics
  hd->nic->send_bytes += length;    // statistics

  return 0;
}

/*----------------------------------------------------------------------
 hdlc_SendPkt - Our send routine.
|----------------------------------------------------------------------*/
int hdlc_SendPkt(Hdlc *hd, int pkt_num, int length)
{
  NTSTATUS Status;

  TraceStr("sendpkt");

  hd->TxPackets[pkt_num]->Private.TotalLength = length;
  NdisAdjustBufferLength(hd->TxPackets[pkt_num]->Private.Head, length);

  hd->TxPackets[pkt_num]->ProtocolReserved[1] = 1;  // mark as pending
  NdisSend(&Status, hd->nic->NICHandle,  hd->TxPackets[pkt_num]);
  if (Status == NDIS_STATUS_SUCCESS)
  {
    TraceStr(" ok");
    hd->TxPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
  }
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceStr(" pend");
      // Status = NicWaitForCompletion(nic);  // wait for completion
  }
  else
  {
    hd->TxPackets[pkt_num]->ProtocolReserved[1] = 0;  // free for use
    TraceErr(" send1A");
    return 1;
  }

  ++hd->nic->pkt_sent;        // statistics
  hd->nic->send_bytes += length;  // statistics

  return 0;
}

#ifdef COMMENT_OUT
/*--------------------------------------------------------------------------
 hdlc_send_ialive - Send out a iframe packet which device is required
   to acknowledge(and send iframe back) so that we can determine if he
   is still alive.
|--------------------------------------------------------------------------*/
void hdlc_send_ialive(Hdlc *hd)
{
  int stat;
  BYTE *buf;

  if (!q_empty(&hd->qout)) // have outpkts waiting for ack.
  {
    hdlc_resend_outpkt(hd); // send it out again!
  }
  else
  {
    stat = hdlc_get_outpkt(hd, &buf);
    if (stat == 0)
    {
      buf[0] = 0;   // an empty iframe packet
      buf[1] = 0;
      stat = hdlc_send_outpkt(hd, 1, hd->dest_addr); // send it out!
      if (stat != 0)
        { TraceErr("2D"); }
    }
    else
    {
      // else we might as well go fishing and forget about this stuff.
      TraceErr("3D");
    }
  }
}
#endif

/*--------------------------------------------------------------------------
 hdlc_resync - At appropriate times it is needed to reset the sequence
   indexing logic in order to get the two sides up a talking.  On
   startup(either side) or a fatal(long) timeout, it is needed to send
   a message to the other party saying: "reset your packet sequencing
   logic so we can get sync-ed up".
|--------------------------------------------------------------------------*/
void hdlc_resync(Hdlc *hd)
{
  TraceErr("resync");
  //----- flush re-send output buffer
  hd->qout.QPut   = 0;
  hd->qout.QGet   = 0;

  //----- flush ctl output buffer
  hd->qout_ctl.QPut   = 0;
  hd->qout_ctl.QGet   = 0;

  //----- use to re-sync up our index count
  hd->in_ack_index = 0;
  hd->out_snd_index= 0;
  hd->next_in_index= 0;

  //----- reset our outgoing packet queue
  hd->sender_ack_timer = 0;

  hd->unacked_pkts = 0;
  //----- notify owner that it needs to resync
  if (hd->upper_layer_proc != NULL)
    (*hd->upper_layer_proc) (hd->context, EV_L2_RESYNC, 0);
}

/*--------------------------------------------------------------------------
| hdlc_send_ack_only - Used to recover from timeout condition.  Used to
    resend ACK only.  Used to send over ACK and index fields in a
    unindexed frame(won't flow off).  No data sent along, just HDLC header.
|--------------------------------------------------------------------------*/
int hdlc_send_ack_only(Hdlc *hd)
{
  int ret_stat;
  BYTE *pkt;

  TraceStr("send_ack_only");
  if (hdlc_get_ctl_outpkt(hd, &pkt) == 0)
    ret_stat = hdlc_send_ctl_outpkt(hd, 0, NULL);
  else
    ret_stat = 1; // packet is already in use

  return ret_stat;
}

/*--------------------------------------------------------------------------
| hdlc_send_raw - Used to send raw ethernets out(non-hdlc).
   Caller has gotten a control packet by hdlc_get_ctl_outpkt()
   and has filled in the header.  We just plug in src/dest addr and
   send it out.  Used to send out non-hdlc packets, we provide the service
   in hdlc layer because we have the nic buffers already setup, so its
   convienent to implement here.
|--------------------------------------------------------------------------*/
int hdlc_send_raw(Hdlc *hd, int data_len, BYTE *dest_addr)
{
  BYTE *tx_base;
  int phy_len;
  int get, stat;

  TraceStr("send_raw");
  get = hd->qout_ctl.QPut;

  tx_base = &hd->qout_ctl.QBase[(MAX_PKT_SIZE * get)];
  ++hd->qout_ctl.QPut;
  if (hd->qout_ctl.QPut >= hd->qout_ctl.QSize)
    hd->qout_ctl.QPut = 0;

  ++hd->rawframes_sent;  // statistics

  if (dest_addr == NULL)
       memcpy(tx_base, hd->dest_addr, 6);   // set dest addr
  else memcpy(tx_base, dest_addr, 6);       // set dest addr

  memcpy(&tx_base[6], hd->nic->address, 6); // set src addr

             // + 1 for trailing 0(sub-pkt terminating header)
  phy_len = 20 + data_len + 1; 

  // BYTE 12-13: Comtrol PCI ID  (11H, FEH), Ethernet Len field
  *((WORD *)&tx_base[12]) = 0xfe11;

  if (phy_len < 60)
    phy_len = 60;

  stat = hdlc_ctl_SendPkt(hd, get, phy_len);


 return stat;
}

/*--------------------------------------------------------------------------
| hdlc_send_control - Used to send small un-indexed hdlc frames.
|--------------------------------------------------------------------------*/
int hdlc_send_control(Hdlc *hd, BYTE *header_data, int header_len,
                       BYTE *data, int data_len,
                       BYTE *dest_addr)
{
  BYTE *buf;
  int i,stat;
  BYTE *pkt;

  i = hdlc_get_ctl_outpkt(hd, &pkt);
  if (i)
    return 1; // error

  buf = pkt;

  if (header_len)
  {
    for (i=0; i<header_len; i++)
      buf[i] = header_data[i];
    buf += header_len;
  }
  if (data_len)
  {
    for (i=0; i<data_len; i++)
      buf[i] = data[i];
    buf += data_len;
  }

  if (dest_addr == NULL)
  {
    stat = hdlc_send_ctl_outpkt(hd, header_len + data_len, hd->dest_addr);
  }
  else
  {
    stat = hdlc_send_ctl_outpkt(hd, header_len + data_len, dest_addr);
  }

  return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\init.c ===
/*-------------------------------------------------------------------
| init.c - main module for RocketPort NT device driver.  Contains
   mostly initialization code.  Driver Entry is DriverEntry() routine.

 Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

//------ local routines, function prototypes -----------------------------
NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);
#ifndef NT50
static NTSTATUS StartNT40(IN PDRIVER_OBJECT DriverObject);
#endif

//------------ global variables -----------------------------------
#ifdef S_RK
PCI_CONFIG PciConfig[MAX_NUM_BOXES+1];  // array of all our pci-boards in sys
#endif

DRIVER_CONTROL Driver;  // all Driver control information eg ISR

ULONG RocketDebugLevel = 0;
#ifdef S_RK
//char *szClassName = {"Resources RocketPort#"};
#endif

#if DBG
static TCHAR *dbg_label = TEXT("DBG_VERSION");
#endif

/*----------------------------------------------------------------------
 DriverEntry -
    The entry point that the system point calls to initialize
    any driver.
    This routine will gather the configuration information,
    report resource usage, attempt to initialize all serial
    devices, connect to interrupts for ports.  If the above
    goes reasonably well it will fill in the dispatch points,
    reset the serial devices and then return to the system.
Arguments:
    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.
    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.
    typical: "REGISTRY\Machine\System\CurrentControlSet\Services\VSLinka"
Return Value:
    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_SERIAL_NO_DEVICE_INITED.
|----------------------------------------------------------------------*/
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,
                     IN PUNICODE_STRING RegistryPath)
{
 NTSTATUS status;
 int stat;
 char tmpstr[120];

  //---- zero out the Driver structure
  RtlZeroMemory(&Driver,sizeof(Driver));

  Driver.GlobalDriverObject = DriverObject;  // used for EventLogging

  Driver.DebugQ.QBase = ExAllocatePool(NonPagedPool,10000+2);
  if ( Driver.DebugQ.QBase == NULL ) {
    return STATUS_INSUFFICIENT_RESOURCES;
  }
  Driver.DebugQ.QSize = 10000;
  Driver.TraceOptions = 0;
#if DBG
   Driver.TraceOptions = 0xffffffffL;
#endif
  KeInitializeSpinLock(&Driver.DebugLock);
  KeInitializeSpinLock(&Driver.TimerLock);

#if DBG
//    RocketDebugLevel = D_Error | D_Test;
//    Driver.GTraceFlags = D_Error | D_Test;

    //RocketDebugLevel = D_Error | D_Nic | D_Hdlc | D_Port;
    //Driver.GTraceFlags = D_Error | D_Nic | D_Hdlc | D_Port;

    //RocketDebugLevel = D_Error | D_Pnp;
    //Driver.GTraceFlags = D_Error | D_Pnp;

    //RocketDebugLevel = D_Error | D_Test | D_Pnp | D_Init;
    //Driver.GTraceFlags = D_Error | D_Test | D_Pnp | D_Init;

    //RocketDebugLevel = D_All;
    //Driver.GTraceFlags = D_All;

    RocketDebugLevel = D_Error;
    Driver.GTraceFlags = D_Error;
#endif

#ifdef S_VS
  stat = LoadMicroCode(NULL);
  if (stat)
  {
    status = STATUS_SERIAL_NO_DEVICE_INITED;
    Eprintf("Err:No VSLINKA.BIN file!");
    return status;
  }
  MyKdPrint(D_Init, ("MicroCode Loaded\n"))

  //----- allocate an array of Nic card structs
  // allow up to VS1000_MAX_NICS nic cards to come and go
  Driver.nics = (Nic *)our_locked_alloc(sizeof(Nic) * VS1000_MAX_NICS, "Dnic");
#endif

  //---- do some registry configuration reading, in options.c
  // Save off RegistryPath to Driver.RegPath
  stat = SaveRegPath(RegistryPath);
  if ( stat ) {
    status = STATUS_SERIAL_NO_DEVICE_INITED;
    return status;
  }

  UToCStr(tmpstr, RegistryPath, sizeof(tmpstr));
  MyKdPrint(D_Test, (" init RegPath=%s\n", tmpstr))

  // read in all the driver level options out of \Parameters
  // this fills out values in Driver struct
  read_driver_options();

  if (Driver.NumDevices == 0)
    Driver.NumDevices = 1;
  if (Driver.NumDevices > MAX_NUM_BOXES)
    Driver.NumDevices = MAX_NUM_BOXES;

  MyKdPrint(D_Init,("DriverEntry\n"))

  if ((Driver.ScanRate < 1) || (Driver.ScanRate > 50))
    Driver.ScanRate = 7;  // default to 7ms operation(137Hz)

  //------ only setup io stuff here if prior to NT5.0
#ifndef NT50
  status = StartNT40(DriverObject);
  if (status != STATUS_SUCCESS)
  {
    EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_FAIL, 0, NULL);
    SerialUnload(DriverObject);  // deallocate our things
    return status;
  }
#endif  // not pnp

  // Initialize the Driver Object with driver's entry points
  DriverObject->DriverUnload = SerialUnload;
  DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = SerialFlush;
  DriverObject->MajorFunction[IRP_MJ_WRITE]  = SerialWrite;
  DriverObject->MajorFunction[IRP_MJ_READ]   = SerialRead;
  DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SerialIoControl;
#ifdef NT50
  DriverObject->DriverExtension->AddDevice  = SerialAddDevice;
  DriverObject->MajorFunction[IRP_MJ_PNP]   = SerialPnpDispatch;
  DriverObject->MajorFunction[IRP_MJ_POWER] = SerialPowerDispatch;
  DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
      SerialInternalIoControl;
#endif
  // these appear to change in 5.0, but not working yet(see serial.sys)....
  DriverObject->MajorFunction[IRP_MJ_CREATE] = SerialCreateOpen;
  DriverObject->MajorFunction[IRP_MJ_CLOSE]  = SerialClose;

  DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SerialCleanup;
  DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
      SerialQueryInformationFile;
  DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] =
      SerialSetInformationFile;

#ifdef NT50
  // pnp
  //---- Log the fact that the driver loaded
  EventLog(DriverObject, STATUS_SUCCESS, SERIAL_NT50_INIT_PASS, 0, NULL);
  return STATUS_SUCCESS;
#endif

#ifndef NT50
# ifdef S_RK
  //--------------- Connect to IRQ, or start Timer.
  StartRocketIRQorTimer();
# else
  RcktInitPollTimer();
  KeSetTimer(&Driver.PollTimer,
             Driver.PollIntervalTime,
             &Driver.TimerDpc);
# endif
  //---- Log the fact that the driver loaded and found some hardware.
  EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_PASS, 0, NULL);
  return STATUS_SUCCESS;
#endif
}

#ifndef NT50
/*----------------------------------------------------------------------
 StartNT40 - Fire up our boards and ports.
|----------------------------------------------------------------------*/
static NTSTATUS StartNT40(IN PDRIVER_OBJECT DriverObject)
{
 NTSTATUS status = STATUS_SUCCESS;
 int i, dstat;
 PSERIAL_DEVICE_EXTENSION ext;
 PSERIAL_DEVICE_EXTENSION board_ext;
  
  if (Driver.NumDevices == 0)  // no rocketports setup.
  {
    Eprintf("No boards configured, run setup.");
    EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_FAIL, 0, NULL);
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }
    //--------Create the driver device object which serves as
    // extensions to link and structure the boards together, and
    // also serve as a special public object for debug and monitor Ioctls.
  if (Driver.driver_ext == NULL)
  {
    status = CreateDriverDevice(Driver.GlobalDriverObject,
                                NULL);  // 
    if (status)
    {
      if (Driver.VerboseLog)
        Eprintf("Err D1.");
      return status;
    }
  }

#ifdef S_VS
    // get our Ethernet running
  i = init_eth_start();
  if (i != STATUS_SUCCESS)
  {
    if (Driver.VerboseLog)
      Eprintf("Err, E1.");
    return i;
  }
#endif

    //--------Create the board device objects which serve as
    // extensions to link and structure the ports together.
  for (i=0; i<Driver.NumDevices; i++)
  {
    status = CreateBoardDevice(DriverObject, NULL);
    if (status)
    {
      if (Driver.VerboseLog)
        Eprintf("Err B1.");
      return status;
    }
  }

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    read_device_options(board_ext);

    if (board_ext->config->NumPorts == 0)
        board_ext->config->NumPorts = 8;

    board_ext = board_ext->board_ext;
  }

#ifdef S_RK
    // rocketport specific startup code.  Setup some of
    // the config structs, look for PCI boards in system, match them up.
  status = init_cfg_rocket(DriverObject);
  if (status != STATUS_SUCCESS)
  {
    if (Driver.VerboseLog)
      Eprintf("Err C1.");
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }
  //------ setup moree rocket hardware specific information
  if (SetupRocketCfg(0) != 0)
  {
    VerboseLogBoards("B -");
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

  //SetupRocketIRQ();

  //------ Report our RocketPort resource usage to NT, and get IO permissions
  ext = Driver.board_ext;
  while(ext)
  {
    if (RocketReportResources(ext) != 0)
    {
      VerboseLogBoards("C -");
      EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_RESOURCE_CONFLICT,0, NULL);
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
    ext = ext->board_ext;  // next
  }
#endif

  //------ Fire up the boards.
  ext = Driver.board_ext;
  while(ext)
  {
# ifdef S_RK
    dstat = InitController(ext);
    if (dstat != 0)
    {
      VerboseLogBoards("D -");
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
# else
    status = VSSpecialStartup(ext);
    if (status != STATUS_SUCCESS)
    {
      if (Driver.VerboseLog)
        Eprintf("Hdlc open fail\n");
      status = STATUS_SERIAL_NO_DEVICE_INITED;
      return status;
    }
# endif
    ext->FdoStarted = 1;  // tell ISR that its on.
    ext->config->HardwareStarted = TRUE;  // tell ISR its ready to go
    ext = ext->board_ext;  // next
  }

  //----- make the port devices
  MyKdPrint(D_Init,("CreatePortDevices\n"))
  status = CreatePortDevices(DriverObject);
  if (status != STATUS_SUCCESS)
  {
# ifdef S_RK
    VerboseLogBoards("E -");
# else
    if (Driver.VerboseLog)
      Eprintf("Err, P1.");
# endif
    EventLog(DriverObject, STATUS_SUCCESS, SERIAL_DEVICEOBJECT_FAILED, 0, NULL);
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

#ifdef S_RK
  //------ If modem boards, initialize modems..
  ext = Driver.board_ext;
  while (ext)
  {
    // pull SocketModem devices out of reset state
    InitSocketModems(ext);

    // load RocketModemII devices...
    InitRocketModemII(ext);
    ext = ext->board_ext;  // next
  }
#endif

  return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\hdlc.h ===
/*----
// hdlc.h
 6-18-97  change timing on timeouts to 1.0 sec base.
------*/

#define HDLC_TRACE_outs(c)

#define HDLC_DEB_outs(s,l) 

// define a circular queue for incoming packets.
// queue uses an extra tail end head room of MAX_PKT_SIZE to avoid having to
// perform to much sypherin concerning queue room.
#define HDLC_TX_PKT_QUEUE_SIZE 9

// control fields for hdlc header control field
#define CONTROL_IFRAME        0
#define CONTROL_UFRAME        1
#define CONTROL_CONNECT_ASK   3
#define CONTROL_CONNECT_REPLY 5
/*--------------------------------------------
 Hdlc struct - main struct for HDLC support(layer 2)
----------------------------------------------*/
typedef struct {
  //LanPort *lp;  // our layer 1 handle.
  Nic *nic;  // nic card we are bound to on lower end
  PVOID context;  // upper layer can put handle here

  BYTE dest_addr[6];  // dest. address(needed for ack/seq. timeouts)

  WORD phys_outpkt_len[HDLC_TX_PKT_QUEUE_SIZE];
  //----- circular que of outgoing data packets
  Queue qout;

  // packet and buffer pool handles, basically points to the
  // tx-buffer space in qout.
  NDIS_HANDLE TxPacketPool;
  NDIS_HANDLE TxBufferPool;
  // queue of packets setup for use
  PNDIS_PACKET TxPackets[HDLC_TX_PKT_QUEUE_SIZE];

  // control packet and buffer pool handles, basically points to the
  // tx-buffer space in qout_ctl.
  NDIS_HANDLE TxCtlPacketPool;
  NDIS_HANDLE TxCtlBufferPool;
  // queue of packets setup for use
  PNDIS_PACKET TxCtlPackets[2];
  //----- circular que of outgoing control packets
  Queue qout_ctl;

  //----- timer statistics
  DWORD  rec_ack_timeouts;  // # of rec-ack-timeouts
  DWORD  send_ack_timeouts;  // # of send-ack-timeouts

  //----- outgoing statistics
  DWORD iframes_resent;    // cout of all resent iframes
  DWORD iframes_sent;    // count of every sent iframe
  DWORD ctlframes_sent;  // count of every sent control frame
  DWORD rawframes_sent;  // count of every sent raw frame
  DWORD iframes_outofseq;  // statistics, error count
  //DWORD ErrBadHeader; // statistics, error count

  //----- incoming statistics
  DWORD frames_rcvd;      // 

  //------ packet driver handle
  WORD status;

      // sent out on each packet, increment by one each time a new packet
      // is sent out.  The receiver uses this to check for packet sequence
      // order.  This value is copied into the snd_index field when we are
      // ready to send a packet.  A sync-message will set this to an
      // initial working value of 0.
  BYTE out_snd_index;

      // last good rx ack_index received.  The receiver will send us a
      // acknowledge index(ack_index field) indicating the last good
      // received packet index it received.  This allows us to remove
      // all packets up to this index number from our transmit buffer
      // since they have been acknowledged.  Until this point we must
      // retain the packet for retransmition in case the receiver does
      // not acknowledge reception after a timeout period.
  BYTE in_ack_index;

      // last good rx snd_index on received packet.  All packets received
      // should have a snd_index value equal to +1 of this value.  So this
      // value is used to check for consequative incrementing index values
      // on the packets received.  On sync-message this value is set to
      // 0xff.
  BYTE next_in_index;  

     // used to measure how many incoming pkts received which are
     // unacknowledged so we can trip a acknowledgement at 80% full
  BYTE unacked_pkts;

      // tick counter used to timeout sent packets and the expected
      // acknowledgement.
  WORD sender_ack_timer;

      // tick counters used to check that connection is still active
      // periodically to recover from device power-cycle or hdlc
      // sequence level failure.  If it ticks up past X many minutes
      // then a iframe packet is sent(and a iframe response is expected
      // back.  If it ticks past (X*2) minutes, then failure is declared
      // and server re-initializes the box.
  WORD tx_alive_timer;  // ticks up, reset every acked-reclaim of sent iframe.
  WORD rx_alive_timer;  // ticks up, reset on every received iframe.

  WORD tick_timer;  // used to generate 10Hz timer signal used for timeouts.

      // tick counter used to timeout rec. packets and our responsibility
      // to send and ack on them
  WORD rec_ack_timer;

  WORD pkt_window_size; // 1 to 8, num tx packets before ack

  WORD state;        // state of hdlc level, see defines
  WORD old_state;    // old state of hdlc level(used to reset timer)
  WORD sub_state;    // sub_state of a particular state
  WORD state_timer;  // state timer

  // following function ptrs is a general method for linking
  // layers together.
  ULONG (*upper_layer_proc) (PVOID context, int message_id, ULONG message_data);
  ULONG (*lower_layer_proc) (PVOID context, int message_id, ULONG message_data);
} Hdlc;

//--- layer 2 HDLC events used in _proc() calls
// layer 2(hdlc) assigned range from 200-299
#define EV_L2_RESYNC        200
#define EV_L2_RX_PACKET     201
#define EV_L2_TX_PACKET     202
#define EV_L2_BOOT_REPLY    203
#define EV_L2_ADMIN_REPLY   204
#define EV_L2_RELOAD        205
#define EV_L2_CHECK_LINK    206

// packet sequence timeout values
#define MIN_ACK_REC_TIME       10   // 10th seconds (1.0 sec)
#define KEEP_ALIVE_TIMEOUT     300  // 10th seconds (30.0 sec)

// state field defines
//#define ST_HDLC_OFF          0  // HDLC is off, won't do anything.
//#define ST_HDLC_DISCONNECTED 1  // HDLC is turned on, will allow connections
//#define ST_HDLC_CONNECTED    2  // HDLC is connected up and active

// status field bit values
#define LST_RESYNC        0x0001  // set if we need to re-sync the packet index
// #define LST_SEND_NAK   0x0002  // set if we need to update other side with index
#define LST_RECLAIM       0x0004  // set if we should attempt to reclaim tx packets
#define LST_SEND_ACK      0x0008  // set if we need to send immediate ACK

//------------------ public functions
int hdlc_open(Hdlc *hd, BYTE *box_mac_addr);
int hdlc_close(Hdlc *hd);

#define ERR_GET_EMPTY      1  // empty
#define ERR_GET_BAD_INDEX  2  // error, packet out of sequence
#define ERR_GET_BADHDR     3  // error, not our packet
#define ERR_CONTROL_PACKET 4  // hdlc control packet only, no data
int hdlc_validate_rx_pkt(Hdlc *hd, BYTE *buf);

int hdlc_send_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr);
int hdlc_send_ctl_outpkt(Hdlc *hd, int data_len, BYTE *dest_addr);

int hdlc_get_outpkt(Hdlc *hd, BYTE **buf);
int hdlc_get_ctl_outpkt(Hdlc *hd, BYTE **buf);

int hdlc_send_raw(Hdlc *hd, int data_len, BYTE *dest_addr);
int hdlc_resend_outpkt(Hdlc *hd);
void hdlc_resync(Hdlc *hd);
void hdlc_poll(Hdlc *hd);
int hdlc_close(Hdlc *hd);

int hdlc_send_control(Hdlc *hd, BYTE *header_data, int header_len,
                      BYTE *data, int data_len, BYTE *dest_addr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\initrk.h ===
// initrk.h
extern char *szResourceClassName;  // used in pnprckt.c

void InitRocketModemII(PSERIAL_DEVICE_EXTENSION ext);

UCHAR  FindPCIBus(void);
int FindPCIRockets(UCHAR NumPCI);
int FindPCIRocket(DEVICE_CONFIG *config, int match_option);
NTSTATUS RcktConnectInt(IN PDRIVER_OBJECT DriverObject);
void VerboseLogBoards(char *prefix);
int SetupRocketCfg(int pnp_flag);
int ConfigAIOP(DEVICE_CONFIG *config);
VOID SerialUnReportResourcesDevice(IN PSERIAL_DEVICE_EXTENSION Extension);
int RocketReportResources(IN PSERIAL_DEVICE_EXTENSION extension);
int InitController(PSERIAL_DEVICE_EXTENSION ext);
void StartRocketIRQorTimer(void);
void SetupRocketIRQ(void);
NTSTATUS init_cfg_rocket(IN PDRIVER_OBJECT DriverObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\initc.h ===
// initc.h

VOID SerialUnload (IN PDRIVER_OBJECT DriverObject);
NTSTATUS CreateDriverDevice(IN PDRIVER_OBJECT DriverObject,
                            OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension);
NTSTATUS CreateBoardDevice(IN PDRIVER_OBJECT DriverObject,
                           OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension);
NTSTATUS CreatePortDevices(IN PDRIVER_OBJECT DriverObject);
NTSTATUS CreateReconfigPortDevices(IN PSERIAL_DEVICE_EXTENSION board_ext,
           int new_num_ports);
NTSTATUS StartPortHardware(IN PSERIAL_DEVICE_EXTENSION port_ext,
                           int chan_num);
NTSTATUS CreatePortDevice(
           IN PDRIVER_OBJECT DriverObject,
           IN PSERIAL_DEVICE_EXTENSION ParentExtension,
           OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension,
           IN int chan_num,
           IN int is_fdo);
VOID RcktDeleteDriverObj(IN PSERIAL_DEVICE_EXTENSION extension);
VOID RcktDeleteDevices(IN PDRIVER_OBJECT DriverObject);
VOID RcktDeleteBoard(IN PSERIAL_DEVICE_EXTENSION extension);
VOID RcktDeletePort(IN PSERIAL_DEVICE_EXTENSION extension);
VOID SerialCleanupDevice (IN PSERIAL_DEVICE_EXTENSION Extension);
PVOID SerialGetMappedAddress(
        IN INTERFACE_TYPE BusType,
        IN ULONG BusNumber,
        PHYSICAL_ADDRESS IoAddress,
        ULONG NumberOfBytes,
        ULONG AddressSpace,
        PBOOLEAN MappedAddress,
        BOOLEAN DoTranslation);
VOID SerialSetupExternalNaming (IN PSERIAL_DEVICE_EXTENSION Extension);
VOID SerialCleanupExternalNaming(IN PSERIAL_DEVICE_EXTENSION Extension);
VOID SerialLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1);
VOID EventLog(
    IN PDRIVER_OBJECT DriverObject,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1, 
    IN PWCHAR Insert1);
VOID InitPortsSettings(IN PSERIAL_DEVICE_EXTENSION extension);
NTSTATUS RcktInitPollTimer(void);
void InitSocketModems(PSERIAL_DEVICE_EXTENSION ext);
int DeterminePortName(void);
int clear_com_db(char *szComport);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\init.h ===
//--- init.h(common for vs and rk)

// use 2.04.03 format 3 part optional for non-released versions)
// use 2.05    format 2 part for released changes
#ifdef S_RK
  #ifdef NT50
    #define VER_PRODUCTVERSION_STR "4.50"
    #define VER_PRODUCTVERSION      4,50
  #else
    #define VER_PRODUCTVERSION_STR "4.50"
    #define VER_PRODUCTVERSION      4,50
  #endif
#else
  #ifdef NT50
    #define VER_PRODUCTVERSION_STR "2.50"
    #define VER_PRODUCTVERSION      2,50
  #else
    #define VER_PRODUCTVERSION_STR "2.50"
    #define VER_PRODUCTVERSION      2,50
  #endif
#endif

// these are now turned on or off in the sources file in rk or vs dir
//#define ROCKET
//#define VS1000
//#define NT50

// make the ExAllocatePool call "WDM-compatible" - use pool tags version
// with our tag "Rckt" (little endian format)

#ifdef NT50
  #ifdef POOL_TAGGING
    #ifdef ExAllocatePool
      #undef ExAllocatePool
    #endif
    #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'tkcR')
  #endif
#endif

//	
//	define paths to Rockwell modem firmware...
//
#define	MODEM_CSREC_PATH	"\\SystemRoot\\system32\\ROCKET\\ctmmdmfw.rm"
#define	MODEM_CSM_SREC_PATH	"\\SystemRoot\\system32\\ROCKET\\ctmmdmld.rm"

//#define TRY_DYNAMIC_BINDING

// define to allow modem download for new pci rocketmodem 56k product(no flash)
#define MDM_DOWNLOAD

// these should be on, they are left in just in case(will strip out in future)
#define RING_FAKE
#define USE_SYNC_LOCKS
#define NEW_WAIT
#define NEW_WRITE_SYNC_LOCK
#define NEW_WAIT_SYNC_LOCK

#ifdef S_RK
// we can only use this on rocketport
#define NEW_FAST_TX
#endif

#define TRACE_PORT
#define USE_HAL_ASSIGNSLOT

// pnp bus-driver stuff
#define DO_BUS_EXTENDER

// attempted io-aliasing solution for nt5.0 to properly get resources
// for isa-bus cards using alias io space
#define DO_ISA_BUS_ALIAS_IO

#define GLOBAL_ASSERT
#define GLOBAL_TRACE
#define TRACE_PORT

#ifdef S_VS
#define MAX_NUM_BOXES 64
#else
#define MAX_NUM_BOXES 8
#endif

#define MAX_PORTS_PER_DEVICE 64

//---- following used to trace driver activity
//#define D_L0        0x00001L
//#define D_L2        0x00004L
//#define D_L4        0x00010L
//#define D_L6        0x00040L
//#define D_L7        0x00080L
//#define D_L8        0x00100L
//#define D_L9        0x00200L
//#define D_L10       0x00400L
//#define D_L11       0x00800L
#define D_Error     0x08000L
#define D_All       0xffffffffL

#define D_Nic       0x00002L
#define D_Hdlc      0x00008L
#define D_Port      0x00020L

#define D_Options      0x01000L
//---- following used to trace driver activity
#define D_Init         0x00010000L
#define D_Pnp          0x00020000L
#define D_Ioctl        0x00040000L
#define D_Write        0x00080000L
#define D_Read         0x00100000L
#define D_Ssci         0x00200000L
#define D_Thread       0x00400000L
#define D_Test         0x00800000L
#define D_PnpAdd       0x01000000L
#define D_PnpPower     0x02000000L

//Constant definitions for the I/O error code log values.
//  Values are 32 bit values layed out as follows:
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//  where
//      Sev - is the severity code
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//      C - is the Customer code flag
//      R - is a reserved bit
//      Facility - is the facility code
//      Code - is the facility's status code

// Define the facility codes
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4

// Define the severity codes
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3
#ifdef S_RK
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0x80060001L)
#else
#define SERIAL_RP_INIT_FAIL              ((NTSTATUS)0xC0060001L)
#endif
#define SERIAL_RP_INIT_PASS              ((NTSTATUS)0x40060002L)
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060003L)
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060004L)
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060005L)
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060006L)
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060007L)
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060008L)
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060009L)
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC006000AL)
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC006000BL)
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC006000CL)
#define SERIAL_RP_RESOURCE_CONFLICT      ((NTSTATUS)0xC006000DL)
#define SERIAL_RP_HARDWARE_FAIL          ((NTSTATUS)0xC006000EL)
#define SERIAL_DEVICEOBJECT_FAILED       ((NTSTATUS)0xC006000FL)
#define SERIAL_CUSTOM_ERROR_MESSAGE      ((NTSTATUS)0xC0060010L)
#define SERIAL_CUSTOM_INFO_MESSAGE       ((NTSTATUS)0x40060011L)
#define SERIAL_NT50_INIT_PASS            ((NTSTATUS)0x40060012L)

// max number of nic cards we will allow
#define VS1000_MAX_NICS 6

#ifdef GLOBAL_ASSERT
#define GAssert(id, exp ) { if (!(exp)) our_assert(id, __LINE__); }
#else
#define GAssert(id, exp )
#endif

#ifdef GLOBAL_TRACE

#define GTrace3(_Mask,_LeadStr, _Msg,_P1,_P2, _P3) \
  { if (Driver.GTraceFlags & _Mask) TTprintf(_LeadStr, _Msg, _P1, _P2, _P3); }

#define GTrace2(_Mask,_LeadStr, _Msg,_P1,_P2) \
  { if (Driver.GTraceFlags & _Mask) TTprintf(_LeadStr, _Msg, _P1, _P2); }

#define GTrace1(_Mask,_LeadStr, _Msg,_P1) \
  { if (Driver.GTraceFlags & _Mask) TTprintf(_LeadStr, _Msg, _P1); }

#define GTrace(_Mask_, _LeadStr, _Msg_) \
  { if (Driver.GTraceFlags & _Mask_) OurTrace(_LeadStr, _Msg_); }
//#define GMark(c, x)
#else
#define GTrace2(_Mask,_LeadStr, _Msg,_P1, _P2) {}
#define GTrace1(_Mask,_LeadStr, _Msg,_P1) {}
#define GTrace(_Mask_, _LeadStr, _Msg_) {}
//#define GMark(c, x) {}
#endif

// following are for debug, when checked build is made DBG is defined
// and the messages go to our debug queue and the nt debug string output.
#if DBG
#define DTrace3(_Mask_,_LeadStr,_Msg_,_P1_,_P2_,_P3_) \
  { if (RocketDebugLevel & _Mask_) TTprintf(_LeadStr,_Msg_,_P1_,_P2_,_P3_); }

#define DTrace2(_Mask_,_LeadStr,_Msg_,_P1_,_P2_) \
  { if (RocketDebugLevel & _Mask_) TTprintf(_LeadStr,_Msg_,_P1_,_P2_); }

#define DTrace1(_Mask_,_LeadStr,_Msg_,_P1_) \
  { if (RocketDebugLevel & _Mask_) TTprintf(_LeadStr,_Msg_,_P1_); }

#define DTrace(_Mask_,_LeadStr,_Msg_) \
  { if (RocketDebugLevel & _Mask_) OurTrace(_LeadStr, _Msg_); }

#define DPrintf(_Mask_,_Msg_) \
  { if (RocketDebugLevel & _Mask_) Tprintf _Msg_; }
#else
#define DTrace3(_Mask,_LeadStr, _Msg,_P1, _P2, _P3) {}
#define DTrace2(_Mask,_LeadStr, _Msg,_P1, _P2) {}
#define DTrace1(_Mask,_LeadStr, _Msg,_P1) {}
#define DTrace(_Mask_, _LeadStr, _Msg_) {}
#define DPrintf(_Mask_,_Msg_) {}
#endif


#ifdef TRACE_PORT

#define ExtTrace4(_Ext_,_Mask_,_Msg_,_P1_,_P2_,_P3_, _P4_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_,_P2_,_P3_,_P4_); }

#define ExtTrace3(_Ext_,_Mask_,_Msg_,_P1_,_P2_,_P3_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_,_P2_,_P3_); }

#define ExtTrace2(_Ext_,_Mask_,_Msg_,_P1_,_P2_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_,_P2_); }

#define ExtTrace1(_Ext_,_Mask_,_Msg_,_P1_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_,_P1_); }

#define ExtTrace(_Ext_,_Mask_,_Msg_) \
  { if (_Ext_->TraceOptions & 1) Tprintf(_Msg_); }
#else
#define ExtTrace3(_Mask_,_Msg_,_P1_,_P2_,_P3_) {}
#define ExtTrace2(_Mask_,_Msg_,_P1_,_P2_) {}
#define ExtTrace1(_Mask_,_Msg_,_P1_) {}
#define ExtTrace(_Mask_,_Msg_) {}
#endif

#if DBG
#define MyAssert( exp ) { if (!(exp)) MyAssertMessage(__FILE__, __LINE__); }

# ifdef S_VS
#define MyKdPrint(_Mask_,_Msg_) \
  { \
    if (_Mask_ & RocketDebugLevel) { \
      DbgPrint ("VS:"); \
      DbgPrint _Msg_; \
    } \
  } 
# else
#define MyKdPrint(_Mask_,_Msg_) \
  { \
    if (_Mask_ & RocketDebugLevel) { \
      DbgPrint ("RK:"); \
      DbgPrint _Msg_; \
    } \
  } 
# endif
#define MyKdPrintUnicode(_Mask_,_PUnicode_)\
  if(_Mask_ & RocketDebugLevel) \
    {  \
    ANSI_STRING tempstr; \
    RtlUnicodeStringToAnsiString(&tempstr,_PUnicode_,TRUE); \
    DbgPrint("%s",tempstr.Buffer);\
    RtlFreeAnsiString(&tempstr); \
    }
#else    
#define MyAssert( exp ) {}
#define MyKdPrint(_Mask_,_Msg_) {}
#define MyKdPrintUnicode(_Mask_,_PUnicode_) {}
#endif //DBG

#define SERIAL_NONE_PARITY  ((UCHAR)0x00)
#define SERIAL_ODD_PARITY   ((UCHAR)0x08)
#define SERIAL_EVEN_PARITY  ((UCHAR)0x18)
#define SERIAL_MARK_PARITY  ((UCHAR)0x28)
#define SERIAL_SPACE_PARITY ((UCHAR)0x38)
#define SERIAL_PARITY_MASK  ((UCHAR)0x38)

// This should be enough space to hold the numeric suffix of the device name.
// #define DEVICE_NAME_DELTA 20

// Default xon/xoff characters.
#define SERIAL_DEF_XON  0x11
#define SERIAL_DEF_XOFF 0x13

// Reasons that reception may be held up.
#define SERIAL_RX_DTR       ((ULONG)0x01)
#define SERIAL_RX_XOFF      ((ULONG)0x02)
#define SERIAL_RX_RTS       ((ULONG)0x04)
#define SERIAL_RX_DSR       ((ULONG)0x08)

// Reasons that transmission may be held up.
#define SERIAL_TX_CTS       ((ULONG)0x01)
#define SERIAL_TX_DSR       ((ULONG)0x02)
#define SERIAL_TX_DCD       ((ULONG)0x04)
#define SERIAL_TX_XOFF      ((ULONG)0x08)
#define SERIAL_TX_BREAK     ((ULONG)0x10)
#define ST_XOFF_FAKE        ((ULONG)0x20)  // added for SETXOFF(kpb)

// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
#define SERIAL_COMPLETE_READ_CANCEL ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE ((LONG)-3)

//--- flags for MdmCountry (ROW country code)
#define ROW_NOT_USED        0
#define ROW_AUSTRIA         1
#define ROW_BELGIUM         2
#define ROW_DENMARK         3
#define ROW_FINLAND         4
#define ROW_FRANCE          5
#define ROW_GERMANY         6
#define ROW_IRELAND         7
#define ROW_ITALY           8
#define ROW_LUXEMBOURG      9
#define ROW_NETHERLANDS     10
#define ROW_NORWAY          11
#define ROW_PORTUGAL        12
#define ROW_SPAIN           13
#define ROW_SWEDEN          14
#define ROW_SWITZERLAND     15
#define ROW_UK              16
#define ROW_GREECE          17
#define ROW_ISRAEL          18
#define ROW_CZECH_REP       19
#define ROW_CANADA          20
#define ROW_MEXICO          21
#define ROW_USA             22         
#define ROW_NA              ROW_USA         
#define ROW_HUNGARY         23
#define ROW_POLAND          24
#define ROW_RUSSIA          25
#define ROW_SLOVAC_REP      26
#define ROW_BULGARIA        27
// 28
// 29
#define ROW_INDIA           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define ROW_AUSTRALIA       40
#define ROW_CHINA           41
#define ROW_HONG_KONG       42
#define ROW_JAPAN           43
#define ROW_PHILIPPINES     ROW_JAPAN
#define ROW_KOREA           44
// 45
#define ROW_TAIWAN          46
#define ROW_SINGAPORE       47
#define ROW_NEW_ZEALAND     48

#define ROW_DEFAULT         ROW_USA



// Ext->DeviceType:  // DEV_PORT, DEV_DRIVER, DEV_BOARD
#define DEV_PORT   0
#define DEV_BOARD  1

/* Configuration information structure for one port */
typedef struct {
  char Name[12];
  ULONG LockBaud;
  ULONG TxCloseTime;
  int WaitOnTx : 1;
  int RS485Override : 1;
  int RS485Low : 1;
  int Map2StopsTo1 : 1;
  int MapCdToDsr : 1;
  int RingEmulate : 1;
} PORT_CONFIG;


/* Configuration information structure for one board or vs1000("device") */
typedef struct
{
#ifdef S_RK
   unsigned int MudbacIO;              /* I/O address of MUDBAC */
   PUCHAR pMudbacIO;                   /* NT ptrs to I/O address of MUDBAC */
   unsigned int BaseIoAddr;   // normal io-address
   unsigned int TrBaseIoAddr; // translated io-address
   PUCHAR       pBaseIoAddr;  // final indirect mapped handle for io-address
   unsigned int BaseIoSize;            /* 44H for 1st isa, 40 for isa addition, etc */
   unsigned int ISABrdIndex;           /* 0 for first, 1 for second, etc(isa only) */
   unsigned int AiopIO[AIOP_CTL_SIZE]; /* I/O addresses of AIOPs */
   PUCHAR pAiopIO[AIOP_CTL_SIZE];      /* NT ptrs to I/O address of AIOPs */
   //int NumChan;                        /* number of channels on this controller */
   // use NumPorts instead
   int NumAiop;                        /* number of Aiops on board */
   unsigned int RocketPortFound;       /* indicates ctl was found and init'd */
   INTERFACE_TYPE BusType;             /* PCIBus or Isa */
   int PCI_DevID;
   int PCI_RevID;
   int PCI_SVID;
   int PCI_SID;

   int Irq;
   int InterruptMode;
   int IrqLevel;
   int IrqVector;
   int Affinity;

   int TrInterruptMode;
   int TrIrqLevel;
   int TrIrqVector;
   int TrAffinity;

   int PCI_Slot;
   int BusNumber;

   int IsRocketPortPlus;  // true if rocketport plus hardware
#else
   int IsHubDevice;  // true if device(RHub) uses slower baud clock
#endif

  BOOLEAN HardwareStarted;

  BYTE MacAddr[6];      // vs1000
  int BackupServer;     // vs1000
  int BackupTimer;      // vs1000

  //int StartComIndex;   // starting com-port index
  ULONG Hardware_ID;     // software derived hardware id(used for nt50 now)
  ULONG IoAddress;      // user interface io-address selection

  int ModemDevice;       // true for RocketModems & Vs2000
  int NumPorts;         // configured number of ports on this device

  ULONG ClkRate;  // def:36864000=rcktport, 44236800=rplus, 18432000=rhub
  ULONG ClkPrescaler;  // def:14H=rcktport, 12H=rplus, 14H=rhub

#ifdef NT50
       // this holds the pnp-name we use as a registry key to hold
       // our device parameters in the registry for RocketPort & NT50
  char szNt50DevObjName[50];  // typical: "Device_002456
#else
  int  DevIndex;  // nt40 keeps simple linear list of devices 0,1,2...
#endif

  PORT_CONFIG port[MAX_PORTS_PER_DEVICE];  // our read in port configuration

} DEVICE_CONFIG;

#define TYPE_RM_VS2000  1       
#define TYPE_RMII       2       
#define TYPE_RM_i       3


// forward declaration
typedef struct _SERIAL_DEVICE_EXTENSION *PSERIAL_DEVICE_EXTENSION;

typedef struct _SERIAL_DEVICE_EXTENSION {
    USHORT DeviceType;  // DEV_PORT, DEV_BOARD
    USHORT BoardNum;    // 0,1,2,3 for DEV_BOARD type

    BOOLEAN         IsPDO;  // a nt50 pnp thing, tells if we are a pdo or fdo
    char NtNameForPort[32];     // like "RocketPort0"
    char SymbolicLinkName[16];  // like "COM5"
#ifdef S_VS
    //int box_num;  // index into box & hdlc array
    SerPort *Port;  // if a DEV_PORT type extension
    PortMan *pm;    // if a DEV_BOARD type extension
    Hdlc    *hd;    // if a DEV_BOARD type extension

    //int DeviceNum;  // index into total port array
#else
    CHANPTR_T ChP;                  // ptr to channel structure
    CHANNEL_T ch;                   // our board channel structure
#endif
    unsigned int UniqueId; // 0,1,2,3... CreateBoardDevice() bumps...

    // if we are DEV_BOARD, the this points to next board extension
    // if we are DEV_PORT, then it points to our parent board
    PSERIAL_DEVICE_EXTENSION   board_ext;

    // if we are DEV_BOARD, the this points to start of port extensions
    // if we are DEV_PORT, then it points to next port extension
    PSERIAL_DEVICE_EXTENSION   port_ext;  // next port extension

    // if we are DEV_BOARD, the this points to start of pdo port extensions
    PSERIAL_DEVICE_EXTENSION   port_pdo_ext;  // next pdo port extension

    ULONG BaudRate;                 // NT defined baud rate      
    SERIAL_LINE_CONTROL LineCtl;    // NT defined line control
    ULONG ModemStatus;              // NT defined modem status
    ULONG DTRRTSStatus;             // NT defined modem status

    USHORT DevStatus;     // device status

    //unsigned int FlowControl;
    //unsigned int DetectEn;
#ifdef S_RK
    USHORT io_reported; // flag to tell if we have io,irq to unreport.
    ULONG EventModemStatus;         // used to detect change for events
    unsigned int ModemCtl;
    unsigned int IntEnables;		// RP specific ints to enable
#endif
    int PortIndex;      // if port: index into ports on board(0,1,2..)

#ifdef TXBUFFER
    //PUCHAR TxBuf;
    //LONG TxIn;
    //LONG TxOut;
    //LONG TxBufSize;
#endif
    Queue RxQ;

    // Used to keep ISR from completing a read while it is being started.
    BOOLEAN ReadPending;

      // This value is set by the read code to hold the time value
      // used for read interval timing.  We keep it in the extension
      // so that the interval timer dpc routine determine if the
      // interval time has passed for the IO.
    LARGE_INTEGER IntervalTime;

      // These two values hold the "constant" time that we should use
      // to delay for the read interval time.
    LARGE_INTEGER ShortIntervalAmount;
    LARGE_INTEGER LongIntervalAmount;

      // This holds the value that we use to determine if we should use
      // the long interval delay or the short interval delay.
    LARGE_INTEGER CutOverAmount;

      // This holds the system time when we last time we had
      // checked that we had actually read characters.  Used
      // for interval timing.
    LARGE_INTEGER LastReadTime;

      // This points the the delta time that we should use to
      // delay for interval timing.
    PLARGE_INTEGER IntervalTimeToUse;

      // Points to the device object that contains
      // this device extension.
    PDEVICE_OBJECT DeviceObject;

      // This list head is used to contain the time ordered list
      // of read requests.  Access to this list is protected by
      // the global cancel spinlock.
    LIST_ENTRY ReadQueue;

      // This list head is used to contain the time ordered list
      // of write requests.  Access to this list is protected by
      // the global cancel spinlock.
    LIST_ENTRY WriteQueue;

      // Holds the serialized list of purge requests.
    LIST_ENTRY PurgeQueue;

      // This points to the irp that is currently being processed
      // for the read queue.  This field is initialized by the open to
      // NULL.
      // This value is only set at dispatch level.  It may be
      // read at interrupt level.
    PIRP CurrentReadIrp;

      // This points to the irp that is currently being processed
      // for the write queue.
      // This value is only set at dispatch level.  It may be
      // read at interrupt level.
    PIRP CurrentWriteIrp;

      // Points to the irp that is currently being processed to
      // purge the read/write queues and buffers.
    PIRP CurrentPurgeIrp;

      // Points to the current irp that is waiting on a comm event.
    PIRP CurrentWaitIrp;

      // Points to the irp that is being used to count the number
      // of characters received after an xoff (as currently defined
      // by the IOCTL_SERIAL_XOFF_COUNTER ioctl) is sent.
    PIRP CurrentXoffIrp;

      // Holds the number of bytes remaining in the current write irp.
      // This location is only accessed while at interrupt level.
    ULONG WriteLength;

      // The syncronization between the various threads in this
      // driver is hosed up in places, besides being really confusing.
      // This is an attempt to have a protected flag which is set
      // to 1 if the ISR owns the currentwriteirp, 2 if the ISR
      // is in the progress of ending the IRP(going to serialcompletewrite),
      // and 0 when it is complete.  The starter routine sets it
      // from 0 to 1 to give a new irp to the isr/timer routine for
      // processing.  The ISR sets it from 1 to 2 when it queues
      // the DPC to finalize the irp.  The DPC sets it from 2 to
      // 0 when it completes the irp.  The cancel or timer routines
      // must run a synchronized routine which guarentees sole access
      // to this flag.  Looks if it is 1, if it is 1 then it takes
      // by setting it to zero, and returning a flag to indicate to
      // the caller to finalize the irp.  If it is a 2, it assumes
      // the isr has arranged to finalize the irp.  Geez-O-Pete
      // what a lot of silly gears!
    ULONG WriteBelongsToIsr;

      // Holds a pointer to the current character to be sent in
      // the current write.
      // This location is only accessed while at interrupt level.
    PUCHAR WriteCurrentChar;

      // This variable holds the size of whatever buffer we are currently
      // using.
    ULONG BufferSize;

      // This variable holds .8 of BufferSize. We don't want to recalculate
      // this real often - It's needed when so that an application can be
      // "notified" that the buffer is getting full.
    ULONG BufferSizePt8;

      // This value holds the number of characters desired for a
      // particular read.  It is initially set by read length in the
      // IRP.  It is decremented each time more characters are placed
      // into the "users" buffer buy the code that reads characters
      // out of the typeahead buffer into the users buffer.  If the
      // typeahead buffer is exhausted by the read, and the reads buffer
      // is given to the isr to fill, this value is becomes meaningless.
    ULONG NumberNeededForRead;

      // This mask will hold the bitmask sent down via the set mask
      // ioctl.  It is used by the interrupt service routine to determine
      // if the occurence of "events" (in the serial drivers understanding
      // of the concept of an event) should be noted.
    ULONG IsrWaitMask;

      // This mask will always be a subset of the IsrWaitMask.  While
      // at device level, if an event occurs that is "marked" as interesting
      // in the IsrWaitMask, the driver will turn on that bit in this
      // history mask.  The driver will then look to see if there is a
      // request waiting for an event to occur.  If there is one, it
      // will copy the value of the history mask into the wait irp, zero
      // the history mask, and complete the wait irp.  If there is no
      // waiting request, the driver will be satisfied with just recording
      // that the event occured.  If a wait request should be queued,
      // the driver will look to see if the history mask is non-zero.  If
      // it is non-zero, the driver will copy the history mask into the
      // irp, zero the history mask, and then complete the irp.
    ULONG HistoryMask;

      // This is a pointer to the where the history mask should be
      // placed when completing a wait.  It is only accessed at
      // device level.
      // We have a pointer here to assist us to synchronize completing a wait.
      // If this is non-zero, then we have wait outstanding, and the isr still
      // knows about it.  We make this pointer null so that the isr won't
      // attempt to complete the wait.
      // We still keep a pointer around to the wait irp, since the actual
      // pointer to the wait irp will be used for the "common" irp completion
      // path.
    ULONG *IrpMaskLocation;
    ULONG WaitIsISRs;  // 1=owned by isr.c(expicit help)
    ULONG DummyIrpMaskLoc;  // Point the IrpMaskLocation here when not in use

      // This mask holds all of the reason that transmission
      // is not proceeding.  Normal transmission can not occur
      // if this is non-zero.
      // This is only written from interrupt level.
      // This could be (but is not) read at any level.
    ULONG TXHolding;

      // This mask holds all of the reason that reception
      // is not proceeding.  Normal reception can not occur
      // if this is non-zero.
      // This is only written from interrupt level.
      // This could be (but is not) read at any level.
    ULONG RXHolding;

      // This holds the reasons that the driver thinks it is in
      // an error state.
      // This is only written from interrupt level.
      // This could be (but is not) read at any level.
    ULONG ErrorWord;

      // This keeps a total of the number of characters that
      // are in all of the "write" irps that the driver knows
      // about.  It is only accessed with the cancel spinlock
      // held.
    ULONG TotalCharsQueued;

      // This holds a count of the number of characters read
      // the last time the interval timer dpc fired.  It
      // is a long (rather than a ulong) since the other read
      // completion routines use negative values to indicate
      // to the interval timer that it should complete the read
      // if the interval timer DPC was lurking in some DPC queue when
      // some other way to complete occurs.
    LONG CountOnLastRead;

      // This is a count of the number of characters read by the
      // isr routine.  It is *ONLY* written at isr level.  We can
      // read it at dispatch level.
    ULONG ReadByIsr;

      // This is the number of characters read since the XoffCounter
      // was started.  This variable is only accessed at device level.
      // If it is greater than zero, it implies that there is an
      // XoffCounter ioctl in the queue.
    LONG CountSinceXoff;

      // Holds the timeout controls for the device.  This value
      // is set by the Ioctl processing.
      // It should only be accessed under protection of the control
      // lock since more than one request can be in the control dispatch
      // routine at one time.
    SERIAL_TIMEOUTS Timeouts;

      // This holds the various characters that are used
      // for replacement on errors and also for flow control.
      // They are only set at interrupt level.
    SERIAL_CHARS SpecialChars;

      // This structure holds the handshake and control flow
      // settings for the serial driver.
      // It is only set at interrupt level.  It can be
      // be read at any level with the control lock held.
    SERIAL_HANDFLOW HandFlow;

      // We keep track of whether the somebody has the device currently
      // opened with a simple boolean.  We need to know this so that
      // spurious interrupts from the device (especially during initialization)
      // will be ignored.  This value is only accessed in the ISR and
      // is only set via synchronization routines.  We may be able
      // to get rid of this boolean when the code is more fleshed out.
    BOOLEAN DeviceIsOpen;

      // Records whether we actually created the symbolic link name
      // at driver load time.  If we didn't create it, we won't try
      // to distry it when we unload.
    BOOLEAN CreatedSymbolicLink;

      // We place all of the kernel and Io subsystem "opaque" structures
      // at the end of the extension.  We don't care about their contents.
      // This lock will be used to protect various fields in
      // the extension that are set (& read) in the extension
      // by the io controls.
    KSPIN_LOCK ControlLock;

      // This points to a DPC used to complete read requests.
    KDPC CompleteWriteDpc;

      // This points to a DPC used to complete read requests.
    KDPC CompleteReadDpc;

      // This dpc is fired off if the timer for the total timeout
      // for the read expires.  It will execute a dpc routine that
      // will cause the current read to complete.
    KDPC TotalReadTimeoutDpc;

      // This dpc is fired off if the timer for the interval timeout
      // expires.  If no more characters have been read then the
      // dpc routine will cause the read to complete.  However, if
      // more characters have been read then the dpc routine will
      // resubmit the timer.
    KDPC IntervalReadTimeoutDpc;

      // This dpc is fired off if the timer for the total timeout
      // for the write expires.  It will execute a dpc routine that
      // will cause the current write to complete.
    KDPC TotalWriteTimeoutDpc;

      // This dpc is fired off if a comm error occurs.  It will
      // execute a dpc routine that will cancel all pending reads
      // and writes.
    KDPC CommErrorDpc;

      // This dpc is fired off if an event occurs and there was
      // a irp waiting on that event.  A dpc routine will execute
      // that completes the irp.
    KDPC CommWaitDpc;

      // This dpc is fired off if the timer used to "timeout" counting
      // the number of characters received after the Xoff ioctl is started
      // expired.
    KDPC XoffCountTimeoutDpc;

      // This dpc is fired off if the xoff counter actually runs down
      // to zero.
    KDPC XoffCountCompleteDpc;

      // This is the kernal timer structure used to handle
      // total read request timing.
    KTIMER ReadRequestTotalTimer;

      // This is the kernal timer structure used to handle
      // interval read request timing.
    KTIMER ReadRequestIntervalTimer;

      // This is the kernal timer structure used to handle
      // total time request timing.
    KTIMER WriteRequestTotalTimer;

      // This timer is used to timeout the xoff counter
      // io.
    KTIMER XoffCountTimer;

    USHORT sent_packets;   // number of write() packets
    USHORT  rec_packets;    // number of read() packets

    SERIALPERF_STATS OurStats;  // our non-resetable stats
    SERIALPERF_STATS OldStats;  // performance monitor statistics(resetable)

    USHORT TraceOptions;  // Debug Trace Options. 1=trace, 2=in data, 4=out dat
       // 8 = isr level events

    USHORT ISR_Flags;  // bit flags used to control ISR, detects EV_TXEMPTY
        // used by NT virt-driver to embed modem status changes in input stream
    unsigned char escapechar; 
    unsigned char Option;  // used for per port options
                                 
    void *TraceExt;  // Debug Trace Extension

    PORT_CONFIG *port_config; // if a port extension, points to port config data
    DEVICE_CONFIG *config;    // if a board extension, points to config data

    //KEVENT SerialSyncEvent;
#ifdef S_RK
    CONTROLLER_T *CtlP; // if a board extension, points to controller struct
#endif

    // This is to tell the driver that we have received a QUERY_POWER asking 
    // to power down.  The driver will then queue any open requests until after
    // the power down.
    BOOLEAN ReceivedQueryD3;
#ifdef NT50
    PDEVICE_OBJECT  Pdo;  // new PnP object used to open registry.
    PDEVICE_OBJECT  LowerDeviceObject;  // new PnP stack arrangement.
    // This is where keep track of the power state the device is in.
    DEVICE_POWER_STATE PowerState;

    // String where we keep the symbolic link that is returned to us when we
    // register our device under the COMM class with the Plug and Play manager.
    //
	UNICODE_STRING  DeviceClassSymbolicName;
#endif
    // Count of pending IRP's
    ULONG PendingIRPCnt;
    
    // Accepting requests?
    ULONG DevicePNPAccept;

    // No IRP's pending event
    KEVENT PendingIRPEvent;

    // PNP State
    ULONG PNPState;

    // Used by PnP.c module
    //BOOLEAN DeviceIsOpened;

    BOOLEAN FdoStarted;

#ifdef RING_FAKE
    BYTE ring_char;   // used to implement RING emulation via software
    BYTE ring_timer;  // used to implement RING emulation via software
#endif

#ifdef NT50
    // WMI Information
    WMILIB_CONTEXT WmiLibInfo;

    // Name to use as WMI identifier
    UNICODE_STRING WmiIdentifier;

    // WMI Comm Data
    SERIAL_WMI_COMM_DATA WmiCommData;

    // WMI HW Data
    SERIAL_WMI_HW_DATA WmiHwData;

    // WMI Performance Data
    SERIAL_WMI_PERF_DATA WmiPerfData;
#endif

} SERIAL_DEVICE_EXTENSION,*PSERIAL_DEVICE_EXTENSION;

//--- bits for Option field in extension
#define OPTION_RS485_OVERRIDE    0x0001  // always use 485 mode
#define OPTION_RS485_SOFTWARE_TOGGLE 0x0002  // port in toggle mode
#define OPTION_RS485_HIGH_ACTIVE  0x0004  // use hardware to toggle rts low

//--- bit flags for ISR_Flags
#define TX_NOT_EMPTY       0x0001

#define SERIAL_PNPACCEPT_OK       0x0L
#define SERIAL_PNPACCEPT_REMOVING 0x1L
#define SERIAL_PNPACCEPT_STOPPING 0x2L
#define SERIAL_PNPACCEPT_STOPPED  0x4L

#define SERIAL_PNP_ADDED          0x0L
#define SERIAL_PNP_STARTED        0x1L
#define SERIAL_PNP_QSTOP          0x2L
#define SERIAL_PNP_STOPPING       0x3L
#define SERIAL_PNP_QREMOVE        0x4L
#define SERIAL_PNP_REMOVING       0x5L

#define SERIAL_FLAGS_CLEAR	  0x0L
#define SERIAL_FLAGS_STARTED      0x1L

typedef struct _DRIVER_CONTROL {

    PDRIVER_OBJECT GlobalDriverObject;

    // copy of RegistryPath into DriverEntry, with room for adding options
    UNICODE_STRING RegPath;

    // working global RegistryPath string, , with room for adding options
    UNICODE_STRING OptionRegPath;

    // head link of all board extensions
    PSERIAL_DEVICE_EXTENSION board_ext;

    USHORT VerboseLog;   // boolean flag tells to log verbose to eventlog.
    USHORT ScanRate;     // scan rate in milliseconds
    USHORT PreScaler;    // optional prescaler value for rocketport boards

    USHORT MdmCountryCode; // country code for ROW RocketModems
    USHORT MdmSettleTime;  // time to allow modems to settle (unit=0.10 sec)

    ULONG  load_testing;  // load testing(creates artificial load in isr.c)
#ifdef S_VS

    // This is the names of the NIC cards which we get from the Registry.
    // Used to specify the nic card when we do an OpenAdapter call.
    char *BindNames;  // list of strings, null, null terminated [VS1000_MAX_BINDINGS];

#ifdef OLD_BINDING_GATHER
    PWCHAR BindString;  // binding in registry, tells us what nic cards we have

    // This is the names of the NIC cards which we get from the Registry.
    // Used to specify the nic card when wee do an OpenAdapter call.
    UNICODE_STRING NicName[VS1000_MAX_BINDINGS];

    int num_nics;  // number of nic cards in system which we use

    int num_bindings;  // number of nic card bindings in our NicName list
      // there may be lots of old useless bindings with NT, PCI adapters
      // leave an old binding resident for each slot they are booted in
      // under nt50, pcmcia adapters also have inactive bindings.

#endif

#ifdef TRY_DYNAMIC_BINDING
    // bind passes in a handle as a reference, when we get an un-bind
    // we get passed in another handle.  At unbind time, we look up in
    // this table to figure which nic card it references.
    NDIS_HANDLE  BindContext[VS1000_MAX_NICS];
#endif

    Nic *nics;    // our open nic adapters, array of Nic structs.

    //Hdlc *hd;     // array of Hdlc structs(NumBoxes # of elements)
    //PortMan *pm;  // array of PortMan structs(NumBoxes # of elements)
    //SerPort *sp;  // total array of serial-port structs(1 per port)

      // tells if thread needs to save off a detected mac-address back
      // to config reg area.
    PSERIAL_DEVICE_EXTENSION AutoMacDevExt; 
#endif

#ifdef S_RK
    ULONG SetupIrq;  // Irq used, 0 if none, 1 if PCI automatic
#endif
    PKINTERRUPT InterruptObject;

    // Timer fields
    KTIMER PollTimer;
    LARGE_INTEGER PollIntervalTime;
    KDPC TimerDpc;
    //USHORT TotalNTPorts;  // count of ports registered with NT
    ULONG PollCnt;  // count of interrupts/timer ticks
    ULONG WriteDpcCnt;
    USHORT TimerCreated;
    USHORT InRocketWrite;

    ULONG TraceOptions;  // bit flags, tells what driver parts to trace
    ULONG TraceFlags;
    Queue DebugQ;        // data output buffer for driver debug log
    PSERIAL_DEVICE_EXTENSION DebugExt;
    KSPIN_LOCK DebugLock;
    ULONG DebugTimeOut;  // used to timeout inactive debug sessions.

#ifdef S_RK
    USHORT RS485_Flags;  // 1H bit set if Reverse hardware type
                         //       clear if driver toggles RTS high
#endif

    ULONG GTraceFlags;  // trace flags, global.
    ULONG mem_alloced;  // track how much memory we are using

#ifdef S_VS
    UCHAR *MicroCodeImage;  // mem buf for micro code to download to unit
    ULONG MicroCodeSize;    // size of it in bytes

    // This is the handle for the protocol returned by ndisregisterprotocol
    NDIS_HANDLE NdisProtocolHandle;
    ULONG ndis_version;  // 3=NT3.51, 4=NT4.0(includes dynamic binding)

      // for auto-find boxes, make a list of boxes which respond with
      // there mac address.  Keep 2 extra bytes, byte [6] is for
      // flags in response tells us if main-driver-app loaded, 
      // while last byte[7] we stuff with the nic-index which responded.
    int   NumBoxMacs;
    BYTE  BoxMacs[MAX_NUM_BOXES*8];
    // following is a counter per mac-address added to list where
    // the list entry will be removed after it ticks down to zero.
    // when the mac-address is added to the list or found again,
    // the counter is initialized to some non-zero value(say 5)
    // and then each time a broadcast query is sent out, all the
    // counters are decremented by 1.  When they hit zero, they
    // are removed from the list.
    BYTE  BoxMacsCounter[MAX_NUM_BOXES];
#else

    UCHAR *ModemLoaderCodeImage;	// --> mem buf for modem loader code to download to unit
    ULONG ModemLoaderCodeSize;		// size in bytes

    UCHAR *ModemCodeImage;		// --> mem buf for modem code to download to unit
    ULONG ModemCodeSize;		// size in bytes
#endif

    int NoPnpPorts;  // flag to tell if we should eject port pdo's
#ifdef S_RK
    PSERIAL_DEVICE_EXTENSION irq_ext; // board ext doing global irq, null if not used
#endif
    //int NT50_PnP;

    int NumDevices; // configuration count of NumDevices for NT4.0
    int Stop_Poll;  // flag to stop poll access

    KSPIN_LOCK TimerLock;   // Timer DPC(ISR) lock to sync up code
#ifdef S_VS
    HANDLE threadHandle;
    int threadCount;
    //int TotalNTPorts;  // this should go away(vs uses it)
#endif
   LARGE_INTEGER IsrSysTime;  // ISR service routine gets this every time
                              // so we know what are time base is.
   LARGE_INTEGER LastIsrSysTime;  // used to recalculate the tick rate periodically
   ULONG TickBaseCnt;  // used to recalculate the tick rate periodically
     // this is the isr-tick rate in 100us units.  Timers called by the
     // isr-service routine can assume they are called periodically based
     // on this rate.  Needed for accurate time bases(VS protocol timers).
   ULONG Tick100usBase;

   // one of these made, and is used to support the global driver
   // object which the applications can open and talk to driver.
   PSERIAL_DEVICE_EXTENSION   driver_ext;

} DRIVER_CONTROL;

typedef struct {
	char	*imagepath;
	char	*imagetype;
	UCHAR	*image;
	ULONG	imagesize;
	int		rc;
} MODEM_IMAGE;

/* Configuration information structure for one port */
typedef struct {
  ULONG BusNumber;
  ULONG PCI_Slot;
  ULONG PCI_DevID;
  ULONG PCI_RevID;
  ULONG BaseIoAddr;
  ULONG Irq;
  ULONG NumPorts;
  ULONG PCI_SVID;
  ULONG PCI_SID;
  ULONG Claimed;  // 1 if we assigned or used it.
} PCI_CONFIG;

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PSERIAL_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    );

typedef struct _SERIAL_UPDATE_CHAR {
    PSERIAL_DEVICE_EXTENSION Extension;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PSERIAL_DEVICE_EXTENSION Extension;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// Return values for mouse detection callback
//
//#define SERIAL_FOUNDPOINTER_PORT   1
//#define SERIAL_FOUNDPOINTER_VECTOR 2

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//
#define SERIAL_REF_ISR         (0x00000001)
#define SERIAL_REF_CANCEL      (0x00000002)
#define SERIAL_REF_TOTAL_TIMER (0x00000004)
#define SERIAL_REF_INT_TIMER   (0x00000008)
#define SERIAL_REF_XOFF_REF    (0x00000010)


#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PLONG _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       GAssert(515,!(*_arg4 & _refType)); \
       *_arg4 |= _refType; \
   } while (0)

#define SERIAL_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PLONG _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       *_arg4 &= ~_refType; \
   } while (0)
       //GAssert(516,*_arg4 & _refType); \  (pull out, not valid, kpb, 1-18-98)

//#define SERIAL_INC_REFERENCE(Irp) \
//   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

//#define SERIAL_DEC_REFERENCE(Irp) \
//   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))

extern ULONG RocketDebugLevel;
extern DRIVER_CONTROL Driver;   // driver related options and references

#ifdef S_RK
extern PCI_CONFIG PciConfig[MAX_NUM_BOXES+1];  // array of all our pci-boards in sys
#endif

extern  int	LoadModemCode(char *firm_pathname,char *flm_pathname);
extern  void FreeModemFiles();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\initc.c ===
/*----------------------------------------------------------------------
  initc.c - init, common code(pull out of custom init.c, put in here)
 1-27-99 - take out "\device\" in hardware\serialcomm reg entries, kpb.
 1-20-99 - adjust unique_id in CreatePortDevice to start names at "RocketPort0".
 1-25-99 - adjust again from "\Device\RocketPort0" to "RocketPort0".  kpb.
|----------------------------------------------------------------------*/
#include "precomp.h"

//------------ local variables -----------------------------------
static int CheckPortName(IN OUT char *name,
                         IN PSERIAL_DEVICE_EXTENSION extension);
static int IsPortNameInHardwareMap(char *name);

static char *szDosDevices = {"\\DosDevices\\"};
static char *szDevice     = {"\\Device\\"};
#ifdef S_RK
static char *szRocket = {"rocket"};
static char *szRocketSys = {"rocketsys"};
#else
char *szRocket = {"vslinka"};
char *szRocketSys = {"vslinkasys"};

#endif

typedef struct
{
  char  *response[2];
  int   response_length[2];
  int   nextstate[2];
} MSTATE_CHOICE;

static USHORT ErrNum = 1;  // used with event logging

#define SEND_CMD_STRING(portex,string) \
  ModemWrite(portex,(char *)string,sizeof(string) - 1)

#define SEND_CMD_DELAY_STRING(portex,string) \
  ModemWriteDelay(portex,(char *)string,sizeof(string) - 1)

#define READ_RESPONSE_STRINGS(portex,s0,s1,retries) \
  ModemReadChoice(portex,(char *)s0,sizeof(s0) - 1,(char *)s1,sizeof(s1) - 1,retries)

#define READ_RESPONSE_STRING(portex,string,retries) \
  ModemRead(portex,(char *)string,sizeof(string) - 1,retries)

#define  ONE_SECOND     10
#define  TWO_SECONDS    (2 * ONE_SECOND)
#define  THREE_SECONDS  (3 * ONE_SECOND)
#define  FOUR_SECONDS   (4 * ONE_SECOND)
#define  FIVE_SECONDS   (5 * ONE_SECOND)
#define  TENTH_SECOND   (ONE_SECOND / 10)
#define  HALF_SECOND    (ONE_SECOND / 2)

#define  MAX_MODEM_ATTEMPTS 3

#ifdef S_RK

#define  MAX_STALL                      50              // fifo stall count

#define RMODEM_FAILED           0
#define RMODEM_NOT_LOADED       1
#define RMODEM_LOADED           2

#define VERSION_CHAR            'V'

char ChecksumString[16];
int      gModemToggle = 0;

typedef struct {
  int                   status;
  unsigned long index;
  PSERIAL_DEVICE_EXTENSION  portex;
} MODEM_STATE;


//------------ local variables -----------------------------------
void    ModemTxFIFOWait(PSERIAL_DEVICE_EXTENSION ext);
void    ModemResetAll(PSERIAL_DEVICE_EXTENSION ext);
void    ChecksumAscii(unsigned short *valueptr);
int     IssueEvent(PSERIAL_DEVICE_EXTENSION ext,int (*modemfunc)(),MODEM_STATE *pModemState);
void    DownModem(MODEM_STATE *pModemState);
#endif


/*----------------------------------------------------------------------
SerialUnload -
    This routine cleans up all of the memory associated with
    any of the devices belonging to the driver.  It  will
    loop through the device list.
Arguments:
    DriverObject - Pointer to the driver object controling all of the
        devices.
Return Value:
    None.
|----------------------------------------------------------------------*/
VOID SerialUnload (IN PDRIVER_OBJECT DriverObject)
{
  PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
  // char full_sysname[40];
#ifdef S_VS
  int i;
#endif //S_VS

#ifdef S_RK
  if (Driver.InterruptObject != NULL)
  {
    CONTROLLER_T *CtlP;                 /* ptr to controller structure */
    // Disable interupts from RocketPort clear the EOI and
    CtlP = Driver.irq_ext->CtlP;
    if(CtlP->BusType == Isa)
    {
   MyKdPrint(D_Init,("Clear ISA IRQ\n"))
   sDisGlobalInt(CtlP);
   sControllerEOI(CtlP);
    }
    if(CtlP->BusType == PCIBus)
    {
   MyKdPrint(D_Init,("Clear PCI IRQ\n"))
   sDisGlobalIntPCI(CtlP);
   sPCIControllerEOI(CtlP);
    }

    IoDisconnectInterrupt(Driver.InterruptObject);
    Driver.InterruptObject = NULL;
  }
#endif

#ifdef S_VS
  if (Driver.threadHandle != NULL)
  {
    Driver.threadHandle = NULL;  // tell thread to kill itself
    time_stall(15);  // wait 1.5 second
  }
#endif

  if (Driver.TimerCreated != 0)
  {
    KeCancelTimer(&Driver.PollTimer);
    Driver.TimerCreated = 0;
  }

  if (DriverObject->DeviceObject != NULL)
  {
    // delete all the Deviceobjects and symbolic links
    RcktDeleteDevices(DriverObject);
    DriverObject->DeviceObject = NULL;
  }

#ifdef S_VS
  if (Driver.MicroCodeImage != NULL)
  {
    our_free(Driver.MicroCodeImage, "MCI");
    Driver.MicroCodeImage = NULL;
  }

  if (Driver.nics != NULL)
  {
    for (i=0; i<VS1000_MAX_NICS; i++)
    {
      if (Driver.nics[i].NICHandle != NULL) {
        NicClose(&Driver.nics[i]);
      }
    }
    our_free(Driver.nics, "nics");
  }
  Driver.nics = NULL;

  if (Driver.NdisProtocolHandle != NULL)
    NicProtocolClose();
  Driver.NdisProtocolHandle = NULL;

  if (Driver.BindNames != NULL)
      ExFreePool(Driver.BindNames);
  Driver.BindNames = NULL;
#endif

  if (Driver.DebugQ.QBase)
  {
    ExFreePool(Driver.DebugQ.QBase);
    Driver.DebugQ.QBase = NULL;
  }

  if (Driver.RegPath.Buffer != NULL)
  {
    ExFreePool(Driver.RegPath.Buffer);
    Driver.RegPath.Buffer = NULL;
  }

  if (Driver.OptionRegPath.Buffer != NULL)
  {
    ExFreePool(Driver.OptionRegPath.Buffer);
    Driver.OptionRegPath.Buffer = NULL;
  }
}

/*----------------------------------------------------------------------
  CreateDriverDevice - Create "rocket" driver object, this is for access to the
   driver as a whole.  The monitoring program uses this to open up
   a channel to get driver information.
   Creates a symbolic link name to do special IOctl calls
|----------------------------------------------------------------------*/
NTSTATUS CreateDriverDevice(IN PDRIVER_OBJECT DriverObject,
	   OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension)
{
 PDEVICE_OBJECT deviceObject = NULL;
 NTSTATUS       ntStatus;
 PSERIAL_DEVICE_EXTENSION extension = NULL;
 char full_ntname[40];
 char full_symname[40];

  MyKdPrint(D_Init,("CreateDriverDevice\n"))

  // Create an device object
  {
    strcpy(full_ntname,szDevice);     // "\\Device\\"
    strcat(full_ntname,szRocketSys);  // "RocketSys"

    // special name
    strcpy(full_symname,szDosDevices);  // "\\DosDevices\\"
    strcat(full_symname,szRocket);      // "ROCKET" or "VSLINKA"

    ntStatus = IoCreateDevice(
      DriverObject,
      sizeof(SERIAL_DEVICE_EXTENSION),
      CToU1(full_ntname),
//#ifdef NT50
//                 FILE_DEVICE_BUS_EXTENDER,
//#else
      0,  // unknown device?   ,  so make a 0 device(unknown?)
//#endif
      0,      // file characteristics
      FALSE,  // exclusive?
      &deviceObject);  // create this

    if (!NT_SUCCESS(ntStatus))
    {
      MyKdPrint(D_Init,("Err CDD1A\n"))
      switch (ntStatus)
      {
	case STATUS_INSUFFICIENT_RESOURCES:
	  MyKdPrint(D_Init,("Err CDD1B\n"))
	break;

	case STATUS_OBJECT_NAME_EXISTS:
	  MyKdPrint(D_Init,("Err CDD1C\n"))
	break;

	case STATUS_OBJECT_NAME_COLLISION:
	  MyKdPrint(D_Init,("Err CDD1D\n"))
	break;

	default:
	  MyKdPrint(D_Init,("Err CDD1E\n"))
	break;
      }
      return(ntStatus);
    }

    MyKdPrint(D_Init,("CreateDriver DevObj[%x]: NT:%s\n", 
      deviceObject, szRocketSys))

    //
    // Create a symbolic link, e.g. a name that a Win32 app can specify
    // to open the device
    //
    // initialize some of the extension values to make it look like
    // another serial port to fake out the supporting functions
    // ie open,close, ...

    deviceObject->Flags |= DO_BUFFERED_IO;
#ifdef NT50
    //
    // Enables Irp assignments to be accepted
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
#endif

    extension = deviceObject->DeviceExtension;
    // Initialize the list heads for the read, write, and mask queues.
    // These lists will hold all of the queued IRP's for the device.
    InitializeListHead(&extension->ReadQueue);
    InitializeListHead(&extension->WriteQueue);
    InitializeListHead(&extension->PurgeQueue);

    KeInitializeEvent(&extension->PendingIRPEvent, SynchronizationEvent,
      FALSE);

    // init to 1, so on irp enter its 1 to 2, on exit 2 to 1.  0 on pnp stop.
    extension->PendingIRPCnt = 1;

    // Mark this device as not being opened by anyone.  We keep a
    // variable around so that spurious interrupts are easily
    // dismissed by the ISR.
    extension->DeviceIsOpen = FALSE;
    extension->WriteLength = 0;
    extension->DeviceObject = deviceObject;

    strcpy(extension->NtNameForPort, szRocketSys);  // "RocketSys"
    extension->DeviceType = DEV_BOARD;  // really a driver type, but..
    extension->UniqueId = 0;

#ifdef NT50
    extension->PowerState = PowerDeviceD0;
#endif

    //------ add to the global links
    Driver.driver_ext = extension;

    // make the public ROCKET or VSLINKA name for applications
    ntStatus = IoCreateSymbolicLink(CToU1(full_symname),
	     CToU2(full_ntname));

    if (!NT_SUCCESS(ntStatus))
    {
      // Symbolic link creation failed- note this & then delete th
      MyKdPrint(D_Init,("CDD1E\n"))
      return(ntStatus);
    }
    extension->CreatedSymbolicLink = TRUE;

    strcpy(extension->SymbolicLinkName, szRocket);  // "ROCKET"
    //Driver.RocketSysDeviceObject = deviceObject;  //set global device object

    //extension->config = ExAllocatePool(NonPagedPool, sizeof(DEVICE_CONFIG));
    //RtlZeroMemory(extension->config, sizeof(DEVICE_CONFIG));
#ifdef S_RK
    //extension->CtlP = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_T));
    //RtlZeroMemory(extension->config, sizeof(CONTROLLER_T));
#endif
    //------- Pass back the extension to the caller.
    if (DeviceExtension != NULL)
      *DeviceExtension = extension;
  }
  return(ntStatus);
}

/*----------------------------------------------------------------------
  CreateBoardDevice - Create "rocket" driver object, this is for access to the
   driver as a whole.  The monitoring program uses this to open up
   a channel to get driver information.
   Creates a symbolic link name to do special IOctl calls

   Need one for each board so we can use them to do IOReportResources
   per board(needed for diferent buses.)
   The first board device gets a "ROCKET" symbolic link so we can
   open it and query the driver as a whole.
|----------------------------------------------------------------------*/
NTSTATUS CreateBoardDevice(IN PDRIVER_OBJECT DriverObject,
	  OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension)
{
  PDEVICE_OBJECT deviceObject = NULL;
  NTSTATUS       ntStatus;
  PSERIAL_DEVICE_EXTENSION extension = NULL;
  char full_ntname[40];
  char full_symname[40];
  char ntname[40];

  // for naming device objects, resource submitting, etc we need a
  // unique name or id which is unique to the driver.  We used to
  // use board number or port number for this, but with pnp, things
  // come and go on the fly, so instead we create a unique number
  // each time we create one of these things.
  static int unique_id = 0;

  MyKdPrint(D_Init,("CreateBoardDevice\n"))

  // Create an EXCLUSIVE device object (only 1 thread at a time
  // can make requests to this device)
  {
    strcpy(ntname, szRocketSys);
    our_ultoa(unique_id, &ntname[strlen(ntname)], 10);
    strcpy(full_ntname,szDevice);     // "\\Device\\"
    strcat(full_ntname,ntname);  // "RocketPort#"

    full_symname[0] = 0;

    ntStatus = IoCreateDevice(
      DriverObject,
      sizeof(SERIAL_DEVICE_EXTENSION),
      CToU1(full_ntname),
#ifdef NT50
      FILE_DEVICE_BUS_EXTENDER,
#else
      0,  // unknown device?   ,  so make a 0 device(unknown?)
#endif
      0,      // file characteristics
      FALSE,  // exclusive?
      &deviceObject);  // create this

    if (!NT_SUCCESS(ntStatus))
    {
      MyKdPrint(D_Error,("CBD1A\n"))
      switch (ntStatus)
      {
	case STATUS_INSUFFICIENT_RESOURCES:
	  MyKdPrint(D_Error,("CBD1B\n"))
	  break;
	case STATUS_OBJECT_NAME_EXISTS:
	  MyKdPrint(D_Error,("CBD1C\n"))
	  break;
	case STATUS_OBJECT_NAME_COLLISION:
	  MyKdPrint(D_Error,("CBD1D\n"))
	  break;
	default:
	  MyKdPrint(D_Error,("CBD1E\n"))
	  break;
      }
      return(ntStatus);
    }

    ++unique_id;  // go to next id so next call will be different.

    // Create a symbolic link, e.g. a name that a Win32 app can specify
    // to open the device
    //
    // initialize some of the extension values to make it look like
    // another serial port to fake out the supporting functions
    // ie open,close, ...

    deviceObject->Flags |= DO_BUFFERED_IO;
#ifdef NT50
    //
    // Enables Irp assignments to be accepted
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
#endif

    MyKdPrint(D_Init,("CreateBoard DevObj[%x]: NT:%s\n", 
      deviceObject, ntname))

    extension = deviceObject->DeviceExtension;
    // Initialize the list heads for the read, write, and mask queues.
    // These lists will hold all of the queued IRP's for the device.
    InitializeListHead(&extension->ReadQueue);
    InitializeListHead(&extension->WriteQueue);
    //InitializeListHead(&extension->MaskQueue);
    InitializeListHead(&extension->PurgeQueue);

    KeInitializeEvent(&extension->PendingIRPEvent, SynchronizationEvent,
      FALSE);

    // init to 1, so on irp enter its 1 to 2, on exit 2 to 1.  0 on pnp stop.
    extension->PendingIRPCnt = 1;

    // Mark this device as not being opened by anyone.  We keep a
    // variable around so that spurious interrupts are easily
    // dismissed by the ISR.
    extension->DeviceIsOpen = FALSE;
    extension->WriteLength = 0;
    extension->DeviceObject = deviceObject;

    strcpy(extension->NtNameForPort, ntname);  // "RocketSys"
    extension->DeviceType = DEV_BOARD;
    extension->UniqueId = unique_id;

#ifdef NT50
    extension->PowerState = PowerDeviceD0;
#endif

    //------ add to the chain of boards
    if (Driver.board_ext == NULL)
      Driver.board_ext = extension;
    else
    {
      PSERIAL_DEVICE_EXTENSION add_ext;
      add_ext = Driver.board_ext;
      while (add_ext->board_ext != NULL)
	add_ext = add_ext->board_ext;
      add_ext->board_ext = extension;
    }

    extension->SymbolicLinkName[0] = 0;

    extension->config = ExAllocatePool(NonPagedPool, sizeof(DEVICE_CONFIG));
    if ( extension->config == NULL ) {
      return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(extension->config, sizeof(DEVICE_CONFIG));
#ifdef S_RK
    extension->CtlP = ExAllocatePool(NonPagedPool, sizeof(CONTROLLER_T));
    if ( extension->CtlP == NULL ) {
      return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(extension->config, sizeof(CONTROLLER_T));
#endif

#ifdef S_VS
    // allocate the hdlc & port manager structs
    extension->hd = (Hdlc *)our_locked_alloc(sizeof(Hdlc), "Dhd");
    extension->pm = (PortMan *)our_locked_alloc(sizeof(PortMan),"Dpm");
    extension->pm->hd = extension->hd;  // set this up, avoids trouble
#endif

    //------- Pass back the extension to the caller.
    if (DeviceExtension != NULL)
      *DeviceExtension = extension;
  }
  return(ntStatus);
}

/*----------------------------------------------------------------------
CreateReconfigPortDevices -
    This routine attempts to resize a rocketport or vs1000 number of
    ports.
|----------------------------------------------------------------------*/
NTSTATUS CreateReconfigPortDevices(IN PSERIAL_DEVICE_EXTENSION board_ext,
      int new_num_ports)
{
  PSERIAL_DEVICE_EXTENSION newExtension = NULL;
  PSERIAL_DEVICE_EXTENSION next_ext;
  PSERIAL_DEVICE_EXTENSION port_ext;

  int ch;
  NTSTATUS stat;
    // bugbug: if pnp-ports, we should be adding and removing pdo's,
    //  not fdo's.
  int is_fdo = 1;
  int existing_ports;

  MyKdPrint(D_Init,("ReconfigNumPorts"))

  if (board_ext == NULL)
  {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

#ifdef S_RK
  // doesn't make as much sense to redo this on the fly as in VS.
  // rocketport special re-configure startup code would be needed.
  return STATUS_INSUFFICIENT_RESOURCES;
#endif
  // code needs work!  don't allow for nt40 as well....
  return STATUS_INSUFFICIENT_RESOURCES;

#ifdef NT50
  // if we are doing pnp-ports, we probably need to remove the
  // pdo's then inform the os to rescan pdos.
  if (!Driver.NoPnpPorts)
    return STATUS_INSUFFICIENT_RESOURCES;
#endif

  existing_ports = NumPorts(board_ext);

  if (new_num_ports == existing_ports)
    return STATUS_SUCCESS;

  if (new_num_ports == 0)
    return STATUS_INSUFFICIENT_RESOURCES;

  MyKdPrint(D_Init,("ReconfigNumPorts B"))

  ++Driver.Stop_Poll;  // flag to stop poll access

  if (new_num_ports < existing_ports)  // want less ports
  {
    // see if anyones got the ports we want to kill off open.
    port_ext = board_ext->port_ext;
    for (ch=0; ch<existing_ports; ch++)
    {
      if (ch>=new_num_ports)
      {
	if (port_ext->DeviceIsOpen)
	{
	  --Driver.Stop_Poll;  // flag to stop poll access
	  MyKdPrint(D_Error,("Port OpenErr\n"))
	  return STATUS_INSUFFICIENT_RESOURCES;  // no they are open
	}
      }
      port_ext = port_ext->port_ext;
    }

    MyKdPrint(D_Error,("Removing Ports\n"))

    //---- must be ok to kill them off
    port_ext = board_ext->port_ext;
    for (ch=0; ch<existing_ports; ch++)
    {
      next_ext = port_ext->port_ext;
      if (ch>=new_num_ports)
      {
	RcktDeletePort(port_ext);
      }
      port_ext = next_ext;
    }
  }
  else if (new_num_ports > existing_ports)  // want more ports
  {
    for (ch=existing_ports; ch<new_num_ports; ch++)
    {
      stat = CreatePortDevice(Driver.GlobalDriverObject,
			      board_ext,
			      &newExtension,
			      ch,is_fdo);
      if (stat != STATUS_SUCCESS)
      {
	--Driver.Stop_Poll;  // flag to stop poll access
	MyKdPrint(D_Error,("StartErr 8E"))
	return stat;
      }
    }  // loop thru ports
  }  // if more ports
  board_ext->config->NumPorts = new_num_ports;

#ifdef S_VS
  stat = VSSpecialStartup(board_ext);
  if (stat != STATUS_SUCCESS)
  {
    --Driver.Stop_Poll;  // flag to start poll access
    MyKdPrint(D_Error,("StartErr 8F"))
    return stat;
  }
#endif

  --Driver.Stop_Poll;  // flag to stop poll access
  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
CreatePortDevices -
    This routine attempts to initialize all the ports on a multiport board
Arguments:
    DriverObject - Simply passed on to the controller initialization routine.
    ConfigData - A linked list of configuration information for all
      the ports on a multiport card.
    DeviceExtension - Will point to the first successfully initialized
	   port on the multiport card.
Return Value: None.
|----------------------------------------------------------------------*/
NTSTATUS CreatePortDevices(IN PDRIVER_OBJECT DriverObject)
{
  PSERIAL_DEVICE_EXTENSION newExtension = NULL;
  int ch, bd;
  NTSTATUS stat;
  int is_fdo = 1;

  PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  bd = 0;
  while (ext)
  {
    for (ch=0; ch<ext->config->NumPorts; ch++)
    {
      stat = CreatePortDevice(DriverObject,
			      ext,
			      &newExtension,
			      ch,is_fdo);
      if (stat != STATUS_SUCCESS)
	return stat;

      stat = StartPortHardware(newExtension, ch);
      if (stat != STATUS_SUCCESS)
	return stat;
    }
    ++bd;
    ext = ext->board_ext;  // next in chain
  }  // while ext

  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 StartPortHardware -
|----------------------------------------------------------------------*/
NTSTATUS StartPortHardware(IN PSERIAL_DEVICE_EXTENSION port_ext,
	  int chan_num)
{
#ifdef S_VS
  int i;
  PSERIAL_DEVICE_EXTENSION board_ext;

  board_ext = port_ext->board_ext;
  MyKdPrint(D_Pnp, ("StartHrdw bd:%d ch:%d\n", 
     BoardExtToNumber(board_ext), chan_num))

  if (port_ext->Port == NULL)
  {
    port_ext->Port = board_ext->pm->sp[chan_num];
    if (port_ext->Port == NULL)
    {
      MyKdPrint(D_Error,("FATAL Err4F\n"))
      KdBreakPoint();
    }
  }
#else
  CONTROLLER_T *CtlP;                 /* ptr to controller structure */
  PSERIAL_DEVICE_EXTENSION board_ext;
  int aiop_i, ch_i;

  board_ext = port_ext->board_ext;
  //board_num = BoardExtToNumber(board_ext);

  MyKdPrint(D_Pnp,("StartHrdw bd:%d ch:%d\n", 
     BoardExtToNumber(board_ext), chan_num))
  CtlP = board_ext->CtlP;      // point to our board struct

  // Set pointers to the Rocket's info
  port_ext->ChP = &port_ext->ch;

  // bugbug: what about special rocketmodem startup? Should we
  // be doing this for pdo's and fdo's?  Should we have a flag
  // indicating job done?

  aiop_i = chan_num / CtlP->PortsPerAiop;
  ch_i   = chan_num % CtlP->PortsPerAiop;
  if(!sInitChan(CtlP,   // ptr to controller struct
     port_ext->ChP,   // ptr to chan struct
     aiop_i,  // aiop #
     (unsigned char)ch_i))     // chan #
  {
    Eprintf("Err Ch %d on Brd %d", chan_num+1,
      BoardExtToNumber(board_ext)+1);
    return STATUS_INSUFFICIENT_RESOURCES;
  }
#endif

  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 CreatePortDevice -
    Forms and sets up names, creates the device, initializes kernel
    synchronization structures, allocates the typeahead buffer,
    sets up defaults, etc.
Arguments:
    DriverObject - Just used to create the device object.
    ParentExtension - a pnp port this will be null.
    DeviceExtension - Points to the device extension of the successfully
	   initialized controller. We return this handle.
    chan_num - 0,1,2,... port index
    is_fdo - is a functional device object(normal port) as apposed to
      a pdo(physical device object) which is used to pnp enumerate
      "found" hardware by our driver.

Return Value:
    STATUS_SUCCCESS if everything went ok.  A !NT_SUCCESS status
    otherwise.
|----------------------------------------------------------------------*/
NTSTATUS CreatePortDevice(
      IN PDRIVER_OBJECT DriverObject,
      IN PSERIAL_DEVICE_EXTENSION ParentExtension,
      OUT PSERIAL_DEVICE_EXTENSION *DeviceExtension,
      IN int chan_num,  // 0,1,2,... port index
      IN int is_fdo)  // is a functional device object(normal port)
{
  char full_ntname[40];

  char comname[16];
  char ntname[20];
  NTSTATUS status = STATUS_SUCCESS;
  int stat;
  ULONG do_type;
  PUNICODE_STRING pucodename;
  static int unique_id = 0;
  ULONG do_characteristics;
  BOOLEAN do_is_exclusive;

    // Points to the device object (not the extension) created
    // for this device.
  PDEVICE_OBJECT deviceObject;

    // Points to the device extension for the device object
    // (see above) created for the device we are initializing.
  PSERIAL_DEVICE_EXTENSION extension = NULL;

#ifdef S_VS
    strcpy(ntname, "Vslinka");
#else
    strcpy(ntname, "RocketPort");
#endif

  // copy over the name in the configuration for dos-name
  strcpy(comname, ParentExtension->config->port[chan_num].Name);

  // setup the nt io-object nt-name
  if (is_fdo)
  {
    strcpy(full_ntname, szDevice); // "\\Device\\"
  }
  else
  {
    // this is what serenum does for naming its pdo's
    strcpy(full_ntname, "\\Serial\\");
    strcat(ntname, "Pdo");  // just to make sure its unique
  }

  our_ultoa(unique_id, &ntname[strlen(ntname)], 10);
  strcat(full_ntname, ntname);

  if (is_fdo)
  {
    ++unique_id;  // go to next id so next call will be different.
    // normal case(nt40), and a functional device object in nt5
    stat = CheckPortName(comname, NULL);  // ensure name is unique
    if (stat)  // name changed
    {
      // save back the new name to the configuration struct
      strcpy(ParentExtension->config->port[chan_num].Name, comname);
    }
    do_type = FILE_DEVICE_SERIAL_PORT;
    do_characteristics = 0;
    do_is_exclusive = TRUE;
  }
  else
  {
    // nt5 pnp physical device object(spawns a fdo later)
    //do_type = FILE_DEVICE_BUS_EXTENDER;
    do_type = FILE_DEVICE_UNKNOWN;
#ifdef NT50
    // nt4 doesn't know what FILE_AUTOGENERATED_DEVICE_NAME is.
    do_characteristics = FILE_AUTOGENERATED_DEVICE_NAME;
#else
    do_characteristics = 0;
#endif
    do_is_exclusive = FALSE;
    //pucodename = NULL;  // no name if a PDO
  }
  pucodename = CToU1(full_ntname);


  //---------------------------- Create the device object for this device.
  status = IoCreateDevice(
      DriverObject,
      sizeof(SERIAL_DEVICE_EXTENSION),
     pucodename,        // name
     do_type,           // FILE_DEVICE_BUS_EXTENDER, FILE_DEVICE_SERIAL_PORT, etc
     do_characteristics,// characteristics
     do_is_exclusive,   // exclusive
     &deviceObject);    // new thing this call creates

  // If we couldn't create the device object, then there
  // is no point in going on.
  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Init,("Err, IoCreate: NT:%s, SYM:%s\n",
      ntname, comname))

    EventLog(DriverObject,
	     status,
	     SERIAL_DEVICEOBJECT_FAILED,
	     0, NULL);
    return STATUS_INSUFFICIENT_RESOURCES;
  }


  // The device object has a pointer to an area of non-paged
  // pool allocated for this device.  This will be the device extension.
  extension = deviceObject->DeviceExtension;

   // Zero all of the memory associated with the device extension.
  RtlZeroMemory(extension, sizeof(SERIAL_DEVICE_EXTENSION));

  extension->PortIndex = chan_num;  // record the port index 0,1,2..
  // for NT5.0, set this up here so we don't crash.(NT4.0 sets
  // up prior to this.
  extension->port_config = &ParentExtension->config->port[chan_num];
  extension->UniqueId = unique_id;
  if (!is_fdo)
  {
    MyKdPrint(D_Init,("PDO-"))
  }
  MyKdPrint(D_Init,("CreatePort DevObj[%x]: NT:%s, SYM:%s\n",
    deviceObject, ntname, comname))

  // save off a ptr to our parent board extension
  extension->board_ext = ParentExtension;

  {
    PSERIAL_DEVICE_EXTENSION add_ext = NULL;
    if (is_fdo)
    {
      //------ add to the chain of ports under board ext
      if (ParentExtension->port_ext == NULL)
	ParentExtension->port_ext = extension;
      else
	add_ext = ParentExtension->port_ext;
    }
    else  // pdo, ejected pnp enumeration
    {
      //------ add to the chain of pdo-ports under board ext
      if (ParentExtension->port_pdo_ext == NULL)
	ParentExtension->port_pdo_ext = extension;
      else
	add_ext = ParentExtension->port_pdo_ext;
    }
    if (add_ext)
    {
      while (add_ext->port_ext != NULL)
	add_ext = add_ext->port_ext;
      add_ext->port_ext = extension;
    }
  }

  // Initialize the list heads for the read, write, and mask queues.
  // These lists will hold all of the queued IRP's for the device.
  InitializeListHead(&extension->ReadQueue);
  InitializeListHead(&extension->WriteQueue);
  //InitializeListHead(&extension->MaskQueue);
  InitializeListHead(&extension->PurgeQueue);

  // Initialize the spinlock associated with fields read (& set)
  // by IO Control functions.
  KeInitializeSpinLock(&extension->ControlLock);

  // Initialize the timers used to timeout operations.
  KeInitializeTimer(&extension->ReadRequestTotalTimer);
  KeInitializeTimer(&extension->ReadRequestIntervalTimer);
  KeInitializeTimer(&extension->WriteRequestTotalTimer);
  KeInitializeTimer(&extension->XoffCountTimer);

  KeInitializeDpc(&extension->CompleteWriteDpc,
		  SerialCompleteWrite,
		  extension);

  KeInitializeDpc(&extension->CompleteReadDpc,
		  SerialCompleteRead,
		  extension);

  // Timeout Dpc initialization
  KeInitializeDpc(&extension->TotalReadTimeoutDpc,
		  SerialReadTimeout,
		  extension);

  KeInitializeDpc(&extension->IntervalReadTimeoutDpc,
		  SerialIntervalReadTimeout,
		  extension);

  KeInitializeDpc(&extension->TotalWriteTimeoutDpc,
		  SerialWriteTimeout,
		  extension);

  KeInitializeDpc(&extension->CommErrorDpc,
		  SerialCommError,
		  extension);

  KeInitializeDpc(&extension->CommWaitDpc,
		  SerialCompleteWait,
		  extension);

  KeInitializeDpc(&extension->XoffCountTimeoutDpc,
		  SerialTimeoutXoff,
		  extension);

  KeInitializeDpc(&extension->XoffCountCompleteDpc,
		  SerialCompleteXoff,
		  extension);

  // Get a "back pointer" to the device object and specify
  // that this driver only supports buffered IO.  This basically
  // means that the IO system copies the users data to and from
  // system supplied buffers.
  extension->DeviceObject = deviceObject;
  extension->DevStatus = 0;

  deviceObject->Flags |= DO_BUFFERED_IO;
#ifdef NT50
  deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
  if (!is_fdo)  // its a PDO, so adjust stack requirements
  {
    deviceObject->StackSize += ParentExtension->DeviceObject->StackSize;
  }
#endif

  KeInitializeEvent(&extension->PendingIRPEvent, SynchronizationEvent,
    FALSE);

  // init to 1, so on irp enter its 1 to 2, on exit 2 to 1.  0 on pnp stop.
  extension->PendingIRPCnt = 1;

  // Set up the default device control fields.
  // Note that if the values are changed after
  // the file is open, they do NOT revert back
  // to the old value at file close.
  extension->SpecialChars.XonChar = SERIAL_DEF_XON;
  extension->SpecialChars.XoffChar = SERIAL_DEF_XOFF;
  extension->SpecialChars.ErrorChar=0;
  extension->SpecialChars.EofChar=0;
  extension->SpecialChars.EventChar=0;
  extension->SpecialChars.BreakChar=0;

  extension->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
  extension->HandFlow.FlowReplace = SERIAL_RTS_CONTROL;
  extension->BaudRate = 9600;
  extension->LineCtl.Parity = NO_PARITY;
  extension->LineCtl.WordLength = 8;
  extension->LineCtl.StopBits = STOP_BIT_1;
#ifdef S_RK
  extension->ModemCtl=COM_MDM_RTS | COM_MDM_DTR;
  extension->IntEnables =(RXINT_EN | MCINT_EN | CHANINT_EN | TXINT_EN);
#endif
  // We set up the default xon/xoff limits.
  extension->HandFlow.XoffLimit = extension->BufferSize >> 3;
  extension->HandFlow.XonLimit = extension->BufferSize >> 1;
  extension->BufferSizePt8 = ((3*(extension->BufferSize>>2))+
    (extension->BufferSize>>4));

  // Initialize stats counters
  extension->OurStats.ReceivedCount = 0L;
  extension->OurStats.TransmittedCount = 0L;
  extension->OurStats.ParityErrorCount = 0L;
  extension->OurStats.FrameErrorCount = 0L;
  extension->OurStats.SerialOverrunErrorCount = 0L;
  extension->OurStats.BufferOverrunErrorCount = 0L;
    
  // Mark this device as not being opened by anyone.  We keep a
  // variable around so that spurious interrupts are easily
  // dismissed by the ISR.
  extension->DeviceIsOpen = FALSE;
  extension->WriteLength = 0;

#ifdef NT50
  extension->PowerState = PowerDeviceD0;
#endif

  // This call will set up the naming necessary for
  // external applications to get to the driver.  It
  // will also set up the device map.
  strcpy(extension->NtNameForPort, ntname);      // RocketPort# or VSLINKA#
  strcpy(extension->SymbolicLinkName, comname);  // "COM#"

  if (is_fdo)
  {
    SerialSetupExternalNaming(extension);  // Configure ports!!!!

    // Check for default settings in registry
    InitPortsSettings(extension);
  }
  else
  {
    // eject PDOs (physical device objects)representing port hardware.
    extension->IsPDO = 1;  // we are a pdo
  }

  // Store values into the extension for interval timing.
  // If the interval timer is less than a second then come
  // in with a short "polling" loop.
  // For large ( >2 seconds) use a 1 second poller.
  extension->ShortIntervalAmount.QuadPart = -1;
  extension->LongIntervalAmount.QuadPart = -10000000;
  extension->CutOverAmount.QuadPart = 200000000;

  //------- Pass back the extension to the caller.
  *DeviceExtension = extension;

  return STATUS_SUCCESS;
}

/*-----------------------------------------------------------------------
RcktDeleteDriverObj - This routine will delete a board and all its ports
  for PnP remove handling.
|----------------------------------------------------------------------*/
VOID RcktDeleteDriverObj(IN PSERIAL_DEVICE_EXTENSION extension)
{
  //int i;
  //PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION del_ext;

  MyKdPrint(D_Init,("Delete Driver Obj:%x\n", extension->DeviceObject))
  MyKdPrint(D_Init,("  IrpCnt:%x\n", extension->PendingIRPCnt))
  
  if (NULL == extension)
  {
    MyKdPrint(D_Init,("Err8U\n"))
    return;
  }

  ++Driver.Stop_Poll;  // flag to stop poll access

  del_ext = extension;  // now kill board
  SerialCleanupDevice(del_ext);  // delete any port stuff on ext.

#ifdef NT50
  if (del_ext->LowerDeviceObject != NULL)
  {
    IoDetachDevice(del_ext->LowerDeviceObject);
    del_ext->LowerDeviceObject = NULL;
  }
#endif
  
  IoDeleteDevice(del_ext->DeviceObject);

  --Driver.Stop_Poll;  // flag to stop poll access
}

/*----------------------------------------------------------------------
RcktDeleteDevices - This routine will delete all devices
|----------------------------------------------------------------------*/
VOID RcktDeleteDevices(IN PDRIVER_OBJECT DriverObject)
{
  PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
  int i;

  i = 0;
  while(currentDevice)
  {
    PSERIAL_DEVICE_EXTENSION extension = currentDevice->DeviceExtension;
    currentDevice = currentDevice->NextDevice;
    SerialCleanupDevice(extension);
#ifdef NT50
    if (extension->LowerDeviceObject != NULL)
    {
      IoDetachDevice(extension->LowerDeviceObject);
      extension->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteDev Obj:%x\n", extension->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", extension->PendingIRPCnt))
    IoDeleteDevice(extension->DeviceObject);
    i++;
  }
  MyKdPrint(D_Init,("Deleted %d Device Objects\n", i))
}

/*----------------------------------------------------------------------
RcktDeleteBoard - This routine will delete a board and all its ports
  for PnP remove handling.
|----------------------------------------------------------------------*/
VOID RcktDeleteBoard(IN PSERIAL_DEVICE_EXTENSION extension)
{
  int i;
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION del_ext;

  MyKdPrint(D_Init, ("Delete Board\n"))
  if (NULL == extension)
  {
    MyKdPrint(D_Error,("Err9X\n"))
    return;
  }

  ++Driver.Stop_Poll;  // flag to stop poll access

  MyKdPrint(D_Init, ("Delete Ports\n"))
  // release any port things
  ext = extension->port_ext;
  i = 0;
  while (ext)
  {
    del_ext = ext;  // kill this one
    ext = ext->port_ext;  // next in list
    
    SerialCleanupDevice(del_ext);  // delete any allocated stuff on ext.

#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
      IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteBoard Port Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
    i++;
  }
  extension->port_ext = NULL;
  MyKdPrint(D_Init,("Deleted %d Ports\n", i))

  // release any PDO port things
  ext = extension->port_pdo_ext;
  i = 0;
  while (ext)
  {
    del_ext = ext;  // kill this one
    ext = ext->port_ext;  // next in list
    
    SerialCleanupDevice(del_ext);  // delete any port stuff on ext.
#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
      IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteBoard PDO Port Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
    i++;
  }
  extension->port_pdo_ext = NULL;
  MyKdPrint(D_Init,("Deleted PDO %d Ports\n", i))

  del_ext = NULL;
  // take out of linked list  
  ext = Driver.board_ext;
  if (ext == extension)  // first in list
  {
    del_ext = extension;  // kill this board
    Driver.board_ext = extension->board_ext;
  }
  else
  {
    while (ext)
    {
      if (ext->board_ext == extension)  // found in list, so take out of list
      {
   del_ext = extension;  // kill this board
   ext->board_ext = extension->board_ext;  // link around deleted one
   break;
      }
      ext = ext->board_ext;
    }
  }

  MyKdPrint(D_Init,("Delete board_ext:%x, remaining: %d\n",
	 extension, NumDevices()))
    
  if (del_ext != NULL)
  {
    SerialCleanupDevice(del_ext);  // delete any port stuff on ext.

#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
     IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeleteBoard Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
  }

  --Driver.Stop_Poll;  // flag to stop poll access
}

/*----------------------------------------------------------------------
RcktDeletePort - This routine will delete a port and is used for
  PnP remove, start handling.  I don't think we ever delete PDO's,
  (other than driver unload) here.
|----------------------------------------------------------------------*/
VOID RcktDeletePort(IN PSERIAL_DEVICE_EXTENSION extension)
{
  PSERIAL_DEVICE_EXTENSION ext;
  PSERIAL_DEVICE_EXTENSION del_ext;

  MyKdPrint(D_Init,("RcktDeletePort\n"))
  if (NULL == extension)
  {
    MyKdPrint(D_Error,("Err8X\n"))
    return;
  }

  ++Driver.Stop_Poll;  // flag to stop poll access

  MyKdPrint(D_Init, ("Delete Port\n"))
  del_ext = NULL;

  ext = extension->board_ext;  // parent board extension
  while (ext)
  {
    if (ext->port_ext == extension)  // found the one before it
    {
      del_ext = extension;
      ext->port_ext = extension->port_ext;  // skip link to next
      break;
    }
    ext = ext->port_ext;
  }

  if (del_ext != NULL)
  {
    SerialCleanupDevice(del_ext);  // delete any port stuff on ext.

#ifdef NT50
    if (del_ext->LowerDeviceObject != NULL)
    {
      IoDetachDevice(del_ext->LowerDeviceObject);
      del_ext->LowerDeviceObject = NULL;
    }
#endif
    MyKdPrint(D_Init,("RcktDeletePort Obj:%x\n", del_ext->DeviceObject))
    //MyKdPrint(D_Init,("  IrpCnt:%x\n", del_ext->PendingIRPCnt))
    IoDeleteDevice(del_ext->DeviceObject);
    MyKdPrint(D_Init,("Deleted Port\n"))
  }

  --Driver.Stop_Poll;  // flag to stop poll access
}

/*----------------------------------------------------------------------
SerialCleanupDevice -
    This routine will deallocate all of the memory used for
    a particular device.  It will also disconnect any resources
    if need be.
Arguments:
    Extension - Pointer to the device extension which is getting
     rid of all it's resources.
Return Value:
    None.
|----------------------------------------------------------------------*/
VOID SerialCleanupDevice (IN PSERIAL_DEVICE_EXTENSION Extension)
{
  MyKdPrint(D_Test, ("Mem Alloced Start:%d\n", Driver.mem_alloced))

  ++Driver.Stop_Poll;  // flag to stop poll access
  if (Extension)
  {
    if (Extension->DeviceType == DEV_PORT)
    {
      //KeRemoveQueueDpc(&Extension->RocketReadDpc);
      //KeRemoveQueueDpc(&Extension->RocketWriteDpc);

      KeCancelTimer(&Extension->ReadRequestTotalTimer);
      KeCancelTimer(&Extension->ReadRequestIntervalTimer);
      KeCancelTimer(&Extension->WriteRequestTotalTimer);
      KeCancelTimer(&Extension->XoffCountTimer);
      KeRemoveQueueDpc(&Extension->CompleteWriteDpc);
      KeRemoveQueueDpc(&Extension->CompleteReadDpc);

      // Timeout
      KeRemoveQueueDpc(&Extension->TotalReadTimeoutDpc);
      KeRemoveQueueDpc(&Extension->IntervalReadTimeoutDpc);
      KeRemoveQueueDpc(&Extension->TotalWriteTimeoutDpc);

      // Timeout
      KeRemoveQueueDpc(&Extension->CommErrorDpc);
      KeRemoveQueueDpc(&Extension->CommWaitDpc);
      KeRemoveQueueDpc(&Extension->XoffCountTimeoutDpc);
      KeRemoveQueueDpc(&Extension->XoffCountCompleteDpc);
    }
    else  // board device
    {
#ifdef S_VS
      if (Extension->hd)
      {
	hdlc_close(Extension->hd);
	our_free(Extension->hd, "Dhd");
	Extension->hd = NULL;
      }
      if (Extension->pm)
      {
	portman_close(Extension->pm);
	our_free(Extension->pm,"Dpm");
	Extension->pm = NULL;
      }
#endif
#ifdef S_RK
      if (Extension->io_reported)  // tells that we should deallocate on unload.
      {
	SerialUnReportResourcesDevice(Extension);  // give back io,irq resources
	Extension->io_reported = 0;
      }
      if (Extension->CtlP)
      {
	ExFreePool(Extension->CtlP);
	Extension->CtlP = NULL;
      }
#endif
      // free board config if present
      if (Extension->config)
      {
	ExFreePool(Extension->config);
	Extension->config = NULL;
      }
    }  // board dev

    // Get rid of all external naming as well as removing
    // the device map entry.
    SerialCleanupExternalNaming(Extension);
  }  // if not a null extension

  MyKdPrint(D_Test, ("Mem Alloced End:%d\n", Driver.mem_alloced))

  --Driver.Stop_Poll;  // flag to stop poll access
}

#ifdef S_RK
/*------------------------------------------------------------------
SerialGetMappedAddress -
    This routine maps an IO address to system address space.
Arguments:
    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    AddressSpace - Denotes whether the address is in io space or memory.
    MappedAddress - indicates whether the address was mapped.
	 This only has meaning if the address returned
	 is non-null.
Return Value:
    Mapped address
----------------------------------------------------------------------*/
PVOID SerialGetMappedAddress(
   IN INTERFACE_TYPE BusType,
   IN ULONG BusNumber,
   PHYSICAL_ADDRESS IoAddress,
   ULONG NumberOfBytes,
   ULONG AddressSpace,
   PBOOLEAN MappedAddress,
   BOOLEAN DoTranslation)
{
  PHYSICAL_ADDRESS cardAddress;
  PVOID address;

  if (DoTranslation)
  {
    if(!HalTranslateBusAddress(
       BusType,
       BusNumber,
       IoAddress,
       &AddressSpace,
       &cardAddress)){
      // if the translate address call failed return null so we don't load
      address = NULL;
      return address;
    }
  }
  else
  {
    cardAddress = IoAddress;
  }

  // Map the device base address into the virtual address space
  // if the address is in memory space.
  if (!AddressSpace) {
    address = MmMapIoSpace(cardAddress,
			   NumberOfBytes,
			   FALSE);
    *MappedAddress = (BOOLEAN)((address)?(TRUE):(FALSE));
  }
  else
  {
    address = (PVOID)cardAddress.LowPart;
    *MappedAddress = FALSE;
  }
  return address;
}
#endif

/*------------------------------------------------------------------
Routine Description:
    This routine will be used to create a symbolic link
    to the driver name in the given object directory.
    It will also create an entry in the device map for
    this device - IF we could create the symbolic link.
Arguments:
    Extension - Pointer to the device extension.
Return Value:
    None.
-------------------------------------------------------------------*/
VOID SerialSetupExternalNaming (IN PSERIAL_DEVICE_EXTENSION Extension)
{
  char full_ntname[50];
  char full_comname[40];
  NTSTATUS status;

  strcpy(full_ntname, szDevice); // "\\Device\\"
  strcat(full_ntname, Extension->NtNameForPort);  // "Rocket#"

  strcpy(full_comname, szDosDevices); // "\\DosDevices\\"
  strcat(full_comname, Extension->SymbolicLinkName);  // "COM#"

  MyKdPrint(D_Init,("SetupExtName:%s\n", Extension->SymbolicLinkName))

  status = IoCreateSymbolicLink(
	 CToU2(full_comname), // like "\\DosDevices\\COM5"
	 CToU1(full_ntname)); // like "\\Device\\RocketPort0"

  if (NT_SUCCESS(status)) {

	  MyKdPrint( D_Init, ("Symbolic link %s created\n", full_comname ))
  }
  else {

	  MyKdPrint(D_Init,("Err SymLnkCreate.\n"))
    // Oh well, couldn't create the symbolic link.  No point
    // in trying to create the device map entry.
    SerialLogError(
       Extension->DeviceObject->DriverObject,
       Extension->DeviceObject,
       0,
       0,
       0,
       ErrNum++,
       status,
       SERIAL_NO_SYMLINK_CREATED,
       CToU1(Extension->SymbolicLinkName)->Length+sizeof(WCHAR),
       CToU1(Extension->SymbolicLinkName)->Buffer);
    return;
  }

  Extension->CreatedSymbolicLink = TRUE;

  // Add entry to let system and apps know about our ports

    // after V3.23 I added "\device\" into the registry entry(this was wrong)
    // 1-26-99, bugfix, don't add "\device\" into the registry entry,
    // this is not what serial.sys does. kpb.
  status = RtlWriteRegistryValue(
      RTL_REGISTRY_DEVICEMAP,
      L"SERIALCOMM",
      CToU2(Extension->NtNameForPort)->Buffer,  // "RocketPort0"
	//CToU2(full_ntname)->Buffer,  // "\Device\Vslinka0"
      REG_SZ,
      CToU1(Extension->SymbolicLinkName)->Buffer,  // COM#
      CToU1(Extension->SymbolicLinkName)->Length+sizeof(WCHAR));

  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Init,("GenError C2.\n"))
    SerialLogError(Extension->DeviceObject->DriverObject,
		   Extension->DeviceObject,
		   0,
		   0,
		   0,
		   ErrNum++,
		   status,
		   SERIAL_NO_DEVICE_MAP_CREATED,
		   CToU1(Extension->SymbolicLinkName)->Length+sizeof(WCHAR),
		   CToU1(Extension->SymbolicLinkName)->Buffer);
  }
}
   
/*---------------------------------------------------------------------
SerialCleanupExternalNaming -
    This routine will be used to delete a symbolic link
    to the driver name in the given object directory.
    It will also delete an entry in the device map for
    this device if the symbolic link had been created.
Arguments:
    Extension - Pointer to the device extension.
|----------------------------------------------------------------------*/
VOID SerialCleanupExternalNaming(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  char name[60];
  NTSTATUS status;

  // We're cleaning up here.  One reason we're cleaning up
  // is that we couldn't allocate space for the directory
  // name or the symbolic link.
  if (Extension->CreatedSymbolicLink)
  {
    MyKdPrint(D_Init,("KillSymLink:%s\n", Extension->SymbolicLinkName))
    strcpy(name, szDosDevices);  // "\\DosDevices\\"
    strcat(name, Extension->SymbolicLinkName);  // like "COM5"
    IoDeleteSymbolicLink(CToU1(name));
#ifdef NT50

	// Only for ports!

	if (Extension->DeviceType == DEV_PORT &&
		&Extension->DeviceClassSymbolicName != NULL &&
		Extension->DeviceClassSymbolicName.Buffer != NULL) {

      MyKdPrint(D_Init,("KillInterface:%s\n", 
		      UToC1(&Extension->DeviceClassSymbolicName)))
	  status = IoSetDeviceInterfaceState( &Extension->DeviceClassSymbolicName, FALSE );
      if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't clear class association for %s\n",
	   	        UToC1(&Extension->DeviceClassSymbolicName)))
	  }
      else {

        MyKdPrint(D_Init, ("Cleared class association for device: %s\n", 
			    UToC1(&Extension->DeviceClassSymbolicName)))
	  }

	  RtlFreeUnicodeString( &Extension->DeviceClassSymbolicName );
	  Extension->DeviceClassSymbolicName.Buffer = NULL;
	}

#endif
    Extension->CreatedSymbolicLink = 0;
  }

  if (Extension->DeviceType == DEV_PORT)
  {
    // Delete any reg entry to let system and apps know about our ports
    strcpy(name, szDevice); // "\\Device\\"
    strcat(name, Extension->NtNameForPort);  // "Rocket#"
    status = RtlDeleteRegistryValue(
	  RTL_REGISTRY_DEVICEMAP,
	  L"SERIALCOMM",
	  CToU1(Extension->NtNameForPort)->Buffer);  // "RocketPort0"
	  //CToU1(name)->Buffer);
	MyKdPrint(D_Init, ("RtlDeleteRegistryValue:%s\n",Extension->NtNameForPort))

#if NT50
	// Make sure the ComDB binary data is cleared for the specific port.  There 
	// are some problems with W2000 PnP Manager taking care of this in every
	// circumstance.

    (void)clear_com_db( Extension->SymbolicLinkName );
#endif
  }
}

/*-----------------------------------------------------------------------
 SerialLogError - 
    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.
Arguments:
    DriverObject - A pointer to the driver object for the device.
    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.
    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.
    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.
    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.
    RetryCount - The number of times a particular operation has been
    retried.
    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.
    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.
    SpecificIOStatus - The IO status for a particular error.
    LengthOfInsert1 - The length in bytes (including the terminating NULL)
	   of the first insertion string.
Return Value:
    None.
|-----------------------------------------------------------------------*/
VOID SerialLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1)
{
 PIO_ERROR_LOG_PACKET errorLogEntry;

 PVOID objectToUse;
 PUCHAR ptrToFirstInsert;

  if (DeviceObject != NULL)
    objectToUse = DeviceObject;
  else
    objectToUse = DriverObject;

  errorLogEntry = IoAllocateErrorLogEntry(
	 objectToUse,
	 (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + LengthOfInsert1));

  if ( errorLogEntry == NULL)
  {
    MyKdPrint(D_Init,("SerialLogErr, Err A size:%d obj:%x\n",
	  LengthOfInsert1,objectToUse))
    return;
  }

  errorLogEntry->ErrorCode = SpecificIOStatus;
  errorLogEntry->SequenceNumber = SequenceNumber;
  errorLogEntry->MajorFunctionCode = MajorFunctionCode;
  errorLogEntry->RetryCount = RetryCount;
  errorLogEntry->UniqueErrorValue = UniqueErrorValue;
  errorLogEntry->FinalStatus = FinalStatus;
  errorLogEntry->DumpDataSize = 0;

  ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

  if (LengthOfInsert1)
  {
    errorLogEntry->NumberOfStrings = 1;
    errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
		(PUCHAR)errorLogEntry);
    RtlCopyMemory(ptrToFirstInsert,
       Insert1,
       LengthOfInsert1);
  }

  IoWriteErrorLogEntry(errorLogEntry);
}

/*-----------------------------------------------------------------------
 EventLog - To put a shell around the SerialLogError to make calls easier
   to use.
|-----------------------------------------------------------------------*/
VOID EventLog(
    IN PDRIVER_OBJECT DriverObject,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1, 
    IN PWCHAR Insert1)
{
    SerialLogError(
      DriverObject,
      NULL,
      0,
      0,
      0,
      ErrNum++,
      FinalStatus,
      SpecificIOStatus,
      LengthOfInsert1,
      Insert1);
    return;
}

/*-----------------------------------------------------------------------
 InitPortsSettings - Read registry default Port setting
|-----------------------------------------------------------------------*/
VOID InitPortsSettings(IN PSERIAL_DEVICE_EXTENSION extension)
{
  RTL_QUERY_REGISTRY_TABLE paramTable[2];

#define MAX_STRING 256
  WCHAR StrValBuf[MAX_STRING+1];
  char comname[10];

  UNICODE_STRING USReturn;

  USReturn.Buffer = NULL;
  RtlInitUnicodeString(&USReturn, NULL);
  USReturn.MaximumLength = sizeof(WCHAR)*MAX_STRING;
  USReturn.Buffer = StrValBuf;

  strcpy(comname, extension->SymbolicLinkName);
  strcat(comname, ":");

  RtlZeroMemory(&paramTable[0],sizeof(paramTable));

  paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name = CToU1(comname)->Buffer;
  paramTable[0].EntryContext = &USReturn;
  paramTable[0].DefaultType = REG_SZ;
  paramTable[0].DefaultData = L"";
  paramTable[0].DefaultLength = 0;

  if (!NT_SUCCESS(RtlQueryRegistryValues(
    // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
	   RTL_REGISTRY_WINDOWS_NT,
	   L"Ports",
	   &paramTable[0],
	   NULL,
	   NULL
	   )))
  {
    // no entry
    return;
  }

  // Check for data, indicates settings exist for COMX
  if (USReturn.Length == 0)
  {
    // no entry
    return;
  }

#define TOKENS 5
#define MAX_DIGITS 6
  {
    unsigned int TokenCounter;
    unsigned int CharCounter;
    unsigned int LastCount;
    WCHAR *TokenPtrs[TOKENS];
    ULONG BaudRateValue;

    // Make sure all Token ptrs point to NULL
    for(TokenCounter = 0; TokenCounter < TOKENS; TokenCounter++)
      TokenPtrs[TokenCounter] = NULL;

    // init counters
    TokenCounter = 0;
    LastCount = 0;

    for(CharCounter = 0; CharCounter < USReturn.Length; CharCounter++)
    {
      if(StrValBuf[CharCounter] == ',')
      {
	StrValBuf[CharCounter] = '\0'; //Null terminate DbgPrint

	TokenPtrs[TokenCounter++] = &StrValBuf[LastCount];

	//point to beginning of next string
	LastCount = CharCounter +1;
      }
    }

    // set up the last token
    if(CharCounter < MAX_STRING)
      StrValBuf[CharCounter] = '\0'; //Null terminate DbgPrint NULL

    if(TokenCounter < TOKENS)
      TokenPtrs[TokenCounter] = &StrValBuf[LastCount];

    // token 0: baud rate
    if(TokenPtrs[0] != NULL)
    {
      BaudRateValue = 0;
      CharCounter = 0;

      while( (TokenPtrs[0][CharCounter] != '\0') && //DbgPrint NULL
	     (CharCounter < MAX_DIGITS) &&
	     (BaudRateValue != ~0x0L) )
      {
	BaudRateValue *= 10;
	switch(TokenPtrs[0][CharCounter++])
	{
	  case '0': break;
	  case '1': BaudRateValue += 1; break;
	  case '2': BaudRateValue += 2; break;
	  case '3': BaudRateValue += 3; break;
	  case '4': BaudRateValue += 4; break;
	  case '5': BaudRateValue += 5; break;
	  case '6': BaudRateValue += 6; break;
	  case '7': BaudRateValue += 7; break;
	  case '8': BaudRateValue += 8; break;
	  case '9': BaudRateValue += 9; break;
	  default: BaudRateValue = ~0x0UL; break;
	}
      }

      if ((BaudRateValue >= 50) && (BaudRateValue <= 460800))
	extension->BaudRate = BaudRateValue;  // allow any baud rate

#ifdef COMMENT_OUT
      switch (BaudRateValue)
      {
	// Valid baud rates
	case 50:    case 75:    case 110:
	case 134:   case 150:   case 200:
	case 300:   case 600:   case 1200:
	case 1800:  case 2400:  case 4800:
	case 7200:  case 9600:  case 19200:
	case 38400: case 57600: case 76800:
	case 115200: case 230400: case 460800:
	  extension->BaudRate = BaudRateValue;
	break;

	default:
	  // Selected baud rate not available for RocketPort COMX
	break;
      }
#endif
    }

    // token 1: parity
    if(TokenPtrs[1] != NULL)
    {
      switch (TokenPtrs[1][0])
      {
	case 'n':
	  extension->LineCtl.Parity = NO_PARITY;
	break;

	case 'o':
	  extension->LineCtl.Parity = ODD_PARITY;
	break;

	case 'e':
	  extension->LineCtl.Parity = EVEN_PARITY;
	break;

	default:
	  // Selected parity not available for RocketPort COMX
	break;
      }
    }

    // token 2: data bits
    if(TokenPtrs[2] != NULL)
    {
      switch (TokenPtrs[2][0])
      {
	case '7':
	  extension->LineCtl.WordLength = 7;
	break;

	case '8':
	  extension->LineCtl.WordLength = 8;
	break;

	default:
	  // Selected databits not available for RocketPort COMX
	break;
      }
    }

    // token 3: Stop bits
    if(TokenPtrs[3] != NULL)
    {
      switch (TokenPtrs[3][0])
      {
	case '1':
	  extension->LineCtl.StopBits = STOP_BIT_1;
	break;

	case '2':
	  extension->LineCtl.StopBits = STOP_BITS_2;
	break;

	default:
	break;
      }
    }

    // token 4: flow control: rts/cts or XON/XOFF
    if(TokenPtrs[4] != NULL)
    {
      switch (TokenPtrs[4][0])
      {
	case 'x': // XON/XOFF f/c
	  extension->HandFlow.FlowReplace |=
	    (SERIAL_AUTO_TRANSMIT | SERIAL_AUTO_RECEIVE) ;
	break;

	case 'p': // RTS/CTS f/c
	  extension->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
	  extension->HandFlow.FlowReplace |= SERIAL_RTS_HANDSHAKE;

	  extension->HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;
	break;

	default:
	break;

      } // Selected flowcontrol not available for RocketPort COMX
    } // flow control token
  }
}

/*----------------------------------------------------------------------
 CheckPortName - If the name is already used, then derive one that is
   not in use.
   name - name of port to check.  Modify if a problem.
   Return - 0=name ok, 1=generated modified name, other= error.
|----------------------------------------------------------------------*/
static int CheckPortName(IN OUT char *name,
       IN PSERIAL_DEVICE_EXTENSION extension)
{
  int i;
  char prefix[20];
  int num;
  int new_name_given = 0;

  MyKdPrint(D_Init, ("CheckPortName:%s\n", name));

  // if no name, give a reasonable default.
  if (name[0] == 0)
  {
    new_name_given = 1;  // flag it
    strcpy(name, "COM3");
  }
  // load prefix(such as "COM" from "COM25" from name)
  i = 0;
  while ( (!our_isdigit(name[i])) && (name[i] != 0) && (i < 18))
  {
    prefix[i] = name[i];
    ++i;
  }
  prefix[i] = 0;

  // now grab post-fix number value incase we need to derive a new name
  num = 0;
  if (our_isdigit(name[i]))
    num = getint(&name[i], NULL);

  i = 0;
  for (;;)
  {
    // if we are already using this name, or if its in the registry
    if ((find_ext_by_name(name, NULL) != NULL) || 
	(IsPortNameInHardwareMap(name)) )
    {
      // name already in use, so derive a new one
      new_name_given = 1;  // flag it
      ++num;  // give a new post-fix index(so "COM4" to "COM5")
      Sprintf(name, "%s%d", prefix, num);
    }
    else
    {  // name is ok
      if (new_name_given)
      {
	MyKdPrint(D_Init, ("Form new name:%s\n", name))
      }
      return new_name_given; // return 0 if no change made, 1 if changed
    }
    ++i;
    if (i > 5000)
    {
      // problems
      return 2;  // return error
    }
  }
}

/*----------------------------------------------------------------------
 IsPortNameInHardwareMap - For Pnp operation, we startup before configuration,
   so pick a reasonable starting com-port name.  We do this by finding
   registry entries for all existing com-ports in the system.  This
   info is used to determine a name for the port.
|----------------------------------------------------------------------*/
static int IsPortNameInHardwareMap(char *name)
{
  static char *szRegRMHDS = 
    {"\\Registry\\Machine\\Hardware\\DeviceMap\\SerialComm"};

  HANDLE KeyHandle = NULL;
  ULONG data_type;
  int node_num = 0;
  char buffer[200];
  char KeyNameStr[60];
  char *data_ptr;
  int stat;

  //MyKdPrint(D_Init, ("IsPortNameInHardwareMap\n"))

  stat = our_open_key(&KeyHandle, NULL, szRegRMHDS, KEY_READ);
  if (stat)
  {
    MyKdPrint(D_Init, ("Failed OpenKey\n"))
    return 0;  // return no name clash
  }
  KeyNameStr[0] = 0;

  for(;;)
  {
    stat = our_enum_value(KeyHandle,
	 node_num,
	 buffer,
	 200,
	 &data_type,
	 &data_ptr,
	 KeyNameStr);
    ++node_num;

    if (stat)
    {
       //MyKdPrint(D_Init, ("Done\n"))
       break;
    }
    //MyKdPrint(D_Init, ("Got Value:%s\n", KeyNameStr))

    if (data_type != REG_SZ)
    {
      MyKdPrint(D_Init, ("Not RegSZ\n"))
      break;
    }

    WStrToCStr(KeyNameStr, (PWCHAR)data_ptr, 18);
    //MyKdPrint(D_Init, ("KeyFound:%s\n", KeyNameStr))

    if (my_lstricmp(KeyNameStr, name) == 0)  // match
    {
      // we got trouble, our name matches one already in registry
      //MyKdPrint(D_Init, ("Not a good name.\n"))
      return 1; // err: name clash
    }
  }
  return 0;  // ok, no name clash
}

/*----------------------------------------------------------------------
 RcktInitPollTimer - Initialize the poll timer for no interrupt operation.
   The fastest we can poll seems to be 10ms under NT.
|----------------------------------------------------------------------*/
NTSTATUS RcktInitPollTimer(void)
{
  MyKdPrint(D_Init,("RcktInitPollTimer\n"))
  KeInitializeDpc(&Driver.TimerDpc, TimerDpc, NULL);

  KeInitializeTimer(&Driver.PollTimer);

  // ScanRate is registry option in MS units.
  if (Driver.ScanRate < 1) Driver.ScanRate = 1;
  if (Driver.ScanRate > 40) Driver.ScanRate = 40;

  // NT Interval unit is 100nsec so to get Freq polls/sec
  Driver.PollIntervalTime.QuadPart = Driver.ScanRate * -10000;
#ifdef S_VS
  Driver.Tick100usBase = 100; // 100us base units(typical:100)
  Driver.TickBaseCnt = Driver.ScanRate * 10;
  KeQuerySystemTime(&Driver.IsrSysTime);
  KeQuerySystemTime(&Driver.LastIsrSysTime);
#endif

  Driver.TimerCreated = 1;  // tells to deallocate
  return STATUS_SUCCESS;
}

/*-----------------------------------------------------------------------
 InitSocketModems -
    This function is responsible for clearing the initial reset state on
    any device with SocketModems and initializing the location information
    (ROW) for each SocketModem on the device.  We only initialize extensions
    for which the device extension has the ModemDevice field enabled in
    the config information.  VS2000 devices don't need to be cleared from
    reset since the firmware does that.
|-----------------------------------------------------------------------*/
void InitSocketModems(PSERIAL_DEVICE_EXTENSION ext)
{
  DEVICE_CONFIG *cfg = ext->config;
  PSERIAL_DEVICE_EXTENSION portex,head_portex;

  MyKdPrint(D_Init,("InitSocketModems\n"))

  // use the PDO port list, if present since they start up first under nt5
  head_portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

  if (!cfg->ModemDevice)  return;

#ifdef S_RK
/*
    RMII boards don't require ROW codes set...
*/
    if (
    ((cfg->PCI_DevID == PCI_DEVICE_RMODEM6)       
    ||
    (cfg->PCI_DevID == PCI_DEVICE_RMODEM4))
    &&
    (cfg->PCI_RevID == PCI_REVISION_RMODEM_II)
    )
	return;

#ifdef MDM_RESET
    // in case the modems are hung up, we'd like server reloads to clear them
    // up...so, even though it's likely the modems are in reset state already,
    // put them there again...
  portex = head_portex;
  while (portex)
  {
    ModemReset(portex,1);
    portex = portex->port_ext;
  }

    // allow the socketmodems to reset...
  time_stall(Driver.MdmSettleTime);
#endif

    // clear the ports on the board from the reset state
  portex = head_portex;
  while (portex)
  {
    ModemReset(portex, 0);
    portex = portex->port_ext;
  }

    // allow the socketmodems to settle after clearing them from reset
  time_stall(Driver.MdmSettleTime);

#endif
  time_stall(20);
/*
    send the localization string (ROW) to each socketmodem, whether internal 
    or external (VS2000)...
*/
  portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

  while (portex) {
    ModemWriteROW(portex, Driver.MdmCountryCode);
    portex = portex->port_ext;
  }
  MyKdPrint(D_Init,("InitSocketModems: exit\n"))
}

#ifdef TRYED_IT_WORKED_REALLY_BAD
/*-----------------------------------------------------------------------
 DumpTracefile -
|-----------------------------------------------------------------------*/
static int DumpTracefile(void)
{
  NTSTATUS ntStatus;
  HANDLE NtFileHandle;
  OBJECT_ATTRIBUTES ObjectAttributes;
  IO_STATUS_BLOCK IoStatus;
  USTR_160 uname;
  FILE_STANDARD_INFORMATION StandardInfo;
  //ULONG LengthOfFile;
  static char *def_filename = {"\\SystemRoot\\system32\\VSLINKA\\trace.txt"};
  BYTE *buf;


  buf = our_locked_alloc(1010,"dump");

  CToUStr((PUNICODE_STRING)&uname, def_filename, sizeof(uname));

  InitializeObjectAttributes ( &ObjectAttributes,
	      &uname.ustr,
	      OBJ_CASE_INSENSITIVE,
	      NULL,
	      NULL );

#ifdef COMMENT_OUT

  ntStatus = ZwCreateFile( &NtFileHandle,
	  SYNCHRONIZE | FILE_WRITE_DATA | FILE_APPEND_DATA,
//                           GENERIC_WRITE | SYNCHRONIZE,
	  &ObjectAttributes,
	  &IoStatus,
	  NULL,              // alloc size = none
	  FILE_ATTRIBUTE_NORMAL,
	  FILE_SHARE_WRITE,
	  FILE_SUPERSEDE,
	  FILE_SYNCHRONOUS_IO_NONALERT,
	  NULL,  // eabuffer
	  0);   // ealength

  if (!NT_SUCCESS(ntStatus))
  {
    Eprintf("Dump Error B");
    our_free(buf, "dump");
    return 1;
  }

  // Write the file from our buffer.
  ntStatus = ZwWriteFile(NtFileHandle,
      NULL,NULL,NULL,
      &IoStatus,
      "Start of file>   ",
      14,
      FILE_WRITE_TO_END_OF_FILE, NULL);

  while (!q_empty(&Driver.DebugQ))
  {
    int q_cnt;
    q_cnt = q_count(&Driver.DebugQ);
    if (q_cnt > 1000)
      q_cnt = 1000;
    q_get(&Driver.DebugQ, buf, q_cnt);

    // Write the file from our buffer.
    ntStatus = ZwWriteFile(NtFileHandle,
	NULL,NULL,NULL,
	&IoStatus,
	buf,
	q_cnt,
	FILE_WRITE_TO_END_OF_FILE, NULL);
  }

  if (!NT_SUCCESS(ntStatus))
     Eprintf("Dump Error A:%d",ntStatus);

  ZwClose(NtFileHandle);
#endif

  our_free(buf, "dump");
  return 0;
}
#endif


/********************************************************************

    RocketModem II loader stuff...

********************************************************************/
#ifdef S_RK
/*
   responses are forced to upper case for ease in checking (response case
   varies depending on whether the modem was loaded already or not...
*/
#define  MODEM_LOADCHECK_CMD     "ATI3\r"
#define  MODEM_RESET_CMD         "ATZ0\r"
#define  MODEM_LOAD_CMD          "AT**\r"

#define  MODEM_LOADCHECK_RESP    "V2.101A2-V90_2M_DLS_RAM\r\n"

#define  DOWNLOAD_INITIATED_RESP "DOWNLOAD INITIATED ..\r\n"
#define  CSM_READY_RESP          "115.2K\r\n"
#define  FIRMWARE_READY_RESP     "DEVICE SUCCESSFULLY PROGRAMMED\r\nCHECKSUM: "
#define  OK_RESP                 "OK"


/**********************************************************************

   send ATI3 to determine if modem is loaded...

**********************************************************************/
static int
RM_Snd_ATI3_Command(MODEM_STATE *pModemState)
{
/*
    discard any data currently in the receive FIFO...
*/
    if (RxFIFOReady(pModemState->portex)) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem on %s overrun",
			pModemState->portex->SymbolicLinkName);

	    return(0);
    }

    SEND_CMD_STRING(pModemState->portex,MODEM_LOADCHECK_CMD);

	return(1);
}

/**********************************************************************

   check response to ATI3 - modem loaded or unloaded...

**********************************************************************/
static int 
RM_Rcv_ATI3_Response(MODEM_STATE *pModemState)
{
    int index;

    index = READ_RESPONSE_STRINGS(pModemState->portex,
	    OK_RESP,
	    MODEM_LOADCHECK_RESP,
	    ONE_SECOND);

    switch (index) {
/*
    loaded with the firmware revision this release of RocketPort NT driver expects...
*/
	case 0: {
	    pModemState->status = RMODEM_NOT_LOADED;

	    break;
	}
	case 1: {
	    pModemState->status = RMODEM_LOADED;

	    break;
	}
	default: {
/*
  either it didn't respond, or responded with the wrong string. either way,
  we'll reset it (again) and then reload it...
*/
	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem on %s no response (I3)",
		    pModemState->portex->SymbolicLinkName);

	    return(0);
	}
    }
	return(1);
}

/**********************************************************************

   response to AT** command received...

**********************************************************************/
static int
RM_Rcv_ModemLoad_Response(MODEM_STATE *pModemState)
{
    int index;

    index = READ_RESPONSE_STRING(
		pModemState->portex,
	    DOWNLOAD_INITIATED_RESP,
	    FIVE_SECONDS);

    if (index) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem on %s no response (LL)",
			pModemState->portex->SymbolicLinkName);

		return(0);
	}

	return(1);
}

/**********************************************************************

   CSM loaded response...

**********************************************************************/
static int 
RM_Rcv_FirmwareLoader_Loaded(MODEM_STATE *pModemState)
{
    int index;

    index = READ_RESPONSE_STRING(
	    pModemState->portex,
	    CSM_READY_RESP,
	    FIVE_SECONDS);

    if (index) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem on %s no response (FL)",
			pModemState->portex->SymbolicLinkName);

		return(0);
    }
	return(1);
}

/**********************************************************************

    check if firmware loaded successfully...

**********************************************************************/
static int 
RM_Rcv_FirmwareLoaded_Response(MODEM_STATE *pModemState)
{
    int index;
    char    workstring[sizeof(FIRMWARE_READY_RESP) + 4];
    char    *to,*from;

    from = FIRMWARE_READY_RESP;
    to  = workstring;

    index = sizeof(FIRMWARE_READY_RESP) -  1;

    while (index--) 
	    *(to++) = *(from++);
    
    from = ChecksumString;

    index = 4;

    while (index--) 
	    *(to++) = *(from++);
	
    *(to++) = 0; 

    index = 0;

    index = READ_RESPONSE_STRING(
	    pModemState->portex,
	    workstring,
	    FIVE_SECONDS);

    if (index) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem %s bad response to load",
	        pModemState->portex->SymbolicLinkName);

		return(0);
    }

	pModemState->status = RMODEM_LOADED;

	return(1);
}

/**********************************************************************

   write a CSM byte. flush any '.' response...

**********************************************************************/
static int 
RM_Snd_Loader_Data(MODEM_STATE *pModemState)
{
	int     loop;

	loop = 100;
/*
    see if there's any available space in the transmit FIFO. if not, pause...
*/
	while (
	(!TxFIFOReady(pModemState->portex)) 
	&&
	(loop-- > 0)
	) {
/*
    pause for any characters currently in the transmit FIFO to move on out...
*/
	    ms_time_stall(1);
	}
/*
    if still no room, bail out...
*/
	if (!TxFIFOReady(pModemState->portex)) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem %s won't accept loader",
			pModemState->portex->SymbolicLinkName);

		return(0);
	}
/*
    write a byte, then go on to next modem...
*/
    ModemWrite(
	    pModemState->portex,
	    (char *)&Driver.ModemLoaderCodeImage[pModemState->index++],
	    (int)1);
/*
    discard any data currently in the receive FIFO...
*/
    if (RxFIFOReady(pModemState->portex)) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem %s loader overrun",
	        pModemState->portex->SymbolicLinkName);

		return(0);
    }
	return(1);
}

/**********************************************************************

   write a firmware byte. flush any '.' response...

**********************************************************************/
static int 
RM_Snd_Firmware_Data(MODEM_STATE *pModemState)
{
    int origcount;
	int loop;

	origcount = (int)TxFIFOStatus(pModemState->portex);

	loop = 100;
/*
    see if there's any available space in the transmit FIFO. if not, pause...
*/
	while (
	(!TxFIFOReady(pModemState->portex)) 
	&&
	(loop-- > 0)
	) {
/*
    pause for characters currently in the transmit FIFO to make room...
*/
	    ms_time_stall(1);
	}

	if (!TxFIFOReady(pModemState->portex)) {

		pModemState->status = RMODEM_FAILED;

		Eprintf("Warning: Modem %s won't accept firmware",
			pModemState->portex->SymbolicLinkName);

		return(0);
	}
/*
    write a byte, then go on to next modem...
*/
    ModemWrite(
	    pModemState->portex,
	    (char *)&Driver.ModemCodeImage[pModemState->index++],
	    (int)1);
/*
    discard any data currently in the receive FIFO...
*/
    if (RxFIFOReady(pModemState->portex)) {

	    pModemState->status = RMODEM_FAILED;

	    Eprintf("Warning: Modem %s firmware overrun",
	        pModemState->portex->SymbolicLinkName);

	    return(0);
    }
	return(1);
}

/**********************************************************************

   send modem load AT command...

**********************************************************************/
static int 
RM_Snd_ModemLoad_Command(MODEM_STATE *pModemState)
{
	SEND_CMD_STRING(pModemState->portex,MODEM_LOAD_CMD);

	return(1);
}

/**********************************************************************

   shutdown modem and port...

**********************************************************************/
static int 
RM_CleanUp(MODEM_STATE *pModemState)
{

	if (pModemState->status == RMODEM_FAILED) {

		DownModem(pModemState);

		return(0);
	}

	ModemUnReady(pModemState->portex);

	return(1);
}


#endif

/**********************************************************************

   load RocketModemII devices...

**********************************************************************/
void 
InitRocketModemII(PSERIAL_DEVICE_EXTENSION ext)
{
#ifdef S_RK
    DEVICE_CONFIG *           cfg;
    PSERIAL_DEVICE_EXTENSION  portex,head_portex;
    MODEM_STATE                  ModemState[8];
    int modem_count,
		loaded_modem_count,
	    modem_index,
	    retry;
    ULONG   index,version_index;
    long    checksum;
	char    VersionString[9];
    char    *cptr,*endptr;

//    Eprintf("RocketModemII init start");      // turn on for timing purposes...

    cfg = ext->config;
/*
    verify this is a RMII board, 4 or 6 port, before proceeding further...
*/
    if (!cfg->ModemDevice) {
		return;
	}

    if (
    (cfg->PCI_DevID != PCI_DEVICE_RMODEM6) 
    &&
    (cfg->PCI_DevID != PCI_DEVICE_RMODEM4)
    )  
		return;
 
    if (cfg->PCI_RevID != PCI_REVISION_RMODEM_II)  
		return;
 /*
    use the PDO port list, if present since they start up first under nt5.
    prepare the ports to each modem...
*/
    head_portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    if (head_portex == (PSERIAL_DEVICE_EXTENSION)NULL) {

		MyKdPrint(D_Init,("InitRocketModemII: No port extensions\r"))

		return;
    }

    retry = 1;

    do {
		modem_count = 0;

		head_portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

		portex = head_portex;

		while ((void *)portex) {

			ModemIOReady(portex,115200);

			ModemState[modem_count].status = RMODEM_NOT_LOADED;
			ModemState[modem_count].portex = portex;
			ModemState[modem_count].index  = 0;

			portex = portex->port_ext;
			++modem_count;
		}
    
		time_stall(ONE_SECOND);  
/*
    after pausing for ports to set up, start with modem hardware reset, before issuing ATI3, 
    making sure that modems are cleaned up and in command mode...
*/
		ModemResetAll(ext);
/*
    enable RMII speaker...
*/
		ModemSpeakerEnable(head_portex);
/*
    start with check on modem load status, by issuing ATI3 to just the first modem. if the first modem
	isn't loaded, assume all the others aren't either. if the first modem is loaded, check the rest. if the
	first modem receive fifo doesn't clear, mark accordingly, then proceed with loading...
*/
		(void) RM_Snd_ATI3_Command(ModemState);
	
		ModemTxFIFOWait(ext);
    
		(void) RM_Rcv_ATI3_Response(ModemState);

		loaded_modem_count = 0;

		if (ModemState[0].status == RMODEM_LOADED) {
/*
    modem 0 was loaded. check remaining modems. if any aren't loaded, load them all...
*/
            ++loaded_modem_count;

			modem_index = 1;

			portex = head_portex->port_ext;

			while ((void *)portex) {

				if (ModemState[modem_index].status != RMODEM_FAILED)  
					(void) RM_Snd_ATI3_Command(&ModemState[modem_index]);
	 
				++modem_index;

				portex = portex->port_ext;
			}
/*
    ATI3 load probe command sent, waiting for OK or loaded firmware revision 
    response. if no modems respond, ignore for now...
*/
			ModemTxFIFOWait(ext);
    
			modem_index = 1;

			portex = head_portex->port_ext;

			while ((void *)portex) {

				if (ModemState[modem_index].status != RMODEM_FAILED)  
					(void) RM_Rcv_ATI3_Response(&ModemState[modem_index]);
	 
				++modem_index;

				portex = portex->port_ext;
			}
/*
    now see if any modems require loading. if any do, reset all modems again,
    and then issue the download modem command to all modems...
*/
    		modem_index = 0;
		
            portex = head_portex->port_ext;

    		while ((void *)portex) {

    			if (ModemState[modem_index++].status == RMODEM_LOADED) 
    				++loaded_modem_count;

    			portex = portex->port_ext;
    		}
		}
/*
	if any modems are unloaded, load them all...
*/
		if (loaded_modem_count != modem_count) {

			ModemResetAll(ext);

			(void) IssueEvent(ext,RM_Snd_ModemLoad_Command,ModemState);
/*
    load commands output. while they're leaving the transmit FIFO, 
    read in the CSM loader and modem firmware files...
*/
			if (LoadModemCode((char *)NULL,(char *)NULL)) {

				Eprintf("Warning: Modem firmware file error");

				FreeModemFiles();

				continue;
			}
/*
    wait until the download commands are truly gone. then start waiting for
    the response. if no modems respond, bail out...
*/
			ModemTxFIFOWait(ext);

			if (IssueEvent(ext,RM_Rcv_ModemLoad_Response,ModemState) == 0) {

				FreeModemFiles();

				continue;
			}

			modem_index = 0;
			while (modem_index < modem_count) 
				ModemState[modem_index++].index = 0;
/*  
    response received, apparently. grind through CSM loader file, sending a byte to 
    all modems...
*/
			index = 0;
			while (index++ < Driver.ModemLoaderCodeSize)   
				(void) IssueEvent(ext,RM_Snd_Loader_Data,ModemState);
/*
    spin while transmit FIFOs clear, then pause for responses to arrive...
*/
			ModemTxFIFOWait(ext);
/*
    wait for loading at 115.2K response to CSM load. after response, pause
    a moment for any remaining receive data to arrive. bail out if no modems
    respond...
*/
			if (IssueEvent(ext,RM_Rcv_FirmwareLoader_Loaded,ModemState) == 0) {

				MyKdPrint(D_Init,("InitRocketModemII: No recognized responses to loader load datastream\r"))

				FreeModemFiles();

				continue;
			}

			time_stall(HALF_SECOND);

			modem_index = 0;
			while (modem_index < modem_count) 
				ModemState[modem_index++].index = 0;
/*
    grind through firmware file, sending a byte to all modems. skip the location
	in the binary where the checksum will reside - it's just trash right now, but
	space still has to be set aside for it - but don't include the trash in the 
	checksum (usually 0xFFFF)...
*/
			checksum = 0x00008000;
			index = 0;
			version_index = 0;

			while (index < Driver.ModemCodeSize) {

				(void) IssueEvent(ext,RM_Snd_Firmware_Data,ModemState);
	
				if (
				(index != (unsigned long)0xFFBE) 
				&&
				(index != (unsigned long)0xFFBF)
				)
					checksum += Driver.ModemCodeImage[index];
/*
    attempt to isolate the firmware version. version should be in form 'Vn.nnnan'. note
    that we _could_ send another ati3 command to a representative modem to pick up the version
    number after the load is complete, but that would take additional time...

    also, note that though we've sent an ati3 command to at least one modem - so we have a 
    pretty good idea what the version is supposed to be based on the string we're expecting 
    on the response - we'll pretend that isn't applicable at this point to avoid dependencies 
    on the ati3 command... 
    
    whether that's a good idea or not remains to be seen. but the following processing seems 
    harmless at this time. if the form of the version changes, though, it might be annoying 
    to change the ati3 response string AND the following code to fit the new version form...
*/
                if (
                (Driver.ModemCodeImage[index] == VERSION_CHAR)
                &&
                (!gModemToggle)
                &&
                (!version_index) 
                ) {
/*
    only look for the version on the first modem board load, and if we haven't found the version yet,
    see if the current character is a 'V'. if so, start the process of examining the following characters...
*/
                    cptr = &Driver.ModemCodeImage[index];
                    endptr = Driver.ModemCodeImage + Driver.ModemCodeSize;

                    while (version_index < sizeof(VersionString)) {
/*
    are we about to go past the end of the file? if so, bail out...
*/
                        if (cptr >= endptr) {
                            version_index = 0;
                            break;
                        }
/*
    check if this character looks ok...
*/
                        if (
                        (*cptr < '.') 
                        ||
                        (*cptr > 'Z')
                        ) {
/*
    not a printable-enough character. have we enough characters to assume this is the version string? if not,
    give up, start search over. if we do, though, then we're done, bail out...
*/
                            if (version_index != (sizeof(VersionString) - 1))                     
                                version_index = 0;
                             
                            break;
                        }
/*
    printable character. if this is the third character in the string, though, it must be a dot. if not,
    give up, start search over...
*/
                        if (
                        ((*cptr == '.')
                        &&
                        (version_index != 2))
                        ||
                        ((*cptr != '.')
                        &&
                        (version_index == 2))
                        ) {
                            version_index = 0;
                            break;
                        }
/*
    printable character, save it away for later. this includes the leading 'V', incidentally...
*/
                        VersionString[version_index++] = *(cptr++);
                        VersionString[version_index] = 0;
                    }                        
                }
				index++;
		    }

		    ChecksumAscii((unsigned short *)&checksum);
/*
	output one time messages. the version shouldn't change from modem board to modem board, and 
	neither should the computed checksum (though we do recompute it)...
*/
			if (!gModemToggle) {

                if (version_index) {
			        Eprintf("RocketModemII firmware %s-%s",VersionString,ChecksumString);
				}
				else if (ChecksumString[0]) {
					Eprintf("RocketModemII checksum %s",ChecksumString);
				}
			}
/*
    all done with files, release them...
*/
		    FreeModemFiles();
/*
    spin while transmit FIFOs clear, then pause for response to arrive...
*/
		    ModemTxFIFOWait(ext);
/* 
    wait for successful load message from each modem...
*/
		    if (IssueEvent(ext,RM_Rcv_FirmwareLoaded_Response,ModemState) == 0) {

				MyKdPrint(D_Init,("InitRocketModemII: No recognized responses to firmware load datastream\r"))
		
				continue;
		    }
		}
/*
    pause for newly-loaded modems to settle down...
*/
		time_stall(HALF_SECOND);   
/*
    unready ports, reset ports associated with any failing modems. bail out if done...
*/
        if (IssueEvent(ext,RM_CleanUp,ModemState) == modem_count)  
			break;

    } while (retry--);

	++gModemToggle;

//    Eprintf("RocketModemII init end");    // turn on for timing purposes...

#endif
}

#ifdef S_RK

/**********************************************************************

   check response...

**********************************************************************/
int 
IssueEvent(PSERIAL_DEVICE_EXTENSION ext,int (*modemfunc)(),MODEM_STATE *pModemState)
{
    PSERIAL_DEVICE_EXTENSION        portex;
    int   responding_modem_count;
/*
    issue event to each modem...
*/
    responding_modem_count = 0;

    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    while ((void *)portex) {

		if (pModemState->status != RMODEM_FAILED) { 
			responding_modem_count += (modemfunc)(pModemState);
		}
	 
		++pModemState;

	portex = portex->port_ext;
    }

    return(responding_modem_count);
}

/**********************************************************************

   dynamic delay for transmit. waits only as long as necessary, but 
   doesn't get caught if a transmit fifo stalls (for whatever reason)...

**********************************************************************/
void 
ModemTxFIFOWait(PSERIAL_DEVICE_EXTENSION ext)
{
    PSERIAL_DEVICE_EXTENSION  portex;
    int index,activity;
	int     fifo_count[16];                 // arbitrary, but reasonably safe, array size
	int     fifo_stall[16];                 // ditto
/*
    build baseline transmit fifo counts, init stall counts to zero...
*/
    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

	index = 0;

	while ((void *)portex) {
		fifo_count[index] = (int)TxFIFOStatus(portex);
		fifo_stall[index] = 0;
		++index;
	portex = portex->port_ext;
	}
/*
    loop until all transmit fifos are empty, or we've given up on the stalled ones...
*/
	do {
		index = 0;
		activity = 0;
    
		portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

		while ((void *)portex) {
/*
    check only those ports that indicate data in the transmit fifo, but then only as
	long as they don't appear to be stalled...
*/
			if (
			((int)TxFIFOStatus(portex))
			&&
			(fifo_stall[index] < MAX_STALL)
			) {

				if (fifo_count[index] == (int)TxFIFOStatus(portex)) {
/*
    pause for a non-moving transmit fifo, flag this fifo as suspect...
*/
					fifo_stall[index]++;
					ms_time_stall(1);
				}
				else {
/*
    this particular transmit fifo count changed. pick up new value to monitor. unflag this 
	fifo as suspect...
*/
					fifo_count[index] = (int)TxFIFOStatus(portex);
					fifo_stall[index] = 0;
				}
/*
    whether they're stalled or not, flag fifos as still active. this goes on until
	they're empty, or stall limit count is reached...
*/
				++activity;
			}
			portex = portex->port_ext;
			++index;
		}
/*
	still some (apparent) activity in transmit fifos? yep, loop some more...
*/
    } while (activity);
}

/**********************************************************************

  unready and reset modem...

**********************************************************************/
void
DownModem(MODEM_STATE *pModemState)
{
    ModemUnReady(pModemState->portex);

    ModemReset(pModemState->portex,1);

    time_stall(Driver.MdmSettleTime);

    ModemReset(pModemState->portex,0);
}


/**********************************************************************

   reset all modems on this board at the same time...

**********************************************************************/
void 
ModemResetAll(PSERIAL_DEVICE_EXTENSION ext)
{
    PSERIAL_DEVICE_EXTENSION  portex;

    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    while ((void *)portex) {

	ModemReset(portex,1);

	portex = portex->port_ext;
    }

    time_stall(HALF_SECOND);

    portex = (ext->port_pdo_ext) ? ext->port_pdo_ext : ext->port_ext;

    while ((void *)portex) {

	ModemReset(portex,0);
	portex = portex->port_ext;
    }

    time_stall(ONE_SECOND);

}

/**********************************************************************

   2 byte conversion to ascii...

**********************************************************************/
void 
ChecksumAscii(unsigned short *valueptr)
{
    int     count,index;
    unsigned short   work;

    ChecksumString[4] = 0;

    index = 0;
    count = 3;

    do {
	work = (*valueptr) & 0x7fff;

	work >>= (count * 4);

	work &= 0x000F;

	if (work > 9)
	    work += '7';
	else
	    work += '0';

	ChecksumString[index++] = (unsigned char)work;

    } while (count--);
}
#endif

/*********************************************************************************
*
* get_comdb_offsets
*
*********************************************************************************/
static int get_comdb_offsets( IN char *portLabel, OUT int *indx, OUT BYTE *mask )
{
	char	*pComLbl;
	int     i, portNum, portIndx;
	BYTE    portMask;

    // Make sure a COMxx string is being passed in

	ASSERT( portLabel );
	ASSERT( indx );
	ASSERT( mask );

	if ( strlen( portLabel ) < 4 ) {

		return 0;
	}

	if ( strncmp( portLabel, "COM", 3 ) ) {

		return 0;
	}

    // A lot of checking, but if the wrong ComDB bit is cleared, the 
    // corresponding COM# may get reassigned although another device
    // is using it.

	pComLbl = portLabel + 3;
	for ( i = 0; pComLbl[i]; i++ ) {

		if (!our_isdigit( pComLbl[i] )) {

			return 0;
		}
	}

    // Convert the string to numeric, then translate into bit & byte 
	// offsets

	portNum = getint( pComLbl, NULL );

	portMask = (BYTE) (1 << ( (portNum - 1) % 8 ));
	portIndx = (int) ((portNum - 1) >> 3);

	MyKdPrint( D_Init, ("Mask value for COM%d is 0x%02x at byte index %d\n",
		portNum, portMask, portIndx ) );

	*indx = portIndx;
	*mask = portMask;

	return portNum;
}


/*********************************************************************************
*
* get_com_db
*
* Makes sure the bit in the \Registry\Machine\System\CurrentControlSet\Control\COM Name Arbiter
* for the specific port gets cleared on an uninstall.  Ordinarily the PnP Manager
* does this automatically but old builds of W2000 don't nor do more recent builds
* under certain circumstances.  If this bit isn't cleared the OS won't reuse the 
* COM port number if the RocketPort is re-installed or another serial device is
* installed.
*
*********************************************************************************/
static char *szRMSCCComNameArbiter =
	{ "\\Registry\\Machine\\System\\CurrentControlSet\\Control\\COM Name Arbiter" };
static char *szValueID = { "ComDB" };

int clear_com_db( char *szComport )
{
	HANDLE  key_handle = NULL;
//	BYTE    *buffer;
	BYTE    *data_ptr = NULL;
	int     i, stat, indx, port_num;
	BYTE    portMask;
	USTR_40 ubuf;		// Unicode key name 
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG   length;

	// Get the COM #

    indx = 0;
	portMask = 0;
	if ( szComport != NULL ) {

		port_num = get_comdb_offsets( szComport, &indx, &portMask );

		if ( port_num < 3 || port_num > 256 ) {

			MyKdPrint( D_Error, ("Invalid COM port number from %d\n", szComport) );
			return 1;
		}
	}
	else {

		MyKdPrint( D_Error, ("COM port parameter was NULL\n") );
		return 1;
	}

    // Open the registry key

	stat = our_open_key( &key_handle, 
		                 NULL,
						 szRMSCCComNameArbiter,
						 KEY_ALL_ACCESS );

    if ( stat ) {

		MyKdPrint(D_Error, ("Unable to find Com Port Arbiter key\n"));
		return 1;
	}

    // convert our name to unicode

    CToUStr((PUNICODE_STRING) &ubuf, // where unicode struct & string gets put
            szValueID,               // our c-string we wish to convert
            sizeof(ubuf));

// The 2-pass ZwQueryValueKey approach ensures accurate buffer size allocation.  
// Pass 1 with a NULL buffer parameter returns the length of the 
// PKEY_VALUE_PARTIAL_INFORMATION structure.  After allocating a buffer of
// this length, pass 2 reads the structure.  The trick is to ignore any return
// code on pass 1 except STATUS_OBJECT_NAME_NOT_FOUND, i.e., the value doesn't
// exist.

	// Determine the required size for the registry data buffer

	stat = ZwQueryValueKey( key_handle,
		                    (PUNICODE_STRING) &ubuf,
							KeyValuePartialInformation,
							NULL,
							0,
							&length);

	if ( stat == STATUS_OBJECT_NAME_NOT_FOUND || length == 0L ) {

		MyKdPrint(D_Error, ("Unable to find %s in specified key\n", szValueID));
		ZwClose( key_handle );
		return 1;
	}

    MyKdPrint(D_Init, 
		("Allocating PKEY_VALUE_PARTIAL_INFORMATION buffer: %d bytes\n", length));

	// Make a buffer for the KEY_VALUE_PARTIAL_INFORMATION struct

	KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool( PagedPool, length );

	if ( KeyValueInfo == NULL ) {

		MyKdPrint(D_Error, ("Unable to allocate PKEY_VALUE_PARTIAL_INFORMATION struct\n"))
		ZwClose( key_handle );
		return 1;
	}

	RtlZeroMemory( KeyValueInfo, length );

	// Now get the actual data structure

	stat = ZwQueryValueKey( key_handle,
		                    (PUNICODE_STRING) &ubuf,
							KeyValuePartialInformation,
							KeyValueInfo,
							length,
							&length );

	if ( !NT_SUCCESS(stat) || length == 0L ) {

		MyKdPrint(D_Error, ("Unable to read PKEY_VALUE_PARTIAL_INFORMATION struct\n"));
		ExFreePool( KeyValueInfo );
		ZwClose( key_handle );
		return 1;
	}

	length = KeyValueInfo->DataLength;
	MyKdPrint(D_Init, ("Data buffer length is %d bytes\n", length));

	if ( KeyValueInfo->Type != REG_BINARY ) {
		MyKdPrint(D_Error, ("Unexpected registry type in PKEY_VALUE_PARTIAL_INFORMATION struct\n"));
		ExFreePool( KeyValueInfo );
		ZwClose( key_handle );
		return 1;
	}

	data_ptr = (PCHAR)(&KeyValueInfo->Data[0]);
    if ( data_ptr ) {

		MyKdPrint(D_Init, ("ComDB byte %d is 0x%02x\n", indx, data_ptr[indx]));
		if ( (data_ptr[indx] & portMask) != 0 ) {

			MyKdPrint(D_Init, 
				("Clearing bit position 0x%02x in ComDB byte value 0x%02x\n", 
				portMask, data_ptr[indx]));
			data_ptr[indx] &= ~portMask;
			
			// Now we write the modified data back to the registry

			stat = our_set_value( key_handle,
				                  (char *)szValueID,
								  data_ptr,
								  length,
								  REG_BINARY);
			if ( stat ) {

				MyKdPrint(D_Error, ("Unable to write ComDB value\n"));
				ExFreePool( KeyValueInfo );
				ZwClose( key_handle );
				return 1;
			}
		}
		else {

			// Previously cleared

			MyKdPrint(D_Init, 
				("Bit position 0x%02x already cleared in ComDB byte value 0x%02x!\n", 
				portMask, data_ptr[indx]));
		}
	}

	// cleanup

    ExFreePool( KeyValueInfo );
	ZwClose( key_handle );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\initrk.c ===
/*-------------------------------------------------------------------
| initrk.c - main init code for RocketPort/Modem NT device driver.
   Contains mostly initialization code.
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

char *szResourceClassName = {"Resources RocketPort"};

MODEM_IMAGE * ReadModemFile(MODEM_IMAGE *mi);
void FreeModemFiles();

/*----------------------------------------------------------------------
 FindPCIBus -
    Purpose:  To query system for pci bus.  If there is a PCI bus
              call FindPCIRocket to check for PCI rocket cards.
    Returns:  Bus number of the PCI bus, or 0 if no PCI bus found.
|----------------------------------------------------------------------*/
UCHAR  FindPCIBus(void)
{
  NTSTATUS Status;
  int i,NumPCIBuses=0;
  unsigned char tmpstr[8];  // place to put data

  for(i=0;i<255;++i)
  {
    Status = HalGetBusData(PCIConfiguration,
                           i,  // bus
                           0,  // slot
                           (PCI_COMMON_CONFIG *) tmpstr, // ptr to buffer
                           2);  // get two bytes of data

    if (Status == 0)   // No more PCI buses
        break;

    if (Status >= 2)  // the bus exists
        ++NumPCIBuses;
  }

  MyKdPrint(
    D_Init,
      ("Found %d PCI Bu%s\n",
      NumPCIBuses,
      (NumPCIBuses != 1 ? "sses" : "s")))

  return((UCHAR)NumPCIBuses);
}

/*----------------------------------------------------------------------
 FindPCIRockets -  Gather info on all rocketport pci boards in the system.
    Returns:  0 if found, 1 if not found.
|----------------------------------------------------------------------*/
int FindPCIRockets(UCHAR NumPCI)
{
  PCI_COMMON_CONFIG *PCIDev;
  UCHAR i;
  NTSTATUS Status;
  int Slot;
  int find_index = 0;

  MyKdPrint(D_Init,("FindPciRocket\n"))

  RtlZeroMemory(&PciConfig,sizeof(PciConfig));

  PCIDev = ExAllocatePool(NonPagedPool,sizeof(PCI_COMMON_CONFIG));
  if ( PCIDev == NULL ) {
    Eprintf("FindPCIRockets no memory");
    return 1;
  }
  for(i=0;i<NumPCI;++i)
  {
    for(Slot = 0;Slot < 32;++Slot) /*5 bits for device 32 = 2^5*/
    {
      // get a few bytes of pci-config space(vendor-id & device-id).
      Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x4);
      if (Status == 0)
      {
        Eprintf("PCI Bus %d does not exist.",i);
      }

      if (Status > 2)        /* Found Device Is it ours? */
      {
        if (PCIDev->VendorID == PCI_VENDOR_ID)
        {

////////////////new///////////////////////
		switch (PCIDev->DeviceID)
			{
			case PCI_DEVICE_4Q:   // 4 Port Quadcable
			case PCI_DEVICE_4RJ:   // 4 Port RJ
			case PCI_DEVICE_8RJ:   // 8 Port RJ
			case PCI_DEVICE_8O:   // 8 Port Octacable
			case PCI_DEVICE_8I:  // 8 Port interface
			case PCI_DEVICE_SIEMENS8:
			case PCI_DEVICE_SIEMENS16:
			case PCI_DEVICE_16I:  //16 Port interface
			case PCI_DEVICE_32I:  // 32 Port interface
			case PCI_DEVICE_RPLUS2:
			case PCI_DEVICE_422RPLUS2:
			case PCI_DEVICE_RPLUS4:
			case PCI_DEVICE_RPLUS8:
			case PCI_DEVICE_RMODEM6:
			case PCI_DEVICE_RMODEM4:

				break;

			default:

				continue;
			}  // switch

//////////////////////////////////////////

          // get 0x40 worth of pci-config space(includes irq, addr, etc.)
          Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x40);

          if (Driver.VerboseLog)
            Eprintf("PCI Board found, IO:%xh, Int:%d ID:%d.",
                               PCIDev->u.type0.BaseAddresses[0]-1,
                               PCIDev->u.type0.InterruptLine,
                               PCIDev->DeviceID);

          PciConfig[find_index].BusNumber = i; //get from previous halquerysysin
          PciConfig[find_index].PCI_Slot = Slot;
          PciConfig[find_index].PCI_DevID = PCIDev->DeviceID;
          PciConfig[find_index].PCI_RevID = PCIDev->RevisionID;
          PciConfig[find_index].PCI_SVID = PCIDev->u.type0.SubVendorID;
          PciConfig[find_index].PCI_SID = PCIDev->u.type0.SubSystemID;
          PciConfig[find_index].BaseIoAddr =
              PCIDev->u.type0.BaseAddresses[0]-1;
          PciConfig[find_index].NumPorts = id_to_num_ports(PCIDev->DeviceID);
          if (PCIDev->u.type0.InterruptLine != 255)
          {
            MyKdPrint(D_Init,("Saving the Interrupt: %d\n",
                    PCIDev->u.type0.InterruptLine))

            PciConfig[find_index].Irq = PCIDev->u.type0.InterruptLine;
          }

          if (Driver.VerboseLog)
             Eprintf("Bus:%d,Slt:%x,Dev:%x,Pin:%x",
                 i, Slot, PCIDev->DeviceID, PCIDev->u.type0.InterruptPin);

          if ((PCIDev->Command & 1) == 0)
          {
            if (Driver.VerboseLog)
              Eprintf("Turn on PCI io access");

            PCIDev->Command = PCI_ENABLE_IO_SPACE;
            Status = HalSetBusDataByOffset(PCIConfiguration,
                           i,  // bus
                           Slot,  // slot
                           &PCIDev->Command,
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                           sizeof(PCIDev->Command));  // len of buffer
          }

          MyKdPrint(D_Init,("Ctlr: __ Slot: %x Device: %x, Base0: %x, IPin: %x, ILine: %x\n",
             Slot,PCIDev->DeviceID,PCIDev->u.type0.BaseAddresses[0]-1,
             PCIDev->u.type0.InterruptPin,
               PCIDev->u.type0.InterruptLine))
          if (find_index < MAX_NUM_BOXES)
            ++find_index;
        } // if (PCIDev->VendorID == PCI_VENDOR_ID)
      }   // if (Status > 2)
    }     // pci slots
  }       // pci buses

  ExFreePool(PCIDev);

  if (find_index > 0)
    return 0;   // ok: found
  return 1;     // err: not found
}

/*----------------------------------------------------------------------
 FindPCIRocket -  Help enumerate Rocketport PCI devices.  Fills in
   enties in config structure.

 match_option : 0 - match exact, 1 - match if desired ports <= actual.
    Returns:  0 if found, 1 if not found.
|----------------------------------------------------------------------*/
int FindPCIRocket(DEVICE_CONFIG *config, int match_option)
{
  int brd = 0;
  int good;

  while (PciConfig[brd].BaseIoAddr != 0)
  {
    good = 1;
    if (PciConfig[brd].Claimed)  // used
      good = 0;

    switch (match_option)
    {
      case 0:
        if (id_to_num_ports(PciConfig[brd].PCI_DevID) != config->NumPorts)
          good = 0;
      break;
      case 1:
        if (id_to_num_ports(PciConfig[brd].PCI_DevID) < config->NumPorts)
          good = 0;
      break;
    }

    if (good)  // assign it.
    {
      config->BusNumber  = PciConfig[brd].BusNumber;
      config->PCI_Slot   = PciConfig[brd].PCI_Slot;
      config->PCI_DevID  = PciConfig[brd].PCI_DevID;
      config->PCI_RevID  = PciConfig[brd].PCI_RevID;
      config->PCI_SVID   = PciConfig[brd].PCI_SVID;
      config->PCI_SID    = PciConfig[brd].PCI_SID;
      config->BaseIoAddr = PciConfig[brd].BaseIoAddr;
      config->Irq        = PciConfig[brd].Irq;
      config->BusType    = PCIBus;

      config->AiopIO[0]  = config->BaseIoAddr;

      // bugfix, 9-30-98  9:20 A.M.
      PciConfig[brd].Claimed = 1;  // used

      return 0;  // ok, found
      //SetupConfig(config);  // fill in NumPorts based on model, etc
    }

    ++brd;
  }
  return 1;  // err, not found
}

/*----------------------------------------------------------------------
 RcktConnectInt -  Connect the Driver.isr to an Interrupt
|----------------------------------------------------------------------*/
NTSTATUS RcktConnectInt(IN PDRIVER_OBJECT DriverObject)
{

  NTSTATUS status;

  KINTERRUPT_MODE InterruptMode;
  BOOLEAN ShareVector;
  ULONG Vector;
  KIRQL Irql;
  KAFFINITY ProcessorAffinity;

  MyKdPrint(D_Init,("RcktConnectInt\n"))
  status = STATUS_SUCCESS;

  //------ Get an interrupt vector from HAL
  Vector = HalGetInterruptVector(
                      Driver.irq_ext->config->BusType,
                      Driver.irq_ext->config->BusNumber,
                      Driver.irq_ext->config->Irq,
                      Driver.irq_ext->config->Irq,
                      &Irql,
                      &ProcessorAffinity);

#if DBG
  //Eprintf("b:%d,n:%d,i:%d",
  //                    Driver.irq_ext->config->BusType,
  //                    Driver.irq_ext->config->BusNumber,
  //                    Driver.irq_ext->config->Irq);
#endif
  MyKdPrint(D_Init,("Vector %x Irql %x Affinity %x\n",
                       Vector, Irql, ProcessorAffinity))
  
  MyKdPrint(D_Init,("Connecting To IRQ %x on a %x bus \n",
                       Driver.irq_ext->config->Irq,
                       Driver.irq_ext->config->BusType))

  // Rocket port doesn't need a context for the ISR
  //Driver.OurIsrContext = NULL;
  //Driver.OurIsr = SerialISR;

  if(Driver.irq_ext->config->BusType == PCIBus)
  {
    InterruptMode = LevelSensitive; //PCI style
    ShareVector = TRUE;
  }
  else  // ISA
  {
    InterruptMode = Latched;   //ISA style
    ShareVector = FALSE;
  }

  status = IoConnectInterrupt(
                     &Driver.InterruptObject,
                     (PKSERVICE_ROUTINE) SerialISR, // Driver.OurIsr,
                     NULL,      // Driver.OurIsrContext,
                     NULL,
                     Vector,
                     Irql,
                     Irql,
                     InterruptMode,
                     ShareVector,
                     ProcessorAffinity,
                     FALSE);

  MyKdPrint(D_Init,("Vector %x Irql %x Affity %x Irq %x\n",
                Vector, Irql,
                ProcessorAffinity,
                Driver.irq_ext->config->Irq))

  if (!NT_SUCCESS(status))
  {
    Driver.InterruptObject = NULL;
    MyKdPrint(D_Init,("Not Avalable IRQ:%d, Status:%xH",
                Driver.irq_ext->config->Irq, status))
  }

  return status;
}


/*----------------------------------------------------------------------
 VerboseLogBoards - Log the Board IO, IRQ configuration.
|----------------------------------------------------------------------*/
void VerboseLogBoards(char *prefix)
{
  int k;
  char tmpstr[80];
  PSERIAL_DEVICE_EXTENSION board_ext;

  MyKdPrint(D_Init,("VerboseLogBoards\n"))

  k = 0;
  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    strcpy(tmpstr, prefix);
    Sprintf(&tmpstr[strlen(tmpstr)], " Brd:%d,IO:%xH,NumCh:%d,NumA:%d,Bus:%d",
       k+1,
       board_ext->config->AiopIO[0],
       board_ext->config->NumPorts,
       board_ext->config->NumAiop,
       board_ext->config->BusType);

    //Sprintf(&tmpstr[strlen(tmpstr)], ",Irq:%d", board_ext->config->.Irq);
    Eprintf(tmpstr); // Log it

    board_ext = board_ext->board_ext;
    ++k;
  }
}

/*-----------------------------------------------------------------------
 SetupRocketCfg - Sets up the details in the DEVICE_CONFIG structure
    based on the information passed to it from DriverEntry() or PnP.
   The NT4.0 DriverEntry handling should be easy, because our boards
   are ordered by us.  NT5.0 is more complex, because we may not see
   the "first" rocketport board in the correct order.
|-----------------------------------------------------------------------*/
int SetupRocketCfg(int pnp_flag)
{
  //int i,j;
  //DEVICE_CONFIG *cfctl;

  int have_isa_boards = 0;
  PSERIAL_DEVICE_EXTENSION first_isa_ext;
  PSERIAL_DEVICE_EXTENSION ext;
  int pnp_isa_index = 1;
  ULONG first_isa_MudbacIO;


  MyKdPrint(D_Init,("SetupRocketCfg\n"))
  // Set up the Mudbac I/O addresses
  // see if we have any isa-boards, and mark a ptr to this first board.
  ext = Driver.board_ext;
  while (ext)
  {
    if (ext->config->BusType == Isa)
    {
      have_isa_boards = 1;
    }
    ext = ext->board_ext;  // next in chain
  }  // while ext

  if (have_isa_boards)
  {
    MyKdPrint(D_Init,("Stp1\n"))
    first_isa_ext = FindPrimaryIsaBoard();
    if (first_isa_ext == NULL)
    {
      MyKdPrint(D_Init,("Err1X\n"))
      if (Driver.VerboseLog)
        Eprintf("First Isa-brd not 44H io");
      // return 1;  // err
      first_isa_MudbacIO = 0x1c0;  // this is cheating
    }
    else
    {
      MyKdPrint(D_Init,("Stp2\n"))

      //----- setup the initial Mudback IO
      if (first_isa_ext->config->MudbacIO == 0)
        first_isa_ext->config->MudbacIO = first_isa_ext->config->AiopIO[0] + 0x40;
      first_isa_MudbacIO = first_isa_ext->config->MudbacIO;
    }

    //----- setup any remaining Mudback IO addresses
    ext = Driver.board_ext;
    while (ext)
    {
      if (ext->config->BusType == Isa)
      {
        if ((ext != first_isa_ext) && (ext->config->BaseIoSize == 0x44))
        {
          MyKdPrint(D_Init,("Unused MudbackIO\n"))
          // don't allow them to configure two boards with space for mudback.
          ext->config->BaseIoSize = 0x40;
        }

        if ((ext != first_isa_ext) && (ext->config->BaseIoSize == 0x40))
        {
          if (ext->config->ISABrdIndex == 0)
          {
            // this case shouldn't come up, pnpadd.c code generates index
            // and saves it to the registry.  Or nt40 driverentry does it.
            MyKdPrint(D_Init,("Bad IsaIndx\n"))
            ext->config->ISABrdIndex = pnp_isa_index;
          }
          ++pnp_isa_index;

          // setup the Mudback IO
          ext->config->MudbacIO = first_isa_MudbacIO +
            (ext->config->ISABrdIndex * 0x400);
        }
      }
      ext = ext->board_ext;  // next in chain
    }  // while ext
  }

  // Set up the rest of the Aiop addresses
  ext = Driver.board_ext;
  while (ext)
  {
    ConfigAIOP(ext->config);   //SetupConfig(ext->config);
    ext = ext->board_ext;  // next in chain
  }  // while ext

  return(0);
}

/*-----------------------------------------------------------------------
 ConfigAIOP -  Setup the number of AIOP's based on:

    * if PCI, use the pci-id to determine number of ports, since
    detecting is unreliable do to back-to-back aiop-is slots possibility.

    * if ISA, set to max and let init controller figure it out.
|-----------------------------------------------------------------------*/
int ConfigAIOP(DEVICE_CONFIG *config)
{
  int j;
  int found_ports=0;

  MyKdPrint(D_Init,("ConfigAIOP\n"))

  if (config->BusType == Isa)      /* Set up ISA adrs */
  {
    if (config->NumPorts == 0)
      config->NumAiop=AIOP_CTL_SIZE;  // let init figure it out
    else if (config->NumPorts <= 8)
      config->NumAiop=1;
    else if (config->NumPorts <= 16)
      config->NumAiop=2;
    else if (config->NumPorts <= 32)
      config->NumAiop=4;

    for(j = 1;j < config->NumAiop;j++)         /* AIOP aliases */
      config->AiopIO[j] = config->AiopIO[j - 1] + 0x400;
  }

  if (config->BusType == PCIBus)      // Set up PCI adrs
  {
    switch (config->PCI_DevID)
    {
      case PCI_DEVICE_4Q:   // 4 Port Quadcable
      case PCI_DEVICE_4RJ:   // 4 Port RJ
        found_ports=4;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      case PCI_DEVICE_8RJ:   // 8 Port RJ
      case PCI_DEVICE_8O:   // 8 Port Octacable
      case PCI_DEVICE_8I:  // 8 Port interface
      case PCI_DEVICE_SIEMENS8:
        found_ports=8;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      case PCI_DEVICE_SIEMENS16:
      case PCI_DEVICE_16I:  //16 Port interface
        found_ports=16;
        config->NumAiop=2;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = config->BaseIoAddr + 0x40;
        break;

      case PCI_DEVICE_32I:  // 32 Port interface
        found_ports=32;
        config->NumAiop=4;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = config->BaseIoAddr + 0x40;
        config->AiopIO[2] = config->BaseIoAddr + 0x80;
        config->AiopIO[3] = config->BaseIoAddr + 0xC0;
        break;

      case PCI_DEVICE_RPLUS2:
      case PCI_DEVICE_422RPLUS2:
        found_ports=2;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = 0;
        break;

      case PCI_DEVICE_RPLUS4:
        found_ports=4;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = 0;
        break;

      case PCI_DEVICE_RPLUS8:
        found_ports=8;
        config->NumAiop=2;
        config->AiopIO[0] = config->BaseIoAddr;
        config->AiopIO[1] = config->BaseIoAddr + 0x40;
        config->AiopIO[2] = 0;
        break;

      case PCI_DEVICE_RMODEM6:
        found_ports=6;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      case PCI_DEVICE_RMODEM4:
        found_ports=4;
        config->NumAiop=1;
        config->AiopIO[0] = config->BaseIoAddr;
        break;

      default:
        found_ports=0;
        config->NumAiop=0;
        Eprintf("Err,Bad PCI Dev ID!");
        break;
    }  // switch

    // allow for user configured smaller number of ports
    if ((config->NumPorts == 0) || (config->NumPorts > found_ports))
      config->NumPorts = found_ports;

  }  // if pci

  return 0;  // ok
}

/*-----------------------------------------------------------------------
  SerialUnReportResourcesDevice -
    This routine unreports the resources used for the board.
|-----------------------------------------------------------------------*/
VOID SerialUnReportResourcesDevice(IN PSERIAL_DEVICE_EXTENSION Extension)
{
  CM_RESOURCE_LIST resourceList;
  ULONG sizeOfResourceList = 0;
  char name[70];
  BOOLEAN junkBoolean;

  MyKdPrint(D_Init,("UnReportResourcesDevice\n"))
    RtlZeroMemory(&resourceList, sizeof(CM_RESOURCE_LIST));

  resourceList.Count = 0;
  strcpy(name, szResourceClassName);
  our_ultoa(Extension->UniqueId, &name[strlen(name)], 10);

  IoReportResourceUsage(
      CToU1(name),
      Extension->DeviceObject->DriverObject,
      NULL,
      0,
      Extension->DeviceObject,
      &resourceList,
      sizeof(CM_RESOURCE_LIST),
      FALSE,
      &junkBoolean);
}

/*-----------------------------------------------------------------------
 RocketReportResources -
|-----------------------------------------------------------------------*/
int RocketReportResources(IN PSERIAL_DEVICE_EXTENSION extension)
{
  PCM_RESOURCE_LIST resourceList;
  ULONG sizeOfResourceList;
  ULONG countOfPartials;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
  NTSTATUS status;
  PHYSICAL_ADDRESS MyPort;
  BOOLEAN ConflictDetected;
  BOOLEAN MappedFlag;
  int i,j;
  int brd = extension->UniqueId;
  DEVICE_CONFIG *Ctl;
  char name[70];

  MyKdPrint(D_Init,("ReportResources\n"))
  ConflictDetected=FALSE;

  countOfPartials=0;
  Ctl = extension->config;

#ifdef USE_HAL_ASSIGNSLOT
  if (Ctl->BusType == PCIBus)
  {
    //-------- Report the resources indicated by partial list (resourceList)
    strcpy(name, szResourceClassName);
    our_ultoa(extension->UniqueId, &name[strlen(name)], 10);

    status= HalAssignSlotResources (
        &Driver.RegPath,                       // RegistryPath
        CToU1(name),                           // DriverClassName(optional)
        extension->DeviceObject->DriverObject, // DriverObject
          // Driver.GlobalDriverObject,        // 
        NULL,                                  // DeviceObject(optional)
        Ctl->BusType,  // PCIBus
        Ctl->BusNumber,  // Bus Num
        Ctl->PCI_Slot,  // slot num
        &resourceList); // IN OUT PCM_RESOURCE_LIST *AllocatedResources

    if (status != STATUS_SUCCESS)
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR21");
      return(1);
    }
    if (resourceList == NULL)
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR22");
      return(2);
    }

    if (resourceList->Count != 1)
    {
      if (Driver.VerboseLog)
        Eprintf("Err ResCnt RR23");
      return(3);
    }

    countOfPartials = resourceList->List[0].PartialResourceList.Count;
    if ( ((countOfPartials > 2) &&
          (Ctl->PCI_SVID != PCI_VENDOR_ID)) ||
         (countOfPartials < 1)) {
      if (Driver.VerboseLog)
        Eprintf("Err ResCnt RR24");
      return(4);
    }

    if (resourceList->List[0].InterfaceType != PCIBus)
    {
      if (Driver.VerboseLog)
        Eprintf("Err ResCnt RR25");
      return(5);
    }
    partial = &resourceList->List[0].PartialResourceList.PartialDescriptors[0];
    for (i=0; i<(int)countOfPartials; i++)
    {
//    partial->u.Port.Start = MyPort;
//    partial->u.Port.Length = SPANOFMUDBAC;
      switch(partial->Type)
      {
        case CmResourceTypePort:
          if ((partial->u.Port.Length != SPANOFAIOP) &&
              (partial->u.Port.Length != (SPANOFAIOP*2)) &&
              (partial->u.Port.Length != (SPANOFAIOP*3)) &&
              (partial->u.Port.Length != (SPANOFAIOP*4)) )
          {
            if (Driver.VerboseLog)
              Eprintf("Err RR35");
            return 6;
          }
          Ctl->pAiopIO[0] =
             SerialGetMappedAddress(Ctl->BusType,
                     Ctl->BusNumber,
                     partial->u.Port.Start,
                     partial->u.Port.Length,
                     1,  // port-io
                     &MappedFlag,1);

          if (Ctl->pAiopIO[0] == NULL)
          {
            if (Driver.VerboseLog)
              Eprintf("Err RR36");
            return 7;
          }
          Ctl->pAiopIO[1] = Ctl->pAiopIO[0] + 0x40;
          Ctl->pAiopIO[2] = Ctl->pAiopIO[0] + 0x80;
          Ctl->pAiopIO[3] = Ctl->pAiopIO[0] + 0xc0;

          Ctl->AiopIO[0] = partial->u.Port.Start.LowPart;
          Ctl->AiopIO[1] = partial->u.Port.Start.LowPart + 0x40;
          Ctl->AiopIO[2] = partial->u.Port.Start.LowPart + 0x80;
          Ctl->AiopIO[3] = partial->u.Port.Start.LowPart + 0xc0;
          break;

        case CmResourceTypeInterrupt:
#ifdef DO_LATER
#endif
          break;

        case CmResourceTypeMemory:
#ifdef DO_LATER
#endif
          break;

        default:
          if (Driver.VerboseLog)
            Eprintf("Err ResCnt RR26");
          return(8);
      }
      ++partial;  // to next io-resource in list.
    }

    // Release the memory used for the resourceList
    if (resourceList)
      ExFreePool(resourceList);
    resourceList = NULL;

    return(0);
  }
#endif

  if (Ctl->BusType == Isa)
    countOfPartials++;        //Mudbacs only exist on ISA Boards

  MyKdPrint(D_Init,("Report Resources brd:%d bus:%d\n",brd+1, Ctl->BusType))

  for (j=0; j<Ctl->NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
      countOfPartials++;  // For each Aiop, we will get resources
  }

  if (Driver.irq_ext == extension)
  {
    MyKdPrint(D_Init,("IRQ:%d\n",Driver.SetupIrq))
    countOfPartials++;   // plus 1 for IRQ info
  }

  sizeOfResourceList = sizeof(CM_RESOURCE_LIST) +
                       sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +  // add, kpb
                        (sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)*
                        countOfPartials);

                       // add 64 for slop -kpb(this structure sucks)
  resourceList = ExAllocatePool(PagedPool, sizeOfResourceList+64);

  if (!resourceList)
  {
    if (Driver.VerboseLog)
      Eprintf("No ResourceList");

    EventLog(extension->DeviceObject->DriverObject,
               ////Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    return(9);
  }

  RtlZeroMemory(resourceList, sizeOfResourceList);

  resourceList->Count = 1;
  resourceList->List[0].InterfaceType = Ctl->BusType;
  resourceList->List[0].BusNumber = Ctl->BusNumber;  //change for multibus
  resourceList->List[0].PartialResourceList.Count = countOfPartials;
  partial = &resourceList->List[0].PartialResourceList.PartialDescriptors[0];

  // Account for the space used by the Rocket.
  // Report the use of the Mudbacs on Isa boards only
  if (Ctl->BusType == Isa)
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;
    partial->Type = CmResourceTypePort;
    partial->ShareDisposition = CmResourceShareDeviceExclusive;
    partial->Flags = CM_RESOURCE_PORT_IO;
    partial->u.Port.Start = MyPort;
    partial->u.Port.Length = SPANOFMUDBAC;
    partial++;
  }

  for (j=0; j<Ctl->NumAiop; j++)
  {
    // Report the use of the AIOPs.
    if (Ctl->AiopIO[j] > 0)
    {
      MyPort.HighPart=0x0;
      MyPort.LowPart=Ctl->AiopIO[j];
      partial->Type = CmResourceTypePort;
      partial->ShareDisposition = CmResourceShareDeviceExclusive;
      partial->Flags = CM_RESOURCE_PORT_IO;
      partial->u.Port.Start = MyPort;
      partial->u.Port.Length = SPANOFAIOP;
      partial++;
    }
    else
    {
      MyKdPrint(D_Init,("Aiop Count Wrong, A.\n"))
      if (Driver.VerboseLog)
        Eprintf("Error RR12");
    }
  }  // end for j


  if (Driver.irq_ext == extension)
  {
    // Report the interrupt information.
    partial->Type = CmResourceTypeInterrupt;

    if(Ctl->BusType == PCIBus)
    {
      partial->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
      partial->ShareDisposition = CmResourceShareShared;
    }
    else // if (Ctl->BusType == Isa)  //Isa and Pci use differnt int mech
    {
      partial->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
      partial->ShareDisposition = CmResourceShareDriverExclusive;
    }

    partial->u.Interrupt.Vector = Driver.SetupIrq;
    partial->u.Interrupt.Level = Driver.SetupIrq;
#ifdef DO_LATER
   // is the above wrong???
#endif
    // partial->u.Interrupt.Affinity = -1; //per CM_PARTIAL_RESOURCE_DESCRIPTOR
    partial++;                          // definition  DbgPrintf
  }

  //-------- Report the resources indicated by partial list (resourceList)
  strcpy(name, szResourceClassName);
  our_ultoa(extension->UniqueId, &name[strlen(name)], 10);

  MyKdPrint(D_Init,("Reporting Resources To system\n"))
  status=IoReportResourceUsage(
      CToU1(name),                     // DriverClassName OPTIONAL,
      extension->DeviceObject->DriverObject,  // DriverObject,
      // Driver.GlobalDriverObject,
      NULL,                          // DriverList OPTIONAL,
      0,                             // DriverListSize OPTIONAL,
      extension->DeviceObject,       // DeviceObject
      resourceList,                  // DeviceList OPTIONAL,
      sizeOfResourceList,            // DeviceListSize OPTIONAL,
      FALSE,                         // OverrideConflict,
      &ConflictDetected);            // ConflictDetected

  if (!NT_SUCCESS(status))
  {
    if (Driver.VerboseLog)
      Eprintf("Err RR13");
    MyKdPrint(D_Init,("Error from IoReportResourceUsage.\n"))
  }

  if (ConflictDetected) 
  {
    Eprintf("Error, Resource Conflict.");
    if (resourceList)
      ExFreePool(resourceList);
    resourceList = NULL;
    EventLog(extension->DeviceObject->DriverObject,
             ////Driver.GlobalDriverObject,
             STATUS_SUCCESS,
             SERIAL_INSUFFICIENT_RESOURCES,
             0, NULL);
    MyKdPrint(D_Init,("Resource Conflict Detected.\n"))
    return(10);
  }

  // OK, even more important than reporting resources is getting
  // the pointers to the I/O ports!!

  if (Ctl->BusType == Isa)
  {
    MyPort.HighPart=0x0;
    MyPort.LowPart=Ctl->MudbacIO;

    Ctl->pMudbacIO =
        SerialGetMappedAddress(Isa,Ctl->BusNumber,MyPort,SPANOFMUDBAC,1,&MappedFlag,1);
    if (Ctl->pMudbacIO == NULL) 
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR15");
      MyKdPrint(D_Init,("Resource Error A.\n"))
      return 11;
    }
  }

  for (j=0; j<Ctl->NumAiop; j++)
  {
    if (Ctl->AiopIO[j] > 0)
    {
      MyPort.HighPart=0x0;
      MyPort.LowPart=Ctl->AiopIO[j];
      Ctl->pAiopIO[j] =
          SerialGetMappedAddress(Ctl->BusType,
                      Ctl->BusNumber,MyPort,SPANOFAIOP,1,&MappedFlag,1);

      if (Ctl->pAiopIO[j] == NULL) 
      {
        if (Driver.VerboseLog)
          Eprintf("Err RR16");
        MyKdPrint(D_Init,("Resource Error B.\n"))
        return 12;
      }

    }
    else
    {
      if (Driver.VerboseLog)
        Eprintf("Err RR17");
      MyKdPrint(D_Init,("Aiop Count Wrong, B.\n"))
      return 13;
    }
  }

  extension->io_reported = 1; // tells that we should deallocate on unload.

  // Release the memory used for the resourceList
  if (resourceList)
    ExFreePool(resourceList);
  resourceList = NULL;
  MyKdPrint(D_Init,("Done Reporting Resources\n"))
  return 0;
}

/*-----------------------------------------------------------------------
 InitController -
|-----------------------------------------------------------------------*/
int InitController(PSERIAL_DEVICE_EXTENSION ext)
{
  int Aiop;                           /* AIOP number */
  CONTROLLER_T *CtlP;                 /* ptr to controller structure */
  int periodic_only = 1;
  CHANNEL_T *Chan;                    /* channel structure */
  CHANNEL_T ch;                       /* channel structure */
  int Irq;
  int freq;                           // poll frequency
  int Ch;                             /* channel number */
  int NumChan;
  static int Dev = 0;
  int Ctl = (int) ext->UniqueId;
  DEVICE_CONFIG *pConfig = ext->config;

//   if (pConfig->pMudbacIO,
  MyKdPrint(D_Init,("InitController\n"))

  if (ext == Driver.irq_ext)  // irq extension
  {
    Irq = pConfig->Irq;
#if DBG
//     Eprintf("Irq Used:%d", Irq);
#endif
    if (Driver.ScanRate == 0)
      freq = FREQ_137HZ;
    else if (Driver.ScanRate <= 2)
    {
      if (pConfig->BusType == PCIBus)
        freq = FREQ_560HZ;
      else
        freq = FREQ_274HZ;
    }
    else if (Driver.ScanRate <= 5)   freq = FREQ_274HZ;
    else if (Driver.ScanRate <= 10)  freq = FREQ_137HZ;
    else if (Driver.ScanRate <= 20)  freq = FREQ_69HZ;
    else if (Driver.ScanRate <= 35)  freq = FREQ_34HZ;
    else if (Driver.ScanRate <= 70)  freq = FREQ_17HZ;
    else                             freq = FREQ_137HZ;
  }
  else
  {
    freq = 0;
    Irq=0;
  }

  if ( (ext->config->BusType == PCIBus) &&
       ((ext->config->PCI_DevID == PCI_DEVICE_RPLUS2) ||
        (ext->config->PCI_DevID == PCI_DEVICE_422RPLUS2) ||
		(ext->config->PCI_DevID == PCI_DEVICE_RPLUS4) ||
        (ext->config->PCI_DevID == PCI_DEVICE_RPLUS8)) )
     ext->config->IsRocketPortPlus = 1;  // true if rocketport plus hardware

  // setup default ClkRate if not specified
  if (ext->config->ClkRate == 0)
  {
    // use default
    if (ext->config->IsRocketPortPlus)  // true if rocketport plus hardware
      ext->config->ClkRate = DEF_RPLUS_CLOCKRATE;
    else
      ext->config->ClkRate = DEF_ROCKETPORT_CLOCKRATE;
  }

  // setup default PreScaler if not specified
  if (ext->config->ClkPrescaler == 0)
  {
    // use default
    if (ext->config->IsRocketPortPlus)  // true if rocketport plus hardware
      ext->config->ClkPrescaler = DEF_RPLUS_PRESCALER;
    else
      ext->config->ClkPrescaler = DEF_ROCKETPORT_PRESCALER;
  }

  // --- stop doing this, 5-7-98, setup now sets, we could check!
  //pConfig->NumPorts = 0;  // this gets calculated in initcontroller

  CtlP = ext->CtlP;      // point to our board struct

  CtlP->ClkPrescaler = (BYTE)ext->config->ClkPrescaler;
  CtlP->ClkRate = ext->config->ClkRate;

  // Initialize PCI Bus and  Dev
  CtlP->BusNumber = (UCHAR)pConfig->BusNumber;
  CtlP->PCI_Slot = (UCHAR)pConfig->PCI_Slot;

  CtlP->PCI_DevID = pConfig->PCI_DevID;
  CtlP->PCI_SVID = pConfig->PCI_SVID;
  CtlP->PCI_SID = pConfig->PCI_SID;

#ifdef TRY_EVENT_IRQ
  periodic_only = 0;
#endif

  if (pConfig->BusType == Isa)
  {
    MyKdPrint(D_Init,("Mbio:%x %x IO len:%x\n",
        pConfig->MudbacIO, pConfig->pMudbacIO, pConfig->BaseIoSize))
  }
  MyKdPrint(D_Init,("Aiopio:%x %x num:%x\n",
      pConfig->AiopIO[0], pConfig->pAiopIO[0], pConfig->NumAiop))

  if (sInitController(CtlP, // Ctl,
                      pConfig->pMudbacIO,
                      pConfig->pAiopIO,
                      pConfig->AiopIO,
                      pConfig->NumAiop,
                      Irq,
                      (unsigned char)freq,
                      TRUE,
                      pConfig->BusType,
                      pConfig->ClkPrescaler) != 0)
  {
    Eprintf("Error, Failed Init, Brd:%d, IO:%xH",
       Ctl, pConfig->AiopIO[0]);
    if (Driver.VerboseLog)
    {
      Eprintf("Init: pM:%x,pA:%x,N:%d,B:%d",
              pConfig->pMudbacIO, pConfig->pAiopIO[0], pConfig->NumAiop,
              pConfig->BusType);
    }
    // This controller was in the registry, but it couldn't be initialized
    pConfig->RocketPortFound = FALSE;
    //pConfig->NumChan = 0; stop messing with NumPorts
    return 2;  // err
  }
  else
  {
    // this controller was successfully initialized
    // if it's the first one found, tell the rest of the init that
    // it should be the one to interrupt.
    pConfig->RocketPortFound = TRUE;
  }

  for(Aiop = 0;Aiop < CtlP->NumAiop; Aiop++)
  {
    if (CtlP->BusType == Isa)
      sEnAiop(CtlP,Aiop);

    NumChan = CtlP->AiopNumChan[Aiop];

    for(Ch = 0; Ch < NumChan; Ch++)
    {
      Chan = &ch;

      //MyKdPrint(D_Init,("sInitChan %d\n", Ch+1))
      if(!sInitChan(CtlP,Chan,Aiop,(unsigned char)Ch))
      {
        if (Driver.VerboseLog)
          Eprintf("Err Ch %d on Brd %d", Ch+1, Ctl+1);

        MyKdPrint(D_Error,("sInitChan %d\n", Ch+1))
        return (-1);
      }
      Dev++;
    }  // for ch
    // pConfig->NumChan += NumChan; [kpb, 5-7-98, stop messing with config]
  }  // for Aiop

  if (Driver.VerboseLog)
  {
    Eprintf("Initialized OK, Brd:%d, IO:%xH",
            Ctl+1, pConfig->AiopIO[0]);
  }

  return 0;
}

/*----------------------------------------------------------------------
  StartRocketIRQorTimer -
|----------------------------------------------------------------------*/
void StartRocketIRQorTimer(void)
{
#ifdef DO_ROCKET_IRQ
  //--------------- Connect to IRQ, or start Timer.
  if (Driver.irq_ext)
  {
    status = RcktConnectInt(DriverObject);
    if (!NT_SUCCESS(status))
    {
      Eprintf("Error,IRQ not found, using Timer!");
      Driver.irq_ext = NULL;
      Driver.SetupIrq = 0;  // use timer instead
    }
  }

  //--- kick start the interrupts
  if (Driver.irq_ext)    // if using interrupt
  {
    CtlP = Driver.irq_ext->CtlP;  // first boards struct
    if(CtlP->BusType == Isa)
    {
      MyKdPrint(D_Init,("ISA IRQ Enable.\n"))
      sEnGlobalInt(CtlP);
    }
    if(CtlP->BusType == PCIBus)
    {
      MyKdPrint(D_Init,("PCI IRQ Enable.\n"))
      sEnGlobalIntPCI(CtlP);
    }
  }
  else
#endif
  {
    MyKdPrint(D_Init,("Initializing Timer\n"))
    RcktInitPollTimer();

    MyKdPrint(D_Init,("Set Timer\n"))
    KeSetTimer(&Driver.PollTimer,
               Driver.PollIntervalTime,
               &Driver.TimerDpc);
  }
}

#ifdef DO_ROCKET_IRQ
/*----------------------------------------------------------------------
  SetupRocketIRQ - 
|----------------------------------------------------------------------*/
void SetupRocketIRQ(void)
{
  PSERIAL_DEVICE_EXTENSION ext;

  //------ Determine a board to use for interrupts
  Driver.irq_ext = NULL;
  if (Driver.SetupIrq != 0)
  {
    ext = Driver.board_ext;
    while(ext)
    {
      if (Driver.SetupIrq == 1)  // auto-pci irq pick
      {
        if ((ext->config->BusType == PCIBus) &&
            (ext->config->Irq != 0))
        {
          Driver.irq_ext = ext; // found a pci-board with irq
          break;  // bail from while
        }
      }
      else
      {
        if (ext->config->BusType == Isa)
        {
          ext->config->Irq = Driver.SetupIrq;
          Driver.irq_ext = ext; // found a isa-board with irq
          break;  // bail from while
        }
      }
      ext = ext->board_ext;  // next
    }
    if (Driver.irq_ext == NULL)  // board for irq not found
    {
      Eprintf("Warning, IRQ not available");
    }
  }
}
#endif

/*----------------------------------------------------------------------
  init_cfg_rocket - rocketport specific startup code.  Setup some of
    the config structs, look for PCI boards in system, match them up.
|----------------------------------------------------------------------*/
NTSTATUS init_cfg_rocket(IN PDRIVER_OBJECT DriverObject)
{
  // Holds status information return by various OS and driver
  // initialization routines.
  UCHAR NumPCIBuses, NumPCIRockets, NumISARockets, all_found;
  PSERIAL_DEVICE_EXTENSION board_ext;

  int do_pci_search = 0;

  //------ get the Box information from setup.exe

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if (board_ext->config->IoAddress == 1) // PCI board setup
      do_pci_search = 1;
    board_ext = board_ext->board_ext;
  }

  //---- tally up boards
  //---- interrupting board always first.
  NumPCIRockets = 0;
  NumISARockets = 0;

  // configure ISA boards, and see if we have any pci boards
  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if (board_ext->config->IoAddress >= 0x100)  // ISA io address
    {
      board_ext->config->BusType = Isa;
      board_ext->config->AiopIO[0] = board_ext->config->IoAddress;
      board_ext->config->BaseIoAddr = board_ext->config->IoAddress;

      board_ext->config->ISABrdIndex = NumISARockets;
      if (NumISARockets == 0)
           board_ext->config->BaseIoSize = 0x44;
      else board_ext->config->BaseIoSize = 0x40;

      ++NumISARockets;
    }
    else if (board_ext->config->IoAddress == 1)  // PCI board setup
    {
      ++NumPCIRockets;  // we have some pci boards configured
    }
    else if (board_ext->config->IoAddress == 0)  // bad setup
    {
      Eprintf("Error, Io Address is 0.");
      EventLog(DriverObject, STATUS_SUCCESS, SERIAL_RP_INIT_FAIL, 0, NULL);
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }

    board_ext = board_ext->board_ext;  // next
  }

  // configure PCI boards, and see if we have any pci boards
  if (NumPCIRockets > 0)  // we have some pci boards configured
  {
    NumPCIBuses = FindPCIBus();
    if (NumPCIBuses == 0)
    {
      Eprintf("Error, No PCI BUS");
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
    if (FindPCIRockets(NumPCIBuses) != 0) // err, none found
    {
      Eprintf("Error, PCI board not found");
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }

    all_found = 1;
    board_ext = Driver.board_ext;
    while (board_ext != NULL)
    {
      if (board_ext->config->IoAddress == 1)  // PCI board setup
      {
        // see if direct matches exist
        if (FindPCIRocket(board_ext->config, 0) != 0)
        {
          all_found = 0;  // not found
        }
      }
      board_ext = board_ext->board_ext;  // next
    }  // while more boards

    // try again, this time allowing NumPorts <= actual_ports
    if (!all_found)
    {
      board_ext = Driver.board_ext;
      while (board_ext != NULL)
      {
        if ((board_ext->config->IoAddress == 1) &&  // PCI board setup
            (board_ext->config->BaseIoAddr == 0))  // not setup yet
        {
          // see if match exist, NumPorts <= actual_ports
          if (FindPCIRocket(board_ext->config, 1) != 0)
          {
            Eprintf("Error, PCI brd %d setup", BoardExtToNumber(board_ext)+1);
            return STATUS_SERIAL_NO_DEVICE_INITED;
          }
        }
        board_ext = board_ext->board_ext;  // next
      }  // while more boards
      Eprintf("Warning, PCI num-ports mismatch");
    }  // if (!all_found)
  } // if (NumPCIRockets > 0)

  return STATUS_SUCCESS;
}

/********************************************************************

  load up the modem microcode from disk.

********************************************************************/
int LoadModemCode(char *Firm_pathname,char *Loader_pathname)
{
#ifdef S_RK
  MODEM_IMAGE   Mi;
  MODEM_IMAGE   *pMi;
  static char   *Firm_def_pathname = {MODEM_CSREC_PATH};
  static char   *Loader_def_pathname = {MODEM_CSM_SREC_PATH};

#define  MLOADER_TYPE  "CSM"
#define  FIRM_TYPE   "MFW"

  // flush any leftovers...
  FreeModemFiles();
  pMi = &Mi;

  // first, do the FLM or CSM loader...
  pMi->imagepath = Loader_pathname;
  pMi->image     = (UCHAR *)NULL;
  pMi->imagesize = (ULONG)0;
  pMi->imagetype = MLOADER_TYPE;
  pMi->rc        = 0;

  if (pMi->imagepath == (char *)NULL)
    pMi->imagepath = Loader_def_pathname;

  pMi = ReadModemFile(pMi);

  if (pMi->rc)
    return(pMi->rc);

  Driver.ModemLoaderCodeImage = pMi->image;
  Driver.ModemLoaderCodeSize  = pMi->imagesize;

  //  tinydump(Driver.ModemLoaderCodeImage,Driver.ModemLoaderCodeSize);

  pMi->imagepath  = Firm_pathname;
  pMi->image    = (UCHAR *)NULL;
  pMi->imagesize  = (ULONG)0;
  pMi->imagetype  = FIRM_TYPE;
  pMi->rc     = 0;

  if (pMi->imagepath == (char *)NULL)
    pMi->imagepath = Firm_def_pathname;

  pMi = ReadModemFile(pMi);

  if (pMi->rc) {
    // earlier read of CSM should have been successful, so we should dump
    // the CSM buffer before we bail...
    if (Driver.ModemLoaderCodeImage)
    {
      our_free(Driver.ModemLoaderCodeImage,MLOADER_TYPE);

      Driver.ModemLoaderCodeImage = (UCHAR *)NULL;
      Driver.ModemLoaderCodeSize = 0;
    }
    return(pMi->rc);
  }

  Driver.ModemCodeImage = pMi->image;
  Driver.ModemCodeSize  = pMi->imagesize;

  //  tinydump(Driver.ModemCodeImage,Driver.ModemCodeSize);

#endif
  return(0);
}

/********************************************************************

  free up space no longer necessary...

********************************************************************/
void FreeModemFiles(void)
{
#ifdef S_RK
  if (Driver.ModemLoaderCodeImage)
  {
    our_free(Driver.ModemLoaderCodeImage,MLOADER_TYPE);

    Driver.ModemLoaderCodeImage = (UCHAR *)NULL;
    Driver.ModemLoaderCodeSize  = 0;
  }

  if (Driver.ModemCodeImage)
  {
    our_free(Driver.ModemCodeImage,FIRM_TYPE);

    Driver.ModemCodeImage = (UCHAR *)NULL;
    Driver.ModemCodeSize = 0;
  }
#endif
}

/********************************************************************

  load up a specified file from disk...

********************************************************************/
MODEM_IMAGE * ReadModemFile(MODEM_IMAGE *pMi)
{
#ifdef S_RK
  NTSTATUS                  ntStatus;
  HANDLE                    NtFileHandle;
  OBJECT_ATTRIBUTES         ObjectAttributes;
  IO_STATUS_BLOCK           IoStatus;
  USTR_160                  uname;
  FILE_STANDARD_INFORMATION StandardInfo;
  ULONG                     LengthOfFile;

  CToUStr((PUNICODE_STRING)&uname,
          pMi->imagepath,
          sizeof(uname));

  InitializeObjectAttributes(&ObjectAttributes,
                             &uname.ustr,
                             OBJ_CASE_INSENSITIVE,
                             NULL,
                             NULL);

  ntStatus = ZwCreateFile(&NtFileHandle,
                          SYNCHRONIZE | FILE_READ_DATA,
                          &ObjectAttributes,
                          &IoStatus,
                          NULL,                           // alloc size = none
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,                           // eabuffer
                          0);                             // ealength

  if (!NT_SUCCESS(ntStatus))
  {
    pMi->rc = 1;
    return(pMi);
  }

  // query the object to determine its length...
  ntStatus = ZwQueryInformationFile(NtFileHandle,
                                    &IoStatus,
                                    &StandardInfo,
                                    sizeof(FILE_STANDARD_INFORMATION),
                                    FileStandardInformation );

  if (!NT_SUCCESS(ntStatus))
  {
    ZwClose(NtFileHandle);

    pMi->rc = 2;

    return(pMi);
  }

  LengthOfFile = StandardInfo.EndOfFile.LowPart;

  if (LengthOfFile < 1)
  {
    ZwClose(NtFileHandle);

    pMi->rc = 3;

    return(pMi);
  }

  // allocate buffer for this file...
  pMi->image = (UCHAR *)our_locked_alloc(LengthOfFile,pMi->imagetype);
  if (pMi->image == (UCHAR *)NULL )
  {
    ZwClose(NtFileHandle );

    pMi->rc = 4;

    return(pMi);
  }

  // read the file into our buffer...
  ntStatus = ZwReadFile(NtFileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        pMi->image,
                        LengthOfFile,
                        NULL,
                        NULL);

  if((!NT_SUCCESS(ntStatus)) || (IoStatus.Information != LengthOfFile))
  {
    our_free(pMi->image,pMi->imagetype);

    pMi->rc = 5;

    return(pMi);
  }

  ZwClose(NtFileHandle);

  pMi->imagesize = LengthOfFile;

#endif

  return(pMi);
}

#ifdef DUMPFILE
/********************************************************************

  grind through S3 files, dumping out each line. assumes there
  are embedded CRs/LFs in the stream...

********************************************************************/
void tinydump(char *ptr, int count)
{
  int   tbcount;
  char  tinybuf[128];

  while (count > 0)
  {
    tbcount = 0;
    if (*ptr >= '0')
    {
      while (*ptr >= '0')
      {
        --count;
        tinybuf[tbcount++] = *(ptr++);
      }
    }
    else
    {
      while (*ptr < '0')
      {
        --count;
        ++ptr;
      }
    }
    tinybuf[tbcount] = 0;
    if (tbcount)
      MyKdPrint(D_Init,("%s\r",tinybuf));
  }
  MyKdPrint(D_Init,("\r"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\initvs.c ===
/*-------------------------------------------------------------------
| initvs.c - main init code for VS1000/2000 NT device driver.  Contains
   mostly initialization code.
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

static int CatBindList(IN WCHAR *pwstr);
static void GetBindingNames(void);
static Nic *FindFreeNic(void);
static int BindNameUsed(char *nicname);
static int NicNameUsed(char *nicname);
static void ScanForNewNicCards(void);
static int reg_list_nt50_linkage(void);
static int reg_list_nt40_linkage(void);

/*----------------------------------------------------------------------
 CatBindList - Given the multisz Wchar string read out of the registry,
   convert it to normal c-string multisz list.
|----------------------------------------------------------------------*/
static int CatBindList(IN WCHAR *pwstr)
{
 char *cstr;
 int size = 0;

  cstr = Driver.BindNames;

  MyKdPrint(D_Thread, ("CatBindList\n"))

  // cat on to end of existing list, so find end of list
  while (cstr[size] != 0)
  {
    //MyKdPrint(D_Thread, ("ExList:%s\n", &cstr[size]))
    while (cstr[size] != 0)
      ++size;
    ++size;  // pass up string null to next string
  }
  cstr += size;

  MyKdPrint(D_Thread, ("CatList Size:%d\n", size))

  if (*pwstr == 0)
  {
    MyKdPrint(D_Thread, ("Null List!\n"))
  }

  while ((*pwstr != 0) && (size < 7700))
  {
    // first convert it past the list end and check if its already in the list
    WStrToCStr(cstr+4, pwstr, 200);
    if (!BindNameUsed(cstr+4))
    {
      WStrToCStr(cstr, pwstr, 200);  // put at end of list

      MyKdPrint(D_Thread, ("Bind: %s\n", cstr))

      size = (strlen(cstr) + 1);
      cstr += size;
      *cstr = 0;  // double null end of list
      *(cstr+1) = 0;
    }
    //-----  Advance to the next string of the MULTI_SZ string
    while (*pwstr != 0)
      ++pwstr;
    ++pwstr;
  }

  return 0; // ok
}

/*----------------------------------------------------------------------
 GetBindingNames - Reads Binding info to find possible nic-card export
   names from registry.  Reads the list into Driver.BindNames multisz
   list.
|----------------------------------------------------------------------*/
static void GetBindingNames(void)
{
  if (Driver.BindNames == NULL)
  {
    Driver.BindNames = ExAllocatePool(PagedPool, 8000 * sizeof(WCHAR));
    if (Driver.BindNames == NULL) {
      Eprintf("GetBindingNames no memory");
      return;
    }
  }
  // clear list
  RtlZeroMemory( (PUCHAR)Driver.BindNames, sizeof(WCHAR)*2);

#ifdef NT50
  reg_list_nt50_linkage();
#else
  reg_list_nt40_linkage();
#endif
}

/*----------------------------------------------------------------------
 FindFreeNic - Find an unused Nic structure to try and open.
|----------------------------------------------------------------------*/
static Nic *FindFreeNic(void)
{
 int i;
#ifdef BREAK_NIC_STUFF
  for (i=VS1000_MAX_NICS-1; i>=0; i--)
#else
  for (i=0; i<VS1000_MAX_NICS; i++)
#endif
  {
    if (Driver.nics[i].NICHandle == NULL)
      return &Driver.nics[i];
  }
  return NULL;
}

/*----------------------------------------------------------------------
 BindNameUsed - Return true if Bind Nic name already in bind list.
|----------------------------------------------------------------------*/
static int BindNameUsed(char *nicname)
{
 char *szptr;

  szptr = Driver.BindNames;  // multisz list

  while (*szptr != 0)  // while list of binding nic-names to try
  {
    if (my_lstricmp(szptr, nicname) == 0) // a match
    {
      return 1;  // its in use.
    }

    while (*szptr != 0)  // to next bind string to try
      ++szptr;
    ++szptr;
  } // while (szptr (more bind strings to try)

  return 0;  // its not in use.
}

/*----------------------------------------------------------------------
 NicNameUsed - Return true if Nic name is in use.
|----------------------------------------------------------------------*/
static int NicNameUsed(char *nicname)
{
 int i;
  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if (Driver.nics[i].NicName[0] != 0)
    {
      if (my_lstricmp(Driver.nics[i].NicName, nicname) == 0) // a match
      {
        return 1;  // its in use.
      }
    }
  }
  return 0;  // its not in use.
}

/*----------------------------------------------------------------------
 ScanForNewNicCards - Reads Binding info to find possible nic-card export
   names.  Scans through all nic cards and attempts to open those that 
  have not been successfully opened already.
|----------------------------------------------------------------------*/
static void ScanForNewNicCards(void)
{
 Nic *nic;
 char *szptr;
 int stat;

  MyKdPrint(D_Thread, ("ScanForNewNicCards\n"))

  GetBindingNames();

  szptr = Driver.BindNames;  // multisz list

  if ((szptr == NULL) || (*szptr == 0))
  {
    MyKdPrint(D_Error, ("No Binding\n"))
    return;  // err
  }

  while (*szptr != 0)  // while list of binding nic-names to try
  {
    if (!NicNameUsed(szptr))  // if this name is not in use yet
    {
      nic = FindFreeNic();
      if (nic == NULL)
      {
        MyKdPrint(D_Error, ("Out of Nics\n"))
        break;
      }

      // try to open NIC card
      stat = NicOpen(nic, CToU1(szptr));
      if (stat == 0)
      {
        MyKdPrint(D_Thread, ("Opened nic %s\n", szptr))
      }
      else
      {
        MyKdPrint(D_Thread, ("Failed Opened nic %s\n", szptr))
      }
    }
    else
    {
      MyKdPrint(D_Thread, ("Nic %s already used.\n", szptr))
    }

    while (*szptr != 0)  // to next bind string to try
      ++szptr;
    ++szptr;
  } // while (szptr (more bind strings to try)

  MyKdPrint(D_Thread, ("End ScanForNewNicCards\n"))
}

/*----------------------------------------------------------------------
 NicThread - Scans through all nic cards and attempts to open those that 
  have not been successfully opened already.  If all nic cards are not opened
  successfully timeout for 1 second and try it again.  This function operates
  as a separate thread spawned by Driver_Entry in init.c.  When all the nic
  cards have been successfully opened this thread will terminate itself.
|----------------------------------------------------------------------*/
VOID NicThread(IN PVOID Context)
{
  int i, stat;
  int SearchForNicsFlag;
  int ticks = 0;
  PSERIAL_DEVICE_EXTENSION ext;

  for (;;)
  {
    // this time of wait is critically matched to a timeout associated
    // with killing this task.
    time_stall(10);  // wait 1 second

    Driver.threadCount++;
    //----- open up any unopened the nic cards.
    if (Driver.threadHandle == NULL)  // request to kill ourselves
      break;

    ++ticks;

    if (Driver.Stop_Poll)  // flag to stop poll access
      ticks = 0;  // don't do config stuff now(contention)

    if (Driver.AutoMacDevExt)
    {
      MyKdPrint(D_Test, ("Auto Mac Assign Thread\n"))
      port_set_new_mac_addr(Driver.AutoMacDevExt->pm,
                            Driver.AutoMacDevExt->config->MacAddr);
      write_dev_mac(Driver.AutoMacDevExt);

      Driver.AutoMacDevExt = NULL;
    }

    if (ticks > 60)  // every 60 seconds
    {

      // if any boxes are not in the init state of communications,
      // then assume that there may be a missing nic-card we need to
      // find in the system.
      SearchForNicsFlag = FALSE;

      ext = Driver.board_ext;
      while(ext)
      {
        if (ext->pm->state == ST_INIT)
        {
          SearchForNicsFlag = TRUE;
        }
        ext = ext->board_ext;  // next
      }

      if (SearchForNicsFlag)
      {
        ticks = 0;  // come back around after full 60 second timeout
        ScanForNewNicCards();
      }
      else
        ticks -= 30;  // come back around in 30 seconds
    }
  }

  Driver.threadHandle = NULL;
  // Terminate myself
  PsTerminateSystemThread( STATUS_SUCCESS );
}

#ifdef NT50

/*-----------------------------------------------------------------
 reg_list_nt50_linkage - Find ethernet nic-card names in the
   registry.  Official binding tells us what we are bound to
   via NT's binding rules.  But, this binding process is combersome
   and has problems.  Another technique is to search the registry
   and look for nic-card names to use.  Under NT50, this is easier
   in that there is a Net class, and we can search it for cards
   with "Ethernet" linkage.  So we do both, this gives some backward
   compatibility if we choose to install and get the proper bindings
   and/or if we want to avoid these binding shortcomings by hacking
   our own list of nic-cards from the registry.

   Installing as a protocol might solve some of the linkage problems,
   (and present new problems too.)

NT4.0 and below stores this in "Services\Servicename\Linkage" area.

NT5.0 PnP network card linkage info stored at:
"REGISTRY\Machine\System\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}\0000\Linkage"

Id to determine if node is ours(vs):
"REGISTRY\Machine\System\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}\0000\ComponentId"=
"vslinka_did"
|------------------------------------------------------------------*/
static int reg_list_nt50_linkage(void)
{
  static char *szLowerRange = {"LowerRange"};
  static char *szNdiInterfaces = {"Ndi\\Interfaces"};
  static char *szComponentId = {"ComponentId"};
  static char *szLinkage = {"Linkage"};
  static char *szBind = {"Bind"};
  static char *szExport = {"Export"};
  static char *szRegRMSCCNetGuid = 
   {"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\{4d36e972-e325-11ce-bfc1-08002be10318}"};
  static char *szEthernet = {"Ethernet"};

  static char tmpstr[200];  // make static, don't put too much on stack..
  static char compstr[40];
  static char nodestr[20];
  WCHAR *wstr_ptr;
  char *buffer = NULL;
  char *data_ptr;
  HANDLE KeyHandle = NULL;
  HANDLE KeyHandle2 = NULL;
  HANDLE KeyHandle3 = NULL;
  int node_num = 0;
  int linkage_found = 0;
  int stat;

#define OUR_BUF_SIZE (8000*2)

  MyKdPrint(D_Thread, ("Start RegFind Linkage\n"))

  stat = our_open_key(&KeyHandle, NULL, szRegRMSCCNetGuid, KEY_READ);
  if (stat)
  {
    MyKdPrint(D_Error, ("Failed OpenKey\n"))
    return 1;
  }

  buffer = ExAllocatePool(PagedPool, OUR_BUF_SIZE);
  if ( buffer == NULL ) {
    Eprintf("RegFindLinkage no memory");
    return 1;
  }

  for(;;)
  {
    stat = our_enum_key(KeyHandle,
                        node_num,
                        buffer,
                        OUR_BUF_SIZE,
                        &data_ptr);
    ++node_num;

    if (stat)
    {
       MyKdPrint(D_Thread, ("Done\n"))
       break;
    }

    // does this come back as wchar?
    WStrToCStr(nodestr, (PWCHAR)data_ptr, 18);
    //if (strlen(data_ptr) < 18)
    //  strcpy(nodestr, data_ptr);

    MyKdPrint(D_Thread, ("Got Key Node:%s.\n", nodestr))
  
    // open up the sub-key (0000, 0001, etc..)
    stat = our_open_key(&KeyHandle2, KeyHandle, nodestr, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Error, ("Err 1X\n"))
      continue;
    }

    stat = our_query_value(KeyHandle2,
                           szComponentId,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

    if (stat)
    {
      // no component id
      MyKdPrint(D_Thread, ("No compId\n"))
      compstr[0] = 0;
    }
    else
    {
      WStrToCStr(compstr, (PWCHAR)data_ptr, 38);
    }
    //if (strlen(data_ptr) < 38)
    //  strcpy(compstr, data_ptr);

    MyKdPrint(D_Thread, ("Got compid:%s.\n", compstr))
    if ((my_lstricmp(compstr, "vslink1_did") == 0) ||
         (my_lstricmp(compstr, "vslink2_did") == 0))
    {
      MyKdPrint(D_Thread, ("Match\n"))

      // open up the sub-key "Linkage" and get "Bind" multisz string
      stat = our_open_key(&KeyHandle3, KeyHandle2, szLinkage, KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Thread, ("No Linkage\n"))
        continue;
      }

      stat = our_query_value(KeyHandle3,
                             szBind,
                             buffer,
                             OUR_BUF_SIZE,
                             NULL,  // pDataType
                             &data_ptr);

      if (stat)
      {
        // no component id
        MyKdPrint(D_Thread, ("No Bind\n"))
        continue;
      }
      MyKdPrint(D_Thread, ("Got bind!\n"))

      wstr_ptr = (PWCHAR)(data_ptr);
#if DBG
      //while (*wstr_ptr != 0)  // while more multisz strings
      //{
      //  WStrToCStr(tmpstr, wstr_ptr, 100);
      //  MyKdPrint(D_Thread, ("Got Bind Name:%s.\n", tmpstr))
      //  while (*wstr_ptr != 0)  // pass up this string
      //    ++wstr_ptr;
      //  ++wstr_ptr;
      //}
      //wstr_ptr = (PWCHAR)(data_ptr);
#endif

      CatBindList(wstr_ptr);
      ++linkage_found;
    }
    else  //------- not a VS node
    {
      // so check to see if its a ethernet nic-card which we can
      // use the exported name to add to our bind list

      // open up the sub-key "Ndi\\Interfaces" and get "LowerRange" multisz string
      stat = our_open_key(&KeyHandle3, KeyHandle2, szNdiInterfaces, KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Thread, ("Not a e.nic-card\n"))
        continue;
      }

      stat = our_query_value(KeyHandle3,
                           szLowerRange,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

      if (stat)
      {
        MyKdPrint(D_Thread, ("No LowRange\n"))
        continue;
      }
      WStrToCStr(tmpstr, (PWCHAR)data_ptr, 38);

      if (my_lstricmp(tmpstr, szEthernet) != 0)
      {
        MyKdPrint(D_Thread, ("Not Eth\n"))
        continue;
      }

      MyKdPrint(D_Thread, ("Found a Nic Card!\n"))

      // open up the sub-key "Linkage" and get "Export" multisz string
      stat = our_open_key(&KeyHandle3, KeyHandle2, szLinkage, KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Thread, ("No Linkage on E card\n"))
        continue;
      }

      stat = our_query_value(KeyHandle3,
                           szExport,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

      if (stat)
      {
        MyKdPrint(D_Thread, ("No Export on E.nic-card\n"))
        continue;
      }

      MyKdPrint(D_Thread, ("Got e.card export 2!\n"))
      wstr_ptr = (PWCHAR) data_ptr;
#if DBG
      //while (*wstr_ptr != 0)  // while more multisz strings
      //{
      //  WStrToCStr(tmpstr, wstr_ptr, 100);
      //  MyKdPrint(D_Thread, ("Got E. Card Name:%s.\n", tmpstr))
      //  while (*wstr_ptr != 0)  // pass up this string
      //    ++wstr_ptr;
      //  ++wstr_ptr;
      //}
      //wstr_ptr = (PWCHAR) data_ptr;
#endif
      ++linkage_found;
      MyKdPrint(D_Thread, ("E card 3!\n"))
      CatBindList(wstr_ptr);
    }
  }  // for

  if (KeyHandle != NULL)
    ZwClose(KeyHandle);

  if (KeyHandle2 != NULL)
    ZwClose(KeyHandle2);

  if (KeyHandle3 != NULL)
    ZwClose(KeyHandle3);

  if (buffer != NULL)
     ExFreePool(buffer);

  if (linkage_found == 0)
  {
    MyKdPrint(D_Thread, ("ERROR, No Ethernet found!\n"))
  }

  MyKdPrint(D_Thread, ("reg_list done\n"))
  return 1;  // err, not found
}
#else
/*----------------------------------------------------------------------------
  nt40
|----------------------------------------------------------------------------*/
static int reg_list_nt40_linkage(void)
{
    //static char *szLowerRange = {"LowerRange"};
    //static char *szNdiInterfaces = {"Ndi\\Interfaces"};
    //static char *szComponentId = {"ComponentId"};
    //static char *szExport = {"Export"};
    //static char *szRegRMSCCNetGuid = 
    // {"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\{4d36e972-e325-11ce-bfc1-08002be10318}"};
    //static char *szEthernet = {"Ethernet"};

  static char *szRegRMSCS = 
   {"\\Registry\\Machine\\System\\CurrentControlSet\\Services"};

  static char *szLinkage = {"Linkage"};
  static char *szBind = {"Bind"};
  static char tmpstr[200];  // make static, don't put too much on stack..
  static char compstr[40];
  static char nodestr[20];
  WCHAR *wstr_ptr;
  char *buffer = NULL;
  char *data_ptr;
  HANDLE KeyHandle = NULL;
  HANDLE KeyHandle2 = NULL;
  HANDLE KeyHandle3 = NULL;
  int node_num = 0;
  int linkage_found = 0;
  int stat;
  OBJECT_ATTRIBUTES objAttribs;
  NTSTATUS status;

#define OUR_BUF_SIZE (8000*2)

  MyKdPrint(D_Thread, ("Start RegFind Linkage\n"))

  MyKdPrint(D_Thread, ("str:%s\n", UToC1(&Driver.RegPath) ))
  
  buffer = ExAllocatePool(PagedPool, OUR_BUF_SIZE);
  if ( buffer == NULL ) {
    Eprintf("RegFindLinkage no memory");
    return 1;
  }

  for (;;)
  {
    //--- open up our service key: controlset\services\vslinka
    InitializeObjectAttributes(&objAttribs,
                             &Driver.RegPath,
                             OBJ_CASE_INSENSITIVE,
                             NULL,  // root dir relative handle
                             NULL);  // security desc

    status = ZwOpenKey(&KeyHandle,
                     KEY_READ,
                     &objAttribs);

    if (status != STATUS_SUCCESS)
    {
      MyKdPrint(D_Error, ("Err 4D:%d\n", status))
      break;
    }

    // open up the sub-key "Linkage" and get "Bind" multisz string
    stat = our_open_key(&KeyHandle2, KeyHandle, szLinkage, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Thread, ("No Linkage\n"))
      break;
    }

    stat = our_query_value(KeyHandle2,
                           szBind,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);

    if (stat)
    {
      // no component id
      MyKdPrint(D_Thread, ("No Bind\n"))
      break;
    }
    MyKdPrint(D_Thread, ("Got bind!\n"))

    wstr_ptr = (PWCHAR)(data_ptr);
#if DBG
    while (*wstr_ptr != 0)  // while more multisz strings
    {
      WStrToCStr(tmpstr, wstr_ptr, 100);
      MyKdPrint(D_Thread, ("Got Bind Name:%s.\n", tmpstr))
      while (*wstr_ptr != 0)  // pass up this string
        ++wstr_ptr;
      ++wstr_ptr;
    }
    MyKdPrint(D_Thread, ("bind 3!\n"))
    wstr_ptr = (PWCHAR)(data_ptr);
#endif
    CatBindList(wstr_ptr);
    MyKdPrint(D_Thread, ("bind 4!\n"))
    ++linkage_found;

    break;  // all done.
  }

  // now go nab tcpip's bindings...
  for (;;)
  {
    MyKdPrint(D_Thread, ("Get other Linkage\n"))

    stat = our_open_key(&KeyHandle, NULL, szRegRMSCS, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Thread, ("Failed OpenKey\n"))
      break;
    }

    // open up the sub-key "tcpip\\Linkage" and get "Bind" multisz string
    tmpstr[0] = 't';
    tmpstr[1] = 'c';
    tmpstr[2] = 'p';
    tmpstr[3] = 'i';
    tmpstr[4] = 'p';
    tmpstr[5] = '\\';
    tmpstr[6] = 0;
    strcat(tmpstr, szLinkage);
    stat = our_open_key(&KeyHandle2, KeyHandle, tmpstr, KEY_READ);
    if (stat)
    {
      MyKdPrint(D_Thread, ("No other binding\n"))
      break;
    }

    stat = our_query_value(KeyHandle2,
                           szBind,
                           buffer,
                           OUR_BUF_SIZE,
                           NULL,  // pDataType
                           &data_ptr);
    if (stat)
    {
      // no component id
      MyKdPrint(D_Thread, ("No other Bind\n"))
      break;
    }

    MyKdPrint(D_Thread, ("Got other bind!\n"))

    wstr_ptr = (PWCHAR)(data_ptr);
#if DBG
    while (*wstr_ptr != 0)  // while more multisz strings
    {
      WStrToCStr(tmpstr, wstr_ptr, 100);
      MyKdPrint(D_Thread, ("Got Bind Name:%s.\n", tmpstr))
      while (*wstr_ptr != 0)  // pass up this string
        ++wstr_ptr;
      ++wstr_ptr;
    }
    wstr_ptr = (PWCHAR)(data_ptr);
#endif
    CatBindList(wstr_ptr);
    ++linkage_found;

    break;
  }

  if (KeyHandle != NULL)
    ZwClose(KeyHandle);

  if (KeyHandle2 != NULL)
    ZwClose(KeyHandle2);

  if (KeyHandle3 != NULL)
    ZwClose(KeyHandle3);

  if (buffer != NULL)
     ExFreePool(buffer);

  MyKdPrint(D_Thread, ("reg_list done\n"))
  if (linkage_found == 0)
  {
    MyKdPrint(D_Thread, ("ERROR, No Ethernet found!\n"))
    return 1;
  }
  return 0;  // ok, linkage found
}
#endif

/*----------------------------------------------------------------------
 init_eth_start - start up ethernet work.
|----------------------------------------------------------------------*/
int init_eth_start(void)
{
  int stat,i;

  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    // this is only used for debug display
    Driver.nics[i].RefIndex = i;
  }

  stat = ProtocolOpen();  // fills in Driver.ndis_version
  if (stat != 0)
  {
    Eprintf("Protocol fail:%d",stat);
    SerialUnload(Driver.GlobalDriverObject);
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

  // start up our nic handler thread, to periodically find any
  // new nic cards in the system

  ScanForNewNicCards();  // do initial scan.

  // start up our thread
  if (Driver.threadHandle == NULL)
  {
    Driver.threadCount = 0;
    stat = PsCreateSystemThread(
                 &Driver.threadHandle,
                 THREAD_ALL_ACCESS,
                 NULL,
                 NULL,
                 NULL,
                 (PKSTART_ROUTINE)NicThread,
                 NULL);  // our context

    if (Driver.threadHandle == NULL)
    {
      Eprintf("Thread Fail\n");
      SerialUnload(Driver.GlobalDriverObject);
      return STATUS_SERIAL_NO_DEVICE_INITED;
    }
  } // if threadHandle

  return STATUS_SUCCESS;
}

/*-----------------------------------------------------------------------
 VSSpecialStartup - after board_ext is created and after port_ext's are
   created.  This sets up further structs.
|-----------------------------------------------------------------------*/
NTSTATUS VSSpecialStartup(PSERIAL_DEVICE_EXTENSION board_ext)

{
  //PSERIAL_DEVICE_EXTENSION ext = NULL;
  int stat, port_index;

  if (board_ext->config->NumPorts <= 8) // its a RHub device
     board_ext->config->IsHubDevice = 1;

  // setup default ClkRate if not specified
  if (board_ext->config->ClkRate == 0)
  {
    // use default
    if (board_ext->config->IsHubDevice)
      board_ext->config->ClkRate = DEF_RHUB_CLOCKRATE;
    else 
      board_ext->config->ClkRate = DEF_VS_CLOCKRATE;
  }

  // setup default PreScaler if not specified
  if (board_ext->config->ClkPrescaler == 0)
  {
    // use default
    if (board_ext->config->IsHubDevice)
      board_ext->config->ClkPrescaler = DEF_RHUB_PRESCALER;
    else
      board_ext->config->ClkPrescaler = DEF_VS_PRESCALER;
  }

  stat =  portman_init(board_ext->hd,
                       board_ext->pm,
                       board_ext->config->NumPorts,
                       board_ext->UniqueId,
                       board_ext->config->BackupServer,
                       board_ext->config->BackupTimer,
                       board_ext->config->MacAddr);
  if (stat != 0)
  {
    MyKdPrint(D_Init, ("Hdlc Failed Open\n"))
    return STATUS_SERIAL_NO_DEVICE_INITED;
  }

#ifdef NT40
  board_ext->config->HardwareStarted = TRUE;  // tell ISR its ready to go
  board_ext->FdoStarted = 1;  // ok to start using
#endif

  return STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 init_stop - unload thread, ndis nic cards, etc
|----------------------------------------------------------------------*/
int init_stop(void)
{
 int i;
  MyKdPrint(D_Init, ("Init Stop\n"))
  if (Driver.threadHandle != NULL)
  {
    Driver.threadHandle = NULL;  // tell thread to kill itself
    time_stall(15);  // wait 1.5 second
  }

  if (Driver.nics != NULL)
  {
    for (i=0; i<VS1000_MAX_NICS; i++)
    {
      if (Driver.nics[i].NICHandle != NULL)
        NicClose(&Driver.nics[i]);
    }
    //our_free(Driver.nics, "nics");
  }
  //Driver.nics = NULL;

  if (Driver.NdisProtocolHandle != NULL)
    NicProtocolClose();
  Driver.NdisProtocolHandle = NULL;
  MyKdPrint(D_Init, ("Init Stop End\n"))
  return 0;
}

/*----------------------------------------------------------------------
 find_all_boxes - Locate all boxes out on the networks.  Use broadcasts.
|----------------------------------------------------------------------*/
int find_all_boxes(int pass)
{
  int inic, j;

  if (pass == 0)
    Driver.NumBoxMacs = 0;  // clear out mac query-respond list

  // do the query on all nic-segments
  for (inic=0; inic<VS1000_MAX_NICS; inic++)
  {
    // broadcast request id
    if (Driver.nics[inic].Open)  // if nic-card open for use
    {
      admin_send_query_id(&Driver.nics[inic], broadcast_addr, 0,0);
    }
  }

  // wait for responses which are accumulated in Driver.BoxMacs[] and
  // Driver.NumBoxMacs.
  time_stall((4*pass)+4);  // wait .2 second

  if (Driver.NumBoxMacs == 0)  // no reply
  {
    return 1;  // return error
  }

  // sort the replies in ascending order
  sort_macs();

#if DBG
  if (Driver.VerboseLog && (pass == 0))
  {
    unsigned char *mac;
    for (j=0; j<Driver.NumBoxMacs; j++)
    {
      mac = &Driver.BoxMacs[j*8];
      Tprintf("MacLst:%x %x %x %x %x %x ,N:%d",
        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],   mac[7]);
    }
  }
#endif
  return 0;  // return ok
}

/*----------------------------------------------------------------------
 sort_macs - sort mac addresses returned by query_id requests sent
   out to boxes.  Mac array is 8 bytes to allow extra room to indicate
   nic-segment it was found on.
|----------------------------------------------------------------------*/
void sort_macs(void)
{
 int i;
 BYTE temp_mac[8];
 BYTE *mac1;
 BYTE *mac2;
 int done;
  int num_macs = Driver.NumBoxMacs;

  if (num_macs <= 1)
    return;

  // bubble sort
  done = 0;
  while (!done)
  {
    done = 1;
    for (i=1; i<num_macs; i++)
    {
      mac1 = &Driver.BoxMacs[i*8];
      mac2 = &Driver.BoxMacs[(i-1)*8];
      if (mac_cmp(mac1, mac2) < 0)
      {
        done = 0;
        // swap em
        memcpy(temp_mac, mac1, 8);
        memcpy(mac1, mac2, 8);
        memcpy(mac2, temp_mac, 8);
      }  // sort op-swap
    }  // sort loop
  }  // !done
}

/*-----------------------------------------------------------------------
 LoadMicroCode - Load up the micro-code from disk.
|-----------------------------------------------------------------------*/
int LoadMicroCode(char *filename)
{
  NTSTATUS ntStatus;
  HANDLE NtFileHandle;
  OBJECT_ATTRIBUTES ObjectAttributes;
  IO_STATUS_BLOCK IoStatus;
  USTR_160 uname;
  FILE_STANDARD_INFORMATION StandardInfo;
  // WCHAR PathPrefix[] = L"\\SystemRoot\\system32\\drivers\\";
  ULONG LengthOfFile;
//  ULONG FullFileNameLength;
  static char *def_filename = {"\\SystemRoot\\system32\\drivers\\vslinka.bin"};

  if (filename == NULL)
    filename = def_filename;

  CToUStr((PUNICODE_STRING)&uname, filename, sizeof(uname));

  InitializeObjectAttributes ( &ObjectAttributes,
                               &uname.ustr,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL );

  ntStatus = ZwCreateFile( &NtFileHandle,
                           SYNCHRONIZE | FILE_READ_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,              // alloc size = none
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,  // eabuffer
                           0);   // ealength

   if (!NT_SUCCESS(ntStatus))
   {
     return 1;
   }

  //
  // Query the object to determine its length.
  //
  ntStatus = ZwQueryInformationFile( NtFileHandle,
                                     &IoStatus,
                                     &StandardInfo,
                                     sizeof(FILE_STANDARD_INFORMATION),
                                     FileStandardInformation );

  if (!NT_SUCCESS(ntStatus))
  {
    ZwClose(NtFileHandle);
    return 2;
  }

  LengthOfFile = StandardInfo.EndOfFile.LowPart;

  //ZwCFDump(ZWCFDIAG1, ("File length is %d\n", LengthOfFile));
  if (LengthOfFile < 1)
  {
    ZwClose(NtFileHandle);
    return 3;
  }

  if (Driver.MicroCodeImage != NULL)
  {
    our_free(Driver.MicroCodeImage, "MCI");
  }
  // Allocate buffer for this file
  Driver.MicroCodeImage = our_locked_alloc(  LengthOfFile, "MCI");

  if( Driver.MicroCodeImage == NULL )
  {
    MyKdPrint(D_Init, ("Err 12A\n"))
    ZwClose( NtFileHandle );
    return 4;
  }

  // Read the file into our buffer.
  ntStatus = ZwReadFile( NtFileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatus,
                         Driver.MicroCodeImage,
                         LengthOfFile,
                         NULL,
                         NULL);

  if( (!NT_SUCCESS(ntStatus)) || (IoStatus.Information != LengthOfFile) )
  {
    MyKdPrint(D_Init, ("Err 12B\n"))
    our_free(Driver.MicroCodeImage,"MCI");
    return 5;
  }

  ZwClose( NtFileHandle );

  Driver.MicroCodeSize = LengthOfFile;

  // no, lets not corrupt the startup code!
  ////Driver.MicroCodeImage[50] = 0;

  // TraceStr(Driver.MicroCodeImage);
  // TraceStr(">>> Done Reading");

  return 0;
}

#if 0
/*----------------------------------------------------------------------
  is_mac_unused - Used for autoconfig of mac-address.
|----------------------------------------------------------------------*/
int is_mac_used(DRIVER_MAC_STATUS *)
{
  PSERIAL_DEVICE_EXTENSION board_ext;

  if (mac_entry->flags & FLAG_APPL_RUNNING)
    return 1;  // its used

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if ((!board_ext->FdoStarted) || (!board_ext->config->HardwareStarted))
    {
      board_ext = board_ext->board_ext;  // next in chain
      return 1;  // might be used
    }
    if (mac_match(ext->config->MacAddr, mac_entry->mac)
      return 1;  // its used
    }
    board_ext = board_ext->board_ext;
  }
  return 0;  // its not used
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\initvs.h ===
VOID NicThread(IN PVOID Context);
int init_eth_start(void);
int find_all_boxes(int pass);
int mac_already_used(int for_box, UCHAR *mac);
//int init_start(void);
int init_stop(void);
void sort_macs(void);
int LoadMicroCode(char *filename);
NTSTATUS VSSpecialStartup(PSERIAL_DEVICE_EXTENSION board_ext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\ioctl.c ===
/*-------------------------------------------------------------------
| ioctl.c - handle all the misc. serial ioctl calls.
4-05-00 - Add address (&) operator to actual parameter passed to sWriteTxBlk
5-13-99 - enable RTS toggling for VS
2-15-99 - make SerialSetHandflow() public, so pnp can call it. kpb
1-21-99  - fix immed char send to trigger EV_TXEMPTY, add some support
  for VS immediate char send.
11-24-98 - update DBG kdprint messages for event handling tests - kpb
 9-24-98 - include tx-shift-reg in getcommstat report - kpb.
 4-29-98 - adjust break output to start immediately if possible - kpb.
Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

typedef struct {
   ULONG struct_size;
   ULONG num_ports;
   ULONG total_loads;
   ULONG good_loads;
   ULONG backup_server;
   ULONG state;
   ULONG iframes_sent;
   ULONG rawframes_sent;  // was send_rawframes
   ULONG ctlframes_sent;  // was send_ctlframes
   ULONG iframes_resent;  // was pkt_resends
   ULONG iframes_outofseq;  // was ErrBadIndex
   ULONG frames_rcvd;    // was: rec_pkts
   ULONG nic_index;
   unsigned char dest_addr[6];
} PROBE_DEVICE_STRUCT;

typedef struct {
  ULONG struct_size;
  ULONG Open;
  ULONG pkt_sent;
  ULONG pkt_rcvd_ours;
  ULONG pkt_rcvd_not_ours;
  char NicName[64];
  unsigned char address[6];
} PROBE_NIC_STRUCT;

static PSERIAL_DEVICE_EXTENSION find_ext_mac_match(unsigned char *mac_addr);
static int ProbeDevices(unsigned char *pPtr, int availableLength);
static int ProbeNic(unsigned char *pPtr, int availableLength);

/*-------------------------------------------------------------------
  Function : SerialIoControl
  Purpose:   Process Ioctls for a device.
  Call:      SerialIoControl(DeviceObject,Irp)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             PIRP Irp: Pointer to the I/O Request Packet
  Return:    STATUS_SUCCESS: always
             STATUS_FAIL: if request couldn't be fulfilled
  Comments:  This function is the device driver IOCTL entry point.
|--------------------------------------------------------------------*/
NTSTATUS SerialIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    KIRQL OldIrql;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(Extension);

    if (acceptingIRPs == FALSE) {
       MyKdPrint(D_Ioctl,("Ioctl:no irps accepted!\n"))
       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
       SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       return STATUS_NO_SUCH_DEVICE;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;

    MyKdPrint(D_Ioctl,("SerialIoControl: %x\n",
                          IrpSp->Parameters.DeviceIoControl.IoControlCode))
    // Make sure we aren't aborting due to error (ERROR_ABORT)

    if (Extension->ErrorWord)
    {
      if (Extension->DeviceType == DEV_PORT)
      {
        if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        {
           MyKdPrint(D_Ioctl,("ErrSet, Cancel!\n"))
           {ExtTrace(Extension,D_Ioctl,"ErrSet!");}
           return STATUS_CANCELLED;
        }
      }
    }

    //
    // Make sure IOCTL is applicable for the device type (i.e. ignore port
    // level IOCTL's if board object is specified
    //

    if (Extension->DeviceType == DEV_BOARD)
    {
        switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
        {
           case IOCTL_SERIAL_CONFIG_SIZE:
           case IOCTL_SERIAL_GET_COMMCONFIG:
           case IOCTL_SERIAL_SET_COMMCONFIG:
           case IOCTL_RCKT_GET_STATS:
           case IOCTL_RCKT_ISR_CNT:
           case IOCTL_RCKT_CHECK:
           case IOCTL_RCKT_MONALL:
           case IOCTL_RCKT_SET_MODEM_RESET:
           case IOCTL_RCKT_CLEAR_MODEM_RESET:
           case IOCTL_RCKT_SEND_MODEM_ROW:
           case IOCTL_RCKT_SET_MODEM_RESET_OLD:
           case IOCTL_RCKT_CLEAR_MODEM_RESET_OLD:
           case IOCTL_RCKT_GET_RCKTMDM_INFO_OLD:
           case IOCTL_RCKT_SEND_MODEM_ROW_OLD:

              break; // Allowable board level IOCTL's

           default:
              MyKdPrint (D_Ioctl, (" Bad Status: %xH on IIOCTL: %xH\n", Status,
                         IrpSp->Parameters.DeviceIoControl.IoControlCode));
              ExtTrace2 (Extension, D_Ioctl, " Bad Status:%xH on IIOCTL:%xH",
                         Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
              Irp->IoStatus.Information = 0;
              Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
              SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
              return STATUS_INVALID_DEVICE_REQUEST;
        }
    };

    // Main IOCTL switch
    //ExtTrace1(Extension,D_Ioctl,"Ioctl:%x",
    //                      IrpSp->Parameters.DeviceIoControl.IoControlCode);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {

      //******************************
      case IOCTL_SERIAL_GET_STATS :  // get performace stats
      {
       PSERIALPERF_STATS sp = Irp->AssociatedIrp.SystemBuffer;

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIALPERF_STATS)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
        Status = STATUS_SUCCESS;

       
       sp->TransmittedCount = Extension->OurStats.TransmittedCount -
                              Extension->OldStats.TransmittedCount;
       sp->FrameErrorCount = Extension->OurStats.FrameErrorCount - 
                             Extension->OldStats.FrameErrorCount;
       sp->SerialOverrunErrorCount = Extension->OurStats.SerialOverrunErrorCount -
                                     Extension->OldStats.SerialOverrunErrorCount;
       sp->BufferOverrunErrorCount = Extension->OurStats.BufferOverrunErrorCount -
                                     Extension->OldStats.BufferOverrunErrorCount;
       sp->ParityErrorCount = Extension->OurStats.ParityErrorCount -
                              Extension->OldStats.ParityErrorCount;
      }
      break;

      //******************************
      case IOCTL_SERIAL_CLEAR_STATS :  // clear performace stats
      {

        Extension->OldStats.TransmittedCount =
          Extension->OurStats.TransmittedCount;

        Extension->OldStats.FrameErrorCount = 
          Extension->OurStats.FrameErrorCount;

        Extension->OldStats.SerialOverrunErrorCount =
          Extension->OurStats.SerialOverrunErrorCount;

        Extension->OldStats.BufferOverrunErrorCount =
          Extension->OurStats.BufferOverrunErrorCount;

        Extension->OldStats.ParityErrorCount =
          Extension->OurStats.ParityErrorCount;

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;
      }
      break;

      //******************************
      case IOCTL_SERIAL_SET_BAUD_RATE :
      {
         ULONG DesiredBaudRate;
         MyKdPrint(D_Ioctl,("[Set Baud Rate]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_BAUD_RATE))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too Small]\n"))
             break;
         }
         DesiredBaudRate =
            ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;

         ExtTrace1(Extension,D_Ioctl,"Set Baud Rate:%d",DesiredBaudRate);

         Status = ProgramBaudRate(Extension,DesiredBaudRate);

         break;
      }

      //******************************
      case IOCTL_SERIAL_GET_BAUD_RATE:
      {
         PSERIAL_BAUD_RATE Br =
                      (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("[Get Baud Rate]\n"))
         ExtTrace1(Extension,D_Ioctl,"Get Baud Rate:%d",Extension->BaudRate);

         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_BAUD_RATE))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }
         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);
         Br->BaudRate = Extension->BaudRate;
         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
         Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
         break;
      }

      //*********************************
      case IOCTL_SERIAL_SET_LINE_CONTROL:
      {
         PSERIAL_LINE_CONTROL DesiredLineControl;
         MyKdPrint(D_Ioctl,("[Set Line Control]\n"))

         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_LINE_CONTROL))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }
         DesiredLineControl =
             ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

         ExtTrace(Extension,D_Ioctl, "Set Line Ctrl");

         Status = ProgramLineControl(Extension,DesiredLineControl);
         break;
      }

      //*********************************
      case IOCTL_SERIAL_GET_LINE_CONTROL:
      {
         PSERIAL_LINE_CONTROL Lc =
                  (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("[Get Line Control]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Line Ctrl");

         Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_LINE_CONTROL))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }
         Lc->Parity=Extension->LineCtl.Parity;
         Lc->WordLength=Extension->LineCtl.WordLength;
         Lc->StopBits=Extension->LineCtl.StopBits;
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_TIMEOUTS:
      {
          PSERIAL_TIMEOUTS NewTimeouts =
              ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));
          MyKdPrint(D_Ioctl,("[Set Timeouts]\n"))

          if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(SERIAL_TIMEOUTS))
          {
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
          }

          if ((NewTimeouts->ReadIntervalTimeout == MAXULONG) &&
              (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) &&
              (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG))
          {
              Status = STATUS_INVALID_PARAMETER;
              break;
          }

          ExtTrace3(Extension,D_Ioctl,"Timeouts-RIT:%xH RM:%xH RC:%xH",
                   NewTimeouts->ReadIntervalTimeout,
                   NewTimeouts->ReadTotalTimeoutMultiplier,
                   NewTimeouts->ReadTotalTimeoutConstant);

          ExtTrace2(Extension,D_Ioctl," WM:%xH WC:%xH",
                   NewTimeouts->WriteTotalTimeoutMultiplier,
                   NewTimeouts->WriteTotalTimeoutConstant);


          KeAcquireSpinLock( &Extension->ControlLock, &OldIrql );

          Extension->Timeouts.ReadIntervalTimeout =
              NewTimeouts->ReadIntervalTimeout;

          Extension->Timeouts.ReadTotalTimeoutMultiplier =
              NewTimeouts->ReadTotalTimeoutMultiplier;

          Extension->Timeouts.ReadTotalTimeoutConstant =
              NewTimeouts->ReadTotalTimeoutConstant;

          Extension->Timeouts.WriteTotalTimeoutMultiplier =
              NewTimeouts->WriteTotalTimeoutMultiplier;

          Extension->Timeouts.WriteTotalTimeoutConstant =
              NewTimeouts->WriteTotalTimeoutConstant;

          KeReleaseSpinLock( &Extension->ControlLock, OldIrql );

          break;
      }

      //******************************
      case IOCTL_SERIAL_GET_TIMEOUTS:
      {
         MyKdPrint(D_Ioctl,("[Get Timeouts]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Timeouts");

          if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_TIMEOUTS))
          {
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
          }

          KeAcquireSpinLock( &Extension->ControlLock, &OldIrql );

          *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = Extension->Timeouts;
          Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

          KeReleaseSpinLock( &Extension->ControlLock, OldIrql );

          break;
      }

      //**************************
      case IOCTL_SERIAL_SET_CHARS:
      {
         SERIAL_IOCTL_SYNC S;
         PSERIAL_CHARS NewChars =
             ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
         MyKdPrint(D_Ioctl,("[Set Xon/Xoff Chars]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_CHARS))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         ExtTrace3(Extension,D_Ioctl,"Set Chars Xon:%xH, Xoff:%xH Evt:%xH",
                  NewChars->XonChar,NewChars->XoffChar, NewChars->EventChar);

         // The only thing that can be wrong with the chars
         // is that the xon and xoff characters are the same.
#ifdef COMMENT_OUT
// comment out kpb, problem with hardware flow control, nt
// may connect and do this(Delrina WinFaxPro, SAPS modem pooling
// had trouble erroring out, but not on standard microsoft port.

         if (NewChars->XonChar == NewChars->XoffChar)
         {
             Status = STATUS_INVALID_PARAMETER;
             break;
         }
#endif
         // We acquire the control lock so that only
         // one request can GET or SET the characters
         // at a time.  The sets could be synchronized
         // by the interrupt spinlock, but that wouldn't
         // prevent multiple gets at the same time.
         S.Extension = Extension;
         S.Data = NewChars;

         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

         Extension->SpecialChars.EofChar = NewChars->EofChar;
         Extension->SpecialChars.ErrorChar = NewChars->ErrorChar;
         Extension->SpecialChars.BreakChar=NewChars->BreakChar;

         // Only set up byte in case we're already EventChar-ing it,
         // Actual programming of interrupt is done in wait on mask call.
         Extension->SpecialChars.EventChar=NewChars->EventChar;
         Extension->SpecialChars.XonChar=NewChars->XonChar;
         Extension->SpecialChars.XoffChar=NewChars->XoffChar;
#ifdef S_RK
         sSetRxCmpVal1(Extension->ChP,NewChars->EventChar);
         sSetTxXONChar(Extension->ChP,NewChars->XonChar);
         sSetTxXOFFChar(Extension->ChP,NewChars->XoffChar);
#else
         pSetEventChar(Extension->Port,NewChars->EventChar);
         pSetXONChar(Extension->Port,NewChars->XonChar);
         pSetXOFFChar(Extension->Port,NewChars->XoffChar);
#endif
         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
         break;
      }

      //**************************
      case IOCTL_SERIAL_GET_CHARS:
      {
         MyKdPrint(D_Ioctl,("[Get Xon/Xoff Chars]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Xon/Xoff Chars");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_CHARS))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

         // Copy the whole struct over to the buffer
         *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) =
                             Extension->SpecialChars;

         Irp->IoStatus.Information = sizeof(SERIAL_CHARS);
         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);
         break;
      }

        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR:
        {
         MyKdPrint(D_Ioctl,("[Set and Clr DTR]\n"))
            // We acquire the lock so that we can check whether
            // automatic dtr flow control is enabled.  If it is,
            // then return an error since the app is not allowed
            // to touch this if it is automatic.

            KeAcquireSpinLock(&Extension->ControlLock, &OldIrql);

            if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE)
            {   // bogus
                //Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                //Status = STATUS_INVALID_PARAMETER;
            }
            else
            {
               if(IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                  IOCTL_SERIAL_SET_DTR )
               {
                  ExtTrace(Extension,D_Ioctl,"Set DTR");
#ifdef S_VS
                  pSetDTR(Extension->Port);
#else
                  sSetDTR(Extension->ChP);
#endif
                  Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
               }
               else
               {
                  //must be IOCTL_SERIAL_CLR_DTR
                  ExtTrace(Extension,D_Ioctl,"Clr DTR");
#ifdef S_VS
                  pClrDTR(Extension->Port);
#else
                  sClrDTR(Extension->ChP);
#endif
                  Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
               }
            }

            KeReleaseSpinLock(&Extension->ControlLock, OldIrql);

            break;
        }

      //************************
      case IOCTL_SERIAL_RESET_DEVICE:
         MyKdPrint(D_Ioctl,("[Reset Device]\n"));
         ExtTrace(Extension,D_Ioctl,"Reset Device");
         // Example driver also takes no action
         break;

      //************************
      case IOCTL_SERIAL_SET_RTS:
         MyKdPrint(D_Ioctl,("[Set RTS]\n"));
         ExtTrace(Extension,D_Ioctl,"Set RTS");
        // Make sure RTS isn't already used for handshake or toggle
        if( ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_RTS_HANDSHAKE) ||
            ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_TRANSMIT_TOGGLE)
          )
        {
           Status = STATUS_INVALID_PARAMETER;
           ExtTrace(Extension,D_Ioctl," not set,flow");
        }
        else
        {
          if (!(Extension->Option & OPTION_RS485_OVERRIDE))
          {
#ifdef S_VS
            pSetRTS(Extension->Port);
#else
            sSetRTS(Extension->ChP);
#endif
            Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
          }
          else
          {
            ExtTrace(Extension,D_Ioctl," not set,485");
          }
        }
        break;

      //************************
      case IOCTL_SERIAL_CLR_RTS:
         MyKdPrint(D_Ioctl,("[Clr RTS]\n"));
         ExtTrace(Extension,D_Ioctl,"Clr RTS");

        // Make sure RTS isn't already used for handshake or toggle
        if( ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_RTS_HANDSHAKE) ||
            ( (Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                                                 SERIAL_TRANSMIT_TOGGLE)
          )
        {
           Status = STATUS_INVALID_PARAMETER;
           ExtTrace(Extension,D_Ioctl," not clr,flow");
        }
        else
        {
           if (!(Extension->Option & OPTION_RS485_OVERRIDE))
           {
#ifdef S_VS
             pClrRTS(Extension->Port);
#else
             sClrRTS(Extension->ChP);
#endif
             Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
           }
           else
           {
             ExtTrace(Extension,D_Ioctl," not clr,485");
           }
        }

        break;

      //*************************
      case IOCTL_SERIAL_SET_XOFF:
         MyKdPrint(D_Ioctl,("[Set Xoff]\n"));
         ExtTrace(Extension,D_Ioctl,"Set Xoff");

#ifdef S_RK
         if (sIsTxSoftFlowCtlEnabled(Extension->ChP))
         {
           sDisTxSoftFlowCtl(Extension->ChP);  // turn off Tx software flow control
           sDisTransmit(Extension->ChP); // Stop the transmitter
           sEnRxIntCompare2(Extension->ChP,(unsigned char) Extension->SpecialChars.XonChar);
           Extension->TXHolding |= SERIAL_TX_XOFF;
           Extension->TXHolding |= ST_XOFF_FAKE;
         }
#else
        if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
        {
           Extension->TXHolding |= SERIAL_TX_XOFF;
           pOverrideSetXoff(Extension->Port);
        }
#endif
         break;

      //************************
      case IOCTL_SERIAL_SET_XON:
         MyKdPrint(D_Ioctl,("[Set Xon]\n"));
         ExtTrace(Extension,D_Ioctl,"Set Xon");
#ifdef S_VS
         {
           pOverrideClearXoff(Extension->Port);
           Extension->TXHolding &= ~SERIAL_TX_XOFF;
         }
#else
         if (Extension->TXHolding & ST_XOFF_FAKE)
         {
           Extension->TXHolding &= ~SERIAL_TX_XOFF;
           Extension->TXHolding &= ~ST_XOFF_FAKE;
           if ((Extension->TXHolding & 
              (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
             sEnTransmit(Extension->ChP); // Start up the transmitter
           sDisRxCompare2(Extension->ChP);
           sEnTxSoftFlowCtl(Extension->ChP);  // turn off Tx software flow control
         }

         // override an actual XOFF from remote
         sClrTxXOFF(Extension->ChP);

         // check for IOCTL_SERIAL_SET_XOFF state
         if(Extension->TXHolding & SERIAL_TX_XOFF)
         {
             // Make sure BREAK state hasn't disabled the Transmitter
             if(!(Extension->TXHolding & SERIAL_TX_BREAK))
                sEnTransmit(Extension->ChP);
             Extension->TXHolding &= ~SERIAL_TX_XOFF;
         }
#endif
         break;

      //******************************
      case IOCTL_SERIAL_SET_BREAK_ON:
      {

         ExtTrace(Extension,D_Ioctl,"Set Break on");
#ifdef S_VS
         pSetBreak(Extension->Port);
         Extension->TXHolding |= SERIAL_TX_BREAK;
#else
         IoAcquireCancelSpinLock(&OldIrql);
         if( !(Extension->TXHolding & SERIAL_TX_BREAK) )
         {
            // Stop the transmitter
            sDisTransmit(Extension->ChP);

            // Request break, Polling will check on Transmitter empty
            Extension->TXHolding |= SERIAL_TX_BREAK;

            // Make sure Transmitter is empty before slamming BREAK
            // Check the bit twice in case of time between buf and txshr load
            if( (sGetChanStatusLo(Extension->ChP) & TXSHRMT) &&
                (sGetChanStatusLo(Extension->ChP) & TXSHRMT) )
            {
              sSendBreak(Extension->ChP);
              Extension->DevStatus &= ~COM_REQUEST_BREAK;
            }
            else
              Extension->DevStatus |= COM_REQUEST_BREAK;
         }
         IoReleaseCancelSpinLock(OldIrql);
#endif
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_BREAK_OFF:
      {
         ExtTrace(Extension,D_Ioctl,"Set Break Off");

#ifdef S_VS
         if (Extension->TXHolding & SERIAL_TX_BREAK)
         {
            Extension->TXHolding &= ~SERIAL_TX_BREAK;
            pClrBreak(Extension->Port);
         }
#else
         IoAcquireCancelSpinLock(&OldIrql);
         if(Extension->TXHolding & SERIAL_TX_BREAK)
         {
            Extension->TXHolding &= ~SERIAL_TX_BREAK;

            sClrBreak(Extension->ChP);

            if(!(Extension->TXHolding & SERIAL_TX_XOFF))
            {
               sEnTransmit(Extension->ChP);
            }
         }

         if(Extension->DevStatus & COM_REQUEST_BREAK)
         {
            // If we hit this code, the requested BREAK will not have gone out
            Extension->DevStatus &= ~COM_REQUEST_BREAK;
         }

         IoReleaseCancelSpinLock(OldIrql);
#endif
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_QUEUE_SIZE:
      {
        LONG new_size;
        PUCHAR NewBuf;

        PSERIAL_QUEUE_SIZE Rs =
            ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));

         MyKdPrint(D_Ioctl,("[Set Queue Size]\n"));

         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_QUEUE_SIZE))
         {
           Status = STATUS_BUFFER_TOO_SMALL;
           break;
         }

         new_size = (LONG) Rs->InSize;
         ExtTrace1(Extension,D_Ioctl,"Set Queue Size, In:%d", new_size);
         if (new_size > 0x20000L)
            new_size = 0x20000L;  /// limit to about 128K

         // try to allocate buffer here if user requests larger buffer
              // don't resize if they want to shrink(why bother)
         if (new_size <= Extension->RxQ.QSize)
         {
            Status = STATUS_SUCCESS;
            break;
         }
  
         ++new_size;  // some circular queue wierdness

         IoAcquireCancelSpinLock(&OldIrql);

         NewBuf = our_locked_alloc(new_size+16, "exRX");  // add some slop
         if (NewBuf != NULL)
         {
           // Eprintf("Resized Buffer, new:%d, old:%d",new_size-1, Extension->RxQ.QSize-1);
           Extension->RxQ.QSize = new_size;
           our_free(Extension->RxQ.QBase, "exRX");
           Extension->RxQ.QBase= NewBuf;
           Extension->RxQ.QGet = 0;
           Extension->RxQ.QPut = 0;
           Status = STATUS_SUCCESS;
         }
         else
         {
            Status = STATUS_INVALID_PARAMETER; // not the greatest choise
         }
         IoReleaseCancelSpinLock(OldIrql);
 
         break;
      }

      //******************************
      case IOCTL_SERIAL_GET_WAIT_MASK:
         // This mask contains the various Events the WaitIrp is waiting
         // for from SetCommMask(), such as EV_BREAK, EV_CTS, EV_DSR,
         // EV_ERR, EV_RING, EV_RLSD, EV_RXCHAR, EV_RXFLAG, EV_TXEMPTY

         MyKdPrint(D_Ioctl,("[Get Wait Mask:%xH\n]",Extension->IsrWaitMask))

         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(ULONG))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         ExtTrace1(Extension,D_Ioctl,"Get Wait Mask:%xH",Extension->IsrWaitMask);

         Irp->IoStatus.Information = sizeof(ULONG);
         *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = Extension->IsrWaitMask;
         break;

      //******************************
      case IOCTL_SERIAL_SET_WAIT_MASK:
      {
         ULONG NewMask;

         if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(ULONG) )
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }
         else
         {
             NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
             MyKdPrint(D_Ioctl,("set wait mask:%xH\n",NewMask))
             ExtTrace1(Extension,D_Ioctl,"Set Wait Mask:%xH",NewMask);
         }

         //------- Complete the old wait if there is one.
#ifdef NEW_WAIT_SYNC_LOCK
         SyncUp(Driver.InterruptObject,
                &Driver.TimerLock,
                SerialGrabWaitFromIsr,
                Extension);
#endif
         IoAcquireCancelSpinLock(&OldIrql);
         if (Extension->CurrentWaitIrp)
         {
           PIRP Irp;
           Extension->IrpMaskLocation = NULL;
           MyKdPrint(D_Ioctl,("[kill old wait]\n"))
           ExtTrace(Extension,D_Ioctl, " Kill Old Wait");
           *(ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer = 0;
           Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
           Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;
           Irp = Extension->CurrentWaitIrp;
           IoSetCancelRoutine(Irp, NULL);
           Extension->CurrentWaitIrp = 0;
           IoReleaseCancelSpinLock(OldIrql);
           SerialCompleteRequest(Extension, Irp, IO_SERIAL_INCREMENT);
         }
         else
           IoReleaseCancelSpinLock(OldIrql);

         //----- retain any bits from when no WaitIrp present
         Extension->HistoryMask &= NewMask;

         //----- set the mask of interested events
         Extension->IsrWaitMask = NewMask;

         // move this from wait_on_mask call to here, kpb, 1-16-97
#ifdef S_RK
         if (Extension->IsrWaitMask & SERIAL_EV_RXFLAG)
         {
            sEnRxIntCompare1(Extension->ChP, 
                             Extension->SpecialChars.EventChar);
         }
         else
         {
            sDisRxCompare1(Extension->ChP);
         }
#endif
      }
      break;

      //******************************
      case IOCTL_SERIAL_WAIT_ON_MASK:
      {
         MyKdPrint(D_Ioctl,("[wait on mask]\n"))
         ExtTrace(Extension,D_Ioctl,"Wait On Mask");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(ULONG))
         {
             ExtTrace(Extension,D_Ioctl,"Wait IRP, Bad Size");
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

// put this in to fix an incompatibility with WaitOnMultipleObjects()
// 6-26-98 kpb
         if (Extension->CurrentWaitIrp)
         {
           MyKdPrint(D_Ioctl,("[Already pending]\n"))
           Status = STATUS_INVALID_PARAMETER;
           break;
         }

#ifdef NEW_WAIT_SYNC_LOCK
         SyncUp(Driver.InterruptObject,
                &Driver.TimerLock,
                SerialGrabWaitFromIsr,
                Extension);
#else
         Extension->WaitIsISRs = 0;
         Extension->IrpMaskLocation = &Extension->DummyIrpMaskLoc;
#endif
         IoAcquireCancelSpinLock(&OldIrql);

         //------- Complete the old wait if there is one.
         if (Extension->CurrentWaitIrp)
         {
           PIRP Irp;

           MyKdPrint(D_Ioctl,("[kill old wait]\n"))
           ExtTrace(Extension,D_Ioctl, " Kill Old Wait");
           *(ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer = 0;
           Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
           Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

           Irp = Extension->CurrentWaitIrp;
           IoSetCancelRoutine(Irp, NULL);
           Extension->CurrentWaitIrp = 0;
           IoReleaseCancelSpinLock(OldIrql);
           SerialCompleteRequest(Extension, Irp, IO_SERIAL_INCREMENT);
         }
         else
           IoReleaseCancelSpinLock(OldIrql);

         if (Extension->IsrWaitMask == 0)
         {
           ExtTrace(Extension,D_Ioctl," WaitMask==0");
           Status = STATUS_INVALID_PARAMETER;
         }
         else
         {
           IoAcquireCancelSpinLock(&OldIrql);

           if (Irp->Cancel)
           {
             IoReleaseCancelSpinLock(OldIrql);
             Irp->IoStatus.Status = STATUS_CANCELLED;
             SerialCompleteRequest(Extension, Irp, 0);
             Status = STATUS_CANCELLED;
           }
           else
           {
             Extension->CurrentWaitIrp = Irp;
             Irp->IoStatus.Status = STATUS_PENDING;
             IoMarkIrpPending(Irp);
             IoSetCancelRoutine(Extension->CurrentWaitIrp,  SerialCancelWait);
             IoReleaseCancelSpinLock(OldIrql);
             // give to ISR to process
             Extension->IrpMaskLocation = (ULONG *)
                Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
             Extension->WaitIsISRs = 1;  // give to ISR
             ExtTrace(Extension,D_Ioctl," PENDING.");
             return STATUS_PENDING;
          }
        }
      }
      break;

      case IOCTL_SERIAL_IMMEDIATE_CHAR:
      {
         UCHAR TxByte;
         KIRQL OldIrql;
         ExtTrace(Extension,D_Ioctl,"Immed. Char");

         if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(UCHAR) )
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         IoAcquireCancelSpinLock(&OldIrql);

         TxByte = *((UCHAR *)(Irp->AssociatedIrp.SystemBuffer));

         Extension->ISR_Flags |= TX_NOT_EMPTY;  // fix for EV_TXEMPTY 1-21-99
#ifdef S_RK
         if(!sWriteTxPrioByte(Extension->ChP,TxByte))
         {
             // No room for immediate character in Priority queue
             Status = STATUS_INVALID_PARAMETER;
         }
#else
          if ( (ULONG)(PortGetTxRoom(Extension->Port)) > 0)
          {
            // Send the byte
            q_put(&Extension->Port->QOut,
                        (PUCHAR) &TxByte,
                        1);
          }
#endif
         IoReleaseCancelSpinLock(OldIrql);
         break;
      }

      //**********************
      case IOCTL_SERIAL_PURGE:
      {
         ULONG Mask;

         MyKdPrint(D_Ioctl,("[Serial Purge]"));

         // Check to make sure that the mask only has 0 or the other
         // appropriate values. A null mask is equivalent to a mask of 0

         if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
              sizeof(ULONG) )
         {
             Status = STATUS_INVALID_PARAMETER;
             break;
         };
         
         if ( Irp->AssociatedIrp.SystemBuffer )
         {
           Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));
           ExtTrace1(Extension,D_Ioctl,"Serial Purge:%xH",Mask);
         }
         else
         {
           Mask = 0;
         }

         if ((!Mask) || (Mask & (~(SERIAL_PURGE_TXABORT |
                                   SERIAL_PURGE_RXABORT |
                                   SERIAL_PURGE_TXCLEAR |
                                   SERIAL_PURGE_RXCLEAR )
                                ) ))
         {
             Status = STATUS_INVALID_PARAMETER;
             break;
         }

         return SerialStartOrQueue(Extension,
                                   Irp,
                                   &Extension->PurgeQueue,
                                   &Extension->CurrentPurgeIrp,
                                   SerialStartPurge );

      }

      //*****************************
      case IOCTL_SERIAL_GET_HANDFLOW:
      {
         MyKdPrint(D_Ioctl,("[Get Handflow]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Handflow");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_HANDFLOW))
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

          *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) =
              Extension->HandFlow;

         break;
      }

      //*****************************
      case IOCTL_SERIAL_SET_HANDFLOW:
      {
         ULONG trace_flags = 0;
         SERIAL_IOCTL_SYNC S;
         PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

         MyKdPrint(D_Ioctl,("[Set HandFlow]\n"))
         ExtTrace(Extension,D_Ioctl,"Set HandFlow");

         // Make sure that the buffer is big enough
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_HANDFLOW))
         {
             ExtTrace(Extension,D_Ioctl,"ErZ!");
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         ///////////////////////////////////////////////////////
         // Make sure that no invalid parameters have been set

         // Check ControlHandShake first
         // For Rocket, we or in several that can't be supported

         if(HandFlow->ControlHandShake & (SERIAL_CONTROL_INVALID |
                                          SERIAL_DSR_SENSITIVITY
                                         ) )
         {
            
            { ExtTrace(Extension,D_Ioctl,"Err M!"); }

            if(HandFlow->ControlHandShake & SERIAL_DSR_SENSITIVITY)
               { ExtTrace(Extension,D_Ioctl,"No DSR Sen!"); }
            if(HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID)
               { ExtTrace(Extension,D_Ioctl,"Invalid con!"); }
            // don't bail out - kpb(5-23-96)
            //Status = STATUS_INVALID_PARAMETER;
            //break;
         }

         if (HandFlow->FlowReplace & SERIAL_FLOW_INVALID)
         {
            ExtTrace(Extension,D_Ioctl,"ErA!");
            Status = STATUS_INVALID_PARAMETER;
            break;
         }

         // Make sure that the app hasn't set an invalid DTR mode.
         // Both options can't be set
         if((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK)
         {
             ExtTrace(Extension,D_Ioctl,"ErB!");
             Status = STATUS_INVALID_PARAMETER;
             break;
         }

         // Xon/Xoff limits unused for RocketPort (they're internal).
         HandFlow->XonLimit=0;
         HandFlow->XoffLimit=0;

         S.Extension = Extension;
         S.Data = HandFlow;

         KeAcquireSpinLock(&Extension->ControlLock,&OldIrql);

         SerialSetHandFlow(Extension, HandFlow);

         KeReleaseSpinLock(&Extension->ControlLock,OldIrql);

         if ((Extension->HandFlow.ControlHandShake & SERIAL_RTS_MASK) == 
              SERIAL_RTS_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"RTS-Auto");}

         if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"CTS-Auto");}

         if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == 
              SERIAL_DTR_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"DTR-Auto");}

         if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
           {ExtTrace(Extension,D_Ioctl,"DSR-Auto");}

         if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
           {ExtTrace(Extension,D_Ioctl,"Xon-Auto");}
      }
      break;
      //********************************
      case IOCTL_SERIAL_GET_MODEMSTATUS:
      {

         if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(ULONG) )
         {   Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         Irp->IoStatus.Information = sizeof(ULONG);
         //Irp->IoStatus.Status = STATUS_SUCCESS;  bogus(set at end)
         Status = STATUS_SUCCESS;  // don't need, default
#ifdef S_RK
         // Update the modem inputs, fn() reads and converts the bits
         SetExtensionModemStatus(Extension);
#endif

         ExtTrace1(Extension,D_Ioctl,"Get ModemStatus:%xH",Extension->ModemStatus);

         *(PULONG)Irp->AssociatedIrp.SystemBuffer = Extension->ModemStatus;

         break;
      }

      //***************************
      case IOCTL_SERIAL_GET_DTRRTS:
      {
         MyKdPrint(D_Ioctl,("[Get DTR/RTS]\n"))
         // The Rocket cannot truly reflect RTS setting, best guess is returned
         if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(ULONG) )
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         Irp->IoStatus.Information = sizeof(ULONG);
         //Irp->IoStatus.Status = STATUS_SUCCESS; bogus, set at end
         Status = STATUS_SUCCESS;  // don't need

         *(PULONG)Irp->AssociatedIrp.SystemBuffer = Extension->DTRRTSStatus;
         ExtTrace1(Extension,D_Ioctl,"Get DTR/RTS:%xH",Extension->DTRRTSStatus);

         break;
      }

      //*******************************
      case IOCTL_SERIAL_GET_COMMSTATUS:
      {
         PSERIAL_STATUS Stat;
         LONG RxCount;
         LONG TxCount;

         if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_STATUS) )
         {
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         Irp->IoStatus.Information = sizeof(SERIAL_STATUS);
         Stat =  Irp->AssociatedIrp.SystemBuffer;

         // EOF is always off, NT only supports binary mode
         // This in keeping with the example driver
         Stat->EofReceived = FALSE;

         // Reading error status clears out the errors.
         Stat->Errors = Extension->ErrorWord;
         Extension->ErrorWord = 0;

         // We only report here what can be read immediately by the next read
         // The RocketPort's hardware FIFO is not added into this count
         RxCount = q_count(&Extension->RxQ);

         Stat->AmountInInQueue = RxCount;

#ifdef NEW_Q
#ifdef S_VS
         {
         LONG tx_remote;
         tx_remote = PortGetTxCntRemote(Extension->Port);
         TxCount = PortGetTxCnt(Extension->Port);
         Stat->AmountInOutQueue = Extension->TotalCharsQueued + TxCount + tx_remote;
         ExtTrace4(Extension,D_Ioctl,"Get CommStat,In:%d IRPOut:%d BufOut:%d Remote:%d",
             RxCount, Extension->TotalCharsQueued, TxCount, tx_remote);
         }
#else
         TxCount = sGetTxCnt(Extension->ChP);
         if ((sGetChanStatusLo(Extension->ChP) & DRAINED) != DRAINED)
          ++TxCount;

         Stat->AmountInOutQueue = Extension->TotalCharsQueued + TxCount;
         ExtTrace3(Extension,D_Ioctl,"Get CommStat,In:%d IRPOut:%d HardOut:%d",
             RxCount, Extension->TotalCharsQueued, TxCount);

#endif
#else
   // older q-tracking code....
#ifdef S_VS
         TxCount = PortGetTxCnt(Extension->Port);
#else
         TxCount = sGetTxCnt(Extension->ChP);
#endif
         Stat->AmountInOutQueue = Extension->TotalCharsQueued + TxCount;

         ExtTrace3(Extension,D_Ioctl,"Get CommStat,In:%d SoftOut:%d HardOut:%d",
             RxCount, Extension->TotalCharsQueued, TxCount);
   // end older q-tracking code....
#endif
#ifdef S_RK
         // NOTE: this can fail due to the Priority buffer bug.
         // If the immediate byte ended up in the FIFO, this will
         // not accurately reflect the Immediate char state.
         if(sGetTxPriorityCnt(Extension->ChP))
            Stat->WaitForImmediate = TRUE;
         else
            Stat->WaitForImmediate = FALSE;
#else
         Stat->WaitForImmediate = FALSE;
#endif
         // Holding reasons are hidden in the part
         // Hardware takes care of all the details
         Stat->HoldReasons = 0;
         if (Extension->TXHolding)
         {
           if (Extension->TXHolding & SERIAL_TX_XOFF)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;
           if (Extension->TXHolding & SERIAL_TX_CTS)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;
           if (Extension->TXHolding & SERIAL_TX_DSR)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;
           if (Extension->TXHolding & SERIAL_TX_BREAK)
             Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;
           if (Extension->TXHolding & SERIAL_TX_DCD)
             Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;
         }
         if (Extension->RXHolding & SERIAL_RX_DSR)
             Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;
         if (Extension->RXHolding & SERIAL_RX_XOFF)
               Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

         Status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

         break;
      }

      //*******************************
      case IOCTL_SERIAL_GET_PROPERTIES:
      {
         PSERIAL_COMMPROP Properties;

         MyKdPrint(D_Ioctl,("[Get Properties]\n"))
         ExtTrace(Extension,D_Ioctl,"Get Properties");
         if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(SERIAL_COMMPROP))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         Properties=(PSERIAL_COMMPROP)Irp->AssociatedIrp.SystemBuffer;
         RtlZeroMemory(Properties,sizeof(SERIAL_COMMPROP));
         Properties->PacketLength = sizeof(SERIAL_COMMPROP);
         Properties->PacketVersion = 2;
         Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
         Properties->MaxTxQueue = 0;
         Properties->MaxRxQueue = 0;

         Properties->MaxBaud = SERIAL_BAUD_USER;

         Properties->SettableBaud = SERIAL_BAUD_075 |
                                    SERIAL_BAUD_110 |
                                    SERIAL_BAUD_134_5 |
                                    SERIAL_BAUD_150 |
                                    SERIAL_BAUD_300 |
                                    SERIAL_BAUD_600 |
                                    SERIAL_BAUD_1200 |
                                    SERIAL_BAUD_1800 |
                                    SERIAL_BAUD_2400 |
                                    SERIAL_BAUD_4800 |
                                    SERIAL_BAUD_7200 |
                                    SERIAL_BAUD_9600 |
                                    SERIAL_BAUD_14400 |
                                    SERIAL_BAUD_19200 |
                                    SERIAL_BAUD_38400 |
                                    SERIAL_BAUD_56K |
                                    SERIAL_BAUD_128K |
                                    SERIAL_BAUD_115200 |
                                    SERIAL_BAUD_57600 |
                                    SERIAL_BAUD_USER;

         Properties->ProvSubType = SERIAL_SP_RS232;
         Properties->ProvCapabilities = SERIAL_PCF_RTSCTS |
                                        SERIAL_PCF_CD     |
                                        SERIAL_PCF_PARITY_CHECK |
                                        SERIAL_PCF_XONXOFF |
                                        SERIAL_PCF_SETXCHAR |
                                        SERIAL_PCF_TOTALTIMEOUTS |
                                        SERIAL_PCF_INTTIMEOUTS;

         Properties->SettableParams = SERIAL_SP_PARITY |
                                      SERIAL_SP_BAUD |
                                      SERIAL_SP_DATABITS |
                                      SERIAL_SP_STOPBITS |
                                      SERIAL_SP_HANDSHAKING |
                                      SERIAL_SP_PARITY_CHECK |
                                      SERIAL_SP_CARRIER_DETECT;


         Properties->SettableData = SERIAL_DATABITS_7 |
                                    SERIAL_DATABITS_8;

         Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                          SERIAL_STOPBITS_20 |
                                          SERIAL_PARITY_NONE |
                                          SERIAL_PARITY_ODD  |
                                          SERIAL_PARITY_EVEN;

         Properties->CurrentTxQueue = 0; // as per MS

         // circular buffer req's -1
         Properties->CurrentRxQueue = Extension->RxQ.QSize -1;

         Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
         //Irp->IoStatus.Status = STATUS_SUCCESS; bogus, set at end
         Status = STATUS_SUCCESS;  // don't need
         break;
      }

      //*****************************
      case IOCTL_SERIAL_XOFF_COUNTER:
      {
         PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

         MyKdPrint(D_Ioctl,("[Xoff Counter]\n"));
         ExtTrace(Extension,D_Ioctl,"Xoff Counter");

         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(SERIAL_XOFF_COUNTER))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         if (Xc->Counter <= 0)
         {   Status = STATUS_INVALID_PARAMETER;
             break;
         }

         // write the 13H(don't play the xoff-counter game)
         // which queues things up in the write queue.  We may
         // screw up the order of outgoing data if other writes
         // pended, but thats life, and this xoff-counter nonsense
         // sucks.  Its used in the msdos 16450 uart emuluation on
         // com1-com4.
#ifdef S_RK
         sWriteTxBlk( Extension->ChP, (PUCHAR) &Xc->XoffChar, 1);
#else
         q_put(&Extension->Port->QOut,(unsigned char *)&Xc->XoffChar,1);         
#endif
        Status = STATUS_SUCCESS;

        break;
      }

      //******************************
      case IOCTL_SERIAL_CONFIG_SIZE:
      {
        ExtTrace(Extension,D_Ioctl,"Config Size");
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG))
        {
          Status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        Irp->IoStatus.Information = sizeof(ULONG);
        Status = STATUS_SUCCESS;

        *(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;
        break;
      }

      //******************************
      case IOCTL_SERIAL_GET_COMMCONFIG:
      {
         // this function is not defined or used in the sample driver.
         ExtTrace(Extension,D_Ioctl,"Get Config");
         Status = STATUS_INVALID_PARAMETER;
         break;
      }

      //******************************
      case IOCTL_SERIAL_SET_COMMCONFIG:
      {
         // this function is not defined or used in the sample driver.
         ExtTrace(Extension,D_Ioctl,"Set Config");
         Status = STATUS_INVALID_PARAMETER;
         break;
      }

      //******************************
      case IOCTL_SERIAL_LSRMST_INSERT:
      {
         PUCHAR escapeChar;

		 if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			  sizeof (ULONG) )
		 {
			 Status = STATUS_INVALID_PARAMETER;
			 break;
		 }
		 else
		 {
             escapeChar = Irp->AssociatedIrp.SystemBuffer;
		 };

         ExtTrace1(Extension,D_Ioctl,"LSRMST Insert, Esc=%xH",
                                    (ULONG) *escapeChar);

         MyKdPrint(D_Ioctl,("[LSRMST Insert]\n"))
         // this "feature" allows setting a escape character, which when
         // non-zero will cause it to be used as an escape character for
         // changes in MSR/LSR registers.  If the Escape char is seen in
         // from the port, it is escaped also.  Oh what fun.

         // used in Virtual driver of microsofts.
         Extension->escapechar = *escapeChar;
#ifdef S_RK
         if (Extension->escapechar != 0)
           {sEnRxIntCompare2(Extension->ChP,Extension->escapechar);}
         else
           {sDisRxCompare2(Extension->ChP);}
#endif
         // Status = STATUS_INVALID_PARAMETER;
         break;
      }

#ifdef NT50
      //******************************
      case IOCTL_SERIAL_GET_MODEM_CONTROL:
      {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
        }
        Irp->IoStatus.Information = sizeof(ULONG);

        //#define SERIAL_DTR_STATE         ((ULONG)0x00000001)
        //#define SERIAL_RTS_STATE         ((ULONG)0x00000002)

        //#define SERIAL_IOC_MCR_DTR              ((ULONG)0x00000001)
        //#define SERIAL_IOC_MCR_RTS              ((ULONG)0x00000002)
        //#define SERIAL_IOC_MCR_OUT1             ((ULONG)0x00000004)
        //#define SERIAL_IOC_MCR_OUT2             ((ULONG)0x00000008)
        //#define SERIAL_IOC_MCR_LOOP             ((ULONG)0x00000010)

        *((ULONG *)Irp->AssociatedIrp.SystemBuffer) =
           (Extension->DTRRTSStatus & 3);
        ExtTrace1(Extension,D_Ioctl,"get MCR:=%xH",
                             *((ULONG *)Irp->AssociatedIrp.SystemBuffer) );
      }
      break;

      //******************************
      case IOCTL_SERIAL_SET_MODEM_CONTROL:
      {
        ULONG mcr;
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        mcr = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);

#ifdef S_VS
        pDisRTSFlowCtl(Extension->Port);
#else
        sDisRTSFlowCtl(Extension->ChP);
#endif

        if (mcr & SERIAL_RTS_STATE)
        {
#ifdef S_VS
            pSetRTS(Extension->Port);
#else
            sSetRTS(Extension->ChP);
#endif
          Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
        }
        else
        {
#ifdef S_VS
          pClrRTS(Extension->Port);
#else
          sClrRTS(Extension->ChP);
#endif
          Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
        }

        if (mcr & SERIAL_DTR_STATE)
        {
#ifdef S_VS
          pSetDTR(Extension->Port);
#else
          sSetDTR(Extension->ChP);
#endif
          Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
        }
        else
        {
#ifdef S_VS
          pClrDTR(Extension->Port);
#else
          sClrDTR(Extension->ChP);
#endif
          Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
        }

        ExtTrace1(Extension,D_Ioctl,"set MCR:=%xH", mcr);
      }
      break;

      //******************************
      case IOCTL_SERIAL_SET_FIFO_CONTROL:
      {
      }
      break;
#endif

      //******************************
      case IOCTL_RCKT_CLR_STATS:
      {
         Tracer *tr;
         PSERIAL_DEVICE_EXTENSION ComDevExt;
         // PortStats *Stats;

         MyKdPrint(D_Ioctl,("[Get Stats]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }

         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("Com_port: %s\n",tr->port_name))
         ComDevExt = FindDevExt(tr->port_name);
         if (ComDevExt == NULL)
         {
            Status = STATUS_INVALID_PARAMETER;
            break;
         }
  
         ComDevExt->OurStats.TransmittedCount = 0;
         ComDevExt->OurStats.ReceivedCount = 0;
         ComDevExt->OurStats.ParityErrorCount = 0;
         ComDevExt->OurStats.FrameErrorCount = 0;
         ComDevExt->OurStats.SerialOverrunErrorCount = 0;
         ComDevExt->OurStats.BufferOverrunErrorCount = 0;

         tr->status = 0;
         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;

         break; 
      }

      //******************************
      case IOCTL_RCKT_SET_LOOPBACK_ON:
      {
         ExtTrace(Extension,D_Ioctl,"LoopBk On");
         MyKdPrint(D_Ioctl,("[Set LoopBack On]"))
#ifdef S_VS
         pEnLocalLoopback(Extension->Port);
#else
         sEnLocalLoopback(Extension->ChP);
#endif
      }
      break;

      //******************************
      case IOCTL_RCKT_SET_LOOPBACK_OFF:
      {
         ExtTrace(Extension,D_Ioctl,"LoopBk Off");
         MyKdPrint(D_Ioctl,("[Set LoopBack Off]"))
#ifdef S_VS
         pDisLocalLoopback(Extension->Port);
#else
         sDisLocalLoopback(Extension->ChP);
#endif
      }
      break;

      //******************************
      case IOCTL_RCKT_SET_TOGGLE_LOW:
      {
         ExtTrace(Extension,D_Ioctl,"Set 485 Low");
         Extension->Option &= ~OPTION_RS485_HIGH_ACTIVE;
         Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->Option |= OPTION_RS485_OVERRIDE;
         // hardware reverse case
#ifdef S_VS
         pEnRTSToggleLow(Extension->Port);
#else
         sEnRTSToggle(Extension->ChP);
#endif
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
      }
      break;

      case IOCTL_RCKT_CLEAR_TOGGLE_LOW:
      {
         ExtTrace(Extension,D_Ioctl,"Clear 485 Low");
         Extension->Option &= ~OPTION_RS485_HIGH_ACTIVE;
         Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->Option &= ~OPTION_RS485_OVERRIDE;
         // hardware reverse case
#ifdef S_VS
         pDisRTSToggle(Extension->Port);
         pSetRTS(Extension->Port);
#else
         sDisRTSToggle(Extension->ChP);
         sSetRTS(Extension->ChP);
#endif
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
      }
      break;

      //******************************
      case IOCTL_RCKT_GET_STATS:
      {
         Tracer *tr;
         PSERIAL_DEVICE_EXTENSION ComDevExt;
         PortStats *Stats;

         ExtTrace(Extension,D_Ioctl,"Get_Stats");
         MyKdPrint(D_Ioctl,("[Get Stats]\n"));
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }

         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("Com_port: %s\n",tr->port_name))
         ComDevExt = FindDevExt(tr->port_name);
         if (ComDevExt == NULL)
            {
            Status = STATUS_INVALID_PARAMETER;
            break;
            }
   
         Stats = (PortStats *)tr->data;
  
         if(ComDevExt->DeviceIsOpen)
           {
#ifdef S_VS
           Stats->transmitFifo = (LONG) (PortGetTxCnt(ComDevExt->Port));
           Stats->receiveFifo  = (LONG) (PortGetRxCnt(ComDevExt->Port));
#else
           Stats->transmitFifo = (LONG) sGetTxCnt(ComDevExt->ChP);
           Stats->receiveFifo = (LONG) sGetRxCnt(ComDevExt->ChP);
#endif
           }
         else
           {
           Stats->transmitFifo = 0;
           Stats->receiveFifo = 0;
           }

         Stats->transmitBytes  = ComDevExt->OurStats.TransmittedCount;
         Stats->receiveBytes  = ComDevExt->OurStats.ReceivedCount;
         Stats->parityErrors  = ComDevExt->OurStats.ParityErrorCount;
         Stats->framingErrors  = ComDevExt->OurStats.FrameErrorCount;
         Stats->overrunHardware = ComDevExt->OurStats.SerialOverrunErrorCount;
         Stats->overrunSoftware = ComDevExt->OurStats.BufferOverrunErrorCount;
         tr->status = 0;
   
         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;

         break;
      }
      //******************************
      case IOCTL_RCKT_ISR_CNT:
      {
         Tracer *tr;
         Global_Track *Gt;

         ExtTrace(Extension,D_Ioctl,"Isr_Cnt");
         MyKdPrint(D_Ioctl,("[Get Stats]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }

         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         tr->status = 0;
         Gt = (Global_Track *)tr->data;
         Gt->int_counter = Driver.PollCnt;
         Gt->WriteDpc_counter = Driver.WriteDpcCnt;
         Gt->Timer_counter = 0;
         Gt->Poll_counter = Driver.PollCnt;

         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;
      }
      break;
      //******************************
      case IOCTL_RCKT_CHECK:
      {
         Tracer *tr;

         ExtTrace(Extension,D_Ioctl,"Rckt_Chk");
         MyKdPrint(D_Ioctl,("[Check]\n"))
         if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(Tracer))
         {
             Status = STATUS_BUFFER_TOO_SMALL;
             MyKdPrint(D_Ioctl,("[Buffer too small]\n"))
             break;
         }
         tr = (Tracer *)Irp->AssociatedIrp.SystemBuffer;
         MyKdPrint(D_Ioctl,("Com_port: %s\n",tr->port_name))
         tr->status = 0x5555;
         Irp->IoStatus.Information = sizeof(Tracer);
         Status = STATUS_SUCCESS;
      }  
      break;

      //****************************** monitor
      case IOCTL_RCKT_MONALL:
      {
        PSERIAL_DEVICE_EXTENSION extension;
        PSERIAL_DEVICE_EXTENSION board_ext;
        int Dev;
        // int total_size;
        PortMonBase *pmb;
        PortMonNames *pmn;
        PortMonStatus *pms;
        char *buf;
        MyKdPrint(D_Ioctl,("[MonAll..]"))

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (PortMonBase) )
		{
			Status = STATUS_INVALID_PARAMETER;
            break;
		}
	    else
		{
		    pmb = (PortMonBase *)Irp->AssociatedIrp.SystemBuffer;
		};

        switch (pmb->struct_type)
        {
          case 9:  // old probe ioctl
            Status = STATUS_SUCCESS;  // don't need, default
          break;

          //*************** 
          case 10:  // name array [12] bytes
            pmn = (PortMonNames *) &pmb[1];  // ptr to after first struct
            if (pmb->struct_size != sizeof(PortMonNames))
            {
              MyKdPrint(D_Ioctl,("Err1L"))
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
            }

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                (((NumPorts(NULL)+1) * sizeof(PortMonNames)) + sizeof(PortMonBase)) )
            {
               MyKdPrint(D_Ioctl,("Err4M, size:%d needed:%d\n",
                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                  (((NumPorts(NULL)+1) * sizeof(PortMonNames)) + sizeof(PortMonBase))
                  ))
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
            }

            Dev=0;
            board_ext = Driver.board_ext;
            while (board_ext)
            {
              extension = board_ext->port_ext;
              while (extension)
              {
                strcpy(pmn->port_name, extension->SymbolicLinkName);
                ++pmn;

                ++Dev;
                extension = extension->port_ext;  // next in chain
              }  // while port extension
              board_ext = board_ext->board_ext;
            }  // while port extension
            pmb->num_structs = Dev;
            pmn->port_name[0] = 0;  // null terminate list.
            Irp->IoStatus.Information = (sizeof(PortMonBase) +
                               sizeof(PortMonNames) *(Dev+1));
            Status = STATUS_SUCCESS;
          break;  // case 10, names
 
          //*************** 
          case 11:  // status array
            pms = (PortMonStatus *) &pmb[1];  // ptr to after first struct
            if (pmb->struct_size != sizeof(PortMonStatus))
            {
              MyKdPrint(D_Ioctl,("Err1M"))
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
            }
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                ((NumPorts(NULL) * sizeof(PortMonStatus)) + sizeof(PortMonBase)) )
            {
              MyKdPrint(D_Ioctl,("Err3M"))
              Status = STATUS_BUFFER_TOO_SMALL;
              break;
            }

            Dev=0;
            board_ext = Driver.board_ext;
            while (board_ext)
            {
              extension = board_ext->port_ext;
              while (extension)
              {
                pms->sent_bytes     = extension->OurStats.TransmittedCount; // total number of sent bytes
                pms->rec_bytes      = extension->OurStats.ReceivedCount;  // total number of receive bytes
 
                pms->sent_packets   = extension->sent_packets;   // number of write() packets
                pms->rec_packets    = extension->rec_packets;    // number of read() packets
 
                pms->overrun_errors = (USHORT)(extension->OurStats.SerialOverrunErrorCount +
                                    extension->OurStats.BufferOverrunErrorCount);
                pms->framing_errors = (USHORT)(extension->OurStats.FrameErrorCount);
                pms->parity_errors  = (USHORT)(extension->OurStats.ParityErrorCount);
#ifdef S_VS 
                if (extension->Port != NULL)
                  pms->status_flags =     // 20H, 10H, 8H
                  (extension->Port->msr_value & (CTS_ACT | DSR_ACT | CD_ACT)) |
                                      // 1H, 2H
                  (WORD)(extension->DTRRTSStatus & (SERIAL_DTR_STATE | SERIAL_RTS_STATE));
#else
                pms->status_flags =     // 20H, 10H, 8H
                  (extension->ModemCtl & (CTS_ACT | DSR_ACT | CD_ACT)) |
                                    // 1H, 2H
                  (WORD)(extension->DTRRTSStatus & (SERIAL_DTR_STATE | SERIAL_RTS_STATE));
#endif 
                if (extension->DeviceIsOpen)
                   pms->status_flags  |= 0x100;
 
#ifdef COMMENT_OUT
                if (sIsCTSFlowCtlEnabled(sIsComDevExt->ChP))
                  pms->status_flags  |= 0x1000;
                if (sIsRTSFlowCtlEnabled(sIsComDevExt->ChP)) 
                   pms->status_flags  |= 0x2000;
                if (sIsTxSoftFlowCtlEnabled(sIsComDevExt->ChP))
                   pms->status_flags  |= 0x4000;
#endif
                ++pms;
                ++Dev;
                extension = extension->port_ext;  // next in chain
              }  // while port extension
                board_ext = board_ext->board_ext;  // next in chain
            }  // while board extension

            Irp->IoStatus.Information = (sizeof(PortMonBase) +
                               sizeof(PortMonStatus)*Dev);
            Status = STATUS_SUCCESS;
          break;   // case 11(status)

#ifdef COMMENT_OUT
      //****************************** debug PCI
          case 12:  // debug in/out instructions
            {
            char *str;
            int i,j,k;
            // KIRQL newlevel, oldlevel;

            Status = STATUS_SUCCESS;

            buf = (char *) &pmb[1];  // ptr to after first struct
            //  Eprintf("dump %s",buf);
            str = buf;
            while ((*str != 0) && (*str != ' '))
              ++str;
            if (*str == ' ')
              ++str;
 
               // newlevel = 2;
               // KeRaiseIrql(newlevel, &oldlevel);
               // KeLowerIrql(oldlevel);
+
            if ((buf[0] == 'i') && (buf[1] == 'n'))
            {
              j = 0;
              i = gethint(str, &j);

              if (buf[2] == 'w')
              {
                str = (char *) i;
                k = READ_PORT_USHORT((PUSHORT) str);

                Sprintf(buf, "InW[%x] = %x\n",i, k);
              }
              else
              {
                str = (char *) i;
                k = READ_PORT_UCHAR((PUCHAR) str);
                // k = inp(i);
                Sprintf(buf, "InB[%x] = %x\n",i, k);
              }

            }
            else if ((buf[0] == 'o') && (buf[1] == 'u'))
            {
              j = 0;
              i = gethint(str, &j);
              k = gethint(&str[j], &j);
              str = (char *) i;
              buf[0] = 0;
              if (buf[3] == 'd')
              {
                //sOutDW(i, k);
                WRITE_PORT_ULONG((PULONG) str, (ULONG) k);
                Sprintf(buf, "OutDW[%x] = %x\n",i, k);
              }
              else if (buf[3] == 'w')
              {
                //sOutW(i, k);
                WRITE_PORT_USHORT((PUSHORT) str, (USHORT) k);
                Sprintf(buf, "OutW[%x] = %x\n",i, k);
              }
              else
              {
                WRITE_PORT_UCHAR((PUCHAR) str, (UCHAR) k);
                //sOutB(i, k);
                Sprintf(buf, "OutB[%x] = %x\n",i, k);
              }
              // Eprintf("Out[%x] = %x\n",i, k);
            }
            else
            {
              Status = STATUS_BUFFER_TOO_SMALL;  // return an error
              strcpy(buf, "Bad ioctl");
              Eprintf("bad io ioctl %s",buf);
            }

            Irp->IoStatus.Information = sizeof(PortMonBase) +
                               strlen(buf) + 1;
            }
          break;   // case 12(in/out)
#endif

          //*************** driver debug log
          case 13:  // driver debug log
          {
            char *str;
            int i;

            Status = STATUS_SUCCESS;

            // someone is actively running the debugger, so don't timeout
            if (Driver.DebugTimeOut > 0)  // used to timeout inactive debug sessions.
               Driver.DebugTimeOut = 100;  // about 600 second seconds timeout

            buf = (char *) &pmb[1];  // ptr to after first struct
            //  Eprintf("dump %s",buf);
            str = buf;

            //----- limit incoming line buffer size
            i = 0;
            while ((*str != 0) && (i < 160))
            {
              ++str;
              ++i;
            }
            *str = 0;

            str = buf;
            if (*str != 0)
              do_cmd_line(str);

            if (!q_empty(&Driver.DebugQ))
            {
              int q_cnt;
              q_cnt = q_count(&Driver.DebugQ);
              if (q_cnt > 1000)
                q_cnt = 1000;
              Irp->IoStatus.Information = sizeof(PortMonBase) + q_cnt;
              pmb->struct_size = (ULONG) q_cnt;
              buf = (char *) &pmb[1];  // ptr to after first struct
              q_get(&Driver.DebugQ, (BYTE *) &pmb[1], q_cnt);
            }
            else
            {
              pmb->struct_size = (ULONG) 0;
              Irp->IoStatus.Information = sizeof(PortMonBase);
            }
          }
          break;   // driver debug log

          //*************** driver option set
          case 14:
            {
            int stat;

            Status = STATUS_SUCCESS;
            buf = (char *) &pmb[1];  // ptr to after first struct
            MyKdPrint(D_Init, ("Ioctl Option:%s\n", buf))
            stat = SetOptionStr(buf);
            Sprintf(buf, "Option stat:%d\n",stat);

            if (stat != 0)
            {
              MyKdPrint(D_Init, (" Err:%d\n", stat))
            }
            Irp->IoStatus.Information = sizeof(PortMonBase) +
                               strlen(buf) + 1;
            }
          break;   // driver option set

#ifdef S_VS
          //*************** mac-address list
          case 15:
            {
              MyKdPrint(D_Ioctl,("start mac list\n"))
              Status = STATUS_SUCCESS;
              buf = (char *) &pmb[1];  // ptr to after first struct
              buf[0] = 0;

              MyKdPrint(D_Ioctl,("do find\n"))
              find_all_boxes(0);  // get list of all boxes out on networks
              find_all_boxes(1);  // do 2nd scan just to be sure

              memcpy(buf, Driver.BoxMacs, 8*Driver.NumBoxMacs);
            
              Irp->IoStatus.Information = sizeof(PortMonBase) +
                               8*Driver.NumBoxMacs;
              MyKdPrint(D_Ioctl,("end mac list\n"))
            }
          break;

          case 16: // advisor sheet: probe NIC status
            MyKdPrint(D_Ioctl,("start nic probe"))
            Irp->IoStatus.Information = 
              (ProbeNic((unsigned char *)&pmb[1],
                        (int)pmb->struct_size)) + sizeof(PortMonBase);
            Status = STATUS_SUCCESS;  // don't need, default
            MyKdPrint(D_Ioctl,("end nic probe"))
          break;

          case 17:  // advisor sheet: probe VS status
            MyKdPrint(D_Ioctl,("start vs probe"))
            Irp->IoStatus.Information = 
              (ProbeDevices((unsigned char *)&pmb[1],
                            (int)pmb->struct_size)) + sizeof(PortMonBase);
        
            MyKdPrint(D_Ioctl,("end vs probe"))
            Status = STATUS_SUCCESS;  // don't need, default
          break;
#endif
          default:
            Status = STATUS_BUFFER_TOO_SMALL;
          break;
        }  // switch
      }
      break;

      //******************************

      case IOCTL_RCKT_SET_MODEM_RESET:
      {
        char *ResetData;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Set Modem Reset");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (char *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
		   ResetData = (char *)Irp->AssociatedIrp.SystemBuffer;
           MyKdPrint(D_Ioctl,("Set reset on Port: %s\n", ResetData))
           ext = find_ext_by_name(ResetData, NULL);
           if (ext)
             ModemReset(ext, 1);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};
        break;
      }

      case IOCTL_RCKT_CLEAR_MODEM_RESET:
      {
        char *ResetData;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Clear Modem Reset");

		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (char *) )
		{
           Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
           ResetData = (char *)Irp->AssociatedIrp.SystemBuffer;
           MyKdPrint(D_Ioctl,("Clear reset on Port: %s\n", ResetData))
           ext = find_ext_by_name(ResetData, NULL);
           if (ext)
             ModemReset(ext, 0);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};
        break;
      }

      case IOCTL_RCKT_SEND_MODEM_ROW:
      {
        char *ResetData;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Send Modem ROW");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (char *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
		   ResetData = (char *)Irp->AssociatedIrp.SystemBuffer;
           MyKdPrint(D_Ioctl,("ROW write on Port: %s\n", ResetData))
           ext = find_ext_by_name(ResetData, NULL);
           if (ext)
             ModemWriteROW(ext, Driver.MdmCountryCode);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};
        break;
      }

#ifdef S_RK
      //******************************
      // These are the old versions of
      // the Reset/ROW ioctls and are
      // provided here only for
      // compatibility with RktReset

      case IOCTL_RCKT_SET_MODEM_RESET_OLD:
      {
        int *ResetData;
        int ChanNum;
        int DevNum;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Set Modem Reset");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (int *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
		else
		{
           ResetData = (int *)Irp->AssociatedIrp.SystemBuffer;
           ChanNum = (*ResetData) & 0xFFFF;
           DevNum = (*ResetData) >> 0x10;
           MyKdPrint(D_Ioctl,("Set reset on Dev: %x, Chan: %x\n", DevNum, ChanNum))
           ext = find_ext_by_index(DevNum, ChanNum);
           if (ext)
             sModemReset(ext->ChP, 1);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};

        break;
      }

      case IOCTL_RCKT_CLEAR_MODEM_RESET_OLD:
      {
        int *ResetData;
        int ChanNum;
        int DevNum;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Clear Modem Reset");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (int *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
		   ResetData = (int *)Irp->AssociatedIrp.SystemBuffer;
           ChanNum = (*ResetData) & 0xFFFF;
           DevNum = (*ResetData) >> 0x10;
           MyKdPrint(D_Ioctl,("Clear reset on Dev: %x, Chan: %x\n", DevNum, ChanNum))
           ext = find_ext_by_index(DevNum, ChanNum);
           if (ext)
             sModemReset(ext->ChP, 0);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;
		};

        break;
      }

      case IOCTL_RCKT_GET_RCKTMDM_INFO_OLD:
      {
        // to maintain compatibility with RktReset, only the first
        // four boards are reported and only the first eight ports
        // on each are allowed.
        RocketModemConfig *RMCfg;
        int BoardNum;
        int PortNum;
        int np;
        PSERIAL_DEVICE_EXTENSION ext_p;   // port extension
        PSERIAL_DEVICE_EXTENSION ext_b;   // board extension

        MyKdPrint(D_Ioctl, ("[Get RktMdm Cfg]\n"))
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(RocketModemConfig))
        {
          Status = STATUS_BUFFER_TOO_SMALL;
          MyKdPrint(D_Ioctl, ("[Buffer too small]\n"))
          break;
        }

        RMCfg = (RocketModemConfig *)Irp->AssociatedIrp.SystemBuffer;
        RMCfg->rm_country_code = Driver.MdmCountryCode;
        RMCfg->rm_settle_time = Driver.MdmSettleTime;
        ext_b = Driver.board_ext;
        BoardNum = 0;
        while ((ext_b) && (BoardNum < 4) )
        {
          if (ext_b->config->ModemDevice) {
            //np = ext_b->config->NumChan;  [kpb, 5-7-98]
            np = ext_b->config->NumPorts;
            if (np > 8)
              np = 8;   // force to 8 since structure only has room for 8
            RMCfg->rm_board_cfg[BoardNum].num_rktmdm_ports = np;
            PortNum = 0;
            ext_p = find_ext_by_index(BoardNum, PortNum);
            while ( (ext_p) && (PortNum < np) )
            {
              if (ext_p)
                strcpy(RMCfg->rm_board_cfg[BoardNum].port_names[PortNum],
                       ext_p->SymbolicLinkName);
              else
                strcpy(RMCfg->rm_board_cfg[BoardNum].port_names[PortNum], 0);
              PortNum++;
              ext_p = find_ext_by_index(BoardNum, PortNum);
            }
          }
          ext_b = ext_b->board_ext;
          BoardNum++;
        }
        Irp->IoStatus.Information = sizeof(RocketModemConfig);
        Status = STATUS_SUCCESS;
        break;
      }

      case IOCTL_RCKT_SEND_MODEM_ROW_OLD:
      {
        int *ResetData;
        int ChanNum;
        int DevNum;
        PSERIAL_DEVICE_EXTENSION ext;

        ExtTrace(Extension,D_Ioctl,"Send Modem ROW");
		if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
			sizeof (int *) )
		{
		   Status = STATUS_INVALID_PARAMETER;
		}
	    else
		{
           ResetData = (int *)Irp->AssociatedIrp.SystemBuffer;
           ChanNum = (*ResetData) & 0xFFFF;
           DevNum = (*ResetData) >> 0x10;
           MyKdPrint(D_Ioctl,("ROW write on Dev: %x, Chan: %x\n", DevNum, ChanNum))
           ext = find_ext_by_index(DevNum, ChanNum);
           if (ext)
             sModemWriteROW(ext->ChP, Driver.MdmCountryCode);

           Irp->IoStatus.Information = 0;
           Status = STATUS_SUCCESS;		    
		};

        break;
      }
#endif

      //******************************
      default:        // bad IOCTL request
      {
        MyKdPrint(D_Ioctl,("Err1O"))
        ExtTrace1(Extension,D_Ioctl," UnHandle IoCtl:%d",
                 IrpSp->Parameters.DeviceIoControl.IoControlCode);
        Status = STATUS_INVALID_PARAMETER;
        break;
      }
   }

   Irp->IoStatus.Status = Status;
   if (Status != STATUS_SUCCESS)
   {
     MyKdPrint(D_Ioctl, (" Bad Status:%xH on IOCTL:%xH",
           Status, IrpSp->Parameters.DeviceIoControl.IoControlCode));
     ExtTrace2(Extension, D_Ioctl, " Bad Status:%xH on IOCTL:%xH",
           Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
     switch (Status)
     { 
       case STATUS_BUFFER_TOO_SMALL:
         MyKdPrint(D_Ioctl,(" Err, Buf Too Small!"));
         ExtTrace(Extension,D_Ioctl," Err, Buf Too Small!");
       break;
       case STATUS_INVALID_PARAMETER:
         MyKdPrint(D_Ioctl,(" Err, Bad Parm!"));
         ExtTrace(Extension,D_Ioctl," Err, Bad Parm!");
       break;
       default:
       break;

     }
   }
   SerialCompleteRequest(Extension, Irp, 0);
   return Status;
}

/*--------------------------------------------------------------------------
 FindDevExt -
  Purpose:  To scan through my Dev objects and return a device object ext
  Return:  PSERIAL_DEVICE_EXTENSION 
|--------------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION FindDevExt(IN PCHAR PortName)
{
   PSERIAL_DEVICE_EXTENSION extension;
   PSERIAL_DEVICE_EXTENSION board_ext;
   int Dev;
   char *pn;
   char *dev_pn;
   int done;
   Dev =0;
   board_ext = Driver.board_ext;
   while (board_ext)
   {
     extension = board_ext->port_ext;
     while (extension)
     {
       pn = PortName;
       dev_pn = extension->SymbolicLinkName;
       done = 0;
       while ((*dev_pn != 0) && (*pn != 0) && (done == 0))
       {
         if (*dev_pn != *pn)
           done = 1;  // no match, try next
         ++dev_pn;
         ++pn;
       }
       if ((*dev_pn == 0) && (*pn == 0))
         return (extension);  // found it, return ext.

      ++Dev;
      extension = extension->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;
  }  // while board extension

   return NULL;
}

/*--------------------------------------------------------------------------
 ProgramBaudRate -
  Purpose:   Configure channel for desired baud rate
  Return:    STATUS_SUCCESS: if baud rate was configured
             STATUS_INVALID_PARAMETER: if baud rate cannot be configured
|--------------------------------------------------------------------------*/
NTSTATUS
ProgramBaudRate(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN ULONG DesiredBaudRate
)
{
 ULONG InBaud = DesiredBaudRate;

   //---- handle baud mapping
   if (Extension->port_config->LockBaud != 0)
     DesiredBaudRate = Extension->port_config->LockBaud;

   MyKdPrint(D_Ioctl,("[DesiredBaud %d]",DesiredBaudRate))
   if (DesiredBaudRate == 56000) DesiredBaudRate = 57600;
   else if (DesiredBaudRate == 128000) DesiredBaudRate = 115200;
   else if (DesiredBaudRate == 256000) DesiredBaudRate = 230400;

#ifdef S_VS
   if(PortSetBaudRate(Extension->Port,DesiredBaudRate,FALSE,
           Extension->board_ext->config->ClkRate,
           Extension->board_ext->config->ClkPrescaler))
         return(STATUS_INVALID_PARAMETER);
#else
   if(sSetBaudRate(Extension->ChP,DesiredBaudRate,FALSE))
         return(STATUS_INVALID_PARAMETER);
#endif
   Extension->BaudRate = InBaud;

#ifdef S_VS
   PortSetBaudRate(Extension->Port,DesiredBaudRate, TRUE,
           Extension->board_ext->config->ClkRate,
           Extension->board_ext->config->ClkPrescaler);
#else
   sSetBaudRate(Extension->ChP,DesiredBaudRate,TRUE);
#endif

   return (STATUS_SUCCESS);
}

/*--------------------------------------------------------------------------
  ProgramLineControl
  Purpose:   Configure channels line control (data bits, stop bits, parity)
  Return:    STATUS_SUCCESS: if line control was programmed as desired
             STATUS_INVALID_PARAMETER: if line control setting was invalid
|--------------------------------------------------------------------------*/
NTSTATUS
ProgramLineControl(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_LINE_CONTROL Lc
)
{
   switch (Lc->WordLength)
   {
      case 7:
         ExtTrace(Extension,D_Ioctl, "7-bits");
#ifdef S_VS
         pSetData7(Extension->Port);
#else
         sSetData7(Extension->ChP);
         sSetRxMask(Extension->ChP,0x7f);
#endif
         Extension->LineCtl.WordLength = Lc->WordLength;
      break;

      case 8:
         ExtTrace(Extension,D_Ioctl, "8-bits");
#ifdef S_VS
         pSetData8(Extension->Port);
#else
         sSetData8(Extension->ChP);
         sSetRxMask(Extension->ChP,0xff);
#endif
         Extension->LineCtl.WordLength = Lc->WordLength;
      break;

      case 5:
         ExtTrace(Extension,D_Ioctl, "Err WL5");
         return(STATUS_INVALID_PARAMETER);
      case 6:
         ExtTrace(Extension,D_Ioctl, "Err WL6");
         return(STATUS_INVALID_PARAMETER);
      default:
         ExtTrace(Extension,D_Ioctl, "Err WL?");
         return(STATUS_INVALID_PARAMETER);
   }

   switch (Lc->Parity)
   {
      case NO_PARITY:
         ExtTrace(Extension,D_Ioctl, "No-Par.");
#ifdef S_VS
         pDisParity(Extension->Port);
#else
         sDisParity(Extension->ChP);
#endif
         Extension->LineCtl.Parity = Lc->Parity;
         break;

      case EVEN_PARITY:
         ExtTrace(Extension,D_Ioctl, "Ev-Par.");
#ifdef S_VS
         pSetEvenParity(Extension->Port);
#else
         sEnParity(Extension->ChP);
         sSetEvenParity(Extension->ChP);
#endif
         Extension->LineCtl.Parity = Lc->Parity;
         break;

      case ODD_PARITY:
         ExtTrace(Extension,D_Ioctl, "Odd-Par.");
#ifdef S_VS
         pSetOddParity(Extension->Port);
#else
         sEnParity(Extension->ChP);
         sSetOddParity(Extension->ChP);
#endif
         Extension->LineCtl.Parity = Lc->Parity;
         break;

      case MARK_PARITY:
         ExtTrace(Extension,D_Ioctl, "Err PM");
         return(STATUS_INVALID_PARAMETER);
      case SPACE_PARITY:
         ExtTrace(Extension,D_Ioctl, "Err PS");
         return(STATUS_INVALID_PARAMETER);
      default:
         ExtTrace(Extension,D_Ioctl, "Err P?");
         return(STATUS_INVALID_PARAMETER);
   } // end switch parity...

   switch (Lc->StopBits)
   {
      case STOP_BIT_1:
         ExtTrace(Extension,D_Ioctl, "1-StopB");
#ifdef S_VS
         pSetStop1(Extension->Port);
#else
         sSetStop1(Extension->ChP);
#endif
         Extension->LineCtl.StopBits = Lc->StopBits;
         break;

      case STOP_BITS_1_5:
         ExtTrace(Extension,D_Ioctl, "Err S1.5");
         return(STATUS_INVALID_PARAMETER);

      case STOP_BITS_2:
         if (Extension->port_config->Map2StopsTo1)
         {
           ExtTrace(Extension,D_Ioctl, "2to1-StopB");
#ifdef S_VS
           pSetStop1(Extension->Port);
#else
           sSetStop1(Extension->ChP);
#endif
         }
         else
         {
           ExtTrace(Extension,D_Ioctl, "2-StopB");
#ifdef S_VS
           pSetStop2(Extension->Port);
#else
           sSetStop2(Extension->ChP);
#endif
         }
         Extension->LineCtl.StopBits = Lc->StopBits;
         break;
   }
   return (STATUS_SUCCESS);
}

/*--------------------------------------------------------------------
 SerialSetHandFlow -
Note: This is somewhat redundant to ForceExtensionSettings() in openclos.c.
|-------------------------------------------------------------------*/
void SerialSetHandFlow(PSERIAL_DEVICE_EXTENSION Extension,
                              SERIAL_HANDFLOW *HandFlow)
{
         //////////////////////////////////////////////
         // All invalid parameters have been dealt with.
         // Now, program the settings.

         //////////////
         // DTR control

         if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
             (HandFlow->ControlHandShake & SERIAL_DTR_MASK))
         {
            Extension->RXHolding &= ~SERIAL_RX_DSR;
            if (  (HandFlow->ControlHandShake & SERIAL_DTR_MASK) ==
                    SERIAL_DTR_CONTROL )
            {
#ifdef S_VS
               pSetDTR(Extension->Port);
#else
               sSetDTR(Extension->ChP);
#endif
               Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
            }
            else if (  (HandFlow->ControlHandShake & SERIAL_DTR_MASK) ==
                    SERIAL_DTR_HANDSHAKE )
            {
#ifdef S_VS
               pEnDTRFlowCtl(Extension->Port);
               Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
#else
               if(  (sGetRxCnt(Extension->ChP) >= RX_HIWATER) ||
                    (!(Extension->DevStatus & COM_RXFLOW_ON))
                 )
               {
                  // drop DTR
                  Extension->DevStatus &= ~COM_RXFLOW_ON;
                  sClrDTR(Extension->ChP);
                  Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
                  Extension->RXHolding |= SERIAL_RX_DSR;
               }
               else
               {
                  // DTR should be on
                  sSetDTR(Extension->ChP);
                  Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
               }
#endif
            }
            else
            {
#ifdef S_VS
               pClrDTR(Extension->Port);
#else
               sClrDTR(Extension->ChP);
#endif
               Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
            }
         }

         //////////////
         // RTS control

         if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
             (HandFlow->FlowReplace & SERIAL_RTS_MASK))
         {

            Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
#ifdef S_VS
            pDisRTSFlowCtl(Extension->Port);
#else
            sDisRTSFlowCtl(Extension->ChP);  // add V2.8.001(2-19-96)
#endif
            switch(HandFlow->FlowReplace & SERIAL_RTS_MASK)
            {
               case SERIAL_RTS_CONTROL: // RTS Should be asserted while open
#ifdef S_VS
                  pSetRTS(Extension->Port);
#else
                  sSetRTS(Extension->ChP);
#endif
                  Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
                  break;
               case SERIAL_RTS_HANDSHAKE: // RTS hardware input flow control
#ifdef S_VS
                  pEnRTSFlowCtl(Extension->Port);
#else
                  sEnRTSFlowCtl(Extension->ChP);
#endif
                  Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
                  break;
               case SERIAL_TRANSMIT_TOGGLE: // RTS transmit toggle enabled

                  if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
                  {  // normal case, emulate standard operation
                    Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
                    Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
#ifdef S_VS
                    pEnRTSToggleHigh(Extension->Port);
#else
                    sClrRTS(Extension->ChP);
#endif
                  }
                  else 
                  {  // hardware reverse case
#ifdef S_VS
                    pEnRTSToggleLow(Extension->Port);
#else
                    sEnRTSToggle(Extension->ChP);
#endif
                    Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
                  }
                  break;
               default:
#ifdef S_VS
                  pClrRTS(Extension->Port);
#else
                  sClrRTS(Extension->ChP);
#endif
                  Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
                  break;
            }
         }

         if (Extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
         {
           if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
           {  // normal case, emulate standard operation
             Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
             Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
#ifdef S_VS
             pEnRTSToggleHigh(Extension->Port);
#else
             sClrRTS(Extension->ChP);
#endif
           }
           else 
           {  // hardware reverse case
#ifdef S_VS
             pEnRTSToggleLow(Extension->Port);
#else
             sEnRTSToggle(Extension->ChP);
#endif
             Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
           }
         }

         ///////////////////////////////
         // Software output flow control

         if ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
             (HandFlow->FlowReplace & SERIAL_AUTO_TRANSMIT))
         {
            if (HandFlow->FlowReplace & SERIAL_AUTO_TRANSMIT)
            {
#ifdef S_VS
               pEnTxSoftFlowCtl(Extension->Port);
#else
               sEnTxSoftFlowCtl(Extension->ChP);
#endif
            }
            else
            {
#ifdef S_VS
              pDisTxSoftFlowCtl(Extension->Port);
#else
              if (Extension->TXHolding & ST_XOFF_FAKE)
              {
                Extension->TXHolding &= ~ST_XOFF_FAKE;
                if ((Extension->TXHolding & 
                  (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
                   sEnTransmit(Extension->ChP); // Start up the transmitter
                sDisRxCompare2(Extension->ChP);
              }
              sDisTxSoftFlowCtl(Extension->ChP);
              sClrTxXOFF(Extension->ChP);
#endif
              Extension->TXHolding &= ~SERIAL_TX_XOFF;
            }
         }

         ///////////////////////////////////////////////////////////////
         // SERIAL_AUTO_RECEIVE checked only because it may be necessary
         // to send an XON if we were using s/w input flow control

         // Did the setting change?
         if ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
             (HandFlow->FlowReplace & SERIAL_AUTO_RECEIVE))
         {
#ifdef S_VS
            if (HandFlow->FlowReplace & SERIAL_AUTO_RECEIVE)
            {
              pEnRxSoftFlowCtl(Extension->Port);
            }
            else
            {
              pDisRxSoftFlowCtl(Extension->Port);
            }
#endif
            // Are we turning AUTO_REC.. off?
            if(!(HandFlow->FlowReplace & SERIAL_AUTO_RECEIVE))
            {
               // Is the remote flowed off?
               if(!(Extension->DevStatus & COM_RXFLOW_ON))
               {
                  // send XON
                  Extension->DevStatus |= COM_RXFLOW_ON;
#ifdef S_RK
                  sWriteTxPrioByte(Extension->ChP,
                                    Extension->SpecialChars.XonChar);
#endif
               }
            }
         }

         /////////////////////////////////////////////////////////
         // No need to program the Rocket for following:
         // SERIAL_BREAK_CHAR
         // Replace Break error (NULL) with SpecialChars.BreakChar
         // SERIAL_ERROR_CHAR
         // Replace Parity and Framing with SpecialChars.ErrorChar

         ///////////////////////////////////
         // CTS hardware output flow control

         if ((Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) !=
             (HandFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE))
         {
            if (HandFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE)
            {
#ifdef S_VS
               pEnCTSFlowCtl(Extension->Port);
#else
               sEnCTSFlowCtl(Extension->ChP);
#endif
               if (!(Extension->ModemStatus & SERIAL_CTS_STATE))
                  Extension->TXHolding |= SERIAL_TX_CTS;    // clear holding
            }
            else
            {
#ifdef S_VS
               pDisCTSFlowCtl(Extension->Port);
#else
               sDisCTSFlowCtl(Extension->ChP);
#endif
               Extension->TXHolding &= ~SERIAL_TX_CTS;    // clear holding
            }
         }

         ///////////////////////////////////
         // DSR hardware output flow control
#ifdef S_VS
         if ((Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) !=
             (HandFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE))
         {
            if (HandFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE)
            {
              pEnDSRFlowCtl(Extension->Port);
              if (!(Extension->ModemStatus & SERIAL_DSR_STATE))
                 Extension->TXHolding |= SERIAL_TX_DSR;
            }
            else
            {
              pDisDSRFlowCtl(Extension->Port);
              Extension->TXHolding &= ~SERIAL_TX_DSR;
            }
         }
#endif

#ifdef S_VS
         ///////////////////////////////////
         // DCD hardware output flow control

         if ((Extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE) !=
             (HandFlow->ControlHandShake & SERIAL_DCD_HANDSHAKE))
         {
            if (HandFlow->ControlHandShake & SERIAL_DCD_HANDSHAKE)
            {
              pEnCDFlowCtl(Extension->Port);
              if (!(Extension->ModemStatus & SERIAL_DCD_STATE))
                 Extension->TXHolding |= SERIAL_TX_DCD;
            }
            else
            {
              pDisCDFlowCtl(Extension->Port);
              Extension->TXHolding &= ~SERIAL_TX_DCD;
            }
         }
#endif

         /////////////////
         // Null stripping

         if (HandFlow->FlowReplace & SERIAL_NULL_STRIPPING)
         {
#ifdef S_VS
            pEnNullStrip(Extension->Port);
#else
            sEnRxIgnore0(Extension->ChP,0);
#endif
         }
         else
         {
#ifdef S_VS
            pDisNullStrip(Extension->Port);
#else
            sDisRxCompare0(Extension->ChP);
#endif
         }

         Extension->HandFlow.FlowReplace = HandFlow->FlowReplace;
         Extension->HandFlow.ControlHandShake = HandFlow->ControlHandShake;

#ifdef S_RK
         // update this because it handles flow-control and holding update
         SetExtensionModemStatus(Extension);
#endif
}

#ifdef NT50
/*--------------------------------------------------------------------
 SerialInternalIoControl -
|-------------------------------------------------------------------*/
NTSTATUS
SerialInternalIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    KIRQL OldIrql;
    BOOLEAN acceptingIRPs;

    acceptingIRPs = SerialIRPPrologue(Extension);

    if (acceptingIRPs == FALSE) {
       MyKdPrint(D_Ioctl,("Ioctl:no irps aceepted\n"))
       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
       SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       return STATUS_NO_SUCH_DEVICE;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;

    MyKdPrint(D_Ioctl,("SerialIntIoControl: %x\n",
                          IrpSp->Parameters.DeviceIoControl.IoControlCode))
    // Make sure we aren't aborting due to error (ERROR_ABORT)

    if (Extension->ErrorWord)
    {
      if (Extension->DeviceType == DEV_PORT)
      {
        if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        {
           {ExtTrace(Extension,D_Ioctl,"ErrSet!");}
           return STATUS_CANCELLED;
        }
      }
    }

    if (Extension->DeviceType == DEV_BOARD)
    {
       ExtTrace2 (Extension, D_Ioctl, " Bad Status:%xH on IIOCTL:%xH",
                  Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
       Status = STATUS_INVALID_DEVICE_REQUEST;
       SerialCompleteRequest (Extension, Irp, 0);
       return Status;
    };

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
#if 0
    case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
       // Send a wait-wake IRP
       Status = SerialSendWaitWake(Extension);
       break;

    case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:
       if (Extension->PendingWakeIrp != NULL) {
          IoCancelIrp(Extension->PendingWakeIrp);
       }
       break;
#endif

      case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
      case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
      {
        SERIAL_BASIC_SETTINGS basic;
        PSERIAL_BASIC_SETTINGS pBasic;
        //SHORT AppropriateDivisor;
        //SERIAL_IOCTL_SYNC S;

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
        {

            MyKdPrint(D_Ioctl,("[Set Internal Settings]\n"))
            ExtTrace(Extension,D_Ioctl,"Set Int Settings");

            // Check the buffer size
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_BASIC_SETTINGS))
            {
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
	    }

            //
            // Everything is 0 -- timeouts and flow control.  If
            // We add additional features, this zero memory method
            // may not work.
            //

            RtlZeroMemory(&basic, sizeof(SERIAL_BASIC_SETTINGS));

            Irp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
            pBasic = (PSERIAL_BASIC_SETTINGS)Irp->AssociatedIrp.SystemBuffer;

            //
            // Save off the old settings
            //

            RtlCopyMemory(&pBasic->Timeouts, &Extension->Timeouts,
                          sizeof(SERIAL_TIMEOUTS));

            RtlCopyMemory(&pBasic->HandFlow, &Extension->HandFlow,
                          sizeof(SERIAL_HANDFLOW));

            //
            // Point to our new settings
            //

            pBasic = &basic;
        }
        else //restoring settings
        { 
            MyKdPrint(D_Ioctl,("[Restore Internal Settings]\n"))
            ExtTrace(Extension,D_Ioctl,"Reset Int Settings");

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength
                < sizeof(SERIAL_BASIC_SETTINGS))
            {
               Status = STATUS_BUFFER_TOO_SMALL;
               break;
	    }

            pBasic = (PSERIAL_BASIC_SETTINGS)Irp->AssociatedIrp.SystemBuffer;
	}

        KeAcquireSpinLock(&Extension->ControlLock, &OldIrql);

        //
        // Set the timeouts
        //

        RtlCopyMemory(&Extension->Timeouts, &pBasic->Timeouts,
                      sizeof(SERIAL_TIMEOUTS));

        //
        // Set flowcontrol
        //
       
        //S.Extension = Extension;
        //S.Data = &pBasic->HandFlow;
        SerialSetHandFlow(Extension, &pBasic->HandFlow);
        //KeSynchronizeExecution(Extension->Interrupt, SerialSetHandFlow, &S);

        KeReleaseSpinLock(&Extension->ControlLock, OldIrql);
      }
      break;

      default:
        Status = STATUS_INVALID_PARAMETER;
      break;
   }

   Irp->IoStatus.Status = Status;
   if (Status != STATUS_SUCCESS)
   {
     ExtTrace2(Extension, D_Ioctl, " Bad Status:%xH on IIOCTL:%xH",
           Status, IrpSp->Parameters.DeviceIoControl.IoControlCode);
   }
   SerialCompleteRequest(Extension, Irp, 0);
   return Status;
}
#endif

#ifdef S_VS
#define  RESET_STATS    1

/*--------------------------------------------------------------------
 find_ext_mac_match 
|-------------------------------------------------------------------*/
static PSERIAL_DEVICE_EXTENSION find_ext_mac_match(unsigned char *mac_addr)
{
  PSERIAL_DEVICE_EXTENSION ext;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if (mac_match(mac_addr, ext->hd->dest_addr))
    {
      //MyKdPrint(D_Ioctl,("Found ext:%x\n", ext))
      return ext;
    }
    ext = ext->board_ext; // next one
  }
  return NULL;
}

/*--------------------------------------------------------------------
 ProbeNic - determine status associated nic card.
|-------------------------------------------------------------------*/
static int ProbeNic(unsigned char *pPtr, int availableLength)
{
 int nic_index;
 int stat;
 PROBE_NIC_STRUCT *pn;
 Nic *nic;
 int flag;

  pn = (PROBE_NIC_STRUCT *) pPtr;

  nic_index = (int) pPtr[0];  // they passed in an index to which nic card
  flag = (int) pPtr[1];  // they passed in a flag too

  stat = 0;
  if (nic_index >= VS1000_MAX_NICS)
  {
    MyKdPrint(D_Error,("Err PD1F\n"))
    stat = 1;  // err
  }

  if (Driver.nics == NULL)
  {
    MyKdPrint(D_Error,("Err PD1G\n"))
    stat = 2;  // err
  }

  if (Driver.nics[nic_index].NICHandle == NULL)
  {
    MyKdPrint(D_Error,("Err PD1H\n"))
    stat = 3;  // err
  }
  if (stat != 0)
  {
    pn->struct_size = 0;
    return sizeof(PROBE_NIC_STRUCT);
  }
  pn->struct_size = sizeof(PROBE_NIC_STRUCT);

  nic = &Driver.nics[nic_index];

#if 0
  if (flag & RESET_STATS) {
    nic->pkt_sent      = 0;
    nic->pkt_rcvd_ours = 0;
    nic->pkt_rcvd_not_ours  = 0;
  }
#endif

  // copy over the data
  memcpy(pn->NicName, nic->NicName, 60);
  pn->NicName[59] = 0;  // ensure null terminated
  memcpy(pn->address, nic->address, 6);
  pn->Open = nic->Open;
  pn->pkt_sent = nic->pkt_sent;
  pn->pkt_rcvd_ours = nic->pkt_rcvd_ours;
  pn->pkt_rcvd_not_ours = nic->pkt_rcvd_not_ours;

  return sizeof(PROBE_NIC_STRUCT);
}

/*--------------------------------------------------------------------
 ProbeDevices - determine status associated with the hex MAC address at pPtr; 
  find associated Comtrol devices...
|-------------------------------------------------------------------*/
static int ProbeDevices(unsigned char *pPtr, int availableLength)
{
  Nic     *nic;
  PortMan *pm;
  Hdlc    *hd;
  unsigned char mac_address[6];
  int    flag;
  int stat,i;
  PSERIAL_DEVICE_EXTENSION ext;
  PROBE_DEVICE_STRUCT *pr = (PROBE_DEVICE_STRUCT *) pPtr;

  memcpy(mac_address,pPtr,sizeof(mac_address));
  flag = pPtr[sizeof(mac_address)];

  // find the active device with the matching address
  ext = find_ext_mac_match(mac_address);

  stat = 0;
  if (ext == NULL)
  {
    MyKdPrint(D_Error,("No found mac:%x %x %x %x %x %x\n",
              mac_address[0],mac_address[1],mac_address[2],
              mac_address[3],mac_address[4],mac_address[5]))
    stat = 1;
  }

  if (ext != NULL)
  {
    pm = ext->pm;
    hd = ext->hd;
    if ((pm == NULL) || (hd == NULL))
    {
      MyKdPrint(D_Error,("No pm or hd\n"))
      stat = 2;
    }
  }

  if (stat != 0)
  {
    pr->struct_size = 0;
    MyKdPrint(D_Error,("ProbeErr1\n"))
    return sizeof(PROBE_DEVICE_STRUCT);
  }

  pr->struct_size = sizeof(PROBE_DEVICE_STRUCT);
#if 0
  if (flag & RESET_STATS) {
      pm->good_loads    = 0;
      pm->total_loads  = 0;
      hd->iframes_sent  = 0;
      hd->ctlframes_sent = 0;
      hd->rawframes_sent = 0;
      hd->iframes_resent  = 0;
      hd->frames_rcvd    = 0;
      hd->iframes_outofseq  = 0;
  }
#endif

  // give back a nic_index to use as a handle
  pr->nic_index = 0;  // default
  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if ((hd->nic == &Driver.nics[i]) && (hd->nic != NULL))
      pr->nic_index = i;
  }
  pr->num_ports = pm->num_ports;
  pr->total_loads = pm->total_loads;
  pr->good_loads = pm->good_loads;
  pr->backup_server = pm->backup_server;
  memcpy(pr->dest_addr, hd->dest_addr, 6);
  pr->state = pm->state;
  pr->iframes_sent = hd->iframes_sent;
  pr->rawframes_sent = hd->rawframes_sent;
  pr->ctlframes_sent = hd->ctlframes_sent;
  pr->iframes_resent = hd->iframes_resent;
  pr->iframes_outofseq = hd->iframes_outofseq;
  pr->frames_rcvd = hd->frames_rcvd;
          
  return sizeof(PROBE_DEVICE_STRUCT);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\ioctl.h ===
//--- ioctl.h
NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PSERIAL_DEVICE_EXTENSION
FindDevExt(IN PCHAR PortName);

NTSTATUS
ProgramBaudRate(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN ULONG DesiredBaudRate
);

NTSTATUS
ProgramLineControl(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_LINE_CONTROL Lc
);

NTSTATUS
SerialInternalIoControl(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

void SerialSetHandFlow(PSERIAL_DEVICE_EXTENSION Extension,
                              SERIAL_HANDFLOW *HandFlow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\nic.h ===
//----- nic.h

#if DBG
//#define BREAK_NIC_STUFF
#endif

#define MAX_RX_PACKETS 1

#define MAX_PKT_SIZE 1550

#ifndef BYTE
#define BYTE  UCHAR
#endif

#ifndef WORD
#define WORD  USHORT
#endif

#ifndef DWORD
#define DWORD ULONG
#endif

#ifndef PBYTE
#define PBYTE PUCHAR
#endif

#ifndef PWORD
#define PWORD PUSHORT
#endif 

#ifndef LWORD
#define LWORD ULONG
#endif

#ifndef PLWORD
#define PLWORD PULONG
#endif

// header space we leave before ndis packet data, since ndis
// wants to split the 14 byte header anyway
#define HDR_SIZE 20
#define HDR_SRC_ADDR(_buf)   (_buf)
#define HDR_DEST_ADDR(_buf)  (&_buf[6])
#define HDR_PKTLEN(_buf)     *((WORD *)&_buf[12])

typedef struct _Nic Nic;
typedef struct _Nic {

  // This is the name of the NIC card which we got from the Registry.
  // Used to specify the nic card when wee do an OpenAdapter call.
  //PUNICODE_STRING NicName;
  char NicName[160];

  int Open;  // flag, set when open for operation (use handle)

  // This is the handle for the NIC card returned from NdisOpenAdapter
  NDIS_HANDLE NICHandle;

  // This event will be set when a compeltion routine finishes so
  // if someone is waiting on it it can continue
  KEVENT CompletionEvent;

  // our local NIC address(6-bytes, two just padding)
  BYTE address[8];

  // following is for temporary output packet(convient but lots of overhead)
  // packet and buffer pool handles
  NDIS_HANDLE TxPacketPoolTemp;
  NDIS_HANDLE TxBufferPoolTemp;
  PNDIS_PACKET TxPacketsTemp;  // []
  // queue data buffer space for all packets
  UCHAR *TxBufTemp;

  // packet and buffer pool handles
  NDIS_HANDLE RxPacketPool;
  NDIS_HANDLE RxBufferPool;

  // queue of packets setup for use
  PNDIS_PACKET RxPackets[MAX_RX_PACKETS];

  // queue data buffer space for all packets
  UCHAR *RxBuf;

  LIST_ENTRY RxPacketList;
  
  NDIS_STATUS PendingStatus;

  //----- statistics
  DWORD RxPendingMoves;
  DWORD RxNonPendingMoves;

  //----- incoming statistics
  WORD pkt_overflows;  // statistics: receiver queue overflow count
  //DWORD RxPacketOurs;
  DWORD pkt_rcvd_ours;
  DWORD rec_bytes;     // statistics: running tally of bytes received.
  DWORD pkt_rcvd_not_ours;

  //----- outgoing statistics
  DWORD pkt_sent;    // statistics: running tally of packets sent.
  DWORD send_bytes;    // statistics: running tally of bytes sent.
  //Nic *next_nic;  // next nic struct in linked list or null if end of chain

  int RefIndex;
} Nic;

#define  FLAG_APPL_RUNNING  0x01
#define  FLAG_NOT_OWNER    0x02
#define  FLAG_OWNER_TIMEOUT  0x04
typedef struct {
  unsigned char  mac[6];
  unsigned char  flags;
  unsigned char  nic_index;
} DRIVER_MAC_STATUS;

//--- layer 1 ethernet events used in _proc() calls
// layer 1(ethernet) assigned range from 100-199
#define EV_L1_RX_PACKET  100
#define EV_L1_TX_PACKET  101

// comtrol_type defines(byte [14] of ethernet packet):
#define ASYNC_PRODUCT_HEADER_ID   0x55
#define  ISDN_PRODUCT_HEADER_ID   0x15
#define   ANY_PRODUCT_HEADER_ID   0xFF

// comtrol_type defines(byte [14] of ethernet packet):
#define ASYNC_PRODUCT_HEADER_ID   0x55
#define  ISDN_PRODUCT_HEADER_ID   0x15
#define   ANY_PRODUCT_HEADER_ID   0xFF

//---- macro to see if mac-addresses match
#define mac_match(_addr1, _addr2) \
     ( (*((DWORD *)_addr1) == *((DWORD *)_addr2) ) && \
       (*((WORD *)(_addr1+4)) == *((WORD *)(_addr2+4)) ) )

//-- packet type
#define ADMIN_FRAME  1
#define ASYNC_FRAME  0x55

#define ADMIN_ID_BOOT     0
#define ADMIN_BOOT_PACKET 1
#define ADMIN_ID_QUERY    2
#define ADMIN_ID_REPLY    3
#define ADMIN_ID_LOOP     4
#define ADMIN_ID_RESET    5

int ProtocolOpen(void);
int NicMakeList(IN PUNICODE_STRING RegistryPath,
                int style);  // 0=nt3.51,4.0 1=nt5.0
int NicOpen(Nic *nic, IN PUNICODE_STRING NicName);
int NicClose(Nic *nic);
int NicProtocolClose(void);
  // int NicSend(Nic *nic, UCHAR *data, int length);
NDIS_STATUS NicSetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size);
NDIS_STATUS NicGetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size);
int nic_send_pkt(Nic *nic, BYTE *buf, int len);

extern BYTE broadcast_addr[6];
extern BYTE mac_zero_addr[6];
extern BYTE mac_bogus_addr[6];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\isr.c ===
/*-------------------------------------------------------------------
| isr.c - Interrupt(or Timer) Service Routine, RocketPort & VS.

1-21-99 fix broken EV_TXEMPTY events due to 1-18-99 spinlock changes.  kpb
1-18-99 implement better write spinlocking to avoid blue-screen
  with wait on tx option.
1-18-99 implement wait on tx option for VS.
9-24-98 add RING emulation.

Copyright 1993-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

// #define LOAD_TESTING
// #define SOFT_LOOP_BACK

// local prototypes
static BOOLEAN SerialPoll(void);
static void ServiceRocket(PSERIAL_DEVICE_EXTENSION extension);
static void ServiceVS(PSERIAL_DEVICE_EXTENSION extension);
static void RocketRead(PSERIAL_DEVICE_EXTENSION extension);
static void VSRead(PSERIAL_DEVICE_EXTENSION extension);
static void RocketRefresh(void);
static void ring_check(PSERIAL_DEVICE_EXTENSION extension,
                BYTE *data,
                int len);

#ifdef S_VS
#define USE_MEMCHR_SCAN
#ifdef USE_MEMCHR_SCAN
#define search_match(buf, cnt, chr) \
   (memchr(buf, chr, cnt) != NULL)
#else
static int search_match(BYTE *buf, int count, BYTE eventchar);
#endif
#endif

#ifdef S_RK
/*---------------------------------------------------------------------------
  Function : SerialISR
  Purpose:   This is the Interrupt Service Routine for RocketPort.
  Call:      SerialISR(InterruptObject,Context)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             Context: Pointer to the extensionst Packet
  Return:   STATUS_SUCCESS: always
  Comments: This function is the device driver ISR entry point.  
            The interrupt from the first active board is used to poll the
            ports for any work to be done.
|---------------------------------------------------------------------------*/
BOOLEAN SerialISR(
         IN PKINTERRUPT InterruptObject,
         IN PVOID Context)
{
   CONTROLLER_T *CtlP;
   unsigned char CtlInt;               /* controller interrupt status */
//static int trace_cnt = 0;
//   ++trace_cnt;
//  if (trace_cnt < 5)
//   {
//     {
//       char str[20];
//       Sprintf(str, "isr trace:%d\n", trace_cnt);
//       q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
//       // showed IRQL:2, ms doc says should be at DISPATCH_LEVEL
//     }
//   }

   CtlP = Driver.irq_ext->CtlP;  // &sController[0];
   if (CtlP->BusType == Isa)
   {
      CtlInt = sGetControllerIntStatus(CtlP);
   }
   else if (CtlP->BusType == PCIBus)
   {
      CtlInt = sPCIGetControllerIntStatus(CtlP);
      if ((CtlInt & PCI_PER_INT_STATUS) ==0)
        return FALSE;  // Not our Interupt PCI devices share interrupts
   }
   SerialPoll();

   if (CtlP->BusType == Isa)
   {
     sControllerEOI(CtlP);
   }
   else if (CtlP->BusType == PCIBus)
     sPCIControllerEOI(CtlP);

   return TRUE;
}
#endif

/*---------------------------------------------------------------------------
  Function : TimerDpc
  Purpose:   This is the Timer routine, alternative to interrupts for polling.
  Call:      SerialTimerDpc(InterruptObject,Context)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             Context: Pointer to the extensionst Packet
  Return:   STATUS_SUCCESS: always
|---------------------------------------------------------------------------*/
VOID TimerDpc(
      IN PKDPC Dpc,
      IN PVOID DeferredContext,
      IN PVOID SystemContext1,
      IN PVOID SystemContext2)
{
 KIRQL OldIrql;

#ifdef USE_SYNC_LOCKS
   KeAcquireSpinLock(&Driver.TimerLock, &OldIrql);
#endif

   SerialPoll();  // poll the rocketport for work to do

#ifdef USE_SYNC_LOCKS
   KeReleaseSpinLock(&Driver.TimerLock, OldIrql );
#endif

   // setup the Timer again.
   KeSetTimer(&Driver.PollTimer,
              Driver.PollIntervalTime,
              &Driver.TimerDpc);

   return;
}

/*---------------------------------------------------------------------------
  Function : SerialPoll
  Purpose:   This is called from ISR or Timer routine.  Common routine to
             periodically service the rocketport card.
  Return:    FALSE if not our interrupt(sharing allowed so causes the
             OS to pass on to next handler(if present).
             TRUE if it was our interrupt.  Return value does not matter
             if running off from Kernal TIMER.
|---------------------------------------------------------------------------*/
static BOOLEAN SerialPoll(void)
{
   PSERIAL_DEVICE_EXTENSION extension;
   PSERIAL_DEVICE_EXTENSION board_ext;

  // periodically we will re-calculate the timer base of NT.
  // we do it periodically, so that we don't waste a bunch of
  // CPU time, we only do it every 128 ticks..
  // We use this information so that our timers can have a
  // valid tick-base.  The timers could do these system calls
  // everytime, but this would get expense CPU wise, so we
  // calculate the basic tick rate in milliseconds so that
  // timer routines can do something simple like
  //   ticktime += msTickBase
  ++Driver.TickBaseCnt;
  if (Driver.TickBaseCnt > 128)
  {
    ULONG msBase;
  
    Driver.TickBaseCnt = 0;
    KeQuerySystemTime(&Driver.IsrSysTime);
    msBase = (ULONG)(Driver.IsrSysTime.QuadPart - Driver.LastIsrSysTime.QuadPart);
      // msBase now has 100ns ticks since last time we did this(128 ticks ago)
    msBase = (msBase / 128);
      // now msBase has the average 100ns time for 1 of our ISR ticks.
      // covert this to 100us units
    msBase = (msBase / 1000);
    if (msBase < 10)  // make at least 1ms
      msBase = 10;
    if (msBase > 200)  // ensure it is less than 20ms
      msBase = 200;
  
    // store it for timer use
    Driver.Tick100usBase = msBase;
    Driver.LastIsrSysTime.QuadPart = Driver.IsrSysTime.QuadPart;
  }

  ++Driver.PollCnt;

  if (Driver.Stop_Poll)  // flag to stop poll access
     return TRUE;  // signal it was our interrupt

  if ((Driver.PollCnt & 0x7f) == 0)  // every 128 ticks(about once a sec)
  {
    RocketRefresh();  // general background activity
  }

#ifdef LOAD_TESTING
   if (Driver.load_testing != 0)
   {
     unsigned int i,j;
     for (j=1000; j<Driver.load_testing; j++)
     {
       for (i=0; i<10000; i++)
       {
         //ustat = sGetModemStatus(extension->ChP);
         ustat = i+1;
       }
     }
   }
#endif

  // main poll service loop, service each board...
  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
    if ((!board_ext->FdoStarted) || (!board_ext->config->HardwareStarted))
    {
       board_ext = board_ext->board_ext;  // next in chain
       continue;         // Check next port on this board
    }

#ifdef S_VS
    if (board_ext->pm->state == ST_ACTIVE)
    {
      port_poll(board_ext->pm);  // poll x times per second
      hdlc_poll(board_ext->hd);
    }
    else
    {
      port_state_handler(board_ext->pm);
    }
#endif

    // main poll service loop, service each board...
    extension = board_ext->port_ext;
    while (extension != NULL)
    {
            // If device not open, don't do anything
      if ( !extension->DeviceIsOpen )
      {
         extension = extension->port_ext;  // next in chain
         continue;         // Check next port on this board
      }

#ifdef S_RK
      ServiceRocket(extension);
#else
      ServiceVS(extension);
#endif

      extension = extension->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;  // next in chain
  }  // while board extension

  return TRUE;  // signal it was our interrupt
}

#ifdef S_VS
/*---------------------------------------------------------------------------
  ServiceVS - Service the VS virtual hardware(queues, nic handling..)
|---------------------------------------------------------------------------*/
static void ServiceVS(PSERIAL_DEVICE_EXTENSION extension)
{
  SerPort *sp;
  ULONG wCount;
  int wrote_some_data;

  sp = extension->Port;

#ifdef SOFT_LOOP_BACK
  if (sp->mcr_value & MCR_LOOP_SET_ON)
  {
int room, out_cnt, wrap_cnt;
Queue *qin, *qout;
    //--------- Do a simple loopback emulation
    if (!q_empty(&sp->QOut))  // if output queue has data
    {
      qin = &sp->QIn;
      qout = &sp->QOut;
      room = q_room(qin);  // chk if room to dump it in
      out_cnt = q_count(qout);
      if (out_cnt > room)
          out_cnt = room;
      if (out_cnt > (int)(extension->BaudRate / 1000))  // assume 10ms tick
      {
        out_cnt = (int)(extension->BaudRate / 1000);
      }

      if (out_cnt != 0)
      {
        if (q_room_put_till_wrap(qin) < out_cnt)  // need a two part move
        {
          wrap_cnt = q_room_put_till_wrap(qin);
                      // read in the data to the buffer, first block
          q_get(qout, &qin->QBase[qin->QPut], wrap_cnt);
  
                    // read in the data to the buffer, second block
          q_get(qout, qin->QBase, out_cnt - wrap_cnt);
        }
        else  // single move will do, no wrap
        {
                   // read in the data to the buffer, 1 block
          q_get(qout, &qin->QBase[qin->QPut], out_cnt);
        }
        q_putted(qin, out_cnt);  // update queue indexes
      }  // room to put it
    }  // output q not empty
  }
#endif

  //////////////////////////////////////
  // If there is any data in the Rx FIFO
  // Read the data and do error checking
  if(!q_empty(&extension->Port->QIn))
     VSRead(extension);

  if (extension->port_config->RingEmulate)
  {
    if (extension->ring_timer != 0)  // RI on
    {
      --extension->ring_timer;
      if (extension->ring_timer != 0)  // RI on
         sp->msr_value |= MSR_RING_ON;
      else
      {
        //MyKdPrint(D_Test,("RING OFF!\n"))
        sp->msr_value &= ~MSR_RING_ON;
      }
    }
  }

  if (sp->old_msr_value != sp->msr_value)  // delta change bits
  {
    WORD diff, ModemStatus;

    diff = sp->old_msr_value ^ sp->msr_value;
    sp->old_msr_value = sp->msr_value;

    if (Driver.TraceOptions & 8)  // trace output data
    {
      char str[20];
      Sprintf(str, "msr:%x\n", sp->msr_value);
      q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
    }

    // Check on modem changes and update the modem status
    if (diff & (MSR_CD_ON | MSR_CTS_ON | MSR_RING_ON | MSR_DSR_ON | MSR_TX_FLOWED_OFF))
    {
      // make a bit set that ioctl can use in report
      ModemStatus = 0;
      if (sp->msr_value & MSR_CTS_ON)
      {
        ModemStatus |= SERIAL_CTS_STATE;
        if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
          extension->TXHolding &= ~SERIAL_TX_CTS;   // set holding
      }
      else
      {
        if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
          extension->TXHolding |= SERIAL_TX_CTS;   // set holding
      }

      if (sp->msr_value & MSR_DSR_ON)
      {
        ModemStatus |= SERIAL_DSR_STATE;
        if (extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
          extension->TXHolding &= ~SERIAL_TX_DSR;   // set holding
      }
      else
      {
        if (extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
          extension->TXHolding |= SERIAL_TX_DSR;   // set holding
      }

      if (sp->msr_value & MSR_RING_ON)
             ModemStatus |=  SERIAL_RI_STATE;

      if (sp->msr_value & MSR_CD_ON)
      {
        ModemStatus |= SERIAL_DCD_STATE;
        if (extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
          extension->TXHolding &= ~SERIAL_TX_DCD;   // set holding
      }
      else
      {
        if (extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
          extension->TXHolding |= SERIAL_TX_DCD;   // set holding
      }

      if (sp->msr_value & MSR_TX_FLOWED_OFF)
      {
        // handle holding detection if xon,xoff tx control activated
        if (extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
        {
          extension->TXHolding |= SERIAL_TX_XOFF; // holding
        }
      }
      else if (extension->TXHolding & SERIAL_TX_XOFF)
      {
        extension->TXHolding &= ~SERIAL_TX_XOFF; // not holding
      }

      extension->ModemStatus = (ULONG) ModemStatus;

      // following is for built in NT virtual 16450 uart support
      // virtual uart depends on escape commands in data stream to
      // detect modem-signal changes.
      if (extension->escapechar != 0)
      {
        UCHAR msr;
        if (q_room(&extension->RxQ) > 2)
        {
          q_put_one(&extension->RxQ, extension->escapechar);
          q_put_one(&extension->RxQ, SERIAL_LSRMST_MST);

          msr = (UCHAR)extension->ModemStatus;
          if (diff & MSR_CD_ON) msr |= 8;  // SERIAL_MSR_DDCD
          if (diff & MSR_RING_ON) msr |= 4;  // SERIAL_MSR_TERI
          if (diff & MSR_DSR_ON) msr |= 2; // SERIAL_MSR_DDSR
          if (diff & MSR_CTS_ON) msr |= 1; // SERIAL_MSR_DCTS
          q_put_one(&extension->RxQ, msr);
        }  // q_room
      } // if escapechar

      // Check if there are any modem events in the WaitMask
      if (extension->IsrWaitMask & ( SERIAL_EV_RING |
                                     SERIAL_EV_CTS |
                                     SERIAL_EV_DSR | 
                                     SERIAL_EV_RLSD ))
      {
        if( (extension->IsrWaitMask & SERIAL_EV_RING) &&
            (diff & MSR_RING_ON) )
        {  extension->HistoryMask |= SERIAL_EV_RING;
        }
        if ((extension->IsrWaitMask & SERIAL_EV_CTS) &&
            (diff & MSR_CTS_ON) )
        {  extension->HistoryMask |= SERIAL_EV_CTS;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_DSR) &&
            (diff & MSR_DSR_ON) )
        {  extension->HistoryMask |= SERIAL_EV_DSR;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_RLSD) &&
            (diff & MSR_CD_ON) )
        {  extension->HistoryMask |= SERIAL_EV_RLSD;
        }
      }  // isrwaitmask
    }  // diff
  } // old_msr != msr

  ////////////////////////////////////////////////////////////
  // At this point, all receive events should be chalked up.
  // Some events have been checked in VSRead()
  // Any Tx related WaitMask events will be reported in Tx Dpc

  // Abort all pending reads and writes if an error and ERROR_ABORT
  if( (extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      (extension->ErrorWord) )
  {
     KeInsertQueueDpc(&extension->CommErrorDpc,NULL,NULL);
  }

  // Tell the app about any Wait events that have occurred if needed
  if (extension->WaitIsISRs && extension->HistoryMask)
  {   

     *extension->IrpMaskLocation = extension->HistoryMask;

     // Done with these
     extension->WaitIsISRs = 0;
     extension->HistoryMask = 0;
     extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

     KeInsertQueueDpc(&extension->CommWaitDpc,NULL,NULL);
  }

  //-------- check for data to move from input queue to irp-buffer
  if (extension->ReadPending &&  // we are given control to fill
      extension->NumberNeededForRead &&  // more to be filled
      extension->CurrentReadIrp) // rug not pulled out from our feet
  {
    if (extension->RxQ.QPut != extension->RxQ.QGet)  // not empty
    {
      // move data from input queue to IRP buffer.
      extension->CountOnLastRead |=
                    SerialGetCharsFromIntBuffer(extension);

      if (extension->NumberNeededForRead == 0) // IRP complete!
      {
         extension->CurrentReadIrp->IoStatus.Information =
             IoGetCurrentIrpStackLocation(
                 extension->CurrentReadIrp
                 )->Parameters.Read.Length;
         extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

         // We're finished with this read
         extension->ReadPending = FALSE;

         KeInsertQueueDpc( &extension->CompleteReadDpc, NULL, NULL );
      }  // irp complete
    }  // more data to read out of input queue
  } // end of Read completion

  wrote_some_data = 0;
  if (extension->WriteBelongsToIsr == 1)  // its ours to process
  {
    // own the cur write irp, have data to write
    if (extension->WriteLength)
    {
       wrote_some_data = 1;
       extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty
                            // Send it all ,WriteTxBlk will chk fifo
       wCount = q_put( &extension->Port->QOut,
                  (PUCHAR)((extension->CurrentWriteIrp)->AssociatedIrp.SystemBuffer)+ 
                    (extension->CurrentWriteIrp)->IoStatus.Information,
                    extension->WriteLength);
  
       extension->OurStats.TransmittedCount += wCount;
       extension->WriteLength -= wCount;
       (extension->CurrentWriteIrp)->IoStatus.Information += wCount;
   
       if(!extension->WriteLength)//No more to write Close the DPC call
       {
         if (!extension->port_config->WaitOnTx)
         {
           extension->WriteBelongsToIsr = 2;
           KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
         }
       }
    } // if (extension->WriteLength)  // data to write
  }

  if (!wrote_some_data)
  {
    if (extension->ISR_Flags & TX_NOT_EMPTY)
    {
      //----- check for EV_TXEMPTY condition
      // and no pending writes
      // check to see if tx-fifo is empty
      if ((q_empty(&extension->Port->QOut)) &&
          (PortGetTxCntRemote(extension->Port) == 0))
      {
        if (IsListEmpty(&extension->WriteQueue))
        {
          extension->ISR_Flags &= ~TX_NOT_EMPTY;

          // do we have an ev_txempty thing to take care of?
          if (extension->IrpMaskLocation &&
             (extension->IsrWaitMask & SERIAL_EV_TXEMPTY) )
          {
            // app has wait irp pending
            if (extension->CurrentWaitIrp)
            {
              extension->HistoryMask |= SERIAL_EV_TXEMPTY;
            }
          }
        }  // no more write irps queued up

          // see if we need to finish waitontx write irp
        if (extension->port_config->WaitOnTx)
        {
          if (extension->WriteBelongsToIsr == 1)  // its ours to process
          {
             extension->WriteBelongsToIsr = 2;
             KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
          }
        }
      }   // tx fifo is empty
    }  // TX_NOT_EMPTY 
  }  // !wrote_some_data

      // Tell the app about any Wait events that have occurred if needed
  if (extension->WaitIsISRs && extension->HistoryMask)
  {   
#ifdef COMMENT_OUT
    if (Driver.TraceOptions & 8)  // trace output data
    {
      char str[20];
      Sprintf(str, "ISR Event:%xH\n", extension->HistoryMask);
      q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
    }
#endif
    *extension->IrpMaskLocation = extension->HistoryMask;

    // Done with these
    extension->WaitIsISRs = 0;
    extension->HistoryMask = 0;
    extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

    KeInsertQueueDpc(&extension->CommWaitDpc,NULL,NULL);
  }
}
#endif

#ifdef S_RK
/*---------------------------------------------------------------------------
  ServiceRocket - Handle the RocketPort hardware service
|---------------------------------------------------------------------------*/
static void ServiceRocket(PSERIAL_DEVICE_EXTENSION extension)
{
  ULONG ustat;
  ULONG wCount;
  int wrote_some_data;

  ustat = sGetChanIntID(extension->ChP);

  //////////////////////////////////////
  // If there is any data in the Rx FIFO
  // Read the data and do error checking
  if (ustat & RXF_TRIG)
  {
       RocketRead(extension);
  }

  // Check on modem changes and update the modem status
  if (ustat & (DELTA_CD|DELTA_CTS|DELTA_DSR))
  {
     // Read and update the modem status in the extension
     SetExtensionModemStatus(extension);
  }

  // handle RPortPlus RI signal
  if (extension->board_ext->config->IsRocketPortPlus)
  {
    if (sGetRPlusModemRI(extension->ChP) != 0)  // RI on
    {
      extension->ModemStatus |=  SERIAL_RI_STATE;
    }
    else
    {
      extension->ModemStatus &= ~SERIAL_RI_STATE;
    }
  }

#ifdef RING_FAKE
    if (extension->port_config->RingEmulate)
    {
      if (extension->ring_timer != 0)  // RI on
      {
        --extension->ring_timer;
        if (extension->ring_timer != 0)  // RI on
          extension->ModemStatus |=  SERIAL_RI_STATE;
        else
          extension->ModemStatus &= ~SERIAL_RI_STATE;
      }
    }
#endif

  if (extension->EventModemStatus != extension->ModemStatus)
  {
     // xor to show changed bits
     ustat = extension->EventModemStatus ^ extension->ModemStatus;

     // update change
     extension->EventModemStatus = extension->ModemStatus;

     // following is for built in NT virtual 16450 uart support
     // virtual uart depends on escape commands in data stream to
     // detect modem-signal changes.
     if (extension->escapechar != 0)
     {
       UCHAR msr;
       // we are assuming we have room to put the following!
       if (q_room(&extension->RxQ) > 2)
       {
         q_put_one(&extension->RxQ, extension->escapechar);
         q_put_one(&extension->RxQ, SERIAL_LSRMST_MST);

         msr = (UCHAR)extension->ModemStatus;
         if (ustat & SERIAL_DCD_STATE) msr |= 8; // SERIAL_MSR_DDCD
         if (ustat & SERIAL_RI_STATE)  msr |= 4; // SERIAL_MSR_TERI
         if (ustat & SERIAL_DSR_STATE) msr |= 2; // SERIAL_MSR_DDSR
         if (ustat & SERIAL_CTS_STATE) msr |= 1; // SERIAL_MSR_DCTS
         q_put_one(&extension->RxQ, msr);
       }
     }

     // Check if there are any modem events in the WaitMask
     if(extension->IsrWaitMask & ( SERIAL_EV_RING |
                                   SERIAL_EV_CTS |
                                   SERIAL_EV_DSR | 
                                   SERIAL_EV_RLSD )
       )
     {
        if( (extension->IsrWaitMask & SERIAL_EV_RING) &&
            (ustat & SERIAL_RI_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_RING;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_CTS) &&
            (ustat & SERIAL_CTS_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_CTS;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_DSR) &&
            (ustat & SERIAL_DSR_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_DSR;
        }
        if( (extension->IsrWaitMask & SERIAL_EV_RLSD) &&
            (ustat & SERIAL_DCD_STATE) )
        {  extension->HistoryMask |= SERIAL_EV_RLSD;
        }
     }
  } // end if modem-control detect change

  ////////////////////////////////////////////////////////////
  // At this point, all receive events should be chalked up.
  // Some events have been checked in RocketRead()
  // Any Tx related WaitMask events will be reported in Tx Dpc

  // Abort all pending reads and writes if an error and ERROR_ABORT
  if( (extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      (extension->ErrorWord) )
  {
     KeInsertQueueDpc(&extension->CommErrorDpc,NULL,NULL);
  }

  //-------- check for data to move from input queue to irp-buffer
  if (extension->ReadPending &&  // we are given control to fill
      extension->NumberNeededForRead &&  // more to be filled
      extension->CurrentReadIrp) // rug not pulled out from our feet
  {
    if (extension->RxQ.QPut != extension->RxQ.QGet)  // not empty
    {
      // move data from input queue to IRP buffer.
      extension->CountOnLastRead |=
                    SerialGetCharsFromIntBuffer(extension);

      if (extension->NumberNeededForRead == 0) // IRP complete!
      {
         extension->CurrentReadIrp->IoStatus.Information =
             IoGetCurrentIrpStackLocation(
                 extension->CurrentReadIrp
                 )->Parameters.Read.Length;
         extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

         // We're finished with this read
         extension->ReadPending = FALSE;

         KeInsertQueueDpc( &extension->CompleteReadDpc, NULL, NULL );
      }  // irp complete
    }  // more data to read out of input queue
  } // end of Read completion

  wrote_some_data = 0;

  //-------- do BREAK handling
  if ( extension->TXHolding & SERIAL_TX_BREAK )
  {
    // Check if we need to start the break
    if(extension->DevStatus & COM_REQUEST_BREAK)
    {
      // Make sure Transmitter is empty before slamming BREAK
      // Check the bit twice in case of time between buf and txshr load
      if( (sGetChanStatusLo(extension->ChP) & TXSHRMT) &&
          (sGetChanStatusLo(extension->ChP) & TXSHRMT) )
      {
          sSendBreak(extension->ChP);
          extension->DevStatus &= ~COM_REQUEST_BREAK;
      }
    }
  }
  else if (extension->WriteBelongsToIsr == 1)  // its ours to process
  {
    //----- Not holding due to BREAK so try to enqueue Tx data
    if (extension->WriteLength)
    {
       wrote_some_data = 1;
       if (extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
       {
         if ((extension->DTRRTSStatus & SERIAL_RTS_STATE) == 0)
         {
           sSetRTS(extension->ChP);
           extension->DTRRTSStatus |= SERIAL_RTS_STATE;
         }
       }

       extension->ISR_Flags |= TX_NOT_EMPTY;  // use to detect fifo empty

                            // Send it all ,WriteTxBlk will chk fifo
       wCount = sWriteTxBlk( extension->ChP,
                  (PUCHAR)((extension->CurrentWriteIrp)->AssociatedIrp.SystemBuffer)+ 
                    (extension->CurrentWriteIrp)->IoStatus.Information,
                    extension->WriteLength);
  
       extension->OurStats.TransmittedCount += wCount;
       extension->WriteLength -= wCount;
       (extension->CurrentWriteIrp)->IoStatus.Information += wCount;
   
       if(!extension->WriteLength)//No more to write Close the DPC call
       {
         if (!extension->port_config->WaitOnTx)
         {
           extension->WriteBelongsToIsr = 2;
           KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
         }
       }
    } // if (extension->WriteLength)  // data to write
  }  // end if !TXholding and WriteBelongsToIsr == 1

  if (!wrote_some_data)
  {
    if (extension->ISR_Flags & TX_NOT_EMPTY)
    {
      //----- check for EV_TXEMPTY condition
      // and no pending writes
      // check to see if tx-fifo truely empty
      // need to check twice due to hardware quirks
      if ( (sGetTxCnt(extension->ChP) == 0) &&
           (sGetChanStatusLo(extension->ChP) & TXSHRMT) )
      {
        if (IsListEmpty(&extension->WriteQueue))
        {
          extension->ISR_Flags &= ~TX_NOT_EMPTY;

          // do we have an ev_txempty thing to take care of?
          if (extension->IrpMaskLocation &&
             (extension->IsrWaitMask & SERIAL_EV_TXEMPTY) )
          {
            // app has wait irp pending
            if (extension->CurrentWaitIrp)
            {
              extension->HistoryMask |= SERIAL_EV_TXEMPTY;
            }
          }

          if (extension->Option & OPTION_RS485_SOFTWARE_TOGGLE)
          {
            if ((extension->DTRRTSStatus & SERIAL_RTS_STATE) != 0)
            {
              extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
              sClrRTS(extension->ChP);
            }
          }
        }  // no more write irps queued up

          // see if we need to finish waitontx write irp
        if (extension->port_config->WaitOnTx)
        {
          if (extension->WriteBelongsToIsr == 1)  // its ours to process
          {
            extension->WriteBelongsToIsr = 2;
            KeInsertQueueDpc( &extension->CompleteWriteDpc, NULL, NULL );
          }
        }
      }   // tx fifo went empty
    }  // TX_NOT_EMPTY 
  }  // !wrote_some_data

      // Tell the app about any Wait events that have occurred if needed
  if (extension->WaitIsISRs && extension->HistoryMask)
  {   
#ifdef COMMENT_OUT
    if (Driver.TraceOptions & 8)  // trace output data
    {
      char str[20];
      Sprintf(str, "ISR Event:%xH\n", extension->HistoryMask);
      q_put(&Driver.DebugQ, (BYTE *) str, strlen(str));
    }
#endif
    *extension->IrpMaskLocation = extension->HistoryMask;

    // Done with these
    extension->WaitIsISRs = 0;
    //extension->IrpMaskLocation = NULL;
    extension->HistoryMask = 0;
    extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

    KeInsertQueueDpc(&extension->CommWaitDpc,NULL,NULL);
  }
}

/*-----------------------------------------------------------------------------
  Function : RocketRead
  Purpose:   Moves data from Rocket's Rx FIFO to RxIn of dev's extension
  NOTES:     The error checking assumes that if no replacement is required,
             the errored chars are ignored.
             The RXMATCH feature is used for EventChar detection. 
  Return:    None
|-----------------------------------------------------------------------------*/
static void RocketRead(PSERIAL_DEVICE_EXTENSION extension)
{
   int WrapCount;       // Number of bytes in wrap (2 stage copy)
   int RxFree;
   int sCount;
   unsigned int ChanStatus;
   unsigned int StatusWord;
   int OriginalCount;  // Used to determine if Rx event occurred

   // Save off the original Rx buff ptr. Test later for Rx event
   OriginalCount = extension->RxQ.QPut;

   // Get count before reading status
   // NOTE: Should always have a count if we entered this code
   sCount = sGetRxCnt(extension->ChP);

   if (sCount == 0)
   {
     //GTrace("Error, RXF_TRIG lied");
     return;
   }

   // Have count, now get status
   ChanStatus = sGetChanStatus(extension->ChP) &
                     (STATMODE | RXFOVERFL | RXBREAK |
                      RXFRAME |  RX2MATCH | RX1MATCH | RXPARITY);

   // Make sure we're in statmode if errors are pending in the FIFO
   if (ChanStatus)
   {
     if (ChanStatus & RX1MATCH)  // Must signal Rx Match immediately
     {
       if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
           extension->HistoryMask |= SERIAL_EV_RXFLAG;
       ChanStatus &= ~RX1MATCH;
     }
     if (ChanStatus)
       sEnRxStatusMode(extension->ChP);
   }

   // See how much space we have in RxBuf (host side buffer)
   RxFree = q_room(&extension->RxQ);


   if (RxFree > 20)  // plenty of space in RX queue
   {
      RxFree -= 20;  // leave some space for virtual insertion stuff
      extension->ReadByIsr++;  // Increment statistics Read flag

      //------ Adjust count to maximum we can put in RxIn buffer
      if (RxFree < sCount)
         sCount = RxFree;
   }
   else // no more room in server buffer input queue
   {
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_RX80FULL);

      // No room in host side buffer, only do the software flow ctl check

      // check for overflow
      if (ChanStatus & RXFOVERFL)
      {
        // extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
        extension->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
        extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
        ++extension->OurStats.BufferOverrunErrorCount;
      }

      goto FlowControlCheck;
   }

   //--------------------------- Attempt to read any pending data
   // ChanStatus indicates any pending errors or matches
   if (ChanStatus)
   {
      // Loop on reading Rocket FIFO
      // sCount represents Rocket data, RxFree represents host buffer
      while(sCount)
      {
         // Get stat byte and data
         StatusWord = sReadRxWord( sGetTxRxDataIO(extension->ChP));
         sCount--;
         ++extension->OurStats.ReceivedCount;       // keep status

         switch(StatusWord & (STMPARITYH | STMFRAMEH | STMBREAKH) )
         {
            case STMPARITYH:
            {
               if (extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
               {
                   q_put_one(&extension->RxQ,
                             extension->SpecialChars.ErrorChar);
               }
               else  // queue the character received(add 12-03-96)
               {
                   q_put_one(&extension->RxQ, (UCHAR)StatusWord);
               }

               extension->ErrorWord |= SERIAL_ERROR_PARITY;
               extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
               ++extension->OurStats.ParityErrorCount;
               break;
            }

            case STMFRAMEH:
            {
               if (extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
               {
                 q_put_one(&extension->RxQ,
                             extension->SpecialChars.ErrorChar);
               }
               else  // queue the character received(add 12-03-96) 
               {
                 q_put_one(&extension->RxQ, (UCHAR)StatusWord);
               }

               extension->ErrorWord |= SERIAL_ERROR_FRAMING;
               extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
               ++extension->OurStats.FrameErrorCount;
               break;
            }

            // PARITY can be set along with BREAK, BREAK overrides PARITY
            case ( STMBREAKH | STMPARITYH ):
            case STMBREAKH:
            {
               if (extension->HandFlow.FlowReplace & SERIAL_BREAK_CHAR)
               {
                 q_put_one(&extension->RxQ,
                           extension->SpecialChars.BreakChar);
               }
               extension->ErrorWord |= SERIAL_ERROR_BREAK;
               extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_BREAK);
               break;
            }

            default:
            {
               if (extension->TXHolding & ST_XOFF_FAKE)
               {
                 if ((UCHAR)StatusWord == extension->SpecialChars.XonChar)
                 {
                   extension->TXHolding &= ~ST_XOFF_FAKE;
                   extension->TXHolding &= ~SERIAL_TX_XOFF;
                   sEnTransmit(extension->ChP); // Start up the transmitter
                   sDisRxCompare2(extension->ChP);  // turn off match
                   sEnTxSoftFlowCtl(extension->ChP);  // turn on Tx software flow control

                   // override an actual XOFF from remote
                   sClrTxXOFF(extension->ChP);
                 }
                 else
                   { q_put_one(&extension->RxQ, (UCHAR)StatusWord); } // queue normal char
               }
               else
                 { q_put_one(&extension->RxQ, (UCHAR)StatusWord); } // queue normal char


               if (extension->escapechar != 0)
               {
                 if ((UCHAR)StatusWord == extension->escapechar)
                 {
                   // Modem status escape convention for virtual port
                   // support, escape the escape char.
                   { q_put_one(&extension->RxQ, SERIAL_LSRMST_ESCAPE); }
                 }
               }
            }
         } // end switch

         //------ check for near overflow condition due to insertions
         if (q_room(&extension->RxQ) < 10)
           sCount = 0;  // stop reading hardware!
      } // end while sCount

      //--- if rx-data all read down, turn off slow status mode
      if(!(sGetChanStatusLo(extension->ChP) & RDA))
      {
         sDisRxStatusMode(extension->ChP);
      }

      // Overflow is reported immediately, statmode can't do it properly
      if (ChanStatus & RXFOVERFL)
      {   extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
          extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
          ++extension->OurStats.SerialOverrunErrorCount;
      }
   } // end if ChanStatus
   else
   {
      //--------------------------------------------------------
      // No pending errors or matches in the FIFO, read the data normally (fast)
      // Check for wrap condition first

      WrapCount = q_room_put_till_wrap(&extension->RxQ);
      if (sCount > WrapCount)  // then 2 moves required
      {
        // This will require a wrap
        sReadRxBlk(extension->ChP,
                   extension->RxQ.QBase + extension->RxQ.QPut,
                   WrapCount);

        // Do the second copy...
        sReadRxBlk(extension->ChP,
                   extension->RxQ.QBase,
                   sCount-WrapCount);
#ifdef RING_FAKE
        if (extension->port_config->RingEmulate)
        {
          if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
          {
            ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                      WrapCount);
            ring_check(extension, extension->RxQ.QBase,
                      sCount-WrapCount);
          }
        }
#endif
      }
      else  // only one move required
      {
        // no queue wrap required
        sReadRxBlk(extension->ChP,
                   extension->RxQ.QBase + extension->RxQ.QPut,
                   sCount);
#ifdef RING_FAKE
        if (extension->port_config->RingEmulate)
        {
          if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
          {
            ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                      sCount);
          }
        }
#endif
      }
      extension->RxQ.QPut = (extension->RxQ.QPut + sCount) % extension->RxQ.QSize;
      extension->OurStats.ReceivedCount += sCount;
   } // end fast read


FlowControlCheck:   ;

   ///////////////////////////////////////
   // Software and DTR input flow control checking
   if(  (extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) ||
        (extension->HandFlow.ControlHandShake & SERIAL_DTR_HANDSHAKE )
     )
   {  
      // check for flow control conditions
      if (extension->DevStatus & COM_RXFLOW_ON)
      {
         // do we need to stop Rx?
         if(sGetRxCnt(extension->ChP) >= RX_HIWATER)
         {
            if(extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
            {
               // send XOFF
               sWriteTxPrioByte(extension->ChP,
                                extension->SpecialChars.XoffChar);
               extension->DevStatus &= ~COM_RXFLOW_ON;
               extension->RXHolding |= SERIAL_RX_XOFF;
            }

            if(extension->HandFlow.ControlHandShake & SERIAL_DTR_HANDSHAKE)
            {
               // drop DTR
               sClrDTR(extension->ChP);
               extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
               extension->DevStatus &= ~COM_RXFLOW_ON;
               extension->RXHolding |= SERIAL_RX_DSR;
            }
         }
      }
      else // Rx flow is stopped
      {
         // can we resume Rx?
         if(sGetRxCnt(extension->ChP) <= RX_LOWATER)
         {
            if(extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
            {
               // send XON
               sWriteTxPrioByte(extension->ChP,
                                extension->SpecialChars.XonChar);
               extension->DevStatus |= COM_RXFLOW_ON;
               extension->RXHolding &= ~SERIAL_RX_XOFF;
            }

            if(extension->HandFlow.ControlHandShake & SERIAL_DTR_HANDSHAKE)
            {
               // raise DTR
               sSetDTR(extension->ChP);
               extension->DTRRTSStatus |= SERIAL_DTR_STATE;
               extension->DevStatus |= COM_RXFLOW_ON;
               extension->RXHolding &= ~SERIAL_RX_DSR;
            }
         }
      }
   } // end of software and DTR input flow control check

   // Should we mark a Rx event?
   if ( OriginalCount != extension->RxQ.QPut )
      extension->HistoryMask|=(extension->IsrWaitMask & SERIAL_EV_RXCHAR);
}
#endif

#ifdef RING_FAKE
/*------------------------------------------------------------------------------
  ring_check - scan the rx data for a modem "RING<CR>" or "2<CR>" string.
    If found, trigger a emulated hardware RING signal.
|------------------------------------------------------------------------------*/
static void ring_check(PSERIAL_DEVICE_EXTENSION extension,
                BYTE *data,
                int len)
{
 int i;

  for (i=0; i<len; i++)
  {
    switch (data[i])
    {
      case '2':
        if (len <= 2)
          extension->ring_char = '2';
        else extension->ring_char = 0;
      break;
      case 'R':
        extension->ring_char = 'R';
      break;
      case 'I':
        if (extension->ring_char == 'R')
          extension->ring_char = 'I';
        else extension->ring_char = 0;
      break;
      case 'N':
        if (extension->ring_char == 'I')
          extension->ring_char = 'N';
        else extension->ring_char = 0;
      break;
      case 'G':
        if (extension->ring_char == 'N')
          extension->ring_char = 'G';
        else extension->ring_char = 0;
      break;
      case 0xd:
        if ( (extension->ring_char == 'G') ||
             ((extension->ring_char == '2') && (len <= 2)) )
        {
          //MyKdPrint(D_Init,("RING!\n"))
          // OK, look s like the data stream says a "RING" took place.
          // so setup a timer which will cause a hardware RING to be made
          // set to .5 sec for 10ms scanrate, .05sec for 1ms scanrate
          extension->ring_timer = 50;  
        }
        extension->ring_char = 0;
      break;
      default:
        extension->ring_char = 0;
      break;
    }
  }
}
#endif

/*-----------------------------------------------------------------------------
  RocketRefresh - This runs every 255 ticks or so, in order to perform
    background activities.  We will go read the modem status, and update
  the ModemCtl field.  The monitor program reads this variable, and we
  don't want to waste time reading it too often, so we just update it
  occasionally here.
|-----------------------------------------------------------------------------*/
static void RocketRefresh(void)
{
   PSERIAL_DEVICE_EXTENSION extension;
   PSERIAL_DEVICE_EXTENSION board_ext;

#ifdef S_RK
  board_ext = Driver.board_ext;
  while (board_ext)
  {
    if ((!board_ext->FdoStarted) || (!board_ext->config->HardwareStarted))
    {
      board_ext = board_ext->board_ext;
      continue;
    }
    extension = board_ext->port_ext;
    while (extension)
    {
      // Read and update the modem status in the extension
      SetExtensionModemStatus(extension);
 
      extension = extension->port_ext;  // next in chain
    }  // while port extension
    board_ext = board_ext->board_ext;
  }  // while board extension
#endif

  debug_poll();  // handle turn off of debug on inactivity timeout
}

#ifdef S_VS
/*-----------------------------------------------------------------------------
  Function : VSRead
  Purpose:   Moves data from VS's Rx FIFO to RxIn of dev's extension
  NOTES:     The error checking assumes that if no replacement is required,
             the errored chars are ignored.
             The RXMATCH feature is used for EventChar detection. 
  Return:    None
|-----------------------------------------------------------------------------*/
static void VSRead(PSERIAL_DEVICE_EXTENSION extension)
{
   int WrapCount;       // Number of bytes in wrap (2 stage copy)
   int RxFree;
   int sCount;
   LONG OriginalCount;  // Used to determine if Rx event occurred

   // Save off the original Rx buff ptr. Test later for Rx event
   OriginalCount = extension->RxQ.QPut;

   // Get count before reading status
   // NOTE: Should always have a count if we entered this code
   sCount=PortGetRxCnt(extension->Port);

   if (sCount == 0)
   {
     //MyTrace("Error, RXF_TRIG lied");
     return;
   }

  // See how much space we have in RxBuf (host side buffer)
  RxFree = q_room(&extension->RxQ);

  // if no space in RxBuf, don't read from RocketPort
  if (RxFree > 20)  // plenty of space in RX queue
  {
     RxFree -= 20;  // leave some space for virtual insertion stuff
     extension->ReadByIsr++;  // Increment statistics Read flag

     //------ Adjust count to maximum we can put in RxIn buffer
     if (RxFree < sCount)
        sCount = RxFree;
  }
  else // no more room in server buffer input queue
  {
     extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_RX80FULL);

     // No room in host side buffer, only do the software flow ctl check

     // check for overflow
     if (extension->Port->esr_reg & ESR_OVERFLOW_ERROR)
     {
       // extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
       extension->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
       extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
       extension->Port->esr_reg = 0;  // reset to zero on read
       ++extension->OurStats.BufferOverrunErrorCount;
     }

     goto FlowControlCheck;
  }

   //------ report any rx error conditions.
  if (extension->Port->esr_reg)
  {
    if (extension->Port->esr_reg & ESR_OVERFLOW_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_OVERRUN;
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
      ++extension->OurStats.SerialOverrunErrorCount;
    }
    else if (extension->Port->esr_reg & ESR_BREAK_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_BREAK;
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_BREAK);
    }
    else if (extension->Port->esr_reg & ESR_FRAME_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_FRAMING;
      extension->HistoryMask |= (extension->IsrWaitMask & SERIAL_EV_ERR);
      ++extension->OurStats.FrameErrorCount;
    }
    else if (extension->Port->esr_reg & ESR_PARITY_ERROR)
    {
      extension->ErrorWord |= SERIAL_ERROR_PARITY;
      extension->HistoryMask |= (extension->IsrWaitMask&SERIAL_EV_ERR);
      ++extension->OurStats.ParityErrorCount;
    }
    extension->Port->esr_reg = 0;  // reset to zero on read
  }

  //--------------------------------------------------------
  // No pending errors or matches in the FIFO, read the data normally (fast)
  // Check for wrap condition first

  WrapCount = q_room_put_till_wrap(&extension->RxQ);
  if (sCount > WrapCount)  // then 2 moves required
  {
     q_get(&extension->Port->QIn,
                extension->RxQ.QBase + extension->RxQ.QPut,
                WrapCount);

     // Do the second copy...
     q_get(&extension->Port->QIn,
                extension->RxQ.QBase,
                sCount-WrapCount);
     if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
     {
       if (search_match(extension->RxQ.QBase + extension->RxQ.QPut,
                WrapCount,extension->SpecialChars.EventChar))
         extension->HistoryMask |= SERIAL_EV_RXFLAG;
       if (search_match(extension->RxQ.QBase,
                sCount-WrapCount,extension->SpecialChars.EventChar))
         extension->HistoryMask |= SERIAL_EV_RXFLAG;
     }

#ifdef RING_FAKE
     if (extension->port_config->RingEmulate)
     {
       if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
       {
         ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                   WrapCount);
         ring_check(extension, extension->RxQ.QBase,
                   sCount-WrapCount);
       }
     }
#endif
  }
  else  // only one move required
  {
     q_get(&extension->Port->QIn,
           extension->RxQ.QBase + extension->RxQ.QPut,
           sCount);
     if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
     {
       if (search_match(extension->RxQ.QBase + extension->RxQ.QPut,
                sCount,extension->SpecialChars.EventChar))
         extension->HistoryMask |= SERIAL_EV_RXFLAG;
     }

#ifdef RING_FAKE
     if (extension->port_config->RingEmulate)
     {
       if ((extension->ModemStatus & SERIAL_DCD_STATE) == 0) // if CD off
       {
         ring_check(extension, extension->RxQ.QBase + extension->RxQ.QPut,
                   sCount);
       }
     }
#endif
  }
  extension->RxQ.QPut = (extension->RxQ.QPut + sCount) % extension->RxQ.QSize;
  extension->OurStats.ReceivedCount += sCount;
  extension->Port->Status |= S_UPDATE_ROOM;
#ifdef NEW_Q
  extension->Port->nGetLocal += sCount;
#endif

FlowControlCheck:   ;

  //----- Should we mark a Rx event?
  if ( OriginalCount != extension->RxQ.QPut )
     extension->HistoryMask|=(extension->IsrWaitMask & SERIAL_EV_RXCHAR);
}

#ifndef USE_MEMCHR_SCAN
/*------------------------------------------------------------------
 search_match -
|------------------------------------------------------------------*/
static int search_match(BYTE *buf, int count, BYTE eventchar)
{
  int i;
  for (i=0; i<count; i++)
  {
    if (buf[i] == eventchar)
      return 1;  // found
  }
  return 0;  // not found
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\isr.h ===
//--- isr.h

BOOLEAN SerialISR(
         IN PKINTERRUPT InterruptObject,
         IN PVOID Context);

VOID TimerDpc(
      IN PKDPC Dpc,
      IN PVOID DeferredContext,
      IN PVOID SystemContext1,
      IN PVOID SystemContext2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\nic.c ===
/*----------------------------------------------------------------------
 nic.c - routines for protocol access to NIC card via upper edge NDIS
  routines.
Change History:
1-18-99 - avoid sending empty HDLC packet(ACK only) up stack.
4-10-98 - Allow for NDIS40 dynamic bind capability if available.
11-14-97 - Created a thread to retry opening NIC's req by NT5.0.  DCS
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"
#define DbgNicSet(n) {sz_modid[3] = nic->RefIndex + '0';}
#define Trace1(s,p1) GTrace1(D_Nic, sz_modid, s, p1)
#define TraceStr(s) GTrace(D_Nic, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)
static char *sz_modid = {"Nic#"};
static char *sz_modid_err = {"Error,Nic"};

#ifdef NT50
#define DO_AUTO_CONFIG 1
#endif

//---- local functions
static PSERIAL_DEVICE_EXTENSION need_mac_autoassign(void);

int NicOpenAdapter(Nic *nic, IN PUNICODE_STRING NicName);
NDIS_STATUS NicWaitForCompletion(Nic *nic);

#ifdef OLD_BINDING_GATHER
NTSTATUS PacketReadRegistry(
    IN  PWSTR              *MacDriverName,
    IN  PWSTR              *PacketDriverName,
    IN  PUNICODE_STRING     RegistryPath,
    IN  int style);  // 0=nt4.0 location, 1=nt5.0 location
NTSTATUS PacketQueryRegistryRoutine(
    IN PWSTR     ValueName,
    IN ULONG     ValueType,
    IN PVOID     ValueData,
    IN ULONG     ValueLength,
    IN PVOID     Context,
    IN PVOID     EntryContext);
#endif

VOID PacketRequestComplete(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS   Status);
VOID PacketSendComplete(
       IN NDIS_HANDLE   ProtocolBindingContext,
       IN PNDIS_PACKET  pPacket,
       IN NDIS_STATUS   Status);
NDIS_STATUS PacketReceiveIndicate (
    IN NDIS_HANDLE ProtocolBindingContext,
    IN NDIS_HANDLE MacReceiveContext,
    IN PVOID       HeaderBuffer,
    IN UINT        HeaderBufferSize,
    IN PVOID       LookAheadBuffer,
    IN UINT        LookAheadBufferSize,
    IN UINT        PacketSize);
VOID PacketTransferDataComplete (
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_PACKET  pPacket,
    IN NDIS_STATUS   Status,
    IN UINT          BytesTransfered);
VOID PacketOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus);
VOID PacketCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status);
VOID PacketResetComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status);
VOID PacketReceiveComplete(IN NDIS_HANDLE ProtocolBindingContext);
VOID PacketStatus(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN NDIS_STATUS   Status,
    IN PVOID         StatusBuffer,
    IN UINT          StatusBufferSize);
VOID PacketStatusComplete(IN NDIS_HANDLE  ProtocolBindingContext);

#ifdef TRY_DYNAMIC_BINDING
void PacketBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE  BindContext,
  IN  PNDIS_STRING DeviceName,
  IN  PVOID SystemSpecific1,
  IN  PVOID SystemSpecific2);
VOID PacketUnBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE ProtocolBindingContext,
  IN  NDIS_HANDLE  UnbindContext);
#endif

VOID GotOurPkt(Nic *nic);
void eth_rx_async(Nic *nic);
void eth_rx_admin(Nic *nic, BYTE *rx, BYTE *pkt_hdr, int len, int server);
Hdlc *find_hdlc_handle(BYTE *rx);
static int nic_handle_to_index(Nic *nic);

BYTE broadcast_addr[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
BYTE mac_zero_addr[6] = {0,0,0,0,0,0};
BYTE mac_bogus_addr[6] = {0,0xc0,0x4e,0,0,0};
/*----------------------------------------------------------------------
 ProtocolOpen -
|----------------------------------------------------------------------*/
int ProtocolOpen(void)
{
  NTSTATUS Status = STATUS_SUCCESS;
  NDIS_PROTOCOL_CHARACTERISTICS  ProtocolChar;
  NDIS_STRING ProtoName = NDIS_STRING_CONST("VSLinka");
  int i;


  MyKdPrint(D_Init,("Proto Open\n"))
  if (Driver.NdisProtocolHandle == NULL)
  {
    MyKdPrint(D_Init,("P1\n"))
    RtlZeroMemory(&ProtocolChar,sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    ProtocolChar.MajorNdisVersion            = 4;
    ProtocolChar.MinorNdisVersion            = 0;
    ProtocolChar.Reserved                    = 0;
    ProtocolChar.OpenAdapterCompleteHandler  = PacketOpenAdapterComplete;
    ProtocolChar.CloseAdapterCompleteHandler = PacketCloseAdapterComplete;
    ProtocolChar.SendCompleteHandler         = PacketSendComplete;
    ProtocolChar.TransferDataCompleteHandler = PacketTransferDataComplete;
    ProtocolChar.ResetCompleteHandler        = PacketResetComplete;
    ProtocolChar.RequestCompleteHandler      = PacketRequestComplete;
    ProtocolChar.ReceiveHandler              = PacketReceiveIndicate;
    ProtocolChar.ReceiveCompleteHandler      = PacketReceiveComplete;
    ProtocolChar.StatusHandler               = PacketStatus;
    ProtocolChar.StatusCompleteHandler       = PacketStatusComplete;
    ProtocolChar.Name                        = ProtoName;

    // version 4.0 NDIS parts:  
    ProtocolChar.ReceivePacketHandler    = NULL;
#ifdef TRY_DYNAMIC_BINDING
    ProtocolChar.BindAdapterHandler      = PacketBind;
    ProtocolChar.UnbindAdapterHandler    = PacketUnBind;
#endif
    //ProtocolChar.TranslateHandler        = NULL;
    ProtocolChar.UnloadHandler           = NULL;
    Driver.ndis_version = 4;
#ifdef TRY_DYNAMIC_BINDING
  // don't do this yet(not fully debugged)
    NdisRegisterProtocol(
        &Status,
        &Driver.NdisProtocolHandle,
        &ProtocolChar,
        sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
    if (Status != NDIS_STATUS_SUCCESS)
#endif
    {
      MyKdPrint(D_Init,("No NDIS40\n"))

      // try NDIS30
      ProtocolChar.MajorNdisVersion           = 3;
      ProtocolChar.BindAdapterHandler      = NULL;
      ProtocolChar.UnbindAdapterHandler    = NULL;

      NdisRegisterProtocol(
          &Status,
          &Driver.NdisProtocolHandle,
          &ProtocolChar,
          sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
      if (Status != NDIS_STATUS_SUCCESS)
      {
        MyKdPrint(D_Init,("No NDIS30\n"))
        return 1;  // error
      }
      Driver.ndis_version = 3;
    }
  }

  MyKdPrint(D_Init,("NDIS V%d\n",Driver.ndis_version))

  return 0;  // ok
}

/*----------------------------------------------------------------------
 NicOpen - Setup all our stuff for our own protocol, so we can
  talk ethernet.  Setup our callbacks to upper edge NDIS routines,
  grab registry entries which tell us who we are and what NIC cards
  we are bound to.  Take care of all init stuff associated with using
  the NIC card.
|----------------------------------------------------------------------*/
int NicOpen(Nic *nic, IN PUNICODE_STRING NicName)
{
  NTSTATUS Status = STATUS_SUCCESS;
  //NDIS_HANDLE NdisProtocolHandle;

  int i;
  NDIS_STATUS     ErrorStatus;
  PNDIS_BUFFER    NdisBuffer;

  //MyKdPrint(D_Init,("Nic Open\n"))
  DbgNicSet(nic);
  TraceStr("NicOpen");

  //----- This event is used in case any of the NDIS requests pend;
  KeInitializeEvent(&nic->CompletionEvent,
                    NotificationEvent, FALSE);

  Status = NicOpenAdapter(nic, NicName);
  if (Status)
  {
    MyKdPrint(D_Init,("Nic Fail Open\n"))
    NicClose(nic);
    return Status;
  }
  MyKdPrint(D_Init,("Nic Open OK\n"))

#ifdef COMMENT_OUT
  Nic->MacInfo.DestinationOffset = 0;
  Nic->MacInfo.SourceOffset = 6;
  Nic->MacInfo.SourceRouting = FALSE;
  Nic->MacInfo.AddressLength = 6;
  Nic->MacInfo.MaxHeaderLength = 14;
  Nic->MacInfo.MediumType = NdisMedium802_3;
#endif
  // NDIS packets consist of one or more buffer descriptors which point
  // to the actual data.  We send or receive single packets made up of
  // 1 or more buffers.  A MDL is used as a buffer descriptor under NT.

  //---------  Allocate a packet pool for our tx packets

  NdisAllocatePacketPool(&Status, &nic->TxPacketPoolTemp, 1,
                         sizeof(PVOID));
                 //        sizeof(PACKET_RESERVED));
  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 4;
  }

  //---------  Allocate a buffer pool for our tx packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &nic->TxBufferPoolTemp, 1);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 5;
  }

  //-------- create tx data buffer area
  nic->TxBufTemp = our_locked_alloc( MAX_PKT_SIZE,"ncTX");
  if (nic->TxBufTemp == NULL)
  {
    NicClose(nic);
    return 16;
  }

  //-------- form our tx queue packets so they link to our tx buffer area
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &nic->TxPacketsTemp, nic->TxPacketPoolTemp);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 8;
    }
    nic->TxPacketsTemp->ProtocolReserved[0] = 0;  // mark with our index
    nic->TxPacketsTemp->ProtocolReserved[1] = 0;  // free for use

    // get a buffer for the temp output packet
    NdisAllocateBuffer(&Status, &NdisBuffer, nic->TxBufferPoolTemp,
      &nic->TxBufTemp[0], 1520);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 9;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(nic->TxPacketsTemp, NdisBuffer);
  }

  //----------  Allocate a packet pool for our rx packets
  NdisAllocatePacketPool(&Status, &nic->RxPacketPool, MAX_RX_PACKETS,
                         sizeof(PVOID));
               //        sizeof(PACKET_RESERVED));

  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 6;
  }

  //---------  Allocate a buffer pool for our rx packets
  // we will only use 1 buffer per packet.
  NdisAllocateBufferPool(&Status, &nic->RxBufferPool, MAX_RX_PACKETS);
  if (Status != NDIS_STATUS_SUCCESS)
  {
    NicClose(nic);
    return 7;
  }

  //-------- create rx data buffer area, add in space at front
  // of packets to put our private data
  nic->RxBuf = our_locked_alloc(
                (MAX_PKT_SIZE+HDR_SIZE) * MAX_RX_PACKETS,"ncRX");

  //------- form our rx queue packets so they link to our rx buffer area
  for (i=0; i<MAX_RX_PACKETS; i++)
  {
    // Get a packet from the pool
    NdisAllocatePacket(&Status, &nic->RxPackets[i], nic->RxPacketPool);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 10;
    }
    nic->RxPackets[i]->ProtocolReserved[0] = i;  // mark with our index
    nic->RxPackets[i]->ProtocolReserved[1] = 0;  // free for use

    //--- link the buffer to our actual buffer space, leaving 20 bytes
    // at start of buffer for our private data(length, index, etc)
    NdisAllocateBuffer(&Status, &NdisBuffer, nic->RxBufferPool,
      &nic->RxBuf[((MAX_PKT_SIZE+HDR_SIZE) * i)+HDR_SIZE], MAX_PKT_SIZE);
    if (Status != NDIS_STATUS_SUCCESS)
    {
      NicClose(nic);
      return 11;
    }
    // we use only one data buffer per packet
    NdisChainBufferAtFront(nic->RxPackets[i], NdisBuffer);
  }

  strcpy(nic->NicName, UToC1(NicName));

  Trace1("Done Open NicName %s", nic->NicName);

  nic->Open = 1;
  return 0;  // ok
}

/*----------------------------------------------------------------------
 NicOpenAdapter -
|----------------------------------------------------------------------*/
int NicOpenAdapter(Nic *nic, IN PUNICODE_STRING NicName)
{
  UINT            Medium;
  NDIS_MEDIUM     MediumArray=NdisMedium802_3;
  NTSTATUS Status = STATUS_SUCCESS;
  NDIS_STATUS     ErrorStatus;
  ULONG RBuf;

  DbgNicSet(nic);

  NdisOpenAdapter(
        &Status,              // return status
        &ErrorStatus,
        &nic->NICHandle,      // return handle value
        &Medium,
        &MediumArray,
        1,
        Driver.NdisProtocolHandle,  // pass in our protocol handle
        (NDIS_HANDLE) nic,    // our handle passed to protocol callback routines
        NicName,        // name of nic-card to open
        0,
        NULL);

  if (Status == NDIS_STATUS_SUCCESS)
      PacketOpenAdapterComplete(nic,  Status, NDIS_STATUS_SUCCESS);
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceErr("NicOpen Pended");
    Status = NicWaitForCompletion(nic);  // wait for completion
  }

  if (Status != NDIS_STATUS_SUCCESS)
  {
    GTrace2(D_Nic, sz_modid, "NicOpen fail:%xH Err:%xH", Status, ErrorStatus);
    TraceStr(UToC1(NicName));
    nic->NICHandle = NULL;
    NicClose(nic);
    return 3;
  }

  GTrace1(D_Nic, sz_modid, "Try NicOpened:%s", nic->NicName);

  //----- get the local NIC card identifier address
  Status = NicGetNICInfo(nic, OID_802_3_CURRENT_ADDRESS,
                         (PVOID)nic->address, 6);

  //----- set the rx filter
  RBuf = NDIS_PACKET_TYPE_DIRECTED;
  Status = NicSetNICInfo(nic, OID_GEN_CURRENT_PACKET_FILTER,
                         (PVOID)&RBuf, sizeof(ULONG));

  return 0;  // ok
}

/*----------------------------------------------------------------------
 NicClose - Shut down our NIC access.  Deallocate any NIC resources.
|----------------------------------------------------------------------*/
int NicClose(Nic *nic)
{
  NTSTATUS Status;

  DbgNicSet(nic);
  TraceStr("NicClose");

  nic->Open = 0;
  nic->NicName[0] = 0;
  if (nic->NICHandle != NULL)
  {
    NdisCloseAdapter(&Status, nic->NICHandle);
    if (Status == NDIS_STATUS_PENDING)
    {
      Status = NicWaitForCompletion(nic);  // wait for completion
    }
    nic->NICHandle = NULL;
  }

  if (nic->TxPacketPoolTemp != NULL)
    NdisFreePacketPool(nic->TxPacketPoolTemp);
  nic->TxPacketPoolTemp = NULL;

  if (nic->TxBufferPoolTemp != NULL)
    NdisFreeBufferPool(nic->TxBufferPoolTemp);
  nic->TxBufferPoolTemp = NULL;

  if (nic->TxBufTemp != NULL)
    our_free(nic->TxBufTemp, "ncTX");
  nic->TxBufTemp = NULL;


  if (nic->RxPacketPool != NULL)
    NdisFreePacketPool(nic->RxPacketPool);
  nic->RxPacketPool = NULL;

  if (nic->RxBufferPool != NULL)
    NdisFreeBufferPool(nic->RxBufferPool);
  nic->RxBufferPool = NULL;

  if (nic->RxBuf != NULL)
    our_free(nic->RxBuf,"ncRX");
  nic->RxBuf = NULL;

  MyKdPrint(D_Nic,("Nic Close End\n"))
  return 0;
}

/*----------------------------------------------------------------------
 NicProtocolClose - Deregister our protocol.
|----------------------------------------------------------------------*/
int NicProtocolClose(void)
{
  NTSTATUS Status;

  MyKdPrint(D_Nic,("Nic Proto Close\n"))

  if (Driver.NdisProtocolHandle != NULL)
    NdisDeregisterProtocol(&Status, Driver.NdisProtocolHandle);
  Driver.NdisProtocolHandle = NULL;
  return 0;
}

/*----------------------------------------------------------------------
 PacketRequestComplete - If a call is made to NdisRequest() to get
   information about the NIC card(OID), then it may return PENDING and
   this routine would then be called by NDIS to finalize the call.
|----------------------------------------------------------------------*/
VOID PacketRequestComplete(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_REQUEST NdisRequest,
    IN NDIS_STATUS   Status)
{

  Nic *nic = (Nic *)ProtocolBindingContext;

  MyKdPrint(D_Nic,("PacketReqComp\n"))
  //MyDeb(NULL, 0xffff, "PktRqComp\n");

  nic->PendingStatus = Status;
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketSendComplete - Callback routine if NdisSend() returns PENDING.
|----------------------------------------------------------------------*/
VOID PacketSendComplete(
       IN NDIS_HANDLE   ProtocolBindingContext,
       IN PNDIS_PACKET  pPacket,
       IN NDIS_STATUS   Status)
{
  Nic *nic = (Nic *)ProtocolBindingContext;

#if DBG
    if (nic == NULL)
    {
      MyKdPrint(D_Error, ("**** NicP Err1"))
      return;
    }
    DbgNicSet(nic);

    //nic->PendingStatus = Status;
    if (Status == STATUS_SUCCESS)
      {TraceStr("PcktSendComplete");}
    else
      {TraceErr("PcktSendComplete Error!");}
#endif

    pPacket->ProtocolReserved[1] = 0;  // free for use

    //--- not using this
    //KeSetEvent(&nic->CompletionEvent, 0L, FALSE);

    return;
}

/*----------------------------------------------------------------------
 NicWaitForCompletion - Utility routine to wait for async. routine
   to complete.
|----------------------------------------------------------------------*/
NDIS_STATUS NicWaitForCompletion(Nic *nic)
{
   MyKdPrint(D_Nic,("WaitOnComp\n"))
   // The completion routine will set PendingStatus.
   KeWaitForSingleObject(
         &nic->CompletionEvent,
              Executive,
              KernelMode,
              TRUE,
              (PLARGE_INTEGER)NULL);

   KeResetEvent(&nic->CompletionEvent);
   MyKdPrint(D_Nic,("WaitOnCompEnd\n"))
   return nic->PendingStatus;
}
  
/*----------------------------------------------------------------------
 PacketReceiveIndicate - When a packet comes in, this routine is called
   to let us(protocol) know about it.  We may peek at the data and
   optionally arrange for NDIS to transfer the complete packet data to
   one of our packets.

   LookAheadBufferSize is guarenteed to be as big as the
    OID_GEN_CURRENT_LOOKAHEAD value or packet size, whichever is smaller.
   If (PacketSize != LookAheadBufferSize) then a NdisTransferData() is
    required.  Otherwise the complete packet is available in the
    lookahead buffer.
    !!!!Check the OID_GEN_somethin or other, there is a bit which indicates
    if we can copy out of lookahead buffer.
    The header len is typically 14 bytes in length for ethernet.
|----------------------------------------------------------------------*/
NDIS_STATUS PacketReceiveIndicate (
  IN NDIS_HANDLE ProtocolBindingContext,
  IN NDIS_HANDLE MacReceiveContext,
  IN PVOID       HeaderBuffer,
  IN UINT        HeaderBufferSize,
  IN PVOID       LookAheadBuffer,
  IN UINT        LookAheadBufferSize,
  IN UINT        PacketSize)
{
  NDIS_STATUS Status;
  UINT BytesTransfered;
  WORD LenOrId;

  //  int stat;
  //static char tmparr[60];

  Nic *nic = (Nic *)ProtocolBindingContext;
#if DBG
  if (nic == NULL)
  {
    MyKdPrint(D_Error, ("Eth15b\n"))
  }
  if (!nic->Open)
  {
    MyKdPrint(D_Error, ("Eth15a\n"))
    return 1;
  }
#endif
  DbgNicSet(nic);
  TraceStr("pkt_rec_ind");

  if (HeaderBufferSize != 14)
  {
    TraceErr("Header Size!");
    ++nic->pkt_rcvd_not_ours;
    return NDIS_STATUS_NOT_ACCEPTED;
  }

  LenOrId = *(PWORD)(((PBYTE)HeaderBuffer)+12);
  if (LenOrId != 0xfe11)
  {
    // this not our packet
    ++nic->pkt_rcvd_not_ours;
    return NDIS_STATUS_NOT_ACCEPTED;
  }

  if (LookAheadBufferSize > 1)
  {
    //------ lets check for our product id header
    LenOrId = *(PBYTE)(((PBYTE)HeaderBuffer)+14);
       // serial concentrator product line
    if (LenOrId != ASYNC_PRODUCT_HEADER_ID)
    {
      if (LenOrId != 0xff)
      {
        TraceStr("nic,not async");
        // this not our packet
        ++nic->pkt_rcvd_not_ours;
        return NDIS_STATUS_NOT_ACCEPTED;
      }
    }
  }

#ifdef BREAK_NIC_STUFF
  if (nic->RxPackets[0]->ProtocolReserved[1] & 1)  // marked as pending
  {
     // our one rx buffer is in use!  (should never happen)
     MyKdPrint(D_Error, ("****** RxBuf in use!"))
     //TraceErr("Rx Buf In Use!");
     return NDIS_STATUS_NOT_ACCEPTED;
  }
  nic->RxPackets[0]->ProtocolReserved[1] |= 1;  // marked as pending
#endif

  memcpy(nic->RxBuf, (BYTE *)HeaderBuffer, 14);  // copy the eth. header

  if (LookAheadBufferSize == PacketSize)
  {
    TraceStr("nic,got complete");
    ++nic->RxNonPendingMoves;
    // we can just copy complete packet out of lookahead buffer
    // store the 14 byte header data at start of buffer

    memcpy(&nic->RxBuf[HDR_SIZE], (BYTE *)LookAheadBuffer, PacketSize);
    HDR_PKTLEN(nic->RxBuf) = PacketSize;  // save the pkt size here
    ++nic->pkt_rcvd_ours;
    GotOurPkt(nic);
  }
  else // LookAhead not complete buffer, pending, do transfer
  {
    ++nic->RxPendingMoves;
    //MyDeb(NULL, 0xffff, "PktRecInd, Pend\n");

    //  Call the Mac to transfer the packet
    NdisTransferData(&Status, nic->NICHandle, MacReceiveContext,
       0, PacketSize, nic->RxPackets[0], &BytesTransfered);

    if (Status == NDIS_STATUS_SUCCESS)
    {
      TraceStr("nic,got trsfer complete");
      HDR_PKTLEN(nic->RxBuf) = PacketSize;

      //------ lets check for our product id header
      if ((nic->RxBuf[HDR_SIZE] != ASYNC_PRODUCT_HEADER_ID) &&
          (nic->RxBuf[HDR_SIZE] != 0xff) )
      {
         nic->RxPackets[0]->ProtocolReserved[1] = 0;  // marked as not use
         TraceStr("nic,not async");
         // this not our packet
         ++nic->pkt_rcvd_not_ours;
         return NDIS_STATUS_NOT_ACCEPTED;
      }

      ++nic->pkt_rcvd_ours;
      GotOurPkt(nic);
    }
    else if (Status == NDIS_STATUS_PENDING)
    {
      TraceStr("nic,got pending");
      // ndis will call PacketTransferDataComplete.
    }
    else  // an error occurred(adapter maybe getting reset)
    {
      MyKdPrint(D_Error, ("nic, Err1D"))
      nic->RxPackets[0]->ProtocolReserved[1] = 0;  // marked as not use
      //MyDeb(NULL, 0xffff, "PktRecInd, PendError\n");
    }
  }
  return NDIS_STATUS_SUCCESS;
}

/*----------------------------------------------------------------------
 GotOurPkt - Its our packet(0x11fe for id at [12,13],
  and ASYNC(VS1000) or ff as [14],
  index byte we don't care about[16],
   rx = ptr to rx_pkt[16].
   [12,13] WORD 11fe(comtrol-pci-id, used as ethertype)
   [14] Product(55H=async, 15H=isdn, FFH=all)
   [15] Index Field(Server assigned box index)
   [16] Packet Class, 1=ADMIN, 0x55=VS1000 packet
     [17] word len for admin packet
     [17] hdlc control field for vs1000 packet
|----------------------------------------------------------------------*/
VOID GotOurPkt(Nic *nic)
{
  // [HDR_SIZE] is after 14 byte header, so contains [14] data
  // [14]=55H or FFH, [15]=Index, not used [16]=1(ADMIN),55H=ASYNC_MESSAGE
  switch(nic->RxBuf[HDR_SIZE+2])  
  {
    case ADMIN_FRAME:  // ADMIN function, special setup admin functions
      TraceStr("admin");
      eth_rx_admin(nic,
                   nic->RxBuf+(HDR_SIZE+3), // ptr to admin data
                   nic->RxBuf,              // ptr to ethernet header data
                   HDR_PKTLEN(nic->RxBuf),  // we embed length at [12] 0x11fe
                   1);  // server flag
    break;

     case ASYNC_FRAME:  // async frame(normal iframe/control hdlc packets)
       TraceStr("iframe");
       eth_rx_async(nic);
     break;

     default:
       TraceStr("badf");
       Tprintf("D: %x %x %x %x",
               nic->RxBuf[HDR_SIZE],
               nic->RxBuf[HDR_SIZE+1],
               nic->RxBuf[HDR_SIZE+2],
               nic->RxBuf[HDR_SIZE+3]);
     break;
   }
   nic->RxPackets[0]->ProtocolReserved[1] = 0;  // mark as not use
}

/*----------------------------------------------------------------
 eth_rx_async - We receive from layer1, validate using the
   hdlc validation call, and ship rx-pkt up to the next upper layer.
|-----------------------------------------------------------------*/
void eth_rx_async(Nic *nic)
{
 int i;
 Hdlc *hd;
 //WORD hd_index;
 WORD id;
 BYTE *rx;
 PSERIAL_DEVICE_EXTENSION ext;

  rx = nic->RxBuf;

#ifdef USE_INDEX_FIELD
  id = rx[HDR_SIZE];
#endif

  // find the HDLC level with the reply address
  //hd_index = 0xffff;  // save index to hdlc handle in header area
  hd = NULL;

  i = 0;
  ext = Driver.board_ext;
  while (ext != NULL)
  {
#ifdef USE_INDEX_FIELD
    if (id == ext->pm->unique_id)
#else
    if (mac_match(&rx[6], ext->hd->dest_addr))
#endif
    {
      hd = ext->hd;
      break;
    }
    ++i;
    ext = ext->board_ext; // next one
  }

  if (hd == NULL)
  {
    TraceErr("no Mac Match!");
    return;
  }

  if (!hd->nic || !hd->nic->Open)
  {
    TraceErr("notOpen!");
    return;
  }

  // 55 0 55 control snd_index ack_index
  rx += (HDR_SIZE+3);  // skip over header

  i = hdlc_validate_rx_pkt(hd, rx);  // validate the packet

  if (i == 0)
  {
    TraceStr("nic, pass upper");
    if (hd->upper_layer_proc != NULL)
    {
      if (*(rx+3) != 0)  // not an empty packet(HDLC ACK packets, t1 timeout)
      {
        (*hd->upper_layer_proc)(hd->context,
                              EV_L2_RX_PACKET,
                              (DWORD) (rx+3) );
      }
      ++(hd->frames_rcvd);
    }
  }
  else
  {
    switch (i)
    {
      case ERR_GET_EMPTY      : // 1  // empty
        TraceErr("Empty!");
      break;
      case ERR_GET_BAD_INDEX  : // 2  // error, packet out of sequence
        TraceErr("LanIdx!");
      break;
      case ERR_GET_BADHDR     : // 3  // error, not our packet
        // TraceErr("LanHdr!");
      break;
      case ERR_CONTROL_PACKET :
      break;

      default: TraceErr("LanErr!"); break;
    }
  }  // else hdlc, error or control, not iframe
}

/*----------------------------------------------------------------------------
| eth_rx_admin - PortMan handles admin functions, validate and pass on as
  event messages.  rx is ptr to admin data, [17][18]=len, [19]=sub-admin-header
|----------------------------------------------------------------------------*/
void eth_rx_admin(Nic *nic, BYTE *rx, BYTE *pkt_hdr, int len, int server)
{
  Hdlc *hd;

  rx += 2;

  TraceStr("AdminPkt");
  if (mac_match(pkt_hdr, broadcast_addr))   // its a broadcast
  {
    if ((*rx == 2) && (!server)) // Product ID request, Broadcast by server
    {
      // ok, we will reply
    }
    else if ((*rx == 3) && (server)) // Product ID reply, reply by concentrator.
    {
      // might be box waking up, or responding to server request.
      // shouldn't see it broadcast, but ISDN box currently broadcasts
      // on power-up.
    }
    else
    {
      TraceErr("bad b-admin!");
    }
    TraceErr("broadcast admin!");
    return;
  }

  switch(*rx)
  {
#ifdef COMMENT_OUT
    case 2:  // Product ID request, Broadcast or sent by server
      TraceStr("idreq");
      if (!server)  // we are not a server, we are box
        eth_id_req(&pkt_hdr[6]);
    break;
#endif

    case 1:  // boot loader query
      if (!server)  // we are a server
        break;

      if ((hd = find_hdlc_handle(&pkt_hdr[6])) != NULL)
      {
        PortMan *pm = (PortMan *) hd->context;
        if (pm->state != ST_SENDCODE)
        {
#if 0
          // not functional at this point.
          // port manager is not uploading code, so it must be debug pkt
          // let port.c code handle boot-loader ADMIN reply.
          debug_device_reply(pm, 
                    rx+1,
                    pkt_hdr);
#endif
        }
        else
        {
          TraceStr("load_reply");
          // tell upper layer(port-manager) about ID reply
          // port-manager does code loading.
          if (hd->upper_layer_proc != NULL)
            (*hd->upper_layer_proc)(hd->context,
                                    EV_L2_BOOT_REPLY,
                                    (DWORD) (rx+1));
        }
      }
#ifdef COMMENT_OUT
#endif
    break;

    case 3:  // Product ID reply, reply by concentrator.
      TraceStr("id_reply");
      if (!server)  // we are a server
        break;
      {
        BYTE *list;
        BYTE *new;
        int i, found;
        // driver previously sent out directed or broadcast query
        // on network to detect boxes.
        // build a list of units which reply.
        // (rx+1) = ptr to reply address
        // *(rx+1+6) = flags byte which indicate if main-driver loaded.
        found = 0;  // default to "did not find mac addr in list"
        new  = rx+1;
        if (Driver.NumBoxMacs < MAX_NUM_BOXES)
        {
          for (i=0; i<Driver.NumBoxMacs; i++)
          {
             list = &Driver.BoxMacs[i*8];
             if (mac_match(list, new))
               found = 1;  // found mac addr in list
          }
        }

        if (!found)  // then add to list of mac addresses found on network
        {
          if (Driver.NumBoxMacs < MAX_NUM_BOXES)
          {
            memcpy(&Driver.BoxMacs[Driver.NumBoxMacs*8], rx+1, 8);
            Driver.BoxMacs[Driver.NumBoxMacs*8+7] = (BYTE) 
              nic_handle_to_index(nic);
            Driver.BoxMacs[Driver.NumBoxMacs*8+6] = *(rx+1+6); // flags byte
            if (Driver.NumBoxMacs < (MAX_NUM_BOXES-1))
             ++Driver.NumBoxMacs;
          }
        }
        if (!Driver.TimerCreated) // init time(no hdlc levels active)
          break;  // so don't try to use hdlc

        if ((hd = find_hdlc_handle(&pkt_hdr[6])) != NULL)
        {
          // stash the nic index in byte after flags byte
          *(rx+1+7) = (BYTE) nic_handle_to_index(nic);
          // tell upper layer(port-mananger) about ID reply
          if (hd->upper_layer_proc != NULL)
            (*hd->upper_layer_proc)(hd->context,
                                    EV_L2_ADMIN_REPLY,
                                    (DWORD) (rx+1));
        }
        else
        {
#ifdef DO_AUTO_CONFIG
          PSERIAL_DEVICE_EXTENSION need_ext;

          MyKdPrint(D_Test,("Got Reply, Check AutoAssign\n"))
          if (!(*(rx+1+6) & FLAG_APPL_RUNNING))  // no box driver running
          {
            MyKdPrint(D_Test,("AutoAssign1\n"))
            // so probably free to auto-assign.
            // see if any extensions need auto assignment
            need_ext =need_mac_autoassign();
            if ((need_ext != NULL) && (Driver.AutoMacDevExt == NULL))
            {
              MyKdPrint(D_Test,("AutoAssigned!\n"))
                // set the mac addr for use
              memcpy(need_ext->config->MacAddr, (rx+1), 6);
                // signal the thread that auto-config needs
                // to be written out to registry
              Driver.AutoMacDevExt = need_ext;
            }
          }
#endif
        }
      }
    break;

    case 4:  // Loopback request
      TraceStr("aloop");
      //eth_loop_back(rx, pkt_hdr, len);
    break;

    case 5:  // Command, Reset
      TraceStr("reset");
      //eth_command_reset(rx, pkt_hdr, len);
    break;
    default:
      TraceErr("admin, badpkt!");
    break;
  }
}

/*----------------------------------------------------------------------
  find_hdlc_handle - find the Hdlc object with the same mac-address
    as the ethernet header source mac address.
|----------------------------------------------------------------------*/
Hdlc *find_hdlc_handle(BYTE *rx)
{
 PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  while (ext != NULL)
  {
    if (mac_match(rx, ext->hd->dest_addr))
    {
      return ext->hd;
    }
    ext = ext->board_ext; // next one
  }

  TraceStr("find,NoMac Match!");
  return NULL;
}

/*----------------------------------------------------------------------
  need_mac_autoassign - Used for autoconfig of mac-address.
|----------------------------------------------------------------------*/
static PSERIAL_DEVICE_EXTENSION need_mac_autoassign(void)
{
  PSERIAL_DEVICE_EXTENSION board_ext;

  board_ext = Driver.board_ext;
  while (board_ext != NULL)
  {
      // see if not configured
    if ( (mac_match(board_ext->config->MacAddr, mac_zero_addr)) ||
         (mac_match(board_ext->config->MacAddr, mac_bogus_addr)) )
      return board_ext;  // needs auto-assignment

    board_ext = board_ext->board_ext;
  }
  return NULL;  // its not used
}

/*----------------------------------------------------------------------
 PacketReceiveComplete -
|----------------------------------------------------------------------*/
VOID PacketReceiveComplete(IN NDIS_HANDLE ProtocolBindingContext)
{
  //Nic *nic = (Nic *)ProtocolBindingContext;

  TraceStr("PcktRxComp");
  //MyDeb(NULL, 0xffff, "PktRecComp, 1\n");

  //lan_rec_proc(Driver->lan, nic->RxBuf, nic->len);
  //netio_got_packet(Driver->lan, nic->RxBuf);
  return;
}

/*----------------------------------------------------------------------
 PacketTransferDataComplete -
|----------------------------------------------------------------------*/
VOID PacketTransferDataComplete (
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN PNDIS_PACKET  pPacket,
    IN NDIS_STATUS   Status,
    IN UINT          BytesTransfered)
{
  Nic *nic = (Nic *)ProtocolBindingContext;

  TraceStr("nic, pend rx complete");
  if ((nic->RxBuf[HDR_SIZE] != ASYNC_PRODUCT_HEADER_ID) &&
      (nic->RxBuf[HDR_SIZE] != 0xff) )
  {
    TraceStr("not ours");
    ++nic->pkt_rcvd_not_ours;
    nic->RxPackets[0]->ProtocolReserved[1] = 0;  // mark as not use
    return;
  }

  ++nic->pkt_rcvd_ours;
  GotOurPkt(nic);

  return;
}

/*----------------------------------------------------------------------
 PacketOpenAdapterComplete - Callback.
|----------------------------------------------------------------------*/
VOID PacketOpenAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status,
    IN NDIS_STATUS  OpenErrorStatus)
{
  Nic *nic = (Nic *)ProtocolBindingContext;
  nic->PendingStatus = Status;
  TraceStr("PcktOpenAd");
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketCloseAdapterComplete -
|----------------------------------------------------------------------*/
VOID PacketCloseAdapterComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status)
{
  Nic *nic = (Nic *)ProtocolBindingContext;
  TraceStr("PcktCloseAd");
  nic->PendingStatus = Status;
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketResetComplete -
|----------------------------------------------------------------------*/
VOID PacketResetComplete(
    IN NDIS_HANDLE  ProtocolBindingContext,
    IN NDIS_STATUS  Status)
{
  Nic *nic = (Nic *)ProtocolBindingContext;
  TraceStr("PcktResetComplete");
  nic->PendingStatus = Status;
  KeSetEvent(&nic->CompletionEvent, 0L, FALSE);
  return;
}

/*----------------------------------------------------------------------
 PacketStatus -
|----------------------------------------------------------------------*/
VOID PacketStatus(
    IN NDIS_HANDLE   ProtocolBindingContext,
    IN NDIS_STATUS   Status,
    IN PVOID         StatusBuffer,
    IN UINT          StatusBufferSize)
{
  TraceStr("PcktStat");
   return;
}

/*----------------------------------------------------------------------
 PacketStatusComplete -
|----------------------------------------------------------------------*/
VOID PacketStatusComplete(IN NDIS_HANDLE  ProtocolBindingContext)
{
  TraceStr("PcktStatComplete");
   return;
}

/*----------------------------------------------------------------------
 NicSetNICInfo -
|----------------------------------------------------------------------*/
NDIS_STATUS NicSetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size)
{
  NDIS_STATUS    Status;
  NDIS_REQUEST   Request;

  // Setup the request to send
  Request.RequestType=NdisRequestSetInformation;
  Request.DATA.SET_INFORMATION.Oid=Oid;
  Request.DATA.SET_INFORMATION.InformationBuffer=Data;
  Request.DATA.SET_INFORMATION.InformationBufferLength=Size;

  NdisRequest(&Status,
              nic->NICHandle,
              &Request);

  if (Status == NDIS_STATUS_SUCCESS)
  {}
  else if (Status == NDIS_STATUS_PENDING)
    Status = NicWaitForCompletion(nic);  // wait for completion

  if (Status != NDIS_STATUS_SUCCESS)
  {
    MyKdPrint (D_Init,("NdisRequest Failed- Status %x\n",Status))
  }
  return Status;
}

/*----------------------------------------------------------------------
 NicGetNICInfo - To call the NICs QueryInformationHandler
|----------------------------------------------------------------------*/
NDIS_STATUS NicGetNICInfo(Nic *nic, NDIS_OID Oid, PVOID Data, ULONG Size)
{
  NDIS_STATUS    Status;
  NDIS_REQUEST   Request;
             
  // Setup the request to send
  Request.RequestType=NdisRequestQueryInformation;
  Request.DATA.SET_INFORMATION.Oid=Oid;
  Request.DATA.SET_INFORMATION.InformationBuffer=Data;
  Request.DATA.SET_INFORMATION.InformationBufferLength=Size;

  NdisRequest(&Status,
              nic->NICHandle,
              &Request);

  if (Status == NDIS_STATUS_SUCCESS)
  {}
  else if (Status == NDIS_STATUS_PENDING)
    Status = NicWaitForCompletion(nic);  // wait for completion

  if (Status != NDIS_STATUS_SUCCESS)
  {
    MyKdPrint (D_Init,("NdisRequest Failed- Status %x\n",Status))
  }
  return Status;
}

/*--------------------------------------------------------------------------
| nic_send_pkt -
|--------------------------------------------------------------------------*/
int nic_send_pkt(Nic *nic, BYTE *buf, int len)
{
// BYTE *bptr;
// int cnt;
 NTSTATUS Status;
//int pkt_num;

  if (nic == NULL)
  {
    MyKdPrint(D_Error, ("E1\n"))
    TraceErr("snd1a");
    return 1;
  }
  if (nic->TxBufTemp == NULL)
  {
    MyKdPrint(D_Error, ("E2\n"))
    TraceErr("snd1b");
    return 1;
  }
  if (nic->TxPacketsTemp == NULL)
  {
    MyKdPrint(D_Error, ("E3\n"))
    TraceErr("snd1c");
    return 1;
  }
  if (nic->Open == 0)
  {
    MyKdPrint(D_Error, ("E4\n"))
    TraceErr("snd1d");
    return 1;
  }
  DbgNicSet(nic);
  TraceStr("send_pkt");

  if (nic->TxPacketsTemp->ProtocolReserved[1] & 1)  // marked as pending
  {
    TraceErr("snd1e");

       // reset in case it got stuck
       // nic->TxPacketsTemp->ProtocolReserved[1] = 0;
    return 3;
  }

  memcpy(nic->TxBufTemp, buf, len);

  nic->TxPacketsTemp->Private.TotalLength = len;
  NdisAdjustBufferLength(nic->TxPacketsTemp->Private.Head, len);

  nic->TxPacketsTemp->ProtocolReserved[1] = 1;  // mark as pending
  NdisSend(&Status, nic->NICHandle,  nic->TxPacketsTemp);
  if (Status == NDIS_STATUS_SUCCESS)
  {           
    TraceStr("snd ok");
    nic->TxPacketsTemp->ProtocolReserved[1] = 0;  // free for use
  }
  else if (Status == NDIS_STATUS_PENDING)
  {
    TraceStr("snd pend");
      // Status = NicWaitForCompletion(nic);  // wait for completion
  }
  else
  {
    nic->TxPacketsTemp->ProtocolReserved[1] = 0;  // free for use
    TraceErr("send1A");
    return 1;
  }
 
  ++nic->pkt_sent;             // statistics
  nic->send_bytes += len;      // statistics

  return 0;
}

#ifdef TRY_DYNAMIC_BINDING
/*----------------------------------------------------------------------
  PacketBind - Called when nic card ready to use.  Passes in name of
    nic card.  NDIS40 protocol only.
|----------------------------------------------------------------------*/
VOID PacketBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE  BindContext,
  IN  PNDIS_STRING DeviceName,
  IN  PVOID SystemSpecific1,
  IN  PVOID SystemSpecific2)
{
 int i,stat;

  MyKdPrint(D_Init,("Dyn. Bind\n"))

  TraceErr("DynBind");
  TraceErr(UToC1(DeviceName));

  // NIC not open - retry open
  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    MyKdPrint(D_Init,("D1\n"))
    if((Driver.nics[i].NICHandle == NULL) &&
       (Driver.NicName[i].Buffer == NULL))
    {
      MyKdPrint(D_Init,("D2\n"))
      // make a copy of the nic-name
      Driver.NicName[i].Buffer =
        our_locked_alloc(DeviceName->Length + sizeof(WCHAR), "pkbd");
      memcpy(Driver.NicName[i].Buffer, DeviceName->Buffer, DeviceName->Length);
      Driver.NicName[i].Length = DeviceName->Length;
      Driver.NicName[i].MaximumLength = DeviceName->Length;

      stat = NicOpen(&Driver.nics[i], &Driver.NicName[i]);
      if (stat)
      {
        TraceErr("Bad NicOpen");
        *Status = NDIS_STATUS_NOT_ACCEPTED;
        return;
      }
      else
      {
        MyKdPrint(D_Init,("D3\n"))
        Driver.BindContext[i] = BindContext;  // save this for the unbind
        *Status = NDIS_STATUS_SUCCESS;
        return;
      }
    }
  }

  MyKdPrint(D_Init,("D4\n"))
  *Status = NDIS_STATUS_NOT_ACCEPTED;
  return;

  //if (pended)
  //  NdisCompleteBindAdapter(BindContext);
}

/*----------------------------------------------------------------------
  PacketUnBind -  Called when nic card is shutting down, going away.
    NDIS40 protocol only.
|----------------------------------------------------------------------*/
VOID PacketUnBind(
  OUT PNDIS_STATUS Status,
  IN  NDIS_HANDLE ProtocolBindingContext,
  IN  NDIS_HANDLE  UnbindContext)
{
 int i, pi;
  TraceErr("DynUnBind");

  //if (pend)
  //  NdisCompleteUnBindAdapter(BindContext);
  // NIC not open - retry open

  // find the nic card which is closing up shop
  for (i=0; i<Driver.num_nics; i++)
  {
    if (Driver.BindContext[i] == ProtocolBindingContext) // a match!
    {
      TraceErr("fnd UnBind");
      if((Driver.nics[i].NICHandle != NULL) &&
         (Driver.nics[i].Open))
      {
        // first find all the box objects, and shut them down
        // BUGBUG: we should use some spinlocks here, we are in danger of
        // doing two things at once(pulling the rug out from under
        // port.c operations while it is running.
        ext = Driver.board_ext;
        while (ext)
        {
          if (Driver.pm[pi].nic_index == i)  // its using this nic card
          {
            if (Driver.pm[pi].state == Driver.pm[i].state)
            {
              TraceErr("Shutdown box");
              Driver.pm[pi].state = ST_INIT;
            }
          }
          ext = ext->board_ext;
        }

        NicClose(&Driver.nics[i]);
        if (Driver.NicName[i].Buffer)
        {
          our_free(Driver.NicName[i].Buffer, "pkbd");  // free up the unicode buf
          Driver.NicName[i].Buffer = 0;
        }
      }
      Driver.BindContext[i] = 0;
    }
  }

  *Status = NDIS_STATUS_SUCCESS;
  return;
}
#endif

/*----------------------------------------------------------------------
  nic_handle_to_index - given a nic handle, give the index into the
    linked list, or array.
|----------------------------------------------------------------------*/
static int nic_handle_to_index(Nic *nic)
{
 int i;

  for (i=0; i<VS1000_MAX_NICS; i++)
  {
    if ((&Driver.nics[i]) == nic)
      return i;
  }
  TraceErr("BadIndex");
  return 0;
}

#if 0
/*----------------------------------------------------------------------
  PacketTranslate -
|----------------------------------------------------------------------*/
VOID PacketTranslate(
  OUT PNDIS_STATUS Status,
  IN NDIS_HANDLE ProtocolBindingContext,
  OUT  PNET_PNP_ID  IdList,
  IN ULONG IdListLength,
  OUT PULONG BytesReturned)
{
}

/*----------------------------------------------------------------------
  PacketUnLoad -
|----------------------------------------------------------------------*/
VOID PacketUnLoad(VOID)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\openclos.c ===
/*-------------------------------------------------------------------
| openclos.c - RocketPort/VS1000 driver Open & Close code.

12-6-00 add code to force modem status update on open.
5-13-99 - enable RTS toggling for VS
2-15-99 - clear any xoff tx state on port-open for VS.
2-09-99 - initialize RocketPort & VS modemstatus variables used
  to detect and generate modem status change event callbacks.
  Spurious initial events could be generated previously.  kpb
9-24-98 add RING emulation, adjust VS port-close to wait on tx-data,
   start using user-configured tx-data port-close wait timeout option.
6-13-97 allow multiple instances of opening monitor port.
5-27-96 minor corrections in ForceExtensionSettings - RTS setup
   replaced this with code from ioctl(previous last case was clearing
   SERIAL_RTS_STATE when shouldn't have.  NULL_STRIPPING setup, 
   this was using RxCompare1 register, ioctl code using 0 so
   changed to match. kpb.

4-16-96 add sDisLocalLoopback() to open() routine - kpb

Copyright 1993-97 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"


static LARGE_INTEGER SerialGetCharTime(IN PSERIAL_DEVICE_EXTENSION Extension);

/******************************************************************************
  Function : SerialCreateOpen
  Purpose:   Open a device.
  Call:      SerialCreateOpen(DeviceObject,Irp)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             PIRP Irp: Pointer to the I/O Request Packet
  Return:    STATUS_SUCCESS: if successful
             STATUS_DEVICE_ALREADY_ATTACHED: if device is already open
             STATUS_NOT_A_DIRECTORY : if someone thinks this is a file! 
             STATUS_INSUFFICIENT_RESOURCES : if Tx or Rx buffer couldn't be
                                            allocated from memory
  Comments: This function is the device driver OPEN entry point
******************************************************************************/
NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
   PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
   BOOLEAN acceptingIRPs;


   ExtTrace(extension,D_Ioctl,("Open Port"));

    acceptingIRPs = SerialIRPPrologue(extension);

   if (acceptingIRPs == FALSE) {
       // || (extension->PNPState != SERIAL_PNP_STARTED)) {
      MyKdPrint(D_Init,("NotAccIrps\n"))
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_NO_SUCH_DEVICE;
   }

   // object for special ioctls
   if (extension->DeviceType != DEV_PORT)
   {
     MyKdPrint(D_Init,("Open Driver\n"))
     //MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
     // Hardware is ready, indicate that the device is open
     //extension->DeviceIsOpen=TRUE;
     ++extension->DeviceIsOpen;  // more than one can open
     // If it is the rocketsys dev object return don't set up serial port
     Irp->IoStatus.Status = STATUS_SUCCESS;
     Irp->IoStatus.Information=0L;
     SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
     return STATUS_SUCCESS;
   }

   // Check for the device already being open
   if (extension->DeviceIsOpen)
   {
       Irp->IoStatus.Status = STATUS_DEVICE_ALREADY_ATTACHED;
       Irp->IoStatus.Information = 0;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

       return STATUS_DEVICE_ALREADY_ATTACHED;
   }   

   // Make sure they aren't trying to create a directory.  
   if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options &
       FILE_DIRECTORY_FILE)
   {
       Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
       Irp->IoStatus.Information = 0;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_NOT_A_DIRECTORY;
   }

   // Create a system side buffer for the RX data.

   extension->RxQ.QSize = 4096 + 1;
   extension->RxQ.QBase= our_locked_alloc(extension->RxQ.QSize, "exRX");

   // Check that Rx buffer allocation was succesful
   if (!extension->RxQ.QBase)
   {  extension->RxQ.QSize = 0;
      Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
      Irp->IoStatus.Information = 0;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   extension->RxQ.QPut = extension->RxQ.QGet = 0;

#ifdef TXBUFFER
   // Create a system side buffer for the TX data.
   extension->TxBufSize = 4096;
   extension->TxBuf= our_locked_alloc(extension->TxBufSize, "exTX");

   // Check that Tx buffer allocation was succesful
   if (!extension->TxBuf)
   {  extension->TxBufSize = 0;
      Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
      Irp->IoStatus.Information = 0;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   // Buffer allocation was successful
   // Set up the indexes for our buffers
   extension->TxIn = extension->TxOut = 0;
#endif //TXBUFFER

   //------ reset our performance stats
   extension->OldStats.TransmittedCount =
     extension->OurStats.TransmittedCount;

   extension->OldStats.FrameErrorCount = 
     extension->OurStats.FrameErrorCount;

   extension->OldStats.SerialOverrunErrorCount =
     extension->OurStats.SerialOverrunErrorCount;

   extension->OldStats.BufferOverrunErrorCount =
     extension->OurStats.BufferOverrunErrorCount;

   extension->OldStats.ParityErrorCount =
     extension->OurStats.ParityErrorCount;

   // Must start with a clear HistoryMask
   extension->HistoryMask = 0;
   extension->WaitIsISRs = 0;
   extension->IrpMaskLocation = &extension->DummyIrpMaskLoc;
   extension->IsrWaitMask = 0;

   // Must start with a clear ErrorWord
   extension->ErrorWord = 0;

   extension->RXHolding = 0;
   extension->TXHolding = 0;
#ifdef S_VS
   if (extension->Port == NULL)
   {
     MyKdPrint(D_Error,("FATAL Err5F\n"))
     KdBreakPoint();
   }
   pDisLocalLoopback(extension->Port);
   PortFlushTx(extension->Port);    // flush tx hardware
   PortFlushRx(extension->Port);    // flush tx hardware
   // Clear any software flow control states
#ifdef DO_LATER
   //sClrTxXOFF(extension->ChP);
#endif
#else
   // Set pointers to the Rocket's info
   extension->ChP = &extension->ch;
   sDisLocalLoopback(extension->ChP);
   sFlushRxFIFO(extension->ChP);
   sFlushTxFIFO(extension->ChP);
   // Clear any software flow control states
   sClrTxXOFF(extension->ChP);
   // Clear any pending errors
   if(sGetChanStatus(extension->ChP) & STATMODE)
   {  // Take channel out of statmode if necessary
      sDisRxStatusMode(extension->ChP);
   }
   // Clear any pending modem changes
   sGetChanIntID(extension->ChP);
#endif

   extension->escapechar = 0;  // virtual NT port uses this

   // Set Status to indicate no flow control
   extension->DevStatus = COM_RXFLOW_ON;

   // Clear any holding states
   extension->TXHolding = 0;

   // Start with 0 chars queued
   extension->TotalCharsQueued = 0;

   // Force settings as specified in the extension
   // Line settings and flow control settings "stick" between close and open
   ForceExtensionSettings(extension);

   
#ifdef S_VS

   //force an update of modem status to get current status from
   // hub.
   extension->Port->old_msr_value = ! extension->Port->msr_value;

#else

   // fix, used to detect change and trip callbacks for rocketport.
   extension->EventModemStatus = extension->ModemStatus;
   SetExtensionModemStatus(extension);

   // Enable Rx, Tx and interrupts for the channel
   sEnRxFIFO(extension->ChP);    // Enable Rx
   sEnTransmit(extension->ChP);    // Enable Tx
   sSetRxTrigger(extension->ChP,TRIG_1);  // always trigger
   sEnInterrupts(extension->ChP, extension->IntEnables);// allow interrupts
#endif

   extension->ISR_Flags = 0;

   // Make sure we don't have a stale value in this var
   extension->WriteLength = 0;

   // Hardware is ready, indicate that the device is open
   extension->DeviceIsOpen=TRUE;

  // check if we should set RS485 override option
  if (extension->port_config->RS485Override)
        extension->Option |= OPTION_RS485_OVERRIDE;
  else  extension->Option &= ~OPTION_RS485_OVERRIDE;

  if (!extension->port_config->RS485Low)
       extension->Option |= OPTION_RS485_HIGH_ACTIVE;
  else extension->Option &= ~OPTION_RS485_HIGH_ACTIVE;

   if (extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
   {
     if (extension->Option & OPTION_RS485_HIGH_ACTIVE)
     {  // normal case, emulate standard operation
       extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
       extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
#ifdef S_VS
       pEnRTSToggleHigh( extension->Port );
#else
       sClrRTS(extension->ChP);
#endif
     }
     else 
     {  // hardware reverse case
#ifdef S_VS
       pEnRTSToggleLow( extension->Port );
#else
       sEnRTSToggle(extension->ChP);
#endif
       extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     }
   }

   // Finish the Irp
   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information=0L;
   SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

   return STATUS_SUCCESS;
}

/******************************************************************************
  Function : SerialClose
  Purpose:   Close a device.
  Call:      SerialClose(DeviceObject,Irp)
             PDEVICE_OBJECT DeviceObject: Pointer to the Device Object
             PIRP Irp: Pointer to the I/O Request Packet
  Return:   STATUS_SUCCESS: always
  Comments: This function is the device driver CLOSE entry point
******************************************************************************/
NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
   LARGE_INTEGER charTime; // 100 ns ticks per char, related to baud rate
   PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
   LARGE_INTEGER WaitTime; // Actual time req'd for buffer to drain
   ULONG check_cnt, nochg_cnt;
   ULONG last_tx_count;
   ULONG tx_count;
   BOOLEAN acceptingIRPs;
   ULONG time_to_stall;

   acceptingIRPs = SerialIRPPrologue(extension);

   if (acceptingIRPs == FALSE) {
      MyKdPrint(D_Init,("NotAccIrps Close\n"))
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_SUCCESS;
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      return STATUS_SUCCESS;
   }

   // object for special ioctls
   if (extension->DeviceType != DEV_PORT)
   {
     MyKdPrint(D_Init,("Close Driver\n"))
     //MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
     // Hardware is ready, indicate that the device is open
     --extension->DeviceIsOpen;
     // If it is the rocketsys dev object return don't set up serial port
     Irp->IoStatus.Status = STATUS_SUCCESS;
     Irp->IoStatus.Information=0L;
     SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
     return STATUS_SUCCESS;
   }

   ExtTrace(extension,D_Ioctl,("Close"))
   // Calculate 100ns ticks to delay for each character
   // Negate for call to KeDelay...
   charTime = RtlLargeIntegerNegate(SerialGetCharTime(extension));

#ifdef TXBUFFER
   // Wait until ISR has pulled all data out of system side TxBuf
   while (extension->TxIn != extension->TxOut)
   {  // Determine how many characters are actually in TxBuf
      TxCount= (extension->TxIn - extension->TxOut);
      if (TxCount < 0L)
         TxCount+=extension->TxBufSize;
      WaitTime= RtlExtendedIntegerMultiply(charTime,TxCount);
      KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
   }
#endif //TXBUFFER


   // Send an XON if Tx is suspend by IS_FLOW
   // send now so we are sure that it gets out of the port before shutdown
   if (extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
   {
      if(!(extension->DevStatus & COM_RXFLOW_ON))
      {
#ifdef S_RK
         sWriteTxPrioByte(extension->ChP,extension->SpecialChars.XonChar);
         extension->DevStatus |= COM_RXFLOW_ON;
#endif
         extension->RXHolding &= ~SERIAL_RX_XOFF;
      }
   }

   //----- wait for Tx data to finish spooling out
   // If tx-data still in transmit buffers, then stall close for
   // the configured amount of time waiting for data to spool out.
   // If no data movement is seen, we timeout after TxCloseTime.
   // If data movement is seen, wait and timeout after (TxCloseTime*3).

   time_to_stall = extension->port_config->TxCloseTime;
   if (time_to_stall <= 0)
     time_to_stall = 1;  // use 1-sec if set to 0
   if (time_to_stall > 240)  // 4-minute max
     time_to_stall = 240;

   time_to_stall *= 10;  // change from seconds to 100ms(1/10th sec) units

#ifdef S_RK
   tx_count = extension->TotalCharsQueued + sGetTxCnt(extension->ChP);
   if ((sGetChanStatusLo(extension->ChP) & DRAINED) != DRAINED)
     ++tx_count;
#else
   tx_count = extension->TotalCharsQueued +
              PortGetTxCntRemote(extension->Port) +
              PortGetTxCnt(extension->Port);
#endif
   last_tx_count = tx_count;

   if (tx_count != 0)
   {
     ExtTrace(extension,D_Ioctl,("Tx Stall"));
   }

   // wait for Tx data to finish spooling out
   check_cnt = 0;
   nochg_cnt = 0;
   while ( (tx_count != 0) && (check_cnt < (time_to_stall*2)) )
   {
     // set wait-time to .1 second.(-1000 000 = relative(-), 100-ns units)
     WaitTime = RtlConvertLongToLargeInteger(-1000000L);
     KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

     if (tx_count != last_tx_count)
     {
       tx_count = last_tx_count;
       nochg_cnt = 0;
     }
     else
     {
       ++nochg_cnt;
       if (nochg_cnt > (time_to_stall))  // no draining occuring!
         break;  // bail out of while loop
     }
     ++check_cnt;
#ifdef S_RK
     tx_count = extension->TotalCharsQueued + sGetTxCnt(extension->ChP);
     if ((sGetChanStatusLo(extension->ChP) & DRAINED) != DRAINED)
       ++tx_count;
#else
     tx_count = extension->TotalCharsQueued +
                PortGetTxCntRemote(extension->Port) +
                PortGetTxCnt(extension->Port);
#endif
   }  // while tx_count

   if (tx_count != 0)
   {
     ExtTrace(extension,D_Ioctl,("Tx Dropped!"));
   }

#ifdef COMMENT_OUT
      // Calculate total chars and time, then wait.
      WaitTime= RtlExtendedIntegerMultiply(charTime,sGetTxCnt(extension->ChP));
      KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);
#endif

#ifdef S_RK
   // Tx Data is drained, shut down the port
   sDisInterrupts(extension->ChP, extension->IntEnables);

   // Disable all Tx and Rx functions
   sDisTransmit(extension->ChP);
   sDisRxFIFO(extension->ChP);
   sDisRTSFlowCtl(extension->ChP);
   sDisCTSFlowCtl(extension->ChP);
   sDisRTSToggle(extension->ChP);
   sClrBreak(extension->ChP);

   // Drop the modem outputs
   // Takes care of DTR flow control as well
   sClrRTS(extension->ChP);
   sClrDTR(extension->ChP);
#else
   // add this, 2-9-99, kpb, CNC xon/xoff problems...
   PortFlushRx(extension->Port);    // flush rx hardware
   PortFlushTx(extension->Port);    // flush tx hardware
   pClrBreak(extension->Port);
   pDisDTRFlowCtl(extension->Port);
   pDisRTSFlowCtl(extension->Port);
   pDisCTSFlowCtl(extension->Port);
   pDisRTSToggle(extension->Port);
   pDisDSRFlowCtl(extension->Port);
   pDisCDFlowCtl(extension->Port);
   pDisTxSoftFlowCtl(extension->Port);
   pDisRxSoftFlowCtl(extension->Port);
   pDisNullStrip(extension->Port);
   pClrRTS(extension->Port);
   pClrDTR(extension->Port);
#endif

   //extension->ModemCtl &= ~(CTS_ACT | DSR_ACT | CD_ACT);
   extension->DTRRTSStatus &= ~(SERIAL_DTR_STATE | SERIAL_RTS_STATE);
   
#ifdef TXBUFFER
   // Release the memory being used for this device's buffers...
   extension->TxBufSize = 0;
   our_free(extension->TxBuf,"exTX");
   extension->TxBuf = NULL;
#endif //TXBUFFER

   extension->DeviceIsOpen = FALSE;
   extension->RxQ.QSize = 0;
   our_free(extension->RxQ.QBase,"exRx");
   extension->RxQ.QBase = NULL;

   // Finish the Irp
   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = 0L;

   SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

   return STATUS_SUCCESS;
}


/***************************************************************************
Routine Description:
    This function is used to kill all longstanding IO operations.
Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
Return Value:
    The function value is the final status of the call
****************************************************************************/
NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    KIRQL oldIrql;
    BOOLEAN acceptingIRPs;

    MyKdPrint(D_Init,("SerialCleanup\n"))

    acceptingIRPs = SerialIRPPrologue(extension);

    if (acceptingIRPs == FALSE) {
       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_SUCCESS;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_SUCCESS;
    }
    if (extension->DeviceType != DEV_PORT)
    {
      MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
    }
#if DBG
    if (extension->CurrentWriteIrp)
    {
      MyKdPrint(D_Error,("CleanUp WriteQ\n"))
    }
    if (extension->CurrentReadIrp)
    {
      MyKdPrint(D_Error,("CleanUp ReadQ\n"))
    }
    if (extension->CurrentPurgeIrp)
    {
      MyKdPrint(D_Error,("CleanUp PurgeQ\n"))
    }
    if (extension->CurrentWaitIrp)
    {
      MyKdPrint(D_Error,("CleanUp WaitQ\n"))
    }
#endif

    ExtTrace(extension,D_Ioctl,("SerialCleanup"));

    // First kill all the reads and writes.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->WriteQueue,
        &extension->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->ReadQueue,
        &extension->CurrentReadIrp
        );

    // Next get rid of purges.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->PurgeQueue,
        &extension->CurrentPurgeIrp
        );

    // Get rid of any mask operations.
    //SerialKillAllReadsOrWrites(
    //    DeviceObject,
    //    &extension->MaskQueue,
    //    &extension->CurrentMaskIrp
    //    );

    if (extension->DeviceType != DEV_PORT)
    {
      MyKdPrint(D_Init,("Driver IrpCnt:%d\n",extension->PendingIRPCnt))
    }
    // Now get rid of any pending wait mask irp.
    IoAcquireCancelSpinLock(&oldIrql);
    if (extension->CurrentWaitIrp) {
        PDRIVER_CANCEL cancelRoutine;
        cancelRoutine = extension->CurrentWaitIrp->CancelRoutine;
        extension->CurrentWaitIrp->Cancel = TRUE;
        if (cancelRoutine)
        {   extension->CurrentWaitIrp->CancelIrql = oldIrql;
            extension->CurrentWaitIrp->CancelRoutine = NULL;
            cancelRoutine( DeviceObject, extension->CurrentWaitIrp );
        }
    }
    else
    {   IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


/************************************************************************
Routine: SerialGetCharTime
    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.
Return Value:
    100 nanosecond intervals in a character time.
*************************************************************************/
LARGE_INTEGER SerialGetCharTime(IN PSERIAL_DEVICE_EXTENSION Extension)
{
    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;

    dataSize = Extension->LineCtl.WordLength;
    if(!Extension->LineCtl.Parity)
       paritySize = 0;
    else
       paritySize = 1;

    if(Extension->LineCtl.StopBits == STOP_BIT_1)
       stopSize = 1;
    else
       stopSize = 2;

    // Calculate number of 100 nanosecond intervals in a single bit time
    if (Extension->BaudRate == 0)
    {
      MyKdPrint(D_Init, ("0 Baud!\n"))
      Extension->BaudRate = 9600;
    }
      
    bitTime = (10000000+(Extension->BaudRate-1))/Extension->BaudRate;
    // Calculate number of 100 nanosecond intervals in a character time
    charTime = bitTime + ((dataSize+paritySize+stopSize)*bitTime);

    return RtlConvertUlongToLargeInteger(charTime);
}

/*****************************************************************************
   Function : ForceExtensionSettings
   Description: "Forces" the RocketPort to settings as indicated
                 by the device extension
Note: This is somewhat redundant to SerialSetHandFlow() in ioctl.c.
*****************************************************************************/
VOID ForceExtensionSettings(IN PSERIAL_DEVICE_EXTENSION Extension)
#ifdef S_VS
{
   /////////////////////////////////////////////////////////////
   // set the baud rate....
   ProgramBaudRate(Extension, Extension->BaudRate);

   /////////////////////////////////////////////////////////////
   // set Line Control.... Data, Parity, Stop
   ProgramLineControl(Extension, &Extension->LineCtl);

   // HandFlow related options
   /////////////////////////////////////////////////////////////
   // set up RTS control

   Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
   switch(Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
   {
     case SERIAL_RTS_CONTROL: // RTS Should be asserted while open
       pDisRTSFlowCtl(Extension->Port);
       pSetRTS(Extension->Port);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_RTS_HANDSHAKE: // RTS hardware input flow control
        // Rocket can't determine RTS state... indicate true for this option
       pEnRTSFlowCtl(Extension->Port);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_TRANSMIT_TOGGLE: // RTS transmit toggle enabled
       if ( Extension->Option & OPTION_RS485_HIGH_ACTIVE ) {
         Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
         pEnRTSToggleHigh(Extension->Port);
       } else {
         pEnRTSToggleLow(Extension->Port);
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
       }
     break;

     default:
       pDisRTSFlowCtl(Extension->Port);
       // Is RTS_CONTROL off?
       pClrRTS(Extension->Port);
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
     break;
   }

   if (Extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
   {
     if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
     {  // normal case, emulate standard operation
       Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
       pEnRTSToggleHigh(Extension->Port);
     }
     else 
     {  // hardware reverse case
       pEnRTSToggleLow(Extension->Port);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     }
   }

   /////////////////////////////////////////////////////////////
   // set up DTR control

   pDisDTRFlowCtl(Extension->Port);
   // Should DTR be asserted when the port is opened?
   if (  (Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) ==
           SERIAL_DTR_CONTROL )
   {
      pSetDTR(Extension->Port);
      Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
   }
   else if (  (Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) ==
           SERIAL_DTR_HANDSHAKE )
   {
      pEnDTRFlowCtl(Extension->Port);
      Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
   }
   else
   {
      pClrDTR(Extension->Port);
      Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
   }

   ///////////////////////////////////
   // DSR hardware output flow control

   if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
   {
     pEnDSRFlowCtl(Extension->Port);
   }
   else
   {
     pDisDSRFlowCtl(Extension->Port);
   }

   ///////////////////////////////////
   // DCD hardware output flow control
   if (Extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
   {
     pEnCDFlowCtl(Extension->Port);
   }
   else
   {
     pDisCDFlowCtl(Extension->Port);
   }

   /////////////////////////////////////////////////////////////
   // Set up CTS Flow Control
   if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
   {
      pEnCTSFlowCtl(Extension->Port);
   }
   else
   {
      pDisCTSFlowCtl(Extension->Port);
   }

   /////////////////////////////////////////////////////////////
   // Set up NULL stripping    OPTIONAL
   // fix: this was using RxCompare1 register, ioctl code using 0 so
   // changed to match.
   if (Extension->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING)
   {
      pEnNullStrip(Extension->Port);
   }
   else
   {
      pDisNullStrip(Extension->Port);
   }

   /////////////////////////////////////////////////////////////
   // Set up Software Flow Control   OPTIONAL

   /////////////////////////////////////////////////////////////
   // Special chars needed by RocketPort
   pSetXOFFChar(Extension->Port,Extension->SpecialChars.XoffChar);
   pSetXONChar(Extension->Port,Extension->SpecialChars.XonChar);

   // Software input flow control
   // SERIAL_AUTO_RECEIVE
   if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
   {
     pEnRxSoftFlowCtl(Extension->Port);
   }
   else
   {
     pDisRxSoftFlowCtl(Extension->Port);
   }

   // Software output flow control
   if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
   {
      pEnTxSoftFlowCtl(Extension->Port);
   }
   else
   {
      pDisTxSoftFlowCtl(Extension->Port);
   }
}

#else  // rocketport code
{
   /////////////////////////////////////////////////////////////
   // set the baud rate....
   ProgramBaudRate(Extension, Extension->BaudRate);

   /////////////////////////////////////////////////////////////
   // set Line Control.... Data, Parity, Stop
   ProgramLineControl(Extension, &Extension->LineCtl);

   // HandFlow related options
   /////////////////////////////////////////////////////////////
   // set up RTS control

   Extension->Option &= ~OPTION_RS485_SOFTWARE_TOGGLE;
   switch(Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
   {
     case SERIAL_RTS_CONTROL: // RTS Should be asserted while open
       sSetRTS(Extension->ChP);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_RTS_HANDSHAKE: // RTS hardware input flow control
        // Rocket can't determine RTS state... indicate true for this option
       sEnRTSFlowCtl(Extension->ChP);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     break;

     case SERIAL_TRANSMIT_TOGGLE: // RTS transmit toggle enabled
       if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
       {  // normal case, emulate standard operation
         Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
         Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
         sClrRTS(Extension->ChP);
       }
       else 
       {  // hardware reverse case
         sEnRTSToggle(Extension->ChP);
         Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
       }
     break;

     default:
       // Is RTS_CONTROL off?
       sClrRTS(Extension->ChP);
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
     break;
   }

   if (Extension->Option & OPTION_RS485_OVERRIDE)  // 485 override
   {
     if (Extension->Option & OPTION_RS485_HIGH_ACTIVE)
     {  // normal case, emulate standard operation
       Extension->Option |= OPTION_RS485_SOFTWARE_TOGGLE;
       Extension->DTRRTSStatus &= ~SERIAL_RTS_STATE;
       sClrRTS(Extension->ChP);
     }
     else 
     {  // hardware reverse case
       sEnRTSToggle(Extension->ChP);
       Extension->DTRRTSStatus |= SERIAL_RTS_STATE;
     }
   }

   /////////////////////////////////////////////////////////////
   // set up DTR control

   // Should DTR be asserted when the port is opened?
   if(  Extension->HandFlow.ControlHandShake &
        (SERIAL_DTR_CONTROL|SERIAL_DTR_HANDSHAKE)
     )
   {
      sSetDTR(Extension->ChP);
      Extension->DTRRTSStatus |= SERIAL_DTR_STATE;
   }
   else
   {
      sClrDTR(Extension->ChP);
      Extension->DTRRTSStatus &= ~SERIAL_DTR_STATE;
   }

   /////////////////////////////////////////////////////////////
   // Set up CTS Flow Control
   if (Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
   {
      sEnCTSFlowCtl(Extension->ChP);
   }
   else
   {
      sDisCTSFlowCtl(Extension->ChP);
   }

   /////////////////////////////////////////////////////////////
   // Set up NULL stripping    OPTIONAL
   // fix: this was using RxCompare1 register, ioctl code using 0 so
   // changed to match.
   if (Extension->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING)
   {
      sEnRxIgnore0(Extension->ChP,0);
   }
   else
   {
      sDisRxCompare0(Extension->ChP);
   }

   /////////////////////////////////////////////////////////////
   // Set up Software Flow Control   OPTIONAL

   /////////////////////////////////////////////////////////////
   // Special chars needed by RocketPort
   sSetTxXOFFChar(Extension->ChP,Extension->SpecialChars.XoffChar);
   sSetTxXONChar(Extension->ChP,Extension->SpecialChars.XonChar);

   // SERIAL_AUTO_RECEIVE is taken care of by the driver

   // Software output flow control
   if (Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
   {
      sEnTxSoftFlowCtl(Extension->ChP);
   }
   else
   {
      sDisTxSoftFlowCtl(Extension->ChP);
      sClrTxXOFF(Extension->ChP);
   }
}
#endif

#ifdef S_RK
/*****************************************************************************
   Function : SetExtensionModemStatus
   Description: Reads and saves a copy of the modem control inputs,
                then fills out the ModemStatus member in the extension.
*****************************************************************************/
VOID
SetExtensionModemStatus(
    IN PSERIAL_DEVICE_EXTENSION extension
    )
{
   unsigned int ModemStatus = 0;  // start off with no status
   ULONG wstat;



   //MyKdPrint(D_Init, ("SetExtModemStat"))

   // ModemCtl is an image of the RocketPort's modem status
   // ModemStatus member is passed to host via IOCTL
#if DBG
   // this is called during isr.c poll, so put
   // some assertions where we have been burned before...
   if (extension->board_ext->config == NULL)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err0\n"))
     return;
   }
#ifdef S_RK
   if (!extension->board_ext->config->RocketPortFound)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err1\n"))
     return;
   }
#endif
   if (NULL == extension->ChP)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err2\n"))
     return;
   }
   if (0 == extension->ChP->ChanStat)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err3\n"))
     return;
   }
   if (NULL == extension->port_config)
   {
     MyKdPrint(D_Init, ("SetExtMdm Err4\n"))
     return;
   }
#endif

   // Read the port's modem control inputs and save off a copy
   extension->ModemCtl = sGetModemStatus(extension->ChP);

   if (extension->port_config->MapCdToDsr)  // if CD to DSR option, swap signals
   {
     // swap CD and DSR handling for RJ11 board owners,
     // so they can have pick between CD or DSR
     if ((extension->ModemCtl & (CD_ACT | DSR_ACT)) == CD_ACT)
     {
       // swap
       extension->ModemCtl &= ~CD_ACT;
       extension->ModemCtl |= DSR_ACT;
     }
     else if ((extension->ModemCtl & (CD_ACT | DSR_ACT)) == DSR_ACT)
     {
       extension->ModemCtl &= ~DSR_ACT;
       extension->ModemCtl |= CD_ACT;
     }
   }

   // handle RPortPlus RI signal
   if (extension->board_ext->config->IsRocketPortPlus)
   {
     if (sGetRPlusModemRI(extension->ChP))
          ModemStatus |=  SERIAL_RI_STATE;
     else ModemStatus &= ~SERIAL_RI_STATE;
   }

#ifdef RING_FAKE
    if (extension->port_config->RingEmulate)
    {
      if (extension->ring_timer != 0)  // RI on
           ModemStatus |=  SERIAL_RI_STATE;
      else ModemStatus &= ~SERIAL_RI_STATE;
    }
#endif

   if (extension->ModemCtl & COM_MDM_DSR)  // if DSR on
   {
     ModemStatus |= SERIAL_DSR_STATE;
     if (extension->TXHolding & SERIAL_TX_DSR)  // holding
     {
        extension->TXHolding &=  ~SERIAL_TX_DSR;  // clear holding
        // if not holding due to other reason
        if ((extension->TXHolding &
            (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
          sEnTransmit(extension->ChP);  // re-enable transmit
     }
   }
   else    // if DSR off
   {
     if (extension->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
     {
       if (!(extension->TXHolding & SERIAL_TX_DSR)) // not holding
       {
          extension->TXHolding |= SERIAL_TX_DSR;   // set holding
          sDisTransmit(extension->ChP);  // hold transmit
       }
     }
   }

   if (extension->ModemCtl & COM_MDM_CTS)  // if CTS on
   {
     ModemStatus |= SERIAL_CTS_STATE;
     if (extension->TXHolding & SERIAL_TX_CTS)  // holding
         extension->TXHolding &= ~SERIAL_TX_CTS;  // clear holding
   }
   else  // cts off
   {
     if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
     {
       if (!(extension->TXHolding & SERIAL_TX_CTS))  // not holding
             extension->TXHolding |= SERIAL_TX_CTS;   // set holding
     }
   }

   if (extension->ModemCtl & COM_MDM_CD)  // if CD on
   {
     ModemStatus |= SERIAL_DCD_STATE;
     if (extension->TXHolding & SERIAL_TX_DCD)  // holding
     {
        extension->TXHolding &=  ~SERIAL_TX_DCD;  // clear holding
        // if not holding due to other reason
        if ((extension->TXHolding & 
            (SERIAL_TX_DCD | SERIAL_TX_DSR | ST_XOFF_FAKE)) == 0)
          sEnTransmit(extension->ChP);  // re-enable transmit
     }
   }
   else    // if CD off
   {
     if (extension->HandFlow.ControlHandShake & SERIAL_DCD_HANDSHAKE)
     {
       if (!(extension->TXHolding & SERIAL_TX_DCD)) // not holding
       {
          extension->TXHolding |= SERIAL_TX_DCD;   // set holding
          sDisTransmit(extension->ChP);  // hold transmit
       }
     }
   }


   // handle holding detection if xon,xoff tx control activated
   if (extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
   {
     wstat = sGetChanStatusLo(extension->ChP);

     // check for tx-flowed off condition to report
     if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
     {
       if (!extension->TXHolding) // not holding
       {
         wstat = sGetChanStatusLo(extension->ChP);
         if ((wstat & (TXFIFOMT | TXSHRMT)) == TXSHRMT)
         {
           extension->TXHolding |= SERIAL_TX_XOFF; // holding
         }
       }
     }
     else  // clear xoff holding report
     {
       if (extension->TXHolding & SERIAL_TX_XOFF)
         extension->TXHolding &= ~SERIAL_TX_XOFF; // not holding
     }
   }

   extension->ModemStatus = ModemStatus;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\openclos.h ===
//--- openclos.h

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ForceExtensionSettings(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SetExtensionModemStatus(
    IN PSERIAL_DEVICE_EXTENSION extension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\opstr.c ===
/*-----------------------------------------------------------------------
 opstr.c - Option Strings.  These are strings which define the options
  associated with the driver at the three levels: driver, device, port.
  This code is special, in that the source may be used for both driver
  and setup program, so consists only of the strings which can be shared
  in source code.

  This has expanded to other code which should be shared by
  both setup program and driver.

Copyright 1998 Comtrol(TM) Corporation.
|-----------------------------------------------------------------------*/
#include "precomp.h"

// driver options
const char szVerboseLog[]   = {"VerboseLog"};
const char szNumDevices[]   = {"NumDevices"};
const char szNoPnpPorts[]     = {"NoPnpPorts"};
const char szScanRate[]     = {"ScanRate"};
const char szModemCountry[] = {"ModemCountry"};
const char szGlobalRS485[]  = {"GlobalRS485Options"};

// device options
//const char szStartComIndex[] = {"StartComIndex"};
const char szNumPorts[]      = {"NumPorts"};
const char szMacAddr[]       = {"MacAddr"};
const char szBackupServer[]  = {"BackupServer"};
const char szBackupTimer[]   = {"BackupTimer"};
const char szName[]          = {"Name"};
const char szModelName[]     = {"ModelName"};
const char szIoAddress[]     = {"IoAddress"};
const char szModemDevice[]   = {"ModemDevice"};
const char szHubDevice[]     = {"HubDevice"};
const char szClkRate[]       = {"ClkRate"};
const char szClkPrescaler[]  = {"ClkPrescaler"};


// port options
const char szWaitOnTx[]      = {"WaitOnTx"};
const char szRS485Override[] = {"RS485Override"};
const char szRS485Low[]      = {"RS485Low"};
const char szTxCloseTime[]   = {"TxCloseTime"};
const char szLockBaud[]      = {"LockBaud"};
const char szMap2StopsTo1[]  = {"Map2StopsTo1"};
const char szMapCdToDsr[]    = {"MapCdToDsr"};
const char szRingEmulate[]    = {"RingEmulate"};

Our_Options driver_options[] = {
  // driver options
  {szVerboseLog,     OP_VerboseLog   , OP_T_DWORD, OP_F_VSRK},
  {szNumDevices,     OP_NumDevices   , OP_T_DWORD, OP_F_VSRK},
#ifdef NT50
  {szNoPnpPorts,       OP_NoPnpPorts     , OP_T_DWORD, OP_F_VSRK},
#endif
  {szScanRate,       OP_ScanRate     , OP_T_DWORD, OP_F_VSRK},
  {szModemCountry,   OP_ModemCountry , OP_T_DWORD, OP_F_VSRK},
  {szGlobalRS485,    OP_GlobalRS485  , OP_T_DWORD, OP_F_VSRK},
  {NULL,0,0,0}
};

Our_Options device_options[] = {
  // device options
//  {szStartComIndex,  OP_StartComIndex, OP_T_DWORD , OP_F_VSRK},
  {szNumPorts,       OP_NumPorts     , OP_T_DWORD , OP_F_VSRK},
#ifdef S_VS
  {szMacAddr,        OP_MacAddr      , OP_T_STRING, OP_F_VS},
  {szBackupServer,   OP_BackupServer , OP_T_DWORD , OP_F_VS},
  {szBackupTimer,    OP_BackupTimer  , OP_T_DWORD , OP_F_VS},
#endif
  {szName,           OP_Name         , OP_T_STRING, OP_F_VSRK},
  {szModelName,      OP_ModelName    , OP_T_STRING, OP_F_VSRK},
#ifdef S_RK
#ifndef NT50
  {szIoAddress,      OP_IoAddress    , OP_T_DWORD , OP_F_RK},
#endif
#endif
  {szModemDevice,    OP_ModemDevice  , OP_T_DWORD , OP_F_VSRK},
  {szHubDevice,      OP_HubDevice    , OP_T_DWORD , OP_F_VS},
  {szClkRate,        OP_ClkRate      , OP_T_DWORD , OP_F_VSRK},
  {szClkPrescaler,   OP_ClkPrescaler , OP_T_DWORD , OP_F_VSRK},
  {NULL,0,0,0}
};

Our_Options port_options[] = {
  // port options
  {szWaitOnTx,       OP_WaitOnTx     , OP_T_DWORD,  OP_F_VSRK},
  {szRS485Override,  OP_RS485Override, OP_T_DWORD,  OP_F_VSRK},
  {szRS485Low,       OP_RS485Low     , OP_T_DWORD,  OP_F_VSRK},
  {szTxCloseTime,    OP_TxCloseTime  , OP_T_DWORD,  OP_F_VSRK},
  {szLockBaud,       OP_LockBaud     , OP_T_DWORD,  OP_F_VSRK},
  {szMap2StopsTo1,   OP_Map2StopsTo1 , OP_T_DWORD,  OP_F_VSRK},
  {szMapCdToDsr,     OP_MapCdToDsr   , OP_T_DWORD,  OP_F_VSRK},
  {szName,           OP_PortName     , OP_T_STRING, OP_F_VSRK},
  {szRingEmulate,    OP_RingEmulate  , OP_T_DWORD,  OP_F_VSRK},
  {NULL,0,0,0}
};

#define INFO_WANT_NUMPORTS        0
#define INFO_WANT_MODEM_DEVICE    1
#define INFO_WANT_HUB_DEVICE      2
#define INFO_WANT_PORTS_PER_AIOP  3
#define INFO_WANT_DEF_CLOCK_PRESC 4

static int IdToInfo(int id, int *ret_dword, int info_wanted);

/*-----------------------------------------------------------------
  IdToInfo -
|------------------------------------------------------------------*/
static int IdToInfo(int id, int *ret_val, int info_wanted)
{ 
 int num_ports = 8;
 int modem_device = 0;
 int hub_device = 0;
 int ret_stat = 0;  // ok
 
    switch (id)
    {
      case PCI_DEVICE_RPLUS2:
      case PCI_DEVICE_422RPLUS2:
        num_ports = 2;
      break;

      case PCI_DEVICE_RPLUS4:
        num_ports = 4;
      break;

      case PCI_DEVICE_4Q  :
        num_ports = 4;
      break;

      case PCI_DEVICE_RMODEM4:
        num_ports = 4;
        modem_device = 1;
      break;

      case PCI_DEVICE_4RJ :
        num_ports = 4;
      break;
      case PCI_DEVICE_8RJ :
        num_ports = 8;
      break;
      case PCI_DEVICE_8O  :
        num_ports = 8;
      break;
      case PCI_DEVICE_8I  :
        num_ports = 8;
      break;
      case PCI_DEVICE_RPLUS8:
        num_ports = 8;
      break;
      case PCI_DEVICE_SIEMENS8:
        num_ports = 8;
      break;

      case PCI_DEVICE_16I :
        num_ports = 16;
      break;
      case PCI_DEVICE_SIEMENS16:
        num_ports = 16;
      break;

      case PCI_DEVICE_32I :
        num_ports = 32;
      break;

      case PCI_DEVICE_RMODEM6 :
        num_ports = 6;
        modem_device = 1;
      break;

      case ISA_DEVICE_RPORT4:  // rocketport
        num_ports = 4;
      break;
      case ISA_DEVICE_RPORT8:
        num_ports = 8;
      break;
      case ISA_DEVICE_RPORT16:
        num_ports = 16;
      break;
      case ISA_DEVICE_RPORT32:
        num_ports = 32;
      break;

      case ISA_DEVICE_RMODEM4:  // rocketmodem isa
        num_ports = 4;
        modem_device = 1;
      break;
      case ISA_DEVICE_RMODEM8:  // rocketmodem isa
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_VS1000:
        num_ports = 16;  // vs1000, base is 16, expandable
      break;
      case NET_DEVICE_VS2000:  // vs2000, base is 8?
        num_ports = 8;
        modem_device = 1;
      break;
      case NET_DEVICE_RHUB8:  // vshub-8 port
        num_ports = 8;
        hub_device = 1;
      break;
      case NET_DEVICE_RHUB4:  // vshub-4 port
        num_ports = 4;
        hub_device = 1;
      break;
      default:
        ret_stat = 1; // err, unknown device
      break;
    }

  switch (info_wanted)
  {
    case INFO_WANT_NUMPORTS:
      *ret_val = num_ports;
    break;

    case INFO_WANT_MODEM_DEVICE:
      *ret_val = modem_device;
    break;

    case INFO_WANT_HUB_DEVICE:
      *ret_val = hub_device;
    break;

#if 0
    case INFO_WANT_PORTS_PER_AIOP:
        if (PortsPerAiop > num_ports)
            PortsPerAiop = num_ports;
      *ret_val = PortsPerAiop;

    case INFO_WANT_DEF_CLOCK_PRESC:
      *ret_val = clk_prescaler;
    break;
#endif

    default:
      ret_stat = 2; // unkown info request
    break;
  }
  return ret_stat;
}

/*-----------------------------------------------------------------
  id_to_num_ports - pci model-id number used, rest come from NT5 .inf
    files.
|------------------------------------------------------------------*/
int id_to_num_ports(int id)
{ 
 int stat;
 int num_ports;

  stat = IdToInfo(id, &num_ports, INFO_WANT_NUMPORTS);
  return num_ports;
}

/*-----------------------------------------------------------------
  IsHubDevice -
|------------------------------------------------------------------*/
int IsHubDevice(int Hardware_ID)
{ 
 int stat;
 int ishub;

  stat = IdToInfo(Hardware_ID, &ishub, INFO_WANT_HUB_DEVICE);
  return ishub;
}

/*-----------------------------------------------------------------
  IsModemDevice -
|------------------------------------------------------------------*/
int IsModemDevice(int Hardware_ID)
{ 
 int stat;
 int ismodemdev;

  stat = IdToInfo(Hardware_ID, &ismodemdev, INFO_WANT_MODEM_DEVICE);
  return ismodemdev;
}

/*-----------------------------------------------------------------
  HdwIDStrToID - Parse the hardware ID string obtained by the WinNT
    Pnp system.
    This is broke if we ever get ID's starting digit >= HEX(A,B..)
|------------------------------------------------------------------*/
int HdwIDStrToID(int *Hardware_ID, char *idstr)
{ 
  char *s = idstr;
#define _IS_STR_DIGIT(c) ((c >= '0') && (c <= '9'))
#define _IS_STR_LET_D(c) ((c == 'D') || (c == 'd'))

  if (strlen(s) < 12)  // a isa hardware id
  {
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
  }
  else // a pci hardware id
  {
    while ( (*s != 0) && (!_IS_STR_LET_D(*s)) ) // find "DEV_
      ++s;
    if (*s != 0)
      ++s;  // pass up the 'D'
    while ( (*s != 0) && (!_IS_STR_DIGIT(*s)) )  // find digit
      ++s;
    // asume we found "DEV_000X"
  }

  if (*s == 0)
  {
    *Hardware_ID = 0;  // unknown
    return 1;  // err
  }

  *Hardware_ID = gethint(s, NULL);
  return 0;  // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\options.h ===
//--- options.h

int SaveRegPath(PUNICODE_STRING RegistryPath);

int MakeRegPath(CHAR *optionstr);

int write_device_options(PSERIAL_DEVICE_EXTENSION ext);

int read_device_options(PSERIAL_DEVICE_EXTENSION ext);

int read_driver_options(void);

int SetOptionStr(char *option_str);

#if 0
int reg_get_str(IN WCHAR *RegPath,
                       int reg_location,
                       const char *str_id,
                       char *dest,
                       int max_dest_len);

int reg_get_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG *dest);

int reg_set_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG val);
#endif

int write_port_name(PSERIAL_DEVICE_EXTENSION dev_ext, int port_index);
int write_dev_mac(PSERIAL_DEVICE_EXTENSION dev_ext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\pnpadd.c ===
/*----------------------------------------------------------------------
 pnpadd.c - Handle pnp adding devices.
|----------------------------------------------------------------------*/
#include "precomp.h"

#ifdef NT50

NTSTATUS AddBoardDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj);

NTSTATUS AddPortDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj,
               IN  int port_index);

NTSTATUS CheckPortName(
               IN PDEVICE_OBJECT Pdo,
               IN PSERIAL_DEVICE_EXTENSION ParentExt,
               IN int port_index);

#define CFG_ID_ISA_BRD_INDEX  0
#define CFG_ID_NODE_INDEX     1
static int read_config_data(PDEVICE_OBJECT Pdo, int *ret_val, int val_id);
static int write_config_data(PDEVICE_OBJECT Pdo, int val, int val_id);
static int derive_unique_node_index(int *ret_val);
static int GetPnpIdStr(PDEVICE_OBJECT Pdo, char *ret_val);


/*----------------------------------------------------------------------
 SerialAddDevice -
    This routine creates a functional device object for boards or
    com ports in the system and attaches them to the physical device
    objects for the boards or ports.

Arguments:
    DriverObject - a pointer to the object for this driver
    PhysicalDeviceObject - a pointer to the physical object we need to attach to

Return Value:
    status from device creation and initialization
|----------------------------------------------------------------------*/
NTSTATUS SerialAddDevice(
               IN PDRIVER_OBJECT DriverObject,
               IN PDEVICE_OBJECT Pdo)
{
   PDEVICE_OBJECT  fdo         = NULL;
   PDEVICE_OBJECT  lowerDevice = NULL;
   PDEVICE_OBJECT  NewDevObj = NULL;
   NTSTATUS        status;
#if DBG_STACK
   int i;
#endif
   int stat;
   int board_device = 1;  // asume pnp board device(not pnp port)
   //PDEVICE_OBJECT   deviceOjbect;
   PSERIAL_DEVICE_EXTENSION    deviceExtension;
   ULONG resultLength;
   USTR_240 *us;  // equal to 240 normal chars length
   char *ptr;
   int port_index;

   // Using stack array instead of static buffer for unicode conversion

   char cstr[320];

   //char temp_szNt50DevObjName[80];
#if DBG_STACK
   DWORD stkchkend;
   DWORD stkchk;
   DWORD *stkptr;
#endif

   MyKdPrint(D_PnpAdd,("RK:SerialAddDevice Start DrvObj:%x, PDO:%x\n",
      DriverObject, Pdo))

   MyKdPrint(D_Pnp, ("SerialAddDevice\n"))
#if DBG_STACK
   stkchk = 0;
   stkptr = (DWORD *)&DriverObject;
   for (i=0; i<50; i++)
   {
     stkchk += *stkptr++;
   }
#endif

   //PAGED_CODE();

   if (Pdo == NULL) {
      //  Bugbug: This is where enumeration occurs.
      //           One possible use for this is to add the user defined
      //           ports from the registry
      // For now: just return no more devices
      MyKdPrint(D_Error, ("NullPDO.\n"))
      return (STATUS_NO_MORE_ENTRIES);
   }

   us = ExAllocatePool(NonPagedPool, sizeof(USTR_240));
   if ( us == NULL ) {
     MyKdPrint(D_Error, ("SerialAddDevice no memory.\n"))
     return STATUS_INSUFFICIENT_RESOURCES;
   }

      // configure the unicode string to: point the buffer ptr to the wstr.
   us->ustr.Buffer = us->wstr;
   us->ustr.Length = 0;
   us->ustr.MaximumLength = sizeof(USTR_240) - sizeof(UNICODE_STRING);

   // get the friendly name
   // "Comtrol xxxx xx" for board, "Comtrol Port(COM24)" for port.
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyFriendlyName,
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("FriendlyName:%s\n", ptr))

   // get the class-name
   // "MultiPortSerial" for board, "Ports" for port.
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyClassName,  // Ports
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("ClassName:%s\n", ptr))
   if (my_toupper(*ptr) == 'P')  // "Ports"
   {
     MyKdPrint(D_Pnp, ("A Port!\n"))
     board_device = 0;  // its a port pnp device
   }
   // else it's the default: a board device

   // get the dev-desc
   // "RocketPort Port0" for port, "RocketPort 8 Port, ISA-BUS" for board
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyDeviceDescription,
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("DevDesc:%s\n", ptr))

   // Find out what the PnP manager thinks my NT Hardware ID is
   // "CtmPort0000" for port, "rckt1002" for isa-board
   // for pci we are getting a huge string, 400 bytes long, not good...
   status = IoGetDeviceProperty (Pdo,
                                 DevicePropertyHardwareID,  // port0000
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   MyKdPrint(D_Pnp, ("status:%d\n", status))
   us->ustr.Length = (USHORT) resultLength;
   MyKdPrint(D_Pnp, ("Len:%d\n",resultLength))
//   ptr = UToC1(&us->ustr);
   ptr = UToCStr( cstr,
	              &us->ustr,
				  sizeof( cstr ));
   MyKdPrint(D_Pnp, ("DevHdwID:%s\n", ptr))

   if (board_device)  // record board type according to pnp
   {
//     if (strlen(ptr) < 12)
//     {
//       i = gethint(&ptr[4], NULL);
//       MyKdPrint(D_Pnp, ("HdwID:%d\n", i))
//       Hardware_Id = i;
//     }
   }
   else // its a port pnp device, find the port-index
   {
     while ((*ptr != 0) && (*ptr != '0'))
       ++ptr;
     port_index = getint(ptr, NULL);
     MyKdPrint(D_Pnp, ("port_index:%d\n", port_index))
   }

#if 0
   // key name
   // {50906CB8-BA12-11D1-BF5D-0000F805F530}\0001 for board
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyDriverKeyName,  // 4D36....
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
   MyKdPrint(D_Pnp, ("KeyName:%s\n", UToC1(&us->ustr)))


   // Find out what the PnP manager thinks my NT Hardware ID is
   // \Device\003354  typical
   status = IoGetDeviceProperty (Pdo, 
                                 DevicePropertyPhysicalDeviceObjectName,   // \Device\003354
                                 us->ustr.MaximumLength,
                                 us->ustr.Buffer,
                                 &resultLength);
   us->ustr.Length = (USHORT) resultLength;
   MyKdPrint(D_Pnp, ("DevName:%s\n", UToC1(&us->ustr)))

   if (board_device)
   {
     int i,j;
     // we need to use this later as this is what our config data is
     // stored under.  Since we want to read in our config before
     // creating the board and port extensions(where the config
     // record eventually ends up), we setup the first entry in
     // the static array of device configuration records as our
     // own as a temporary measure so our read options routine
     // has a place to put the config data.
     strcpy(temp_szNt50DevObjName, UToC1(&us->ustr));
     // strip off the forward slashes
     i=0;
     j=0;
     while (temp_szNt50DevObjName[i] != 0)
     {
       if (temp_szNt50DevObjName[i] != '\\')
         temp_szNt50DevObjName[j++] = temp_szNt50DevObjName[i];
       i++;
     }
     temp_szNt50DevObjName[j] = 0;
   }
#endif
   ExFreePool(us);
   us = NULL;

   MyKdPrint(D_Pnp, ("CreateFdo\n"))

   if (board_device)
   {
      status = AddBoardDevice(DriverObject, Pdo, &NewDevObj);
      if (status != STATUS_SUCCESS)
      {
        MyKdPrint(D_Error, ("Err, Creating Board Obj\n"))
        return status;
      }
      deviceExtension = NewDevObj->DeviceExtension;
      //strcpy(deviceExtension->config->szNt50DevObjName, temp_szNt50DevObjName);

      // read in our device configuration from the registry
      stat = read_device_options(deviceExtension);

   }  // board device
   else
   {
      status = AddPortDevice(DriverObject, Pdo, &NewDevObj, port_index);
   }

   if (status != STATUS_SUCCESS)
   {
     MyKdPrint(D_Error,("Error on NewPort Create!\n"))

     return status;
   }
   fdo = NewDevObj;
 
   // Layer our FDO on top of the PDO
   // The return value is a pointer to the device object to which the
   //    fdo is actually attached.
   lowerDevice = IoAttachDeviceToDeviceStack(fdo, Pdo);

   MyKdPrint(D_PnpAdd,("RK:SerialAddDevice New FDO:%x, Ext:%x TopOfStack:%x\n",
        fdo, fdo->DeviceExtension, lowerDevice))

   // No status. Do the best we can.
   MyAssert(lowerDevice);

   // fdo source, pdo is target, save handle to lower device object
   deviceExtension                     = fdo->DeviceExtension;
   deviceExtension->LowerDeviceObject  = lowerDevice;
   deviceExtension->Pdo = Pdo;  // save off the handle to the pdo

   // Set the stack requirement for this device object to 2 + the size of the 
   // lower device's stack size.  This will allow the same Irp that comes in 
   // for Open and Close calls to be used for the PoCallDriver calls to change 
   // the power state of the device.
   // fdo->StackSize = lowerDevice->StackSize + 2;

   fdo->Flags    |= DO_POWER_PAGABLE;

#if DBG_STACK
   stkchkend = 0;
   stkptr = (DWORD *)&DriverObject;
   for (i=0; i<50; i++)
   {
     stkchkend += *stkptr++;
   }
   if (stkchkend != stkchk)
   {
     MyKdPrint(D_Error, ("Err, ******** STACK CHECK FAIL!!!!\n"))
   }
   else
   {
     MyKdPrint(D_Error, ("OK Stack chk\n"))
   }
#endif

   MyKdPrint(D_PnpAdd, ("End SerialAddDevice\n"))

   MyKdPrint(D_Pnp, ("End SerialAddDevice\n"))
   return status;
}

/*----------------------------------------------------------------------
  AddBoardDevice - Setup and Create a board device in response to
    AddDevice ioctl.
|----------------------------------------------------------------------*/
NTSTATUS AddBoardDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj)
{
   PSERIAL_DEVICE_EXTENSION NewExtension = NULL;
   NTSTATUS                    status          = STATUS_SUCCESS;
   char tmpstr[110];
   ULONG Hardware_ID = 0;
   int num_ports = 0;
   int stat;
   static int max_isa_board_index = 0;
   int device_node_index = -1;
   int isa_board_index = -1;

   MyKdPrint(D_Pnp, ("AddBoardDevice\n"))

     // Find out what the PnP manager thinks my NT pnp Hardware ID is
   tmpstr[0] = 0;
   stat = GetPnpIdStr(Pdo, tmpstr);
   if (stat)
   {
     MyKdPrint(D_Error, ("Err, HdwID 1B\n"))
   }
   MyKdPrint(D_Test, ("DevHdwID:%s\n", tmpstr))

     // Parse this info, tells us what type of board we have
   stat = HdwIDStrToID(&Hardware_ID, tmpstr);
   if (stat)
   {
     MyKdPrint(D_Error, ("Err, HdwID 1A:%s\n", tmpstr))
   }
   MyKdPrint(D_Pnp, ("HdwID:%x\n", Hardware_ID))

     // Read in our Node Index, see if we are new...
   stat = read_config_data(Pdo, &device_node_index, CFG_ID_NODE_INDEX);

   if (stat)  // not exist
   {
     derive_unique_node_index(&device_node_index);
     MyKdPrint(D_Test, ("Derive Node ID:%d\n", device_node_index))
     stat = write_config_data(Pdo, device_node_index, CFG_ID_NODE_INDEX);
   }
   else
   {
     MyKdPrint(D_Test, ("Node ID:%d\n", device_node_index))
   }
   if (device_node_index < 0)
       device_node_index = 0;

#ifdef S_RK
   // try to order the ISA boards
   if ((Hardware_ID >= 0x1000) && (Hardware_ID <= 0x2fff))  // its ISA
   {
     stat = read_config_data(Pdo, &isa_board_index, CFG_ID_ISA_BRD_INDEX);
     MyKdPrint(D_Pnp,("Read isa_board_index:%d\n", isa_board_index))
   }
#endif

   //----- create a board device
   Driver.Stop_Poll = 1;  // flag to stop poll access

   if (Driver.driver_ext == NULL)
   {
     status = CreateDriverDevice(Driver.GlobalDriverObject,
                                 &NewExtension);  // create the driver device
#ifdef S_VS
     init_eth_start();
#endif
   }

   status = CreateBoardDevice(Driver.GlobalDriverObject,
                              &NewExtension);  // create the board device

   *NewDevObj = NewExtension->DeviceObject;
   if (status != STATUS_SUCCESS)
   {
      Driver.Stop_Poll = 0;  // flag to stop poll access
      Eprintf("CreateBoardDevice Err1A");
      return status;
   }

   // DoPnpAssoc(Pdo);

     // copy over our key name used to find config info in the registry
   Sprintf(NewExtension->config->szNt50DevObjName, "Device%d", device_node_index);
#if 0
   //strcpy(NewExtension->config->szNt50DevObjName, PnpKeyName);
#endif

   NewExtension->config->Hardware_ID = Hardware_ID;
   num_ports = id_to_num_ports(Hardware_ID);
   MyKdPrint(D_Test, ("NumPorts:%d\n", num_ports))

   // read in our device configuration from the registry
   stat = read_device_options(NewExtension);

   //if (!(Hardware_ID == NET_DEVICE_VS1000))  // jam in
   //  NewExtension->config->NumPorts = num_ports;

   if (NewExtension->config->NumPorts == 0)
     NewExtension->config->NumPorts = num_ports;

   // check for ModemDevice, etc.
   if (IsModemDevice(Hardware_ID))
     NewExtension->config->ModemDevice = 1;

   MyKdPrint(D_Pnp, ("Num Ports:%d\n",NewExtension->config->NumPorts))

#ifdef S_RK
   // try to order the ISA boards
   if ((Hardware_ID >= 0x1000) && (Hardware_ID <= 0x2fff))  // its ISA
   {
     if (isa_board_index == -1)  // new
     {
       isa_board_index = max_isa_board_index;
       stat = write_config_data(Pdo, isa_board_index, CFG_ID_ISA_BRD_INDEX);
       MyKdPrint(D_Pnp,("Save IsaIndex:%d\n", isa_board_index))
     }
     // bump so next isa board gets new index
     if (max_isa_board_index >= isa_board_index)
       max_isa_board_index = isa_board_index + 1;
     NewExtension->config->ISABrdIndex = isa_board_index;
   }  // isa board
#endif

   Driver.Stop_Poll = 0;  // flag to stop poll access

   status = STATUS_SUCCESS;
   return status;
}

/*----------------------------------------------------------------------
  derive_unique_node_index -
|----------------------------------------------------------------------*/
static int derive_unique_node_index(int *ret_val)
{
  HANDLE DrvHandle = NULL;
  HANDLE DevHandle = NULL;
  char tmpstr[40];
  int i, stat;

  // force a creation of "Parameters" if not exist
  stat = our_open_driver_reg(&DrvHandle, KEY_ALL_ACCESS);

  for (i=0; i< 100; i++)
  {
    Sprintf(tmpstr,"Device%d", i);
    stat = our_open_key(&DevHandle,
                 DrvHandle, tmpstr,  KEY_READ);

    if (stat)  // does not exist
    {
      // create it, so next one won't pick up the same
      stat = our_open_key(&DevHandle,
                   DrvHandle, tmpstr,  KEY_ALL_ACCESS);

      ZwClose(DevHandle);
      ZwClose(DrvHandle);
      *ret_val = i;
      return 0;  // ok
    }
  }

  ZwClose(DevHandle);
  ZwClose(DrvHandle);
  return 1;  // err
}

/*----------------------------------------------------------------------
  GetPnpIdStr - 
|----------------------------------------------------------------------*/
static int GetPnpIdStr(PDEVICE_OBJECT Pdo, char *ret_val)
{
  NTSTATUS status = STATUS_SUCCESS;
  UNICODE_STRING ustr;
  ULONG resultLength = 0;
  char *ptr;

   // configure the unicode string to: point the buffer ptr to the wstr.
   ustr.Buffer = ExAllocatePool(PagedPool, 1002);
   if ( ustr.Buffer == NULL ) {
     return -1;
   }
   ustr.Length = 0;
   ustr.MaximumLength = 1000;

   MyKdPrint(D_Pnp, ("AddBoardDevice\n"))

   // Find out what the PnP manager thinks my NT Hardware ID is
   // "CtmPort0000" for port, "rckt1002" for isa-board
   // for pci we are getting a multi-wstring, 400 bytes long with
   //  "PCI\VEN_11FE&DEV_0003&SUBSYS00000...",0,"PCI\VEN.."
   status = IoGetDeviceProperty (Pdo,
                                 DevicePropertyHardwareID,  // port0000
                                 ustr.MaximumLength,
                                 ustr.Buffer,
                                 &resultLength);
   ustr.Length = (USHORT) resultLength;
   if (ustr.Length > 100)
       ustr.Length = 100;  // limit
   ptr = UToC1(&ustr);

   strcpy(ret_val, ptr);

   ExFreePool(ustr.Buffer);
   MyKdPrint(D_Pnp, ("DevHdwID:%s\n", ret_val))
  return 0;
}

#if 0
/*----------------------------------------------------------------------
  DoPnpAssoc - Weird pnp stuff I haven't figured out yet
|----------------------------------------------------------------------*/
static int DoPnpAssoc(PDEVICE_OBJECT Pdo)
{
   if (!Driver.NoPnpPorts)
   {
#ifdef DO_BUS_SHINGLES
     //
     // Tell the PlugPlay system that this device will need an interface
     // device class shingle.
     //
     // It may be that the driver cannot hang the shingle until it starts
     // the device itself, so that it can query some of its properties.
     // (Aka the shingles guid (or ref string) is based on the properties
     // of the device.)
     //
     status = IoRegisterDeviceInterface (
               Pdo,  // BusPhysicalDeviceObject
               (LPGUID) &GUID_CTMPORT_BUS_ENUMERATOR,
               NULL, // No ref string
               &NewExtension->DevClassAssocName);
#endif
        //
        // If for any reason you need to save values in a safe location that
        // clients of this DeviceClassAssociate might be interested in reading
        // here is the time to do so, with the function
        // IoOpenDeviceClassRegistryKey
        // the symbolic link name used is was returned in
        // deviceData->DevClassAssocName (the same name which is returned by
        // IoGetDeviceClassAssociations and the SetupAPI equivs.
        //

        //status = IoGetDeviceProperty (BusPhysicalDeviceObject,
        //                              DevicePropertyPhysicalDeviceObjectName,
        //                              0,
        //                              NULL,
        //                              &nameLength);
        //IoGetDeviceProperty (BusPhysicalDeviceObject,
        //                     DevicePropertyPhysicalDeviceObjectName,
        //                     nameLength,
        //                     deviceName,
        //                     &nameLength);
        //Game_KdPrint (deviceData, GAME_DBG_SS_TRACE,
        //              ("AddDevice: %x to %x->%x (%ws) \n",
        //               deviceObject,
        //               NewExtension->TopOfStack,
        //               BusPhysicalDeviceObject,
        //               deviceName));


        //
        // Turn on the shingle and point it to the given device object.
        //
#ifdef DO_BUS_SHINGLES
        status = IoSetDeviceInterfaceState (
                        &NewExtension->DevClassAssocName,
                        TRUE);

        if (!NT_SUCCESS (status)) {
            Game_KdPrint (deviceData, GAME_DBG_SS_ERROR,
                          ("AddDevice: IoSetDeviceClass failed (%x)", status));
            return status;
        }
#endif
    //IoInvalidateDeviceRelations (NewExtension->DeviceObject, BusRelations);
   }  // !NoPnpPorts
#endif

/*----------------------------------------------------------------------
  write_config_data - 
|----------------------------------------------------------------------*/
static int write_config_data(PDEVICE_OBJECT Pdo, int val, int val_id)
{
  HANDLE                      keyHandle;
  NTSTATUS                    status          = STATUS_SUCCESS;
  USTR_40 uname;

  status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DRIVER, 
              KEY_WRITE, &keyHandle);

  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Error, ("Err7V\n"))
    return 1;
  }
  switch(val_id)
  {
    case CFG_ID_ISA_BRD_INDEX:
      CToUStr((PUNICODE_STRING)&uname, "isa_board_index", sizeof(uname));
    break;

    case CFG_ID_NODE_INDEX:
      CToUStr((PUNICODE_STRING)&uname, "CtmNodeId", sizeof(uname));
    break;
  }
  status = ZwSetValueKey (keyHandle,
                          (PUNICODE_STRING) &uname,
                          0,  // type optional
                          REG_DWORD,
                          &val,
                          sizeof(REG_DWORD));
 
  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Error, ("Err8V\n"))
  }
  ZwClose(keyHandle);
  return 0;
}

/*----------------------------------------------------------------------
  read_config_data - 
|----------------------------------------------------------------------*/
static int read_config_data(PDEVICE_OBJECT Pdo, int *ret_val, int val_id)
{
   HANDLE                      keyHandle;
   NTSTATUS                    status          = STATUS_SUCCESS;
   ULONG tmparr[100];
   USTR_40 uname;
   PKEY_VALUE_PARTIAL_INFORMATION parInfo =
     (PKEY_VALUE_PARTIAL_INFORMATION) &tmparr[0];
   ULONG length;
   int ret_stat = 1;  // err

   //----- go grab some configuration info from registry
   // PLUGPLAY_REGKEY_DRIVER opens up the control\class\{guid}\node
   // PLUGPLAY_REGKEY_DEVICE opens up the enum\enum-type\node\Device Parameters
   status = IoOpenDeviceRegistryKey(Pdo,
                                    PLUGPLAY_REGKEY_DRIVER,
                                    STANDARD_RIGHTS_READ,
                                    &keyHandle);

   if (!NT_SUCCESS(status))
   {
     return 2;  // err
   }
   switch(val_id)
   {
     case CFG_ID_ISA_BRD_INDEX:
       CToUStr((PUNICODE_STRING)&uname, "isa_board_index", sizeof(uname));
     break;

     case CFG_ID_NODE_INDEX:
       CToUStr((PUNICODE_STRING)&uname, "CtmNodeId", sizeof(uname));
     break;
   }
   // try to order the ISA boards
   status = ZwQueryValueKey (keyHandle,
                             (PUNICODE_STRING) &uname,
                             KeyValuePartialInformation,
                             parInfo,
                             sizeof(tmparr),
                             &length);

   if (NT_SUCCESS(status))
   {
     if (parInfo->Type == REG_DWORD)
     {
       ret_stat = 0;  // ok
       *ret_val = *((ULONG *) &parInfo->Data[0]);
       //MyKdPrint(D_Pnp,("Read isa_board_index:%d\n", isa_board_index))
     }
   }
   ZwClose(keyHandle);

   return ret_stat;
}
/*----------------------------------------------------------------------
  AddPortDevice - Setup and Create a pnp port device in response to
    AddDevice ioctl.  This can be caused by either:
      * pdo port objects ejected from our driver at board startup.
|----------------------------------------------------------------------*/
NTSTATUS AddPortDevice(
               IN  PDRIVER_OBJECT DriverObject,
               IN  PDEVICE_OBJECT Pdo,
               OUT PDEVICE_OBJECT *NewDevObj,
               IN  int port_index)
{
   NTSTATUS status = STATUS_SUCCESS;


   PSERIAL_DEVICE_EXTENSION NewExtension;
   PSERIAL_DEVICE_EXTENSION ext;
   PSERIAL_DEVICE_EXTENSION ParExt;

   MyKdPrint(D_Pnp, ("AddPortDevice\n"))

   // Find the parent device
   ext = (PSERIAL_DEVICE_EXTENSION) Pdo->DeviceExtension;
   if (ext == NULL)
   {
     MyKdPrint(D_Pnp, ("Er7E\n"))
     return STATUS_SERIAL_NO_DEVICE_INITED;
   }
   else
     ParExt = ext->board_ext;

   CheckPortName(Pdo, ParExt, port_index);

   //----- create a port device
   Driver.Stop_Poll = 1;  // flag to stop poll access

   status = CreatePortDevice(
                           Driver.GlobalDriverObject,
                           ParExt, // parent ext.
                           &NewExtension,  // new device ext.
                           port_index,  // port index, channel number
                           1);  // is_fdo

   if (status != STATUS_SUCCESS)
   {
     Driver.Stop_Poll = 0;  // flag to stop poll access
     MyKdPrint(D_Error, ("Error Creating Port\n"))
     return STATUS_SERIAL_NO_DEVICE_INITED;
   }

   if (status == STATUS_SUCCESS)
   {
     *NewDevObj = NewExtension->DeviceObject;

     status = StartPortHardware(NewExtension, port_index);

     if (status != STATUS_SUCCESS)
     {
       Driver.Stop_Poll = 0;  // flag to stop poll access
       MyKdPrint(D_Error, ("5D\n"))
       // bugbug: should delete our port here
       return STATUS_SERIAL_NO_DEVICE_INITED;
     }
   }

   if (!NT_SUCCESS(status)) {
      Driver.Stop_Poll = 0;  // flag to stop poll access
      Eprintf("CreateBoardDevice Err1A");
      return status;
   }

   Driver.Stop_Poll = 0;  // flag to stop poll access

   status = STATUS_SUCCESS;
   return status;
}

/*----------------------------------------------------------------------
  CheckPortName - Make sure the port-name for us in the registry works.
    Get the pnp-port name held in the enum branch, if ours does not match,
    then change it to match(use the pnp-port name.)
|----------------------------------------------------------------------*/
NTSTATUS CheckPortName(
               IN PDEVICE_OBJECT Pdo,
               IN PSERIAL_DEVICE_EXTENSION ParentExt,
               IN int port_index)
{
   HANDLE    keyHandle;
   NTSTATUS  status;
   char namestr[20];

   PORT_CONFIG *port_config;

   MyKdPrint(D_Pnp, ("CheckPortName\n"))

   //----- go grab PORTNAME configuration info from registry
     // serial keeps params under ENUM branch so we open DEVICE not DRIVER
     // which is considered CLASS area.
     // opens: enum\device\node\Device Parameters area
     // status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DRIVER, 

   namestr[0] = 0;
   status = IoOpenDeviceRegistryKey(Pdo,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_READ,
                                    &keyHandle);

   // go get "Device Parameters\PortName"="COM5"
   // also, key params: PollingPeriod=, Serenumerable=
   if (NT_SUCCESS(status))
   {
     status = get_reg_value(keyHandle, namestr, "PortName", 15);
     if (status)  // err
     {
       namestr[0] = 0;
       MyKdPrint(D_Error, ("No PortName\n"))
     }
     else
     {
       MyKdPrint(D_Pnp, ("PortName:%s\n", namestr))
     }
     ZwClose(keyHandle);
   }

   if ((strlen(namestr) > 10) || (strlen(namestr) <= 0))
   {
     MyKdPrint(D_Error, ("Bad PortName Er1E\n"))
   }

   port_config = &ParentExt->config->port[port_index];

   if (my_lstricmp(port_config->Name, namestr) != 0)  // it does not match!
   {
     MyKdPrint(D_Pnp, ("port name fixup to:%s, from%s\n",
               namestr, port_config->Name))
     // fix it, use one assigned by port class installer
     strcpy(port_config->Name, namestr);
     write_port_name(ParentExt, port_index);
   }

  return 0;
}

#endif // nt50
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\pnpadd.h ===
// pnpadd.h

NTSTATUS SerialAddDevice(
               IN PDRIVER_OBJECT DriverObject,
               IN PDEVICE_OBJECT Pdo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\options.c ===
/*-------------------------------------------------------------------
| options.c - Handle options.
 Copyright 1996-98 Comtrol Corporation. All rights reserved.
|--------------------------------------------------------------------*/
#include "precomp.h"

#define D_Level D_Options
static int set_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN  const char *szVarName,
                          IN VOID *Value);
static int get_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN HANDLE DefHandle,
                          IN  const char *szVarName,
                          OUT char *szValue,
                          IN int szValueSize);
static int atomac(BYTE *mac, char *str);

static int SetMainOption(int index, char *value);
static int SetDeviceOption(int device_index, int option_index, char *value);
static int SetPortOption(int device_index,
                         int port_index,
                         int option_index,
                         char *value);

//--- country codes for SocketModem support
#define mcNotUsed         0
#define mcAustria         1
#define mcBelgium         2
#define mcDenmark         3
#define mcFinland         4
#define mcFrance          5
#define mcGermany         6
#define mcIreland         7
#define mcItaly           8
#define mcLuxembourg      9
#define mcNetherlands     10
#define mcNorway          11
#define mcPortugal        12
#define mcSpain           13
#define mcSweden          14
#define mcSwitzerland     15
#define mcUK              16
#define mcGreece          17
#define mcIsrael          18
#define mcCzechRep        19
#define mcCanada          20
#define mcMexico          21
#define mcUSA             22         
#define mcNA              mcUSA          // North America
#define mcHungary         23
#define mcPoland          24
#define mcRussia          25
#define mcSlovacRep       26
#define mcBulgaria        27
// 28
// 29
#define mcIndia           30
// 31
// 32
// 33
// 34
// 35
// 36
// 37
// 38
// 39
#define mcAustralia       40
#define mcChina           41
#define mcHongKong        42
#define mcJapan           43
#define mcPhilippines     mcJapan
#define mcKorea           44
// 45
#define mcTaiwan          46
#define mcSingapore       47
#define mcNewZealand      48

#ifdef NT50
/*----------------------------------------------------------------------
 write_device_options - Normally the driver just reads the config
   from the registry, but NT5.0 is a bit more dynamic(it gets started
   prior to configuration, and we want to write out the port names
   if the driver has no defaults.  This enables the config prop pages
   to be in sync when we fire it up.
|----------------------------------------------------------------------*/
int write_device_options(PSERIAL_DEVICE_EXTENSION ext)
{
#if 0
 int port_i, stat;
 PSERIAL_DEVICE_EXTENSION port_ext;
 HANDLE DevHandle;
 DEVICE_CONFIG *dev_config;


  // make sure \\Parameters subkey is made
  MakeRegPath(szParameters);  // this forms Driver.OptionRegPath
  RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, Driver.OptionRegPath.Buffer);

   // form "\Parameters\Device#" or "\Parameters\Device<pnp-id>"
  stat = make_device_keystr(ext, devstr);
  if (stat)
    return 1;  // err

  // make sure \Parameters\Device# subkey is made
  MakeRegPath(devstr);  // this forms Driver.OptionRegPath
  RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, Driver.OptionRegPath.Buffer);
#endif

#if 0
  // no, setup program can grab pnp hardware id, etc as well as we can.

  //---- open and write out critical device entries so setup
  // sees what we have.
  stat = our_open_device_reg(&DevHandle, dev_ext, KEY_ALL_ACCESS);
  if (stat == 0)
  {
    dev_config = ext->config;
    stat = set_reg_option(OP_T_DWORD,  // dword, string, etc
                        DevHandle,
                        szNumPort,      // name of var. to set
                        (VOID *)dev_config->NumPorts);

    if (stat)
      { MyKdPrint(D_Error, ("Write Err B\n")) }
    ZwClose(DevHandle);
  }
#endif

#if 0
  //---- now write out the port names
  port_i = 0;
  port_ext = ext->port_ext;
  while (port_ext != NULL)
  {
    write_port_name(ext, port_i);
    ++port_i;
    port_ext = port_ext->port_ext;
  }
#endif

  return 0;
}

/*----------------------------------------------------------------------
 write_port_name -
|----------------------------------------------------------------------*/
int write_port_name(PSERIAL_DEVICE_EXTENSION dev_ext, int port_index)
{
 //char devstr[60];
 char portstr[20];
 //char tmpstr[80];
 int stat;
 PORT_CONFIG *port_config;
 HANDLE DevHandle = NULL;
 HANDLE PortHandle = NULL;

  port_config = &dev_ext->config->port[port_index];
  MyKdPrint(D_Init, ("write_port_name:%s\n",port_config->Name))


  // make sure \Parameters\Device# subkey is made
  stat = our_open_device_reg(&DevHandle, dev_ext, KEY_ALL_ACCESS);
  if (stat)
  {
    MyKdPrint(D_Error, ("write_port_name, error\n"))
    return 1;
  }

  Sprintf(portstr, "Port%d", port_index);

  stat = our_open_key(&PortHandle,
                      DevHandle,
                      portstr,
                      KEY_ALL_ACCESS);
  if (stat == 0)
  {
    MyKdPrint(D_Init, ("set_reg1, writing %s=%s\n", 
                szName, port_config->Name))

    stat = set_reg_option(OP_T_STRING,  // dword, string, etc
                        PortHandle,
                        szName,      // name of var. to set
                        (VOID *)port_config->Name);
    if (stat)
      { MyKdPrint(D_Error, ("Write Err B\n")) }
    ZwClose(PortHandle);
  }
  ZwClose(DevHandle);

  return 0;
}
#endif

/*----------------------------------------------------------------------
 write_dev_mac - Used for auto-config, writes mac-addr out to reg
|----------------------------------------------------------------------*/
int write_dev_mac(PSERIAL_DEVICE_EXTENSION dev_ext)
{
 char macstr[30];
 int stat;
 HANDLE DevHandle = NULL;
 BYTE *mac;

  MyKdPrint(D_Init, ("write_dev_mac\n"))

  // make sure \Parameters\Device# subkey is made
  stat = our_open_device_reg(&DevHandle, dev_ext, KEY_ALL_ACCESS);
  if (stat)
  {
    MyKdPrint(D_Error, ("write_port_name, error\n"))
    return 1;
  }
  mac = dev_ext->config->MacAddr;
  Sprintf(macstr, "%02x %02x %02x %02x %02x %02x",
      mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

  MyKdPrint(D_Init, ("set_mac, writing %s=%s\n", 
                  szMacAddr, macstr))

  stat = set_reg_option(OP_T_STRING,  // dword, string, etc
                        DevHandle,
                        szMacAddr,      // name of var. to set
                        (VOID *)macstr);
  if (stat)
    { MyKdPrint(D_Error, ("Write Err 5\n")) }

  ZwClose(DevHandle);

  return 0;
}

/*----------------------------------------------------------------------
 read_device_options - Read in the program options from the registry.
   These options are at device level, and port level.  The device holds
   all the config options for the ports as well.
|----------------------------------------------------------------------*/
int read_device_options(PSERIAL_DEVICE_EXTENSION ext)
{
 int j, port_i, stat;
 ULONG dstat;
 char tmpstr[80];
 char option_str[62];
 char small_str[20];
 HANDLE DevHandle = NULL;
 HANDLE PortHandle = NULL;

 HANDLE DefDevHandle = NULL;
 HANDLE DefPortHandle = NULL;
 HANDLE DriverHandle = NULL;

 //DEVICE_CONFIG *dev_config;
  // dev_config = (DEVICE_CONFIG *) ExAllocatePool(NonPagedPool,sizeof(*dev_config));
  // ExFreePool(dev_config);

  MyKdPrint(D_Init, ("read_device_options\n"))

  dstat = our_open_driver_reg(&DriverHandle, KEY_READ);
  if (dstat == 0)
  {
    // open up a "default" registry areas, where we look for config
    // if the main one does not exist.
    dstat = our_open_key(&DefDevHandle, DriverHandle, "DefDev", KEY_READ);
    dstat = our_open_key(&DefPortHandle, DriverHandle, "DefPort", KEY_READ);
    our_close_key(DriverHandle);
  }

  stat = our_open_device_reg(&DevHandle, ext, KEY_READ);
  if (stat)
  {
    MyKdPrint(D_Error, ("read_device_options: Err1\n"))
  }

  //------ read in the device options
  j = 0;
  while (device_options[j].name != NULL)
  {
    dstat = get_reg_option(device_options[j].var_type,  // dword, string, etc
                           DevHandle,
                           DefDevHandle,  //DefDevHandle,
                           device_options[j].name,  // name of var. to get
                           option_str, 60);  // return string value
    if (dstat == 0) // ok we read it
    {
      Sprintf(tmpstr,"device[%d].%s=%s",
                     BoardExtToNumber(ext),
                     device_options[j].name,
                     option_str);
      dstat = SetOptionStr(tmpstr);
      if (dstat != 0)
      {
        MyKdPrint(D_Init, ("  Err %d, last option\n", dstat))
      }
    }
    else
    {
      MyKdPrint(D_Init, ("No %s option in reg\n", device_options[j].name))
    }
    ++j;
  }

#if DBG
  if (ext == NULL)
  {
    MyKdPrint(D_Init, ("ErrD\n"))
    return 1;
  }

  if (ext->config == NULL)
  {
    MyKdPrint(D_Init, ("ErrE\n"))
    return 1;
  }
#endif

#ifdef S_VS
  if (mac_match(ext->config->MacAddr, mac_zero_addr))  // set to auto
  {
#ifndef NT50
    Eprintf("Error, Device address not setup");
#endif
    // allow to load using bogus mac-address, so driver stays loaded.
    //0 c0 4e # # #
    memcpy(ext->config->MacAddr, mac_bogus_addr, 6);
    //0,0xc0,0x4e,0,0,0
  }
#endif

  if ((DevHandle != NULL) || (DefPortHandle != NULL))
  {
    //------ get the Port information from setup.exe
    for (port_i=0; port_i<ext->config->NumPorts; port_i++)
    {
      Sprintf(small_str, "Port%d", port_i);
  
      stat = our_open_key(&PortHandle,
                   DevHandle,  // relative to this handle
                   small_str,
                   KEY_READ);
      if (stat)
      {
        MyKdPrint(D_Error, ("read_device_options: port Err2\n"))
      }
      j = 0;
      while (port_options[j].name != NULL)
      {
        dstat = get_reg_option(port_options[j].var_type,  // dword, string, etc
                               PortHandle,
                               DefPortHandle, // DefPortHandle,
                               port_options[j].name,  // name of var. to get
                               option_str, 60);  // return string value
    
        if (dstat == 0) // ok we read it
        {
          Sprintf(tmpstr,"device[%d].port[%d].%s=%s",
              BoardExtToNumber(ext), port_i, port_options[j].name, option_str);
          dstat = SetOptionStr(tmpstr);
          if (dstat)
          {
            MyKdPrint(D_Error, ("Err %d, Option:%s\n",dstat, tmpstr))
          }
        }
        ++j;
      }
      our_close_key(PortHandle);
    }  // ports

    our_close_key(DefPortHandle);
    our_close_key(DefDevHandle);
    our_close_key(DevHandle);
  }
  return 0;
}

/*----------------------------------------------------------------------
 read_driver_options - Read in the initial program options from the registry.
   These options are at driver level.
|----------------------------------------------------------------------*/
int read_driver_options(void)
{
 int i;
 ULONG dstat;

 char tmpstr[80];
 char option_str[62];
 HANDLE DriverHandle = NULL;
 HANDLE DefDriverHandle = NULL;

  MyKdPrint(D_Init, ("read_driver_options\n"))

  // set some default options
  Driver.MdmCountryCode = mcNA;     // North America

  dstat = our_open_driver_reg(&DriverHandle, KEY_READ);
  if (dstat == 0)
  {
    // open up a "default" registry area, where we look for config
    // if the main one does not exist.
    dstat = our_open_key(&DefDriverHandle, DriverHandle, "DefDrv", KEY_READ);
    MyKdPrint(D_Init, ("driver Defh:%x\n", DefDriverHandle))

    i = 0;
    while (driver_options[i].name != NULL)
    {
      MyKdPrint(D_Init, ("get %s\n", driver_options[i].name))
      dstat = get_reg_option(driver_options[i].var_type,  // dword, string, etc
                             DriverHandle,
                             DefDriverHandle,
                             driver_options[i].name,  // name of var. to get
                             option_str, 60);  // return string value
  
      if (dstat == 0) // ok we read it
      {
        MyKdPrint(D_Init, ("got %s\n", option_str))

        Sprintf(tmpstr,"%s=%s",driver_options[i].name, option_str);
  
        dstat = SetOptionStr(tmpstr);
        if (dstat != 0)
        {
          Sprintf(tmpstr,"Err %d, last option\n",dstat);
          MyKdPrint(D_Error, (tmpstr))
        }
      }
      ++i;
    }
  }
  else
  {
    MyKdPrint(D_Error, ("Read driver failed key open"))
  }

  our_close_key(DefDriverHandle);
  our_close_key(DriverHandle);

  if (Driver.NumDevices == 0)
    Driver.NumDevices = 1;
  if (Driver.NumDevices > MAX_NUM_BOXES)
    Driver.NumDevices = MAX_NUM_BOXES;

  return 0;
}

/*----------------------------------------------------------------------
 set_reg_option - write out a option to the registry
|----------------------------------------------------------------------*/
static int set_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN  const char *szVarName,
                          IN VOID *Value)
{
 int dstat = 1;  // err

  MyKdPrint(D_Init, ("set_reg_option %s=", szVarName))

  if (OptionVarType == OP_T_STRING)  // string option type
  {
    MyKdPrint(D_Init, ("%s\n", (char *)Value))
    dstat = our_set_value(Handle,
                    (char *)szVarName,
                    Value,
                    strlen((char *) Value),
                    REG_SZ);
  }
  else  // DWORD option type
  {
    MyKdPrint(D_Init, ("DWORD\n"))
    dstat = our_set_value(Handle,
                    (char *)szVarName,
                    Value,
                    sizeof(DWORD),
                    REG_DWORD);
  }
  if (dstat)
  {
    MyKdPrint(D_Error, ("set_reg_option:err\n"))
  }

  return dstat;
}

/*----------------------------------------------------------------------
 get_reg_option - read in a option from the registry, and convert it to
   ascii.
|----------------------------------------------------------------------*/
static int get_reg_option(IN int OptionVarType,
                          IN HANDLE Handle,
                          IN HANDLE DefHandle,
                          IN  const char *szVarName,
                          OUT char *szValue,
                          IN int szValueSize)
{
 int dstat = 1;  // err
 ULONG dwValue;
 char buffer[200];
 char  *ret_str;
 ULONG data_type;

  //MyKdPrint(D_Init, ("get_reg_option\n"))

  szValue[0] = 0;

  dstat = our_query_value(Handle,
                 (char *)szVarName,
                 buffer,
                 sizeof(buffer),
                 &data_type,
                 &ret_str);
  if ((dstat != 0) && (DefHandle != NULL))
  {
    dstat = our_query_value(DefHandle,
                 (char *)szVarName,
                 buffer,
                 sizeof(buffer),
                 &data_type,
                 &ret_str);
    if (dstat == 0)
    {
      MyKdPrint(D_Test, ("query default reg val\n"))
    }
  }

  if (OptionVarType == OP_T_STRING)  // string option type
  {
    if (dstat == 0)
    {
      WStrToCStr(szValue, (PWCHAR)ret_str, szValueSize);
      MyKdPrint(D_Test, ("reg read:%s\n", ret_str))
    }
  }
  else  // DWORD option type
  {
    if (dstat == 0)  // value read ok
      dwValue = *((ULONG *) ret_str);
    else
      dwValue = 0;
    Sprintf(szValue,"%d", dwValue);
  }
  if (dstat)
  {
    //MyKdPrint(D_Init, ("get_reg_option:No value for:%s\n", szVarName))
  }
  else
  {
    MyKdPrint(D_Init, ("get_reg_option:%s=%s\n", szVarName, szValue))
  }
  //MyKdPrint(D_Init, ("End get_reg_option\n"))
  return dstat;
}

/*-----------------------------------------------------------------------
 SetOptionStr - set an option, based on simple ascii command line
  entry.  Allow:

   GlobalVar1 = value;
   GlobalVar2 = value;
   box[0].BoxVar = value;
   box[0].port[5].PortVar = value;
|-----------------------------------------------------------------------*/
int SetOptionStr(char *option_str)
{
  int i;
  int option_i = -1;
  int box_i = -1;
  int port_i = -1;
  int option_id = -1;
  int stat;
  PSERIAL_DEVICE_EXTENSION board_ext = NULL;

  MyKdPrint(D_Level, ("SetOptionStr:%s\n", option_str))

  if (my_sub_lstricmp("device", option_str) == 0)  // match
  {
    option_str += 6;  // pass up "device"
    if (*option_str++ != '[')
      return 1;
#if (defined(NT50))
    if (my_toupper(*option_str) == 'D')  // it's a nt5.0 keyword device name
    {
      int k;
      // instead of an index, we key off a pnp-device name
      // this is because nt50 stores devices under a pnp-tree dynamically
      // and does not have just a simple array list of devices.
      board_ext = Driver.board_ext;

      box_i = -1;
      k = 0;
      while (board_ext != NULL)
      {
        if (my_sub_lstricmp(board_ext->config->szNt50DevObjName,
            option_str) == 0)  // match
        {
          i = strlen(board_ext->config->szNt50DevObjName);
          box_i = k;
        }
        board_ext = board_ext->board_ext;
        ++k;
      }
      if (box_i == -1)
      {
        MyKdPrint(D_Error, ("Pnp key not found.\n"))
        return 15;  // err
      }
    }
    else  // set option by device by index(which our reg-reading one does.)
    {
      box_i = getint(option_str, &i);  // get the box index [#]
      if (i==0)
        return 2;
      if (find_ext_by_index(box_i, -1) == NULL)  // if no device exists)
      {
        return 3;
      }
    }
#else
    box_i = getint(option_str, &i);  // get the box index [#]
    if (i==0)
      return 2;
    if (find_ext_by_index(box_i, -1) == NULL)  // if no device exists)
    {
      return 3;
    }
#endif
    option_str += i;
    if (*option_str++ != ']')
      return 4;
    if (*option_str++ != '.')
      return 5;
    if (my_sub_lstricmp("port[", option_str) == 0)  // match
    {
      // its a port option
      
      option_str += 4;  // pass up "port"
      if (*option_str++ != '[')
        return 20;
      port_i = getint(option_str, &i);  // get the port index [#]
      if (i==0)
        return 21;
      option_str += i;

      if (*option_str++ != ']')
        return 23;

      if (*option_str++ != '.')
        return 34;

      //-- find the option-string index
      i = 0;
      while (port_options[i].name != NULL)
      {
        if (my_sub_lstricmp(port_options[i].name, option_str) == 0)  // match
        {
          option_i = i;
          option_id = port_options[i].id;
        }
        ++i;
      }
      if (option_i == -1)
        return 24;  // option not found

      option_str += strlen(port_options[option_i].name);
      while (*option_str == ' ')
       ++option_str;
      if (*option_str++ != '=')
        return 25;
      while (*option_str == ' ')
       ++option_str;

      stat = SetPortOption(box_i, port_i, option_id, option_str);
      if (stat)
        return (50+stat);  // option not set

      return 0; // ok
    }  // == port[

    //-------- its a device level option, find the option-string index
    i = 0;
    while (device_options[i].name != NULL)
    {
      if (my_sub_lstricmp(device_options[i].name, option_str) == 0)  // match
      {
        option_i = i;
        option_id = device_options[i].id;
      }
      ++i;
    }
    if (option_i == -1)
    {
      MyKdPrint(D_Error, ("Option not found:%s\n", option_str))
      return 6;  // option not found
    }

    option_str += strlen(device_options[option_i].name);
    while (*option_str == ' ')
     ++option_str;
    if (*option_str++ != '=')
      return 7;
    while (*option_str == ' ')
     ++option_str;

    stat = SetDeviceOption(box_i, option_id, option_str);
    if (stat)
      return (50+stat);  // option not set
    return 0; // ok
  }

  //-- assume a global option string
  //-- find the option-string index
  i = 0;
  while (driver_options[i].name != NULL)
  {
    if (my_sub_lstricmp(driver_options[i].name, option_str) == 0)  // match
    {
      option_i = i;
      option_id = driver_options[i].id;
    }
    ++i;
  }
  if (option_i == -1)
    return 7;  // option not found

  option_str += strlen(driver_options[option_i].name);
  while (*option_str == ' ')
   ++option_str;
  if (*option_str++ != '=')
    return 7;
  while (*option_str == ' ')
   ++option_str;

  stat = SetMainOption(option_id, option_str);
  if (stat)
    return (50+stat);  // option not set

 return 0;
}

/*-----------------------------------------------------------------------
 SetMainOption -
|-----------------------------------------------------------------------*/
static int SetMainOption(int index, char *value)
{
 int j;
 int ret_stat = 2;  // default, return an error, unknown option

  //MyKdPrint(D_Init, ("SetMainOp[%d]:%s\n", index, value))

  switch (index)
  {
    case OP_VerboseLog:
      Driver.VerboseLog = (WORD)getnum(value,&j);
      ret_stat = 0;  // ok
    break;

    case OP_NumDevices:
      if (NumDevices() == 0)
      {
        Driver.NumDevices = getnum(value,&j);
        if (Driver.NumDevices > MAX_NUM_BOXES)
          Driver.NumDevices = MAX_NUM_BOXES;
        ret_stat = 0;
      }
      else
      {
        // if this gets changed on the fly, this could kill us!!!!!
        ret_stat = 1;  // not allowed
      }
    break;

    case OP_ScanRate:
      Driver.ScanRate = (WORD)getnum(value,&j);
      if (Driver.ScanRate == 0) Driver.ScanRate = 10;
      if (Driver.ScanRate < 1) Driver.ScanRate = 1;
      if (Driver.ScanRate > 50) Driver.ScanRate = 50;
      Driver.PollIntervalTime.QuadPart = Driver.ScanRate * -10000;
#ifdef NT50
      ExSetTimerResolution(Driver.ScanRate, 1);
      //ExSetTimerResolution(-Driver.PollIntervalTime.QuadPart, 1);
#endif
      ret_stat = 0;  // ok
    break;

    case OP_ModemCountry :
      Driver.MdmCountryCode = (WORD)getnum(value,&j);
      MyKdPrint(D_Level, ("ModemCountry=%d\n", Driver.MdmCountryCode))
      ret_stat = 1;  // probably need to restart to reinit modems
    break;

//    case OP_ModemSettleTime :
//      Driver.MdmSettleTime = getnum(value,&j);
//      ret_stat = 1;  // probably need to reinit modems
//    break;

#ifdef NT50
    case OP_NoPnpPorts         :
      Driver.NoPnpPorts = getnum(value,&j);

      ret_stat = 0;  // ok
      // if boards and ports started
      if (Driver.board_ext != NULL)
      {
        if (Driver.board_ext->port_ext != NULL)
        {
          ret_stat = 1;  // currently need a reset to get this operational
        }
      }
    break;
#endif

//    case OP_PreScaler        :
//      Driver.PreScaler = getnum(value,&j);
//      ret_stat = 1;  // currently need a reset to get this going
//    break;

    default:
    return 2;  // err, option unknown
  }
 return ret_stat;
}

/*-----------------------------------------------------------------------
 SetDeviceOption -
|-----------------------------------------------------------------------*/
static int SetDeviceOption(int device_index, int option_index, char *value)
{
 int stat,j, num;
 int ret_stat = 2;  // default, return an error, unknown option
 DEVICE_CONFIG *dev_config;
 PSERIAL_DEVICE_EXTENSION board_ext = NULL;

  //MyKdPrint(D_Level, ("SetDeviceOp[%d.%d]:%s\n", device_index, option_index, value))
  board_ext = find_ext_by_index(device_index, -1);
  if (board_ext == NULL)  // if no device exists)
  {
    MyKdPrint(D_Error, ("Err, SetDevOpt, No Dev"))
    return 6;  // no device found
  }
  dev_config = board_ext->config;
  if (dev_config == NULL)  // if no device exists)
  {
    MyKdPrint(D_Error, ("Err, SetDevOpt, No Config"))
    return 6;  // no device found
  }

  switch (option_index)
  {
#if 0
    case OP_StartComIndex  :
      num = getnum(value,&j);
    break;
#endif

    case OP_NumPorts        :
      num = getnum(value,&j);
      if (NumPorts(board_ext) == 0)
      {
        // assume start up reading in, and other code will adjust
        dev_config->NumPorts = num;
        ret_stat = 0;
      }
      else
      {
        if (num == NumPorts(board_ext))
          ret_stat = 0;
        else  // different number of ports asked for.
        {
           stat = CreateReconfigPortDevices(board_ext, num);
           if (stat == STATUS_SUCCESS)
                ret_stat = 0;
           else
           {
             ret_stat = 1;  // err, need reboot
             MyKdPrint(D_Init, ("NumPorts chg needs reboot\n"))
           }
        }
      }
    break;

    case OP_IoAddress       :
      if (dev_config->IoAddress == 0)
      {
        // assume startup of nt40.
        dev_config->IoAddress = getnum(value,&j);
        ret_stat = 0;
      }
      else
      {
        MyKdPrint(D_Init, ("Io chg needs reboot\n"))
        ret_stat = 1;  // err, need reboot
      }
    break;

    case OP_ModemDevice   :
      dev_config->ModemDevice = getnum(value, &j);
      ret_stat = 0;  // ok
    break;

    case OP_Name:
      ret_stat = 0;  // ok
    break;

    case OP_ModelName:
      ret_stat = 0;  // ok
    break;

    case OP_HubDevice:
      ret_stat = 0;  // ok
    break;

#ifdef S_VS
    case OP_MacAddr         :
      ret_stat = 0;  // ok, took
      stat = atomac(dev_config->MacAddr, value);
      if (stat)
      {
        MyKdPrint(D_Error, ("Error%x device:%d, MAC addr\n",stat, device_index+1))
        ret_stat = 1;
      }
      else
      {
        if (!mac_match(dev_config->MacAddr, board_ext->hd->dest_addr))
        {
          MyKdPrint(D_Init, ("MacAddr:%x %x %x %x %x %x\n",
            dev_config->MacAddr[0],dev_config->MacAddr[1],dev_config->MacAddr[2],
            dev_config->MacAddr[3],dev_config->MacAddr[4],dev_config->MacAddr[5]))
          #if DBG
          if (board_ext->pm->hd == NULL)
          {
            MyKdPrint(D_Error, ("Err, null pm or hd\n"))
            break;
          }
          #endif
          port_set_new_mac_addr(board_ext->pm, dev_config->MacAddr);
        }
      }
      MyKdPrint(D_Error, ("End Mac Chg\n"))
    break;

    case OP_BackupServer    :
      dev_config->BackupServer = getnum(value,&j);
      board_ext->pm->backup_server = dev_config->BackupServer;
      ret_stat = 0;  // ok, took
    break;

    case OP_BackupTimer    :
      dev_config->BackupTimer = getnum(value,&j);
      board_ext->pm->backup_timer = dev_config->BackupTimer;
      ret_stat = 0;  // ok, took
    break;
#endif

    default:
    return 2;
  }
 return ret_stat;
}

/*-----------------------------------------------------------------------
 SetPortOption -
|-----------------------------------------------------------------------*/
static int SetPortOption(int device_index,
                         int port_index,
                         int option_index,
                         char *value)
{
 int j;
 int i = device_index;
 int ret_stat = 2;  // default, return an error, unknown option
 PSERIAL_DEVICE_EXTENSION board_ext = NULL;
 PSERIAL_DEVICE_EXTENSION ext = NULL;
 PORT_CONFIG *port_config;

  MyKdPrint(D_Level, ("SetPortOp[%d.%d,%x]:%s\n",
     device_index, port_index, option_index, value))

  board_ext = find_ext_by_index(device_index, -1);
  if (board_ext == NULL)
  {
    MyKdPrint(D_Error, ("Can't find board\n"))
    return 6;
  }

  ext = find_ext_by_index(device_index, port_index);
  if (ext == NULL)
  {
    // so point it at the boards port config(which is what the ports
    // ptr points to anyway.
    port_config = &board_ext->config->port[port_index];
  }
  else
    port_config = ext->port_config;

  if (port_config == NULL)
  {
    MyKdPrint(D_Error, ("Err 8U\n"))
    return 7;
  }

  switch (option_index)
  {
    case OP_WaitOnTx :
      port_config->WaitOnTx = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_RS485Override :
      // will take next port open
      port_config->RS485Override = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_RS485Low :
      port_config->RS485Low = getnum(value,&j);
      // will take next port open
      ret_stat = 0;  // ok, took
    break;
    case OP_TxCloseTime :
      port_config->TxCloseTime = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_LockBaud :
      port_config->LockBaud = getnum(value,&j);
      if (ext != NULL)
        ProgramBaudRate(ext, ext->BaudRate);
      ret_stat = 0;  // ok, took
    break;
    case OP_Map2StopsTo1 :
      port_config->Map2StopsTo1 = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;

    case OP_MapCdToDsr :
      port_config->MapCdToDsr = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;
    case OP_RingEmulate :
      port_config->RingEmulate = getnum(value,&j);
      ret_stat = 0;  // ok, took
    break;

    case OP_PortName :
      if (ext == NULL)  // must be initial load prior to port ext creation
      {
        strcpy(port_config->Name, value);
        ret_stat = 0;  // ok, took
        break;
      }

      // not init time, runtime
      ret_stat = 1;  // err, need reboot
      if (ext == NULL)
      {
        MyKdPrint(D_Error,("Err7K\n"))
        break;
      }
#define ALLOW_RENAMING_ON_FLY
#ifdef ALLOW_RENAMING_ON_FLY
      {
        PSERIAL_DEVICE_EXTENSION other_ext = NULL;
        char othername[20];

        MyKdPrint(D_Init,("NewName:%s OldName:%s\n",
             value, ext->SymbolicLinkName))

        // see if some other port has the name we want
        other_ext = find_ext_by_name(value, NULL);
        if (other_ext == ext)  //it's the same
        {
          ret_stat = 0;  // ok, took
          break;
        }

        if (other_ext)
        {
          MyKdPrint(D_Init,("Change other name\n"))
          // it does, so rename it to ours
          strcpy(othername, other_ext->SymbolicLinkName);
          SerialCleanupExternalNaming(other_ext);
          strcpy(other_ext->port_config->Name, ext->port_config->Name);
          strcpy(other_ext->SymbolicLinkName, ext->port_config->Name);  // "COM#"
        }

        SerialCleanupExternalNaming(ext);
        if (other_ext)
        {
          SerialSetupExternalNaming(other_ext);  // Configure port
        }
        // copy over the name in the configuration for dos-name
        strcpy(port_config->Name, value);
        strcpy(ext->SymbolicLinkName, value);  // "COM#"

        MyKdPrint(D_Init,("NewName:%s\n", ext->SymbolicLinkName))
        SerialSetupExternalNaming(ext);  // Configure port

  MyKdPrint(D_Init,("Done renaming\n"))
        ret_stat = 0;  // ok
      }
    break;
#endif

    default:
    return 2;
  }
 return ret_stat;
}

/*-----------------------------------------------------------------------
 SaveRegPath - Make a copy of the DriverEntry() RegistryPath unicode
   string into the registry area we reside.
   Create and save into Driver.RegPath.
|-----------------------------------------------------------------------*/
int SaveRegPath(PUNICODE_STRING RegistryPath)
{
 int len;

  //MyKdPrint(D_Init, ("SaveRegPath A:%s\n", UToC1(RegistryPath)))

  // if RegPath buffer not allocated, then take care of that
  if (Driver.RegPath.Buffer == NULL)
  {
    // allocate buffer space for original regpath
    len = RegistryPath->Length + 2;
    Driver.RegPath.Buffer = ExAllocatePool(PagedPool, len);
    if ( Driver.RegPath.Buffer == NULL ) {
      Eprintf("SaveRegPath no memory");
      return -1;
    }
    Driver.RegPath.MaximumLength = (WORD)len;
    Driver.RegPath.Length = 0;
  }

  RtlZeroMemory(Driver.RegPath.Buffer, Driver.RegPath.MaximumLength);

  //--- copy registry path to our local copy
  RtlMoveMemory(Driver.RegPath.Buffer,
                RegistryPath->Buffer,
                RegistryPath->Length);

  Driver.RegPath.Length = RegistryPath->Length;  // set unicode length
  return 0;
}

/*-----------------------------------------------------------------------
 MakeRegPath - Form a unicode Registry string to an area where we get
   info from the registry.  Concat's str onto original RegistryPath
   and forms a unicode string at Driver.OptionRegPath.
|-----------------------------------------------------------------------*/
int MakeRegPath(CHAR *optionstr)
{
 //UCHAR *upath;  // a byte ptr for byte indexing path stuff
 //WCHAR *pwstr;
 int len;
 USTR_80 utmpstr;

  if (Driver.RegPath.Buffer == NULL)
    return 1;

  //MyKdPrint(D_Init, ("MakeRegPath A:%s\n", UToC1(&Driver.RegPath)))

  // if OptionRegPath buffer not allocated, then take care of that
  if (Driver.OptionRegPath.Buffer == NULL)
  {
    // allocate buffer space for original regpath + room to tack on option
    // strings.
    len = Driver.RegPath.Length + (128*(sizeof(WCHAR)));
    Driver.OptionRegPath.Buffer = ExAllocatePool(PagedPool, len);
    if ( Driver.OptionRegPath.Buffer == NULL ) {
      Eprintf("MakeRegPath no memory");
      return -1;
    }
    Driver.OptionRegPath.MaximumLength = (WORD)len;
    Driver.OptionRegPath.Length = 0;
  }

  RtlZeroMemory(Driver.OptionRegPath.Buffer,
                Driver.OptionRegPath.MaximumLength);

  // copy over the orignal RegPath
  RtlMoveMemory(Driver.OptionRegPath.Buffer,
                Driver.RegPath.Buffer,
                Driver.RegPath.Length);
  Driver.OptionRegPath.Length = Driver.RegPath.Length;

  //---- now tack on what we want to concatinate(example: L"\\Parameters")
  if (optionstr != NULL)
  {
    // convert to unicode
    CToUStr((PUNICODE_STRING) &utmpstr, optionstr, sizeof(utmpstr));

    // Copy the key string over
    RtlCopyMemory( ((UCHAR *) Driver.OptionRegPath.Buffer) +
                     Driver.OptionRegPath.Length,
                   utmpstr.ustr.Buffer,
                   utmpstr.ustr.Length);

    Driver.OptionRegPath.Length += utmpstr.ustr.Length;
  }
  //MyKdPrint(D_Init, ("MakeRegPath B:%s\n", UToC1(&Driver.OptionRegPath)))

  return 0;  // ok
}
#if 0
/*-----------------------------------------------------------------
  reg_get_str - get a str value out of the registry.
|------------------------------------------------------------------*/
int reg_get_str(IN WCHAR *RegPath,
                       int reg_location,
                       const char *str_id,
                       char *dest,
                       int max_dest_len)
{
 RTL_QUERY_REGISTRY_TABLE paramTable[2];
 PUNICODE_STRING ustr;
 USTR_80 ustr_id;
 USTR_80 ustr_val;
 char *ret_str;

  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));
  RtlZeroMemory(&paramTable[0],sizeof(paramTable));

  //ustr = CToU2("");  // allocated static space for unicode
  ustr = CToUStr((PUNICODE_STRING)&ustr_val, "", sizeof(ustr_val));

  ustr = (PUNICODE_STRING) &ustr_val;  // allocated static space for unicode
  paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name = ustr_id.ustr.Buffer;
  paramTable[0].EntryContext = ustr;
  paramTable[0].DefaultType = 0;
  paramTable[0].DefaultData = 0;
  paramTable[0].DefaultLength = 0;

  if (!NT_SUCCESS(RtlQueryRegistryValues(
//                      RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                      reg_location | RTL_REGISTRY_OPTIONAL,
                      RegPath,
                      &paramTable[0],
                      NULL,
                      NULL)))
  {
    dest[0] = 0;
    return 1;
  }

  ret_str = (char *) &ustr_id;  // reuse this stack space for u to c conv.
  UToCStr(ret_str, ustr, 80);
  if ((int)strlen(ret_str) > max_dest_len)
    ret_str[max_dest_len] = 0;
    
  strcpy(dest, ret_str);

  return 0;
}

/*-----------------------------------------------------------------
  reg_get_dword - get a dword value out of the registry.
|------------------------------------------------------------------*/
int reg_get_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG *dest)
{
 ULONG DataValue;
 RTL_QUERY_REGISTRY_TABLE paramTable[2];
 ULONG notThereDefault = 12345678;
 USTR_80 ustr_id;
  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));

  RtlZeroMemory(&paramTable[0],sizeof(paramTable));

  paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name = ustr_id.ustr.Buffer;
  paramTable[0].EntryContext = &DataValue;
  paramTable[0].DefaultType = REG_DWORD;
  paramTable[0].DefaultData = &notThereDefault;
  paramTable[0].DefaultLength = sizeof(ULONG);

  if (!NT_SUCCESS(RtlQueryRegistryValues(
                      RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                      RegPath,
                      &paramTable[0],
                      NULL,
                      NULL)))
  {
    return 1;
  }

  if (DataValue == 12345678)
    return 2;

  *dest = DataValue;
  return 0;
}

/*-----------------------------------------------------------------
  reg_set_str - get a dword value out of the registry.
|------------------------------------------------------------------*/
static int reg_set_str(IN WCHAR *RegPath,
                IN const char *str_id,
                IN const char *str_val)
{
 int status;
  USTR_80 ustr_id;
  USTR_80 ustr_val;
  MyKdPrint(D_Init, ("Reg_set, writing %s=%s\n", str_id, str_val))

  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));
  CToUStr((PUNICODE_STRING)&ustr_val, str_val, sizeof(ustr_val));

  status = RtlWriteRegistryValue(
      RTL_REGISTRY_ABSOLUTE,
      RegPath,
      ustr_id.ustr.Buffer,
      REG_SZ,
      ustr_val.ustr.Buffer,
      ustr_val.ustr.Length);

  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error, ("Error, writing %s=%s\n", str_id, str_val))
    MyKdPrint(D_Error, ("  Path:%s\n", RegPath))
    return 1;
  }

  return 0;
}

/*-----------------------------------------------------------------
  reg_set_dword - get a dword value out of the registry.
|------------------------------------------------------------------*/
int reg_set_dword(IN WCHAR *RegPath,
                          const char *str_id,
                          ULONG val)
{
 int status;
 USTR_80 ustr_id;
  CToUStr((PUNICODE_STRING)&ustr_id, str_id, sizeof(ustr_id));

  status = RtlWriteRegistryValue(
      RTL_REGISTRY_ABSOLUTE,
      RegPath,
      ustr_id.ustr.Buffer,
      REG_DWORD,
      &val,
      sizeof(ULONG));

  if (status != STATUS_SUCCESS)
  {
    return 1;
  }

  return 0;
}
#endif

/*-----------------------------------------------------------------
  atomac - convert from ascii to mac-addr.
|------------------------------------------------------------------*/
static int atomac(BYTE *mac, char *str)
{
 int i,j;
 WORD h;

  for (i=0; i<6; i++)
  {
    j = 0;
    h = 0xffff;
    h = (WORD)gethint(str, &j);
    str += j;
    if ((h > 0xff) || (j == 0))
      return 1;
    mac[i] = (BYTE) h;
  }
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\opstr.h ===
// opstr.h

//----- Pnp-ID Defines
/* PCI Defines */
#define PCI_VENDOR_ID           0x11fe
#define PCI_DEVICE_32I          0x0001
#define PCI_DEVICE_8I           0x0002
#define PCI_DEVICE_16I          0x0003
#define PCI_DEVICE_4Q           0x0004
#define PCI_DEVICE_8O           0x0005
#define PCI_DEVICE_8RJ          0x0006
#define PCI_DEVICE_4RJ          0x0007
#define PCI_DEVICE_SIEMENS8     0x0008
#define PCI_DEVICE_SIEMENS16    0x0009
#define PCI_DEVICE_RPLUS4       0x000a
#define PCI_DEVICE_RPLUS8       0x000b
#define PCI_DEVICE_RMODEM6      0x000c
#define PCI_DEVICE_RMODEM4      0x000d
#define PCI_DEVICE_RPLUS2       0x000e
#define PCI_DEVICE_422RPLUS2    0x000f

#define ISA_DEVICE_RPORT4       0x1001
#define ISA_DEVICE_RPORT8       0x1002
#define ISA_DEVICE_RPORT16      0x1003
#define ISA_DEVICE_RPORT32      0x1004
#define ISA_DEVICE_RMODEM4      0x2001
#define ISA_DEVICE_RMODEM8      0x2002
#define NET_DEVICE_VS1000       0x3001  // 16 to 64 port
#define NET_DEVICE_VS2000       0x3002  // 8 port
#define NET_DEVICE_RHUB8        0x3003
#define NET_DEVICE_RHUB4        0x3004

// ids for Our_Option.var_type
#define OP_T_DWORD  0
#define OP_T_STRING 1
#define OP_T_BOOL   2

// flags for Our_Option.flags
#define OP_F_VS             1
#define OP_F_RK             2
#define OP_F_VSRK           3
#define OP_F_SETUP_ONLY     8

typedef struct {
  const char * name;  // name of option see lists
  int id;     // unique id, also has bit which tells option type.
  WORD var_type;  // see OP_T_* types, 0=DWORD, 1=String, 2=BOOL
  WORD    flags;  // see OP_F_* types
} Our_Options;

// driver options
extern const char szVerboseLog[]   ;
extern const char szNumDevices[]   ;
extern const char szNoPnpPorts[]   ;
extern const char szScanRate[]     ;
extern const char szModemCountry[] ;
extern const char szGlobalRS485[]  ;

#define OP_VerboseLog    0x100
#define OP_NumDevices    0x101
#define OP_NoPnpPorts    0x102
#define OP_ScanRate      0x103
#define OP_ModemCountry  0x104
#define OP_GlobalRS485   0x105

// device options
//extern const char szStartComIndex[] ;
extern const char szNumPorts[]      ;
extern const char szMacAddr[]       ;
extern const char szBackupServer[]  ;
extern const char szBackupTimer[]   ;
extern const char szName[]          ;
extern const char szModelName[]     ;
extern const char szIoAddress[]     ;
extern const char szModemDevice[]   ;
extern const char szHubDevice[]     ;
extern const char szClkRate[]       ;
extern const char szClkPrescaler[]  ;

//#define OP_StartComIndex   0x200
#define OP_NumPorts        0x201
#define OP_MacAddr         0x202
#define OP_BackupServer    0x203
#define OP_BackupTimer     0x204
#define OP_Name            0x205
#define OP_ModelName       0x206
#define OP_IoAddress       0x207
#define OP_ModemDevice     0x208
#define OP_HubDevice       0x209
#define OP_ClkRate         0x20a
#define OP_ClkPrescaler    0x20b

// port options
extern const char szWaitOnTx[]      ;
extern const char szRS485Override[] ;
extern const char szRS485Low[]      ;
extern const char szTxCloseTime[]   ;
extern const char szLockBaud[]      ;
extern const char szMap2StopsTo1[]  ;
extern const char szMapCdToDsr[]    ;
extern const char szRingEmulate[]   ;
  	
#define OP_WaitOnTx         0x400
#define OP_RS485Override    0x401
#define OP_RS485Low         0x402
#define OP_TxCloseTime      0x403
#define OP_LockBaud         0x404
#define OP_Map2StopsTo1     0x405
#define OP_MapCdToDsr       0x406
#define OP_PortName         0x407
#define OP_RingEmulate      0x408

extern Our_Options driver_options[];
extern Our_Options device_options[];
extern Our_Options port_options[];

int HdwIDStrToID(int *Hardware_ID, char *idstr);
int id_to_num_ports(int id);
int IsHubDevice(int Hardware_ID);
int IsModemDevice(int Hardware_ID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\pnp.c ===
/*----------------------------------------------------------------------
 pnp.c -
 4-18-00 Remove IoStartNextPacket call from PnPBoardFDO function
 4-06-00 Reject irps for query_device_relations if not a bus_relation request
 3-30-99 fix hybernate power on to restore dtr/rts states
  properly, in RestorePortSettings().
 2-15-99 - allow to hibernate with open ports, restore ports when
  comes back up now - kpb.
11-24-98 - fix power handling to avoid crash,
           allow hibernation if no ports open. kpb
----------------------------------------------------------------------*/
#include "precomp.h"

#ifdef NT50

NTSTATUS PnPBoardFDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS PnPPortFDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS PnpPortPDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS BoardBusRelations(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
NTSTATUS WaitForLowerPdo(IN PDEVICE_OBJECT fdo, IN PIRP Irp);
NTSTATUS BoardFilterResReq(IN PDEVICE_OBJECT devobj, IN PIRP Irp);

NTSTATUS SerialRemoveFdo(IN PDEVICE_OBJECT pFdo);
NTSTATUS SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
           PDEVICE_OBJECT PDevObj,
           PIRP PIrp);
NTSTATUS Serial_PDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS Serial_FDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS PowerUpDevice(PSERIAL_DEVICE_EXTENSION    Ext);
void RestorePortSettings(PSERIAL_DEVICE_EXTENSION Ext);

//NTSTATUS SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
//           PDEVICE_OBJECT PDevObj,
//           PIRP PIrp);
//NTSTATUS SerialSetPowerD0(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS OurPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);

NTSTATUS SerialD3Complete(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS SerialStartDevice(
        IN PDEVICE_OBJECT Fdo,
        IN PIRP Irp);

NTSTATUS SerialSyncCompletion(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PKEVENT SerialSyncEvent
                       );

NTSTATUS SerialFinishStartDevice(IN PDEVICE_OBJECT Fdo,
           IN PCM_RESOURCE_LIST resourceList,
           IN PCM_RESOURCE_LIST trResourceList);
static NTSTATUS RocketPortSpecialStartup(PSERIAL_DEVICE_EXTENSION Ext);

#if DBG
static char *power_strs[] = {
"WAIT_WAKE",       //             0x00
"POWER_SEQUENCE",  //             0x01
"SET_POWER",       //             0x02
"QUERY_POWER",     //             0x03
"UNKNOWN", // 
NULL};

static char *pnp_strs[] = {
"START_DEVICE", //                 0x00
"QUERY_REMOVE_DEVICE", //          0x01
"REMOVE_DEVICE", //                0x02
"CANCEL_REMOVE_DEVICE", //         0x03
"STOP_DEVICE", //                  0x04
"QUERY_STOP_DEVICE", //            0x05
"CANCEL_STOP_DEVICE", //           0x06
"QUERY_DEVICE_RELATIONS", //       0x07
"QUERY_INTERFACE", //              0x08
"QUERY_CAPABILITIES", //           0x09
"QUERY_RESOURCES", //              0x0A
"QUERY_RESOURCE_REQUIREMENTS", //  0x0B
"QUERY_DEVICE_TEXT", //            0x0C
"FILTER_RESOURCE_REQUIREMENTS", // 0x0D
"UNKNOWN", // 
"READ_CONFIG", //                  0x0F
"WRITE_CONFIG", //                 0x10
"EJECT", //                        0x11
"SET_LOCK", //                     0x12
"QUERY_ID", //                     0x13
"QUERY_PNP_DEVICE_STATE", //       0x14
"QUERY_BUS_INFORMATION", //        0x15
"PAGING_NOTIFICATION", //          0x16
NULL};
#endif

/*----------------------------------------------------------------------
 SerialPnpDispatch -
    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).
|----------------------------------------------------------------------*/
NTSTATUS SerialPnpDispatch(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
   PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
   //PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS                    status          = STATUS_NOT_SUPPORTED;
   BOOLEAN acceptingIRPs;
   int index;

   // dump out some debug info
   index = irpStack->MinorFunction;
   if (index > 0x16)
     index = 0x0e;

#ifdef DO_BUS_EXTENDER
   if (Ext->IsPDO)
   {
     MyKdPrint(D_Pnp,("Port PDO %s PnPIrp:%d,%s\n", 
             Ext->SymbolicLinkName, irpStack->MinorFunction,
        pnp_strs[index]))
     InterlockedIncrement(&Ext->PendingIRPCnt);
     return PnpPortPDO(devobj, Irp);
   }
   else
#endif
   {
     if (Ext->DeviceType == DEV_BOARD)
     {
       MyKdPrint(D_Pnp,("Board %s PnPIrp:%d,%s\n", 
               Ext->SymbolicLinkName, irpStack->MinorFunction,
               pnp_strs[index]))
     }
     else
     {
       MyKdPrint(D_Pnp,("Port %s PnPIrp:%d,%s\n", 
          Ext->SymbolicLinkName, irpStack->MinorFunction,
          pnp_strs[index]))
     }

     acceptingIRPs = SerialIRPPrologue(Ext);

#if 0
     if ((irpStack->MinorFunction != IRP_MN_REMOVE_DEVICE)
         && (irpStack->MinorFunction != IRP_MN_CANCEL_REMOVE_DEVICE)
         && (irpStack->MinorFunction != IRP_MN_STOP_DEVICE)
         && (irpStack->MinorFunction != IRP_MN_CANCEL_STOP_DEVICE)
         && (acceptingIRPs == FALSE))
     {
        MyKdPrint(D_Pnp,("Removed!\n"))
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
     }
#endif

     if (Ext->DeviceType == DEV_BOARD)
     {
       return PnPBoardFDO(devobj, Irp);
     }
     else
     {
       //return PnPPortFDO(devobj, Irp);
       return PnPBoardFDO(devobj, Irp);
     }
   }
}

/*----------------------------------------------------------------------
 PnPBoardFDO - This handles both Board and Port FDO's
|----------------------------------------------------------------------*/
NTSTATUS PnPBoardFDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
 PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
 PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
 PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
 NTSTATUS  status = STATUS_NOT_SUPPORTED;
 ULONG pendingIRPs;
 int pass_down = 1;

  ASSERT( devobj );
  ASSERT( Ext );

#if DBG
  if (* ((BYTE *)(Irp)) != 6)  // in signiture of irp
  {
    MyKdPrint(D_Pnp,("bad irp!!!\n"))
  }
#endif

  switch (irpStack->MinorFunction)
  {
    case IRP_MN_START_DEVICE:   // 0x00
      MyKdPrint(D_Pnp,("StartDevice\n"))
      status = SerialStartDevice(devobj, Irp);
//
// Is this were we should register and enable the device, or should it be in
// the PDO start? (see DoPnpAssoc(Pdo) in pnpadd.c)
//
      Irp->IoStatus.Status = status;
      pass_down = 0;  // already passed down
    break;

   case IRP_MN_STOP_DEVICE:    // 0x04
      // need to unhook from resources so system rebalance resources
      // on the fly.
      MyKdPrint(D_Pnp,("StopDevice\n"))
       //Ext->Flags |= SERIAL_FLAGS_STOPPED;

       Ext->PNPState = SERIAL_PNP_STOPPING;
       Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_STOPPED;
       Ext->DevicePNPAccept &= ~SERIAL_PNPACCEPT_STOPPING;

      InterlockedDecrement(&Ext->PendingIRPCnt);  // after dec, =1

      pendingIRPs = InterlockedDecrement(&Ext->PendingIRPCnt); // after dec, =0

      if (pendingIRPs) {
         KeWaitForSingleObject(&Ext->PendingIRPEvent, Executive,
                               KernelMode, FALSE, NULL);
      }

      Ext->FdoStarted = FALSE;  // this should stop service of the device
#ifdef NT50

	  if (Ext->DeviceType != DEV_BOARD) {

		  // Disable the interface

          status = IoSetDeviceInterfaceState( &Ext->DeviceClassSymbolicName,
                                              FALSE);

          if (!NT_SUCCESS(status)) {

             MyKdPrint(D_Error,("Couldn't clear class association for %s\n",
	    	      UToC1(&Ext->DeviceClassSymbolicName)))
		  }
          else {

             MyKdPrint(D_PnpAdd, ("Cleared class association for device: %s\n and ", 
			      UToC1(&Ext->DeviceClassSymbolicName)))
		  }
	  }   
#endif

      // Re-increment the count for exit
      InterlockedIncrement(&Ext->PendingIRPCnt);  //after inc=1
      InterlockedIncrement(&Ext->PendingIRPCnt);  //after inc=2
      // exit this irp decr it to=1


      status = STATUS_SUCCESS;
      Irp->IoStatus.Status = STATUS_SUCCESS;
        //Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        //pass_down = 0;  // we are failing it
   break;

#if 0
   case IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
     if ( irpStack->Parameters.QueryDeviceRelations.Type != BusRelations )
     {
       //
       // Verifier requires pass down is PDO present
       //

       if ( (Ext->DeviceType == DEV_BOARD) && (pdo == 0) )
       {
           status = STATUS_NOT_IMPLEMENTED;
           pass_down = 0;
       };
       break;
     }
     if (!Driver.NoPnpPorts)
     {
       if (Ext->DeviceType == DEV_BOARD)
       {
         status = BoardBusRelations(devobj, Irp);
       }
     }
   break;
#endif
#ifdef DO_BUS_EXTENDER
   case IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
       //
       // Verifier requires pass down is PDO present
       //

     if ( (Ext->DeviceType == DEV_BOARD) && (pdo == 0) )
     {
         pass_down = 0;
     }
	 if ( irpStack->Parameters.QueryDeviceRelations.Type != BusRelations ) {

         status = STATUS_NOT_IMPLEMENTED;
		 break;
	 }
     if (!Driver.NoPnpPorts)
     {
       if (Ext->DeviceType == DEV_BOARD)
       {
         status = BoardBusRelations(devobj, Irp);
       }
     }
   break;
#endif

#ifdef DO_BRD_FILTER_RES_REQ
   case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:  // 0x0D
     if (Ext->DeviceType == DEV_BOARD)
     {
       status = BoardFilterResReq(devobj, Irp);
       pass_down = 0;  // already passed down
     }
   break;
#endif

   case IRP_MN_QUERY_STOP_DEVICE: //            0x05
     MyKdPrint(D_Pnp,("QueryStopDevice\n"))

     status = STATUS_SUCCESS;
     if (Ext->DeviceType == DEV_BOARD)
     {
       if (is_board_in_use(Ext))
         status = STATUS_DEVICE_BUSY;
     }
     else
     {
       if (Ext->DeviceIsOpen)
         status = STATUS_DEVICE_BUSY;
     }

     if (status == STATUS_DEVICE_BUSY)
     {
       MyKdPrint(D_Pnp,("Can't Remove, Busy\n"))
       Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
       pass_down = 0;  // we are failing it out, no need to pass down
     }
     else
     {
       Ext->PNPState = SERIAL_PNP_QSTOP;
         // this is hosing up things(kpb)
         //Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_STOPPING;
       Irp->IoStatus.Status = STATUS_SUCCESS;
       status = STATUS_SUCCESS;
     }
   break;

   case IRP_MN_CANCEL_STOP_DEVICE:     // 0x06
     MyKdPrint(D_Pnp,("CancelStopDevice\n"))
     if (Ext->PNPState == SERIAL_PNP_QSTOP)
     {
       Ext->PNPState = SERIAL_PNP_STARTED;
       Ext->DevicePNPAccept &= ~SERIAL_PNPACCEPT_STOPPING;
     }
     Irp->IoStatus.Status = STATUS_SUCCESS;
     status = STATUS_SUCCESS;
   break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
     MyKdPrint(D_Pnp,("CancelRemoveDevice\n"))

     // Restore the device state

     Ext->PNPState = SERIAL_PNP_STARTED;
     Ext->DevicePNPAccept &= ~SERIAL_PNPACCEPT_REMOVING;

     Irp->IoStatus.Status = STATUS_SUCCESS;
     status = STATUS_SUCCESS;
   break;

   case IRP_MN_QUERY_REMOVE_DEVICE:  // 0x01
     // If we were to fail this call then we would need to complete the
     // IRP here.  Since we are not, set the status to SUCCESS and
     // call the next driver.
     MyKdPrint(D_Pnp,("QueryRemoveDevice\n"))
     status = STATUS_SUCCESS;
     if (Ext->DeviceType == DEV_BOARD)
     {
       if (is_board_in_use(Ext))
         status = STATUS_DEVICE_BUSY;
     }
     else
     {
       if (Ext->DeviceIsOpen)
         status = STATUS_DEVICE_BUSY;
     }

     if (status == STATUS_DEVICE_BUSY)
     {
       MyKdPrint(D_Pnp,("Can't Remove, Busy\n"))
       Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
       pass_down = 0;  // we are failing it out, no need to pass down
     }
     else
     {
       Ext->PNPState = SERIAL_PNP_QREMOVE;
       Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_REMOVING;
       Irp->IoStatus.Status = STATUS_SUCCESS;
       status = STATUS_SUCCESS;
     }
   break;

   case IRP_MN_REMOVE_DEVICE:  // 0x02
     // If we get this, we have to remove
     // Mark as not accepting requests
     Ext->DevicePNPAccept |= SERIAL_PNPACCEPT_REMOVING;


     // Complete all pending requests
     SerialKillPendingIrps(devobj);

       // Pass the irp down
       //WaitForLowerPdo(devobj, Irp);

     Irp->IoStatus.Status = STATUS_SUCCESS;

     MyKdPrint(D_Pnp,("RemoveDevice\n"))
     IoSkipCurrentIrpStackLocation (Irp);
       //IoCopyCurrentIrpStackLocationToNext(Irp);

       // We do decrement here because we incremented on entry here.
       //SerialIRPEpilogue(Ext);
     SerialIoCallDriver(Ext, pdo, Irp);

     // Wait for any pending requests we raced on.
     pendingIRPs = InterlockedDecrement(&Ext->PendingIRPCnt);

     MyKdPrint(D_Pnp,("Remove, C\n"))
     if (pendingIRPs) {
       MyKdPrint(D_Pnp,("Irp Wait\n"))
       KeWaitForSingleObject(&Ext->PendingIRPEvent, Executive,
          KernelMode, FALSE, NULL);
     }

     // Remove us
     SerialRemoveFdo(devobj);
     status = STATUS_SUCCESS;
     // MyKdPrint(D_Pnp,("End PnPDispatch(Remove)\n"))
   return status;   // BAIL


   case IRP_MN_QUERY_INTERFACE:         // 0x8
   case IRP_MN_QUERY_RESOURCES :       // 0x0A
   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:  // 0x0B
   case IRP_MN_READ_CONFIG:            // 0x0f
   case IRP_MN_WRITE_CONFIG:           // 0x10
   case IRP_MN_EJECT:                  // 0x11
   case IRP_MN_SET_LOCK:               // 0x12
   //case IRP_MN_PNP_DEVICE_STATE:       // 0x14
   case IRP_MN_QUERY_BUS_INFORMATION:  // 0x15
   //case IRP_MN_PAGING_NOTIFICATION:    // 0x16
   default:
      MyKdPrint(D_Pnp,("Unhandled\n"));
      // all these get passed down, we don't set the status return code
   break;
   }   // switch (irpStack->MinorFunction)

#if DBG
  if (* ((BYTE *)(Irp)) != 6)  // in signiture of irp
  {
    MyKdPrint(D_Pnp,("bad irp b!!!\n"))
  }
#endif
   if (pass_down)
   {
      MyKdPrint(D_Pnp,(" Send irp down\n"))
      // Pass to driver beneath us
      IoSkipCurrentIrpStackLocation(Irp);
      status = SerialIoCallDriver(Ext, pdo, Irp);
   }
   else
   {
      Irp->IoStatus.Status = status;
      //MyKdPrint(D_Pnp,(" Complete irp\n"))
      SerialCompleteRequest(Ext, Irp, IO_NO_INCREMENT);
   }

   // MyKdPrint(D_Pnp,(" End PnPDispatch\n"))

   return status;
}


#ifdef DO_BUS_EXTENDER
/*----------------------------------------------------------------------
  PnpPortPDO -
|----------------------------------------------------------------------*/
NTSTATUS PnpPortPDO(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
   PSERIAL_DEVICE_EXTENSION    Ext = devobj->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status = Irp->IoStatus.Status;

   switch (irpStack->MinorFunction)
   {
     case IRP_MN_START_DEVICE:   // 0x00
       status = STATUS_SUCCESS;
     break;

     case IRP_MN_STOP_DEVICE:
       status = STATUS_SUCCESS;
     break;

     case IRP_MN_REMOVE_DEVICE:
       MyKdPrint(D_Pnp,("Remove PDO\n"))
       // shut down everything, call iodelete device
       status = STATUS_SUCCESS;
     break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
       status = STATUS_SUCCESS;
     break;


     case IRP_MN_QUERY_CAPABILITIES: {  // x09
       PDEVICE_CAPABILITIES    deviceCapabilities;

        deviceCapabilities=irpStack->Parameters.DeviceCapabilities.Capabilities;
        MyKdPrint(D_Pnp,("Report Caps.\n"))
        // Set the capabilities.
        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

        // We cannot wake the system.
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

        // We have no latencies
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

        // No locking or ejection
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

        // Device can be physically removed.
        // Technically there is no physical device to remove, but this bus
        // driver can yank the PDO from the PlugPlay system, when ever it
        // receives an IOCTL_GAMEENUM_REMOVE_PORT device control command.
        //deviceCapabilities->Removable = TRUE;
        // we switch this to FALSE to emulate the stock com port behavior, kpb
        deviceCapabilities->Removable = FALSE;

        // not Docking device
        deviceCapabilities->DockDevice = FALSE;
 
        // BUGBUG: should we do uniqueID???
        deviceCapabilities->UniqueID = FALSE;

        status = STATUS_SUCCESS;
      }
     break;

     case IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
      if (irpStack->Parameters.QueryDeviceRelations.Type !=
          TargetDeviceRelation)
        break;  //

      {
         PDEVICE_RELATIONS pDevRel;

         // No one else should respond to this since we are the PDO
         ASSERT(Irp->IoStatus.Information == 0);
         if (Irp->IoStatus.Information != 0) {
            break;
         }

         pDevRel = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

         if (pDevRel == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
         }

         pDevRel->Count = 1;
         pDevRel->Objects[0] = devobj;
         ObReferenceObject(devobj);

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = (ULONG_PTR)pDevRel;
      }
     break;

     case IRP_MN_QUERY_ID:  // 0x13
     {
       switch (irpStack->Parameters.QueryId.IdType)
       {
        case BusQueryInstanceID:
        {
           WCHAR *wstr;
           CHAR our_id[40];

           // Build an instance ID.  This is what PnP uses to tell if it has
           // seen this thing before or not.
           // its used to form the ENUM\ key name along with the DeviceID.
           //Sprintf(our_id, "Ctm_%s", Ext->NtNameForPort);
           Sprintf(our_id, "Port%04d", PortExtToIndex(Ext,0));
           MyKdPrint(D_Pnp,("InstanceId:%s\n", our_id))
           wstr = str_to_wstr_dup(our_id, PagedPool);
           if ( wstr ) {
             // as per serenum bus enumerator:
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
           Irp->IoStatus.Information = (ULONG)wstr;
        }
        break;

        case BusQueryDeviceID:
        {
           // This is the name used under ENUM to form the device instance
           // name under which any new PDO nodes will be created.
           // after find new hardware install we find this as an example
           // new port node under ENUM:
           // Enum\CtmPort\RDevice\6&Port0000
           // Enum\CtmPort\RDevice\6&Port0000\Control
           // Enum\CtmPort\RDevice\6&Port0000\Device Parameters
           // Enum\CtmPort\RDevice\6&Port0000\LogConf

           WCHAR *wstr;
           CHAR our_id[40];

#ifdef S_VS
           strcpy(our_id, "CtmPort\\VSPORT");
#else
           strcpy(our_id, "CtmPort\\RKPORT");
#endif
           wstr = str_to_wstr_dup(our_id, PagedPool);
           MyKdPrint(D_Pnp,("DevID:%s\n", our_id))

           Irp->IoStatus.Information = (ULONG)wstr;
           if ( wstr ) {
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
        }
        break;

        case BusQueryHardwareIDs:
        {
            // return a multi WCHAR (null terminated) string (null terminated)
            // array for use in matching hardare ids in inf files;
           WCHAR *wstr;
           CHAR our_id[40];

#ifdef S_VS
           Sprintf(our_id, "CtmvPort%04d",
              PortExtToIndex(Ext, 0 /* driver_flag */) );
#else
           Sprintf(our_id, "CtmPort%04d", 
              PortExtToIndex(Ext, 0 /* driver_flag */) );
#endif
           MyKdPrint(D_Pnp,("HrdwrID:%s\n", our_id))
           wstr = str_to_wstr_dup(our_id, PagedPool);
           Irp->IoStatus.Information = (ULONG)wstr;
           if ( wstr ) {
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
        }  //BusQueryHardwareIDs
        break;

        case BusQueryCompatibleIDs:
        {
#if 0
           WCHAR *wstr;
           CHAR our_id[40];

           // The generic ids for installation of this pdo.

           Sprintf(our_id, "Cpt_CtmPort0001");
           MyKdPrint(D_Pnp,("CompID:%s\n", our_id))
           wstr = str_to_wstr_dup(our_id, PagedPool);

           Irp->IoStatus.Information = (ULONG)wstr;
           status = STATUS_SUCCESS;
#endif
           // no compatible id's
           Irp->IoStatus.Information = 0;
           status = STATUS_SUCCESS;
        }
        break;
        default:
           MyKdPrint(D_Pnp,(" UnHandled\n"))
           // Irp->IoStatus.Information = 0;
           // status = STATUS_SUCCESS;
        break;

       }  // switch IdType
     }  // IRP_MN_QUERY_ID
     break;

     case IRP_MN_QUERY_DEVICE_TEXT: // 0x0C
       MyKdPrint(D_Pnp,("QueryDevText\n"))

       if (irpStack->Parameters.QueryDeviceText.DeviceTextType
            != DeviceTextDescription)
       {
         MyKdPrint(D_Pnp,(" Unhandled Text Type\n"))
         break;
       }

       {
           // this is put in the Found New Hardware dialog box message.
           WCHAR *wstr;
#if DBG
           if (Irp->IoStatus.Information != 0)
           {
             MyKdPrint(D_Error,("StrExists!\n"))
           }
#endif

#ifdef S_VS
           wstr = str_to_wstr_dup("Comtrol VS Port", PagedPool);
#else
           wstr = str_to_wstr_dup("Comtrol Port", PagedPool);
#endif
           Irp->IoStatus.Information = (ULONG)wstr;
           if ( wstr ) {
             status = STATUS_SUCCESS;
           } else {
             status = STATUS_INSUFFICIENT_RESOURCES;
           }
       }
     break;  // IRP_MN_QUERY_DEVICE_TEXT

     default:
       //MyKdPrint(D_Pnp,(" PDO Unhandled\n"))
     break;
   }

   Irp->IoStatus.Status = status;
   InterlockedDecrement(&Ext->PendingIRPCnt);
   IoCompleteRequest (Irp, IO_NO_INCREMENT);
   MyKdPrint(D_Pnp,(" PDO Dispatch End\n"))
   return status;
}

/*----------------------------------------------------------------------
 BoardBusRelations -  handle  IRP_MN_QUERY_DEVICE_RELATIONS:  // 0x7
  for our board FDO entity.
|----------------------------------------------------------------------*/
NTSTATUS BoardBusRelations(IN PDEVICE_OBJECT devobj, IN PIRP Irp)
{
 PSERIAL_DEVICE_EXTENSION  Ext = devobj->DeviceExtension;
 PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
 PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
 NTSTATUS                    status          = STATUS_NOT_SUPPORTED;
 ULONG i, length, NumPDOs;
 PDEVICE_RELATIONS   relations;
 PSERIAL_DEVICE_EXTENSION ext;

  ASSERT( devobj );

  switch (irpStack->Parameters.QueryDeviceRelations.Type)
  {
    case BusRelations:
      MyKdPrint(D_Pnp,("BusRelations\n"))
      // Tell the plug and play system about all the PDOs.
      //
      // There might also be device relations below and above this FDO,
      // so, be sure to propagate the relations from the upper drivers.
      //
      // No Completion routine is needed so long as the status is preset
      // to success.  (PDOs complete plug and play irps with the current
      // IoStatus.Status and IoStatus.Information as the default.)
      //

      NumPDOs = 0;  // count the number of pdo's
      // count up pdo's for device
      ext = Ext->port_pdo_ext;
      while (ext != NULL)
      {
        ++NumPDOs;
        ext = ext->port_ext;
      }
      // The current number of PDOs
      i = 0;
      if (Irp->IoStatus.Information != 0)
        i = ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

      MyKdPrint(D_Pnp, ("Num PDOs:%d + %d\n", i, NumPDOs))

      length = sizeof(DEVICE_RELATIONS) +
              ((NumPDOs + i) * sizeof (PDEVICE_OBJECT));

      relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, length);

      if (NULL == relations) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      // Copy in the device objects so far
      if (i) {
          RtlCopyMemory (
                relations->Objects,
                ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                i * sizeof (PDEVICE_OBJECT));
      }
      relations->Count = NumPDOs + i;

      //
      // For each PDO on this bus add a pointer to the device relations
      // buffer, being sure to take out a reference to that object.
      // The PlugPlay system will dereference the object when it is done with
      // it and free the device relations buffer.
      //
      ext = Ext->port_pdo_ext;
      while (ext != NULL)
      {
        relations->Objects[i++] = ext->DeviceObject;
        ObReferenceObject (ext->DeviceObject); // add 1 to lock on this object
        ext = ext->port_ext;
      }

      // Set up and pass the IRP further down the stack
      Irp->IoStatus.Status = STATUS_SUCCESS;

      if (0 != Irp->IoStatus.Information) {
          ExFreePool ((PVOID) Irp->IoStatus.Information);
      }
      Irp->IoStatus.Information = (ULONG) relations;
    break;

    case EjectionRelations:
     MyKdPrint(D_Pnp, ("EjectRelations\n"))
    break;

    case PowerRelations:
     MyKdPrint(D_Pnp,("PowerRelations\n"))
    break;

    case RemovalRelations:
     MyKdPrint(D_Pnp,("RemovalRelations\n"))
    break;

    case TargetDeviceRelation:
     MyKdPrint(D_Pnp,("TargetDeviceRelations\n"))
    break;

    default:
     MyKdPrint(D_Pnp,("UnknownRelations\n"))
    break;
  }  // switch .Type

  status = STATUS_SUCCESS;
  return status;
}

#endif

/*----------------------------------------------------------------------
 WaitForLowerPdo -
|----------------------------------------------------------------------*/
NTSTATUS WaitForLowerPdo(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
 PSERIAL_DEVICE_EXTENSION  Ext = fdo->DeviceExtension;
 PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
 NTSTATUS status;
 KEVENT Event;

  KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

  IoCopyCurrentIrpStackLocationToNext(Irp);
  IoSetCompletionRoutine(Irp, SerialSyncCompletion, &Event,
                         TRUE, TRUE, TRUE);
  status = IoCallDriver(pdo, Irp);

  // Wait for lower drivers to be done with the Irp
  if (status == STATUS_PENDING)
  {
    MyKdPrint(D_Pnp,("WaitPend\n"))
    KeWaitForSingleObject (&Event, Executive, KernelMode, FALSE,
                            NULL);
    status = Irp->IoStatus.Status;
  }

  if (!NT_SUCCESS(status))
  {
    MyKdPrint(D_Pnp,("WaitErr\n"))
    return status;
  }
  return 0;
}

/*----------------------------------------------------------------------
 SerialPowerDispatch -
    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request

Return Value:
    The function value is the final status of the call
|----------------------------------------------------------------------*/
NTSTATUS SerialPowerDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Ext = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN hook_it = FALSE;
  PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
  BOOLEAN acceptingIRPs = TRUE;
  int index;

   // dump out some debug info
   index = irpStack->MinorFunction;
   if (index > 0x3)
     index = 0x4;

   if (Ext->IsPDO)
   {
#if DBG
     MyKdPrint(D_PnpPower,("Port PDO PowerIrp:%d,%s\n", irpStack->MinorFunction,
	power_strs[index]))
#endif
     return Serial_PDO_Power (DeviceObject, Irp);
   }

   // else it's a FDO
#if DBG
   if (Ext->DeviceType == DEV_BOARD)
   {
     MyKdPrint(D_PnpPower,("Board PowerIrp:%d,%s\n", irpStack->MinorFunction,
        power_strs[index]))
   }
   else
   {
     MyKdPrint(D_PnpPower,("Port PowerIrp:%d,%s\n", irpStack->MinorFunction,
        power_strs[index]))
   }
#endif
   return Serial_FDO_Power (DeviceObject, Irp);
}


/*----------------------------------------------------------------------
 Serial_FDO_Power - Handle board and port FDO power handling.
|----------------------------------------------------------------------*/
NTSTATUS Serial_FDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Ext = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN hook_it = FALSE;
  PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
  PDEVICE_OBJECT pPdo = Ext->Pdo;
  BOOLEAN acceptingIRPs = TRUE;
  POWER_STATE         powerState;
  POWER_STATE_TYPE    powerType;
  int ChangePower = 0;
  int fail_it = 0;

   powerType = irpStack->Parameters.Power.Type;
   powerState = irpStack->Parameters.Power.State;
   status      = STATUS_SUCCESS;

   acceptingIRPs = SerialIRPPrologue(Ext);

   if (acceptingIRPs == FALSE)
   {
     MyKdPrint(D_PnpPower,("Removed!\n"))
     status = STATUS_NO_SUCH_DEVICE;  // ?????????????
     fail_it = 1;
   }
   else
   {
     switch (irpStack->MinorFunction)
     {
       case IRP_MN_SET_POWER:
         MyKdPrint(D_PnpPower,("SET_POWER Type %d, SysState %d, DevStat %d\n",powerType,powerState.SystemState,powerState.DeviceState));
         // Perform different ops if it was system or device
         switch (irpStack->Parameters.Power.Type)
         {
           case DevicePowerState:
             // do power up & down work on device
             ChangePower = 1;
           break;
  
           case SystemPowerState:
             //if (pDevExt->OwnsPowerPolicy != TRUE) {
             //    status = STATUS_SUCCESS;
             //    goto PowerExit;
             // }
  

             ChangePower = 1;
             switch (irpStack->Parameters.Power.State.SystemState)
             {
               case PowerSystemUnspecified:
                 powerState.DeviceState = PowerDeviceUnspecified;
               break;
  
               case PowerSystemWorking:
                 powerState.DeviceState = PowerDeviceD0;
               break;
  
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:
               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:
               case PowerSystemMaximum:
               default:
                 powerState.DeviceState = PowerDeviceD3;
               break;
             }
           break;  // end case SystemPowerState
  
         }  // end switch
  
        if (ChangePower)
        {
          // If we are already in the requested state, just pass the IRP down
          if (Ext->PowerState == powerState.DeviceState)
          {
             MyKdPrint(D_PnpPower,(" Same\n"))
             status      = STATUS_SUCCESS;
             Irp->IoStatus.Status = status;
             ChangePower = 0;
          }
        }
  
        if (ChangePower)
        {
          MyKdPrint(D_PnpPower,("ExtPowerState %d, DeviceState %d\n",Ext->PowerState,powerState.DeviceState));
          switch (powerState.DeviceState)
          {
            case PowerDeviceD0: 
              if (Ext->DeviceType == DEV_BOARD)
              {
                // powering up board.
                MyKdPrint(D_PnpPower,(" Hook\n"))
                ASSERT(Ext->LowerDeviceObject);
                hook_it = TRUE;
              }
            break;
  
            case PowerDeviceD1:  
            case PowerDeviceD2: 
            case PowerDeviceD3:
            default:
              // we should be doing this on the way up in the hook routine.
              MyKdPrint(D_PnpPower,(" PwDown\n"))
              // Before we power down, call PoSetPowerState
              PoSetPowerState(DeviceObject, powerType, powerState);
  
              // Shut it down
              //.....
              //
       
              Ext->PowerState = powerState.DeviceState; // PowerDeviceD0;
              if (Ext->DeviceType == DEV_BOARD)
              {
                MyKdPrint(D_PnpPower,(" PwDown Board\n"))
                // shut some things down, so it comes back up ok
#if S_RK
                Ext->config->RocketPortFound = 0;   // this tells if its started
#endif
                Ext->config->HardwareStarted = FALSE;
              }
              Irp->IoStatus.Status = STATUS_SUCCESS;
              status      = STATUS_SUCCESS;
            break;
          }   // switch (IrpSp->Parameters.Power.State.DeviceState)
        }  // ChangePower
       break;  // SET_POWER
  
       case IRP_MN_QUERY_POWER:
         MyKdPrint(D_PnpPower,(" QueryPower SystemState 0x%x\n",irpStack->Parameters.Power.State.SystemState))
           // if they want to go to a power-off state(sleep, hibernate, etc)
         if (irpStack->Parameters.Power.State.SystemState != PowerSystemWorking)
         {
           MyKdPrint(D_PnpPower,(" QueryPower turn off\n"))
           // only handle power logic for the board as a whole
           if (Ext->DeviceType == DEV_BOARD)
           {
             MyKdPrint(D_PnpPower,(" PwDown Board\n"))
             // if a port is open and being used, then fail the request
#if 0
// try to get the wake up restore of hardware working...
// kpb, 2-7-99
             if (is_board_in_use(Ext))
             {
               MyKdPrint(D_PnpPower,(" PwDown Board In Use!\n"))
               // if wants to powerdown
               // BUGBUG:, refuse hibernation
               status = STATUS_NO_SUCH_DEVICE;  // ?
               fail_it = 1;
             }
             else
#endif
             {
               MyKdPrint(D_PnpPower,(" PwDown Board, allow it!\n"))
#ifdef MTM_CLOSE_NIC_ATTEMPT
               if ( Driver.nics ) {
                 for( i=0; i<VS1000_MAX_NICS; i++ ) {
                   if ( Driver.nics[i].NICHandle ) {
                     MyKdPrint(D_PnpPower,("Closing Nic %d\n",i))
                     NicClose( &Driver.nics[i] );
                   }
                 }
               }
#endif
             }
           }
         }
         if (!fail_it)
         {
           status = STATUS_SUCCESS;
           Irp->IoStatus.Status = status;
         }
       break;
       //case IRP_MN_WAIT_WAKE:
         // Here is where support for a
         // serial device (like a modem) waking the system when the
         // phone rings.
       //case IRP_MN_POWER_SEQUENCE:
       default:
       break;
     }   // switch (irpStack->MinorFunction)
   }   // else, handle irp

   if (fail_it)
   {
     // status assumed set above
     PoStartNextPowerIrp (Irp);
     Irp->IoStatus.Information = 0;
     Irp->IoStatus.Status = status;
     InterlockedDecrement(&Ext->PendingIRPCnt);
     IoCompleteRequest (Irp, IO_NO_INCREMENT);
     return status;
   }

   // Pass to the lower driver
   if (hook_it)
   {
     IoCopyCurrentIrpStackLocationToNext (Irp);
     MyKdPrint(D_PnpPower,(" Hooked\n"))
     IoSetCompletionRoutine(Irp, OurPowerCompletion, NULL, TRUE, TRUE, TRUE);
	 MyKdPrint(D_PnpPower,(" Ready to send Irp 0x%x to PDO 0x%x\n", Irp, pdo))
     status = PoCallDriver(pdo, Irp);
     // hooking proc is responsible for decrementing reference count in ext
     // and calling PoStartNextPowerIrp().
   }
   else
   {
     IoCopyCurrentIrpStackLocationToNext (Irp);
     /// try this ^ instead ---- IoSkipCurrentIrpStackLocation (Irp);
     MyKdPrint(D_PnpPower,(" Passed\n"))
     PoStartNextPowerIrp(Irp);
     status = PoCallDriver(pdo, Irp);
     SerialIRPEpilogue(Ext);
   }

   MyKdPrint(D_PnpPower,("End PowerDisp\n"))
   return status;
}

/*----------------------------------------------------------------------
 Serial_PDO_Power - Handle port PDO power handling.
|----------------------------------------------------------------------*/
NTSTATUS Serial_PDO_Power (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
  PSERIAL_DEVICE_EXTENSION Ext = DeviceObject->DeviceExtension;
  PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN hook_it = FALSE;
  PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;
  BOOLEAN acceptingIRPs = TRUE;
  POWER_STATE         powerState;
  POWER_STATE_TYPE    powerType;

   powerType = irpStack->Parameters.Power.Type;
   powerState = irpStack->Parameters.Power.State;
   status      = STATUS_SUCCESS;


     switch (irpStack->MinorFunction)
     {
       case IRP_MN_SET_POWER:
        if (powerType == SystemPowerState)
        {
           MyKdPrint(D_PnpPower,(" SysPower\n"))
           status      = STATUS_SUCCESS;
           Irp->IoStatus.Status = status;
           break;
        }

        if (powerType != DevicePowerState)
        {
          MyKdPrint(D_PnpPower,(" OtherType\n"))
          // They asked for a system power state change which we can't do.
          // Pass it down to the lower driver.
          status      = STATUS_SUCCESS;
          Irp->IoStatus.Status = status;
          break;
        }

        // If we are already in the requested state, just pass the IRP down
        if (Ext->PowerState == powerState.DeviceState)
        {
          MyKdPrint(D_PnpPower,(" Same\n"))
          status      = STATUS_SUCCESS;
          Irp->IoStatus.Status = status;
          break;
        }

        MyKdPrint(D_PnpPower,(" Set\n"))
        Ext->PowerState = powerState.DeviceState; // PowerDeviceD0;
        PoSetPowerState(DeviceObject, powerType, powerState);
      break;

      case IRP_MN_QUERY_POWER:
        status = STATUS_SUCCESS;
      break;

      case IRP_MN_WAIT_WAKE:
      case IRP_MN_POWER_SEQUENCE:
      default:
         MyKdPrint(D_PnpPower,("Not Imp!\n"))
         status = STATUS_NOT_IMPLEMENTED;
      break;
     }

     Irp->IoStatus.Status = status;
     PoStartNextPowerIrp (Irp);
     IoCompleteRequest (Irp, IO_NO_INCREMENT);
     MyKdPrint(D_PnpPower,("End PDO PowerDisp\n"))
     return status;
}

/*----------------------------------------------------------------------
 SerialStartDevice -
    This routine first passes the start device Irp down the stack then
    it picks up the resources for the device, ititializes, puts it on any
    appropriate lists (i.e shared interrupt or interrupt status) and 
    connects the interrupt.

Arguments:

    Fdo - Pointer to the functional device object for this device
    Irp - Pointer to the IRP for the current request

Return Value:
    Return status
|----------------------------------------------------------------------*/
NTSTATUS SerialStartDevice(
        IN PDEVICE_OBJECT Fdo,
        IN PIRP Irp)
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   PSERIAL_DEVICE_EXTENSION Ext = Fdo->DeviceExtension;
   PDEVICE_OBJECT pdo = Ext->LowerDeviceObject;

   MyKdPrint(D_Pnp,("SerialStartDevice\n"))

   // Set up the external naming and create the symbolic link
   // Pass this down to the Pdo
   status = WaitForLowerPdo(Fdo, Irp);

   status = STATUS_SUCCESS;
   // Do the serial specific items to start the device
   status = SerialFinishStartDevice(Fdo,
            irpStack->Parameters.StartDevice.AllocatedResources,
            irpStack->Parameters.StartDevice.AllocatedResourcesTranslated);

   Irp->IoStatus.Status = status;
   MyKdPrint(D_Pnp,("End Start Dev\n"))
   return status;
}

/*----------------------------------------------------------------------
 SerialSyncCompletion -
|----------------------------------------------------------------------*/
NTSTATUS SerialSyncCompletion(
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PKEVENT SerialSyncEvent
                       )
{
   KeSetEvent(SerialSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}

/*----------------------------------------------------------------------
 SerialFinishStartDevice -
    This routine starts driver hardware.  On the RocketPort, this is
    a board, or a port.  On the VS, this would be the whole VS driver
    (all boxes) or a individual port.

    A Pnp ADDDEVICE call(in pnpadd.c) should have been seen before this
    to setup the driver.  After this, we may see Starts or Stops on the
    hardware, which the OS may start and stop to change resource assignments,
    etc.

Arguments:

   Fdo         -  Pointer to the Functional Device Object that is starting
   resourceList   -  Pointer to the untranslated resources needed by this device
   trResourceList -  Pointer to the translated resources needed by this device
   PUserData      -  Pointer to the user-specified resources/attributes 
   
  Return Value:
    STATUS_SUCCESS on success, something else appropriate on failure
|----------------------------------------------------------------------*/
NTSTATUS SerialFinishStartDevice(IN PDEVICE_OBJECT Fdo,
           IN PCM_RESOURCE_LIST resourceList,
           IN PCM_RESOURCE_LIST trResourceList)
{
   PSERIAL_DEVICE_EXTENSION Ext = Fdo->DeviceExtension;
   NTSTATUS status;
   DEVICE_CONFIG *pConfig;
   PSERIAL_DEVICE_EXTENSION newExtension = NULL;
   PDEVICE_OBJECT NewDevObj;
   int ch;
   int is_fdo = 1;
#ifdef NT50
   PWSTR  iBuffer;
#endif

   MyKdPrint(D_Pnp,("SerialFinishStartDevice\n"))

   pConfig = Ext->config;

   MyKdPrint(D_Pnp,("ChkPt A\n"))

   if (Ext->DeviceType != DEV_BOARD)
   {
     MyKdPrint(D_Pnp,("Start PnpPort\n"))
     Ext->FdoStarted     = TRUE;  // i don't thinks this is used on ports
#ifdef NT50
     // Create a symbolic link with IoRegisterDeviceInterface() 
     // 
     status = IoRegisterDeviceInterface( Ext->Pdo,
	                                     (LPGUID)&GUID_CLASS_COMPORT,
		 							     NULL,
									     &Ext->DeviceClassSymbolicName );

     if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't register class association\n"))
        Ext->DeviceClassSymbolicName.Buffer = NULL;
	 }
     else {

       MyKdPrint(D_Init, ("Registering class association for:\n PDO:0x%8x\nSymLink %s\n",
		         Ext->Pdo, UToC1(&Ext->DeviceClassSymbolicName)))
	 }

      // Now set the symbolic link for the interface association 
      //

     status = IoSetDeviceInterfaceState( &Ext->DeviceClassSymbolicName,
                                         TRUE);

     if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't set class association for %s\n",
	    	 UToC1(&Ext->DeviceClassSymbolicName)))
	 }
     else {

        MyKdPrint(D_PnpAdd, ("Enable class association for device: %s\n", 
			 UToC1(&Ext->DeviceClassSymbolicName)))
	 }

#if 0
     // Strictly for verification - get the entire list of COM class interfaces
	 // for up to 6 COM ports

	 status = IoGetDeviceInterfaces( (LPGUID)&GUID_CLASS_COMPORT, 
		                             NULL, // No PDO - get 'em all
                                     0,
									 &iBuffer );

     if (!NT_SUCCESS(status)) {

        MyKdPrint(D_Error,("Couldn't get interface list for GUID_CLASS_COMPORT\n"))
	 }
     else {

		PWCHAR pwbuf = iBuffer;
		char cbuf[128];
		int  j = 0;
		int  ofs = 0;

		while ( (pwbuf != 0) && (j < 8) ){

           WStrToCStr( cbuf, pwbuf, sizeof(cbuf) );
        
		   MyKdPrint(D_Pnp, ("COM port interface %d: %s\n", j, cbuf))

		   ofs += strlen(cbuf) + 1;
		   pwbuf = &iBuffer[ofs];
		   j++;
        }
		ExFreePool(iBuffer);
	 }
#endif

#endif

     status = STATUS_SUCCESS;
     return status;
   }

   if (Ext->FdoStarted == TRUE)
   {
     MyKdPrint(D_Error,("ReStart PnpBrd\n"))
     status = STATUS_SUCCESS;
     return status;
   }

   if (!Driver.NoPnpPorts)
      is_fdo = 0;  // eject PDOs representing port hardware.

   // Get the configuration info for the device.
#ifdef S_RK
   status = RkGetPnpResourceToConfig(Fdo, resourceList, trResourceList,
                              pConfig);

   if (!NT_SUCCESS (status)) {
     Eprintf("StartErr 1N");
     return status;
   }

#ifdef DO_ISA_BUS_ALIAS_IO
   status = Report_Alias_IO(Ext);
   if (status != 0)
   {
      Eprintf("StartErr Alias-IO");
      MyKdPrint(D_Pnp,("Error 1P\n"))
      status = STATUS_INSUFFICIENT_RESOURCES;
      return status;
   }
   MyKdPrint(D_Pnp,("ChkPt B\n"))
#endif
//DELF
MyKdPrint(D_Pnp,("INIT RCK\n"))
//END DELF
   status = RocketPortSpecialStartup(Ext);
   if (status != STATUS_SUCCESS)
   {
     Eprintf("StartErr 1J");
     return status;
   }
#endif

   MyKdPrint(D_Pnp,("ChkPt C\n"))

#ifdef S_VS
   status = VSSpecialStartup(Ext);
   if (status != STATUS_SUCCESS)
   {
     Eprintf("StartErr 1J");
     return status;
   }
#endif

   //----- Create our port devices, if we are doing pnp ports, then
   // create PDO's, if not, then create normal com-port device objects
   // (same as FDO's.)
   for (ch=0; ch<Ext->config->NumPorts; ch++)
   {
     //MyKdPrint(D_Pnp,("FS,ChanInit:%d\n", ch))
     status = CreatePortDevice(
                          Driver.GlobalDriverObject,
                          Ext, // parent ext.
                          &newExtension,
                          ch,
                          is_fdo);
     if (status != STATUS_SUCCESS)
     {
       Eprintf("StartErr 1Q");
       return status;
     }
     NewDevObj = newExtension->DeviceObject;  //return the new device object
     NewDevObj->Flags |= DO_POWER_PAGABLE;

     if (!is_fdo)  // eject PDOs representing port hardware.
       newExtension->IsPDO = 1;  // we are a pdo

#if S_RK
     if (Ext->config->RocketPortFound)  // if started(not delayed isa)
#endif
     {
       status = StartPortHardware(newExtension,
                         ch);  // channel num, port index

       if (status != STATUS_SUCCESS)
       {
         Eprintf("StartErr 1O");
         return status;
       }
     }
   }  // for ports

#ifdef S_RK
   if (Ext->config->RocketPortFound)  // if started(not delayed isa)
#endif
   {
     Ext->config->HardwareStarted = TRUE;

     // send ROW configuration to SocketModems
     InitSocketModems(Ext);
#ifdef S_RK
	 InitRocketModemII (Ext);
#endif
   }
   MyKdPrint(D_Pnp,("ChkPt D\n"))

  //---- start up the timer
  if (!Driver.TimerCreated)
  {
#ifdef S_RK
    Driver.SetupIrq = 0;
#endif
    //MyKdPrint(D_Pnp,("before rcktinitpolltimer\n"))
    RcktInitPollTimer();
    //MyKdPrint(D_Pnp,("after rcktinitpolltimer\n"))

    KeSetTimer(&Driver.PollTimer,
               Driver.PollIntervalTime,
               &Driver.TimerDpc);
  }
  MyKdPrint(D_Pnp,("ChkPt F, after\n"))

  Ext->FdoStarted = TRUE;

  //if (Drier.VerboseLog)
  //  Eprintf("Success start dev");

   status = STATUS_SUCCESS;
   return status;
}

#ifdef S_RK
/*-----------------------------------------------------------------------
 RocketPortSpecialStartup -
|-----------------------------------------------------------------------*/
static NTSTATUS RocketPortSpecialStartup(PSERIAL_DEVICE_EXTENSION Ext)

{
  int ch;
  int start_isa_flag;
  NTSTATUS status = STATUS_SUCCESS;
  PSERIAL_DEVICE_EXTENSION tmpExt;
  PSERIAL_DEVICE_EXTENSION newExt;

  if (Ext->config->BusType == Isa)
  {
    MyKdPrint(D_PnpPower,("pnp- ISA brd Index:%d\n",
       Ext->config->ISABrdIndex))

    if (Ext->config->ISABrdIndex == 0)
      start_isa_flag = 1;
    else if (is_first_isa_card_started())
      start_isa_flag = 1;
    else
    {
      MyKdPrint(D_PnpPower,("Delay 2ndary ISA card start\n"))
      start_isa_flag = 0;
    }
  }

  //----- Init the RocketPort hardware
  if ((Ext->config->BusType == Isa) && (!start_isa_flag))
    status = 0;  // skip, can't start until we get the first board
  else
  {
    status = InitController(Ext);  // this sets RocketPortFound = TRUE if ok
    if (status != 0)
    {
      status = STATUS_INSUFFICIENT_RESOURCES;
      MyKdPrint(D_Error,("Brd failed startup\n"))

      //if (Driver.VerboseLog)
      //  Eprintf("Error InitCtrl");
      return status;
    }
    MyKdPrint(D_PnpPower,("Brd started\n"))
  }

  if ((Ext->config->BusType == Isa) && (is_first_isa_card_started()) &&
       (is_isa_cards_pending_start()) )
  {
    MyKdPrint(D_Pnp,("Do Pending\n"))
    tmpExt = Driver.board_ext;
    while (tmpExt)
    {
      if ((tmpExt->config->BusType == Isa) &&
          (!tmpExt->config->RocketPortFound))   // this tells if its started
      {
        MyKdPrint(D_Pnp,("Pending 1A\n"))
        status = InitController(tmpExt);  // this sets RocketPortFound = TRUE if ok

        if (status != 0)
        {
          status = STATUS_INSUFFICIENT_RESOURCES;
          if (Driver.VerboseLog)
            Eprintf("Error 5C");
          return status;
        }

        MyKdPrint(D_Pnp,("Pend 2A\n"))
        //----- Find and initialize the controller ports
        newExt = tmpExt->port_ext;
        ch=0;
        while (newExt)
        {
          status = StartPortHardware(newExt,
                         ch);  // channel num, port index

          if (status != STATUS_SUCCESS)
          {
            Eprintf("StartErr 1N");
            return status;
          }
          newExt = newExt->port_ext;
          ++ch;
        }
        tmpExt->config->HardwareStarted = TRUE;

        // send ROW configuration to SocketModems
        InitSocketModems(tmpExt);

        MyKdPrint(D_Pnp,("Pending OK\n"))
      }
      tmpExt = tmpExt->board_ext;
    }
  }  // if isa boards to startup

  return status;
}
#endif

/*-----------------------------------------------------------------------

   This routine kills any irps pending for the passed device object.
   
Arguments:
    DeviceObject - Pointer to the device object whose irps must die.

Return Value:
    VOID
|-----------------------------------------------------------------------*/
VOID SerialKillPendingIrps(PDEVICE_OBJECT DeviceObject)
{
   PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
   KIRQL oldIrql;
   
   //PAGED_CODE();
   //SerialDump (SERTRACECALLS,("SERIAL: Enter SerialKillPendingIrps\n"));

   // this is for the FDO, which currently is the BOARD, so we have to
   // do all ports for this board.(THIS IS NOT A PORT EXTENSION!!!!!)

   // First kill all the reads and writes.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->WriteQueue,
        &extension->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->ReadQueue,
        &extension->CurrentReadIrp
        );

    // Next get rid of purges.
    SerialKillAllReadsOrWrites(
        DeviceObject,
        &extension->PurgeQueue,
        &extension->CurrentPurgeIrp
        );

    // Now get rid a pending wait mask irp.
    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->CurrentWaitIrp) {

        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = extension->CurrentWaitIrp->CancelRoutine;
        extension->CurrentWaitIrp->Cancel = TRUE;

        if (cancelRoutine) {

            extension->CurrentWaitIrp->CancelIrql = oldIrql;
            extension->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(
                DeviceObject,
                extension->CurrentWaitIrp
                );

        }

    } else {

        IoReleaseCancelSpinLock(oldIrql);

    }
    //SerialDump (SERTRACECALLS,("SERIAL: Leave SerialKillPendingIrps\n"));
}

/*-----------------------------------------------------------------------

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPPrologue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:
   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:
   None.
|-----------------------------------------------------------------------*/
VOID SerialIRPEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt)
{
   ULONG pendingCnt;

   pendingCnt = InterlockedDecrement(&PDevExt->PendingIRPCnt);

#if DBG
   //MyKdPrint(D_Pnp,("Exit PendingIrpCnt:%d\n", PDevExt->PendingIRPCnt))
#endif

   if (pendingCnt == 0)
   {
      MyKdPrint(D_Pnp,("Set PendingIRPEvent\n"))
      KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
   }
}

/*-----------------------------------------------------------------------
 SerialIoCallDriver -
|-----------------------------------------------------------------------*/
NTSTATUS SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
           PDEVICE_OBJECT PDevObj,
           PIRP PIrp)
{
   NTSTATUS status;

   ASSERT( PDevObj );

   status = IoCallDriver(PDevObj, PIrp);
   SerialIRPEpilogue(PDevExt);
   return status;
}

/*-----------------------------------------------------------------------
 SerialPoCallDriver -
|-----------------------------------------------------------------------*/
NTSTATUS SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt,
           PDEVICE_OBJECT PDevObj,
           PIRP PIrp)
{
   NTSTATUS status;

   status = PoCallDriver(PDevObj, PIrp);
   SerialIRPEpilogue(PDevExt);
   return status;
}

/*-----------------------------------------------------------------------
    This routine is a completion handler that is called after the COM port
    has been powered up.  It sets the COM port in a known state by calling
    SerialReset, SerialMarkClose, SerialClrRTS, and SerialClrDTR.  The it
    does a PoCompleteRequest to finish off the power Irp.

Arguments:
    DeviceObject - Pointer to the device object for this device
    Irp - Pointer to the IRP for the current request
    Context -  None

Return Value:
    Return status in IRP when being called (if not STATUS_SUCCESS) or 
    STATUS_SUCCESS.
|-----------------------------------------------------------------------*/
NTSTATUS OurPowerCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
   NTSTATUS                    status      = Irp->IoStatus.Status;
   PSERIAL_DEVICE_EXTENSION    Ext   = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION          irpStack    = IoGetCurrentIrpStackLocation(Irp);
   POWER_STATE         powerState;
   POWER_STATE_TYPE    powerType;

   powerType = irpStack->Parameters.Power.Type;
   powerState = irpStack->Parameters.Power.State;

   MyKdPrint(D_PnpPower,("In OurPowerCompletion\n"))

   if (irpStack->MinorFunction == IRP_MN_SET_POWER)
   {
      if (powerState.DeviceState == PowerDeviceD0)
      {
        MyKdPrint(D_PnpPower,("Restoring to Power On State D0\n"))

        status = STATUS_SUCCESS;
        // set hardware to known power up state
        Ext->PowerState = powerState.DeviceState; // PowerDeviceD0;

        if (Ext->DeviceType == DEV_BOARD)
        {
          status = PowerUpDevice(Ext);
        }  // board device
        else if (Ext->DeviceType == DEV_PORT)
        {
          Ext->config->HardwareStarted = TRUE;
        }

        PoSetPowerState(DeviceObject, powerType, powerState);
      }
      else  // if (powerState.DeviceState == PowerDeviceD3)
      {
        status = STATUS_SUCCESS;
        // Clear the flag saying we are waiting for a power down
        Ext->ReceivedQueryD3  = FALSE;

        Ext->PowerState = PowerDeviceD3;
     }
   }

   InterlockedDecrement(&Ext->PendingIRPCnt);

   PoStartNextPowerIrp(Irp);
   return status;
}

/*-----------------------------------------------------------------------
 RestorePortSettings - Try to restore port hardware settings.  Called
   after power-off sleep mode.
|-----------------------------------------------------------------------*/
void RestorePortSettings(PSERIAL_DEVICE_EXTENSION Ext)
{
  SERIAL_HANDFLOW TempHandFlow;
  DWORD TempDTRRTSStatus;
  DWORD xorDTRRTSStatus;

#ifdef S_RK
  // remember what the status of pins are coming into this
  // so we can try to put them back to what they were prior to
  // hardware re-initialization.
  TempDTRRTSStatus = Ext->DTRRTSStatus; // SERIAL_DTR_STATE;

  if(sGetChanStatus(Ext->ChP) & STATMODE)
  {  // Take channel out of statmode if necessary
     sDisRxStatusMode(Ext->ChP);
  }
  // pDisLocalLoopback(Ext->Port);
  // Clear any pending modem changes
  sGetChanIntID(Ext->ChP);
  sEnRxFIFO(Ext->ChP);    // Enable Rx
  sEnTransmit(Ext->ChP);    // Enable Tx
  sSetRxTrigger(Ext->ChP,TRIG_1);  // always trigger
  sEnInterrupts(Ext->ChP, Ext->IntEnables);// allow interrupts

  ForceExtensionSettings(Ext);

  // make a temp. copy of handflow struct
  memcpy(&TempHandFlow, &Ext->HandFlow, sizeof(TempHandFlow));

  // force updates in SerialSetHandFlow, which looks for delta change.
  Ext->HandFlow.ControlHandShake = ~TempHandFlow.ControlHandShake;
  Ext->HandFlow.FlowReplace = ~TempHandFlow.FlowReplace;

  SerialSetHandFlow(Ext, &TempHandFlow);  // in ioctl.c

  // program hardware baudrate
  ProgramBaudRate(Ext, Ext->BaudRate);

  xorDTRRTSStatus = Ext->DTRRTSStatus ^ TempDTRRTSStatus;

  // try to restore the actual dtr & rts outputs 
  if (xorDTRRTSStatus & SERIAL_DTR_STATE)  // changed
  {
    // if not auto-handshake dtr mode
    if (!((Ext->HandFlow.ControlHandShake & SERIAL_DTR_MASK) ==
                    SERIAL_DTR_HANDSHAKE ))
    {
      if (TempDTRRTSStatus & SERIAL_DTR_STATE)  // was on
      {
        sSetDTR(Ext->ChP);
      }
      else
      {
        sClrDTR(Ext->ChP);
      }
    }  // not auto-dtr flow
  }  // chg in dtr

  if (xorDTRRTSStatus & SERIAL_RTS_STATE)  // changed
  {
    // if not auto-flow control rts  
    if (!((Ext->HandFlow.ControlHandShake & SERIAL_RTS_MASK) == 
        SERIAL_RTS_HANDSHAKE))
    {
      if (TempDTRRTSStatus & SERIAL_RTS_STATE)  // was on
      {
        sSetRTS(Ext->ChP);
      }
      else
      {
        sClrRTS(Ext->ChP);
      }
    } // chg in rts
    Ext->DTRRTSStatus = TempDTRRTSStatus;
  }  
#endif
  // the VS boxes will not be powered off, and will hold their state
  // so no hardware re-initialization is needed.  The box will have
  // probably timed out the connection, and force a re-sync operation,
  // we might want to pro-actively start this so there is a smaller
  // delay...
}

/*-----------------------------------------------------------------------
 PowerUpDevice - Used to bring power back on after turning it off.
|-----------------------------------------------------------------------*/
NTSTATUS PowerUpDevice(PSERIAL_DEVICE_EXTENSION    Ext)
{
  PSERIAL_DEVICE_EXTENSION    port_ext;
  int ch;
  NTSTATUS status = STATUS_SUCCESS;

#ifdef S_RK
  MyKdPrint(D_PnpPower,("RocketPort Init %d\n",Ext->config->HardwareStarted))
  status = RocketPortSpecialStartup(Ext);
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error,("RocketPort Init Failed\n"))
    //return status;
  }
  if (Ext->config->RocketPortFound)  // if started(not delayed isa)
    Ext->config->HardwareStarted = TRUE;
#endif

#ifdef S_VS
  MyKdPrint(D_PnpPower,("VS Init\n"))
  status = VSSpecialStartup(Ext);
  if (status != STATUS_SUCCESS)
  {
    MyKdPrint(D_Error,("VS Init Failed\n"))
    //return status;
  }
  Ext->config->HardwareStarted = TRUE;
#endif

  if (Ext->config->HardwareStarted == TRUE)
  {
    if (Ext->port_ext == NULL)
      {MyKdPrint(D_Error,("No Ports\n")) }

    //----- Find and initialize the controller ports
    port_ext = Ext->port_ext;
    ch=0;
    while (port_ext)
    {
      MyKdPrint(D_PnpPower,("PowerUp Port %d\n", ch))
      status = StartPortHardware(port_ext,
                 ch);  // channel num, port index

      if (status != STATUS_SUCCESS)
      {
        
        MyKdPrint(D_Error,("PortPowerUp Err1\n"))
        return status;
      }
      MyKdPrint(D_PnpPower,("PowerUp Port %d Restore\n", ch))
      RestorePortSettings(port_ext);

      port_ext = port_ext->port_ext;
      ++ch;
    }
  }
  else
  {
    MyKdPrint(D_Error,("Not started\n"))
  }
  // send ROW configuration to SocketModems
  //InitSocketModems(Ext);

  status = STATUS_SUCCESS;
  return status;
}

/*-----------------------------------------------------------------------
 SerialRemoveFdo -
|-----------------------------------------------------------------------*/
NTSTATUS SerialRemoveFdo(IN PDEVICE_OBJECT pFdo)
{
   PSERIAL_DEVICE_EXTENSION extension = pFdo->DeviceExtension;

   MyKdPrint(D_Pnp,("SerialRemoveFdo\n"))

   // Only do these things if the device has started
   //(comment out 8-15-98) if (extension->FdoStarted)
   {
     if (extension->DeviceType == DEV_BOARD)
     {
       // BUGBUG, shut down this board(are we deallocating resources?)!!!
       RcktDeleteBoard(extension);
       if (Driver.board_ext == NULL)  // no more boards, so delete driver obj
       {
         // Delete Driver obj
         RcktDeleteDriverObj(Driver.driver_ext);
         Driver.driver_ext = NULL;  // no more boards
#ifdef S_VS
         // to allow the driver to unload from nt50, we need to
         // stop the nic-binding thread, shut down the nic
         // cards and the protocol from ndis
         init_stop();  // unload thread, ndis nic cards, etc
#endif
         {
           PDEVICE_OBJECT currentDevice = Driver.GlobalDriverObject->DeviceObject;
           int i;

           i = 0;
           while(currentDevice)
           {
             currentDevice = currentDevice->NextDevice;
             if (currentDevice)
               ++i;
           }
           if (i != 0)
           {
             MyKdPrint(D_Pnp,("Err, %d Devices still remain\n",i))
           }
           else
           {
             MyKdPrint(D_Pnp,("Ok remove\n"))
           }
         }
       }
     }
     else
     {
       RcktDeletePort(extension);
       // must be a port fdo, kill it
     }
   }

   MyKdPrint(D_Pnp,("End SerialRemoveFdo\n"))

   return STATUS_SUCCESS;
}

#endif  // NT50

/*-----------------------------------------------------------------------

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPEpilogue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:
   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:
    TRUE if the device can accept IRP's.
|-----------------------------------------------------------------------*/
BOOLEAN SerialIRPPrologue(IN PSERIAL_DEVICE_EXTENSION PDevExt)
{
   InterlockedIncrement(&PDevExt->PendingIRPCnt);
#ifdef NT50
   return PDevExt->DevicePNPAccept == SERIAL_PNPACCEPT_OK ? TRUE : FALSE;
#else
   return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\pnp.h ===
// Define an Interface Guid to access the game port enumerator
//

#undef FAR
#define FAR
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

#ifdef NT50
//DEFINE_GUID (GUID_CTMPORT_BUS_ENUMERATOR, 0x11223344, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda);
//  11223344-684a-11d0-b6f6-00a0c90f57da

#include <initguid.h>

// GUIDs for the board & ports
//
DEFINE_GUID (GUID_CTMPORT_MPS, 0x50906cb8, 0xba12, 0x11d1, 0xbf, 0x5d, 0x00, 0x00, 0xf8, 0x05, 0xf5, 0x30);
// 50906cb8-ba12-11d1-bf5d-0000f805f530
//DEFINE_GUID (GUID_CLASS_COMPORT, 0x4d36e978, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18);
// 4d36e978-e325-11ce-bfc1-08002be10318
// GUID_CLASS_COMPORT changed for Whistler 
DEFINE_GUID (GUID_CLASS_COMPORT, 0x86e0d1e0, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73);
// 86e0d1e0-8089-11d0-9ce4-08003e301f73

#endif

NTSTATUS SerialPnpDispatch(IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS SerialPowerDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

VOID SerialKillPendingIrps(PDEVICE_OBJECT DeviceObject);
BOOLEAN SerialIRPPrologue(IN PSERIAL_DEVICE_EXTENSION PDevExt);
VOID SerialIRPEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt);
NTSTATUS
SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
		   PIRP PIrp);
NTSTATUS
SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
		   PIRP PIrp);

#ifdef NT50
#define SerialCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      IoCompleteRequest((PIrp), (PriBoost)); \
      SerialIRPEpilogue((PDevExt)); \
   }
#else
#define SerialCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      IoCompleteRequest((PIrp), (PriBoost)); \
      InterlockedDecrement(&((PDevExt)->PendingIRPCnt)); \
   }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\pnprckt.h ===
#ifdef S_RK
int GetPCIRocket(ULONG BaseAddr, DEVICE_CONFIG *CfCtl);
NTSTATUS
RkGetPnpResourceToConfig(IN PDEVICE_OBJECT Fdo,
                  IN PCM_RESOURCE_LIST pResourceList,
                  IN PCM_RESOURCE_LIST pTrResourceList,
                  OUT DEVICE_CONFIG *pConfig);
int Report_Alias_IO(IN PSERIAL_DEVICE_EXTENSION extension);
PSERIAL_DEVICE_EXTENSION FindPrimaryIsaBoard(void);
NTSTATUS BoardFilterResReq(IN PDEVICE_OBJECT devobj, IN PIRP Irp);
int is_isa_cards_pending_start(void);
int is_first_isa_card_started(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\serial\mps\comtrol\rocket\driver\pnprckt.c ===
/*----------------------------------------------------------------------
 pnprckt.c - rocketport pnp specific things.
|----------------------------------------------------------------------*/
#include "precomp.h"
#define TraceStr(s)          GTrace(D_Pnp, sz_modid, s)
#define TraceStr1(s, p1)     GTrace1(D_Pnp, sz_modid, s, p1)
#define TraceStr2(s, p1, p2) GTrace2(D_Pnp, sz_modid, s, p1, p2)

#define DTraceStr(s)         DTrace(D_Pnp, sz_modid, s)
#define TraceErr(s) GTrace(D_Error, sz_modid_err, s)

static char *sz_modid = {"pnpadd"};
static char *sz_modid_err = {"Error,pnpadd"};


/*----------------------------------------------------------------------
 PrimaryIsaBoard - Search for Primary Isa boards, if found then return
  a pointer to the extension.

Return Value:
    Return ptr to extension of primary Isa board, if not found, null.
|----------------------------------------------------------------------*/
PSERIAL_DEVICE_EXTENSION FindPrimaryIsaBoard(void)
{
  PSERIAL_DEVICE_EXTENSION ext;

  ext = Driver.board_ext;
  while (ext)
  {
    if (ext->config->BusType == Isa)
    {
      // first board must have 4 hex io-defined, 4 bytes for mudback.
      // additional isa-boards alias up on original to save space.
      if ((ext->config->BaseIoSize == 0x44) &&
          (ext->config->ISABrdIndex == 0))
      {
        return ext;
      }
    }
    ext = ext->board_ext;  // next in chain
  }  // while ext
  return NULL;
}

#ifdef NT50

/*----------------------------------------------------------------------
 GetPCIRocket - find the pci-card indicated by BaseAddr and fill in
   the rest of the info in the config.
|----------------------------------------------------------------------*/
int GetPCIRocket(ULONG BaseAddr, DEVICE_CONFIG *CfCtl)
{
 PCI_COMMON_CONFIG *PCIDev;
 UCHAR i;
 NTSTATUS Status;
 int Slot;
 int NumPCI;

 NumPCI =  FindPCIBus();
 if (NumPCI == 0)
  return 1;

  PCIDev = ExAllocatePool(NonPagedPool,sizeof(PCI_COMMON_CONFIG));
  if ( PCIDev == NULL ) {
    Eprintf("No memory for PCI device.");
    return 1;
  }

  for(i=0;i<NumPCI;++i)
  {
    for(Slot = 0;Slot < 32;++Slot) /*5 bits for device 32 = 2^5*/
    {
      // get a few bytes of pci-config space(vendor-id & device-id).
      Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x4);
      if (Status == 0)
      {
        Eprintf("PCI Bus %d does not exist.",i);
      }

      if (Status > 2)        /* Found Device Is it ours? */
      {
        if (PCIDev->VendorID == PCI_VENDOR_ID)
        {
          // get 0x40 worth of pci-config space(includes irq, addr, etc.)
          Status = HalGetBusData(PCIConfiguration,i,Slot,PCIDev,0x40);

          if (BaseAddr == (PCIDev->u.type0.BaseAddresses[0]-1))
          {
            if (Driver.VerboseLog)
              Eprintf("PCI Board found, IO:%xh, Int:%d ID:%d Rev:%d.",
                               PCIDev->u.type0.BaseAddresses[0]-1,
                               PCIDev->u.type0.InterruptLine,
                               PCIDev->DeviceID,
                               PCIDev->RevisionID);

            CfCtl->BusType=PCIBus;
            CfCtl->BusNumber = i; //get from previous halquerysysin
            CfCtl->PCI_Slot = Slot;
            CfCtl->PCI_DevID = PCIDev->DeviceID;
            CfCtl->PCI_RevID = PCIDev->RevisionID;
            CfCtl->PCI_SVID = PCIDev->u.type0.SubVendorID;
            CfCtl->PCI_SID = PCIDev->u.type0.SubSystemID;
            CfCtl->BaseIoAddr =
                PCIDev->u.type0.BaseAddresses[0]-1;

            //if (PCIDev->u.type0.InterruptLine != 255)
            //{
            //RcktCfg->Irq = PCIDev->u.type0.InterruptLine;
            //}
            if (Driver.VerboseLog)
               Eprintf("Bus:%d,Slt:%x,Dev:%x,Rev:%x,Pin:%x",
                 i, Slot, PCIDev->DeviceID, PCIDev->RevisionID, PCIDev->u.type0.InterruptPin);

            ExFreePool(PCIDev);
            return 0;  // fail
          }
        } // if (PCIDev->VendorID == PCI_VENDOR_ID)
      } // if (Status > 2) 
    }
  }
  ExFreePool(PCIDev);
  return 2;  // fail
}

/*----------------------------------------------------------------------
 RkGetPnpResourceToConfig -

    This routine will get the configuration information and put
    it and the translated values into CONFIG_DATA structures.
    It first sets up with  defaults and then queries the registry
    to see if the user has overridden these defaults; if this is a legacy
    multiport card, it uses the info in PUserData instead of groping the
    registry again.

Arguments:

    Fdo - Pointer to the functional device object.
    pResourceList - Pointer to the untranslated resources requested.
    pTrResourceList - Pointer to the translated resources requested.
    pConfig - Pointer to configuration info
    PUserData - Pointer to data discovered in the registry for legacy devices.

Return Value:
    STATUS_SUCCESS if consistant configuration was found - otherwise.
    returns STATUS_SERIAL_NO_DEVICE_INITED.
|----------------------------------------------------------------------*/
NTSTATUS
RkGetPnpResourceToConfig(IN PDEVICE_OBJECT Fdo,
                  IN PCM_RESOURCE_LIST pResourceList,
                  IN PCM_RESOURCE_LIST pTrResourceList,
                  OUT DEVICE_CONFIG *pConfig)
{
   PSERIAL_DEVICE_EXTENSION        fdoExtension    = Fdo->DeviceExtension;
   PDEVICE_OBJECT pdo = fdoExtension->LowerDeviceObject;
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;

   ULONG                           count;
   ULONG                           i;
   BOOLEAN MappedFlag;

   PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL,
      pFullTrResourceDesc = NULL;

   ULONG zero = 0;


   pFullResourceDesc   = &pResourceList->List[0];
   pFullTrResourceDesc = &pTrResourceList->List[0];

   // Ok, if we have a full resource descriptor.  Let's take it apart.
   if (pFullResourceDesc) {
     PCM_PARTIAL_RESOURCE_LIST       prl;
     PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
     unsigned int Addr;

      prl    = &pFullResourceDesc->PartialResourceList;
      prd    = prl->PartialDescriptors;
      count                   = prl->Count;

      // Pull out the stuff that is in the full descriptor.
      // for rocketport could be: PCIBus, Isa, MicroChannel
      pConfig->BusType        = pFullResourceDesc->InterfaceType;
      pConfig->BusNumber      = pFullResourceDesc->BusNumber;

      if ((pConfig->BusType != PCIBus) && (pConfig->BusType != Isa))
      {
        Eprintf("Err, Unknown Bus");
        return STATUS_INSUFFICIENT_RESOURCES;
      }

      // Now run through the partial resource descriptors looking for the port,
      // interrupt, and clock rate.
      for (i = 0;     i < count;     i++, prd++)
      {
        switch (prd->Type)
        {
          case CmResourceTypePort:
            Addr = (unsigned int) prd->u.Port.Start.LowPart;
#if 0
// we don't handle aliasing here
            if (pConfig->BusType == Isa)
            {
              // only setup if not an isa-bus alias address
              if (prd->u.Port.Start.LowPart < 0x400)
                pConfig->BaseIoAddr = Addr;
            }
            else
#endif
              pConfig->BaseIoAddr = Addr;

            pConfig->BaseIoSize = prd->u.Port.Length;

            switch(pConfig->BusType)
            {
              case Isa:
                pConfig->AiopIO[0] = pConfig->BaseIoAddr;
                pConfig->AiopIO[1] = pConfig->AiopIO[0] + 0x400;
                pConfig->AiopIO[2] = pConfig->AiopIO[0] + 0x800;
                pConfig->AiopIO[3] = pConfig->AiopIO[0] + 0xc00;
                pConfig->MudbacIO = pConfig->AiopIO[0] + 0x40;
                //if (prd->u.Port.Length == 0x40)
                //pConfig->AddressSpace = prd->Flags;
                //Eprintf("Error, Res 1C");
                GTrace1(D_Pnp,sz_modid,"ISA_Addr:%xH", pConfig->BaseIoAddr);
              break;
              case PCIBus:
                pConfig->AiopIO[0] = pConfig->BaseIoAddr;
                pConfig->AiopIO[1] = pConfig->AiopIO[0] + 0x40;
                pConfig->AiopIO[2] = pConfig->AiopIO[0] + 0x80;
                pConfig->AiopIO[3] = pConfig->AiopIO[0] + 0xc0;
                GTrace1(D_Pnp,sz_modid,"PCI_Addr:%xH", pConfig->BaseIoAddr);
              break;
            }
          break;

          case CmResourceTypeInterrupt:
            pConfig->IrqLevel  = prd->u.Interrupt.Level;
            pConfig->IrqVector = prd->u.Interrupt.Vector;
            pConfig->Affinity  = prd->u.Interrupt.Affinity; 

            if (prd->Flags
               & CM_RESOURCE_INTERRUPT_LATCHED) {
               pConfig->InterruptMode  = Latched;
            } else {
               pConfig->InterruptMode  = LevelSensitive; }
            GTrace1(D_Pnp,sz_modid, "Res_Int:%xH", pConfig->IrqVector);
          break;

          case CmResourceTypeMemory:
            DTraceStr("PnP:Res,DevSpec");
          break;

          case CmResourceTypeDeviceSpecific:
            DTraceStr("PnP:Res,DevSpec");
          break;

          default:
            if (Driver.VerboseLog)
              Eprintf("PnP:Dev. Data 1G:%x",prd->Type);
          break;
        }   // switch (prd->Type)
      }   // for (i = 0;     i < count;     i++, prd++)
   }    // if (pFullResourceDesc)


   //---- Do the same for the translated resources
   if (pFullTrResourceDesc)
   {
     PCM_PARTIAL_RESOURCE_LIST       prl;
     PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
     PUCHAR pAddr;

      prl = &pFullTrResourceDesc->PartialResourceList;
      prd = prl->PartialDescriptors;
      count = prl->Count;

      for (i = 0;     i < count;     i++, prd++)
      {
        switch (prd->Type)
        {
          case CmResourceTypePort:

            pConfig->TrBaseIoAddr = (unsigned int) prd->u.Port.Start.LowPart;

            pAddr = SerialGetMappedAddress(
                      pConfig->BusType,
                      pConfig->BusNumber,
                      prd->u.Port.Start,
                      prd->u.Port.Length,
                      prd->Flags,  // port-io?
                         //1,  // port-io
                      &MappedFlag,  // do we need to unmap on cleanup?
                      0);  // don't translate
#if 0
// we do not handle the alias io here
            //!!!!!!! this is  guarenteed to work, since it is mapped
            if (pConfig->BusType == Isa)
            {
              // only setup if not an isa-bus alias address
              if (prd->u.Port.Start.LowPart < 0x400)
                pConfig->pBaseIoAddr = pAddr;
            }
            else
#endif
              pConfig->pBaseIoAddr = pAddr;

            if (pConfig->BaseIoSize == 0)
                pConfig->BaseIoSize = prd->u.Port.Length;

            switch(pConfig->BusType)
            {
              case Isa:
                pConfig->NumAiop=AIOP_CTL_SIZE;  // let init figure it out
                pConfig->pAiopIO[0] = pConfig->pBaseIoAddr;
                pConfig->pAiopIO[1] = pConfig->pAiopIO[0] + 0x400;
                pConfig->pAiopIO[2] = pConfig->pAiopIO[0] + 0x800;
                pConfig->pAiopIO[3] = pConfig->pAiopIO[0] + 0xc00;
                if (pConfig->BaseIoSize == 0x44)
                {
                  pConfig->pMudbacIO =  pConfig->pAiopIO[0] + 0x40;
                }
                GTrace1(D_Pnp,sz_modid,"ISA TrRes_Addr:%xH", prd->u.Port.Start.LowPart);
                GTrace1(D_Pnp,sz_modid,"ISA pAddr:%xH", pAddr);
                //Eprintf("ISA TrRes_Addr:%xH", prd->u.Port.Start.LowPart);
              break;
              case PCIBus:
                pConfig->pAiopIO[0] = pConfig->pBaseIoAddr;
                pConfig->pAiopIO[1] = pConfig->pAiopIO[0] + 0x40;
                pConfig->pAiopIO[2] = pConfig->pAiopIO[0] + 0x80;
                pConfig->pAiopIO[3] = pConfig->pAiopIO[0] + 0xc0;
                //if (prd->u.Port.Length == 0x40)
                //pConfig->AddressSpace = prd->Flags;
                //Eprintf("Error, Res 1G");
                GTrace1(D_Pnp,sz_modid,"PCI TrRes_Addr:%xH", prd->u.Port.Start.LowPart);
                GTrace1(D_Pnp,sz_modid,"PCI pAddr:%xH", pAddr);
              break;
            }
          break;

          case CmResourceTypeInterrupt:
            pConfig->TrIrqVector   = prd->u.Interrupt.Vector;
            pConfig->TrIrqLevel = prd->u.Interrupt.Level;
            pConfig->TrAffinity   = prd->u.Interrupt.Affinity;
            GTrace1(D_Pnp,sz_modid,"TrRes_Int:%xH", pConfig->TrIrqVector);
          break;

          case CmResourceTypeMemory:
            DTraceStr("PnP:TransRes,DevSpec");
          break;

          default:
            if (Driver.VerboseLog)
              Eprintf("PnP:Dev. Data 1H:%x",prd->Type);
          break;
        }   // switch (prd->Type)
      }   // for (i = 0;     i < count;     i++, prd++)
   }    // if (pFullTrResourceDesc)

   if (pConfig->BusType == Isa)
   {
     // figure out mudbac alias io space stuff.
     SetupRocketCfg(1);
   }  // isa

   // if PCI bus, then we need to query for device type, etc.
   if (pConfig->BusType == PCIBus)
   {
     if (GetPCIRocket(pConfig->AiopIO[0], pConfig) != 0)
     {
       Eprintf("Unknown PCI type");
     }
   }
   ConfigAIOP(pConfig);

  status = STATUS_SUCCESS;
   return status;
}

#ifdef DO_ISA_BUS_ALIAS_IO
/*-----------------------------------------------------------------------
 Report_Alias_IO -
|-------------------------------